
============================================================================
 Note su newLISP
 © copyright 2019-2020-2021 Massimo Corinaldesi aka cameyo
 MIT License
============================================================================

========

 INDICE

========

newLISP IN GENERALE
===================
  Introduzione
  Installazione
  Eseguire newLISP
  Le funzioni utente
  Argomenti di una funzione
  Trasformare una funzione distruttiva in non-distruttiva
  Trasformare una funzione da due a n argomenti
  Applicare una funzione ad ogni sottolista di una lista
  Assegnazione globale: set, setq e setf (e define)
  Assegnazione locale: let, letn e local
  Effetti collaterali (side effect) di setq e let e local
  Passaggio per valore e passaggio per riferimento
  Nil, true e lista vuota '()
  La funzione quote e il simbolo '
  Funzioni con memoria
  Generare funzioni da funzioni
  Tipi di numeri
  Punto decimale o virgola decimale
  Formattazione dell'output
  Operazioni aritmetiche elementari
  Incremento/decremento di variabili
  Uso dei numeri big integer
  Introspezione
  Conversioni di tipo: implicite ed esplicite
  Quanto sono precisi i numeri floating point?
  Quanto sono strani i numeri floating-point?
  Tipi di errore
  Propagazione degli errori
  Rappresentazione dei numeri floating point (32-bit)
  Machine epsilon
  Infinito e Not a Number (inf e NaN)
  Confronto tra numeri floating-point
  Verifica delle operazioni floating-point
  Una strana successione
  Operazioni sicure
  Quanto vale pi greco?
  Quanto vale il numero di eulero?
  Tempo di esecuzione
  Lista o vettore?
  Vettori
  Indicizzazione di stringhe, liste e vettori
  Attraversamento di liste e vettori
  Attraversamento di stringhe
  Uscita anticipata da funzioni, cicli e blocchi
  Lavorare con file di dati (file i/o)
  Salvare e caricare gli oggetti
  Struttura dati: il record
  Ambito (scope) dinamico e lessicale
  Contesti
  Uso dei moduli
    La variabile di ambiente NEWLISPDIR
    Il file di inizializzazione init.lsp
    Esempi sull'utilizzo dei moduli
  Hash-Map e dizionari
  CAR e CDR in newLISP
  Espressioni regolari
  Macro
  FOOP - Programmazione funzionale orientata agli oggetti
  XML e S-espressioni
  Analisi dei tempi di esecuzione delle funzioni
  Unificazione
  Stampare con print/println/format
  Codici ANSI ESCape
  Complessità temporale delle operazioni aritmetiche fondamentali
  Codifica Unicode e UTF-8

FUNZIONI VARIE
==============
  Tabella ASCII
  Pari o dispari
  Crono
  Cambiare di segno ad un numero
  Moltiplicazione solo con addizioni
  Divisione solo con sottrazioni
  Distanza tra due punti
  Conversione decimale <--> binario
  Conversione decimale <--> esadecimale
  Conversione decimale --> romano
  Conversione numero intero <--> lista
  Numeri casuali in un intervallo
  Calcolo proporzione
  Estrarre l'elemento n-esimo da una lista
  Verificare se una lista è palindroma
  Verificare se una stringa è palindroma
  Verificare se un numero è palindromo
  Zippare N liste
  Sostituire gli elementi di una lista con un determinato valore
  Raggruppare gli elementi di una lista
  Enumerare gli elementi di una lista
  Creare una stringa come ripetizione di un carattere/stringa
  Massimo annidamento di una lista ("s-espressione")
  Run Length Encode di una lista
  Run Length Decode di una lista
  Massimo Comun Divisore e Minimo Comune Multiplo
  Funzioni booleane
  Estrazione dei bit di un numero
  Conversione gradi decimali <--> gradi sessagesimali
  Conversione RGB <--> HSV
  Calcolo della media di n numeri
  Istogramma
  Stampare una matrice
  Retta passante per due punti
  Coordinate dei punti di una funzione
  Leggere e stampare un file di testo
  Criptazione e decriptazione di un file
  Funzioni per input utente
  Emettere un beep
  Disabilitare l'output delle espressioni
  Trasformare una lista di stringhe in lista di simboli
  Trasformare una lista di simboli in lista di stringhe
  Simboli creati dall'utente
  Il programma è in esecuzione? (progress display)
  Ispezionare una cella newLISP
  Informazioni sul sistema (sys-info)
  Valutazione di elementi di una lista
  Download tutti i file da una pagina web
  Conversione numero da cifre a lettere
  Punto a destra o sinistra di una linea
  Creazione di un poligono da una lista di punti
  Percorso minimo di una lista di punti
  Utilizzo del protocollo ftp
  Normalizzazione di una lista di numeri
  Trasformazione omografica 2D
  Numeri primi successivi e precedenti
  Giorno Giuliano (Julian day)
  Punto interno al poligono
  Prodotto cartesiano (dot-product)
  Prodotto vettoriale (cross-product)
  Insieme delle parti (powerset)
  Terne pitagoriche
  Calcolo di e con il metodo spigot
  Calcolo IVA
  Numeri casuali distinti
  Numeri casuali con distribuzione discreta predefinita
  Generatore di stringhe casuali
  Inverso di un numero
  Crivello di Atkin
  Esponenziazione modulare veloce
  random sample
  Funzioni di Mobius e di Mertens
  Quadruple pitagoriche
  Lista dei contesti attivi
  Conversione lista <--> stringa
  Funzione butlast
  Lista di tutte le partizioni di un numero
  Algoritmo di Euclide esteso
  Punti casuali in una circonferenza
  Esponenziazione (potenza) binaria
  Permutazioni circolari
  Crivello di Eratostene Lineare
  Area di un poligono semplice
  Rango di una matrice
  Operazioni tra coppie di elementi di una lista
  Polinomio interpolatore di Lagrange
  Moltiplicativo modulare inverso
  Radice n-esima di un numero
  Prodotto scalare (dot product)
  Prodotto vettoriale (cross-product)
  Angolo tra due direzioni (bearing)
  URL encoder/decoder
  Funzione gamma-ln
  select per i vettori
  Lunghezza di un numero intero
  Normalizzazione
  Papersize
  Verificare se due numeri hanno lo stesso segno
  Suddivisione di una lista
  Stampo di un numero
  Conversione vettore <--> lista
  one?
  Algoritmo Knuth-Morris-Pratt
  Heap binario (Binary Heap)
  Flood Fill
  Poligoni convessi
  Variazione percentuale
  Grafico di coppie di coordinate
  Sottosequenza crescente più lunga
  Conversione stringa <--> big-integer
  Dismutazioni (Derangements)
  Stampa lista come tabella

newLISP 99 PROBLEMI (28)
========================
  N-99-01 Estrarre l'ultimo elemento di una lista
  N-99-02 Estrarre il penultimo elemento di una lista
  N-99-03 Estrarre il k-esimo elemento di una lista
  N-99-04 Determinare il numero di elementi di una lista
  N-99-05 Invertire una lista
  N-99-06 Determinare se una lista è palindroma
  N-99-07 Appiattire una lista annidata
  N-99-08 Elimina gli elementi duplicati consecutivi di una lista
  N-99-09 Unire gli elementi duplicati consecutivi di una lista in sottoliste.
  N-99-10 Run-length encode di una lista
  N-99-11 Run-length encode di una lista (modificato)
  N-99-12 Run-length decode di una lista
  N-99-13 Run-length encode di una lista (diretto)
  N-99-14 Duplicare gli elementi di una lista
  N-99-15 Replicare per n volte gli elementi di una lista
  N-99-16 Eliminare gli elementi da una lista per ogni k
  N-99-17 Dividere una lista in due parti (la lunghezza della prima lista è un parametro)
  N-99-18 Estrarre una parte di una lista
  N-99-19 Ruotare una lista di N posti a sinistra
  N-99-20 Eliminare l'elemento k-esimo di una lista
  N-99-21 Inserire un elemento in una data posizione di una lista
  N-99-22 Creare una lista che contiene tutti i numeri interi di un intervallo
  N-99-23 Estrarre un dato numero di elementi da una lista in maniera casuale (random)
  N-99-24 Lotto: estrarre N numeri differenti da un intervallo 1..M
  N-99-25 Generare le permutazioni degli elementi di una lista
  N-99-26 Generare le combinazioni di K oggetti distinti tra gli N elementi di una lista
  N-99-27 Raggruppare gli elementi di un insieme in sottoinsiemi disgiunti
  N-99-28 Ordinare una lista in base alla lunghezza delle sottoliste

ROSETTA CODE
============
  FizzBuzz
  Numeri Primi
  Numeri di Smith
  Numeri di Hamming
  Numeri di Catalan
  Numeri di Kaprekar
  Numeri Felici
  Numeri Primoriali
  Numeri Perfetti
  Numeri Amicabili
  Numeri Perniciosi
  Numeri di Munchausen
  Sequenza di Collatz
  Permutazioni
  Combinazioni
  Regola di Horner
  Problema dello zaino (Knapsack)
  Giorno della settimana
  Triangolo di Pascal
  Codice Morse
  Problema di Babbage
  Cifrario di Cesare
  Cifrario di Vigenere
  Anagrammi
  Numeri primi cuban
  Data di Pasqua
  Equazione di Pell
  Punteggio numerico (ranking)
  Legge di Bendford
  Calendario
  Carte da gioco
  Generatore di password
  Calcolo di Pi greco
  Numeri di Lucas
  Logaritmo intero di un numero intero
  Numeri di Carmichael
  Radice quadrata intera di un numero intero
  Coppie di primi gemelli
  Numeri semiprimi
  Numeri coprimi
  Fattorizzazione di un numero intero (big integer)
  Potenza di due numeri interi (big integer)
  Numeri di Tribonacci
  Numeri Eureka
  Abitazioni multiple
  Toziente di Eulero
  Numeri Vampiri
  Il gioco del Nim
  Fibonacci sequenze di n-numeri
  Il problema dei matrimoni stabili
  Test Primi Miller-Rabin
  Il problema di Giuseppe
  ROT-13
  Sudoku
  Chess960
  Percorso del cavallo
  Teorema cinese dei resti
  Numeri attraenti
  IBAN
  Estendere il linguaggio
  Composizione di funzioni
  Calcolo di una serie
  Numeri gapful
  Valutazione di una espressione RPN
  Il gioco del 24
  Sequenza fusc
  Algoritmo Damm
  Distanza tra due punti della terra
  Algoritmo Soundex
  Trasformata Discreta di Fourier (DFT)
  Numeri di Harshad
  Numeri Humble
  Persistenza di un numero
  Numeri Taxicab
  Codice Gray
  Game of Life
  Ackermann
  Sequenza Q di Hofstadter
  Sequenza Figura-Figura di Hofstadter
  Sequenza G di Hofstadter
  Sequenza Femmina (F) Maschio (M) di Hofstadter
  Convex Hull
  Sequenza Thue-Morse
  Numeri di Bell
  Numeri auto-descrittivi
  Jort sort
  Funzioni mutuamente ricorsive
  Numeri in base negativa
  Quaternioni
  Bioritmi
  Runge-Kutta
  ISBN13
  Insieme di Cantor
  Incremento-decremento di una stringa numerica
  Funzioni di prima classe
  Inversione frase
  Conteggio popolazione
  Selezione casuale da una lista
  Rappresentazione di Zeckendorf
  Vecchie unità di misura Russe

PROJECT EULERO
==============
  Problemi 1..102

PROBLEMI VARI
=============
  BubbleSort
  QuickSort
  Simulare una matrice con un vettore
  Implementare una pila (stack) con un vettore
  Implementare una coda (queue) con un vettore
  Coda circolare (Ring Buffer)
  Fattoriale
  Coefficiente binomiale
  Lancio di dadi
  Quadrati magici
  Quadrati magici 3x3
  Mastermind numerico
  Algoritmo babilonese sqrt(x)
  Radice quadrata intera di un numero intero (2^64 bit)
  Ricerca binaria (Binary search)
  Frazione generatrice
  Il numero aureo
  Equazione di secondo grado
  Equazione di terzo grado
  Sistemi lineari (Cramer)
  Sistemi lineari (Gauss)
  Numeri Brutti
  Numeri Poligonali
  Torre di Hanoi
  Indovina il numero
  Il problema Monty Hall
  Il problema del compleanno
  Algoritmo di Karatsuba
  Formati A0, A1, A2, A3, A4, ...
  Moltiplicazione del contadino russo
  Distanza di Manhattan
  Modello di crescita di una popolazione di conigli
  The Game of Pig
  Il gioco dei salti
  Ricerca stringa in un testo (algoritmo base)
  Ricerca stringa in un testo (algoritmo Z)
  Distanza di Levenshtein
  Social Network
  Skyline
  Knuth-shuffle
  Bussola e direzioni
  Puzzle (a b c + a b c + a b c = c c c)
  Numero mancante
  Somma massima di una sottolista (Algoritmo Kadane)
  Prodotto massimo di una sottolista
  Problema delle N-Regine
  Somma delle cifre di un numero
  Coppia di punti più vicina
  Moltiplicazione tra numeri interi (stringhe)
  Numeri pandigitali
  Somma dei divisori propri di un numero
  Labirinti (calcolo percorsi)
  Moltiplicazioni di fattori
  Problemi patologici dei numeri floating point
  Numerali di Church
  Creazione e valutazione di polinomi
  Quadrato perfetto di un numero
  Potenza perfetta di un numero
  Problema della segretaria
  Numeri con tre divisori
  Congettura di Goldbach
  Problema dei travasi ed equazioni diofantee
  Primi circolari
  Radici di un polinomio (Bairstow)
  Nomi ordinati
  Distanza di numeri in una lista
  Ascensore difettoso ed equazioni diofantine
  Monete e griglie
  Teorema di Pick
  Problema dei fiammiferi di Banach
  Window sliding
  Il gioco di Wythoff
  Ordinamento per rime
  Lista circolare
  Circuito automobilistico
  Il problema delle studentesse di Kirkman
  Contadino, lupo, capra e cavoli
  Ancora la congettura di Goldbach
  Triangolo di Steinhaus
  L'ago di Buffon
  La scimmia e le noci di cocco

DOMANDE PROGRAMMATORI (CODING INTERVIEW QUESTIONS)
==================================================
  Notazione Big-O
  Contare i bit di un numero (McAfee)
  Scambiare il valore di due variabili (McAfee)
  Funzione "atoi" (McAfee)
  Somma di numeri in una lista (Google)
  Aggiornamento di una lista (Uber)
  Ricerca numero su una lista (Stripe)
  Decodifica di un messaggio (Facebook)
  Implementazione di un job-scheduler (Apple)
  Massimo raccoglitore d'acqua (LeetCode)
  Quantità d'acqua in un bacino (Facebook)
  Sposta gli zeri (Facebook)
  Intersezione di segmenti (byte-by-byte)
  Trovare l'elemento mancante (LeetCode)
  Verifica lista/sottolista (Visa)
  Controllo ordinamento lista (Visa)
  Caramelle (Visa)
  Unire due liste ordinate (Facebook)
  Salire le scale (Amazon)
  Numeri interi con segni opposti (MacAfee)
  Parità di un numero (McAfee)
  Minimo e massimo di due numeri (McAfee)
  Numero potenza di due (Google)
  Stanze e riunioni (Snapchat)
  Bilanciamento parentesi (Facebook)
  K punti più vicini - K Nearest points (LinkedIn)
  Ordinamento Colori (LeetCode)
  Unione di intervalli (Google)
  Somma dei numeri unici (Google)
  Unione di due liste ordinate (Google)
  Prodotto massimo di due numeri in una lista (Facebook)
  Distanza di Hamming tra DNA (Google)
  Controllo sequenza RNA (Google)
  Somma di due box (Amazon)
  Punti vicini a zero (Amazon)
  Trova la Funzione (Uber)
  Prodotto scalare minimo e massimo (Google)
  25 numeri (Wolfram)
  Le cento porte (Wolfram)
  Insiemi con la stessa somma (Wolfram)
  Tripartizione di un intero (Wolfram)
  Cifre stampate (Uber)
  Travasi di liquidi (Facebook)
  Cambio monete 1 (LinkedIn)
  Cambio monete 2 (LinkedIn)
  Primi con cifre uguali (Wolfram)
  Intervalli di numeri (Facebook)
  Pattern Matching (Facebook)
  Percorsi su una griglia (Uber)
  Dadi e probabilità (Visa)
  Numeri casuali e fattori (Wolfram)
  Coprimi vicini (Wolfram)
  Unione di liste (LinkedIn)
  Tripla crescente (LeetCode)
  Stringhe isomorfe (Facebook)
  Raggruppamento codici (Google)
  Caratteri differenti (Amazon)
  Triple con una data somma (Uber)
  Somma perfetta (Amazon)
  Mescolare una lista (LeetCode)
  Lista somma (geeks4geeks)
  Ordinare una lista di 0, 1 e 2 (geeks4geeks)
  Stipendio giusto (geeks4geeks)
  Volo completo (Programming Praxis)
  Benzina e stazioni (Uber)
  Aggiungere uno (Google)
  Numeri romani (LeetCode)
  Numero singolo (McAfee)
  Matrici a spirale (Google)
  Lunghezza della sottostringa più lunga senza caratteri ripetuti (Amazon)
  Rendere palindroma una stringa (Google)
  Cifre diverse (Visa)
  Rapporto minimo (Wolfram)
  Quadrato binario (McAfee)
  Fattoriale e zeri finali (Wolfram)
  Massima ripetizione di un carattere in una stringa (Google)
  Leggere libri (Uber)
  Numero mancante (Wolfram)
  Lista strettamente crescente (Visa)
  Pile di monete (LinkedIn)
  Numero più grande formato da una lista (Amazon)
  Rettagoli e quadrati in una scacchiera (Google)
  Rettangolo perfetto (Google)
  Addizione per intervalli (Range addition) (Google)
  Ordinamento Wiggle (Google)
  Generare parentesi (Amazon)
  Maggiori a destra (Visa)
  Numero che raddoppia (Wolfram)
  Calcolatore rotto (Broken calculator) (LeetCode)
  Contare le isole (islands) (Google)
  Lista con prodotto 1 (Amazon)
  Somma delle monete (Visa)
  Boomerang (Visa)
  Ricerca in una matrice 2D (Wolfram)
  Invertire le vocali (Google)
  Intervalli mancanti (LeetCode)
  Numeri strobogrammatici (LeetCode)
  Bomba sul nemico (Visa)
  Pitturare una staccionata (Amazon)
  Palindroma più lunga in una stringa (algoritmo Manacher) (Amazon)
  Permutazioni Palindrome (Uber)

LIBRERIE
========
  Operazioni con i numeri complessi
  Operazioni con le frazioni
  Operazioni con i tempi
  Operazioni con gli insiemi
  Funzioni winapi
  Operazioni con gli alberi binari
  funlisp.lsp (by Dmitry Chernyak)
  The Little newLISPER (newlisper.lsp)
  MessageBox (by Dexter Santucci)

NOTE LIBERE 1
=============
  Perchè newLISP?
  newLISP facile
  Apprendere newLISP
  Commentare righe di codice
  Stile del codice newLISP
  Considerazioni sulle parentesi del LISP
  Controllare l'output della REPL (prettyprint)
  Gestione di file e cartelle
  Funzioni come liste
  4-4 Puzzle
  Il primo Primo
  Uso delle date
  Chiusura transitiva e raggiungibilità in un grafo
  Stalin sort
  Sequenza triangolare
  Vettore/lista di funzioni
  Numeri dispari differenza di quadrati
  Zero? test
  Operazioni su elementi consecutivi di una lista
  Il loop implicito del linguaggio Scheme (named let)
  Brainfuck string encode/decode
  Creare una utilità di sistema (.exe)
  Fattoriale, Fibonacci, Primi
  Quine
  I buchi delle cifre numeriche
  Ordinare tre numeri
  Conteggio strano
  Funzioni automodificanti
  I cicli (loops)
  L'alfabeto web "Leet"
  Autogrammi
  Ambito dinamico e ambito lessicale (statico)
  Uso delle espressioni condizionali
  select e unselect (antiselect)
  Generatori 1
  Generatori 2
  Shift logico e Shift aritmetico
  fold-left e fold-right
  La divisione di Feynman
  Il linguaggio di programmazione Fractran
  La funzione map semplificata
  Generazione della documentazione con newLISPdoc
  Ancora sui numeri primi
  Un algoritmo: matrice con somme positive
  Dadi e probabilità
  Test Vettori e Liste
  Un motore per espressioni regolari
  Insiemi (set) senza reinserimento
  Funzioni con parametri nominali
  La funzione COMMAND-EVENT
  Massimo Comun Divisore (MCD)
  Indicizzazione implicita
  nil come valore e nil come risultato
  Simulare un iteratore
  "Don't underrate an iterate..."
  Simboli che iniziano con "$"
  Uso di map nelle liste annidate
  Funzioni ordinali con le liste
  gensym e macro igieniche
  La variabile anaforica $idx
  Gestione dei simboli
  Funzioni e contesti
  Buon 2020 (e 2021)
  Nascita della teoria della probabilità
  Fibonacci(104911)
  Conta e leggi
  Assegnazione parallela
  Generatore di numeri casuali
  Liste di associazione
  Funzione Z e ipotesi di Riemann
  Rotazione di stringhe, liste e numeri
  Quadrato di una lista ordinata
  Somma da due numeri
  Mescolamento perfetto
  Mergesort
  Cifre crescenti e decrescenti
  Somma di numeri
  Operatori logici
  Quick select
  Macchina di Turing

NOTE LIBERE 2
=============
  Creare una lista di frequenza
  Approssimazione razionale di un numero
  Modificare le liste annidate
  Criptare un file sorgente o un contesto
  Leggere e stampare un file
  Lisp reader
  Liste e vettori annidati
  Conversione di un numero da una base ad un'altra
  Convertire una stringa in un numero univoco
  Reduce
  Quadrati nascosti
  Push, cons e list
  Append esteso
  newLISP keywords (Parole riservate)
  Estrazione di dati da un file di testo
  File di testo windows e unix
  CRC32
  Mescolare le parole
  Parsing di stringhe
  Formattazione di elementi di una lista
  Slice mapping
  Valore minimo/massimo di una lista di numeri
  Sommare una stringa
  Numeri palindromi
  Frazioni continue
  Liste formate da coppie di elementi
  Liste quotate
  Il limite sulle stringhe
  Aggiunta di liste
  Liberare una variabile
  Massimo prodotto di due numeri
  Test di funzioni
  Sostituzioni multiple in liste o stringhe
  Cambio monete
  Funzione Harakiri
  Ciclo for con numeri float
  Nascondere la finestra DOS
  Funzioni come parametri
  Valutazione input utente
  Passare dati per riferimento
  Pagamento giornaliero
  Differenze tra let e letn
  Tecnica RAID
  Crypto XOR
  Lancio di una moneta
  Area massima
  Sole o pioggia
  Roulette russa
  Common LISP Quicksort
  Ambito dinamico e parametri delle funzioni
  Torte e tagli
  Il ciclo for
  Perché uno specchio inverte destra e sinistra invece che su e giù?
  Treni e mosche
  Gestione degli errori
  Effetto percentuali
  Teorema di Euclide (infinità dei numeri primi)
  Il programma più corto
  Frequenza cifre pi greco
  Conversione a big-integer
  Congettura 8424432925592889329288197322308900672459420460792433L
  floor, ceil e fract
  Multipli di nove
  fizzbuzz esteso
  Conversione tra liste, stringhe, caratteri e simboli
  Divisori di un numero
  Sequenza di Collatz
  Generatore
  Multiplo con tutti 1 e 0
  Risolvere i sistemi lineari
  Sudoku test
  Integrali definiti
  Fattorizzazione
  "setq" o "set"
  Memfrob
  Generatore di sequenze
  Massimo gap
  Simulazione di un cannone
  Ottimizzare il taglio di un tubo
  Generazione automatica di una hash-map

NOTE LIBERE 3
=============
  Generazione di un simbolo univoco
  Compromessi tra tempo e spazio
  Scambio di somme
  Evitare begin nella condizione if
  Frazioni continue (funzioni)
  Redditi e tasse
  Numero di eulero o di nepero
  map e filter multiplo
  Direct Acyclic Graph (DAG)
  Corde e cerchio
  Toziente
  Numeri permutati
  Numeri bouncy
  docstring
  Numeri sfenici
  Bilancia a due piatti
  Somma di 6s
  Serie ricorsiva
  Sei contro cinque
  Torneo ad eliminazione diretta
  Roulette
  Daniel Dennet Quinian Crossword
  Lista delle fattorizzazioni di un numero
  Algoritmo di Bellman-Ford
  Catene di Markov
  Contornare una matrice
  Stringa decimale infinita 12345678910111213141516...
  Numeri early-bird
  Zero elevato a zero
  Fattoriale di zero
  Somma delle potenze dei primi n numeri
  Cercaparole
  Generare frazioni proprie
  Somma di quadrati
  Somma di cubi (Taxicab)
  Somma numeri dispari (pari)
  Cavo sospeso
  Numeri automorfici
  Numeri trimorfici
  Funzioni come Stringhe
  Assegnazione multipla
  Doppio fattoriale
  0.999999999...
  Quadrati magici curiosi
  Serie infinite
  Il gioco del Pig
  Mandelbrot
  find per vettori
  Variabili libere
  Debug spartano
  Espressioni ABCDEFGHIJ
  Sequenza Juggler
  Limiti dei big-integer
  Valutazione di espressioni infisse
  Vincere 2 volte su 3
  Investimenti in comune
  Dadi intransitivi
  Il prezzo di un libro
  La barca, l'uomo e il mattone
  Creare, modificare e restituire una funzione
  Input utente multi-linea
  Distanza dell'orizzonte
  Tic-Tac-Toe
  Labirinti (Maze)
  Progettare TinyURL
  Costante di Ramanujan
  Giustificazione del testo
  Data e tempo
  Algoritmo di Gale-Shapley
  Il problema dello zaino (Knapsack)
  Validazione UTF-8
  Sudoku mania
  Radici quadrate con il metodo di Newton
  Ippodromo
  Parser di espressioni infisse-prefisse-postfisse
  Derivate Simboliche
  Media geotmetica
  Verificare l'esistenza di un simbolo
  Primi troncati
  Contenimento del quadrato

NOTE LIBERE 4
=============
  Una relazione tra π ed e
  Ricerca del numero diverso
  Ricerca del numero singolo
  Punti in un semicerchio
  Coefficiente di Sorensen-Dice
  Parole di Lyndon
  Fattorizzazione di Lyndon
  Rimozione dei multipli
  Rock Paper Scissors
  TODO application
  Quine e Narciso
  Test di primalità
  Passeggiata casuale lungo una linea
  Serie di teste e croci (valore atteso)
  Ricerca con caratteri jolly (wildcard)
  Funzioni logiche booleane
  Tavole di verità
  Numeri Brasiliani
  Probabilità condizionata
  Teorema di Bayes 1
  Teorema di Bayes 2
  Probabilità bayesiane
  Dadi
  replace multiplo
  ASCII Mandelbrot
  Yahtzee
  Gioco del 15
  Numeri rari
  Patience Sort
  Lista degli indici
  Buche sulle strada
  Storia delle variabili
  Numeri di Chowla
  Secondi -> periodo
  Partizione di una lista in due parti con somme uguali
  Numeri di Zumkeller
  Numeri di Leonardo
  Frequenza caratteri
  Frequenza parole
  Magic 8-Ball
  I Ching
  Problema ABC
  Compressione/Decompressione intervallo di valori
  Plot di funzioni
  Spirale di Archimede
  Misure angolari
  Numero di settimane
  Il gioco del 21
  Fattoriale sinistro (Left factorial)
  Numeri primi lunghi
  Numeri Tau
  Sequenza Yellowstone
  Distanza di Jaro
  Pietre e gioielli (Stones and Jewels)
  Numeri super-d
  Algoritmo di Bresenham
  Associare gli elementi di una lista ogni k
  Somma delle potenze delle cifre
  Bruchi saltellanti
  Buste matrioska
  ASCII Julia
  Dado da 7 con dado da 5
  42 in newLISP e C
  Uguaglianza approssimata
  Primi sexy
  Tavola pitagorica
  Sottostringa più piccola che contiene tutti i caratteri di una stringa
  Algoritmo Floyd-Warshall
  Triangoli casuali
  Triangoli e bastoncini
  Generazione di una lista di numeri casuali che sommano a 1
  Numeri disarium
  Numeri promici
  Formula di Erone
  Tre funzioni per calcolare la potenza di un numero intero
  Numeri Armstrong
  Evoluzione dell'algoritmo per la moltiplicazione di due numeri interi
  Indice di equilibrio
  Numero soluzioni equazione lineare a k variabili  
  Internet-point

NOTE LIBERE 5
=============
  Spostamento di zeri
  Quadratura approssimata
  Introduzione alla programmazione dinamica
  Programmazione dinamica: il gioco delle pentole d'oro (pots of gold)
  Somma delle cifre in posizioni pari e dispari
  Ordinare una lista con un'altra lista
  Test di Lucas-Lehmer
  0,1,2 con 0,1
  Angolo delle lancette di un'orologio
  Data e ora
  Corda intorno alla Terra
  Eredità
  Sequenza di Farey
  Distanza di Chebyshev
  Anti-primi
  Numeri altamente abbondanti
  Creazione dinamica di variabili
  La funzione curry
  Algoritmo evolutivo
  Nome del programma
  loop e recur macro
  Breve introduzione ai grafi
  Lanciare N volte una moneta
  Problema dei fiammiferi di Banach con N scatole
  Conflitti read-write nelle transazioni di un database
  Unico elemento diverso in una lista
  1 o 2
  Generare tutte le coppie di elementi di una lista
  Numero di partite nel Tic-Tac-Toe
  Estrazione dati da file PDF
  Media continua
  Sequenza di Kolakoski
  Da stringa generica a stringa palindroma
  Frasi e semplici regole grammaticali  
  commonLISP in newLISP
  Peso ideale e indice di massa corporea
  Sequenza di Golomb
  Acquistare e vendere azioni
  Numeri armonici
  Valore atteso e linearità dell'aspettativa
  Numero previsto di prove fino al successo
  Moltiplicazione ricorsiva
  Il gioco del Lotto
  Hash-map e contesti
  Numeri di Narayana
  Numeri di Motzkin
  Permutazioni, Disposizioni, Combinazioni
  Valore massimo di una lista ordinata
  Treni e binari
  Mastermind (by Norman)
  newLISP banner
  Puzzle di Gordon Lee
  Orologio ANSI
  Indici ordinali
  Generazione di password
  Verifica accessibilità siti web
  Miglior punto d'incontro
  Stringhe Unicode (UTF8) o ASCII
  Funzione set-nth
  Somma di interi rappresentati come liste

APPENDICI
=========
  Lista delle funzioni newLISP
  Sul linguaggio newLISP - FAQ (Lutz Mueller)
  newLISP in 21 minuti (John W. Small)
  newLISP per programmatori (Dmitry Chernyak)
  notepad++ bundle
  Visual Studio Code e newLISP
  Debugger
  newLISPdoc - Il programma per la documentazione newLISP
  Compilare i sorgenti di newLISP
  Ricorsione e ottimizzazione della chiamata di coda (Tail Call Optimization)
  F-expression - FEXPR
  newLISP - Lisp per tutti (Krzysztof Kliś)
  Ricorsione avanzata in newLISP (Krzysztof Kliś)
  Differenze tra newLISP, Scheme e Common LISP (Lutz Mueller)
  Chiusure, contesti e funzioni con stato (Lutz Mueller)
  Creazione di funzioni con ambito lessicale in newLISP (Lutz Mueller)
  "The Y of Why" in newLISP (Lutz Mueller)
  Valutazione delle espressioni, Indicizzazione Implicita, Contesti e Funtori di Default (Lutz Mueller)
  Gestione Automatica della Memoria in newLISP (Lutz Mueller)
  Benchmarking newLISP
  Frasi Famose sulla Programmazione e sul Linguaggio Lisp
  Codici ASCII

BIBLIOGRAFIA/WEB
==================

YO LIBRARY
==========
"yo.zip" Libreria per matematica ricreativa e problem solving (172 funzioni)

DOCUMENTAZIONE EXTRA
====================
  A) Introduction to newLISP (by Cormullion)
  B) Code Patterns (by Lutz Mueller)
  C) The Little newLISPER

==========================================================================

LICENSE

MIT License

Copyright (c) 2019-2020-2021 Massimo Corinaldesi aka cameyo

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

==========================================================================
Klaatu barada nikto
==========================================================================

=============================================================================

=======================

  newLISP IN GENERALE

=======================

==============
 INTRODUZIONE
==============

Questi appunti introducono all'uso del linguaggio newLISP per le elaborazioni numeriche (e anche per altre cose). È necessaria una conoscenza di base della programmazione in newLISP. Un'ottima scelta per imparare questo linguaggio è il libro "Introduction to newLISP" disponibile come WikiBooks all'indirizzo: 

http://en.wikibooks.org/wiki/Introduction_to_newLISP

Comunque per avere una panoramica sul linguaggio potete anche consultare "newLISP in 21 minuti" di John W. Small oppure "newLISP per programmatori" di Dmitry Chernyak entrambi tradotti e riportati in appendice.

Un'altra risorsa molto utile per chi inizia a programmare in newLISP è il documento "newlisp.pdf" (in italiano) di Vittorio Albertoni che si trova al seguente indirizzo:

http://www.vittal.it/wp-content/uploads/2019/10/newlisp.pdf

Maggiori informazioni sono reperibili al sito ufficiale del linguaggio:

http://www.newLISP.org/

Questo documento è in continua evoluzione e aggiornamento ed è scritto non da un programmatore professionista, ma da un principiante che studia ed utilizza newLISP per divertimento e per risolvere problemi di matematica ricreativa. Qualche volta (ultimamente sempre più spesso) uso newLISP anche nel mio lavoro quotidiano.

Per convenzione i comandi di input della REPL (Read Eval Print Loop) non contengono il prompt di newLISP ">".
L'output della REPL viene preceduto dalla stringa ";-> ".
Nel testo sono riportate le descrizioni di alcuni comandi predefiniti tradotte dal manuale di riferimento ("newLISP Reference"). Queste descrizioni sono precedute dalla stringa ">>>funzione". Ad esempio, per trovare la funzione "map", ricercare la stringa ">>>funzione MAP".

Nota: quasi tutti i paragrafi sono indipendenti, cioè hanno tutto il codice necessario per essere seguiti completamente. Per questo motivo alcue funzioni saranno ripetute nell'intero documento.

Caratteristiche del sistema utilizzato
--------------------------------------
S.O. Windows 10 Professional 64-bit
Linguaggio: newLISP 10.7.5 UTF-8
Motherboard: ASUS GTX750-PH/ASUS TUF Z390-PLUS
CPU: Intel Core i5-4460/Intel Core i7-9700
RAM: 16Gb DDR3 800mHz/32Gb DDR4 1330mHz
GPU: NVIDIA Geforce GTX 750 SDRAM: 2Gb GDDR5

Nota:
I riferimenti principali di questo documento sono:

1) "newLISP User Manual and Reference" di Lutz Mueller

2) "Code Patterns in newLISP" di Lutz Mueller

3) "Introduction to newLISP" di Cormullion

4) il forum di newLISP: http://www.newlispfanclub.alh.net/forum/

Tutti gli articoli tradotti presenti in questo documento sono sotto il copyright dei rispettivi autori. Ogni errore di traduzione è imputabile soltanto a me.
Per quanto possibile ho sempre riportato il nome degli autori delle funzioni realizzate da altri programmatori utilizzate in questo documento (trovate e prese da forum, blog, ecc.).
Ringrazio tutti quelli che vorranno suggerire consigli, critiche, correzioni e miglioramenti.


===============
 INSTALLAZIONE
===============

Scaricate il file di installazione dal sito http://www.newLISP.org/index.cgi?Downloads
Esistono versioni per Windows 32 e 64-bit, Mac OS X, Linux, FreeBSD, ecc.
Per windows 64-bit il file si chiama: newLISP-10701-win64-gs-166.exe
Questo manuale utilizza le versioni 10.7.1, 10.7.4 e 10.7.5 UTF-8 di newLISP.
Potete scaricare l'ultima versione del linguaggio dal sito http://www.newLISP.org/downloads/ dove potete trovare anche la versione UTF-8.
Per installare il programma seguire le semplici istruzioni riportate nel sito.
Terminata l'installazione abbiamo a disposizione due modalità per eseguire newLISP:
1) modalità console (REPL)
2) modalità grafica (GUI)
Utilizzeremo solo la modalità REPL (Read Evaluate Print Loop).
Questo manuale e i sorgenti in esso contenuti si trovano al sito:

https://github.com/cameyo42/notes-newLISP

Scaricate e copiate i file in una cartella a piacere (es. c:\newLISP\numeric).
Potete leggere il file PDF oppure utilizzare il file di testo. In quest'ultimo caso per seguire gli esempi potete usare l'editor notepad++ con il plugin che si trova al sito:

https://github.com/cameyo42/notepadpp-newLISP

Seguendo le istruzioni riportate in appendice potete leggere il documento e contemporaneamente eseguire il codice che ritenete opportuno. Questo è possibile anche utilizzando l'editor gratuito Visual Studio Code (disponibile per windows, mac e linux).


==================
 ESEGUIRE newLISP
==================

Possiamo eseguire il programma newLISP utilizzando l'icona che viene creata durante l'installazione, oppure possiamo aprire una finestra DOS (command prompt) ed eseguire il comando: newLISP.exe.
Se ottenete un errore, allora probabilmente la variabile di ambiente PATH non contiene la cartella dove si trova l'eseguibile del programma (es. c:\Program Files (x86)\newLISP\).
Se tutto va bene otteniamo una finestra di testo con il prompt di newLISP (>):

newLISP v.10.7.5 64-bit on Windows IPv4/6 UTF-8 libffi, options: newLISP -h

>

Per vedere in quale cartella ci troviamo digitiamo il comando "!cd":

!cd
;-> c:\newLISP\note

Oppure possiamo usare la funzione "real-path":

(real-path)
;-> "c:\newLISP\note"

Se non ci troviamo nella cartella corretta possiamo cambiare cartella con il comando "change-dir":

(change-dir "c://newLISP/note")
;-> true

Verifichiamo:

(real-path)
;-> "c:\newLISP\note"

Questa sarà la cartella di default per la REPL.

====================
 LE FUNZIONI UTENTE
====================

La struttura di base di una funzione definita dall'utente è la seguente:

(define (nome-funzione v1 v2 ... vn)
  (expression-1)
  (expression-2)
  ...
  (expression-n)
)

I parametri della funzione v1 v2 ... vn sono opzionali.
Quando la funzione viene eseguita, ogni espressione viene valutata in sequenza.
Il valore dell'ultima espressione valutata viene restituito come valore della funzione.

Se vogliamo specificare esplicitamente il valore da restituire, aggiungiamo un'espressione alla fine che valuta al valore desiderato:

(define (maggiore a b)
  (setq out (> a b))
  (setq delta (- a b))
  out
)

(maggiore 2 3)
;-> nil

Per fare in modo che una funzione restituisca più di un valore possiamo restituire una lista:

(define (maggiore a b)
  (setq out (> a b))
  (setq delta (- a b))
  (list out delta)
)

(maggiore 2 3)
;-> (nil -1)

I simboli definiti nella lista degli argomenti della funzione sono locali alla funzione, anche se esistono simboli con lo stesso nome al di fuori della funzione.


===========================
 ARGOMENTI DI UNA FUNZIONE
===========================

Il carattere virgola "," è un simbolo.
In newLISP viene usato (per convenzione e opzionale) come separatore tra:
gli argomenti di una funzione e le variabili locali di una funzione.
In questo modo si aumenta la leggibilità del programma (e non bisogna ridefinire le variabili locali).
Nella funzione test t1 e t2 sono variabili interne alla funzione, mentre out è il valore restituito dalla funzione. Questo è possibile perchè newLISP permette di chiamare una funzione con un numero di argomenti diverso da quello stabilito dalla sua definizione.
Tutti gli argomenti che non possono essere associati hanno valore nil.
I simboli degli argomenti sono locali alla funzione, anche se esistono al di fuori della funzione.

(define (test a b c , t1 t2 out)
  (setq t1 10)
  (setq t2 20)
  (setq , 42) ; La virgola "," è un simbolo
  (println ,)  ;
  (setq out (+ a b c t1 t2))
)

Esecuzione della funzione con tre parametri:

(test 1 2 3)
;-> 42
;-> 36

Esecuzione della funzione con sei parametri:

(test 1 2 3 100 200 300)
;-> 42
;-> 36

Come detto prima, in genere la virgola viene usata come separatore tra gli argomenti di una funzione e le variabili locali di una funzione. In questo modo le variabili locali sono inizializzate al valore nil e non devono essere dichiarate nuovamente all'interno della funzione (per esempio con "let" o "local"):

(define (test a b , t1 t2)
  (println t1 " " t2)
  (if t1
    (setq t1 (* a t1))
    (setq t1 a)
  )
  (if t2
    (setq t2 (* b t2))
    (setq t2 b)
  )
  (list t1 t2)
)

Proviamo la funzione con due parametri:

(test 1 2)
;-> nil nil
;-> (1 2)
(list t1 t2)
;-> (nil nil)

Proviamo la funzione con 5 parametri (la virgola è un parametro!):

(test 1 2 , 10 20)
;-> 10 20
;-> (10 40)
(list t1 t2)
;-> (nil nil)

Le funzioni di incremento e decremento "inc", "++" ,"dec" e "--" considerano il valore nil come 0:

(define (test a , b) (inc b))
(test)
;-> 1

(define (test a , b) (++ b))
(test)
;-> 1

Altre funzioni generano un errore con una variabile di valore nil:

(define (test a , b)  (setq a (+ b 1)))
(test)
;-> ERR: value expected in function + : nil
;-> called from user function (test)

Possiamo scrivere funzioni che accettano un numero variabile di argomenti:

(define (test v1)
  (println "gli argomenti sono " v1 " e " (args)))

(test)
;-> gli argomenti sono nil e ()

(test 1 2 3)
;-> gli argomenti sono 1 e (2 3)

Notiamo che v1 contiene il primo argomento passato alla funzione, ma ogni argomento rimasto inutilizzato si trova nella lista ritornata da (args).

Con args è possibile scrivere funzione che accettano un numero variabile di argomenti (e di tipo).
La seguente funzione può essere chiamata senza argomenti, con un argomento di tipo stringa o di tipo numero, o con una lista:

(define (flessibile)
  (println "gli argomenti sono " (args))
  (dolist (a (args))
  (println "-> argomento " $idx " vale " a)))

(flessibile)
;-> gli argomenti sono ()
;-> nil

(flessibile "ok")
;-> gli argomenti sono ("ok")
;-> -> argomento 0 vale ok

(flessibile 1 2 3)
;-> gli argomenti sono (1 2 3)
;-> -> argomento 0 vale 1
;-> -> argomento 1 vale 2
;-> -> argomento 2 vale 3

Nota: $idx è una variabile interna di newLISP che tiene traccia dell'indice relativo all'elemento corrente.
Tale variabile può essere letta all'interno del ciclo (es. dolist, doargs, map, ecc), ma non può essere modificata dall'utente.

Vediamo un altro esempio di funzione che accetta un numero variabile di argomenti:

(define (somma)
  (apply + (args)))

(somma 1 2 3 4 5)
;-> 15

Per accedere agli argomenti ritornati da (args) possiamo usare la funzione "doargs" al posto di "dolist":

(define (flessibile)
  (println "gli argomenti sono " (args))
  (doargs (a) ; al posto della funzione dolist
    (println "-> argomento " $idx " vale " a)))

Le variabili locali definite nell'elenco degli argomenti della funzione possono avere valori predefiniti, che verranno utilizzati solo se non si specificano i valori quando si chiama la funzione.

(define (test (a 1) b (c 2))
   (println a " " b " " c))

I simboli "a" e "c" assumono i valori 1 e 2 se non si forniscono valori nella chiamata, ma "b" avrà valore nil a meno che non venga fornito un valore per questo.

(test)
;-> 1 nil 2


=========================================================
 TRASFORMARE UNA FUNZIONE DISTRUTTIVA IN NON-DISTRUTTIVA
=========================================================

Una funzione viene detta "distruttiva" quando modifica il proprio argomento.

La maggior parte delle funzione primitive in newLISP sono non-distruttive (non hanno effetti collaterali) e lasciano intatti gli oggetti esistenti, sebbene possano crearne di nuovi. Esistono tuttavia alcune funzioni distruttive che modificano il contenuto di una variabile, una lista, un vettore o una stringa:

Funzione        Descrizione
--------        -----------
++              increments numbers in integer mode
--              decrements numbers in integer mode
bind            binds variable associations in a list
constant        sets the contents of a variable and protects it
extend          extends a list or string
dec             decrements a number referenced by a variable, list or array
define          sets the contents of a variable
define-macro    sets the contents of a variable
inc             increments a number referenced by a variable, list or array
let             declares and initializes local variables
letn            initializes local variables incrementally, like nested lets
letex           expands local variables into an expression, then evaluates
net-receive     reads into a buffer variable
pop             pops an element from a list or string
pop-assoc       removes an association from an association list
push            pushes a new element onto a list or string
read            reads into a buffer variable
receive         receives a message from a parent or child process
replace         replaces elements in a list or string
reverse         reverses a list or string
rotate          rotates the elements of a list or characters of a string
set             sets the contents of a variable
setf setq       sets the contents of a variable, list, array or string
set-ref         searches for an element in a nested list and replaces it
set-ref-all     searches for an element in a nested list and replaces all instances
sort            sorts the elements of a list or array
swap            swaps two elements inside a list or string

Alcune funzioni distruttive possono essere rese non-distruttive applicando la funzione "copy" al parametro della funzione. In questo modo viene passata alla funzione una copia dei dati, impedendo così la modifica dei dati originali.

Per esempio la funzione distruttiva "replace":

(set 'aList '(a b c d e f))
(replace 'c aList)
;-> (a b d e f)

aList ; la lista originale viene modificata
;-> (a b d e f)

Diventa non-distruttiva utilizzando la funzione "copy":

(set 'aList '(a b c d e f))
(replace 'c (copy aList))
;-> (a b d e f)

aList ; la lista originale non viene modificata
;-> (a b c d e f)


===============================================
 TRASFORMARE UNA FUNZIONE DA DUE A N ARGOMENTI
===============================================

Ecco una funzione che calcola il Massimo Comun Divisore di due numeri interi:

(define (MCD a b)
  (let (r (% b a))
       (if (= r 0) a (MCD r a))
  )
)

(MCD 21 14)
;-> 7

Non possiamo calcolare il MCD per tre o piu' numeri:

(MCD 15 5 21)
;-> 5

Risultato errato: newLISP associa solo i primi due argomenti 15 e 5 e non considera 21.

Per poter applicare alla funzione un numero arbitrario di argomenti, possiamo utilizzare una macro che applica tutti gli argomenti, chiamando la funzione originale con il corretto numero di parametri.

Modifichiamo il nome della funzione originale in "MCD-aux":

(define (MCD-aux a b)
  (let (r (% b a))
       (if (= r 0) a (MCD-aux r a))
  )
)

Adesso definiamo la macro:

(define-macro (MCD)
  (apply MCD-aux (args) 2))

(MCD 15 5 21)
;-> 1

Per capire come funziona dobbiamo analizzare la funzione "apply":

******************
>>>funzione APPLY
******************
sintassi: (apply func list [int-reduce])

Applica l'espressione "func" (primitiva, funzione utente, o lambda) agli argomenti di "list".
Gli argomenti vengono utilizzati tutti con un unica operazione.
Possiamo usare solo funzioni e operatori che hanno una valutazione normale dei loro argomenti.

(apply + '(1 2 3 4))
;-> 10
(set 'aList '(3 4 5))
;-> (3 4 5)
(apply * aList)
;-> 60
(apply sqrt '(25))
;-> 5
(apply (lambda (x y) (* x y)) '(3 4))
;-> 12

Il parametro opzionale "int-reduce" indica il numero di parametri della funzione "func".
In questo caso, "func" viene applicata ripetutamente utilizzando il risultato precedente come primo argomento, mentre gli altri argomenti vengono presi da "list".
(con ordine di associazione sinistro).

In altre parole, se la funzione "op" ha due argomenti, allora l'espressione:

(apply op '(1 2 3 4 5) 2)

equivale a:

(op (op (op (op 1 2) 3) 4) 5)

Tutte le volte che viene applicata, la funzione "op" viene chiamata con due argomenti.

Per esempio:

(apply max '(11 22 13 41 15) 2)
;-> 41

(max (max (max (max 11 22) 13) 41) 15)
;-> 41

Nel nostro caso risulta che: (MCD a b c ...) = (MCD (MCD (MCD a b) c) ...)

Gli argomenti di una funzione/macro che non vengono associati nella chiamata sono memorizzati nella lista "args".

Abbiamo definito la macro "MCD" senza alcun argomento, quindi la chiamata:
(MCD 15 5 21) non associa alcun argomento e la variabile "args" vale (15 5 21).
Sostituendo nella funzione "apply" otteniamo:

(apply MCD-aux '(15 5 21) 2)
;-> 1

(MCD-aux (MCD-aux 15 5) 21)
;-> 1

Proviamo ancora la macro:

(MCD 10 25)
;-> 5

(MCD 4 8 24)
;-> 4

Comunque se usiamo delle espressioni come parametri della macro, otteniamo un errore:

(MCD (+ 2 2) (- 10 2) 24)
;-> ERR: value expected in function % : (- 10 2)
;-> called from user function (MCD (+ 2 2) (- 10 2) 24)

Le espressioni non vengono valutate dalla nostra macro.
Infatti ci limitiamo a passare i parametri alla macro senza prima valutarli.

Per risolvere il problema possiamo utilizzare le funzioni "map" e "eval".

****************
>>>funzione MAP
****************
sintassi: (map func list-args-1 [list-args-2 ... ])

Applica la funzione "func" (primitiva, funzione utente, espressione lambda) ad ogni gruppo di argomenti specificati dalle liste "list-args-1", "list-args-2", etc.
La funzione "func" viene applicata tante volte quanti sono i gruppi di argomenti:
gli argomenti della prima chiamata sono i primi elementi di ogni lista,
gli argomenti della seconda chiamata sono i secondi elementi di ogni lista,
gli argomenti della n-esima chiamata sono gli n-esimi elementi di ogni lista,
In numero degli argomenti usati viene determinato dalla lunghezza di "list-args1" (prima lista).
Restituisce una lista di risultati.
list-args può essere un vettore, ma il risultato sarà sempre una lista.

Ad esempio:

(map max '(3 2 1) '(5 8 7) '(1 9 8))
;-> (5 9 8)

Il risultato viene costruito con le seguenti chiamate:

(max 3 5 1) ; prima chiamata
;-> 5
(max 2 8 9) ; seconda chiamata
;-> 9
(max 1 7 8) ; terza chiamata
;-> 8

Altri esempi:

(map pow '(1 2 3))
;-> (1 4 9)

(map + '(1 2 3) '(50 60 70))
;-> (51 62 73)

(map if '(true nil true nil true) '(1 2 3 4 5) '(6 7 8 9 10))
;-> '(1 7 3 9 5)

(map (fn (x y) (* x y)) '(3 4) '(20 10))
;-> (60 40)

map può utilizzare anche l'indice della lista interna $idx.

(map (fn (x) (list $idx x)) '(a b c))
;-> ((0 a) (1 b) (2 c))

Il numero di argomenti utilizzati è determinato dalla lunghezza della prima lista di argomenti.

*****************
>>>funzione EVAL
*****************
sintassi: (eval exp)

"eval" calcola il risultato della valutazione dell'espressione "exp".
La valutazione viene effettuata nel contesto corrente delle variabili.

Esempi:

(set 'expr '(+ 3 4))
;-> (+ 3 4)
(eval expr)
;-> 7
(eval (list + 3 4))
;-> 7
(eval ''x)
;-> x
(set 'y 123)
(set 'x 'y)
;-> y
(eval x)
;-> 123

La valutazione delle variabili avviene nel contesto corrente:

(set 'x 3 'y 4)
(eval '(+ x y))
;-> 7

Vediamo "eval" in un contesto locale:

(let ( (x 33) (y 44) )
    (eval '(+ x y)))
;-> 77

Ancora "eval" nel vecchio contesto dopo essere usciti dal contesto locale:

(eval '(+ x y))
;-> 7

Ritornando al nostro problema, possiamo valutare tutti gli argomenti della macro "MCD" con la funzione "eval", utilizzando la funzione "map".

(define-macro (MCD)
  (apply MCD-aux (map eval (args)) 2))

Proviamo la nuova macro:

(MCD (+ 2 2) (- 10 2) 24)
;-> 4

Funziona !!!

Adesso vediamo la funzione "curry":

******************
>>>funzione CURRY
******************
sintassi: (curry func exp)

Trasforma "func" da una funzione f(x, y) che prende due argomenti, in una funzione fx(y) che prende un singolo argomento. "curry" funziona come una macro, nel senso che non valuta i suoi argomenti. Questi ultimi vengono valutati durante l'applicazione della funzione "func".

(set 'f (curry + 10))
;-> (lambda ($x) (+ 10 $x))

(f 7)
;-> 17

(filter (curry match '(a *)) '((a 10) (b 5) (a 3) (c 8) (a 9)))
;-> ((a 10) (a 3) (a 9))

(clean (curry match '(a *)) '((a 10) (b 5) (a 3) (c 8) (a 9)))
;-> ((b 5) (c 8))

(map (curry list 'x) (sequence 1 5))
;-> ((x 1) (x 2) (x 3) (x 4) (x 5))

"curry" può essere usato con tutte le funzioni che prendono due argomenti.

Vediamo come usare "curry" insieme alla funzione "map".
Possiamo utilizzare "map" con una funzione che riceve più di un argomento (ad esempio la funzione "pow") in questo modo:

(map pow '(2 1) '(3 4))
;-> (8 1)

dove: 8 = 2^3, 1 = 1^4

Ma se la lista degli argomenti si trova all'interno di un'altra lista, allora otteniamo un errore:

(setq lst '((2 1) (3 4)))
(map pow lst)
;-> ERR: value expected in function pow : '(2 1)

Possiamo utilizzare la funzione "curry" per risolvere questo problema:

(map (curry apply pow) lst)
;-> (2 81)

dove: 2 = 2^1, 81 = 3^4

Ok, non è il risultato che volevamo, ma se trasponiamo la lista degli argomenti:

(transpose lst)
;-> ((2 3) (1 4))

Quindi possiamo scrivere:

(map (curry apply pow) (transpose lst))
;-> (8 1)

Che è equivalente a:

(map (lambda(x) (apply pow x)) (transpose lst))
;-> (8 1)

Possiamo anche utilizzare una funzione definita dall'utente:

(define (mypow lst)
  (if (null? lst) '()
      (cons (pow (nth '(0 0) lst) (nth '(0 1) lst)) (mypow (rest lst)))
  )
)

(setq lst '((2 1) (3 4)))
(mypow (transpose lst))
;-> (8 1)

Un altro esempio con la funzione "max":

(map max '(3 5) '(2 7))
;-> (3 7)

(map (curry apply max) '((3 5) (2 7)))
;-> (5 7)

(map (curry apply max) (transpose '((3 5) (2 7))))
;-> (3 7)


========================================================
 APPLICARE UNA FUNZIONE AD OGNI SOTTOLISTA DI UNA LISTA
========================================================

Supponiamo di voler sommare gli elementi di ogni sottolista della seguente lista:

(setq lst '((1 3) (3 4) (5 6)))

Il risultato dovrebbe essere: (4 7 11).

Primo metodo
Applichiamo la funzione map con una funzione lambda che somma gli elementi della sottolista:

(map (lambda (x) (apply + x)) lst)
;-> (4 7 11)

Secondo metodo
Utilizziamo la funzione "curry" per rimpiazzare la funzione lambda:

(map (curry apply +) lst)
;-> (4 7 11)


===================================================
 ASSEGNAZIONE GLOBALE: SET, SETQ e SETF (e DEFINE)
===================================================

****************
>>>funzione SET
****************
sintassi: (set sym-1 exp-1 [sym-2 exp-2 ... ])

Valuta entrambi gli argomenti e poi assegna il risultato di exp al simbolo trovato in sym.
La funzione "set" restituisce il risultato dell'assegnazione.
Il vecchio contenuto del simbolo viene cancellato.
Viene visualizzato un messaggio di errore quando si tenta di modificare il contenuto dei simboli nil, true o un simbolo del contesto.
"set" può effettuare assegnazioni multiple sulle coppie di argomenti.

*****************
>>>funzione SETQ
*****************
sintassi: (setq place-1 exp-1 [place-2 exp-2 ... ])

*****************
>>>funzione SETF
*****************
sintassi: (setf place-1 exp-1 [place-2 exp-2 ... ])

In newLISP "setq" e "setf" funzionano allo stesso modo:
impostano il contenuto di un simbolo, una lista, un array o una stringa o di una loro parte.
Il primo argomento è un simbolo o un riferimento ad una parte di un simbolo.
Come "set", anche "setq" e "setf" possono assumere più coppie di argomenti.
Per convenzione si utilizza:
1) "setq" quando si imposta un simbolo
2) "setf" quando si imposta una parte di una lista o di un array
Sia "setq" che "setf" puntano internamente alla stessa funzione.

Esempi:

Il simbolo "a" è quotato poichè altrimenti verrebbe valutato.
("set" valuta anche il suo primo argomento)

(set 'a '(1 2 3))
;-> (1 2 3)

Non serve quotare "a" ("setq" non valuta il primo argomento):

(setq a '(1 2 3))
;-> (1 2 3)

Assegnazione multipla:

(setq a 1 b 2 c 3)
;-> 3
a b c
;-> 1
;-> 2
;-> 3

Usando la funzione "nth" oppure l'indicizzazione implicita (gli indici iniziano da zero).

(setq L '(a b (c d) e f g))

(setf (L 1) 'C)
L
;-> (a C (c d) e f g)

(setf (nth 1 L) 'B)
L
;-> (a B (c d) e f g)

(setf (L 2 0) 'C)
L
;-> (a B (C d) e f g)

Assegnazione e modifica di stringhe:

(set 's "NewISP")
;-> "NewISP"

(setf (s 0) "n")
;-> "n"

(setf (s 3) "LI")
;-> "LI"

Spesso il nuovo valore dipende dal vecchio valore. Con "setf" e "setq" possiamo usare la variabile interna di sistema "$it" per riferirsi al vecchio valore all'interno dell'espressione di assegnazione:

(setq L '((apples 4) (oranges 1)))
(setf (L 1 1) (+ $it 1))
L
;-> ((apples 4) (oranges 2))

(set 's "newLISP")
(setf (s 0) (lower-case $it))
s
;->"newLISP"

Vediamo adesso la funzione "define":

*******************
>>>funzione DEFINE
*******************
sintassi: (define sym-name exp)

In genere "define" viene utilizzata per definire una funzione.
In questo caso si comporta come la funzione "set", con la differenza che il primo argomento non viene valutato e quindi non deve essere quotato.
Se proviamo a ridefinire un simbolo protetto otteniamo un messaggio di errore.

Esempi:

(define x 123)
;-> 123
è uguale a:
(set 'x 123)
;-> 123

(define area (lambda (x y) (* x y)))
è uguale a:

(set 'area (lambda (x y) (* x y)))
è uguale a:

(define (area x y) (* x y))

Nota: l'assegnazione setq o setf è più veloce di set.

;; setq
(time (dotimes (i 100000) (setq a 10) (setq b 10)) 1000)
;-> 6145.725

;; set
(time (dotimes (i 100000) (set 'a 10) (set 'b 10)) 1000)
;-> 6911.922

;; setf
(time (dotimes (i 100000) (setf a 10) (setf b 10)) 1000)
;-> 6113.744

(time (setq a 10) 100000000)
;-> 2547.251
(time (set 'a 10) 100000000)
;-> 2859.788
(time (setf a 10) 100000000)
;-> 2594.358


========================================
 ASSEGNAZIONE LOCALE: LET, LETN e LOCAL
========================================

Usando le funzioni "let" e "letn", possiamo definire variabili (simboli) che esistono solo all'interno di una lista. Non sono valide al di fuori della lista e perdono il loro valore una volta che la lista ha finito di essere valutata.
Il primo elemento di una lista "let" è un sottolista contenente variabili (che non devono essere quotate) ed espressioni che servono ad inizializzare ogni variabile.
Gli elementi rimanenti della lista sono espressioni che possono accedere a tali variabili.
Si consiglia di allineare le coppie variabile/valore iniziale:

(let
  (x (* 2 2)
   y (* 3 3)
   z (* 4 4)
  ) ; fine dell'inizializzazione
  (println "somma = " (+ x y z))
) ; fine della lista
;-> somma = 29

Se vogliamo utilizzare una variabile locale anche nella parte successiva dell'inizializzazione, dobbiamo usare la funzione "letn" al posto di "let":

(letn
  (x 2 ; definiamo x
   y (pow x 3) ; poi usiamo x nell'inizializzazione
   z (pow x 4))
  (println "somma = " (+ x y z))
)
;-> somma = 26

Al posto di "let" e "letn" possiamo usare la funzione "local". In questo caso non dobbiamo fornire alcun valore, poichè vengono impostati tutti a nil da newLISP:

(define (test)
  (local (a b c)
    (println a " " b " " c)
    (set 'a 1 'b 2 'c 3)
    (println a " " b " " c)))

(test)

;-> nil nil nil
;-> 1 2 3

(define a 10)
(define b 20)
(define c 30)

(define (test a b c)
    (println a " " b " " c)
    (set 'a 1 'b 2 'c 3)
    (println a " " b " " c))

(test 100 200 300)
;-> 100 200 300
;-> 1 2 3

In genere l'uso di "local" è più comodo e rende il programma più leggibile.


========================================================
 EFFETTI COLLATERALI (side effect) DI SETQ, LET e LOCAL
========================================================

Un comportamento subdolo...

Definiamo la funzione "add2":

(define (add2 x)
  (setq i 2)
  (+ i x)
)

Proviamo:

(add2 5)
;-> 7

Definiamo una funzione "formula":

(define (formula x)
    (setq i 1)
    (+ i (add2 x))
    ;(println i { } out)
)

Proviamo:

(formula 3)
;-> 6

Riscriviamo la funzione "formula" spostando la variabile "i":

(define (formula x)
    (setq i 1)
    (+ (add2 x) i) ;scambiamo di posto alla variabile i
)

Proviamo:

(formula 3)
;-> 7 ; Non è il risultato voluto

Che cosa è successo?

Nell'espressione (setq out (+ 5 (add2 x) i)) la variabile "i" vale 2, perchè questo è il valore che ha dopo l'esecuzione della funzione "add2"
(vedi l'espressione (setq i 2))

Questo può essere evitato se utilizziamo "let" al post di "setq".
Le variabili dichiarate con "let" esistono solo all'interno del blocco e vengono eliminate quando termina il blocco stesso.

Riscriviamo la funzione "add2":

(define (add2 x)
  (let ((i 2))
        (+ i x)
  ) ;fine del blocco let: la variabile "i" del blocco non esiste
)

Proviamo:

(add2 5)
;-> 7

Riscriviamo la funzione "formula":

(define (formula x)
    (let ((i 1))
         (+ i (add2 x)))
)

Proviamo:

(formula 3)
;-> 6

Proviamo con la "i" scambiata di posto:

(define (formula x)
    (let ((i 1))
         (+ (add2 x) i))
)

(formula 3)
;-> 6

Adesso tutto funziona correttamente.

Occore fare attenzione anche nel caso di variabili globali, per esempio:

(setq tot 0)

(define (somma x y)
  (setq tot (+ x y))
)

(somma 2 3)
;-> 5

La funzione si comporta correttamente, ma la variabile "tot" adesso vale:

tot
;-> 5

Riscriviamo la funzione usando "let":

(define (somma x y)
  (let ((tot (+ x y)))
       tot
  )
)

Proviamo:

(setq tot 0)

(somma 2 3)
;-> 5

tot
;-> 0

Il valore globale della variabile "tot" non è cambiato.

Dentro il blocco "let" possiamo utilizzare "setq" senza problemi.

Definiamo una variabile globale:

(setq y 10)

Definiamo una funzione di test:

(define (test x)
  (let ((y 0))
    (setq y 2)
    (* x y)
  )
)

Proviamo:

(test 3)
;-> 6

La variabile globale non è stata modificata:
y
;-> 10

Per capire meglio modifichiamo la funzione di test:

(define (test x)
  (let ((y 0))
    (setq y 2)
    (println "Risultato funzione = " (* x y))
    (println "y let (locale) = " y)
  )
  (println "y setq (globale) = " y)
)

Riproviamo:

(setq y 10)

(test 3)
;-> Risultato funzione = 6
;-> y let (locale) = 2
;-> y setq (globale) = 10
;-> 10

Vediamo un altro comportamento delle variabili con la funzione "local":

(define (f)
  (local (fa fb)
    (println "da F prima di G")
    (setq fa 1)
    (setq fb 2)
    (println {fa = } fa { @ } {fb = } fb)
    (g)
    (println "da F dopo G")
    (println {fa = } fa { @ } {fb = } fb)
  )
)

(define (g)
  (local (fa)
    (println "da G")
    (println {fa = } fa { @ } {fb = } fb)
    (setq fa 22)
    (setq fb 33)
    (println {fa = } fa { @ } {fb = } fb)
  )
)

(f)
;-> da F prima di G
;-> fa = 1 @ fb = 2
;-> da G
;-> fa = nil @ fb = 2
;-> fa = 22 @ fb = 33
;-> da F dopo G
;-> fa = 1 @ fb = 33

La variabile "fa" viene ridefinita nella funzione "g" quindi il suo valore non cambia per la funzione "f" (in altre parole esistono due variabili locali "fa", una interna alla funzione "f" e l'altra interna alla funzione "g").
La variabile "fb" non viene ridefinita in "g" quindi il suo valore cambia anche all'interno della funzione "f" (in altre parole esiste una sola variabile "fb" visibile da entrambe le funzioni "f" e "g").

Un ultimo esempio:

(setq a 1 b 2)

(let (c (+ a b)) (println c))
;-> 3

(let (a 4 b 5 c (+ a b)) (println a { } b { } c))
;-> 4 5 3

c = 3 perchè nell'espressione (+ a b), a = 1 e b = 2.

Usiamo letn per risolvere il problema:

(letn (a 4 b 5 c (+ a b)) (println a { } b { } c))
;-> 4 5 9

Adesso c = 9 perchè dentro l'espressione letn a = 4 e b = 5.


==================================================
 PASSAGGIO PER VALORE E PASSAGGIO PER RIFERIMENTO
==================================================
 Pass by Value e Pass by Reference

Per default, il linguaggio newLISP passa i parametri per valore (Pass by Value), cioè passa alle funzioni una copia dei valori dei parametri.
Se vogliamo utilizzare il passaggio per riferimento (Pass by Reference) bisogna usare i contesti (CONTEXT).

Cosa significa questo?

Supponiamo di avere una lista m = (0 1 2 3) e di voler modificare il valore di alcuni elementi.
Scriviamo una funzione che prende tre parametri: una lista, un indice e un valore.

(define (aggiorna lst idx el) (setf (lst idx) el) (println lst))

Proviamo:

(setq m '(0 1 2 3))
;-> (0 1 2 3)
(aggiorna m 0 2)
;-> (2 1 2 3)

Sembra tutto a posto, ma se stampiamo la lista "m" abbiamo una sorpresa:

m
;-> (0 1 2 3)

La lista "m" non è cambiata !!!

In newLISP, alle funzioni viene sempre passata una copia dei parametri, quindi la lista "m" non può essere modificata perchè la funzione "aggiorna" lavora su una copia della lista "m".

Quindi se vogliamo aggiornare la lista "m" dobbiamo modificare la funzione in modo che ritorni la lista aggiornata e poi assegnare questa lista alla lista "m".

(define (demo lst el) (setf (lst 0) el) lst)

Assegniamo a "m" la lista modificata restituita dalla funzione "aggiorna".

(setq m (demo m 2))
;-> (2 1 2 3)
m
;-> (2 1 2 3)

Nota:
Quando abbiamo delle liste con molti elementi, il passaggio per valore rallenta l'esecuzione del programma perchè ad ogni chiamata di funzione deve sempre essere fatta una copia degli argomenti.

Per utilizzare il passaggio per riferimento dovremmo vedere come funzionano i contesti (CONTEXT), comunque, dal punto di vista pratico, questa è la tecnica pe usare il "passaggio per riferimento":

(setq m:m '(0 1 2 3 4 5 6 7))

(define (aggiorna lst idx el) (setf (lst idx) el))

Proviamo:

(aggiorna m 0 2)
;-> 2

m:m
(2 1 2 3 4 5 6 7))

In questo esempio, la lista viene incapsulata in un contesto denominato "m" che contiene una variabile con lo stesso nome.

Ogni volta che una funzione utilizza un parametro di tipo stringa o lista, è possibile passare un contesto, che verrà quindi interpretato come il funtore predefinito di quel contesto.


=============================
 NIL, TRUE e LISTA VUOTA '()
=============================

In newLISP il simbolo "nil" e la lista vuota non sono esattamente la stessa cosa, anche se in alcuni casi sono intercambiabili.

Facciamo alcuni test:

Ovviamente, due liste vuote sono uguali:

(= '() '())
;-> true

ma la seguente espressione genera un errore:

(= () '())
;-> ERR: invalid function in function = : ()

Invece per il valore "nil", abbiamo:

(= nil nil)
; true

ma la seguente espressione non genera un errore perchè "nil" valuta su se stesso:

(= nil 'nil)
; true

Come abbiamo detto all'inizio, la lista vuota '() e "nil" sono diversi:

(= '() 'nil)
;-> nil

In newLISP il valore falso non è rappresentato dal simbolo "false" (che non esiste), ma dal simbolo "nil".

Il simbolo "false" non esiste:

false
;-> nil

(= 'false false)
;-> nil

(= 'false nil)
;-> nil

In newLISP il valore vero è rappresentato dal simbolo "true" e da tutti i simboli che non valgono "nil".
Il simbolo "true" valuta su se stesso:

(= true 'true)
; true

Anche i numeri valutano su se stessi:

(= '0 0)
;-> true

(= '3.14 3.14)
;-> true

Vediamo come un valore venga considerato vero in quanto non "nil":

(if 0 'vero 'falso)
;-> vero

(if 1 'vero 'falso)
;-> vero

Comunque, anche se non sono uguali, la lista vuota '() e "nil" sono considerati come valore falso:

(= '() nil)
;-> nil

(if nil 'vero 'falso)
;-> falso

(if '() 'vero 'falso)
;-> falso

Qualunque altro valore viene considerato vero:

(if '(1 2) 'vero 'falso)
;-> vero

Quindi in newLISP tutto viene considerato vero (true) tranne la lista vuota '() e "nil" che vengono considerati falso (nil). Comunque la lista vuota '() e "nil" sono diversi se confrontati tra loro.

Quindi, "nil" e "true" rappresentano sia simboli che i valori booleani falso (nil) e vero (true). A seconda del loro contesto, "nil" e "true" sono trattati in modo diverso. I seguenti esempi usano "nil", ma possono essere applicati a "true" semplicemente invertendo la logica.

La valutazione di "nil" produce falso (in senso booleano) e viene trattato come tale all'interno di espressioni di controllo del flusso come "if", "unless", "while", "until", e "not". Allo stesso modo, la valutazione di "true" produce vero (cioè true).

(= nil 'nil)
;-> true

(= true 'true)
;-> true

(set 'lst '(nil nil nil))
;-> (nil nil nil)

(map symbol? lst)
;-> (true true true)

Nota: in newLISP, "nil" e la lista vuota () non sono uguali a quelli di altri Lisp. Solo nelle espressioni condizionali vengono trattati come falsi booleani, come in "and", "or", "if", "while", "unless", "until", e "cond".
Possiamo scrivere una funzione per verificare il valore booleano (true o nil) di un simbolo/variabile:

(define (bool-value x) (if x true nil))

(bool-value '())
;-> nil

In questo caso, la funzione utilizza "if", quindi la lista vuota '() viene considerata nil, ma abbiamo visto che la lista vuota non è uguale a nil:

(nil? '())
;-> nil

Il valore true si comporta normalmente:

NaN vale true:
(bool-value (div 0 0))
;-> true

Infinito vale true:
(bool-value (div 1 0))
;-> true

Adesso vediamo quali sono i valori che sono considerati true:

Con i valori booleani:
(true? true)
;-> true
(true? nil)
;-> nil

Con i numeri:
(true? 1)
;-> true
(true? 0)
;-> true
(true? -1)
;-> true

; infinito
(true? (div 1 0))
;-> true

; Not A Number
(true? (div 0 0))
;-> true

Con le liste:
(true? '(1 a))
;-> true
; la lista vuota è nil
(true? '())
;-> nil

Con le stringhe:
(true? "nome")
;-> true
; la stringa vuota è true
(true? "")
;-> true

Associamo al simbolo '() il valore true:
(setq () true)
;-> ERR: invalid function in function setf : ()
(set '() true)
;-> ERR: invalid function in function setf : ()

Assegnazione corretta:
(setq '() true)
;-> true
(true? '())
;-> nil
(true? (quote '()))
;-> true

La valutazione di (cons 'x' ()) produce (x), ma (cons 'x nil) produce (x nil) perché "nil" viene trattato come valore booleano quando viene valutato, non come una lista vuota. In newLISP l'applicazione di "cons" a due atomi non produce una coppia puntata, ma piuttosto una lista di due elementi. Il predicato "atom?" è vero per "nil", ma falso per la lista vuota. La lista vuota in newLISP è solo una lista vuota e non è uguale a nil.

Una lista in newLISP è una cella newLISP di tipo lista. Agisce come un contenitore per la lista (linked list) che collega gli elementi che formano il contenuto della lista. Non c'è una coppia puntata in newLISP perché la parte "cdr" (coda) di una cella Lisp punta sempre a un'altra cella Lisp e mai a un tipo di dati di base, come un numero o un simbolo. Solo la parte "car" (testa) può contenere un tipo di dati di base. Le prime implementazioni di Lisp utilizzavano "car" e "cdr" per i nomi head (testa) e tail (coda).



==================================
 LA FUNZIONE QUOTE E IL SIMBOLO '
==================================

Il carattere quote "'" serve per impedire la valutazione dell'espressione che lo segue.
Questa espressione quotata viene quindi valutata letteralmente.
Ricordiamoci che ogni espressione deve produrre un risultato. Infatti non possiamo valutare la lista vuota ():

()
;-> ERR: invalid function : ()

Quotando la lista vuota newLISP restituisce il valore non valutato, cioè la lista vuota:

'()
;-> ()

In newLISP tutto viene valutato come vero [true] tranne la lista vuota "()" e "nil" che vengono valutati come falso [nil]. Comunque la lista vuota "()" e "nil" sono diversi:

(= '() nil)
;-> nil

Il linguaggio newLISp ha hanche la funzione "quote" che è equivalente al carattere "'". Comunque possiamo notare il seguente problema:

(= '(quote 1) ''1)
;-> nil

oppure

(first (quote (quote 1)))
;-> quote

(first ''1)
;-> ERR: array, list or string expected in function first : ''1

C'è una sottile differenza tra i due. Il simbolo ' viene risolto durante la traduzione del codice sorgente, quando la cella quotata viene protetta dalla valutazione con un involucro. La funzione "quote" fa la stessa cosa, ma durante la valutazione dell'espressione. Per la maggior parte degli scopi la funzione e il simbolo si comportano in modo equivalente.
In questo modo la funzione "quote" è più simile alla funzione quote del LISP originale. L'uso del simbolo ' è un'ottimizzazione effettuata durante la traduzione del codice sorgente,Se vuoi saperne di più sulla traduzione e la valutazione del codice, confronta le funzioni "read-expr" e "eval-string".
Nel codice sorgente di newLISP la funzione "quote" viene trasformata in un simbolo (SYMBOL) e il simbolo ' viene trasformato come QUOTE.

Vediamo un altro esempio:

(setq x '(1 '(2 3 4)))
;-> (1 '(2 3 4))

(x 0)
;-> 1
(x 1)
;-> '(2 3 4)

Se vogliamo estrarre il primo elemento con "first" otteniamo un errore:
(first (x 1))
;-> ERR: array, list or string expected in function first : (x 1)

Invece applicare "first" direttamente alla lista funziona:
(first '(2 3 4))
;-> 2

(setq a (x 1))
;-> '(2 3 4)
(first a)
;-> ERR: array, list or string expected in function first : a

(setq z (quote (1 (quote (2 3 4)))))
;-> (1 (quote (2 3 4)))

(z 1)
;-> (quote (2 3 4))
(first (z 1))
;-> quote

Utilizzando "quote" newLISP si comporta come Scheme o Common LISP:

In newLISP:

(setq x '(1 '(2 3 4)))
;-> (1 '(2 3 4))
(first (first (rest x)))
;-> ERR: array, list or string expected : (first (rest x))

In Scheme:

1> (define x '(1 '(2 3 4)))
2> (car (car (cdr x)))
;-> quote

In Common LISP:

[1]> (setq x '(1 '(2 3 4)))
;-> (1 '(2 3 4))
[2]> (car (car (cdr x)))
;-> QUOTE

Il simbolo ' valuta nel proprio tipo di dati quote-type (cioè un sottotipo di lista) in newLISP in modo simile al lambda-type di lista (un altro sottotipo di lista).
Il simbolo ' e la funzione "quote" sono equivalenti quando valutati:

(= 'x (quote x))
;-> true

(quote? (quote 'x))
;-> true

ma qui l'espressione (quote x) non è valutata:

(quote? '(quote x))
;-> nil

(list? '(quote x))
;-> true

Proprio come lambda, il simbolo ' viene risolto durante la traduzione/parsing del codice sorgente.
Questo è il motivo per cui abbiamo i predicati "quote?" e "lambda?".
Il più delle volte la differenza non è riconoscibile (come nel mio esempio), ma nel primo esempio questa differenza viene evidenziata.
Sia il simbolo ' che la funzione "quote" servono hanno lo stesso scopo di proteggere un'espressione dalla valutazione, ma l'elaborazione del simbolo ' è molto più veloce perché viene tradotto durante il tempo di caricamento del sorgente.
Comunque abbiamo ancora bisogno della funzione "quote" per quotare durante il runtime.
Per questo motivo, quando si desidera riscrivere la definizione originale di McCarthy di LISP in newLISP dovresti usare la funzione (quote ...) invece del simbolo ':

(first (first (rest (quote (1 (quote 2 3 4)))))) => quote

ottenendo lo stesso risultato come in Scheme e in Common LISP.


======================
 FUNZIONI CON MEMORIA
======================

È possibile scrivere una funzione con memoria, cioè una funzione che produce un risultato diverso ogni volta che viene chiamata ricordando uno stato interno. Per fare questo occorre utilizzare una chiusura (closure). In altre parole scriviamo una funzione generatore.
In newLISP creiamo variabili di stato locali usando un spazio dei nomi chiamato "context":

; generatore newLISP
(define (gen:gen)
  (setq gen:sum
    (if gen:sum (inc gen:sum) 1)))

Questo potrebbe essere scritto più brevemente, perché "inc" considera nil come zero:

(define (gen:gen)
  (inc gen:sum))

(gen)
;-> 1
(gen)
;-> 2

Quando si scrive gen:gen, viene creato un context chiamato gen. gen è uno spazio di nomi (namespace) lessicale contenente i propri simboli usati come variabili e come funzioni. In questo caso il nome-spazio gen contiene due simboli: "gen" (funzione) e "sum" (variabile).
Il primo simbolo di un contesto ha lo stesso nome del contesto in cui è contenuto e viene chiamato "funtore" di default del contesto. In questo caso il contesto si chiama "gen" e quindi il funtore si chiama "gen". Quando si utilizza un nome di contesto al posto di un nome di funzione, newLISP assume il funtore predefinito. Quindi possiamo chiamare la nostra funzione generatore usando (gen). Non è necessario chiamare la funzione usando (gen:gen), (gen) verrà impostato automaticamente su (gen:gen).


===============================
 GENERARE FUNZIONI DA FUNZIONI
===============================

In newLISP possiamo scrivere programmi che generano programmi oppure funzioni che generano funzioni.
In newLISP codice e dati sono allo stesso livello, cioè le funzioni e le variabili sono nello stesso contesto.
Ad esempio possiamo assegnare la funzione "println" alla variabile "stampa":

(setq stampa println)
;-> print@40AC99

Adesso usiamo la funzione "stampa" come la funzione "println":

(stampa "CODICE = DATI")
;-> CODICE = DATI

Quando definiamo una funzione utente, newLISP la converte in una funzione lambda:

(define (doppio x) (add x x))
;-> (lambda (x) (add x x))

Anche le funzioni lambda possono essere associate alle variabili:

(setq dd (lambda (x) (add x x)))
;-> (lambda (x) (add x x))

(dd 5)
;-> 10

Le funzioni lambda hanno la seguente forma:
(lambda (<arg-1 arg-2 ... arg-n) (expr-1 expr-2 ... expr-n))

Possiamo crearle dinamicamente con una funzione:

(define (crea-lambda operazione parametro)
    (append (fn (x)) (list (list operazione parametro 'x))))

La funzione "crea-lambda" genera funzioni lambda che hanno un operatore (add) con un parametro (2) e un argomento (x):

(crea-lambda 'add 2)
;-> (lambda (x) (add 2 x))

La funzione "map" permette l'uso delle funzioni lambda:

(map (lambda (x) (add 2 x)) '(1 2 3 4 5))
;-> (3 4 5 6 7)

Quindi possiamo fare lo stesso con la nostra funzione "crea-lambda"

(map (crea-lambda add 2) '(1 2 3 4 5))
;-> (3 4 5 6 7)

; Ma anche:

(map (crea-lambda mul 3) '(1 2 3 4 5))
;-> (3 6 9 12 15)

Nota: Possiamo omettere il simbolo quote prima dell'operando (add oppure mul) perche' newLISP valuta sempre le primitive su se stesse.

Possiamo utilizzare la funzione "map" all'interno della funzione "crea-lambda" per applicare direttamente l'operazione (con il parametro) ad una lista:

(define (list-map operazione parametro lista)
    (map (lambda (x) (operazione parametro x)) lista))

(list-map + 2 '(1 2 3 4))
;-> (3 4 5 6)

(list-map mul 1.5 '(1 2 3 4))
;-> (1.5 3 4.5 6)

La funzione "map" rende disponibile anche un indice della lista $idx:

(map (fn (x) (list $idx x)) '(a b c))
;-> ((0 a) (1 b) (2 c))

In altre parole, in newLISP le funzioni sono liste di prima classe:

(define (double x) (+ x x)))
(setf (nth 1 double) '(mul 2 x))

double => (lambda (x) (mul 2 x))

La natura di prima classe delle espressioni lambda in newLISP consente di scrivere codice auto modificante.

Come ultimo esempio vediamo un interessante articolo di Kazimir Majorinc:
http://kazimirmajorinc.com/Documents/Crawler-tractor/index.html

Crawler Tractor (Trattore Cingolato) di Kazimir Majorinc
--------------------------------------------------------

Viene presentato un esempio di programma Lisp di auto-elaborazione. La funzione f incrementa continuamente il valore della variabile "counter" e ne stampa il valore. Tuttavia, l'implementazione di f non contiene alcun ciclo o ricorsione. Invece, la funzione cambia il codice della sua definizione durante la valutazione.

(set 'f
     (lambda()
       (begin (print "Hi for the "
                     (inc counter)
                     ". time. ")
              (push (last f) f -1)
              (if (> (length f) 3)
                  (pop f 1)))))

Il risultato della valutazione della funzione "f" vale:

Hi for the 1. time.
Hi for the 2. time.
Hi for the 3. time.
Hi for the 4. time.
...

La valutazione ricorda il funzionamento di un trattore cingolato, veicolo di costruzione popolare. Inizialmente, l'interprete generava un errore di "stack overflow" dopo che il contatore era stato incrementato alcune centinaia di migliaia di volte. Lutz Mueller, l'autore di newLISP, ha prontamente risolto il problema. La perdita di velocità era, secondo Mueller, molto bassa.

Come prova di concetto, Joel Ericson ha definito due funzioni fattoriali che valutano in modo simile. In una di queste non vengono usate nemmeno le variabili:

(define (f)
  (begin
    (when (> (length f) 2)
             (pop f -1))
    (push '(if (> 0 1)
               (begin ; Increase return value
                      (setf ((last f) -1)
                            (* $it ((last f) 1 1)))
                      ; Change exit condition
                      (dec ((last f) 1 1))
                      ; Shorten f if too long
                      (if (> (length f) 4)
                          (pop f 2))
                      (push (last f) f -1))
               1)
          f
          -1)
    (setq ((last f) 1 1) (args 0))))

Il risultato della valutazione di (f 4) è 24.


================
 TIPI DI NUMERI
================

newLISP gestisce due tipi di numeri: interi (integer) e reali detti anche a virgola mobile (floating-point).
I numeri interi si suddividono in integer e big integer.
Gli integer sono rappresentati con 64-bit includendo il bit del segno.
Gli integer vanno da -9,223,372,036,854,775,808 a +9,223,372,036,854,775,807.
Gli integer di newLISP a 32-bit vanno da -2,147,483,647 a +2,147,483,648.
I numeri floating point sono di tipo double e sono conformi allo standard IEEE 754 a 64-bit.
Questi numeri mantengono solo le prime 15 o 16 cifre più significative (cioè le cifre a sinistra del numero, che sono quelle di valore più alto).
Per maggiori informazioni: https://it.wikipedia.org/wiki/IEEE_754
Possiamo visualizzare numeri senza segno fino a 18,446,744,073,709,551,615 con il comando "format".
Il comando "format" ha una sintassi molto simile a quella del comando "printf" del linguaggio C.
I numeri big integer hanno precisione illimitata e sono limitati soltanto dalla memoria (RAM).

Un numero big integer richiede la seguente quantità di memoria:

bytes = 4 * ceil(digits / 9) + 4.

dove "digits" sono le cifre decimali, "bytes" sono a 8 bit e "ceil" è la funzione che arrotonda un numero intero al numero intero successivo più grande.

Attenzione: Numeri grandi che vengono convertiti da numeri floating point sono troncati ai limiti dei numeri integer. Per esempio:

(setq f 2e20)
;-> 2e+020
(int f)
;-> 9223372036854775807

newLISP gestisce anche numeri con altre basi:

123 → 123 intero decimale (base 10)
0xE8 → 232 intero esadecimale con prefisso 0x (base 16)
055 → 45 intero ottale con prefisso 0 (base 8)
0b101010 → 42 intero binario con prefisso 0b (base 2)

I numeri in virgola mobile possono essere rappresentati anche in notazione scientifica:

1.23 → 1.23    virgola mobile
123e-3 → 0.123 virgola mobile in notazione scientifica

Nota: sebbene i numeri interi siano a 64 bit, se utilizziamo newLISP a 32 bit i puntatori di indirizzi di memoria rimangono a 32 bit.


===================================
 PUNTO DECIMALE O VIRGOLA DECIMALE
===================================

Molti paesi usano una virgola anziché un punto come separatore decimale nei numeri. newLISP analizza correttamente i numeri in base all'impostazione locale.

Per vedere l'impostazione del locale corrente:

(set-locale)
;-> ("English_United States.1252" ".")
oppure
;-> ("Italian_Italy.1252" ",")

Per impostare il locale predefinito:

(set-locale "")
;-> ("English_United States.1252" ".")

Per impostare il locale italiano (uso della virgola invece del punto):

(set-locale "Italian_Italy.1252")

Per impostare il locale di default POSIX C:

(set-locale "C")
;-> ("C" ".")

Nota: l'utilizzo di "set-locale" non modifica il comportamento delle espressioni regolari in newLISP.


===========================
 FORMATTAZIONE DELL'OUTPUT
===========================

La funzione utilizzata per formattare la stampa dei numeri si chiama "format".
Di seguito viene riportata la sintassi e alcuni esempi di utilizzo:

sintassi: (format str-format exp-data-1 [exp-data-2 ... ])
sintassi: (format str-format list-data)

Costruisce una stringa formattata da exp-data-1 utilizzando il formato specificato nella valutazione di str-format. Il formato specificato è identico a quello della funzione "printf()" del linguaggio ANSI C.

In str-format possono essere specificati due o più argomenti per un comando "format".

Nella sintassi alternativa i dati da formattare sono passati tramite una lista.

"format" controlla la validità della stringa di formato, la correttezza del tipo di dato, e il corretto numero di argomenti
Formati o tipi di dati errati producono un messaggio di errore
Possiamo usare int, float, o string per assicurare che il tipo di dato sia corretto ed evitare messaggi di errore.

La stringa di formattazione ha il seguente formato generale:

"%w.pf"

Il segno percentuale "%" definisce l'inizio di una stringa di formattazione.
Per visualizzare il carattere "%" con una stringa di formattazione occorre raddoppiarlo: "%%".

Con linux il segno percentuale può essere seguito da un carattere apice "%'" per inserire il separatore delle migliaia nel formato del numero.

Il carattere "w" rappresenta la larghezza del campo.
I dati sono allineati a destra, eccetto quando vengono preceduti da un segno meno, in tal caso vengono allineati a sinistra.
Se inseriamo il carattere "+" all'inizio di un numero, allora i numeri positivi vengono visualizzati con il segno "+".

Quando inseriamo il carattere "0" all'inizio, lo spazio non utilizzato viene riempito da zeri iniziali.

Il campo larghezza è opzionale e serve tutti i tipi di dati.

Il carattere "p" rappresenta il numero dei decimali dei numeri floating-point o stringhe ed è separato dal campo larghezza da un punto "." (period).
La precisione è opzionale. Quando si utilizza il campo precisione in una stringa, allora il numero di caratteri visualizzati è limitato dal valore del numero "p".

Il carattere "f" rappresenta il campo che definisce il tipo di dato ed è essenziale, non può essere omesso.

Di seguito vengono riportati i tipi specificati da "f":

-------------------------------------------------------------------------
|  Formato | Descrizione                                                |
-------------------------------------------------------------------------
|    s     | text string                                                |
|    c     | character (value 1 - 255)                                  |
|    d     | decimal (32-bit)                                           |
|    u     | unsigned decimal (32-bit)                                  |
|    x     | hexadecimal lowercase                                      |
|    X     | hexadecimal uppercase                                      |
|    o     | octal (32-bits) (not supported on all of newLISP flavors)  |
|    f     | floating point                                             |
|    e     | scientific floating point                                  |
|    E     | scientific floating point                                  |
|    g     | general floating point                                     |
-------------------------------------------------------------------------

Su sistemi a 32-bit quando formattiamo un numero a 64-bit utilizzando uno specificatore di formato a 32-bit il numero verrà troncato e formattato con i 32-bit inferiori e pone gli eventuali overflow a 0xFFFFFFFF.

Per numeri a 32-bit e 64-bit utilizzate le seguenti stringhe di formattazione.
Nei sistemi a 32-bit, i numeri a 64-bit saranno troncati a 32-bit.

-------------------------------------------------
| formato   | descrizione                       |
-------------------------------------------------
|   ld      | decimal (32/64-bit)               |
|   lu      | unsigned decimal (32/64-bit)      |
|   lx      | hexadecimal (32/64-bit)           |
|   lX      | hexadecimal uppercase (32/64-bit) |
-------------------------------------------------

Esempi:

(format ">>>%6.2f<<<" 1.2345)           → ">>>  1.23<<<"
(format ">>>%-6.2f<<<" 1.2345)          → ">>>1.23  <<<"
(format ">>>%+6.2f<<<" 1.2345)          → ">>> +1.23<<<"
(format ">>>%+6.2f<<<" -1.2345)         → ">>> -1.23<<<"
(format ">>>%-+6.2f<<<" -1.2345)        → ">>>-1.23 <<<"

(format "%e" 123456789)                 → "1.234568e+08"
(format "%12.10E" 123456789)            → "1.2345678900E+08"

(format "%10g" 1.23)                    → "      1.23"
(format "%10g" 1.234)                   → "     1.234"

(format "Result = %05d" 2)              → "Result = 00002"

(format "%14.2f" 12345678.12)           → "   12345678.12"

; solo su piattaforme UNIX glibc compatibili (Linux, MAC OS X 10.9)
(format "%'14.2f" 12345678.12)          → " 12,345,678.12"

(format "%8d" 12345)                    → "   12345"

; solo su piattaforme UNIX glibc compatibili (Linux, MAC OS X 10.9)
(format "%'8d" 12345)                   → "  12,345"

(format "%-15s" "hello")                → "hello          "
(format "%15s %d" "hello" 123)          → "          hello 123"
(format "%5.2s" "hello")                → "   he"
(format "%-5.2s" "hello")               → "he   "

(format "%o" 80)                        → "120"

(format "%x %X" -1 -1)                  → "ffffffff FFFFFFFF"

; numeri a 64-bit su Windows
(format "%I64X" 123456789012345678)     → "1B69B4BA630F34E"

; numeri a 64-bit su Unix (eccetto TRU64)
(format "%llX" 123456789012345678)      → "1B69B4BA630F34E"

(format "%c" 65)                        → "A"

I dati da formattare possono essere passsati con una lista:

(set 'L '("hello" 123))
(format "%15s %d" L)                    → "          hello 123"

Se la stringa di formattazione lo richiede, newLISP è in grado di convertire gli interi in floating-point e viceversa.

(format "%f" 123)                       → 123.000000

(format "%d" 123.456)                   → 123

In newLISP possiamo usare le parentesi graffe al posto dei doppi apici.

(format {%f %s %d} 3.14 "maggiore di" 3)
;-> "3.140000 maggiore di 3"

Vediamo un altro esempio:

(define (pow2 n)
    (println (trim (format "%16.f" (pow 2 n))))
    (format "%16.f" (pow 2 n)))

(pow2 38)
;-> 274877906944
;-> "    274877906944"

(pow2 52)
;-> 4503599627370496
;-> "4503599627370496"

L'ultimo esempio mostra la massima risoluzione che possiamo avere con i numeri double float di newLISP.

La funzione "trim" rimuove gli spazi davanti per numeri inferiori a 16 cifre.
Se si stampa senza formattare newLISP sceglierà il formato "%g" e fornisce 9 cifre di precisione. Quando formattiamo a destra otteniamo fino a 15/16 cifre di precisione (52 bit)
quando si utilizzano double float a 64 bit.


===================================
 OPERAZIONI ARITMETICHE ELEMENTARI
===================================

newLISP utilizza operatori matematici diversi in funzione del tipo di numero:
a) per i numeri interi occorre usare: "+", "-", "*" e "/"
b) per i numeri reali occorre usare: "add", "sub", "mul" e "div"

newLISP utilizza la notazione prefissa: prima l'operatore, poi gli argomenti.

Esempi di operazioni aritmetiche con i numeri interi:

(+ 3 9)
;-> 12

(- 4 2)
;-> 2

(* 3 2)
;-> 6

(/ 8 2)
;-> 4

Esempi di operazioni aritmetiche con i numeri reali:

(+ 3.0 1.2) ;oops, abbiamo usato l'operatore somma dei numeri interi
;-> 4

(add 3.0 1.2)
;-> 4.2

(/ 12 5) ;oops, abbiamo usato l'operatore divisione dei numeri interi
;-> 2

(div 12 5)
;-> 2.4


====================================
 INCREMENTO/DECREMENTO DI VARIABILI
====================================

Quando dobbiamo incrementare le variabili possiamo utilizzare diversi metdoi.
Il metodo normale consiste nell'utilizzare la funzione "setq":

(setq i 0)
(setq i (+ i 1))
;-> 1

Oppure possiamo utilizzare l'operatore "++" (per i numeri interi).

sintassi: (++ valore [num])

L'operatore ++ incrementa il valore di 1 o del numero opzionale num e restituisce il risultato. L'operatore ++ usa l'aritmetica intera. Senza l'argomento facoltativo in num, ++ incrementa il valore di 1. Se i numeri in virgola mobile vengono passati come argomenti, la parte frazionaria viene prima troncata. I calcoli risultanti in numeri superiori a 9.223.372.036.854.775.807 produrranno numeri negativi. Risultati inferiori a -9.223.372.036.854.775.808 produrranno numeri positivi. Il parametro "valore" è un simbolo o un valore indicizzato di una lista o il risultato di una espressione.

(set 'x 1)
(++ x)
;-> 2
(set 'x 3.8)
(++ x)
;-> 4
(++ x 1.3)
;-> 5
(set 'lst' (1 2 3))
(++ (lst 1) 2))
;-> 4
lst
;-> (1 4 3)

Se il simbolo per valore contiene nil, viene trattato come se contenga 0.

L'operatore "--" effettua le operazioni di decremento (numeri interi).

Oppure possiamo usare la funzione "inc" (per i numeri in virgola mobile).

sintassi: (inc valore [num])

Incrementa il valore di 1.0 o del numero opzionale num e restituisce il risultato. inc utilizza l'aritmetica in virgola mobile e converte i numeri interi passati in un tipo a virgola mobile. Senza l'argomento facoltativo in num, inc incrementa il valore di 1.0. Il parametro "valore" è un simbolo o un valore indicizzato di una lista o il risultato di una espressione.

(set 'x 0)
(inc x)
;-> 1
(inc x 0.25)
;-> 1.25
(inc x)
;-> 2.25

Se un simbolo per valore contiene nil, viene trattato come se contenga 0.0:

z
;-> nil
(inc z)
;-> 1

Possono essere aggiornati anche gli elementi di una lista o un numero restituito da un'altra espressione:

(set 'lst '(1 2 3 4))
(inc (lst 3) 0.1)
;-> 4.1
(inc (first lst))
;-> 2
lst
;-> (2 2 3 4.1)
(inc (+ 3 4))
;-> 8

La funzione "dec" effettua le operazioni di decremento (numeri in virgola mobile).

Nota: Le funzioni "inc" e "dec" hanno un comportamento diverso se il parametro "valore" viene quotato: le funzioni restituiscono il risultato corretto (incremento o decremento dal numero contenuto in valore, ma la la variabile "valore" mantiene inalterato il numero, cioè non viene incrementato.

Parametro "valore" non quotato:
(setq x 0)
(inc x)
;-> 1
x
;-> 1

Parametro "valore" quotato:
(inc 'x)
;-> 2
x
;-> 1

Invece le funzioni "++" e "--" generano un errore quando cerchiamo di appricarle ad un parametro quotato:

(setq x 0)
(++ 'x)
;-> ERR: value expected in function ++ : x


============================
 USO DEI NUMERI BIG INTEGER
============================

I numeri interi a 64-bit hanno il seguente intervallo: da -9223372036854775808 a 9223372036854775807.
Se aggiungiamo 1 al più grande numero intero a 64-bit, ritorniamo al primo numero dell'intervallo:

(setq intero64-max 9223372036854775807)
(+ intero64-max 1)
;-> -9223372036854775808

Analogamente per il limite inferiore:

(setq intero64-min -9223372036854775808)
(- intero64-min 1)
;-> 9223372036854775807

Quando abbiamo la necessità di calcolare con numeri più grandi dobbiamo utilizzare il tipo big integer.
newLISP permette di definire un numero di tipo big integer aggiungendo il carattere "L" alla fine del numero:

(setq grande-intero 9223372036854775807L)
(+ grande-intero 1)
;-> 9223372036854775808L

In alcuni casi newLISP converte automaticamente il tipo del numero in big integer, ad esempio:

(* 1000000000000000000000000000000 1000000000000000000000000000)
;-> 1000000000000000000000000000000000000000000000000000000000L  ;newLISP ha convertito il risultato in big integer

Ma questa conversione non avviene in ogni calcolo:

(* 1234567899990 1234567899990)
;-> -4329404533060271900 ;newLISP non ha convertito il risultato in big integer

Se tutti gli operandi sono numeri big integer (anche senza la "L" finale), allora il risultato sarà di tipo big integer.
Se gli operandi sono di tipo diverso, allora vale la seguente regola:
il primo operando determina se il risultato sarà di tipo big integer.

Vediamo un esempio:

(for (i 1 10) (println (+ 9223372036854775800 i)))
;-> 9223372036854775801
;-> 9223372036854775802
;-> 9223372036854775803
;-> 9223372036854775804
;-> 9223372036854775805
;-> 9223372036854775806
;-> 9223372036854775807
;-> -9223372036854775808  ;errore
;-> -9223372036854775807
;-> -9223372036854775806
;-> -9223372036854775806

Il primo operando non è un big integer e quindi il risultato non è di tipo big integer.

Per ottenere il risultato corretto dobbiamo scrivere:

(for (i 1 10) (println (+ 9223372036854775800L i))) nota la "L" finale

;-> 9223372036854775801L
;-> 9223372036854775802L
;-> 9223372036854775803L
;-> 9223372036854775804L
;-> 9223372036854775805L
;-> 9223372036854775806L
;-> 9223372036854775807L
;-> 9223372036854775808L
;-> 9223372036854775809L
;-> 9223372036854775810L
;-> 9223372036854775810L

In altre parole, il tipo del primo operando determina il tipo del risultato finale.

Possiamo convertire un numero intero in big integer usando la funzione "bigint":

(setq num (bigint 1000))
;-> 1000L

(setq grande (bigint 9223372036854775807))

(* grande grande)
;-> 85070591730234615847396907784232501249L

(setq atomi (bigint 1E+50))
100000000000000000000000000000000000000000000000000L

(++ atomi)
100000000000000000000000000000000000000000000000001L

I calcoli con i numeri big integer sono più lenti dei calcoli effettuati con gli interi a 64-bit.


===============
 INTROSPEZIONE
===============

Ci sono diversi predicati che consentono di conoscere il tipo di numero associato ad una variabile:

number?    controlla se una espressione è un integer o un floating point

float?    controlla se una espressione è floating point

integer?  controlla se una espressione è un integer

bigint?    controlla se una espressione è un big integer

inf?      controlla se un floating point vale infinito

NaN?      controlla se un floating point vale NaN (Not a Number)

zero?     controlla se una espressione vale 0 (zero)

Scriviamo una funzione che prende una espressione numerica e restituisce il tipo di numero:

(define (type? num)
  (if (number? num)
      (cond ((float? num) "reale")
            ((bigint? num) "grande_intero")
            ((integer? num) "intero")
            (true "sconosciuto"))
      nil ;se non è un numero restituisce nil
   )
)

(type? 10)
;-> "intero"

(type? 10.0)
;-> "reale"

(type? 1e-800)
;-> "reale"

(type? 2394782394578239457239472345723945723458723457234578)
;-> "grande_intero"

(type? 2394782394578239457239472345723945723458723457234578L)
;-> "grande_intero"

Nota: un numero big integer risulta anche integer.

(integer? 2394782394578239457239472345723945723458723457234578)
;-> true

(bigint?  2394782394578239457239472345723945723458723457234578)
;-> true

Nota: il tipo di numero viene definito anche dall'operatore usato.

(float? (add 3 2))
;-> true

(float? (+ 3 2))
;-> nil

(integer? (+ 3 2))
;-> true

(float? (+ 3.0 2.0))
;-> nil

(integer? (+ 3.1 2.1))
;-> true


=============================================
 CONVERSIONI DI TIPO: IMPLICITE ED ESPLICITE
=============================================

newLISP possiede tutte le funzioni necessarie per permettere all'utente di convertire il tipo di un numero, ma effettua autonomamente delle conversioni di tipo quando si verificano speciali condizioni (ad esempio quando nelle espressioni numeriche compaiono numeri che hanno tipi diversi).
Quindi abbiamo conversioni implicite (quelle fatte da newLISP) e conversioni esplicite (quelle richieste dall'utente).
Abbiamo visto alcuni esempi di conversioni durante l'uso dei numeri di tipo big integer.
Per convertire una stringa in numero, oppure convertire il tipo di un numero, possiamo usare le funzioni "int" e "float".

Per esempio, possiamo estrarre i numeri da una stringa:

(map int (find-all {\d+} {In questa stringa ci sono 3 numeri: 10, 20 e 30}))
;-> (3 10 20 30) una lista di interi

(map float (find-all {\d+(\.\d+)?} {pi vale 3.1415, e vale 2.7182}))
;-> (3.1415 2.7182) una lista di floating-point

Quando convertiamo un numero possiamo specificare un valore di default nel caso la conversione fallisca:

(int "x")
;-> nil

(int "x" 0)
;-> 0

Possiamo convertire un numero in un'altra base, ad esempio convertire una stringa esadecimale nel numero corrispondente in base 10:

(int "1F" 0 16) dobbiamo specificare il valore di default "0" e la base del numero "16"
;-> 31

oppure (prefisso "0x"):

(int "0x1F")
;-> 31

Conversione di un numero binario:

(int "1001001001010010010000000000000000" 0 2)
;-> 9819455488

oppure (prefisso "0b"):

(int "0b1001001001010010010000000000000000")
;-> 9819455488

Conversione di un numero ottale:

(int "35" 0 8)
;-> 29

oppure (prefisso "0"):

(int "035")
;-> 29

Alcune funzioni convertono automaticamente i numeri floating-point in numeri interi e viceversa.
Se utilizziamo operatori composti da lettere dell'alfabeto (es. "add", "sub", etc)  allora newLISP converte i numeri in floating-point.
Se utilizziamo operatori speciali (es. +, -, *, /), allora newLISP converte i numeri in interi.

(setq reale (sqrt 2))
;-> 1.414213562373095
(float? reale)
;-> true

(setq intero 2)
;-> 2
(integer? intero)
;-> true

Risultato di tipo intero:

(setq res (+ intero reale))
;-> 3
(float? res)
;-> nil
(integer? res)
;-> true

Risultato di tipo floating-point:

(setq res (add intero reale))
;-> 3.414213562373095
(float? res)
;-> true
(integer? res)
;-> nil

Risultato di tipo floating-point:

(setq num (inc intero))
;-> 3
(float? num)
;-> true
(integer? num)
;-> nil

Nella maggior parte dei casi le conversioni implicite non creano problemi.
Comunque in alcuni casi è possibile perdere in precisione, per esempio se utilizziamo un numero intero molto grande con una funzione che lo converte in floating-point:

(format {%15.15f} (add 1 746575847474723219))
;-> "746575847474723200.000000000000000"

Nota: durante l'esecuzione del programma una variabile può assumere dei valori che hanno tipi diversi.


==============================================
 QUANTO SONO PRECISI I NUMERI FLOATING POINT?
==============================================

In questo documento vedremo solo informazioni pratiche sull'utilizzo dei numeri floating-point.
Per una trattazione più completa vedi:
https://en.wikipedia.org/wiki/Floating-point_arithmetic
https://floating-point-gui.de/
http://pages.cs.wisc.edu/~david/courses/cs552/S12/handouts/goldberg-floating-point.pdf

La filosofia di un numero floating-point è quella di essere "vicino abbastanza", piuttosto che memorizzare il valore vero. Questo è un compromesso tra velocità di esecuzione e accuratezza dei risultati.

Supponiamo di voler memorizzare il valore di pi greco con 20 decimali:

(constant 'PI 3.14159265358979323846)
;-> 3.141592653589793

(println PI)
;-> 3.141592653589793

Sembra che newLISP abbia eliminato 5 cifre della parte destra del numero!
In effetti sono stati memorizzate solo le 15 o 16 cifre più significative e le rimanenti 5 sono state scartate (quelle meno importanti).
Per vedere ome viene memorizzato questo numero all'interno di newLISP utilizziamo la funzione "format":

(format {%1.20f} PI)
;-> "3.14159265358979310000"

Adesso compariamo i numeri come stringhe e vediamo le differenze:

stringa con PI originale (con 20 cifre)
(setq pi-originale-str "3.14159265358979323846")
;-> "3.14159265358979323846")

numero floating-point convertito dalla stringa con PI originale
(setq pi (float pi-originale-str))
;-> 3.141592653589793

numero formattato (stringa) dal numero floating-point PI memorizzato
(setq numero-pi-str (format {%1.20f} pi))
;-> "3.14159265358979310000"

(println pi-originale-str " -> stringa PI originale")
(println pi " -> numero floating-point convertito dalla stringa PI originale")
(println numero-pi-str " -> numero formattato (stringa) dal numero floating-point ")
;-> 3.141592653589793 -> stringa PI originale
;-> 3.141592653589793 -> numero floating-point convertito dalla stringa PI originale
;-> 3.14159265358979310000 -> numero formattato (stringa) dal numero floating-point

(define (test)
  (dotimes (i (length pi-originale-str) (!= (pi-originale-str i) (numero-pi-str i)))
    (print (pi-originale-str i)))
(println " -> versione originale e versione memorizzata sono uguali fino a qui"))

(test)
;-> 3.141592653589793 -> versione originale e versione memorizzata sono uguali fino a qui

Il valore rimane accurato fino alle cifre 9793, poi le seguenti cifre non vengono memorizzate.
Questo è il modo in cui tutti i computer memorizzano i numeri floating-point, non dipende da newLISP.
Il numero floating-point più piccolo utilizzabile vale circa 2.2e-308.
Il numero floating-point più grande utilizzabile vale circa 1.8e+308.

         -1.8e308                 -2.2e-308            2.2e-308                     1.8e308
 ------------|--------------------------|------ 0 ------|--------------------------|------------
   Overflow  |  numeri rappresentabili  |   Underflow   |  numeri rappresentabili  |  Overflow


=============================================
 QUANTO SONO STRANI I NUMERI FLOATING-POINT?
=============================================

Facciamo una semplice somma:

(add 0.1 0.2)
;-> 0.3

Sembra tutto corretto, comunque se visualizziamo il numero con 20 cifre dopo la virgola:

(format {%1.20f} (add 0.1 0.2))
;-> "0.30000000000000004000"

Da dove è uscito quel 4?
Perché 0.1 + 0.2 non vale un preciso 0.3 e invece ottengo un risultato strano come 0.30000000000000004?
Perché internamente, i computer utilizzano un formato (binario a virgola mobile) che non può rappresentare con precisione un numero come 0.1, 0.2 o 0.3.
Il numero 0.1 viene memorizzato con il numero più vicino possibile in quel formato (floating-point).
Questo si traduce in un piccolo errore di arrotondamento ancor prima di effettuare il calcolo.
Quindi il risultato non è realmente 0.3, ma il valore più vicino rappresentabile nel formato floating-point.

Comunque le stranezze non sono terminate:

(sub (add 0.1 0.2) 0.3)
;-> 5.551115123125783e-017

Perchè non vale esattamente 0?
Perchè il numero 0.3 viene rappresentato in modo diverso dal numero 0.1 + 0.2.
Per capire il motivo vediamo il seguente esempio:

(setq a (add 0.1 0.2))
;-> 0.3

(setq b 0.3)
;-> 0.3

Vediamo come sono rappresentati con 20 cifre decimali dopo la virgola:

(format {%1.20f} a)
;-> "0.30000000000000004000"

(format {%1.20f} b)
;-> "0.29999999999999999000" il valore di b è diverso dal valore di a

Quindi abbiamo verificato che la rappresentazione floating point di 0.3 è diversa da quella del numero (0.1 + 0.2):

(sub a b)
;-> 5.551115123125783e-017

(sub 0.30000000000000004000 0.29999999999999999000)
;-> 5.551115123125783e-017

(format {%1.20f} (sub (add 0.1 0.2) 0.3))
"0.00000000000000005551"

Facciamo un altro esempio:

(add 0.1 0.4)
;-> 0.5

Visualizziamo il numero con 20 cifre dopo la virgola:

(format {%1.20f} (add 0.1 0.4))
;-> "0.50000000000000000000"

In questo caso il risultato (0.5) può essere rappresentato esattamente come un numero in virgola mobile, ed è anche possibile che gli errori di arrotondamento nei numeri di input si annullino a vicenda.

Per capire meglio, vediamo come vengono rappresentati i numeri da 0 a 1 con intervallo pari a 0.1:

(for (x 0 1 0.1) (println (format {%1.20f} x)))
;-> 0.00000000000000000000
;-> 0.10000000000000001000
;-> 0.20000000000000001000
;-> 0.30000000000000004000
;-> 0.40000000000000002000
;-> 0.50000000000000000000
;-> 0.60000000000000009000
;-> 0.70000000000000007000
;-> 0.80000000000000004000
;-> 0.90000000000000002000
;-> 1.00000000000000000000

Gli unici valori rappresentati in modo matematicamente corretto sono 0.0, 0.5 e 1.0.

Allora perchè utilizziamo questo sistema di rappresentazione?
1) Perchè i numeri binari sono i più veloci da trattare per i computer
2) Perchè nella maggior parte dei calcoli, un piccolo errore nella sedicesima posizione decimale non ha alcuna importanza, in quanto i numeri con cui si lavora non sono uguali (o comunque precisi)


================
 TIPI DI ERRORE
================

Dato un numero N e la sua rappresentazione M possiamo definire:

Errore = N - M

Errore Assoluto = abs(N - M)

Errore Relativo = abs(N - M) / abs(N)

Abbiamo bisogno di due tipi di errore (assoluto e relativo) per far fronte alla variabilità dei numeri, cioè per tener conto della magnitudine dei numeri.

Supponiamo di dover calcolare un numero piccolo sqrt(2)/e^20:

N = valore vero = 2.91491140698704220338218698754849111429863329048893 (50 cifre decimali)

M = valore calcolato = (div (sqrt 2) (exp 20)) = 2.914911406987042e-009

(format {%1.30f} (setq M (div (sqrt 2) (exp 20))))
;-> "0.000000002914911406987042300000"

Errore Assoluto =
= (2.91491140698704220338218698754849111429863329048893e-009 - 0.0000000029149114069870423) =
= -9.661781301245150888570136670951 × 10^-26

calcolato con Mathematica, poichè con newLISP:
(sub 2.91491140698704220338218698754849111429863329048893e-009 2.9149114069870423e-009)
;-> 0 per newLISP i due numeri sono uguali

Errore Relativo =
(2.91491140698704220338218698754849111429863329048893e-009 - 2.9149114069870423e-009) / 2.91491140698704220338218698754849111429863329048893e-009 =
= -3.314605472429063389421276668952 × 10^-17

calcolato con Mathematica, poichè con newLISP:
(div (sub 2.91491140698704220338218698754849111429863329048893e-009 2.9149114069870423e-009) 2.91491140698704220338218698754849111429863329048893e-009)
;-> 0 per newLISP i due numeri sono uguali

Supponiamo di dover calcolare un numero grande (e^(e^6)):

N = valore vero = 1.61027056677937207488718139872102038366075780678065 × 10^175 (50 cifre decimali)

M = valore calcolato = (setq M (exp (exp 6)))) = 1.610270566779352e+175

(format {%.3f} (setq M (exp (exp 6))))
"1610270566779352300000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000.000" = 1.6102705667793523e+175

Errore Assoluto =
= 1.61027056677937207488718139872102038366075780678065×10^175 - 1.610270566779352×10^175 =
= 2.007488718139872102038366075780678065 × 10^161

Errore Relativo =
= (1.61027056677937207488718139872102038366075780678065×10^175 - 1.610270566779352×10^175) / 1.61027056677937207488718139872102038366075780678065×10^175 =
= 1.2466778934890164076152223629835707813418896107248402 × 10^-14

Gli errori assoluti perdono di significato con l'aumentare della magnitudine dei numeri, cioè quando trattiamo con numeri grandi.


===========================
 PROPAGAZIONE DEGLI ERRORI
===========================

Mentre gli errori nei singoli numeri in virgola mobile sono molto piccoli, anche calcoli semplici su di essi possono contenere insidie ​​che aumentano l'errore nel risultato ben oltre l'avere i singoli errori "sommati".

In generale:

Moltiplicazione e divisione sono operazioni "sicure".
Addizione e sottrazione sono pericolose, perché quando sono coinvolti numeri di diversa grandezza, le cifre del numero di grandezza minore vengono perse.
Questa perdita di cifre può essere inevitabile e benigna (quando le cifre perse sono anche insignificanti per il risultato finale) o catastrofica (quando la perdita viene amplificata e distorce fortemente il risultato).
Più calcoli sono fatti (specialmente quando sono la base di un algoritmo iterativo) più è importante considerare questo tipo di problema.
Un metodo di calcolo può essere stabile (nel senso che tende a ridurre gli errori di arrotondamento) o instabile (ovvero gli errori di arrotondamento vengono ingranditi). Molto spesso, ci sono soluzioni stabili e instabili per un problema.
Esiste un intero sotto-campo della matematica (in analisi numerica) dedicato allo studio della stabilità numerica degli algoritmi. Per fare calcoli complessi che coinvolgono numeri in virgola mobile, è assolutamente necessario avere una certa comprensione di questa disciplina.
L'articolo "What Every Computer Scientist Should Know About Floating-Point Arithmetic" fornisce un'introduzione dettagliata anche se è necessario avere un background scientifico.


=====================================================
 RAPPRESENTAZIONE DEI NUMERI FLOATING POINT (32-bit)
=====================================================

Vediamo, come vengono rappresentati i numeri in floating-point (virgola mobile) secondo lo standard IEEE754.
Si consideri il numero reale 100.25(b10).
Esso può venire rappresentato come:

100.25 = 1 * (10)² + 0 * (10)¹ + 0 * (10)° + 2 * (10)¯¹ + 5 * (10)¯²

Analogamente, per il numero binario 101.001(b2) vale:

101.001(b2) =
 = 1 * (2)² + 0 * (2)¹ + 1 * (2)° + 0 * (2)¯¹ + 0 * (2)¯² + 1 *(2)¯³ =
 = (2)² + (2)° +(2)¯³ =
 = 5.125(b10)

Il numero reale 100.25(b10) espresso secondo la notazione scientifica è:

 1.0025 * 10²

dove 1.0025 è la mantissa, 10 è la base del sistema di numerazione e ² è l' esponente.
Anche in binario vale la stessa cosa.

Si consideri il numero binario corrispondente a 5.625, ovvero:

101.101(b2) = 1.01101(b2) * (2²)(b10)

dove 1.011101 è la mantissa, 2 è la base del sistema binario (in questo caso espressa in
base 10) e ² è l' esponente (anch'esso espresso in base 10).

Lo standard IEE754 prevede, per i numeri binari in virgola mobile a 32-bits (quattro bytes), la seguente rappresentazione:

X       XXXXXXXX    XXXXXXXXXXXXXXXXXXXXXXX
Segno   Esponente   Mantissa
1 bit   8 bit       23 bit

Campo Segno
-----------
Il primo campo della rappresentazione IEE754, lungo un bit, rappresenta il segno del numero binario. Se vale 0 indica che il numero è positivo, se vale 1 indica che il numero è negativo.
Il numero 1.01101(2b) * (2²)(10b) è positivo per cui questo campo deve valere 0 come illustrato nella figura seguente:

0 XXXXXXXX XXXXXXXXXXXXXXXXXXXXXXX

Campo Esponente
---------------
Il secondo campo, lungo otto bit (un byte), rappresenta l'esponente del numero binario espresso in notazione scientifica. Come è noto, un byte può assumere valori che vanno da 0 a 255. Come si fa per rappresentare gli esponenti negativi? Per poter rappresentare sia gli esponenti positivi che negativi si usa, per questo campo, la notazione eccesso 127. Quest'ultima prevede che al vero esponente vada sommato 127. Perciò, per il numero 1.01101(2b) * (2²)(10b) l'esponente da inserire nel secondo campo della rappresentazione vale: 2 + 127 = 129 ovvero in binario: 1000 0001.

0 1000 0001 XXXXXXXXXXXXXXXXXXXXXXX

Campo Mantissa
--------------
Il terzo campo, lungo ventitrè bits, rappresenta la mantissa del numero binario spresso in notazione scientifica. Nel caso in esame vale 1.01101. A questo punto occorre notare che tutti i numeri binari espressi in notazione scientifica hanno un "1" prima della virgola, per cui nella rappresentazione IEE754 questo viene sottointeso. Inoltre, al valore effettivo della mantissa dell'esempio: 01101, vengono aggiunti tanti "0" quanti ne servono per completare il campo a 23 bits è perciò si ha:

0110100 00000000 00000000

In definitiva il numero 101.101(b2) = 1.01101(b2) * (2²)(10) viene rappresentato ,in floating point, nel modo seguente:

0 1000 0001 0110100 00000000 00000000

Riarrangiando i 32-bits della rappresentazione come quattro byte si ha:

0100 0000 1011 0100 0000 0000 0000 0000(b2)

che in esadecimale equivale a:

40 B4 00 00

Nota: La codifica IEEE754 è complicata dalla necessità di rappresentare alcuni valori particolari:
1) NaN (Not a Number, risultato di operazioni non ammesse, es. 0/0)
2) +∞ e -∞ (es. 3/0 = infinito)
3) Il valore 0 (meno banale di quanto sembri)

Proprietà fondamentale della codifica
-------------------------------------
NB. I circa 4 miliardi di configurazioni (usati a 32-bit) consentono di coprire un campo di valori molto ampio grazie alla distribuzione non uniforme:
1) per numeri piccoli in valore assoluto i valori rappresentati sono «fitti»,
2) per numeri grandi in valore assoluto i valori rappresentati sono «diradati»

-∞---------------------------------------------0---------------------------------------------+∞
 |      |     |     |    |    |   |   | | | ||||||| | | |   |   |    |    |     |     |      |

newLISP rappresenta e usa tutti i numeri floating point in precisione doppia (double a 64-bit).

Nota: Si osservi che nell’intervallo [0.125, 0.25) abbiamo 2 numeri.
Nell’intervallo [0.25, 0.5), che è il doppio di quello precedente abbiamo ancora 2 numeri.
Nell’intervallo [0.5, 1) che è ancora il doppio di quello precedente abbiamo la possibilità di rappresentare ancora 2 numeri.
Nell’intervallo [1, 2) abbiamo infine ancora 2 numeri.
Man mano che ci muoviamo nella direzione crescente di valori in potenze di due (da 0.125 a 2) la densità dei numeri diminuisce. Abbiamo quindi una distribuzione non uniforme.
Questa considerazione ci fa pensare al concetto di precisione.
Nell’intervallo [0.125, 0.25) possiamo rappresentare solo 0.125 e 0.1875, ma non possiamo rappresentare l’entità 0.1415 se non attraverso un errore in difetto (0.125) o in eccesso (0.1875).
È evidente che non potremo rappresentare perfettamente tutti i numeri reali ma ci dovremo accontentare di un’approssimazione, tanto più efficiente quanti più bit destiniamo alla mantissa.

Complessità dei calcoli
-----------------------
Senza voler entrare in dettaglio basti osservare che supponendo che per la somma fra 2 numeri in virgola fissa ci voglia un tempo di 1 microsecondo (1 milionesimo di secondo), per la somma di 2 numeri in virgola mobile ci vogliono almeno 10 microsecondi (dovendo fare una quantità molto elevata di operazioni la differenza in termini di tempo non è per nulla trascurabile).


=================
 MACHINE EPSILON
=================

Il "machine epsilon" è il più piccolo numero ε, appartenente a un dato insieme F di numeri in virgola mobile, diverso in valore assoluto da zero, che sommato all'unità, dà un risultato diverso da 1.
Se prendiamo due numeri in F, per esempio a e b, per cui nell'insieme dei corrispondenti reali

 a - b < ε,

si ottiene nel detto insieme F

 a - b = 0

e si verifica un fenomeno di cancellazione dei dati.
Questo è dovuto al fatto che l'implementazione dell'aritmetica in virgola mobile nei comuni microprocessori è approssimata a causa della dimensione finita dei registri nei quali vengono memorizzati risultati e operandi.
Tale numero rappresenta la distanza tra 1 e il numero successivo rappresentabile in floating point, cioè secondo la precisione della macchina.
In altre parole "machine epsilon ε" è definito come il più piccolo numero tale che: ((1 + ε) > 1).
Si tratta della differenza tra 1 e il più vicino numero successivo rappresentabile in floating point.
Facciamo un esempio:
supponiamo di avere un sistema ad 8 bit che memorizza un numero reale con il primo bit che rappresenta il segno, i successivi tre bit rappresentano l'esponente e gli ultimi quattro bit la mantissa.
Il numero 1 in base 10 è rappresentato da:

| 0 | 0 | 1 | 1 | 0 | 0 | 0 | 0

Il numero binario successivo è rappresentato da:

| 0 | 0 | 1 | 1 | 0 | 0 | 0 | 1

e vale 1.0625.

Quindi il machine epsilon vale: ε = 1.0625 - 1 = 0.0625

Possiamo scrivere una funzione che calcola il valore di machine epsilon per newLISP:

primo metodo:

(define (machine-epsilon1)
  (setq eps '()) lista per memorizzare la sequenza calcolata di machine epsilon
  (setq u 1.0)
  (while (!= 1.0 (add 1 u))
    (setq u (mul u 0.5))
    (push u eps))
  (println "machine epsilon: " (eps 0))
  eps
)

(machine-epsilon1)
;-> 1.110223024625157e-016

secondo metodo:

(define (machine-epsilon2)
  (setq eps 1.0)
  (while (> (add 1.0 eps) 1.0)
    (setq eps (div eps 2.0)))
  (println "machine epsilon: " eps)
)

(machine-epsilon2)
;-> 1.110223024625157e-016

Dal punto di vista dei calcoli numerici, il machine epsilon rappresenta il limite superiore dell'errore assoluto relativo alla rappresentazione di un numero.
In altre parole, l'errore assoluto relativo alla rappresentazione di un numero è sempre inferiore al machine epsilon.

Abbiamo visto che "machine epsilon ε" è definito come il più piccolo numero tale che: ((1 + ε) > 1).
Se utilizziamo un altro numero iniziale per il confronto (cioè tale che ((N + ε) > 1)) otteniamo un risultato diverso:

(define (machine-epsilonN num)
  (setq eps 1.0)
  (while (> (add num eps) num)
    (setq eps (div eps 2.0)))
  (println "machine epsilon: " eps)
)

(machine-epsilonN 1)
;-> 1.110223024625157e-016

(machine-epsilonN 10)
;-> 8.881784197001252e-016

(machine-epsilonN 100000)
;-> 7.275957614183426e-012

Come potete notare il machine-epsilon cambia in funzione della magnitudine del numero considerato (non è un valore stabile), in particolare il suo valore aumenta con l'aumentare del numero N considerato. Questo significa che la distanza nella rappresentazione floating-point di due numeri adiacenti non è costante. In altre parole:
1) per numeri piccoli in valore assoluto i valori rappresentati sono «fitti»
2) per numeri grandi in valore assoluto i valori rappresentati sono «diradati»

-∞---------------------------------------------0---------------------------------------------+∞
 |      |     |     |    |    |   |   | | | ||||||| | | |   |   |    |    |     |     |      |

Nota: il numero macchina (che è diverso dal machine-epsilon) viene definito come: nm = (b^(1-m))/2
dove:
b -> base
m -> mantissa


=====================================
 INFINITO E NOT A NUMBER (INF e NaN)
=====================================

Lo standard IEEE 754 per i numeri floating-point definisce, oltre i numeri ordinari, anche due numeri particolari: INF e NaN.
Si tratta di numeri con valore Infinito e di numeri che...non sono numeri (Not a Number).
In alcuni linguaggi la divisione per 0 genera un errore di sistema, mentre in newLISP genera il valore Infinito:

(setq a-inf (div 1 0))
;-> 1.#INF
(inf? a-inf)
;-> true

(setq a-inf-neg (div -1 0))
;-> -1.#INF
(inf? a-inf-neg)
;-> true

(setq a-NaN (sqrt -1))
;-> -1.#IND
(NaN? a-NaN)
;-> true

NaN (Not a Number) è un membro di un tipo di dati numerico che può essere interpretato come un valore non definito o non rappresentabile, specialmente nell'aritmetica a virgola mobile. L'uso sistematico di NaN è stato introdotto dallo standard a virgola mobile IEEE 754 nel 1985, insieme alla rappresentazione di altre quantità non finite come gli infiniti.

In matematica, lo zero diviso per zero non è definito come un numero reale ed è quindi rappresentato da NaN nei sistemi informatici. La radice quadrata di un numero negativo non è un numero reale ed è quindi rappresentata anche da NaN nei sistemi informatici conformi. I NaN possono essere utilizzati anche per rappresentare i valori mancanti nei calcoli.

Le operazioni in virgola mobile (tranne i confronti) normalmente propagano un NaN silenzioso (qNaN = quiet NaN). La propagazione di NaN silenziosi attraverso operazioni aritmetiche consente di rilevare gli errori alla fine di una sequenza di operazioni senza test approfonditi durante le fasi intermedie. Ad esempio, se si inizia con un NaN e si aggiunge 1 tre volte di seguito, ogni somma risulta in un NaN, ma non è necessario controllare ogni calcolo perché si può semplicemente notare che il risultato finale è NaN.

Tuttavia, a seconda dei linguaggi e della funzione usata, i NaN possono essere rimossi silenziosamente da una catena di calcoli in cui un calcolo nella catena darebbe un risultato costante per tutti gli altri valori a virgola mobile. Ad esempio, il calcolo x^0 può produrre il risultato 1, anche dove x è NaN, quindi controllare solo il risultato finale oscurerebbe il fatto che un calcolo prima di x^0 ha dato come risultato un NaN.

Lo standard a virgola mobile IEEE (IEEE 754) specifica anche un valore infinito positivo e uno negativo (e anche valori indefiniti). Questi sono definiti come il risultato di overflow aritmetico, divisione per zero e altre operazioni eccezionali.

Alcuni linguaggi di programmazione, come Java, consentono un accesso esplicito ai valori di infinito positivo e negativo come costanti. Questi possono essere usati come elementi di massimo e di minimo, poiché sono (rispettivamente) maggiore o minore di tutti gli altri valori. Vengono usati come valori sentinella negli algoritmi che coinvolgono l'ordinamento, la ricerca o il windowing.

Nei linguaggi che non hanno elementi massimi e minimi è possibile creare questi valori.

Nota: un ciclo infinito è un ciclo la cui condizione di uscita non è mai soddisfatta, quindi viene eseguito indefinitamente.

newLISP mette a disposizione due funzioni per verificare se un numero vale NaN o Infinito: "NaN?" e "inf?"

******************
>>> funzione NaN?
******************
sintassi: (NaN? float)

Verifica se il risultato di un'operazione matematica in virgola mobile è un NaN (cioè se il risultato è un numero valido). Alcune operazioni in virgola mobile restituiscono uno speciale formato numerico IEEE 754 chiamato NaN per "Not a Number".

; floating point operation on NaN yield NaN
(set 'x (sqrt -1))  → NaN
(NaN? x)            → true
(add x 123)         → NaN
(mul x 123)         → NaN

; integer operations treat NaN as zero
(+ x 123)  → 123
(* x 123)  → 0

; comparisons with NaN values yield nil
(> x 0)   → nil
(<= x 0)  → nil
(= x x)   → nil

(set 'infinity (mul 1.0e200 1.0e200)) → inf
(NaN? (sub infinity infinity)) → true

Nota: tutte le operazioni aritmetiche in virgola mobile con un NaN producono un NaN.

Tutti i confronti con NaN restituiscono nil, ma è vero se confrontato con se stesso. Il confronto con se stesso, tuttavia, risulterebbe non vero quando si utilizza ANSI C.

Nota: le operazioni con numeri interi trattano NaN come valori 0 (zero).

******************
>>> funzione inf?
******************
sintassi: (inf? float)
  
Se il valore in float è infinito la funzione restituisce true altrimenti nil.

(inf? (div 1 0)) → true

(div 0 0) → NaN

Nota che una divisione intera per zero, ad es. (/ 1 0) genera un errore di "divisione per zero" e non produce infinito.

Vediamo alcuni esempi:

(setq a (/ 1 0))
;-> ERR: division by zero in function /

(setq a (div 1 0))
;-> 1.#INF
(inf? a)
;-> true

(setq b (- (div 1 0) (div 1 0)))
;-> 0 ; obscured INF (for integer math operator)

(setq b (sub (div 1 0) (div 1 0)))
;-> -1.#IND ; non obscured INF (for floating point math operator)
(inf? b)
;-> nil
(NaN? b)
;-> true

(setq x (sqrt -1))
;-> -1.#IND
(NaN? x)
;-> true
(pow x 0)
;-> 1 ; obscured NaN

(log -1)
;-> 1.#QNAN ; quiet NaN
(div (log -1) (log -1))
;-> 1.#QNAN ; quiet NaN

Possiamo anche assegnare questi valori a delle variabili e poi usarle nelle operazioni matematiche:

Not a Number
------------
(setq my-nan (div 0 0))
;-> -1.#IND
(NaN? my-nan)
;-> true
(add my-nan 1)
;-> -1.#IND
(add my-nan my-nan)
;-> -1.#IND

Ogni NaN è un Not-a-Number a modo suo e non è uguale neanche a se stesso:
(= my-nan my-nan)
;-> nil

Infinito
--------
(setq infplus (div 1 0))
;-> 1.#INF
(setq infminus (div -1 0))
;-> -1.#INF
(= infplus infminus)
;-> nil
(add infplus infminus)
;-> -1.#IND
(add infplus 1)
;-> 1.#INF

Zero
----
(setq zerominus -0.0)
;-> -0
(setq zeroplus +0.0)
;-> 0
zerominus
;-> -0
(add zerominus zeroplus)
;-> 0
(= zerominus zeroplus)
;-> true

Operazioni
----------
(div 1 infplus)
;-> 0
(div 1 infminus)
;-> -0

(atan2 0 0)
;-> 0
(atan2 0 infplus)
;-> 0
(atan2 0 zerominus)
;-> 3.141592653589793
(atan2 0 infminus)
;-> 3.141592653589793


=====================================
 CONFRONTO TRA NUMERI FLOATING-POINT
=====================================

La matematica a virgola mobile non è esatta. Valori semplici come 0.1 non possono essere rappresentati con precisione usando numeri floating-point binari, e la precisione limitata di questa rappresentazione significa che lievi cambiamenti nell'ordine delle operazioni o la precisione dei valori intermedi possono cambiare il risultato. Ciò significa che confrontare due numeri floating-point per vedere se sono uguali di solito non sempre genera un risultato corretto.

Il compilatore GCC ha anche un avvertimento per questo:

"Avviso: confrontare i numeri in virgola mobile con == oppure != non è sicuro".

Vediamo con un esempio alcuni dei problemi che possiamo incontrare.
In questo caso produciamo il numero 1 in tre modi differenti:
1. partendo da 0.0 sommiamo 0.1 per 10 volte.
2. partendo da 2.0 sottraiamo 0.1 per 10 volte.
3. moltiplichiamo 0.1 per 10.

(setq f 0.1)
(setq val1 0.0)
(setq val2 2.0)
(for (i 1 10) (setq val1 (add val1 f)))
(for (i 1 10) (setq val2 (sub val2 f)))
(setq val3 (mul f 10))
(println (format {%1.20f %1.20f %1.20f} val1 val2 val3))
;-> 0.99999999999999989000 0.99999999999999922000 1.00000000000000000000

Otteniamo tre risultati differenti e il loro confronto non è quello che volevamo:

(= val1 val2)
;-> nil
(= val2 val3)
;-> nil
(= val1 val3)
;-> nil

Come possiamo confrontare due numeri floating point?

Se confrontare i float per l'uguaglianza è una cattiva idea, allora come controllare se la loro differenza rientra nei limiti di errore o in un valore di epsilon, come questo:

se (abs(val1 - val2) <= epsilon) allora i due numeri sono (quasi) uguali.

Con questo calcolo possiamo esprimere il concetto di due float abbastanza vicini da considerarli uguali. Ma quale valore dovremmo usare per epsilon?

Data la nostra sperimentazione sopra, potremmo essere tentati di usare il machine-epsilon.
Comunque abbiamo anche visto che questo non è un valore costante, ma dipende dalla magnitudine (grandezza) dei numeri. Purtroppo non abbiamo altri numeri epsilon da utilizzare, quindi invece della differenza assoluta dobbiamo usare una comparazione relativa di epsilon e dei valori. L'idea di un confronto relativo epsilon è trovare la differenza tra i due numeri e vedere quanto è grande rispetto alla loro grandezza. Non c'è una risposta semplice a questo problema, ma per ottenere risultati coerenti, devi sempre confrontare la differenza con il più grande dei due numeri. In altre parole: per confrontare f1 e f2 occorre calcolare diff = abs (f1-f2). Se diff è inferiore a n% di max(abs(f1), abs(f2)) allora f1 e f2 possono essere considerati uguali.
La risposta più generica a questo dilemma consiste nell'utilizzare una miscela di epsilon assoluti e relativi. Se i due numeri confrontati sono estremamente vicini - qualunque cosa significhi - trattali come uguali, indipendentemente dai loro valori relativi. Questa tecnica è necessaria ogni volta che ti aspetti una risposta prossima a zero a causa della sottrazione. Il valore di epsilon assoluto deve essere basato sulla grandezza dei numeri da sottrarre (es. maxInput * machine-epsilon). Sfortunatamente ciò significa che l'uguaglianza tra due numeri dipende dall'algoritmo e dai numeri di input.

La funzione finale per confrontare due numeri floating-point è la seguente:

(define (almostEqual x y maxDiff (maxRelDiff 1e-9))
  (local (diff a b largest)
    (setq diff (abs (sub x y))) ;controlla i numeri vicini allo zero
    (setq a (abs x))
    (setq b (abs y))
    (setq largest (if (> b a) b a))
    (if (<= diff maxDiff) true
        (if (<= diff (mul largest maxRelDiff)) true nil))
  )
)

(almostEqual 1 1.000001 1e-6)
;-> true

(almostEqual 1 1.000001 1e-12)
;-> nil

Una formulazione diversa, ma fondamentalmente equivalente, è la seguente funzione:

(define (nearlyEqual a b epsilon)
  (local (absA absB diff)
    (setq Float.MAX_VALUE 3.402823466E38)
    (setq Float.MIN_NORMAL 1.175494351E-45)
    (setq absA (abs a))
    (setq absB (abs b))
    (setq diff (abs (sub a b))) ;controlla i numeri vicini allo zero
    (cond ((= a b) true) ; controlla i numeri infiniti
          ; se a o b valgono 0 o sono molto vicini a 0,
          ; allora l'errore relativo non è significativo
          ((or (zero? a) (zero? b) (< diff Float.MIN_NORMAL))
              (< diff mul(epsilon Float.MIN_NORMAL)))
          ; altrimenti usiamo l'errore relativo
          (true (< (div diff (min (add absA absB) Float.MAX_VALUE)) epsilon))
    )
  )
)

con i seguenti valori:

Double.MIN_NORMAL = 2^-1022 =
= 2.225073858507201383090232717332404064219215980462331... × 10^-308
Double.MIN_VALUE = 2^-1074 =
= 4.940656458412465441765687928682213723650598026143247... × 10^-324
Double.MAX_VALUE = (2 - 2^-52)·2^1023 =
= 1.7976931348623157081452742373170435679807056752584499... × 10^308
Float.MIN_NORMAL = 2^-126 =
= 1.1754943508222875079687365372222456778186655567720875... × 10^-38
Float.MIN_VALUE = 2^-149 =
= 1.4012984643248170709237295832899161312802619418765157... × 10^-45
Float.MAX_VALUE = (2 - 2^-23) * 2^127 =
= 3.4028234663852885981170418348451692544 × 10^38

(nearlyEqual 1 1.000001 1e-6)
;-> true

(nearlyEqual 1 1.000001 1e-12)
;-> nil

Questa funzione è valida nella maggior parte dei casi, anche se non è sempre commutativa:

(nearlyEqual a b) != (nearlyEqual b a)

Questo metodo supera i test per molti casi speciali importanti, come puoi vedere ha una logica abbastanza consistente. In particolare, occorre usare una definizione completamente diversa del margine di errore quando a o b è zero, perché in quei casi la definizione classica di errore relativo diventa priva di significato.

Ci sono alcuni casi in cui il metodo sopra produce ancora risultati imprevisti (in particolare, è molto più severo quando un valore è quasi zero rispetto a quando è esattamente zero), e alcuni dei test che sono stati sviluppati per il controllo evidenziano un comportamento che non è adatto per alcune applicazioni. Prima di usarlo, assicuratevi che sia appropriato per la vostra applicazione!

Se non siete soddisfatti di queste informazioni pratiche, potete consultate il libro: "Numerical Computing with IEEE Floating Point Arithmetic" di Michael Overton.


==========================================
 VERIFICA DELLE OPERAZIONI FLOATING-POINT
==========================================

Nel codice sorgente di newLISP possiamo trovare uno script che verifica l'aderenza di newLISP allo standard IEEE 754 nelle operazioni floating-point.
Il file si chiama "qa-float.lsp" ed è riportato di seguito:

;------------------------------------------------------
#!/usr/bin/env newLISP

; Test IEEE compliance of some FP operations and handling of 'inf' and 'NaN'
; numbers. In all versions of newLISP (32Bit and 64Bit) floating point numbers
; are represented as IEE 754 64-bit: Double (binary64) numbers.

; Thanks to Nelson H.F. Beebe <beebe@math.utah.edu> for some of the tests
; in this file

(println)
(println "Testing floating point performance")
(set-locale "C")
(set 'aNan (sqrt -1))
(set 'aInf (div 1.0 0))
(set 'aNegInf (div -1 0))
; operation on NaN result in NaN
(set 'tests '(
  "operation on NaN result in NaN"
  (NaN? (mul 1.0 aNan))
  (NaN? (div 1.0 aNan))
  (NaN? (add 1.0 aNan))
  (NaN? (sub 1.0 aNan))
  (NaN? (sin aNan))
  (NaN? (cos aNan))
  (NaN? (tan aNan))
  (NaN? (atan aNan))
  "comparison with NaN is always nil"
  (not (< 1.0 aNan))
  (not (> 1.0 aNan))
  (not (>= 1.0 aNan))
  (not (<= 1.0 aNan))
  (not (= aNan aNan))
  "NaN is not equal to itself"
  (not (= aNan aNan))
  "integer operations assume NaN as 0"
  (= (- 1 aNan) 1)
  (= (+ 1 aNan) 1)
  (= (* 1 aNan) 0)
  (not (catch (/ 1 aNan) 'error))
  (= (>> aNan) 0)
  (= (<< aNan) 0)
  "integer operations assume inf as max-int"
  (= (* 1 aInf) 9223372036854775807)
  (= (- aInf 1) 9223372036854775806)
  (= (+ aInf 1) -9223372036854775808) ; wrap around
  "FP division by inf results in 0"
  (= (/ 1 aInf) 0)
  (= (div 1 aInf) 0)
  "inf specials"
  (= aInf aInf)
  (NaN? (sub aInf aInf))
  "retain sign of -0.0"
  (= (set 'tiny (div -1 aInf)) -0.0)
  (= (sqrt tiny) -0.0)
    (= (div -1 (div 1.0 0)) -0.0)
  "inf is signed too"
  (= aNegInf (div -1 0))
  (!= aNegInf (div 1 0))
    (= (int aNegInf) -9223372036854775808)
  "mod with 0 divisor is NaN"
  (NaN? (mod 10 0))
  "% with 0 divisor throws error"
  (not (catch (% 10 0) 'error))
  )
)
(dolist (t tests)
  (if (string? t)
    (println (format "\n%-47s\n%s" t (dup "-" 47)))
    (let (result (eval t))
      (println (format "%40s => %s" (string t) (string result)))
      (push result result-list))
  )
)
(println)
(set 'result '())
(set 'u 1.0)
(while (> u 0.0) (set 'u (mul u 0.5)) (push u result))
(println "support of subnormals: " (0 2 result) " => (0 4.940656458e-324)")
(set 'epsilon 1.0)
(while (!= 1.0 (add 1.0 epsilon))
    (set 'epsilon (mul epsilon 0.5))
)
(println "machine epsilon: " epsilon  " => 1.110223025e-16")
(println)
(if
    (and
         ;(= 2.2250738585072007e-308 2.2250738585072011e-308) ; true on OSX nil on FreeBSD and Win232
         ;(= 2.2250738585072011e-308 2.2250738585072012e-308) ; true on FreeBSD and Win32 nil on OSX

         ;(= (bits (first (unpack "Lu" (pack "lf" 2.2250738585072007e-308)))) ; true on FreeBSD and Win32 nil OSX
         ;"1111111111111111111111111111111111111111111111111110")
         ;(= (bits (first (unpack "Lu" (pack "lf" 2.2250738585072007e-308)))) ; true on OSX nil on FreeBSD and Win32
         ;"1111111111111111111111111111111111111111111111111111")

         ;(= (bits (first (unpack "Lu" (pack "lf" 2.2250738585072011e-308)))) ; true on OSX and Win32 nil on FreeBSD
         ;"1111111111111111111111111111111111111111111111111111") ; 52 bits
         ;(= (bits (first (unpack "Lu" (pack "lf" 2.2250738585072011e-308)))) ; true on FreeBS nil on OSX and Win32
         ;"10000000000000000000000000000000000000000000000000000") ; 53 bits

         ; work on FreeBSD and OSX but not on Win32 XP
;         (= (bits 2.2250738585072007e-308) "0")
;         (= (bits (first (unpack "Lu" (pack "lf" 2.2250738585072012e-308))))
;         "10000000000000000000000000000000000000000000000000000")  ; 53 bits

         ; works on FreeBSD, OSX and Win32
         (= (bits (first (unpack "Lu" (pack "lf" (sqrt -1)))))
         "1111111111111000000000000000000000000000000000000000000000000000") ; 64-bits
    )
    (println "bit patterns OK")
    (println "problems in bit patterns")
)
(println)
(if-not (apply and result-list)
  (println ">>>>> PROBLEM in floating point tests")
  (println ">>>>> Floating point tests SUCCESSFUL")
)
;(exit)

L'esecuzione di questo script (load "qa-float.lsp") genera il seguente output:

-----------------------------------------------
Testing floating point performance

operation on NaN result in NaN
-----------------------------------------------
                     (NaN? (mul 1 aNan)) => true
                     (NaN? (div 1 aNan)) => true
                     (NaN? (add 1 aNan)) => true
                     (NaN? (sub 1 aNan)) => true
                       (NaN? (sin aNan)) => true
                       (NaN? (cos aNan)) => true
                       (NaN? (tan aNan)) => true
                      (NaN? (atan aNan)) => true

comparison with NaN is always nil
-----------------------------------------------
                        (not (< 1 aNan)) => true
                        (not (> 1 aNan)) => true
                       (not (>= 1 aNan)) => true
                       (not (<= 1 aNan)) => true
                     (not (= aNan aNan)) => true

NaN is not equal to itself
-----------------------------------------------
                     (not (= aNan aNan)) => true

integer operations assume NaN as 0
-----------------------------------------------
                        (= (- 1 aNan) 1) => true
                        (= (+ 1 aNan) 1) => true
                        (= (* 1 aNan) 0) => true
         (not (catch (/ 1 aNan) 'error)) => true
                         (= (>> aNan) 0) => true
                         (= (<< aNan) 0) => true

integer operations assume inf as max-int
-----------------------------------------------
      (= (* 1 aInf) 9223372036854775807) => true
      (= (- aInf 1) 9223372036854775806) => true
     (= (+ aInf 1) -9223372036854775808) => true

FP division by inf results in 0
-----------------------------------------------
                        (= (/ 1 aInf) 0) => true
                      (= (div 1 aInf) 0) => true

inf specials
-----------------------------------------------
                           (= aInf aInf) => true
                  (NaN? (sub aInf aInf)) => true

retain sign of -0.0
-----------------------------------------------
        (= (set 'tiny (div -1 aInf)) -0) => true
                      (= (sqrt tiny) -0) => true
               (= (div -1 (div 1 0)) -0) => true

inf is signed too
-----------------------------------------------
                  (= aNegInf (div -1 0)) => true
                  (!= aNegInf (div 1 0)) => true
  (= (int aNegInf) -9223372036854775808) => true

mod with 0 divisor is NaN
-----------------------------------------------
                       (NaN? (mod 10 0)) => true

% with 0 divisor throws error
-----------------------------------------------
           (not (catch (% 10 0) 'error)) => true

support of subnormals: (0 4.940656458412465e-324) => (0 4.940656458e-324)
machine epsilon: 1.110223024625157e-016 => 1.110223025e-16

bit patterns OK

>>>>> Floating point tests SUCCESSFUL
-----------------------------------------------


========================
 UNA STRANA SUCCESSIONE
========================

Sebbene newLISP implementi lo standard IEEE 754 correttamente, esistono dei calcoli che non producono il risultato corretto (casi molto rari).
Ad esempio prendiamo la seguente successione:

u(0) =  2

u(1) = -4
               1130           3000
u(n) = 111 - -------- + -----------------   per n >= 2
              u(n-1)     u(n-1) * u(n-2)

Scriviamo una funzione che calcola questa successione:

(define (test-successione n)
  (setq u0 2.0)
  (setq u1 -4.0)
  (for (i 3 n 1)
      (setq w (add (sub 111.0 (div 1130.0 u1)) (div 3000.0 (mul u1 u0))))
      (setq u0 u1)
      (setq u1 w)
      (println (format {n = %d     u = %1.17g} i u1))
  )
)

(test-successione 31)

Analizzando i valori troviamo che il risultato non è corretto:

 n     Valore calcolato               Valore esatto (calcolato con Mathematica)
  3    18.5                           18.5
  4     9.378378378378379               9.3783783783783783783...
  5     7.8011527377521688              7.8011527377521613833...
  6     7.1544144809753334              7.1544144809752493535...
 11     6.2744386627281159              6.2744385982163279138...
 12     6.2186967685821628              6.2186957398023977883...
 16     6.1660865595980994              6.0947394393336811283...
 17     7.2350211655349312              6.0777223048472427363...
 18    22.062078463525793               6.0639403224998087553...
 19    78.575574887872236               6.0527217610161521934...
 20    98.349503122165359               6.0435521101892688678...
 21    99.898569266182903               6.0360318810818567800...
 22    99.993870988902785               6.0298473250239018567...
 23    99.999630387286345               6.0247496523668478987...
 30    99.999999999998934               6.0067860930312057585...
 31    99.999999999999929               6.0056486887714202679...

Che cosa è successo?

La spiegazione di questo strano fenomeno è abbastanza semplice.
In generale la soluzione per la successione sopra definita vale:

        A*100^(n+1) + B*6^(n+1) + C*5^(n+1)
u(n) = -------------------------------------
             A*100^n + B*6^n + C*5^n

dove A, B e C dipendono dai valori iniziali u0 e u1.
Pertanto, se A = 0, allora il limite della sequenza è 100, altrimenti (assumendo B = 0), è 6.
Nell' esempio, sono stati scelti i valori iniziali u0 = 2 e u1 = -4 in modo che A = 0 e B/C = -3/4.
Pertanto, il limite esatto di u(n) è 6.
Eppure, quando si calcolano i valori usando il nostro programma, l'aritmetica floating-point utilizzata produce piccoli errori di arrotondamento, e anche i primi termini calcolati sono leggermente differenti da quelli esatti.
In questo caso, il valore di A corrispondente a questi calcoli è molto piccolo, ma diverso da zero. Questo è sufficiente per far convergere la successione al numero errato 100.
Bisogna sempre stare attenti!
Per risolvere questo problema potremmo utilizzare le frazioni intere per i calcoli e convertire la frazione finale in un numero floating-point.


===================
 OPERAZIONI SICURE
===================

Consideriamo le operazioni (add, sub, mul e div) e due numeri floating-point x e y.
In generale il risultato di una operazione (es. (add x y)) può considerarsi come il risultato esatto dell’operazione tra x ed y seguito dall’arrotondamento o dal troncamento.
Quindi è improbabile che l’esatto valore di (add x y) sia un numero floating-point.
Mentre gli errori nei singoli numeri in virgola mobile sono molto piccoli, anche calcoli semplici su di essi possono contenere insidie che aumentano l'errore nel risultato ben oltre l'avere i singoli errori "sommati".
Per cercare di contenere la propagazione degli errori ricordiamo le seguenti regole generali:

Moltiplicazione e divisione sono operazioni "sicure".

Addizione e sottrazione sono pericolose, perché quando sono coinvolti numeri di diversa ampiezza, le cifre del numero di grandezza minore vengono perse.

Questa perdita di cifre può essere inevitabile e benigna (quando le cifre perse sono anche insignificanti per il risultato finale) o catastrofica (quando la perdita viene amplificata e distorce fortemente il risultato).
Più calcoli sono fatti (specialmente quando formano un algoritmo iterativo) più è importante considerare questo tipo di problema.
Un metodo di calcolo può essere stabile (nel senso che tende a ridurre gli errori di arrotondamento) o instabile (ovvero gli errori di arrotondamento vengono ingranditi). Molto spesso, ci sono soluzioni stabili e instabili per un problema.


=======================
 QUANTO VALE PI GRECO?
=======================

newLISP non definisce alcun valore costante per pi greco.
Comunque possiamo trovarlo utilizzando le funzioni trigonometriche inverse:

(setq pi1 (mul 2.0 (acos 0.0)))
;-> 3.141592653589793
(format {%1.20f} pi1)
;-> "3.14159265358979310000"

(setq pi2 (mul 2.0 (asin 1.0)))
;-> 3.141592653589793
(format {%1.20f} pi2)
;-> "3.14159265358979310000"

Un test abbastanza conosciuto per verificare la correttezza dei numeri floating point è il calcolo della seguente espressione:

((e^pi) - pi)

(format {%1.20f} (sub (exp 3.1415926535897931) 3.1415926535897931))
;-> "19.99909997918947400000"

Il valore esatto dell'espressione calcolato con mathematica (con 60 cifre):

19.99909997918947576726644298466904449606893684322510617247

Quindi abbiamo un errore pari a (calcolato con newLISP):

(sub 19.99909997918947576726644298466904449606893684322510617247 19.99909997918947400000)
;-> 3.552713678800501e-015

Invece con mathematica l'errore calcolato vale:

1.76726644298466904449606893684322510617247e-15


==================================
 QUANTO VALE IL NUMERO DI EULERO?
==================================

newLISP non definisce alcun valore costante per il numero di Eulero "e".
Comunque possiamo trovarlo utilizzando la funzione esponenziale:

(exp x) -> e^x

(setq e (exp 1))
;-> 2.718281828459045

(format {%1.20f} e)
;-> "2.71828182845904510000"

Il valore esatto dell'espressione calcolato con mathematica (con 50 cifre):

2.71828182845904523536028747135266249775724709369995

Possiamo scrivere una funzione per calcolare il valore del numero "e" utilizzando la formula che rappresenta "e" come somma di una serie infinita: e = sum [1/k!] (k da 0 a infinito)

Scriviamo prima la funzione cha calcola il fattoriale:

(define (fattoriale n)
  (setq fact 1)
  (for (x 1 n)
    (setq fact (mul fact x))
  );for end
)

Poi scriviamo la funzione che calcola "e":

(define (print-e)
  (setq eps 1e-15) ;precisione (deve essere maggiore di machine-epsilon)
  (setq n 1)
  (setq res 1.0)  ;valore iniziale del risultato
  (setq res0 0.0) ;valore precedente del risultato
  ; Continua il calcolo fino a che il valore assoluto della differenza tra
  ; il risultato attuale e quello precedente è maggiore del valore della precisione (eps)
  (while (>= (abs (sub res res0)) eps)
    (setq res0 res)
    (setq res (add res (div 1 (fattoriale n))))
    (setq n (add n 1))
    ;(println res { ### } n)
  )
  res
)

(print-e)
;-> 2.718281828459046

Con un errore rispetto al valore fornito da newLISP pari a:

(sub (exp 1) (print-e))
;-> -4.440892098500626e-016


=====================
 TEMPO DI ESECUZIONE
=====================

Per calcolare il tempo di esecuzione di una funzione o di una espressione possiamo usare la macro "time".
La macro ha la seguente sintassi:

(time exp [int-count])

Valuta l'espressione "exp" e restituisce il tempo dedicato alla valutazione in millisecondi.
Il parametro opzionale "int-count" determina quante volte deve essere eseguita la valutazione dell'espressione exp.

Calcoliamo il tempo di esecuzione dell'espressione (add 0 1):

(time (add 0 1))
;-> 0

Questo non significa che il tempo di valutazione sia 0 (zero), ma che è inferiore ad 1 millisecondo.
Se ripetiamo la valutazione per 10 milioni di volte:

(time (add 0 1) 10000000)
;-> 312.519

Otteniamo un tempo di valutazione pari a 312.519 millisecondi.

Quindi il tempo di esecuzione dell'espressione vale (circa):

(div (time (add 0 1) 10000000) 10000000)
;-> 3.12497e-005 millisecondi

Nota: nei sistemi windows la precisione della macro "time" è di 16 msec (circa).


==================
 LISTA O VETTORE?
==================

newLISP mette a disposizione sia le liste che i vettori (anche multidimensionali). In genere la soluzione di un problema può essere fatta utilizzando una delle due strutture dati (o anche entrambe). La scelta dipende dai gusti personali anche se in genere l'algoritmo di soluzione utilizza una struttura dati specifica.
A noi però interessa sapere quale struttura è più veloce nel gestire i dati.
Per confrontare la velocità tra le liste e i vettori possiamo utilizzare il seguente programma:

; codice modificato dall'originale del libro "Introduction to newLISP"
(for (size 25 100)
  ; crea un vettore con valori random
  (set 'vettore (array size (randomize (sequence 0 size))))
  ; crea una lista con valori random
  (set 'lista (randomize (sequence 0 size)))
  ; ripete 10000 volte per avere un tempo diverso da zero
  (set 'tempo-vettore
    (int (time (dotimes (x (/ size 2))
      (nth x vettore)) 100000)))
  ; ripete 10000 volte per avere un tempo diverso da zero
  (set 'tempo-lista
    (int (time (dotimes (x (/ size 2))
      (nth x lista)) 100000)))
  (println size " elementi: tempo vettore: " tempo-vettore
    " - tempo lista: " tempo-lista
    " - l/v: " (div tempo-lista tempo-vettore )))

Riportiamo solo una parte dei risultati che dipendono (in valore assoluto) dalla velocità del computer:

25 elementi: tempo vettore: 62 - tempo lista: 62 - l/v: 1
...
50 elementi: tempo vettore: 109 - tempo lista: 140 - l/v: 1.28
...
75 elementi: tempo vettore: 156 - tempo lista: 234 - l/v: 1.5
...
100 elementi: tempo vettore: 218 - tempo lista: 343 - l/v: 1.57
...
125 elementi: tempo vettore: 265 - tempo lista: 453 - l/v: 1.70
...
150 elementi: tempo vettore: 343 - tempo lista: 625 - l/v: 1.82
...
175 elementi: tempo vettore: 390 - tempo lista: 781 - l/v: 2.00
...
200 elementi: tempo vettore: 421 - tempo lista: 968 - l/v: 2.29
...
225 elementi: tempo vettore: 484 - tempo lista: 1140 - l/v: 2.35
...
250 elementi: tempo vettore: 546 - tempo lista: 1390 - l/v: 2.54

Notiamo che fino a 50 elementi la lista e il vettore hanno la stessa velocità e aumentando il numero di elementi il vettore aumenta la differenza di velocità con la lista: con 250 elementi il vettore è 2.5 volte più veloce della lista.

Inoltre, il calcolo della lunghezza di una lista è una operazione onerosa in termini di tempo (perchè non è un valore costante come nei vettori).

(silent (setq a (sequence 1 1000000)))
(time (length a))
;-> 15.629

(silent (setq vec (array (length a) a)))
(time (length vec))
;-> 0


=========
 VETTORI
=========

I vettori (array) di newLISP consentono un accesso rapido agli elementi all'interno di liste di grandi dimensioni. I vettori possono essere costruiti e inizializzati con il contenuto di una lista esistente. Le liste possono essere convertite in vettori e viceversa.
La maggior parte delle funzioni utilizzate per accedere e modificare le liste può essere applicata anche ai vettori. I vettori possono contenere qualsiasi tipo di dati o una combinazione di questi.
In particolare, è possibile utilizzare le seguenti funzioni per creare, accedere e modificare i vettori:

Funzione     Descrizione
--------     -----------
append       appends arrays
apply        apply a function or operator to a list of arguments.
array        creates and initializes an array with up to 16 dimensions
array-list   converts an array into a list
array?       checks if expression is an array
corr         calculates the product-moment correlation coefficient
det          returns the determinant of a matrix
dolist       evaluates once for each element in an array vector
first        returns the first row of an array
invert       returns the inversion of a matrix
last         returns the last row of an array
length       returns the number of rows in an array or elements in a vector
map          applies a function to vector(s) of arguments and returns results in a list.
mat          perform scalar operations on matrices
multiply     multiplies two matrices
nth          returns an element of and array
rest         returns all but the first row of an array
reverse      reverses the elements or rows in an array
setf         sets contents of an array reference
slice        returns a slice of an array
sort         sort the elements in an array
stats        calculates some basic statistics for a data vector
t-test       compares means of data samples using the Student's t statistic
transpose    transposes a matrix

newLISP rappresenta matrici multidimensionali con una matrice di matrici (vale a dire, gli elementi dell'array sono matrici stesse).
Se utilizzato in modo interattivo, newLISP stampa e visualizza i vettori come le liste, senza alcun modo di distinguerli.
Utilizzare le funzioni source o save per serializzare i vettori (o le variabili che li contengono). L'istruzione array è inclusa come parte della definizione durante la serializzazione degli array.
Come gli elenchi, è possibile utilizzare indici negativi per enumerare gli elementi di un array, a partire dall'ultimo elemento.
Un indice "out-of-bounds" causerà un messaggio di errore su un vettore o una lista.
Le matrici possono essere non rettangolari, ma sono rese rettangolari durante la serializzazione quando si utilizza source o save. La funzione array costruisce sempre matrici di forma rettangolare.
Le funzioni matriciali det, transpose, multiply e invert possono essere utilizzate su matrici costruite con liste annidate o vettori costruiti con array.

******************
>>>funzione ARRAY
******************
sintassi: (array int-n1 [int-n2 ...] [list-init])

Crea un vettore con elementi int-n1, inizializzandolo opzionalmente con il contenuto di list-init. Possono essere specificate fino a sedici dimensioni per i vettori multidimensionali (matrici).

Internamente, newLISP crea vettori multidimensionali usando i vettori come elementi di un vettore. I vettori in newLISP dovrebbero essere utilizzati ogni volta che l'indicizzazione random in una lista di grandi dimensioni diventa troppo lenta. Non tutte le funzioni applicabili alle liste possono essere utilizzate sui vettori.

(array 5)
;-> (nil nil nil nil nil)

(array 5 (sequence 1  5))
;-> (1 2 3 4 5)

(array 10 '(1 2))
;-> (1 2 1 2 1 2 1 2 1 2)

I vettori possono essere inizializzati con oggetti di qualsiasi tipo. Se vengono forniti meno valori di inizializzazione degli elementi disponibili, allora la lista viene ripetuto finché tutti gli elementi del vettore non vengono inizializzati.

(set 'myarray (array 3 4 (sequence 1 12)))
;-> ((1 2 3 4) (5 6 7 8) (9 10 11 12))

L'accesso e la modifica dei valori dei vettori vengono effettuati utilizzando la maggior parte delle stesse funzioni utilizzate per modificare le liste.

(setf (myarray 2 3) 99)
;-> 99
myarray
;-> ((1 2 3 4) (5 6 7 8) (9 10 11 99))

(setf (myarray 1 1) "hello")
;-> "hello"

myarray
;-> ((1 2 3 4) (5 "hello" 7 8) (9 10 11 99))

(setf (myarray 1) '(a b c d))
;-> (a b c d)
myarray
;-> ((1 2 3 4) (a b c d) (9 10 11 99))

(nth 1 myarray)
;-> (a b c d)  ; accesso ad una riga intera

;; indicizzazione implicita e slicing sui vettori

(myarray 1)
;-> (a b c d)

(myarray 0 -1)
;-> 4

(2 myarray)
;-> ((9 10 11 99))

(-3 2 myarray)
;-> ((1 2 3 4) (a b c d))

Bisogna fare attenzione ad usare un vettore quando si sostituisce un'intera riga.

La funzione array-list può essere usata per convertire un vettore in una lista:

(array-list myarray)
;-> ((1 2 3 4) (a b c d) (1 2 3 99))

Per riconvertire la lista in un vettore, applicare la funzione flat alla lista:

(set 'aList '((1 2) (3 4)))
;-> ((1 2) (3 4))

(set 'aArray (array 2 2 (flat aList)))
;->  ((1 2) (3 4))

La funzione "array?" la funzione può essere utilizzata per verificare se un'espressione è un vettore:

(array? myarray)
;-> true
                               
(array? (array-list myarray))
;-> nil

Quando si serializzano i vettori usando le funzioni "source" o "save", il codice generato include la dichiarazione necessaria per la loro creazione. In questo modo, le variabili che contengono i vettori sono serializzate correttamente quando si salva con la funzione "save" o si creano stringhe di sorgenti usando la funzione "source".

(set 'myarray (array 3 4 (sequence 1 12)))

(save "array.lsp" 'myarray)

;; contents of file arraylsp ;;

(set 'myarray (array 3 4 (flat '(
  (1 2 3 4)
  (5 6 7 8)
  (9 10 11 12)))))


=============================================
 INDICIZZAZIONE DI STRINGHE, LISTE E VETTORI
=============================================

Alcune funzioni accettano vettori, liste o gli elementi di una stringa (caratteri) specificati da uno o più int-index (indice intero). Gli indici positivi hanno valori in sequenza da 0, 1, ..., N-2, N-1, dove N è il numero di elementi nell'elenco. Se int-index è negativo, la sequenza è -N, -N + 1, ..., -2, -1. L'aggiunta di N ad un indice negativo di un elemento produce un indice positivo. A meno che una funzione non sia scritta appositamente, un indice maggiore di N-1 o minore di -N causa un errore "out-of-bounds" su liste e vettori.

Indicizzazione esplicita
------------------------
La funzione "nth" accede ad un elemento di una stringa, di una lista o di un vettore.

****************
>>>funzione NTH
****************
sintassi: (nth int-index list)
sintassi: (nth int-index array)
sintassi: (nth int-index str)

sintassi: (nth list-indices list)
sintassi: (nth list-indices array)

Nel primo gruppo di sintassi "nth" usa il valore di int-index per individuare un indice in una lista, un vettore o una stringa e restituisce l'elemento trovato a quell'indice.
È possibile specificare più indici per accedere in modo ricorsivo a elementi in liste o vettori annidati. Se ci sono più indici che livelli di annidamento, gli indici extra vengono ignorati. Quando vengono utilizzati più indici, devono essere inseriti in una lista come mostrato nel secondo gruppo di sintassi.

(set 'L '(a b c))
(nth 0 L)
;->  a

; o semplicemente
(L 0)
;-> a

(set 'names '(john martha robert alex))
;-> (john martha robert alex)

(nth 2 names)
;-> robert

; o semplicemente
(names 2)
;-> robert

(names -1)
;-> lex

; indici multipli
(set 'persons '((john 30) (martha 120) ((john doe) 17)))

(persons 1 1)
;-> 120

(nth '(2 0 1) persons)
;-> doe

; o semplicemente
(persons 2 0 1)
;-> doe

; indici multipli in un vettore
(set 'v '(2 0 1))
(persons v)
;-> doe
(nth v persons)
;-> doe

; indici negativi
(persons -2 0)
;-> martha

; out-of-bounds indices cause error
(persons 10)
;-> ERR: list index out of bounds

(person -5)
;-> ERR: list index out of bounds

La lista L può essere il contesto del funtore predefinito L:L. Questo consente di passare liste per riferimento:

(set 'L:L '(a b c d e f g))

(define (second ctx)
  (nth 1 ctx))

(reverse L)
;-> (g f e d c b a)
L:L
;-> (g f e d c b a)

;; passare la lista in L:L per riferimento (by reference)
(second L)
;-> b

;; passare la lista in L:L per valore (by value)
(second L:L)
;-> b

Il passaggio di riferimenti è più veloce e utilizza meno memoria in elenchi di grandi dimensioni e deve essere utilizzato su elenchi con più di poche centinaia di elementi.

Si noti che la versione di indicizzazione implicita di nth non infrange le regole di sintassi di newLISP, ma dovrebbe essere intesa come un'espansione logica delle  regole di sintassi di newLISP in altri tipi di dati rispetto alle funzioni integrate o alle espressioni lambda. Una lista nella posizione del functor di una s-espressione assume la funzionalità di autoindicizzazione utilizzando gli argomenti seguenti come indici.

Le forme di sintassi indicizzate implicite sono più veloci, ma l'altra forma con "n-th" esplicito può essere più leggibile in alcune situazioni.

nth funziona sui vettori proprio come fa sulle liste:

(set 'aArray (array 2 3 '(a b c d e f)))
;->  ((a b c) (d e f))
(nth 1 aArray)
;->  (d e f)
(aArray 1)
;->  (d e f)

(nth '(1 0) aArray)
;-> d
(aArray 1 0)
;-> d
(aArray '(1 0))
;-> d

(set 'vec '(1 0))
(aArray vec)
;-> d

Nella versione per le stringhe, nth restituisce il carattere trovato nella posizione int-index della stringa str e lo restituisce come una stringa.

(nth  0 "newLISP")
;-> "n"

("newLISP" 0)
;-> "n"

("newLISP" -1)
;-> "P"

Nota che "nth" funziona sui caratteri piuttosto che sui limiti dei byte quando si utilizza la versione UTF-8 di newLISP. Per accedere ai buffer delle stringhe ASCII e binarie sui limiti dei singoli byte utilizzare la funzione "slice".

Vedi anche "setf" per la modifica di liste e matrici multidimensionali e "push" e "pop" per modificare gli elenchi.

Indicizzazione implicita
------------------------
È possibile utilizzare l'indicizzazione implicita anziché la funzione "nth" per accedere agli elementi di una lista o di un vettore o ai caratteri di una stringa:

(set 'lst '(a b c (d e) (f g)))

(lst 0)    → a      ; uguale a (nth 0 lst)
(lst 3)    → (d e)
(lst 3 1)  → e      ; uguale a (nth '(3 1) lst)
(lst -1)   → (f g)

(set 'myarray (array 3 2 (sequence 1 6)))

(myarray 1)     → (3 4)
(myarray 1 0)   → 3
(myarray 0 -1)  → 2

; indicizzazione di una stringa ASCII
("newLISP" 3)   → "L"

; indicizzaione di una stringa in newLISP UTF8
 ("我能吞下玻璃而不伤身体。" 3) → "下"

Gli indici possono anche essere forniti da una lista. In questo modo, l'indicizzazione implicita funziona insieme a funzioni che prendono o producono indici di vettori, come "push", "pop", "ref" e "ref-all".

(lst '(3 1))
;-> e
(set 'vec (ref 'e lst))
;-> (3 1)
(lst vec)
;-> e

Si noti che l'indicizzazione implicita non infrange le regole di sintassi di newLISP, ma è semplicemente un'espansione delle regole esistenti per altri tipi di dati nella posizione del funtore di una s-espressione. Nel Lisp originale, il primo elemento di un elenco di una s-espressione viene applicato come una funzione agli elementi restanti che vengono presicome argomenti. In newLISP, una lista nella posizione del funtore di una s-espressione assume la funzionalità di autoindicizzazione utilizzando gli argomenti che seguono come indici.

L'indicizzazione implicita è più veloce delle forme esplicite, ma le forme esplicite possono essere più leggibili a seconda del contesto.

Si noti che nella versione di newLISP abilitata a UTF-8, l'indicizzazione implicita delle stringhe o l'uso della funzione nth funzionano sul carattere anziché sui limiti di un a byte singolo.

Indicizzazione implicita e funtore predefinito
----------------------------------------------
Il funtore predefinito è un functor all'interno di un contesto con lo stesso nome del contesto. (vedi il capitolo sui Contesti). È possibile utilizzare un funtore predefinito insieme all'indicizzazione implicita per fungere da meccanismo di riferimento per le liste:

(set 'MyList:MyList '(a b c d e f g))

(MyList 0)
;-> a
(MyList 3)
;-> d
(MyList -1)
;-> g

(3 2 MyList)
;-> (d e)
(-3 MyList)
;-> (e f g)

(set 'aList MyList)

(aList 3)
;-> d

In questo esempio, aList fa riferimento a MyList:MyList, non ad una copia di essa.

Il funtore predefinito indicizzato può anche essere utilizzato con "setf" come mostrato nell'esempio seguente:

(set 'MyList:MyList '(a b c d e f g))

(setf (MyList 3) 999)
;-> 999
(MyList 3)
;-> 999

MyList:MyList
;-> (a b c 999 e f g)

Indicizzazione implicita per "rest" e "slice"
---------------------------------------------
È possibile creare forme implicite di "rest" e "slice" anteponendo ad una lista uno o due numeri per l'offset e la lunghezza. Se la lunghezza è negativa, il conto avviene dalla fine della lista o della stringa:

(set 'lst '(a b c d e f g))
; or as array
(set 'lst (array 7 '(a b c d e f g)))

(1 lst)      → (b c d e f g)
(2 lst)      → (c d e f g)
(2 3 lst)    → (c d e)
(-3 2 lst)   → (e f)
(2 -2 lst)   → (c d e)

; rest e slice funzionano sempre sui limiti dei caratteri a 8-bit anche con versioni abilitate per UTF8

(set 'str "abcdefg")

(1 str)      → "bcdefg"
(2 str)      → "cdefg"
(2 3 str)    → "cde"
(-3 2 str)   → "ef"
(2 -2 str)   → "cde"

Le funzioni "rest", "first" e "last" funzionano sui limiti dei caratteri multibyte nelle versioni abilitate UTF-8 di newLISP. Ma i moduli di indicizzazione impliciti per le funzioni "slice" e "rest"slicing e resting funzioneranno sempre sui limiti a byte singolo e possono essere utilizzati per il contenuto binario. I risultati di offset e lunghezza delle funzioni per le espressione regolare "find" e "regex" utilizzano il conteggio a byte singolo e possono essere ulteriormente elaborati con "slice" o la sua forma implicita.

Modifica degli elementi di una lista, un vettore o una stringa
--------------------------------------------------------------
Gli elementi a cui si fa riferimento per indici nelle liste, nei vettori e nelle stringhe possono essere modificati usando "setf":
; lists

(set 'lst '(a b c d (e f g)))

(lst 1)
;-> b

(setf (lst 1) 'z)
;-> z

lst
;-> (a z c d (e f g))

(setf (lst -1) '(E F G))
;-> (E F G)

lst
;-> (a z c d (E F G))

; arrays

(set 'myarray (array 2 3 (sequence 1 6)))
;-> ((1 2 3) (4 5 6))

(setf (myarray 1 2) 66)
;-> 66

myarray
;-> ((1 2 3) (4 5 66))

; strings

(set 's "newLISP")

(setf (s 0) "n")
;-> "n"

s
;-> "newLISP"

Si noti che solo gli elementi completi di liste annidate o dei vettori possono essere modificati in questo modo. Gli slice e il rest di una lista o di un vettore non possono essere modificati utilizzando "setf", ma dovrebbero essere sostituiti elemento per elemento. Nelle stringhe può essere sostituito un solo carattere alla volta, ma quel carattere può essere sostituito da una stringa multi-carattere.


====================================
 ATTRAVERSAMENTO DI LISTE E VETTORI
====================================

Proviamo la velocità di attraversare le liste e i vettori delle funzioni "dolist" e "for":

Definiamo un vettore di 100000 elementi:
(silent (setq arr (array 100000 (sequence 1 100000))))

Definiamo una lista di 100000 elementi:
(silent (setq lst (array-list arr)))

Definiamo tre funzioni che fanno la stessa cosa (costruiscono una lista) con le seguenti varianti:

1) Uso di "dolist" con la lista

(define (try-list lst)
  (setq outlst '())
  (dolist (el lst)
    (push el outlst -1)
  )
)

2) Uso di "dolist" con il vettore

(define (try-array-as-list arr)
  (setq outarr '())
  (dolist (el arr)
    (push el outarr -1)
  )
)

3) Uso di "for" per la lista:

(define (try-list-as-array arr)
  (setq outlst-arr '())
  (setq fine (- (length lst) 1))
  (for (i 0 fine)
    (push (arr i) outlst-arr -1)
  )
)

4) Uso di "for" per il vettore:

(define (try-array arr)
  (setq outarr '())
  (setq fine (- (length arr) 1))
  (for (i 0 fine)
    (push (arr i) outarr -1)
  )
)

Vediamo i tempi di calcolo:

(time (try-list lst) 10)
;-> 93.77
(length outlst)
;-> 100000

(time (try-array-as-list lst) 10)
;-> 93.578

(time (try-list-as-array lst) 10)
;-> 80869.0 ; 80 secondi
(length outlst-arr)
;-> 100000

(time (try-array arr) 10)
;-> 93.765
(length outarr)
;-> 100000

Nota: Usare "dolist" per attraversare le liste e usare "for" o "dolist" per attraversare i vettori.
Non usare "for" per attraversare una lista (l'indicizzazione di una lista (lst i) è un'operazione onerosa).


=============================
 ATTRAVERSAMENTO DI STRINGHE
=============================

Proviamo la velocità di attraversare le liste e i vettori delle funzioni " dostring", "dolist" e "for":

1) Uso di "dostring" con la stringa

(setq str "abcd")
;-> "abcd"
(dostring (c str)
  (println (char c) { } c)
)
;-> a 97
;-> b 98
;-> c 99
;-> d 100

Nota: L'indice di "dostring" (es. c) contiene il valore ASCII del carattere (intero).
Per ottenere il carattere occorre applicare la funzione "char" (es. (char c)).

2) Uso di "dolist" con la lista ottenuta dalla stringa con "explode"

(setq str "abcd")
;-> "abcd"
(setq lst (explode str))
;-> ("a" "b" "c" "d")
(dolist (c lst)
  (println (char c ) { } c)
)
;-> 97 a
;-> 98 b
;-> 99 c
;-> 100 d

3) Uso di "for" sulla stringa

(setq str "abcd")
;-> "abcd"
(for (i 0 (- (length str) 1))
  (println (char (str i)) { } (str i))
)
;-> 97 a
;-> 98 b
;-> 99 c
;-> 100 d

4) Uso di "for" con la lista ottenuta dalla stringa con "explode"

(setq str "abcd")
;-> "abcd"
(setq lst (explode str))
;-> ("a" "b" "c" "d")
(for (i 0 (- (length lst) 1))
  (println (lst i) { } (char (lst i)))
)
;-> a 97
;-> b 98
;-> c 99
;-> d 100

Proviamo la velocità dei quattro metodi:

(silent (setq str (dup "-" 2000)))
(silent (setq lst (explode str)))

(time (dostring (c str) (setq a (char c))) 10000)
;-> 3406.351
(time (dolist (c lst) (setq a (char c))) 10000)
;-> 3688.129
(time (for (i 0 (- (length str) 1)) (setq a (char (str i)))) 10000)
;-> 44769.743
(time (for (i 0 (- (length lst) 1)) (setq a (char (lst i)))) 10000)
;-> 33721.979

Nota: Usare "dostring" oppure "dolist" per attrversare le stringhe.


================================================
 USCITA ANTICIPATA DA FUNZIONI, CICLI E BLOCCHI
================================================

Quelli che seguono sono i metodi per interrompere il flusso di controllo all'interno dei cicli e delle espressioni "begin".

Le funzioni di ciclo "for", "dolist" e "dotimes" possono avere espressioni condizionali opzionali che permettono di uscire dal ciclo in anticipo. "catch" e throw sono una forma più generale per uscire da un ciclo e sono applicabili anche ad altre forme o blocchi di istruzioni.


Usando "catch" e "throw"
------------------------
Poiché newLISP è un linguaggio funzionale, non utilizza le istruzioni "break" o "return" per uscire da funzioni o iterazioni. Invece, è possibile uscire da un blocco o una funzione in qualsiasi momento usando le funzioni catch e throw:

(define (foo x)
    ...
    (if condition (throw 123))
    ...
    456
)

;; se la condizione è vera

(catch (foo p))
;-> 123

;; se la condizione non è vera

(catch (foo p))
;-> 456

L'interruzione dei cicli loop funziona in modo simile:

(catch
    (dotimes (i N)
        (if (= (foo i) 100) (throw i))))

;-> valore di i quando foo (i) è uguale a 100

L'esempio mostra come è possibile uscire da un ciclo iterativo prima che venga eseguito N volte.

Punti di ritorno multipli possono essere codificati usando l'espressione "throw":

(catch (begin
    (foo1)
    (foo2)
    (if condition-A (throw 'x))
    (foo3)
    (if condition-B (throw 'y))
    (foo4)
    (foo5)))

Se la condizione-A è vera, x sarà restituito dall'espressione "catch", se la condizione-B è vera, il valore restituito è y. In caso contrario, il risultato di foo5 verrà utilizzato come valore di ritorno.

Esempio di catch che simula l'espressione "continue" nella funzione "dolist":

(dolist (el lst)
  (catch
     (if (= el 'e) (throw nil)
         (println el))
  )
)

Esempio di catch in una funzione:

(define (prova n)
  (catch
    (local (x)
      (if (< n 0) (throw true))
      (for (i 0 100)
        (if (= i n) (throw i))
      )
      (throw "end")
    )
  )
)

(prova -1)
;-> true

(prova 10)
;-> 10

(prova 101)
;-> "end"

Esempio di catch nidificati in una funzione:

(define (prova2 n)
  (catch
    (local (x)
      (if (< n 0) (throw "primo catch"))
      (catch
        (for (i 0 100)
          (if (= i n) (throw (println i " secondo catch")))
        )
      )
      (println "...continua")
      (if (> n 100) (throw "maggiore: first catch"))
      (println "normale")
    )
  )
)

(prova2 -1)
;-> "primo catch"

(prova2 10)
;-> 10 secondo catch
;-> ...continua
;-> normale

(prova2 101)
;-> ...continua
;-> "maggiore: first catch"

Oltre alla funzione "catch", possiamo usare la funzione di "error-event" per rilevare errori causati da codice errato o eccezioni avviate dall'utente.

La funzione "throw-error" può essere utilizzata per generare errori definiti dall'utente.


======================================
 LAVORARE CON FILE DI DATI (FILE I/O)
======================================

In genere i dati sono memorizzati su file con differenti formati. La prima distinzione è il tipo di file: binario o testo (ASCII). Per adesso prendiamo in considerazione i file di testo (cioè quelli che possono essere letti e/o creati con un qualsiasi editor di testi).
Consideriamo i seguenti due file di dati:

data.txt
1 2 3 4 5
6 7 8 9 0
a b c d e
f g h i j

dataCSV.txt
1,2,3,4,5
6,7,8,9,0
a,b,c,d,e
f,g,h,i,j

newLISP ha la funzione "read-file" che permette di leggere tutto il contenuto di un file e restituirlo come stringa:

(setq datastring (read-file "data.txt"))
;-> "1 2 3 4 5\r\n6 7 8 9 0\r\na b c d e\r\nf g h i j"

Adesso dobbiamo trasformare questa stringa in una lista di stringhe delimitate dal carattere di fine linea (eol - end of line). La funzione "parse" fa proprio questo, suddivide una stringa in sottostringhe basandosi su un delimitatore (in windows il delimitatore di fine linea è "\r\n", mentre su UNIX è "\n"):

(setq data (parse datastring "\r\n"))
;-> ("1 2 3 4 5" "6 7 8 9 0" "a b c d e" "f g h i j")

Adesso se vogliamo ottenere una lista per ogni riga, basta mappare la funzione "list" sugli elementi della lista data:

(map list data)
;-> (("1 2 3 4 5") ("6 7 8 9 0") ("a b c d e") ("f g h i j"))

Notiamo che applicando la funzione "sym" otteniamo una lista di simboli:

(length (map sym data))
;-> (1 2 3 4 5 6 7 8 9 0 a b c d e f g h i j)

Quindi se vogliamo avere i simboli al posto delle stringhe nella lista finale, possiamo scrivere:

(setq data (map list (map sym data)))
;-> ((1 2 3 4 5) (6 7 8 9 0) (a b c d e) (f g h i j))

Abbiamo ottenuto una lista le cui sottoliste rappresentano le righe del file di dati.

Purtroppo non è il risultato voluto, poichè ogni sottolista è composta da un solo elemento:

(length (first data))
;-> 1

(first (first data))
;-> 1 2 3 4 5

Questo è dovuto al fatto che abbiamo applicato la funzione "sym" ad ogni elemento della lista (es. (1 2 3 4 5)),
non ad ogni elemento delle sottoliste (es. 1).

Per capire meglio, ripartiamo dall'inizio:

Leggiamo il file su una stringa:

(setq datastring (read-file "data.txt"))
;-> "1 2 3 4 5\r\n6 7 8 9 0\r\na b c d e\r\nf g h i j"

Dividiamo la stringa in sottostringhe delimitate da eol:

(setq data (parse datastring "\r\n"))
;-> ("1 2 3 4 5" "6 7 8 9 0" "a b c d e" "f g h i j")

Possiamo applicare nuovamente la funzione "parse" sulla striga "data" utilizzando come separatore il carattere spazio " ":

(setq data (map (fn (x) (parse x " ")) data))
;-> (("1" "2" "3" "4" "5") ("6" "7" "8" "9" "0") ("a" "b" "c" "d" "e") ("f" "g" "h" "i" "j"))

Adesso possiamo applicare la funzione "sym":

(setq data (map (fn (x) (map sym x)) data))
;-> ((1 2 3 4 5) (6 7 8 9 0) (a b c d e) (f g h i j))

Controlliamo il risultato:

(length (first data))
;-> 5

(first (first data))
;-> 1

Sembra tutto corretto, ma cosa succede se i valori nel file sono separati da un numero differente di spazi " "?

data2.txt
1  2   3 4   5
6   7 8 9   0
a b    c d   e
f g h    i j

Se vogliamo ignorare gli spazi ripetuti, allora possiamo usare una espressione regolare nella la funzione "parse":

(setq data (map (fn (x) (parse x " +" 0)) data))

Il parametro "0" indica a newLISP di trattare la stringa " +" come un pattern di una espressione regolare. In particolare " +" significa: qualunque numero di spazi.

Quindi le istruzioni finali sono le seguenti:

(setq datastring (read-file "data2.txt"))
(setq data (parse datastring "\r\n"))
(setq data (map (fn (x) (parse x " +" 0)) data))
(setq data (map (fn (x) (map sym x)) data))
;-> ((1 2 3 4 5) (6 7 8 9 0) (a b c d e) (f g h i j))

Per quanto riguarda il file "dataCSV.txt", notiamo che è in formato CSV (Comma Separated Value).
Possiamo utilizzare lo stesso metodo che abbiamo visto per il file "data.txt", purchè venga utilizzato il carattere virgola "," come separatore:

Leggiamo il file in una stringa:

(setq datastring (read-file "dataCSV.txt"))
;-> "1,2,3,4,5\r\n6,7,8,9,0\r\na,b,c,d,e\r\nf,g,h,i,j"

Dividiamo la stringa in sottostringhe delimitate da eol:

(setq data (parse datastring "\r\n"))
;-> ("1,2,3,4,5" "6,7,8,9,0" "a,b,c,d,e" "f,g,h,i,j")

Applichiamo la funzione "parse" sulla striga "data" utilizzando come separatore il carattere virgola ",":

(setq data (map (fn (x) (parse x ",")) data))
;-> (("1" "2" "3" "4" "5") ("6" "7" "8" "9" "0") ("a" "b" "c" "d" "e") ("f" "g" "h" "i" "j"))

Applichiamo la funzione "sym":

(setq data (map (fn (x) (map sym x)) data))
;-> ((1 2 3 4 5) (6 7 8 9 0) (a b c d e) (f g h i j))

Controlliamo il risultato:

(length (first data))
;-> 5

(first (first data))
;-> 1

Ok. Ma cosa succede se abbiamo dei valori mancanti nel file di dati?

data2CSV.txt
,2,3,4,5
6,7,,,0
a,b,c,,e
f,g,h,i,

(setq datastring (read-file "data2CSV.txt"))
;-> ",2,3,4,5\r\n6,7,,,0\r\na,b,c,,e\r\nf,g,h,i,"

Dividiamo la stringa in sottostringhe delimitate da eol:

(setq data (parse datastring "\r\n"))
;-> (",2,3,4,5" "6,7,,,0" "a,b,c,,e" "f,g,h,i,")

Applichiamo la funzione "parse" sulla striga "data" utilizzando come separatore il carattere virgola ",":

(setq data (map (fn (x) (parse x ",")) data))
;-> (("" "2" "3" "4" "5") ("6" "7" "" "" "0") ("a" "b" "c" "" "e") ("f" "g" "h" "i" ""))

Adesso prima di applicare la funzione "sym", trasformiamo i valori "" con quello che vogliamo (ad esempio "null"):

(setq data (map (fn (x) (replace "" x "null")) data))
;-> (("null" "2" "3" "4" "5") ("6" "7" "null" "null" "0") ("a" "b" "c" "null" "e") ("f" "g" "h" "i" "null"))

Adesso possiamo applicare la funzione "sym":

(setq data (map (fn (x) (map sym x)) data))
;-> ((null 2 3 4 5) (6 7 null null 0) (a b c null e) (f g h i null))

Quindi le istruzioni finali per un file CSV sono le seguenti:

(setq datastring (read-file "data2CSV.txt"))
(setq data (parse datastring "\r\n"))
(setq data (map (fn (x) (parse x ",")) data))
(setq data (map (fn (x) (replace "" x "null")) data))
(setq data (map (fn (x) (map sym x)) data))
;-> ((null 2 3 4 5) (6 7 null null 0) (a b c null e) (f g h i null))

A questo punto siamo in grado di scrivere una funzione che importa i nostri file di dati:

(define (leggi-dati file delim sep tipo vuoto)
  (local (datastring data)
    (setq datastring (read-file file))
    (setq data (parse datastring "\r\n"))
    (if (= sep " ")
        (setq data (map (fn (x) (parse x (append " " "+") 0)) data)) ; file separato da spazi
        (begin
          (setq data (map (fn (x) (parse x sep)) data)) ; file separato con altro separatore
          (setq data (map (fn (x) (replace "" x vuoto)) data)) ; modifica i valori vuoti
        )
    )
    ; converto in simboli?
    (if (= tipo "sim") (setq data (map (fn (x) (map sym x)) data)))
    data
  );local
)

Facciamo alcune prove:

(leggi-dati "data.txt" "\r\n" " " "str" "-1")
;-> (("1" "2" "3" "4" "5") ("6" "7" "8" "9" "0") ("a" "b" "c" "d" "e") ("f" "g" "h" "i" "j"))

(leggi-dati "data2.txt" "\r\n" " " "sim" "-1")
;-> ((1 2 3 4 5) (6 7 8 9 0) (a b c d e) (f g h i j))

(leggi-dati "dataCSV.txt" "\r\n" "," "sim" "-1")
;-> ((1 2 3 4 5) (6 7 8 9 0) (a b c d e) (f g h i j))

(leggi-dati "data2CSV.txt" "\r\n" "," "sim" "-1")
;-> ((-1 2 3 4 5) (6 7 -1 -1 0) (a b c -1 e) (f g h i -1))

Nota:
(setq lst (leggi-dati "data2CSV.txt" "\r\n" "," "sim" "-1"))
;-> ((-1 2 3 4 5) (6 7 -1 -1 0) (a b c -1 e) (f g h i -1))
(setq a 99999)
;-> 99999
(eval (nth '(2 0) lst))
;-> 99999

Possiamo quindi creare da un file una lista con sottoliste di simboli e poi assegnare i valori senza utilizzare alcun tipo di indicizzazione.

Nota: Questa funzione carica il file completamente in memoria.

In altri casi potremmo avere la necessità di leggere il file linea per linea ed elaborare ogni linea fino al raggiungimento della fine del file. Per fare questo dobbiano utilizzare le funzioni "open", "read-line" e "close".

(define (read-data file sep)
  (setq lst '()) ; lista dei dati
  ; apre il file in lettura (e assegna un numero di device a in-file)
  (setq in-file (open file "read"))
  (while (read-line in-file) ; legge il file linea per linea
    (setq data-linea (parse (current-line) sep)) ; lista con i dati della linea in formato stringa
    ; Adesso possiamo elaborare i dati della linea corrente ("1" "2" "3" "4" "5")...
    ;(println (current-line))
    (println data-linea)
    (setq lst (push data-linea lst -1)) ; aggiunge la linea corrente alla lista dati
  )
  (close in-file) ; chiude il file
  lst
)

Proviamo a leggere i nostri file di esempio:

(read-data "data.txt" " ")
;-> ("1" "2" "3" "4" "5")
;-> ("6" "7" "8" "9" "0")
;-> ("a" "b" "c" "d" "e")
;-> ("f" "g" "h" "i" "j")
;-> (("1" "2" "3" "4" "5") ("6" "7" "8" "9" "0") ("a" "b" "c" "d" "e") ("f" "g" "h" "i" "j"))

(read-data "data2.txt" " ")
("1" "" "2" "" "" "3" "4" "" "" "5")
("6" "" "" "7" "8" "9" "" "" "0")
("a" "b" "" "" "" "c" "d" "" "" "e")
("f" "g" "h" "" "" "" "i" "j")
(("1" "" "2" "" "" "3" "4" "" "" "5") ("6" "" "" "7" "8" "9" "" "" "0") ("a" "b" "" "" "" "c" "d" "" "" "e") ("f" "g" "h" "" "" "" "i" "j"))

(read-data "dataCSV.txt" ",")
;-> ("1" "2" "3" "4" "5")
;-> ("6" "7" "8" "9" "0")
;-> ("a" "b" "c" "d" "e")
;-> ("f" "g" "h" "i" "j")
;-> (("1" "2" "3" "4" "5") ("6" "7" "8" "9" "0") ("a" "b" "c" "d" "e") ("f" "g" "h" "i" "j"))

(read-data "data2CSV.txt" ",")
;-> ("" "2" "3" "4" "5")
;-> ("6" "7" "" "" "0")
;-> ("a" "b" "c" "" "e")
;-> ("f" "g" "h" "i" "")
;-> (("" "2" "3" "4" "5") ("6" "7" "" "" "0") ("a" "b" "c" "" "e") ("f" "g" "h" "i" ""))

Questo metodo ci permette di eleborare i dati linea per linea (e poi elemento per elemento).

Per scrivere in un file dobbiamo usare le funzioni  le funzioni "open", "write-line" e "close".
Le seguenti linee visualizzano il file "data.txt":

(setq datafile (open "data.txt" "read"))
;-> 4 ; numero device associato al file data.txt
(while (read-line datafile) (write-line)) ; stampiamo il file linea per linea
;-> 1 2 3 4 5
;-> 6 7 8 9 0
;-> a b c d e
;-> f g h i j
;-> 11
(close datafile) ; chiudiamo il file
;-> true

Usata senza parametri la funzione "write-line" scrive sulla REPL (standard output) il contenuto dell'ultima chiamata di "read-line" (cioè "current-line"). Inoltre "write-line" restituisce il numero di byte (caratteri) scritti.

Per capire meglio i parametri della funzione "write-line" e il funzionamento delle operazioni di Input/Output sui file, vediamo la definizione di tutte le funzioni interessate:

"device", "open", "close", "read-line", "current-line", "write-line", "read-char", "write-char", "read", "write".

*******************
>>>funzione DEVICE
*******************
sintassi: (device [int-io-handle])

int-io-handle è un numero di dispositivo I/O, che è impostato su 0 (zero) per l'I/O standard (0 per stdin, 1 per stdout e 2 per stderr). int-io-handle può anche essere un handle di file precedentemente ottenuto usando la funzione "open". In questo caso, sia l'input che l'output utilizzano questo handle. Se non viene fornito alcun argomento, viene restituito il numero corrente del dispositivo I/O.

Il canale I/O specificato da device viene utilizzato internamente dalle funzioni print, println, write, write-line e read-char, read-line. Quando il dispositivo I/O corrente è 0 o 1, la stampa invia l'output alla finestra della console e il read-line accetta l'input dalla tastiera. Se il dispositivo I/O corrente è stato impostato aprendo un file, allora la stampa e la lettura lavorano su quel file.

Si noti che su sistemi operativi Unix, il canale stdin (0) può essere utilizzato anche per l'output e il canale stdout (1) può essere utilizzato anche per la lettura dell'ingresso. Questo non è il caso di Windows, dove 0 è strettamente per input e stdout 1 strettamente per l'output.

(device (open "myfile" "write"))  → 5
(print "This goes in myfile")     → "This goes in myfile"
(close (device))                  → true

Nota che usare "close" su un "device" automaticamente impostano il valore di "device" a zero (0).

*****************
>>>funzione OPEN
*****************
sintassi: (open str-path-file str-access-mode [str-option])

Il file str-path è un nome di file e str-access-mode è una stringa che specifica la modalità di accesso al file. open restituisce un numero intero, che è un handle di file da utilizzare nelle successive operazioni di lettura o scrittura sul file. In caso di fallimento, open restituisce nil. La modalità di accesso "write" crea il file se non esiste, o tronca un file esistente a 0 (zero) byte di lunghezza.

Le seguenti stringhe sono le modalità di accesso disponibili:

"read"   o "r" per accesso in lettura (read)
"write"  o "w" per accesso in scrittura (write)
"update" o "u" per accesso in lettura/scrittura (read/write)
"append" o "a" per accesso in aggiungere/leggere/scrivere (append/read/write)

(device (open "newfile.data" "write"))  → 5
(print "hello world\n")  → "hello world"
(close (device))         → 5

(set 'aFile (open "newfile.data" "read"))
(seek aFile 6)
(set 'inChar (read-char aFile))
(print inChar "\n")
(close aFile)

Il primo esempio utilizza open per impostare il dispositivo per la stampa e scrive la parola "ciao mondo" nel file newfile.data. Il secondo esempio legge il valore di byte all'offset 6 dello stesso file (il valore ASCII di 'w' è 119). Si noti che l'utilizzo di close sul device ripristina automaticamente il device sul valore 0 (zero).

L'opzione aggiuntiva str-option, "non-block" o "n" possono essere specificati dopo l'opzione "read" o "write". Disponibile solo su sistemi Unix, la modalità non bloccante può essere utile quando si aprono pipe con nome, ma non è richiesto per eseguire I/O su pipe con nome.

******************
>>>funzione CLOSE
******************
sintassi: (close int-file)

Chiude il file specificato dall'handle del file int-file. L'handle dovrebbe essere stato ottenuto tramite una precedente chiamata alla funzione open. In caso di successo, chiude restituisce vero, altrimenti viene restituito nil.

(close (device))  → true
(close 7)         → true
(close aHandle)   → true

Si noti che l'utilizzo di close su un device lo reimposta automaticamente su 0 (zero, il device dello schermo).

**********************
>>>funzione READ-LINE
**********************
sintassi: (read-line [int-file])

Legge dal device I/O corrente una stringa delimitata da un carattere di avanzamento riga (line-feed ASCII 10). Non c'è limite alla lunghezza della stringa che può essere letta. Il carattere line-feed non fa parte della stringa restituita. La linea si spezza sempre su un line-feed, che viene poi scartato. Una riga si interrompe su un ritorno a capo (carriage-return ASCII 13) solo se seguito da un avanzamento riga, nel qual caso entrambi i caratteri vengono scartati. Un ritorno a capo da solo spezza la linea e viene scartato solo se è l'ultimo carattere del file.

Per impostazione predefinita, il dispositivo corrente è la tastiera (dispositivo 0). Utilizzare il dispositivo funzione predefinita "device" incorporato per specificare un diverso dispositivo I/O (ad es. un file). Facoltativamente, è possibile specificare un handle di file nel parametro int-file ottenuto da una precedente istruzione open.

L'ultimo contenuto del buffer da un'operazione di lettura riga può essere recuperato utilizzando la linea corrente.

Quando read-line sta leggendo da un file o da stdin in un programma o pipe CGI, restituirà zero quando l'input è esaurito.

Quando si utilizza read-line su stdin, la lunghezza della linea è limitata a 2048 caratteri e le prestazioni sono molto più veloci.

(print "Enter a num:")
(set 'num (int (read-line)))

(set 'in-file (open "afile.dat" "read"))
(while (read-line in-file)
        (write-line))
(close in-file)

Il primo esempio legge l'input dalla tastiera e lo converte in un numero. Nel secondo esempio, un file viene letto riga per riga e visualizzato sullo schermo. L'istruzione write-line si avvale del fatto che il risultato dell'ultima operazione di lettura (read-line) è memorizzato in un buffer interno al sistema.
Quando write-line viene utilizzata senza argomenti, scrive il contenuto del buffer ottenuto con l'ultima chiamata di read-line.

*************************
>>>funzione CURRENT-LINE
*************************
sintassi: (current-line)

Recupera il contenuto dell'ultima operazione di read-line. Il contenuto di current-line viene implicitamente usato quando write-line viene chiamata senza il parametro stringa.

Il seguente codice sorgente mostra il tipico pattern per la creazione di un filtro da riga di comando Unix:

#!/usr/local/bin/newLISP

(set 'inFile (open (main-args 2) "read"))
(while (read-line inFile)
  (if (starts-with (current-line) ";;")
    (write-line)))
(exit)

Il programma viene chiamato in questo modo:

./filter myfile.lsp

Questo comando mostra tutte le righe di commento che iniziano con ";;" del file fornito come argomento della riga di comando (myfile.lsp)

***********************
>>>funzione WRITE-LINE
***********************
sintassi: (write-line [int-file [str]])
sintassi: (write-line str-out [str]])

La stringa str e i caratteri di terminazione di riga vengono scritti nel device specificato dal parametro int-file. Quando l'argomento stringa viene omesso, write-line scrive il contenuto dell'ultima operazione read-line sul device individuato da int-file Se viene omesso anche il primo argomento, allora scrive su standard output (STDOUT) o sul dispositivo impostato dalla funzione device.

Nella seconda sintassi le righe vengono aggiunte alla stringa str-out.

write-line restituisce il numero di byte scritti.

(set 'out-file (open "myfile" "write"))
(write-line out-file "hello there")
(close out-file)

(set 'myFile (open "init.lsp" "read")
(while (read-line myFile) (write-line))

(set 'str "")
(write-line str "hello")
(write-line str "world")

str  →  "hello\nworld\n"

Il primo esempio apre/crea un file, scrive una riga e chiude il file. Il secondo esempio mostra l'uso di write-line senza argomenti. Il contenuto di init.lsp viene scritto sullo schermo della console.

**********************
>>>funzione READ-CHAR
**********************
sintassi: (read-char [int-file])

Legge un byte da un file specificato dall'handle in int-file o dal dispositivo di I/O corrente - ad es. stdin quando non viene specificato alcun handle di file. L'handle del file è ottenuto da una precedente chiamata alla funzione open. Ogni read-char avanza il puntatore del file di un byte. Una volta raggiunta la fine del file, viene restituito nil.

(define (slow-file-copy from-file to-file)
    (set 'in-file (open from-file "read"))
    (set 'out-file (open to-file "write"))
    (while (set 'chr (read-char in-file))
        (write-char out-file chr))
    (close in-file)
    (close out-file)
    "finished")

Usa read-line e device per leggere un'intera linea alla volta. Notare che newLISP fornisce una funzione predefinita molto veloce per copiare i file (copy-file).

***********************
>>>funzione WRITE-CHAR
***********************
sintassi: (write-char int-file int-byte1 [int-byte2 ... ])

Scrive il byte specificato in int-byte nel file specificato dall'handle int-file. L'handle del file è ottenuto da una precedente chiamata alla funzione open. Ogni chiamata write-char fa avanzare il puntatore del file di un byte (8 bit).

write-char restituisce il numero di byte scritti.

(define (slow-file-copy from-file to-file)
    (set 'in-file (open from-file "read"))
    (set 'out-file (open to-file "write"))
    (while (set 'chr (read-char in-file))
        (write-char out-file chr))
     (close in-file)
    (close out-file)
    "finished")

Utilizzare le funzioni print e device per scrivere grandi porzioni di dati alla volta. Notare che newLISP fornisce già una funzione integrata più veloce chiamata copy-file. Notare che newLISP fornisce una funzione predefinita molto veloce per copiare i file (copy-file).

*****************
>>>funzione READ
*****************
sintassi: (read int-file sym-buffer int-size [str-wait])

Legge al massimo int-size byte da un file specificato dall'handle int-file nel buffer sym-buffer. Tutti i dati a cui fa riferimento il simbolo sym-buffer prima della lettura vengono cancellati. L'handle int-file è ottenuto da una precedente istruzione open. Il simbolo sym-buffer contiene dati di tipo stringa dopo l'operazione di lettura. sym-buffer può anche essere un funtore predefinito specificato da un simbolo di contesto per il passaggio per riferimento di funzioni definite dall'utente.

read è un modo più breve di usare read-buffer. La forma più lunga funziona ancora, ma è deprecata e dovrebbe essere evitata nei nuovi programmia.

Opzionalmente, una stringa da attendere può essere specificata in str-wait. read leggerà una quantità massima di byte specificata in int-size o uscirà preventivamente se str-wait è stato trovato nei dati. La stringa di attesa è parte dei dati restituiti e non deve contenere caratteri binari 0 (zero).

Restituisce il numero di byte letti o nil quando non è stata trovata la stringa di attesa. In ogni caso, i byte letti vengono inseriti nel buffer puntato da sym-buffer e il puntatore del file del file in lettura viene spostato in avanti. Se non sono stati letti nuovi byte, sym-buffer conterrà nil.

(set 'handle (open "aFile.ext" "read"))
(read handle buff 200)
Legge 200 byte nel buff symbol dal file aFile.ext.

(leggi handle buff 1000 "password:")
Legge 1000 byte o fino a quando si incontra la stringa "password:". La stringa "password:" sarà parte dei dati restituiti.

******************
>>>funzione WRITE
******************
sintassi: (write)
sintassi: (write int-file str-buffer [int-size])
sintassi: (write str str-buffer [int-size])

Nella seconda sintassi write scrive int-size byte da un buffer in str-buffer in un file specificato da int-file, che è stato precedentemente ottenuto da un'operazione di apertura file (open). Se int-size non viene specificato, allora vengono scritti tutti i dati in sym-buffer o str-buffer. write restituisce il numero di byte scritti o nil in caso di errore.

Se tutti i parametri sono omessi, write scrive il contenuto ottenuto dall'ultima chiamata read-line sullo standard output (stdout).

write è una modo più breve di write-buffer. La forma più lunga funziona ancora, ma è deprecata e dovrebbe essere evitata nel nuovo codice.

(set 'handle (open "myfile.ext" "write"))
(write handle data 100)
(write handle "a quick message\n")

Il codice dell'esempio scrive 100 byte nel file myfile.ext presi dal contenuto di della variabile data.

Nella terza sintassi, la scrittura può essere utilizzata per unire stringhe in modo distruttivo:

(set 'str "")
(write str "hello world")

str   → "hello world"

**********************
>>>funzione READ-FILE
**********************
sintassi: (read-file str-file-name)

Legge un file dato in str-file-name in un colpo solo e restituisce una stringa (buffer) contenente i dati.

In caso di fallimento la funzione ritorna nil. Per informazioni sull'errore, utilizzare sys-error sul file. Se utilizzato su URL, net-error fornisce ulteriori informazioni sull'errore.

(write-file "myfile.enc"
    (encrypt (read-file "/home/lisp/myFile") "secret"))

Il file myfile viene prima letto, poi criptato usando la password "secret" e infine scritto con un nuovo nome "myfile.enc" nella cartella corrente.

read-file può usare http:// oppure file:// URL in str-file-name. Quando il prefisso vale http:// read-file funziona esattamente come get-url e può avere gli stessi parametri addizionali.

(read-file "http://asite.com/somefile.tgz" 10000)

Il file somefile.tgz viene caricato dalla locazione remota http://asite.com. Il trasferimento del file viene interrotto dopo un tempo di 10 secondi (time-out) anche se la lettura non è terminata. In questo modo, read-file può anche essere usato per trasferire file da un server remoto newLISP.

***********************
>>>funzione WRITE-FILE
***********************
sintassi: (write-file str-file-name str-buffer)

Scrive un file dato in str-file-name con il contenuto di str-buffer in un colpo solo e restituisce il numero di byte scritti.

In caso di fallimento la funzione ritorna nil. Per informazioni sull'errore, utilizzare sys-error sul file. Se utilizzato su URL, net-error fornisce ulteriori informazioni sull'errore.

(write-file "myfile.enc"
    (encrypt (read-file "/home/lisp/myFile") "secret"))

Il file myfile viene prima letto, poi criptato usando la password "secret" e infine sritto con un nuovo nome "myfile.enc" nella cartella corrente.

write-file può usare http:// oppure file:// URL in str-file-name. Quando il prefisso vale http:// allora write-file funziona esattamente come put-url e può avere gli stessi parametri addizionali.

(write-file "http://asite.com/message.txt" "This is a message" )

Il file message.txt viene creato e scritto nella locazione remota http://asite.com con il contenuto di str-buffer. In questo modo, write-file può anche essere usato per trasferire file a un server remoto newLISP.

************************
>>>funzione APPEND-FILE
************************
sintassi: (append-file str-filename str-buffer)

Funziona in modo simile a write-file, ma il contenuto di str-buffer viene aggiunto se il file str-filename esiste. Se il file non esiste, allora viene creato (in questo caso append-file funziona esattamente come write-file). Questa funzione ritorna il numero di byte scritti.

In caso di fallimento la funzione ritorna nil. Per informazioni sull'errore, utilizzare sys-error sul file. Se utilizzato su URL, net-error fornisce ulteriori informazioni sull'errore.

(write-file "myfile.txt" "ABC")
(append-file "myfile.txt" "DEF")

(read-file "myfile.txt")  → "ABCDEF"

append-file può usare a http:// oppure file:// URL in str-file-name. Quando il prefisso vale http:// allora append-file funziona esattamente come con l'opzione header "Pragma: append\r\n" e può avere gli stessi parametri addizionali. L'opzione "Pragma: append\r\n" viene aggiunta automaticamente.

(append-file "http://asite.com/message.txt" "More message text.")

Il file message.txt viene aggiunto nella locazione remota http://asite.com con il contenuto di str-buffer. Se il file non esiste, allora verrà creato. In questo modo, append-file può anche essere usato per trasferire file a un server remoto newLISP.


================================
 SALVARE E CARICARE GLI OGGETTI
================================

Una caratteristica importante di un linguaggio interpretato è la capacità di salvare gli oggetti creati dall'utente durante la sessione REPL.

Oltre alle funzioni I/O standard ("open", "close", "write-char", ecc), newLISP mette a disposizione le funzioni "save", "load", "source" e "pretty-print".

Vediamo la loro definizione:

*****************
>>>funzione SAVE
*****************
sintassi: (save str-file)
sintassi: (save str-file sym-1 [sym-2 ... ])

Nella prima sintassi, la funzione save scrive il contenuto dello spazio di lavoro di newLISP (in forma testuale) nel file str-file. save è la funzione inversa di load. L'utilizzo di load sui file creati con save fa sì che newLISP ritorni allo stesso stato di quando è stata utilizzata la funzione save. I simboli di sistema che iniziano con il carattere $ (ad es. $0 dalle espressioni regolari o $main-args dalla riga di comando), i simboli delle funzioni integrate e i simboli che contengono nil non vengono salvati.

Nella seconda sintassi, i simboli possono essere forniti come argomenti. Se viene fornito sym-n, viene salvata solo la definizione di quel simbolo. Se sym-n è un contesto, tutti i simboli di quel contesto vengono salvati. È possibile specificare più di un simbolo e possono essere combinati simboli e simboli di contesto. Quando i contesti vengono salvati, le variabili di sistema e i simboli che iniziano con il carattere $ non vengono salvati. Specificando esplicitamente i simboli di sistema causa il slavataggio degli stessi.

Ogni simbolo viene salvato mediante un'istruzione set o, se il simbolo contiene una funzione lambda o macro lambda, mediante le istruzioni define o define-macro.

save ritorna il valore true al termine.

(save "save.lsp")
(save "/home/myself/myfunc.LSP" 'my-func)
(save "file:///home/myself/myfunc.LSP" 'my-func)
(save "http://asite.com:8080//home/myself/myfunc.LSP" 'my-func)
(save "mycontext.lsp" 'mycontext)

;; argomenti multipli
;; multiple args
(save "stuff.lsp" 'aContext 'myFunc '$main-args 'Acontext)

Poiché tutti i simboli di contesto fanno parte del contesto MAIN, il salvataggio di MAIN salva tutti i contesti.

Il salvataggio su un indirizzo URL causerà l'invio di una richiesta HTTP PUT all'URL. In questa modo, è possibile utilizzare save anche per inviare i sorgenti di un programma a nodi/server newLISP remoti. Si noti che è necessario un doppio backslash quando i nomi dei percorsi sono specificati relativamente alla directory root. In modalità HTTP save osserverà un timeout di 60 secondi.

I simboli creati usando sym che sono incompatibili con le normali regole di sintassi per i simboli sono serializzati usando un'istruzione sym invece di un'istruzione set.

save serializza contesti e simboli come se il contesto corrente fosse MAIN. Indipendentemente dal contesto attuale, save genererà sempre lo stesso risultato.

Vedi anche le funzioni load (l'operazione inversa di save) e source, che salva simboli e contesti in una stringa anziché in un file.

*****************
>>>funzione LOAD
*****************
sintassi: (load str-file-name-1 [str-file-name-2 ... ] [sym-context])

Carica e traduce newLISP da un file sorgente specificato in uno o più str-nome-file e valuta le espressioni contenute in tutti i file. Quando il caricamento ha esito positivo, load restituisce il risultato dell'ultima espressione nell'ultimo file valutato. Se non è possibile caricare un file, load genera un errore.

È possibile specificare un simbolo di contesto (sym-context) facoltativo, che diventa il contesto di valutazione, a meno che un tale cambiamento di contesto non sia già presente nel file che si sta caricando. Per impostazione predefinita, i file che non contengono cambiamenti di contesto verranno caricati nel contesto MAIN.

Il parametro str-file-name può contenere URL. Entrambi i metodi http:// e file:// di URL sono supportati.

(load "myfile.lsp")

(load "a-file.lsp" "b-file.lsp")

(load "file.lsp" "http://mysite.org/mypro")

(load "http://192.168.0.21:6000//home/test/program.lsp")

(load "a-file.lsp" "b-file.lsp" 'MyCTX)

(load "file:///usr/local/share/newLISP/mysql.lsp")

Nel caso in cui le espressioni valutate durante il caricamento stiano cambiando il contesto, ciò non influenzerà il modulo di programmazione che esegue il caricamento.

Il contesto corrente dopo l'istruzione load sarà sempre lo stesso di quello prima dell'operazione load.

Le normali specifiche per i file e gli URL possono essere utilizzati nello stesso comando load.

Utilizzare load con URL HTTP può anche essere utilizzato per caricare il codice sorgente da nodi/server remoti di newLISP che hanno sistema operativo UNIX/Linux. In questa modo, load invierà una richiesta HTTP GET all'URL di destinazione. Si noti che è necessario un doppio backslash quando i nomi dei percorsi sono specificati relativamente alla directory root. In modalità HTTP load osserverà un timeout di 60 secondi.

La penultima riga fa caricare i file nel contesto MyCTX. Il carattere quote "'" forza la creazione del contesto se questo non esiste.

L'indirizzo URL file:// è seguito da un terzo / per le specifiche della directory.

*******************
>>>funzione SOURCE
*******************
sintassi: (source)
sintassi: (source sym-1 [sym-2 ... ])

Funziona in modo quasi identico a save, tranne che i simboli e i contesti vengono serializzati su una stringa anziché essere scritti su un file. È possibile specificare più simboli variabili, definizioni e contesti. Se non viene fornito alcun argomento, source serializza l'intero spazio di lavoro di newLISP. Quando i simboli di contesto sono serializzati, anche i simboli contenuti in quel contesto saranno serializzati. I simboli di sistema che iniziano con il carattere $ (simbolo del dollaro) vengono serializzati solo quando menzionati esplicitamente.

I simboli che non appartengono al contesto corrente sono scritti con il loro prefisso di contesto.

(define (double x) (+ x x))

(source 'double)  → "(define (double x)\n  (+ x x))\n\n"

Come con save, la formattazione delle interruzioni di riga e degli spazi iniziali o delle tabulazioni può essere controllata usando la funzione pretty-print.

*************************
>>>funzione PRETTY-PRINT
*************************
sintassi: (pretty-print [int-length [str-tab [str-fp-format]])

Riformatta le espressioni per la print, save o source e quando si stampa in una console interattiva. Il primo parametro, int-length, specifica la lunghezza massima della linea e str-tab specifica la stringa utilizzata per le righe di rientro (indentazione). Il terzo parametro str-fp-format descrive il formato predefinito per la stampa di numeri in virgola mobile. Tutti i parametri sono opzionali. pretty-print restituisce le impostazioni correnti o le nuove impostazioni quando vengono specificati i parametri.

(pretty-print)  → (80 " " "%1.15g")  ; default setting

(pretty-print 90 "\t")  → (90 "\t" "%1.15g")

(pretty-print 100)  → (100 "\t" "%1.15g")

(sin 1)    → 0.841470984807897
(pretty-print 80 " " "%1.3f")
(sin 1)    → 0.841

(set 'x 0.0)
x   → 0.000

Il primo esempio riporta le impostazioni predefinite di 80 per la lunghezza massima della linea e un carattere di spazio per il rientro. Il secondo esempio cambia la lunghezza della linea in 90 e il rientro nel carattere TAB. Il terzo esempio modifica solo la lunghezza della linea. L'ultimo esempio modifica il formato predefinito per i numeri in virgola mobile. Ciò è utile quando si stampano numeri in virgola mobile non formattati senza parti frazionarie e questi numeri dovrebbero essere ancora riconoscibili come numeri in virgola mobile. Senza il formato personalizzato, x verrebbe stampato come 0 indistinguibile dal numero in virgola mobile. Sono interessate tutte le situazioni in cui vengono stampati numeri in virgola mobile non formattati.

Si noti che non è possibile utilizzare la stampa fine per impedire la stampa delle interruzioni di riga. Per sopprimere completamente la stampa carina, utilizzare la stringa di funzioni per convertire l'espressione in una stringa non formattata come segue:

;; stampa senza formattazione
;; print without formatting

(print (string my-expression))

Nota: Quando vogliamo salvare delle liste di simboli occorre ricordare che i simboli devono avere un nome valido. Supponiamo di scrivere la seguente lista:

(setq lst '(aa bb 1c 1d))
;-> (aa bb 1 c 1 d)

Il risultato non è quello voluto perchè i nomi "1c" e "1d" non sono validi, quindi newLISP li analizza e modifica il loro nome. Questa analisi si verifica anche quando usiamo la funzione "LOAD".
Se i simboli "1c" e "1d" rappresentano dei valori esadecimali, allora dobbiamo scrivere:

(setq lst '(aa bb 0x1c 0x1d))
;-> (a bb 28 29)


===========================
 STRUTTURA DATI: IL RECORD
===========================

Un record (noto anche come struttura) è un tipo di dato strutturato che comprende diversi elementi (detti campi o membri) di tipo diverso. Nei record il numero e il tipo dei campi vengono stabiliti nella sua definizione iniziale. I record sono impiegati tipicamente nell'implementazione delle strutture dati plain old data (POD).
Nei linguaggi di programmazione orientata agli oggetti, un oggetto può avere dei campi che agiscono come funzioni o procedure che manipolano i dati memorizzati.

Un esempio di record è il seguente:

Nome record: PERSONA
Campi:
 1) nome (stringa)
 2) età  (intero)
 3) lavoro (true|false)
 4) indirizzo (sub-record)
4a)     via (stringa)
4b)   città (stringa)
4c)   paese (stringa)
 5) figli (sub-record)
5a)    nome (stringa)
5b)     età (intero)

In newLISP un record può essere implementato tramite le liste di associazione.
Una lista associativa è una "lista di liste", in cui il primo elemento è utilizzato come chiave per la ricerca:

((chiave1 valore1_1 valore1_2) (chiave2 valore2_1 valore2_2) ...)

Esempio:

(setq alst '( (1 Cuori) (2 Quadri)  (3 Fiori) (4 Picche)))

Per la ricerca nelle liste associative, si utilizzano le funzioni "assoc" e "lookup".

(assoc 2 alst)
;-> (2 Quadri)

(lookup 4 alst)
;-> Picche

Adesso vediamo la loro definizione:

*******************
>>> funzione ASSOC
*******************
sintassi: (assoc exp-key list-alist)
sintassi: (assoc list-exp-key list-alist)

Nella prima sintassi il valore di exp-key (chiave) viene utilizzato per cercare nella lista list-alist una sottolista il cui primo elemento corrisponde al valore della chiave. Se trovato, viene restituita la sottolista. In caso contrario, il risultato sarà nil.

(assoc 1 '((3 4) (1 2)))
;-> (1 2)

(set 'data '((apples 123) (bananas 123 45) (pears 7)))

(assoc 'bananas data)
;-> (bananas 123 45)
(assoc 'oranges data)
;-> nil

Insieme a "setf" la funzione "assoc" può essere usata per modificare un'associazione.

(setf (assoc 'pears data) '(pears 8))
data
;-> ((apples 123) (bananas 123 45) (pears 8))

Nella seconda sintassi è possibile specificare più espressioni-chiave per la ricerca di liste associative annidate in più livelli:

(set 'persons '(
    (id001 (name "Anne") (address (country "USA") (city "New York")))
    (id002 (name "Jean") (address (country "France") (city "Paris")))
))

(assoc '(id001 address) persons)
;-> (address (country "USA") (city "New York"))
(assoc '(id001 address city) persons)
;-> (city "New York")

La lista in list-aList può essere un contesto (context) che verrà interpretato come il suo funtore di default. In questo modo è possibile passare per riferimento liste molto grandi per un accesso più rapido e un minore utilizzo della memoria:

(set 'persons:persons '(
    (id001 (name "Anne") (address (country "USA") (city "New York")))
    (id002 (name "Jean") (address (country "France") (city "Paris")))
))

(define (get-city db id)
    (last (assoc (list id 'address 'city) db ))
)

(get-city persons 'id001)
;-> "New York"

Per effettuare sostituzioni nelle liste di associazioni, utilizzare "setf" insieme alla funzione "assoc". La funzione "lookup" viene utilizzata per eseguire la ricerca di associazione e l'estrazione dell'elemento in un solo passaggio.

********************
>>> funzione LOOKUP
********************
sintassi: (lookup exp-key list-assoc [int-index [exp-default]])

Cerca, nella lista di associazione list-assoc, una sottolista, il cui elemento chiave ha lo stesso valore di exp-key e restituisce l'elemento int-index dell'associazione (o l'ultimo elemento se int-index è assente).

Facoltativamente, è possibile specificare exp-default, che viene restituita se non è possibile trovare un'associazione corrispondente a exp-key. Se exp-default è assente e non è stata trovata alcuna associazione, viene restituito nil.

Vedi anche l'indicizzazione delle liste e delle stringhe.

La ricerca è simile a quella della funzione "assoc", ma fa un ulteriore passo estraendo un elemento specifico trovato nella lista.

(set 'params '(
    (name "John Doe")
    (age 35)
    (gender "M")
    (balance 12.34)
))

(lookup 'age params)
;-> 35

; utilizzata insieme a setf per modificare una lista di associazione

(setf (lookup 'age params) 42)
;-> 42
(lookup 'age params)
;-> 42

(set 'persons '(
    ("John Doe" 35 "M" 12.34)
    ("Mickey Mouse" 65 "N" 12345678)
))

(lookup "Mickey Mouse" persons 2)
;-> "N"
(lookup "Mickey Mouse" persons -3)
;-> 65
(lookup "John Doe" persons 1)
;-> 35
(lookup "John Doe" persons -2)
;-> "M"
(lookup "Jane Doe" persons 1 "N/A")
;-> "N/A"

Ritornando all'esempio iniziale del record, possiamo definire una lista di associazione per rappresentare la sua struttura:

Record                             Lista associativa

 1) nome (stringa)                 ( ("nome" "Pietro Rossi")
 2) età  (intero)                    ("eta" 42)
 3) lavoro (true|false)              ("lavoro" true)
 4) indirizzo (sub-record)           ("indirizzo" (
4a)     via (stringa)                    ("via" "Mazzini, 104.")
4b)   città (stringa)                    ("citta" "Roma")
4c)   paese (stringa)                    ("paese" "Italia")) )
 5) figli (sub-record)               ("figli" (
5a)    nome (stringa)                    (("nome" "Eva")  ("eta" 7))
5b)     età (intero)                     (("nome" "Lisa") ("eta" 4))
                                         (("nome" "Luca") ("eta" 3))) ) )

Notare che il campo "figli" ha un numero variabile di elementi.

Una volta definita la lista associativa che rappresenta il record, dobbiamo scivere le funzioni che operano su di essi, cioè le funzioni di creazione di un record, ricerca del record, aggiornamento del record, eliminazione del record, ecc.

Per esempio supponiamo di avere il seguente tipo di record:

(setq rec
 '( ("nome" "Pietro Rossi")
    ("eta" 42)
    ("lavoro" true)
    ("indirizzo" (
      ("via" "Mazzini, 104.")
      ("citta" "Roma")
      ("paese" "Italia")) )
    ("figli" (
      (("nome" "Eva")  ("eta" 7))
      (("nome" "Lisa") ("eta" 4))
      (("nome" "Luca") ("eta" 3))) ) )
)

I valori possono essere estratti con le funzioni "assoc", "lookup" o "ref":

; indirizzo
(lookup "indirizzo" rec)
;-> (("via" "Mazzini, 104.") ("citta" "Roma") ("paese" "Italia"))

; la citta dell'indirizzo
(lookup "citta" (lookup "indirizzo" rec))
;-> "Roma"

; una figlia di nome Eva
(ref '(( * "Eva") *) rec match true)
;-> (("nome" "Eva") ("eta" 7))

; tutti i nomi
(map last (ref-all '("nome" *) rec match true))
;-> ("Pietro Rossi" "Eva" "Lisa" "Luca")

; solo i nomi dei figli
(map last (ref-all '("nome" *) (lookup "figli" rec) match true))
;-> ("Eva" "Lisa" "Luca")

; solo i nomi dei figli (altro metodo)
(map last (map first (lookup "figli" rec)))
;-> ("Eva" "Lisa" "Luca")

I record possono essere memorizzati utilizzando una lista, un vettore, un file XML o JSON, ecc.
Comunque le prestazioni sono accettabili soltanto fino ad un migliaia di record, poi sarebbe meglio utilizzare un DBMS (esempio: SQLite).


=====================================
 AMBITO (SCOPE) DINAMICO E LESSICALE
=====================================

newLISP utilizza l'ambito dinamico all'interno dei contesti. Un contesto è uno spazio di nomi lessicalmente chiuso. In questo modo, parti di un programma newLISP possono vivere in spazi di nomi diversi sfruttando l'ambito lessicale.

Quando i simboli dei parametri di un'espressione lambda sono associati ai relativi argomenti, i vecchi collegamenti vengono inseriti in una pila. newLISP ripristina automaticamente le associazioni originali  delle variabili quando termina la funzione lambda.

Nell'esempio seguente viene illustrato il meccanismo di ambito dinamico.

(set 'x 1)
;-> 1
(define (f) x)
;-> (lambda () x)
(f)
;-> 1
(define (g x) (f))
;-> (lambda (x) (f))
(g 0)
;-> 0
(f)
;-> 1
> _

La variabile x è prima impostata su 1. Ma quando viene chiamata (g 0), x è associato a 0 ed x viene è riconosciuto da (f) come 0 durante l'esecuzione di (g 0). Dopo l'esecuzione di (g 0), la chiamata a (f) riporterà x di nuovo al valore 1.

Questo comportamento è diverso dai meccanismi di ambito lessicale che troviamo in linguaggi come C o Java, dove il legame dei parametri locali avviene solo all'interno della funzione. Nei linguaggi lessicali come il C, (f) stamperebbe sempre i collegamenti globali del simbolo x con 1.

Tieni presente che il passaggio di simboli quotati a una funzione definita dall'utente causa un conflitto di nomi se lo stesso nome di variabile viene utilizzato come parametro di funzione:

(define (inc-symbol x y) (inc (eval x) y))
;-> (lambda (x y) (inc (eval x) y))
(set 'y 200)
;-> 200
(inc-symbol 'y 123)
;-> 246
y
;-> 200; y è ancora 200

Poiché la y globale condivide lo stesso simbolo del secondo parametro della funzione, inc-symbol restituisce 246 (123 + 123), lasciando inalterato il globale. La cattura delle variabili in ambito dinamico può essere uno svantaggio quando si passano i riferimenti dei simboli a funzioni definite dall'utente. newLISP offre diversi metodi per evitare la cattura delle variabili.

- La funzione "args" può essere utilizzata quando si passano simboli.
- Una o più funzioni definite dall'utente possono essere inserite in uno spazio dei nomi chiamato proprio contesto ("context"). Un conflitto di nomi di simboli non può verificarsi quando si accede a simboli e si chiamano funzioni dall'esterno del contesto di definizione.

I contesti devono essere utilizzati per raggruppare le funzioni correlate quando si creano interfacce o librerie di funzioni. Ciò racchiude le funzioni con un "recinto" lessicale, evitando così conflitti tra i nomi delle variabili e le funzioni chiamate.

In seguito vedremo che newLISP utilizza i contesti per diverse forme di ambiti lessicali.

Perchè newLISP usa l'ambito dinamico?
Lutz: I pericoli dell'ambito dinamico sono ampiamente sopravvalutati e per questo motivo, le possibilità dell'ambito dinamico sono quasi inesplorate.

Nel corso degli anni, non abbiamo quasi mai visto l'ambito dinamico come un problema. Laddove il pericolo è in qualche modo presente, si trova nelle fexprs 'define-macro' e tale pericolo può essere facilmente evitato usando gli spazi dei nomi. Esistono pochissime ragioni nello stile di programmazione di newLISP per passare simboli quotati alle funzioni "define", ci sono altri modi sicuri per passare i dati per riferimento in newLISP, ovvero tramite gli handle degli spazi dei nomi.

Puoi avere un isolamento lessicale usando gli spazi dei nomi, che hanno un sovraccarico minimo in newLISP: puoi letteralmente averne milioni. Le fexpr in stile 'define-macro' possono essere inserite nel proprio contesto dello spazio dei nomi e quindi sono completamente sicure. Generalmente, lo stile migliore di programmazione in newLISP è quello di inserire dati, funzioni e fexprs correlati in un contesto di spazio dei nomi.

L'assenza delle chiusure lessicali di Scheme consente a newLISP di eseguire un diverso tipo di gestione automatica della memoria - non la tradizionale garbage collection, ma un tipo sincrono di gestione della memoria - molto più veloce, senza pause inattese di garbage collection e molto più efficiente nell'uso delle risorse di memoria. Non c'è modo di scrivere un linguaggio completamente dinamico così piccolo e veloce come newLISP usando la tradizionale gestione della memoria della garbage collection.

Vediamo un esempio:

(define (sum f n)
    (set 'result 0)
    (for (i 1 n)
        (inc result (f i)))
    result)

; works because no clash of free j in f with i in sum
(for (j 1 5)
    (define (f x) (pow x j))
    (println j ": " (sum f 10)))

; does not work, free i in f clashes with i in sum
(for (i 1 5)
     (define (f x) (pow x i))
     (println i ": " (sum f 10)))

; works with previous expansion of free variable
(for (i 1 5)
     (letex (e i) (define (f x) (pow x e))) ; expansion of free variable
     (println i ": " (sum f 10)))

produce:

1: 55
2: 385
3: 3025
4: 25333
5: 220825
1: 1.040507132e+10
2: 1.040507132e+10
3: 1.040507132e+10
4: 1.040507132e+10
5: 1.040507132e+10
1: 55
2: 385
3: 3025
4: 25333
5: 220825

Le variabili libere nello scoping dinamico non sono pre-associate durante la definizione della funzione. Ma proprio come una chiusura di Scheme vincolerebbe le variabili libere al suo ambiente durante la definizione di f, lo stesso può essere fatto usando "letex" o "expand" associando la variabile libera durante la definizione della funzione.


==========
 CONTESTI
==========

In newLISP, i simboli possono essere separati in spazi dei nomi chiamati contesti. Ogni contesto ha una tabella di simboli privata separata da tutti gli altri contesti. I simboli noti in un contesto sono sconosciuti in altri, quindi lo stesso nome può essere usato in diversi contesti senza conflitti.

I contesti sono usati per costruire moduli di definizioni di variabili e funzioni isolate. Possono anche essere usati per costruire dizionari per coppie di valore e chiave. I contesti possono essere copiati e assegnati dinamicamente alle variabili o passati come argomenti per riferimento. Poiché i contesti in newLISP hanno spazi dei nomi separati lessicalmente, consentono la programmazione con scope lessicale e stili di programmazione software orientati agli oggetti.

I contesti sono identificati da simboli che fanno parte del contesto principale MAIN (radice). Sebbene i simboli di contesto siano in maiuscolo in questo capitolo, possono essere utilizzati anche i simboli in minuscolo.

Oltre ai nomi di contesto, MAIN contiene i simboli per funzioni incorporate (predefinite) e simboli speciali come true e nil. Il contesto MAIN viene creato automaticamente ogni volta che viene eseguito newLISP. Per vedere tutti i simboli in MAIN, inserere la seguente espressione dopo aver avviato newLISP:

(symbols)

Per vedere tutti i simboli in MAIN che puntano ai contesti (associati):

(filter context? (map eval (symbols)))

Per vedere tutti i simboli del contesto MAIN quando MAIN non è il contesto corrente:

(filter context? (map eval (symbols MAIN)))

Creazione di simboli nei contesti
---------------------------------
Le seguenti regole dovrebbero semplificare il processo di comprensione dei contesti identificando a quale contesto vengono assegnati i simboli creati.

1) newLISP dapprima analizza e traduce ogni espressione a partire dal livello più alto. Tutti i simboli vengono creati durante questa fase. Dopo che l'espressione è stata tradotta, viene valutata.

2) Un simbolo viene creato quando newLISP lo vede per la prima volta, mentre chiama le funzioni load, sym o eval-string. Quando newLISP legge un file sorgente, i simboli vengono creati "prima" che avvenga la valutazione. La funzione reader-event può essere utilizzata per ispezionare l'espressione dopo la lettura e la traduzione, ma prima della valutazione. La funzione read-expr può essere utilizzata per leggere e tradurre il sorgente newLISP senza valutazione.

3) Quando si incontra un simbolo sconosciuto durante la traduzione del codice, una ricerca per la sua definizione inizia nel contesto corrente. In caso contrario, la ricerca continua all'interno di MAIN per una funzione predefinita, un contesto o un simbolo globale. Se non viene trovata alcuna definizione, il simbolo viene creato localmente all'interno del contesto corrente.

4) Una volta che un simbolo viene creato e assegnato a un contesto specifico, apparterrà a tale contesto in modo permanente o finché non verrà eliminato utilizzando la funzione di eliminazione delete.

5) Quando viene valutata una funzione definita dall'utente, il contesto viene commutato allo spazio nome che possiede quel simbolo.

6) Il cambio di contesto influenza solo la creazione del simbolo durante load, sym o eval-string. load per default carica in MAIN tranne quando il contesto cambia al livello superiore del file caricato (all'inizio). Per uno stile migliore, è necessario specificare sempre il contesto quando vengono utilizzate le funzioni sym e eval-string. Normalmente uno switch di contesto dovrebbe essere effettuato solo al livello più alto di un programma (all'inizio), mai all'interno di una funzione.

Creare contesti
---------------
I contesti possono essere creati usando la funzione di contesto o tramite la creazione implicita. Il primo metodo è usato quando si scrivono porzioni più grandi di codice appartenenti allo stesso contesto:

(context 'FOO)

(setq 'var 123)

(define (func x y z)
    ...)

(context MAIN)

Se il contesto non esiste ancora, il simbolo di contesto deve essere citato. Se il simbolo non è quotato, newLISP assume che il simbolo sia una variabile che contiene il simbolo del contesto da creare. Poiché un contesto valuta se stesso, i contesti già esistenti come MAIN non richiedono la citazione.

Quando newLISP legge il codice sopra, leggerà, quindi valuterà la prima affermazione: (context 'FOO). Ciò fa sì che newLISP cambi lo spazio dei nomi in FOO ei seguenti simboli var, x, y e z verranno tutti creati nel contesto FOO durante la lettura e la valutazione delle espressioni rimanenti.

Un simbolo di contesto è protetto dal cambiamento. Una volta che un simbolo fa riferimento a un contesto, non può essere utilizzato per nessun altro scopo, tranne quando si utilizza l'eliminazione.

Per fare riferimento a var o func da qualsiasi altra parte al di fuori dello spazio dei nomi FOO, devono essere preceduti dal nome del contesto:

FOO: var
;-> 123

(FOO: func p q r)

Si noti che nell'esempio sopra, solo func appartiene allo spazio dei nomi FOO, i simboli p q r fanno tutti parte del contesto corrente da cui viene effettuata la chiamata FOO: func.

La funzione simboli è usata per mostrare tutti i simboli appartenenti ad un contesto:

(symbols FOO)
;-> (FOO: func FOO: var FOO: x FOO: y FOO: z)

; o dall'interno del contesto i simboli sono mostrati senza prefisso di contesto
(contesto FOO)
;-> (func x y z)
(symbols)


================
 USO DEI MODULI
================

Un modulo è un file sorgente di newLISP che contiene funzioni specifiche relative ad un determinato argomento.
Questa è la lista dei moduli che newLISP mette a disposizione:

- canvas.lsp
Questo modulo genera pagine HTML adatte per i browser che riconoscono i tag grafici canvas HTML-5.

- cgi.lsp
Questo modulo definisce gli strumenti di base per la gestione CGI per l'elaborazione di richieste e cookie CGI GET e CGI POST.

- crypto.lsp
Modulo per il binding della libreria crypto SSL (algoritmi di hashing MD5 e SHA-1).

- ftp.lsp
Modulo con funzioni per il trasferimento di file tramite protocollo FTP.

- gsl.lsp
Modulo per l'utilizzo di alcune funzioni della libreria scientifica GNU (devono essere installate le librerie 'libgsl' e 'libgslcblas').

- infix.lsp
Modulo per analizzare le espressioni infisse, prefisse o postfisse passate come stringa. Restituisce una espressione newLISP che può essere valutata (cattura gli errori di sintassi).

- mysql.lsp
Modulo per interfacciare il database relazionale MySQL 5.x.

- odbc.lsp
Modulo per interfacciare i database tramite le librerie ODBC.

- plot.lsp
Modulo con funzioni per la creazione di grafici di dati.

- pop3.lsp
Modulo con funzioni per utilizzo della posta POP3.

- postgres.lsp
Modulo per interfacciare il database relazionale PostgreSQL (PostgreSQL 9.4).

- postscript.lsp
Modulo con funzioni per la creazione di file PostScript.

- smtp.lsp
Modulo per la gestione della posta tramite protocollo SMTP.

- smtpx.lsp
Modulo per la gestione della posta tramite protocollo SMTP (-nix).

- sqlite3.lsp
Modulo per interfacciare il database relazionale sqlite.

- stat.lsp
Modulo per statistiche di base e librerie di plottaggio.

- unix.lsp
Module with interface to various UNIX libc functions

- xmlrpc-client.lsp
Modulo con funzioni per interfaccia la libreria libc di UNIX.

- zlib.lsp
Modulo con funzioni per compressione/decompressione di file con la libreria zlib.


La variabile di ambiente newLISPDIR
-----------------------------------

Durante l'avvio newLISP imposta la variabile di ambiente newLISPDIR, se non è già impostata. Su Linux, BSDs, macOS e altri Unix la variabile /usr/local/share/newLISP. Su MS Windows la variabile viene impostata dove è stato installato newLISP.

La variabile d'ambiente newLISPDIR è utile quando si caricano moduli (file) installati con newLISP:

(load (append (env "newLISPDIR") "/modules/mysql.lsp"))

Una funzione predefinita "module" può essere utilizzata per abbreviare il parametro relativo alla cartella dell'istruzione load:

(module "mysql.lsp")


Il file di inizializzazione init.lsp
------------------------------------

Prima di caricare qualsiasi file specificato sulla riga di comando e prima che vengano visualizzati il banner e il prompt, newLISP tenta di caricare un file .init.lsp dalla cartella home dell'utente che esegue newLISP. Su macOS, Linux e altri Unix, la cartella home si trova nella variabile di ambiente HOME. Su MS Windows il nome della cartella è contenuto nella variabile di ambiente USERPROFILE (o DOCUMENT_ROOT).

Se un file .init.lsp non può essere trovato nella cartella home, allora newLISP prova a caricare il file init.lsp dalla cartella trovata nella variabile di ambiente newLISPDIR.

Quando newLISP viene eseguito come libreria condivisa, viene cercato un file di inizializzazione nella variabile di ambiente newLISPLIB_INIT. È necessario specificare il nome percorso completo del file di inizializzazione. Se newLISPLIB_INIT non è definita, nessun file di inizializzazione verrà caricato dal modulo della libreria.

Sebbene newLISP non richieda init.lsp per l'esecuzione, è utile per definire funzioni e variabili a livello di sistema.

Nota: nessun file di inizializzazione viene caricato durante il caricamento di programmi collegati (linked) o quando viene specificata una delle opzioni -n, -h, -x.

Nel mio sistema risulta:

(env "newLISPDIR")
;-> "C:\\newLISP"

(env "PROGRAMFILES")
;-> "C:\\Program Files"

(env "USERPROFILE")
;-> "C:\\Users\\u42"

(env "DOCUMENT_ROOT")
;-> nil

Esempi sull'utilizzo dei moduli
-------------------------------

Vediamo ora come utilizzare i moduli con alcuni esempi. Cominciamo con il modulo "postscript.lsp" che ci permette di creare file postscript. Il seguente programma crea un file pdf con alcune forme geometriche create con la superformula 2D.

; Per eseguire questo file, digitare: (load "superformula.lsp") nella REPL di newLISP.
; superformula2D.lsp
; by cameyo 2019
;
; Superformula 3D in coordinate polari:
; r(t) = (|cos(m1*t/4)/a|^n2 + |sin(m2*t/4)/b|^n3)^-1/n1
; x = mag*r*cos(t);
; y = mag*r*sin(t);

; Caricamento del modulo
;(load (append (env "newLISPDIR") "/modules/postscript.lsp"))
(module "postscript.lsp")

; Sfondo
(ps:goto 0 0)
(ps:fill-color 0 0 0)
(ps:line-color 0 0 0)
;(ps:shape '((0 792) (90 612) (90 792) (90 612)) true)
(ps:rectangle 612 792 true)
; Setup iniziale
(ps:line-join 2)
(ps:line-width 0.25)
(ps:fill-color 0.9 0.9 0.9)
(ps:circle 0 0)
; Centro della pagina
(setq xc (/ 612 2))
(setq yc (/ 792 2))
; Parametri
(setq m1 10)
(setq m2 10)
(setq a 1)
(setq b 1)
(setq n2 3)
(setq n3 3)
(setq n1 2)
(setq step 0.001)
(setq t 0.0)
;ciclo di disegno formula
(setq i 0)
(while (< i 6)
  (ps:fill-color (random) (random) (random))
  (setq mag (+ 150 (* i 20)))
  (while (< t 6.29)
    (setq r1 (pow (abs (div (cos (div (mul m1 t) 4)) a)) n2))
    (setq r2 (pow (abs (div (sin (div (mul m2 t) 4)) b)) n3))
    (setq r (pow (add r1 r2) (div -1.0 n1)))
    (setq x (add xc (mul mag r (cos t))))
    (setq y (add yc (mul mag r (sin t))))
    (setq t (add t step))
    (ps:goto x y)
    (ps:circle .5 true)
  )
  (++ i)
  (setq t 0.0)
)
; firma
(ps:line-color 0.77 0.77 0.77)
(ps:goto 12 12)
;(ps:angle 90)
(ps:angle 0)
(ps:font "Helvetica" 10)
(ps:text "newLISP 2019")
; salva il file postscript
(ps:save "sf2d01.ps")
; conversione del file .ps al file .pdf (ghostscript)
(! "ps2pdf sf2d01.ps sf2d03.pdf")
; eof

Questo è il file batch per la conversione da file .ps a file .pdf:

------ Inizio file batch
@echo off
rem convert postscript (.ps) file to portable document format file (.pdf)
rem with ghostscript
rem ps2pdf <file.ps> <file.pdf>
rem cameyo 2019

rem standard
rem gs -sDEVICE=pdfwrite -dBATCH -sOutputFile=aFile.pdf -r300 aFile.ps

rem windows 64 bit ghostscript
rem "c:\Program Files\gs\gs9.15\bin\gswin64c.exe" -sDEVICE=pdfwrite -dBATCH -sOutputFile=%2.pdf -r300 %1

rem windows 64 bit ghostscript (no pause)
"c:\Program Files\gs\gs9.15\bin\gswin64c.exe" -q -dNOPAUSE -sDEVICE=pdfwrite -dBATCH -sOutputFile=%2 -r300 %1
------ Fine file batch

Vediamo ora il modulo "infix.lsp", che permette di trsformare le espressioni infisse, prefisse o suffisse passate come stringhe. Restituisce una espressione newLISP, che può essere valutata (cattura gli errori di sintassi).

Carichiamo il modulo:

(module "infix.lsp")

Conversione di formule dal formato infix a newLISP:

(INFIX:xlate "(cos(m1 * t / 4) / a)")
;-> (div (cos (div (mul m1 t) 4)) a)

(INFIX:xlate "(-b + (sqrt (b ^ 2 - 4 * a * c))) / (2 * a)")
;-> (div (add -b (sqrt (sub (pow b 2) (mul (mul 4 a) c)))) (mul 2 a))

(INFIX:xlate "(a*x*x + b*x + c)")
;-> (add (add a*x*x b*x) c)

(INFIX:xlate "(a + b)/(c - d)")
;-> (div (add a b) (sub c d))

Conversione di formule dal formato postfix (rpn) a newLISP:

(INFIX:xlate "(3 4 5 + +)")
;-> (add 3 (add 4 5))

(INFIX:xlate "(5 6 + 5 7 * +)")
;-> (add 5 (add 6 (mul 5 7)))

Come ultimo esempio vediamo l'utilizzo del modulo "plot.lsp" che permette di creare alcuni tipi di grafici.
Questo modulo utilizza guiserver.jar che deve essere installato sulla cartella di newLISP.
Importazione del modulo:

(module "plot.lsp")

Test del modulo (vengono creati due grafici, anche come file .png):

(test-plot)

Un altro modulo molto utile è quello che gestisce il protocollo ftp (File Transfer Protocol): "ftp.lsp". L'utilizzo è molto semplice:

; load ftp module
(module "ftp.lsp")

;; Functions:
;; (FTP:get <str-user-id> <str-password> <str-host> <str-dir> <str-file-name>)
;; (FTP:put <str-user-id> <str-password> <str-host> <str-dir> <str-file-name>)

(set 'FTP:debug-mode true)
(FTP:put "ADMIN" "pwd-admin" "ftpzone.com" "VAS" "ex01ftp.png")
;-> true

(FTP:get "USER" "pwd-user" "ftpzone.com" "VAS" "olmeco.png")
;-> true


======================
 HASH-MAP E DIZIONARI
======================

Per newLISP una hash-map è un dizionario e viceversa.
Vediamo come simulare la struttura dati hash map con i contesti (namespace).
Un funtore predefinito di un contesto che contiene nil e si trova nella posizione di operatore simula una funzione di hash per la costruzione di dizionari con (chiave associativa → accesso al valore).

Crea un contesto (namespace) e un funtore di default di nome myHash che contiene il valore nil:

(define myHash:myHash)
;-> nil

In alternativa al metodo precedente, è possibile utilizzare un contesto predefinito e il funtore di default Tree per instanziare un nuovo contesto:

(new Tree 'myHash)
;-> myHash

Entrambi i metodi producono lo stesso risultato, ma il secondo metodo protegge anche il funtore predefinito myHash:myHash da possibili modifiche.

Adesso possiamo usare il contesto definito come una hash map.

Creiamo la chiave key con valore 123:

(myHash "var" 123)
;-> 123

Recuperiamo il valore tramite la chiave:

(myHash "var")
;-> 123

Possiamo assegnare altri valori al dizionario:

(myHash "x" "stringa")
;-> "stringa"

(myHash "x")
;-> "stringa"

(myHash "var")
;-> 123

Se una chiave non esiste, allora newLISP restituisce nil:

(myHash "valore")
;-> nil

Per eliminare una chiave occorre assegnarle il valore nil:

(myHash "var" nil)
;-> nil

(myHash "var")
;-> nil

(myHash "var" 123)
;-> 123

Per conoscere tutti i simboli del contesto myHash:

(symbols myHash)
;-> (myHash:_var myHash:_x myHash:myHash)

Le chiavi (simboli) var e x vengono memorizzate precedute dal contesto e dal carattere underscore "_".
Aggiungiamo una chiave che inizia per "_":

(myHash "_y" '(1 2))
;-> (1 2)

(dolist (el (symbols myHash)) (println el))
;-> myHash:__y
;-> myHash:_var
;-> myHash:_x
;-> myHash:myHash
;-> myHash:myHash

I simboli delle variabili create in questo modo possono contenere spazi o altri caratteri normalmente non consentiti nei nomi dei simboli newLISP:

(myHash "il numero" 123)
;-> 123
(myHash "#1234" "hello world")
;-> "hello world"
(myHash "var" '(a b c d))
;-> (a b c d)
(myHash "il numero")
;-> 123
(myHash "#1234")
;-> "hello world"
(myHash "var")
;-> (a b c d)

Comunque è consigliabile di non eccedere nell'utilizzo di questi caratteri normalmente non consentiti.

Il simbolo chiave può anche essere un numero intero (che verrà internamente convertito in stringa in modo trasparente all'utente):

(myHash 1 "uno")
;-> "uno"

(myHash 1)
;-> "uno"

(myHash "1")
;-> "uno"

Possiamo vedere tutti gli elementi del dizionario (coppie chiave-valore) utilizzando (valutando) il nome del contesto:

(myHash)
;-> (("#1234" "hello world") ("1" "uno") ("_y" (1 2))
;->  ("il numero" 123) ("var" (a b c d)) ("x" "stringa"))

Ma myHash non è una lista:

(list? myHash)
;-> nil

Però possiamo usare lo stesso dolist su un contesto hash per elencare tutte le coppie chiave-valore del dizionario:

(dolist (cp (myHash)) (println (list (cp 0) (cp 1))))
;-> ("#1234" "hello world")
;-> ("1" "uno")
;-> ("_y" (1 2))
;-> ("il numero" 123)
;-> ("var" (a b c d))
;-> ("x" "stringa")
;-> ("x" "stringa")

Per creare una lista di associazione dal dizionario hash basta assegnare la valutazione del contesto (dizionario) ad una variabile:

(setq alst (myHash))
;-> (("#1234" "hello world") ("1" "uno") ("_y" (1 2))
;->  ("il numero" 123) ("var" (a b c d)) ("x" "stringa"))

(list? alst)
;-> true

Per popolare un dizionario possiamo anche usare una lista:

(myHash '((3 4) (5 6)))
;-> myHash

(myHash)
;-> (("#1234" "hello world") ("1" "uno") ("3" 4) ("5" 6) ("_y" (1 2))
;->  ("il numero" 123) ("var" (a b c d)) ("x" "stringa"))

Nota: le chiavi del dizionario sono ordinate in maniera lessicografica.

Cosa accade alle liste che hanno valori della chiave ripetuti?

Nella lista seguente le chiavi "1" e "3" sono ripetute:

(setq lst '(("4" 4) ("1" 0) ("2" 2) ("3" 0) ("1" 1) ("3" 3) ("5" 5)))

Quando assegniamo la lista ad una hash-map i valori con chiave multipla vengono memorizzati soltanto una volta...ma quali elementi sceglie e quali elimina newLISP?
Facciamo una prova:

(new Tree 'hash)
(hash lst)
;-> hash
(hash)
;-> (("1" 1) ("2" 2) ("3" 3) ("4" 4) ("5" 5))

Gli elementi ("1" 0) e ("3" 0) sono stati eliminati... cioè quelli che si trovavano prima.
In newLISP la hash-map inserisce gli elementi partendo dal fondo della lista (poi nella hash-map gli elementi sono ordinati in base alla chiave). Quindi quando incontra elementi multipli prende l'ultimo che compare nella lista (cioè il primo partendo dal fondo della lista).


Come molte delle funzioni integrate, le espressioni hash restituiscono un riferimento al loro contenuto che può essere modificato direttamente:

(pop (myHash "var"))
;-> a

(myHash "var")
;-> (b c d)

(push 'z (myHash "var"))
;-> (z b c d)

(myHash "var")
;-> (z b c d)

Quando si impostano i valori hash, la variabile anaforica di sistema "$it" può essere utilizzata per riferirsi al vecchio valore quando si imposta il nuovo:

(myHash "bar" "hello world")
;-> "hello world"

(myHash "bar" (upper-case $it))
;-> "HELLO WORLD"

(myHash "bar")
;-> "HELLO WORLD"

I valori hash possono essere modificati anche usando "setf":

(myHash "bar" 123)
;-> 123

(setf (myHash "bar") 456)
;-> 456

(myHash "bar")
;-> 456

Ma fornire il valore come secondo parametro alle funzioni hash è più breve da scrivere ed è anche più veloce.

I dizionari possono essere facilmente salvati in un file e ricaricati in un secondo momento:

; save dictionary
(save "myHash.lsp" 'myHash)
;-> true

Ecco il contenuto del file "myHash.lsp":

(context 'myHash)
(set '_#1234 "hello world")
(set '_3 4)
(set '_5 6)
(set '__y '(1 2))
(set '_bar 456)
(set  (sym "_il numero" MAIN:myHash)  123)
(set '_var '(MAIN:a MAIN:b MAIN:c MAIN:d))
(set '_x "stringa")
(context MAIN)

; load dictionary
(load "myHash.lsp")

Internamente le stringhe chiave vengono create e memorizzate come simboli nel contesto dell'hash. Come abbiamo viato, tutte le stringhe chiave sono precedute da un carattere di sottolineatura "_". Questo protegge contro la sovrascrittura del simbolo di default a dalle funzioni set and sym che sono necessarie per caricare il contesto dell'hash (namespace) da disco o tramite http. Nota le seguente differenza:

(myHash)
;-> (("#1234" "hello world") ("1" "uno") ("3" 4) ("5" 6) ("_y" (1 2))
;->  ("bar" "HELLO WORLD") ("il numero" 123) ("var" (z b c d)) ("x" "stringa"))

(symbols myHash)
;-> (myHash:_#1234 myHash:_1 myHash:_3 myHash:_5 myHash:__y myHash:_bar
;->  myHash:_il numero myHash:_var myHash:_x myHash:myHash)

Nella prima riga i simboli di hash sono mostrati come stringhe senza i caratteri di sottolineatura. La seconda riga mostra la forma interna dei simboli con anteposti i caratteri di sottolineatura.

Per vedere se esiste un valore nel dizionario occorre interrogare tutte le chiavi:

(define (hasValue val hash)
  (catch
    (dolist (cp (hash))
      (if (= (cp 1) val) (throw true))
    )
  )
)

(hasValue '(1 2) myHash)
;-> true

(hasValue '(1) myHash)
;-> nil

Per vedere se esiste una chiave nel dizionario non occorre interrogare tutte le chiavi:

(myHash "var")
;-> (z b c d)

(myHash "k")
;-> nil

Quindi possiamo scrivere la seguente funzione:

(define (hasKey? key hash) (if (hash key) true nil))

(hasKey? "var" myHash)
;-> true

(hasKey? "#1234" myHash)
;-> true

Possiamo fare lo stesso con un ciclo dolist:

(define (hasKey? key hash)
  (catch
    (dolist (cp (hash))
      (if (= (cp 0) key) (throw true))
    )
  )
)

(hasKey? "var" myHash)
;-> true

(hasKey? "#1234" myHash)
;-> true

Quindi esistono due metodi per iterare in una hash map:

; crea un dizionario
(context 'pippo "A" 111)
(context 'pippo "B" 222)
(context 'pippo "C" 333)

metodo 1:
; mostra tutte le coppie di valori/chiave in ordine alfabetico
(dotree (s pippo)
     (println s "->" (eval s)))
;-> pippo:A->111
;-> pippo:B->222
;-> pippo:C->333

metodo 2:
; metodo alternativo
(dolist (s (symbols pippo))
     (println s "->" (eval s)))
;-> pippo:A->111
;-> pippo:B->222
;-> pippo:C->333

Invece di "context" è possibile usare "sym" per creare/testare/modificare simboli.
A volte è più conveniente, dipende dalla situazione.

Definiamo alcune funzioni per gestire le hash map (dizionario).

Creazione di una nuova hash map:
--------------------------------

(define (newHash hash) (new Tree hash))

(newHash 'dictA)
;-> dictA
(dictA)
;-> ()
(newHash 'dictB)
;-> dictB

Creazione/modifica di una coppia chiave -> valore nella hash map:
-----------------------------------------------------------------

(define (addHash key value hash) (hash key value))

(addHash "var" 20 dictA)
;-> 10
(addHash "num" 42 dictA)
;-> 42
(dictA)
;-> (("num" 42) ("var" 20))

Cancellazione di una coppia chiave -> valore:
---------------------------------------------

(define (removeHash key hash) (hash key nil))

(removeHash "var" dictA)
;-> nil
(dictA)
;-> (("num" 42))
(addHash "var" 22 dictA)
;-> 22

Conversione da hash map a lista associativa:
--------------------------------------------
Creiamo una lista con tutte le coppie chiave-valore del dizionario

(define (hash2list hash) (hash))

(setq lstA (hash2list dictA))
;-> (("num" 42) ("var" 22))

Aggiornamento hash map da lista associativa:
--------------------------------------------

(define (list2hash lst hash) (if (= hash nil) nil (hash lst)))

(list2hash lstA dictB)
;-> dictB
(dictB)
;-> (("num" 42) ("var" 22))

Se la hash map non esiste, allora viene restituito nil:

(list2hash lstA dictC)
;-> nil

Lunghezza della hash map:
-------------------------

(define (lenHash hash) (if (= hash nil) nil (length (hash))))

(lenHash dictA)
;-> 2

(lenHash dictC)
;-> nil

Controllo presenza valore in hash map:
--------------------------------------

(define (hasValue val hash)
  (if (= hash nil) nil
    (catch
      (dolist (cp (hash))
        (if (= (cp 1) val) (throw true))
      )
    )
  )
)

(hasValue 22 dictA)
;-> true
(hasValue 22 dictC)
;-> nil

Controllo presenza chiave in hash map:
--------------------------------------

(define (hasKey key hash) (if (= hash nil) nil (if (hash key) true nil)))

(hasKey "num" dictA)
;-> true
(hasKey "nome" dictA)
;-> nil
(hasKey "num" dictC)
;-> nil

Estrazione di tutte le chiavi in una lista:
-------------------------------------------

(define (getKeys hash)
  (local (out)
    (dolist (cp (hash))
      (push (cp 0) out -1)
    )
  out
  )
)

(getKeys myHash)
;-> ("#1234" "1" "_y" "bar" "il numero" "var" "x")

Estrazione di tutti i valori in una lista:
------------------------------------------

(define (getValues hash)
  (local (out)
    (dolist (cp (hash))
      (push (cp 1) out -1)
    )
  out
  )
)

(getValues myHash)
;-> ("hello world" "uno" (1 2) "hello world" 123 (a b c d) "stringa")

Duplicazione (copia) di un hash:
--------------------------------
Basta assegnare il dizionario ad una variabile.

(setq Pippo myHash)
;-> myHash

(Pippo)
;-> (("#1234" "hello world") ("3" 4) ("5" 6) ("_y" (1 2)) ("bar" 456)
;->  ("il numero" 123) ("var" (a b c d)) ("x" "stringa"))

Le liste associative possono essere annidate:

(setq data '((1 ("Sara" (storia geografia italiano))) (2 ("Luca" (matematica storia)))))
;-> (1 ("Sara" (storia geografia italiano)))

(lookup 1 data)
;-> ("Sara" (storia geografia italiano))

(assoc 1 data)
;-> (1 ("Sara" (storia geografia italiano)))

Possiamo estrarre le materie associate a Sara:

(assoc "Sara" (assoc 1 data))
;-> ("Sara" (storia geografia italiano))

(lookup "Sara" (assoc 1 data))
;-> (storia geografia italiano)

In generale per aggiornare il valore associato ad una chiave esistente (di un dizionario data) possiamo scrivere:

(letn (key "chiave")
   (if (lookup key data)
       (setf (assoc key data) (list key "nuovo valore"))))

Invece, per aggiungere una materia a "Sara":

(if (lookup "Sara" (assoc 1 data))
    (setf (lookup "Sara" (assoc 1 data)) (push 'matematica (lookup "Sara" (assoc 1 data)) -1)))

Possiamo avere una chiave che si autoincrementa in una hash-map (dizionario):

(new Tree 'Hash)
;-> Hash
(Hash (format "%05d" (inc Hash:counter)) "A")
;-> "A"
(Hash (format "%05d" (inc Hash:counter)) "B")
;-> "B"
(Hash)
;-> (("00001" "A") ("00002" "B"))
(symbols Hash)
;-> (Hash:Hash Hash:_00001 Hash:_00002 Hash:counter)

La variabile 'Hash:counter' viene creata automaticamente quando newLISP legge l'espressione e la funzione "inc" cambia il suo valore da "nil" a 0 (zero). La funzione "format" assicura che l'ordine di creazione sia corretto. Lutz

Per creare una hashmap invece di (define hash:hash) usare (new Tree 'hash) che fa la stessa cosa, ma rende anche la funzione predefinita hash:hash una costante (contenente nil).

Un buon stile di programmazione è quello di definire tutti gli hash e gli altri contesti nel modulo di contesto MAIN come tutti gli altri simboli usati a livello globale. Nei progetti più grandi di newLISP o quando si lavora in un gruppo di programmatori sullo stesso progetto, i conflitti/problemi possono essere evitati/minimizzati in questo modo.
Chiamiamo i dizionari di contesto spesso "hash", ma non esiste una funzione di hash alla base di esso. "Hash" è solo un nome conveniente poiché la maggior parte degli altri linguaggi implementa la funzionalità di ricerca utilizzando le funzioni hash.
In newLISP i dizionari sono basati su alberi binari bilanciati rosso-nero (AVL red-black tree) separati e solo la radice del dizionario - il nome del contesto - fa parte dello spazio principale dei simboli MAIN.

Suggerimento:
il contesto è un valore, quindi possiamo usare (uuid) per generare un simbolo univoco in MAIN, quindi trasformarlo in un contesto. Ma non c'è garbage collection, devi eliminare tu stesso il contesto.

(set 'a (new Tree (sym (string "_" (uuid)) MAIN)))

Eliminare il contesto in questo modo:

(set 'name (sym (term a) MAIN)) ; trova il nome del contesto in MAIN
(delete name) ; elimina il contesto
(delete name) ; elimina il simbolo in MAIN

Cancellazione di un contesto
----------------------------
Quando si elimina un simbolo di contesto, la prima eliminazione rimuove il contenuto dello spazio dei nomi di contesto e riduce il simbolo a un normale simbolo mono-variabile. La seconda eliminazione rimuove quindi completamente il simbolo dalla tabella dei simboli. Questo metodo è necessario quando si utilizzano simboli di variabili locali in funzioni come contesti.

In generale: non cancellare di spazi dei nomi nei programmi newLISP di dimensioni non banali. Tranne quando si usa il flag nil nel comando delete, i simboli vengono controllati come riferimento nell'intero spazio di memoria delle celle newLISP, che può rallentare molto su programmi grandi con dati grandi.

I contesti non sono pensati per essere creati ed eliminati in modo frequente. Anche se è possibile farlo, ci sono altri modi per ottenere qualcosa di globale, che rimane attivo per l'intera esecuzione del programma.

Per tale motivo, nella FOOP i contesti vengono utilizzati principalmente come contenitori per le classi e i metodi, mentre i dati sono normali liste LISP, che sono gestite automaticamente dalla memoria di newLISP. Se usi i contesti come oggetti, la loro gestione della memoria è manuale e quindi non è molto efficiente.

Per cancellare un contesto dobbiamo usare:

(delete 'S) oppure (delete 'S true)

che non sono la stessa cosa anche se entrambi effettuano il controllo dei riferimenti.
Infatti, (delete 'S true) restituirà nil quando viene trovato un riferimento. (delete 'S) sostituisce tutti i riferimenti trovati con nil.
In definitiva abbiamo davvero 3 modalità:

(delete 'S) controlla i riferimenti e li sostituisce con nil.

(delete 'S true) controlla i riferimenti e restituisce nil quando vengono trovati riferimenti.

(delete 'S nil) ignora i riferimenti, elimina soltanto (metodo non sicuro se esistono riferimenti).

Con i contesti è un processo in due passaggi: il primo elimina i contenuti del contesto, il secondo elimina il simbolo del contesto.
L'eliminazione dei contesti in due fasi è necessaria quando lo stesso simbolo viene utilizzato come contesto, quindi il contenuto del contesto viene eliminato, e poi lo stesso simbolo ottiene nuovamente un contesto.


======================
 CAR E CDR IN newLISP
======================

La spiegazione del nome delle istruzioni CAR e CADR direttamente dall'autore Steve Russell:

"I wrote the first implementation of a LISP interpreter on the IBM 704 at MIT in early in 1959.
The 704 family (704, 709, 7090) had "Address" and "Decrement" fields that were 15 bits long in some of the looping instructions.
There were also special load and store instructions that moved these 15-bit addresses between memory and the index regiseters ( 3 on the 704, 7 on the others ).
We had devised a representation for list structure that took advantage of these instructions.
Because of an unfortunate temporary lapse of inspiration, we couldn't think of any other names for the 2 pointers in a list node than "address" and "decrement", so we called the functions CAR for "Contents of Address of Register" and CDR for "Contents of Decrement of Register".
After several months and giving a few classes in LISP, we realized that "first" and "rest" were better names, and we (John McCarthy, I and some of the rest of the AI Project) tried to get people to use them instead. Alas, it was too late! We couldn't make it stick at all.
So we have CAR and CDR."

newLISP chiama "first" la funzione "CAR" e chiama "rest" la funzione "CDR".

Sebbene auto e cdr siano stati nomi poco ispirati per quasi 50 anni, sono sopravvissuti perché offrono una geniale funzionalità: puoi aggiungere più lettere a e d tra "c" e "r", per produrre funzioni con nomi anche più strani.
Allora "caddr" trova il "car" del "cdr" del "cdr", leggiamo da sinistra a destra, sebbene le funzioni siano applicate da destra a sinistra come al solito.

Come vengono pronunciate queste funzioni?

Dal libro "Common Lisp: A Gentle Introduction to Symbolic Computation" di David S. Touretzky:

CAR/CDR Pronunciation Guide
---------------------------

Function       Pronunciation    Alternate Name
CAR            kar              FIRST
CDR            cou-der          REST
CAAR           ka-ar
CADR           kae-der          SECOND
CDAR           cou-dar
CDDR           cou-dih-der
CAAAR          ka-a-ar
CAADR          ka-ae-der
CADAR          ka-dar
CADDR          ka-dih-der       THIRD
CDAAR          cou-da-ar
CDADR          cou-dae-der
CDDAR          cou-dih-dar
CDDDR          cou-did-dih-der
CADDDR         ka-dih-dih-der   FOURTH
...

Possiamo definire queste funzioni in newLISP:

; =======================================
; Funzioni CAR e CDR
; C????R (quattro livelli)
; =======================================
(define (car x)    (first x))
(define (cdr x)    (rest x))
(define (caar x)   (first (first x)))
(define (cadr x)   (first (rest x)))
(define (cdar x)   (rest (first x)))
(define (cddr x)   (rest (rest x)))
(define (caaar x)  (first (first (first x))))
(define (caadr x)  (first (first (rest x))))
(define (cadar x)  (first (rest (first x))))
(define (caddr x)  (first (rest (rest x))))
(define (cdaar x)  (rest (first (first x))))
(define (cdadr x)  (rest (first (rest x))))
(define (cddar x)  (rest (rest (first x))))
(define (cdddr x)  (rest (rest (rest x))))
(define (caaaar x) (first (first (first (first x)))))
(define (caaadr x) (first (first (first (rest x)))))
(define (caadar x) (first (first (rest (first x)))))
(define (caaddr x) (first (first (rest (rest x)))))
(define (cadaar x) (first (rest (first (first x)))))
(define (cadadr x) (first (rest (first (rest x)))))
(define (caddar x) (first (rest (rest (first x)))))
(define (cadddr x) (first (rest (rest (rest x)))))
(define (cdaaar x) (rest (first (first (first x)))))
(define (cdaadr x) (rest (first (first (rest x)))))
(define (cdadar x) (rest (first (rest (first x)))))
(define (cdaddr x) (rest (first (rest (rest x)))))
(define (cddaar x) (rest (rest (first (first x)))))
(define (cddadr x) (rest (rest (first (rest x)))))
(define (cdddar x) (rest (rest (rest (first x)))))
(define (cddddr x) (rest (rest (rest (rest x)))))

(cadadr '(0 (1 2 3) 4 5))
;-> 2

(cadr (cdr '(7 3 5)))
;-> 5

(caddr '(7 3 5))
;-> 5

Per ottimizzare le funzioni sarebbe meglio scrivere:

(define car first)
;-> first@4071B9
(define cdr rest)
;-> rest@4072CA

In questo modo newLISP lavora molto più velocemente:

(define (car1 x) (first x))
(define (cdr1 x) (rest x))

(time (car '(1 2 3 4 5 6 7 8 9 0)) 10000000)
;-> 171.873

(time (car1 '(1 2 3 4 5 6 7 8 9 0)) 10000000)
;-> 1468.897

È possibile generare/definire queste funzioni in maniera automatica con una funzione (fornita da Kazimir Majorinc):

(define (car x) (first x))
(define (cdr x) (rest x))

(define (cdadderize x)
  (inc 'x)
  (set 'results '())
  (until (= x 0)
     (push   (% x 2) results)
     (set 'x (/ x 2)))
  (set 'results (rest results) 'f-name results)
  (map (fn (a b) (replace a results b)) '(0 1) '("(car " "(cdr "))
  (push (string "x"  (dup ")" (length results))) results -1)
  (set 'results (join results))
  (map (fn (a b) (replace a f-name b)) '(0 1) '("a" "d"))
  (letex ((fnm   (sym (string "c" (join f-name) "r")))
          (body results))
    (define (fnm x) (eval-string body))
    fnm))

Eseguiamo questa funzione:

(cdadderize 14)
;-> (lambda (x) (eval-string "(cdr (cdr (car x)))"))

Verifichiamo quali funzione sono state aggiunte controllando la tabella dei simboli:

(define (list-car-cdr)
  (filter (fn (s)
      (and (starts-with (string s) "ca|cd" 0)
          (ends-with (string s) "r")))
      (symbols)))

(list-car-cdr)
;-> (car cddar cdr)

Per generare le funzioni car e cdr fino ad un certo limite:

; genera tutte le funzioni cXXXr:
(for (i 3 14) (cdadderize i)) ; 1 e 2 sono già definite
;-> (lambda (x) (eval-string "(cdr (cdr (car x)))"))
(list-car-cdr)
;-> (caaar caadr caar cadar caddr cadr car cdaar cdadr cdar cddar cddr cdr)

; genera tutte le funzioni cXXXXr:
(for (i 3 30) (cdadderize i))
;-> (lambda (x) (eval-string "(cdr (cdr (cdr (car x))))"))
(list-car-cdr)
;-> (caaaar caaadr caaar caadar caaddr caadr caar cadaar cadadr cadar
;->  caddar cadddr caddr cadr car cdaaar cdaadr cdaar cdadar cdaddr
;->  cdadr cdar cddaar cddadr cddar cdddar cdddr cddr cdr)

; genera tutte le funzioni cXXXXXXXXXr:
(for (i 3 1022) (cdadderize i))
;-> (lambda (x) (eval-string "(cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (car x)))))))))"))
(list-car-cdr)

Proviamo alcune di queste le funzioni:

(setq lst '((a (b (c (d)) (e) (f (g (h (i)) (j)) (k (l (m (n)) (o))))))
           (p (q (r (s)) (t) (u (v (x (y)) (w)) (z (z (z (z)) (z))))))))

(caar lst)
;-> a

(cadr lst)
;-> ((b (c (d)) (e) (f (g (h (i)) (j)) (k (l (m (n)) (o))))))

(cadadr lst)
;-> (q (r (s)) (t) (u (v (x (y)) (w)) (z (z (z (z)) (z)))))

(cadadadr lst)
;-> (r (s))

(cadaddar lst)
;-> ERR: list is empty : (cdr (cdr (car x)))
;-> called from user function (cadaddar lst)


======================
 ESPRESSIONI REGOLARI
======================

Le espressioni regolari (regex o regexp) sono estremamente utili per estrarre informazioni da qualsiasi testo cercando una o più corrispondenze di un modello (pattern) di ricerca specifico (ovvero una sequenza specifica di caratteri ASCII o unicode).
I campi di applicazione sono convalida di dati, analisi/sostituzione di stringhe, trasformazione di dati in altri formati, web scraping, syntax highlighting, ecc.
Una delle caratteristiche più interessanti è che una volta appresa la sintassi, puoi utilizzare questo strumento in (quasi) tutti i linguaggi di programmazione con minime distinzioni in base al tipo di supporto fornito dal linguaggio utilizzato.

newLISP utilizza le espressioni regolari di tipo PCRE (Perl Compatible Regular Expressions).
Per maggior informazioni consultare: https://www.pcre.org/

Le funzioni newLISP che utilizzano le regex sono:

1) directory
2) find
3) find-all
4) parse
5) regex
6) regex-comp
7) replace
8) search

Vediamo come viene definita nel manuale la funzione "regex".

******************
>>>funzione REGEX
******************
sintassi: (regex str-pattern str-text [regex-option [int-offset]])

Esegue una ricerca PCRE compatibile su str-text con il pattern (modello) specificato in str-pattern. La stesso modello di espressione regolare è supportato anche nelle funzioni directory, find, find-all, parse, replace, e search quando vengono usate con delle stringhe.

regex restituisce una lista con le stringhe e le sottostringhe trovate e l'inizio (offset) e la lunghezza di ciascuna stringa all'interno del testo. Se non viene trovata alcuna corrispondenza, restituisce nil. È possibile utilizzare i numeri di offset per una elaborazione successiva.

Inoltre, è possibile specificare una opzione regex per controllare alcune opzioni delle espressioni regolari definite in seguito. Le opzioni possono essere fornite da numeri o lettere in una stringa.

Il parametro int-offset aggiuntivo dice a regex di iniziare la ricerca di una corrispondenza non dall'inizio della stringa, ma da un offset specifico.

Quando non è presente alcuna opzione regex, i numeri di offset e i numeri di lunghezza di regex sono calcolati in base ai byte, anche quando si esegue la versione abilitata UTF-8 di newLISP. Quando si specifica l'opzione PCRE_UTF8 in regex-option, sono calcolati come caratteri UTF8 solo l'offset e la lunghezza in caratteri.

regex imposta anche le variabili $0, $1 e $2 relative all'espressione e alle sottoespressioni trovate. Proprio come qualsiasi altro simbolo in newLISP, queste variabili o le loro espressioni equivalenti ($0), ($1) e ($2), possono essere utilizzate in altre espressioni newLISP per ulteriori elaborazioni.

Le funzioni che usano espressioni regolari non resettano le variabili $0, $1 ... $15 a nil quando non viene trovata alcuna corrispondenza.

(regex "b+" "aaaabbbaaaa")  → ("bbb" 4 3)

; ricerca senza distinzione tra maiuscole e minuscole - opzione 1
(regex "b+" "AAAABBBAAAA" 1)  → ("BBB" 4 3)
; stessa opzione, ma passata come stringa "i"
(regex "b+" "AAAABBBAAAA" "i")  → ("BBB" 4 3)

(regex "[bB]+" "AAAABbBAAAA" )  → ("BbB" 4 3)

(regex "http://(.*):(.*)" "http://nuevatec.com:80")
→ ("http://nuevatec.com:80" 0 22 "nuevatec.com" 7 12 "80" 20 2)

$0  → "http://nuevatec.com:80"
$1  → "nuevatec.com"
$2  → "80"

(dotimes (i 3) (println ($ i)))
http://nuevatec.com:80
nuevatec.com
80
→ "80"

Il secondo esempio mostra l'uso di opzioni extra, mentre il terzo esempio mostra l'analisi più complessa di due sottoespressioni che sono state contrassegnate da parentesi nel modello di ricerca. Nell'ultimo esempio, l'espressione e le sottoespressioni vengono recuperate utilizzando le variabili di sistema da $0 a $2 o la loro espressione equivalente ($0) a ($2).

Quando i caratteri "" (virgolette) vengono utilizzate per delimitare le stringhe che includono caratteri di backslash \, il carattere backslash deve essere raddoppiato nel modello di espressione regolare "\\". In alternativa, è possibile utilizzare i caratteri {} (parentesi graffe) o [testo] e [/ testo] (tag di testo) per delimitare le stringhe di testo. In questi casi, non sono richieste backslash aggiuntivi.

I caratteri protetti con un backslash (escaped) in newLISP (ad esempio, il carattere quote \" o \n)" non devono essere raddoppiati in un modello di espressione regolare, che a sua volta è delimitato da virgolette.

; doppio backslash per le parentesi e altri caratteri speciali delle regex
(regex "\\(abc\\)" "xyz(abc)xyz")  → ("(abc)" 3 5)

; doppio backslash per il backslash (carattere speciale delle regex)
(regex "\\d{1,3}" "qwerty567asdfg")  → ("567" 6 3)

; un solo backslash per il carattere quote (carattere speciale in newLISP)
(regex "\"" "abc\"def")  → ("\"" 3 1)

; parentesi graffe (brackets) come delimitatori
(regex {\(abc\)} "xyz(abc)xyz")  → ("(abc)" 3 5)

; parentesi graffe (brackets) come delimitatori e carattere quote nel pattern
(regex {"} "abc\"def")  → ("\"" 3 1)

; tag [text] come delimitatore, utile per testi multilinea
(regex [text]\(abc\)[/text] "xyz(abc)xyz")  → ("(abc)" 3 5)
(regex [text]"[/text] "abc\"def")           → ("\"" 3 1)

Quando vengono utilizzate parentesi graffe o il tag [text] per delimitare la stringa del modello anziché le virgolette, è sufficiente un semplice backslash. Il modello e la stringa vengono quindi passati in forma grezza alle routine delle espressioni regolari. Quando le parentesi graffe vengono utilizzate all'interno di un modello delimitato da parentesi graffe, le parentesi interne devono essere bilanciate, come segue:

; le parentesi graffe nel pattern sono bilanciate
(regex {\d{1,3}} "qwerty567asdfg")  → ("567" 6 3)

Le seguenti costanti possono essere usate per regex-option.
Diverse opzioni possono essere combinate usando un operatore "or" binario | (pipe). Per esempio, (| 1 4) combina le opzioni 1 e 4 oppure la stringa "is" quando si usano le lettere per le due opzioni.

Le ultime due opzioni sono specifiche per newLISP.
L'opzione REPLACE_ONCE deve essere utilizzata solo in sostituzione e può essere combinata con altre opzioni PCRE.

È possibile combinare più opzioni usando + (più) o | (or) operatore, ad esempio, (| PCRE_CASELESS PCRE_DOTALL) oppure la stringa "is" quando si usano le lettere come opzioni.

PCRE name            num        description
---------            ---        -----------
PCRE_CASELESS          1 or i   treat uppercase like lowercase
PCRE_MULTILINE         2 or m   limit search at a newline like Perl's /m
PCRE_DOTALL            4 or s   . (dot) also matches newline
PCRE_EXTENDED          8 or x   ignore whitespace except inside char class
PCRE_ANCHORED         16 or A   anchor at the start
PCRE_DOLLAR_ENDONLY   32 or D   $ matches at end of string, not before newline
PCRE_EXTRA            64        additional functionality currently not used
PCRE_NOTBOL          128        first ch, not start of line; ^ shouldn't match
PCRE_NOTEOL          256        last char, not end of line; $ shouldn't match
PCRE_UNGREEDY       512i or U   invert greediness of quantifiers
PCRE_NOTEMPTY       1024        empty string considered invalid
PCRE_UTF8           2048 or u   pattern and strings as UTF-8 characters
REPLACE_ONCE      0x8000        replace only one occurrence only for use in replace
PRECOMPILED      0x10000 or p   pattern is pre-compiled, can only be combined with RREPLACE_ONCE 0x8000

Le impostazioni delle opzioni PCRE_CASELESS, PCRE_MULTILINE, PCRE_DOTALL e PCRE_EXTENDED possono essere modificate all'interno del modello da una sequenza di lettere di opzione racchiuse tra "(?" e ")". Le lettere delle opzioni sono:

  i for PCRE_CASELESS
  m for PCRE_MULTILINE
  s for PCRE_DOTALL
  x for PCRE_EXTENDED

Nota che la sintassi delle espressioni regolari è molto complessa e ricca di funzionalità con molti caratteri e forme speciali. Per ulteriori dettagli, consultare un libro o le pagine del manuale di PCRE. La maggior parte dei libri PERL o introduzioni a Linux o Unix contengono anche capitoli sulle espressioni regolari. Vedi anche http://www.pcre.org per ulteriori riferimenti e la consultazione delle pagine del manuale.

I pattern di espressione regolari possono essere precompilati, per una maggiore velocità quando si usano i pattern in modo ripetuto, con regex-comp.
-----------------------------------------------------------

Quindi per usare in modo proficuo le espressioni regolari occorre imparare come devono essere costruiti i pattern regex in relazione alle ricerche che vogliamo affettuare. In questo contesto ci limiteremo ad affrontare i pattern di ricerca e sostituzione più comuni e come utilizzarli all'interno di newLISP.

Le espressioni regolari sono stringhe che contengono caratteri e metacaratteri. I caratteri vengono valutati in modo letterale, mentre i metacaratteri assumono un significato speciale. Vediamo la lista dei metacaratteri principali:

Metacarattere   Significato
-------------   -----------
  .             qualsiasi carattere (tranne newline)
  *             zero o più occorrenze (carattere o gruppo di caratteri)
  ?             zero o una occorrenza (carattere o gruppo di caratteri)
  {}            numero esatto o minimo o massimo o l’intervallo di occorrenze (carattere o gruppo di caratteri)
  +             una o più occorrenze (carattere o gruppo di caratteri)
  ^             inizio della stringa (o la negazione di un gruppo di caratteri)
  $             fine della stringa
  |             operatore OR
  \             carattere di escape per i caratteri speciali
  ()            contengono una sottostringa
  []            contengono una 'classe' di caratteri

Per utilizzare i metacaratteri come "valori letterali" devono essere preceduti dal carattere di escap backslash " \ ". Ad esempio, se volessimo ricercare il carattere punto interrogativo "?" all'interno di una stringa, dovremmo scrivere: \?

Esaminiamo meglio i singoli metacaratteri.

"[]"
Le parentesi quadre [], come si è accennato, racchiudono una 'classe' di caratteri. Questo vuol dire che il modello può o deve contenere alcuni o tutti i caratteri in esse contenute. Vediamo alcuni esempi:

[abc]
questo modello è soddisfatto quando viene trovata una delle lettere, senza tener conto dell’ordine in cui sono presenti:

[a-z]
in questo modello è presente un intervallo di caratteri (notare il segno -, sta per "dalla a alla z"), esso è soddisfatto quando viene trovato uno qualsiasi dei caratteri compresi nell’intervallo;

[0-9]
in questo modello è presente invece un intervallo di numeri, esso è soddisfatto quando viene trovato uno qualsiasi dei numeri compresi nell’intervallo;

[a-z0-9?]
questo modello è leggermente più complesso, ma dovrebbe essere di facile comprensione. La corrispondenza viene trovata quando la stringa contiene una lettera (minuscola in questo caso), un numero o il carattere ? (notate il segno prima di ?, perché il punto interrogativo è un carattere speciale, che qui però assumiamo per il suo valore letterale);

[^a-z]
questo modello è soddisfatto quando viene trovato un qualsiasi carattere che non sia una lettera minuscola (notate il segno ^ che all’interno della classe, la nega);

Naturalmente una classe di caratteri può essere seguita (e normalmente lo è) da uno dei metacaratteri che indicano il numero di volte in cui uno dei caratteri in essa contenuti, deve essere presente, riprendendo l’ultimo modello:

[a-z0-9?]?
i caratteri contenuti nella classe devono essere presenti zero o una volta;

[a-z0-9?]*
i caratteri contenuti nella classe devono essere presenti zero o più volte;

[a-z0-9?]{3}
i caratteri contenuti nella classe devonoo essere presenti esattamente tre volte;

[a-z0-9?]{1,3}
i caratteri contenuti nella classe devono essere presenti da una a tre volte;

[a-z0-9?]{3,}
i caratteri contenuti nella classe devono essere presenti minimo tre volte;

[a-z0-9?]{,3}
i caratteri contenuti nella classe devono essere presenti massimo tre volte.

Le parentesi graffe, come abbiamo già visto, indicano il numero esatto, minimo, massimo o l’intervallo di volte in cui una un’esatta sequenza o una classe di caratteri, devono essere presenti in una stringa:

{3} esattamente 3 volte;
{3,} minimo 3 volte;
{,3} massimo 3 volte;
{1,3} da 1 a 3 volte;

"()"
Le parentesi tonde, invece, fanno riferimento ad una sottostringa, o una parte di stringa se preferite, che viene assunta per il suo esatto valore letterale.

Quindi ad esempio (abc) si riferisce all’esatta sequenza di caratteri abc, a differenza, come abbiamo visto, di [abc] che si riferisce invece ad uno dei tre caratteri.

Ovviamente anche le parentesi tonde, possono essere usate con quei metacaratteri che indicano il numero di volte in cui la sottostringa deve ripetersi, per cui l’espressione (casa)? indica la presenza opzionale della parola casa (o, il che è lo stesso, che la parola deve essere presente zero o una volta).

Ma le parentesi tonde sono molto importanti anche e soprattutto perche le parti di stringa (o le espressioni) in esse contenute, possono essere "utilizzate" per vari scopi (un replace per dirne uno), ma lo vedremo più avanti quando faremo un cenno alle funzioni PHP sulle Espressioni Regolari.

Descriviamo adesso brevemente, gli altri metacaratteri.

"."
Partiamo dal punto che sta per qualsiasi carattere escluso un accapo, per cui, ad esempio, l’espressione (.)+ indica qualsiasi carattere ripetuto una o più volte (nella pratica è difficile che questo modello non trovi corrispondenza…).

"|"
Dei caratteri *,? e + abbiamo già detto in relazioni alle classi e alle sottostringhe. Il carattere | (pipe) indica l’operatore OR e consente, quindi, di presentare più alternative per un’espressione: ad esempio (bello|normale|brutto) va letta come "bello o normale o brutto" ed è quindi soddisfatta quando solo una delle tre parole viene trovata nella stringa analizzata.

"^"
Sul carattere ^ vale la pena di soffermarsi un attimo perchè, come accennato, esso assume una duplice valenza, a seconda del punto in cui si trovi all’interno dell’Espressione Regolare ed occorre quindi porre molta attenzione nel suo uso.

Se posto all’inizio del modello, tale carattere indica l’inizio esatto dello stesso: ^(ciao) indica infatti che la stringa deve iniziare con la parola ciao. Ma l’accento circonflesso, se posto all’interno di una classe di caratteri, nega la stessa: [^0-9] indica qualsiasi carattere che non sia un numero.

"$"
Infine, il carattere $ indica la fine di una stringa, per cui se viene usato in combinazione con ^, è possibile costruire un’Espressione Regolare che indichi un modello esattamente contenuto in una stringa, ad esempio ^Ciao come stai ?$, o che indichi l’esatto inizio e l’esatta fine di una stringa, ad esempio ^(Ciao) [a-zA-Z]+ (come stai ?)$

Le Espressioni Regolari, conoscono anche, per così dire, delle abbreviazioni per ottenere ciò che si desidera, in relazione, ad esempio, alle classi di caratteri usate più di frequente. Eccone di seguito un breve schema riepilogativo:

d equivale a [0-9]
D equivale a [^0-9]
w equivale a [0-9A-Za-z]
W equivale a [^0-9A-Za-z]
s equivale a [ tnr]
S equivale a [^ tnr]

Analogamente, esistono delle classi di caratteri predefinite:

[[:alpha:]] indica qualsiasi lettera, maiuscola o minuscola
[[:digit:]] indica qualsiasi cifra
[[:space:]] indica tutti i caratteri di spazio ( trn)
[[:upper:]] indica le lettere maiuscole
[[:lower:]] indica le lettere minuscole
[[:punct:]] indica i caratteri di punteggiatura
[[:xdigit:]] indica i valori esadecimali

Che ci crediate o no, le poche regole appena esplicate (che non esauriscono l’argomento, comunque) sono sufficienti a permetterci di lavorare con le Espressioni Regolari e a costruire modelli validi per gli scopi che ci proponiamo. Prima di costruire l’espressione, è fondamentale che abbiate in mente l’esatto modello che volete riprodurre, le parti di cui esso si compone, in altre parole, che sappiate esattamente ciò che volete cercare delimitandone correttamente i confini.

Adesso esaminiamo alcuni esempi generali non specifici a newLISP. Le spiegazioni degli esempi sono state lasciate in lingua inglese perchè sono più sintetiche.

Argomenti di base
-----------------

Ancoraggi: "^" e "$"
--------------------
^The
matches any string that starts with The

end$
matches a string that ends with end

^The end$
exact string match (starts and ends with The end)

roar
matches any string that has the text roar in it

Quantificatori: "*" "+" "?" e "{}"
----------------------------------
abc*
matches a string that has "ab" followed by zero or more "c"

abc+
matches a string that has "ab" followed by one or more "c"

abc?
matches a string that has "ab" followed by zero or one "c"

abc{2}
matches a string that has "ab" followed by 2 "c"

abc{2,}
matches a string that has "ab" followed by 2 or more "c"

abc{2,5}
matches a string that has "ab" followed by 2 up to 5 "c"

a(bc)*
matches a string that has "a" followed by zero or more copies of the sequence "bc"

a(bc){2,5}
matches a string that has "a" followed by 2 up to 5 copies of the sequence "bc"

Operatore OR: "|" oppure "[]"
-----------------------------
a(b|c)
matches a string that has "a" followed by "b" or "c"

a[bc]
same as previous

Classi di caratteri: "\d" "\w" "\s" e "."
-----------------------------------------
\d
matches a single character that is a digit

\w
matches a word character (alphanumeric character plus underscore)

\s
matches a whitespace character (includes tabs and line breaks)

.
matches any character

Usa l'operatore "." con attenzione poiché spesso le classi o le classi di caratteri negati (che tratteremo in seguito) sono più veloci e più precisi.

"\d", "\w" e "\s" hanno anche le rispettive negazioni con "\D", "\W" e "\S".

Per esempio, "\D" effettua il match inverso rispetto a quello ottenuto con "/d".

\D
matches a single non-digit character

Per specificare correttamente il carattere, occurre proteggere i caratteri ^.[$()|*?{}\ con il carattere '\' (barra rovesciata - backslash). Questa regola viene chiamata "escape rule".

\$\d
matches a string that has a "$" before one digit

Nota che possiamo utilizzare anche caratteri non stampabili come tab "\t", new-line "\n", ritorni a capo "\r".

Marcatori (flag)
----------------
I marcatori (flag) rappresentano un aspetto fondamentale delle espressioni regolari.
Una regex di solito si presenta nella forma /abc/, dove il modello di ricerca è delimitato da due caratteri barra /. Alla fine possiamo specificare un flag con questi valori (possiamo anche combinarli tra loro):

g (globale)
non ritorna dopo la prima corrispondenza, riavviando le ricerche successive dalla fine della corrispondenza precedente

m (multilinea)
quando abilitato, "^" e "$" corrisponderanno all'inizio e alla fine di una riga, anziché all'intera stringa

i (insensibile)
rende l'intera espressione senza distinzione tra maiuscole e minuscole (ad esempio /aBc/ corrisponde con AbC)

Argomenti intermedi
-------------------

Raggruppare e catturare: "()"
-----------------------------
a(bc)
parentheses create a capturing group with value bc

a(?:bc)*
using ?: we disable the capturing group

a(?<foo>bc)
using ?<foo> we put a name to the group

Questo operatore è molto utile quando abbiamo bisogno di estrarre informazioni da stringhe o dati usando il linguaggio di programmazione preferito. Eventuali ricorrenze multiple catturate da più gruppi saranno esposte sotto forma di un classico vettore/lista: accederemo ai loro valori specificando un indice del risultato della corrispondenza.

Se assegniamo un nome ai gruppi (usando (?<nome> ...)) saremo in grado di recuperare i valori del gruppo usando il risultato della corrispondenza come un dizionario in cui le chiavi saranno il nome di ciascun gruppo.

Espressioni con parentesi: "[]"
-------------------------------
[abc]
matches a string that has either an a or a b or a c -> is the same as a|b|c

[a-c]
same as previous

[a-fA-F0-9]
a string that represents a single hexadecimal digit, case insensitively

[0-9]%
a string that has a character from 0 to 9 before a % sign

[^a-zA-Z]
a string that has not a letter from a to z or from A to Z
In this case the ^ is used as negation of the expression

Ricorda che all'interno delle parentesi quadre tutti i caratteri speciali (inclusa la barra rovesciata \) perdono i loro poteri speciali: quindi non applicheremo la "escape rule".

Corrispondenza golosa (greedy) e pigra (lazy)
---------------------------------------------
I quantificatori (* + {}) sono operatori golosi, nel senso che espandono la corrispondenza il più possibile nel testo da analizzare.

Ad esempio, "<. +>" corrisponde a "<div>simple div</div>" nel testo "This is a <div> simple div</div>". Per catturare solo il tag div possiamo usare un "?" per renderlo pigro:

<.+?>
matches any character one or more times included inside < and >, expanding as needed

Si noti che una soluzione migliore dovrebbe evitare l'utilizzo di "." a favore di una regex più rigorosa:

<[^<>]+>
matches any character except < or > one or more times included inside < and >

Argomenti avanzati
------------------

Confini (Boundaries): "\b" e "\B"
---------------------------------
\babc\b
performs a "whole words only" search

\b rappresenta un punto di ancoraggio come il punto di inserimento (è simile a $ e ^) in corrispondenza delle posizioni in cui un lato è un carattere di una parola (come \w) e l'altro lato non è un carattere di parola (ad esempio potrebbe essere l'inizio della stringa o un carattere spazio).

Esiste anche la sua negazione, \B. Questo corrisponde a tutte le posizioni in cui \b non corrisponde e rappresenta un modello per la ricerca di pattern racchiusi da altri caratteri.

\Babc\B
matches only if the pattern is fully surrounded by word characters

Riferimento all'indietro (Back-references): "\1"
------------------------------------------------
([abc])\1
using \1 it matches the same text that was matched by the first capturing group

([abc])([de])\2\1
we can use \2 (\3, \4, etc.) to identify the same text that was matched by the second (third, fourth, etc.) capturing group

(?<foo>[abc])\k<foo>
we put the name foo to the group and we reference it later (\k<foo>). The result is the same of the first regex

Guarda-avanti (look-ahead) e (look-behind): "(?=)" e "(?<=)"
------------------------------------------------------------
d(?=r)
matches a d only if is followed by r, but r will not be part of the overall regex match

(?<=r)d
matches a d only if is preceded by an r, but r will not be part of the overall regex match

Possiamo anche usare l'operatore di negazione "!":

d(?!r)
matches a d only if is not followed by r, but r will not be part of the overall regex match

(?<!r)d
matches a d only if is not preceded by an r, but r will not be part of the overall regex match

Adesso vediamo alcuni esempi di regex e delle funzioni di newLISP che la utilizzano.

********************
>>>funzione REPLACE
********************
sintassi: (replace str-pattern str-data exp-replacement regex-option)

La presenza di un quarto parametro indica che è necessario eseguire una ricerca di espressioni regolari con un modello di espressione regolare specificato in str-pattern e un numero di opzione specificato in regex-option (ad es. 1 (uno) o "i" per la ricerca senza distinzione tra maiuscole e minuscole o 0 (zero) per una ricerca standard Perl compatibile con espressione regolare (PCRE) senza opzioni). Vedi regex sopra per i dettagli.

Per impostazione predefinita, replace sostituisce tutte le occorrenze di una stringa di ricerca anche se nel modello di ricerca è inclusa una specifica di inizio riga. Dopo ogni sostituzione, viene avviata una nuova ricerca in una nuova posizione in str-data. L'impostazione del bit di opzione su 0x8000 in regex-option forzerà la sostituzione solo della prima occorrenza. Viene restituita la stringa modificata.

replace con le espressioni regolari imposta anche le variabili interne $0, $1 e $2 con il contenuto delle espressioni e delle sottoespressioni trovate. La variabile di sistema anaforica $it è impostata sullo stesso valore di $0. Questi possono essere utilizzati per eseguire sostituzioni che dipendono dal contenuto trovato durante la sostituzione. I simboli $it, $0, $1 e $2  possono essere usati nelle espressioni come qualsiasi altro simbolo. Se l'espressione di sostituzione restituisce qualcosa di diverso da una stringa, non viene effettuata alcuna sostituzione. In alternativa, è possibile accedere al contenuto di queste variabili anche utilizzando ($ 0), ($ 1), ($ 2) e così via. Questo metodo consente l'accesso indicizzato (ad es. ($ i), dove i è un numero intero).

Dopo aver effettuato tutte le sostituzioni, il numero di sostituzioni è contenuto nella variabile di sistema $count.

;; using the option parameter to employ regular expressions

(set 'str "ZZZZZxZZZZyy")     → "ZZZZZxZZZZyy"
(replace "x|y" str "PP" 0)    → "ZZZZZPPZZZZPPPP"
str                           → "ZZZZZPPZZZZPPPP"

;; using system variables for dynamic replacement

(set 'str "---axb---ayb---")
(replace "(a)(.)(b)" str (append $3 $2 $1) 0)
→ "---bxa---bya---"

str  → "---bxa---bya---"

;; using the 'replace once' option bit 0x8000

(replace "a" "aaa" "X" 0)  → "XXX"

(replace "a" "aaa" "X" 0x8000)  → "Xaa"

;; URL translation of hex codes with dynamic replacement

(set 'str "xxx%41xxx%42")
(replace "%([0-9A-F][0-9A-F])" str
               (char (int (append "0x" $1))) 1)

str    → "xxxAxxxB"

$count → 2

Un'altra funzione che può usare le espressioni regolari è "search".

*******************
>>>funzione SEARCH
*******************
sintassi: (search int-file str-search [bool-flag [regex-option]])

Cerca un file specificato dal suo handle in int-file per una stringa in str-search. int-file può essere ottenuto da un precedente file aperto. Dopo la ricerca, il puntatore del file viene posizionato all'inizio o alla fine della stringa cercata o alla fine del file se non viene trovato nulla.

Per impostazione predefinita, il puntatore del file è posizionato all'inizio della stringa cercata. Se bool-flag vale true, il puntatore del file viene posizionato alla fine della stringa cercata.

In regex-option, i flag delle opzioni possono essere specificati per eseguire una ricerca di espressioni regolari PCRE. Vedi la funzione regex per i dettagli. Se l'opzione regex non viene specificata, viene eseguita una ricerca di stringhe più veloce e semplice. search restituisce la nuova posizione del file o zero se non viene trovato nulla.

Quando si utilizza il flag delle opzioni di espressione regolare, i modelli trovati vengono archiviati nelle variabili di sistema da $0 a $15.

(set 'file (open "init.lsp" "read"))
(search file "define")
(print (read-line file) "\n")
(close file)

(set 'file (open "program.c" "r"))
(while (search file "#define (.*)" true 0) (println $1))
(close file)

Il file init.lsp viene aperto e cercata la stringa "define" e viene stampata la linea in cui si trova la stringa.

Il secondo esempio cerca tutte le righe nel file program.c che iniziano con la stringa "#define" e stampa il resto della riga dopo la stringa "#define".

Vediamo adesso alcuni esempi di espressioni regolari:

Esempio 1
---------
(setq str "xyzabcXYZ")
; questo non funziona
(replace "x|y" str "e")
;-> "abcXYZ"

(setq str "xyzabcXYZ")
; funziona case insensitive
(replace "x|y" str "O" 0)
;-> "OOzabcXYZ"

; funziona case sensitive
(setq str "xyzabcXYZ")
(replace "x|y" str "O" 1)
;-> "OOzabcOOZ"

Esempio 2
----------


=======
 MACRO
=======

Iniziamo con la descrizione del manuale della funzione "define-macro":

*************************
>>>funzione DEFINE-MACRO
*************************
sintassi: (define-macro (sym-name [sym-param-1 ...]) body)
sintassi: (define-macro (sym-name [(sym-param-1 exp-default) ...]) body)

Le funzioni definite usando "define-macro" sono chiamate fexpr in altri LISP in quanto non effettuano l'espansione delle variabili. In newLISP sono ancora chiamate macro, perché sono scritte con lo stesso scopo di creare forme di sintassi speciali con schemi di valutazione non standard degli argomenti. Le funzioni create usando "define-macro" possono essere combinate con le funzioni di espansione "expand" o "letex".

Dalla v.10.5.8, newLISP ha anche una macro di espansione utilizzando la funzione "macro".

Definisce una nuova fexpr di nome sym-name, con argomenti opzionali sym-param-1. "define-macro" equivale ad assegnare un'espressione lambda-macro ad un simbolo. Quando viene chiamata una funzione "define-macro", gli argomenti non valutati vengono assegnati alle variabili in sym-param-1 .... Quindi vengono valutate le espressioni del corpo. Quando si valuta la funzione "define-macro", viene restituita l'espressione lambda-macro.

(define-macro (my-setq p1 p2) (set p1 (eval p2)))
→ (lambda-macro (p1 p2) (set p1 (eval p2)))

(my-setq x 123)  → 123
x                → 123

Nuove funzioni possono essere create per comportarsi come funzioni integrate che ritardano la valutazione di determinati argomenti. Poiché le fexpr possono accedere agli argomenti all'interno di una lista di parametri, possono essere utilizzate per creare funzioni di controllo del flusso come quelle già presenti in newLISP.

Tutti i parametri definiti sono opzionali. Quando una macro viene chiamata senza argomenti, tali parametri assumono il valore nil. Se tali parametri hanno un valore predefinito specificato in exp-default, assumono quel valore predefinito.

(define-macro (foo (a 1) (b 2))
  (list a b))

(foo)      → (1 2)
(foo 3)    → (3 2)
(foo 3 4)  → (3 4)

Le espressioni in exp-default vengono valutate nell'ambiente della funzione corrente.

(define-macro (foo (a 10) (b (div a 2)))
  (list a b))

(foo)      → (10 5)
(foo 30)   → (30 15)
(foo 3 4)  → (3 4)

Si noti che nelle fexprs esiste il pericolo di passare un parametro con lo stesso nome di una variabile usata nella definizione di "define-macro". In questo caso, la variabile interna della fexpr finirebbe per ricevere nil invece del valore previsto:

;; not a good definition!

(define-macro (my-setq x y) (set x (eval y)))

;; symbol name clash for x

(my-setq x 123)  → 123
x                → nil

Esistono diversi metodi che possono essere utilizzati per evitare questo problema, noto come "cattura delle variabili", scrivendo delle macro "igieniche":

Inserire la definizione nel proprio contesto dello spazio dei nomi lessicamente chiuso. Se la funzione ha lo stesso nome del contesto, può essere chiamata utilizzando solo il nome del contesto. Una funzione con questa caratteristica è chiamata funzione di default (funtore di default). Questo è il metodo preferito in newLISP per scrivere macro-definizioni.

Utilizzare args per accedere agli argomenti passati dalla funzione.

;; a define-macro as a lexically isolated function
;; avoiding variable capture in passed parameters

(context 'my-setq)

(define-macro (my-setq:my-setq x y) (set x (eval y)))

(context MAIN)

(my-setq x 123)  → 123  ; no symbol clash
x                → 123

La definizione nell'esempio è isolata dal punto di vista lessicale e non può verificarsi alcuna cattura di variabile. Invece di chiamare la funzione usando (my-setq:my-setq ...), può essere chiamata con solo (my-setq ...) perché è una funzione di default.

La seconda possibilità è di fare riferimento ai parametri passati usando args:

;; avoid variable capture in macros using the args function

(define-macro (my-setq) (set (args 0) (eval (args 1))))

Vedi anche la funzione di espansione "macro" che non risente della cattura delle variabili.
----------

In newLISP la differenza tra una funzione definita con 'define' e una con 'define-macro' è che 'define' valuterà tutti i suoi argomenti, mentre 'define-macro' no.

Con 'define-macro' è possibile creare funzioni che si comportano e sembrano fiunctions built-in. Cioè la funzione (setq x y) non valuta l'argomento 'x', ma passa direttamente 'x' come simbolo. La normale (set 'x y) non funziona nello stesso modo perchè valuta entrambi i suoi argomenti.

Un altro esempio è: (dolist (item mylist) .....). L'espressione (item mylist) non viene valutata ma passata in "dolist" per gestirla. Altrimenti, dovremmo citare facendo (dolist '(item mylist) ...).

Le macro non vengono utilizzate molto spesso, ma quando vengono utilizzate possono essere utili e importanti.

Abbiamo bisogno delle macro solo quando non vogliamo che una funzione valuti immediatamente i suoi argomenti. Per esempio:

(define (calc e)
  (println "the answer to " e " is " (eval e)))

(calc (+ 2 2))

;-> the answer to 4 is 4

(define-macro (calc e)
  (println "the answer to " e " is " (eval e)))

(calc (+ 2 2))

;-> the answer to (+ 2 2) is 4

La funzione non produce il risultato voluto, perché vede solo il '4', non l'espressione. La macro è migliore, perché "e" viene valutata solo quando vogliamo che sia valutata, dandoci la possibilità di utilizzarla anche come espressione non valutata.

Comunque le macro possono anche estendere il linguaggio con nuove funzioni. L'esempio seguente implementa la funzione "defun" come si trova nel Common LISP. Senza 'define-macro' questo sarebbe impossibile:

; Esempio d'uso: (defun foo (x y z) ....)

(define-macro (defun _func-name _arguments)
      (set _func-name (append
        '(lambda )
         (list _arguments)
         (args))))

;(defun foo (x y z) ....)

Senza 'define-macro' potremmo scrivere solo un 'defun' in cui sia il nome della funzione (cioè foo) che l'elenco dei parametri (cioè (x y z)) dovrebbero essere quotati.

Una macro è un tipo speciale di funzione che possiamo usare per modificare il modo in cui newLISP valuta il codice. Per esempio, è possibile creare nuovi tipi di funzioni di controllo di flusso, come la propria versione di if o di case.
Con le macro, possiamo creare dei costrutti altamente personalizzati. In verità, le macro di newLISP sono "fexprs", non macro. In newLISP, le "fexprs" vengono chiamate macro perché hanno uno scopo simile alle macro in altri LISP.

Il concetto fondamentale delle macro è il metodo di valutazione delle espressioni: in una funzione ordinaria gli argomenti delle espressioni vengono valutati per primi, mentre in una funzione macro possiamo decidere se e quando valutare gli argomenti.

In altre parole, in newLISP la funzione "define-macro" crea delle funzioni(macro) in cui gli argomenti non sono valutati: se abbiamo una variabile/simbolo x con valore 10 e la passiamo ad una macro, allora il valore visto dalla macro è x e non 10.

Vediamo un esempio, supponiamo di voler creare la nostra funzione "if" con una funzione ordinaria:

(define (iff test true-action nil-action)
  (if test true-action nil-action))

Adesso eseguiamo la nostra funzione con un test vero (true) e un test falso (nil):

(iff (> 3 2) (println "vero") (println "falso"))
;-> vero
;-> falso
;-> "vero"

(iff (< 3 2) (println "vero") (println "falso"))
;-> vero
;-> falso
;-> "falso"

Il risultato non è quello che volevamo: qualunque sia il risultato del test, vengono sempre stampati entrambi i valori (vero e falso) prima del risultato dell'azione. Questo perchè newLISP valuta gli argomenti prima della valutazione (applicazione) della funzione "iff".

Per risolvere il problema utilizziamo una macro:

(define-macro (iff test true-action nil-action)
  (if test true-action nil-action))

proviamo la nostra macro:

(iff (> 3 2) (println "vero") (println "falso"))
;-> (println "vero")

(iff (< 3 2) (println "vero") (println "falso"))
;-> (println "vero")

Anche in questo caso non abbiamo ottenuto il risultato sperato: questo è dovuto al fatto che la nostra macro non valuta affatto gli argomenti e quindi restituisce sempre un'espressione non valutata (in questo caso (println "vero")). Per fare in modo che la macro valuti gli argomenti occorre utilizzare la funzione "eval", che ci permette di effettuare la valutazione delle espressioni in modo sequenziale:

(define-macro (iff test true-action nil-action)
  (if (eval test) (eval true-action) (eval nil-action)))

(iff (> 3 2) (println "vero") (println "falso"))
;-> vero
;-> "vero"

(iff (< 3 2) (println "vero") (println "falso"))
;-> (println "vero")
;-> falso
;-> "falso"

Finalmente la nostra macro "iff" si comporta correttamente.

Adesso creiamo una macro che effettua un ciclo su una funzione. Il primo tentativo è quello di scrivere la funzione seguente:

(define (loop _func) (while true _func))

Proviamo:

(loop (println "."))
;-> .
Otteniamo un crash della REPL.

Quando l'argomento della funzione (println ".") viene passato alla funzione, viene valutato e restituisce ".". Poi all'interno della funzione troviamo (while true "."), che ferma l'esecuzione del programma senza alcun output.

Usando 'define-macro' lasciamo (println ".") non valutato e otteniamo:

(while true (eval '(println ".")))

che viene valutato correttamente.

Con la seguente macro otteniamo il comportamento voluto:

(define-macro (loop _func) (while true (eval _func)))

Proviamo (premere Ctrl-C per terminare il programma):

(loop (println "."))
;-> .
;-> .
;-> .
Ctrl-C
;-> ERR: received SIGINT - in function println
;-> called from user function (loop (println ".")).

Vediamo un altro esempio, questa volta creiamo una funzione di assegnazione "qset":

(define-macro (qset simb val)
  (set simb (eval val)))

In questo caso il simbolo "simb" non viene valutato e rimane in forma simbolica (è come se fosse quotato). Invece il simbolo "val" viene valutato e il valore risultante viene poi assegnato a "simb".

(qset a (+ 20 10))
;-> 30
a
;-> 30

Cerchiamo di capire come funziona una macro con altri esempi. Definiamo una macro che crea una lista con i due parametri passati alla macro:

(define-macro (f1 _x _y) (list _x _y))

La macro restituisce una lista con i valori passati:

(f1 1 2)
;-> (1 2)
(f1 a b)
;-> (a b)

Proviamo a cambiare la macro ponendo la funzione "list" all'interno di una funzione lambda:

(define-macro (f2 _x _y) (lambda () (list _x _y)))

Adesso la macro restituisce la funzione lambda non valutata:

(f2 1 2)
;-> (lambda () (list _x _y))

Quindi define-macro è define-lazy (non valuta la funzione lambda al suo interno).
Possiamo utilizare la funzione "expand" per espandere le variabili:

(define-macro (f3 _x _y) (expand (fn () (list _x _y)) '_x '_y))
(f3 1 2)
;-> (lambda () (list 1 2)

Questo spiega perchè il seguente esempio non funziona come vorremmo:

(define-macro (my-setq x y) (setq x (eval y)))
(my-setq x 123)
;-> 123
x
;-> nil

La variabile x è locale alla define-macro e non può impostare il valore per l'ambiente dinamico superiore: si tratta del "problema della cattura delle variabili".

Problema: la cattura delle variabili
------------------------------------
Il problema principale delle macro è dovuto alla possibile sovrapposizione (cioè nomi uguali) tra i simboli utilizzati dalla macro e i simboli utilizzati dal programma chiamante.
Vediamo un esempio per capire meglio di cosa si tratta. Supponiamo di chiamare la nostra ultima macro "qset" nel modo seguente:

(qset val (+ 20 10))
;-> 30
val
;-> nil

(qset simb (+ 20 10))
;-> 30
simb
;-> nil

In questi casi la nostra macro non ha effettuato alcuna assegnazione, poichè le espressioni:
(setq simb (+ 20 10)) e (setq val (+ 20 10)) impostano il valore delle variabili/simboli locali "simb" e "val". Quando questo accade, si dice che la variabile "val" (e "simb") è stata catturata durante l'"espansione" della macro.
Il linguaggio Scheme permette di scrivere macro "igieniche", nel senso che la sovrapposizione delle variabili viene risolta automaticamente dall'interprete del linguaggio, quind i simboli con lo stesso nome non creano effetti indesiderati. Purtroppo newLISP non ha questa funzionalità, quindi dobbiamo risolvere in altro modo il problema della "cattura delle variabili".

Possiamo utilizzare uno dei seguenti tre metodi per evitare la "cattura delle variabili".

Metodo 1: uso di variabili con underscore "_"
---------------------------------------------
Decidiamo di utilizziamo il carattere underscore "_" come prefisso per ogni variabile della macro.
Inoltre decidiamo di non utilizziamo il carattere underscore "_" come prefisso per le variabile del codice newLISP standard.
Ad esempio, la macro "qset" viene scritta nel modo seguente:

(define-macro (qset _simb _val)
  (set _simb (eval _val)))

(qset a (+ 20 10))
;-> 30
a
;-> nil

Abbiamo soltanto "aggirato" il problema, infatti:

(qset _simb (+ 20 10))
;-> 30
_simb
;-> nil

Si tratta di una soluzione naif, che però si adatta bene ai principi pratici di newLISP.

Nota: questa soluzione può essere considerata nel caso di un solo programmatore, oppure previo accordo tra il team di programmatori che lavorano al programma.

Metodo 2: uso della funzione "args"
-----------------------------------
Utilizziamo la funzione "args" per estrarre le variabili locali dai parametri.
In questo caso, la macro "qset" diventa:

(define-macro (qset)
  (set (args 0) (eval (args 1))))

(qset _simb (+ 20 10))
;-> 30
_simb
;-> 30

Possiamo anche utilizzare la funzione "letex" che ci permette di espandere gli argomenti ed assegnarli alle variabili locali della macro:

(define-macro (qset)
  (letex (_simb (args 0)
          _val  (args 1))
  (set _simb (eval _val))))

(qset _simb (+ 20 10))
;-> 30
_simb
;-> 30

La funzione "letex" funziona come qualsiasi altra espressione lambda in quanto localizza le variabili di un ambito dinamico che non è "igienico".

Comunque se esiste un simbolo globale con lo stesso nome di una variabile della macro, oppure se passiamo alla macro un parametro con lo stesso nome di una variabile (anche locale) della macro, oppure ricadiamo nella "cattura delle variabili".

Esempio:

(setq _simb 10)
;-> 10

(qset _simb (+ 20 10))
;-> 30
_simb
;-> 10 ; il valore della variabile _simb non è cambiato

Altro esempio:

(define-macro (demo param)
  (println "y globale = " y)
  (let (y 10)
    (println "y locale = " y)
    (setq param (add (eval param) y))))

(setq y 3)
(demo y)
;-> 20
y
;-> 3  ; anche in questo caso il valore della variabile y non è cambiato

Metodo 3: uso di un contesto (context)
--------------------------------------
Utilizziamo un contesto con lo stesso nome della macro. Inoltre utilizziamo la funzione "args" per assegnare i parametri alle variabili locali della macro.
In questo caso, la macro "qset" viene scritta nel modo seguente:

(context 'qset)

(define-macro (qset:qset)
  (letex (_simb (args 0)
          _val  (args 1))
  (setq _simb (eval _val))))

(context MAIN)

(qset a (+ 20 10))
;-> 30
a
;-> 30

(setq _simb 10)
(qset _simb (+ 20 10))
;-> 30
_simb
;-> 30 ; questa volta la variabile globale _simb è stata modificata.

Nota: questo è il metodo più sicuro per evitare la "cattura delle variabili". Anche perchè il simbolo "qset" è protetto perchè è un contesto (context).

(context? qset)
;-> true
(setq qset 1)
;-> ERR: symbol is protected in function setf : qset

La chiamata alla funzione (args) restituisce l'elenco di tutti gli argomenti passati alla lambda-macro (cioè tutti quelli che non vengono assegnati durante la chiamata tramite i parametri). Questo ci permette di estendere la funzione "qset" in modo che sia possibile effettuare assegnazioni multiple.
La nuova funzione "mset" è la seguente:

(define-macro (mset)
  (eval (cons 'setq (args))))

La funzione cons unisce una lista con un nuovo primo elemento (inserisce un elemento al primo posto di una lista):

(cons 1 '(2 3))
;-> (1 2 3)

Adesso possiamo associare/utilizzare un numero variabile di argomenti:

(mset x 10 y 11)
;-> 11
x
;-> 10
y
;-> 11

Quindi la macro prima costruisce l'espressione simbolica mostrata sotto:

'(setq x 10 y 11)

Poi questa espressione viene valutata.

Per capire le macro di newLISP dovresti anche familiarizzare con le seguenti funzioni: "expand", "letex" e "doargs".

Lo scopo principale delle macro è quello di estendere la sintassi del linguaggio.

Debug delle macro
-----------------
Le macro sono abbastanza complesse da scrivere, soprattutto quando dobbiamo testare e verificare la loro correttezza. Possiamo usare il debug di newLISP, ma è più difficile rispetto ad una funzione standard.
Un metodo utile è quello di sostituire la funzione "eval" con la funzione "list" o "println" per verificare l'aspetto dell'espressione espansa prima di essere valutata.
Infatti, non è possibile espandere le macro in Newlisp, poiché queste sono in realtà fexpr, che non si espandono. In molti casi è possibile sostituire eval esterno con println: in tal caso la chiamata alla macro stamperà ciò che si intendeva valutare.

Supponiamo di voler creare una macro che implementi il controllo "dolist-while":

(define-macro (dolist-while)
  (letex (_var (args 0 0) ; variabile del ciclo
          _lst (args 0 1) ; lista
          _cnd (args 0 2) ; condizione
          _body (cons 'begin (1 (args)))) ; corpo della funzione
    (let (_y)
    (println (args 0 0) { - } _lst)
    (catch (dolist (_var _lst)
    (if (set '_y _cnd) _body (throw _y)))))))

Abbiamo inserito una println per "vedere" cosa accade all'interno della macro.

Proviamo la nostra macro:

(dolist-while (x (sequence 15 0) (> x 10))
  (println {x is } (dec x 1)))
;-> x - (15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0)
;-> x is 14
;-> x is 13
;-> x is 12
;-> x is 11
;-> x is 10

Nota: questa macro non è immune dal problema della "cattura delle variabili", infatti se passiamo alla macro la variabile _y, otteniamo un errore:

(dolist-while (_y (sequence 15 0) (> _y 10))
  (println {_y is } (dec _y 1)))
;-> _y - (15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0)
;-> _y is
;-> ERR: value expected in function dec : true
;-> called from user function (dolist-while (_y (sequence 15 0) (> _y 10))
;-> (println "_y is " (dec _y 1)))

Vediamo altri esempi. Il primo è l'implementazone della funzione "inc":

(define-macro (my-inc _var)
  (eval (list 'setq _var (list '+ 1 _var) ))
)

Proviamo:

(setq i 0)
(while (< i 5) (println (my-inc i)))
;-> 1
;-> 2
;-> 3
;-> 4
;-> 5

Notiamo che la macro costruisce codice che viene valutato dalla funzione "eval". In questo caso costruisce una lista che contiene (setq i (+ 1 i)) e poi la valuta. Se sostituiamo "eval" con "println" possiamo vedere il codice che deve essere valutato:

(define-macro (my-inc _var)
  (println (list 'setq _var (list '+ 1 _var) ))
)

(setq i 0)
(while (< i 5) (println (my-inc i)))
;-> (setq i (+ 1 i))
;-> (setq i (+ 1 i))
;-> (setq i (+ 1 i))
...

Alternativamente la macro potrebbe restituire la lista non valutata pronta per essere elaborata ulteriormente.

Il secondo esempio è una replica del ciclo "for":

(define-macro (mi-for var from init to final do body)
  (eval
    (list 'let (list (list var init))
               (cons 'while (cons (list '<= var final)
                             (append (list body)
                               (list (list 'inc var))))))))

In modo analogo in questo caso la macro costruisce un ciclo while che viene eseguito un certo numero di volte.

Proviamo:

(mi-for i from 1 to 5 do (println i))
;-> 1
;-> 2
;-> 3
;-> 4
;-> 5
;-> 6 ; valore restituito da "mi-for"

Sostituiamo "eval" con "println":

(define-macro (mi-for var from init to final do body)
  (println
    (list 'let (list (list var init))
               (cons 'while (cons (list '<= var final)
                             (append (list body)
                               (list (list 'inc var))))))))

(mi-for i from 1 to 5 do (println i))
;-> (let ((i 1)) (while (<= i 5) (println i) (inc i)))

Quindi le macro possono servire per costruire codice che può essere valutato successivamente.

Adesso vediamo una macro scritta da John Small per capire come si applica la funzione "expand". La macro "expand-let" opera nello stesso modo della seguente espressione:

(let ((x 1)(y 2)(z 3))
  (expand '(x y z) 'x 'y 'z))
;-> (1 2 3)

(define (keys alist)
  (map (fn (pair) (first pair)) alist))

(keys '((x 1) (y 2) (z 3)))
;-> (x y z)

(define (bindings alist)
  (map (fn (pair) (cons (first pair) (eval (last pair)))) alist))

(bindings '((x 1) (y (+ 1 1)) (z 3)))
;-> ((x 1) (y 2) (z 3))

(define-macro (expand-let expr)
  (let ((ks (keys (rest (args))))
        (bs (bindings (rest (args)))))
  (eval (expand '(let bs
        (apply expand (cons (eval expr) (quote ks))))
  'ks 'bs))))

Comunque il risultato non è quello voluto:

(expand-let '(x y z) (x 1) (y 2) (z 3))
;-> (x 2 3)

Abbiamo ottenuto "x" al posto di "1" (e non ho ancora capito perchè).
Comunque se chiamiamo la macro aggiungendo un parametro con valore nil, allora tutto funziona:

(expand-let '(x y z) nil (x 1) (y 2) (z (+ 1 2)))
;-> (1 2 3)

Nel frattempo Lutz ha fornito una versione compatta:

(define-macro (expand-let)
  (eval (append (list 'let (rest (args)))
                (list (cons 'expand
                             (append (list (first (args)))
                             (map quote (map first (rest (args))))))))))

(expand-let '(x y z) (x 1) (y (+ 1 1)) (z 3))
;-> (1 2 3)

Macro di esempio
----------------
Vediamo altri esempi di macro presi dal forum di newLISP per avere un'idea di quanto sono potenti. Alcune di queste macro sono abbastanza complesse, ma non spaventatevi... andate avanti.

Nota: per ogni macro viene riportato anche il nome del creatore (quando conosciuto).

macro "ecase" (Dmitry)
----------------------
Questa macro (a differenza della funzione built-in "case") valuta le espressioni di confronto (test).

(define-macro (ecase _v)
  (eval (append
          (list 'case _v)
          (map (fn (_i) (cons (eval (_i 0)) (rest _i))) (args)))))

(define (test n)
  (ecase n
    ((/ 4 4) (println "n vale 1"))
    ((- 12 10) (println "n vale 2"))))

(define-macro (test n)
  (ecase n
    ((/ 4 4) (println "n vale 1"))
    ((- 12 10) (println "n vale 2"))
    (true (println "n diverso da 1 e 2"))))

(test 1)
;-> n vale 1

(test 2)
;-> n vale 2

(test 3)
;-> n diverso da 1 e 2

Come possiamo notare le espressioni (/ 4 4), (- 12 10) e true sono state tutte valutate. Con la versione standard di "case", queste espressioni non sarebbero state valutate.

macro "create-functions" (Cormullion)
-------------------------------------
Questa macro crea nuove funzioni.

(define-macro (create-functions group-name)
  (letex
    ((f1 (sym (append (term group-name) "1")))
     (f2 (sym (append (term group-name) "2"))))
    (define (f1 arg) (+ arg 1))
    (define (f2 arg) (+ arg 2))))

; creazione di due funzioni che iniziano con "foo":
(create-functions foo)
(foo1 10)
;-> 11
(foo2 10)
;-> 12
(create-functions bar)
; crea due funzioni che iniziano con "bar":
(bar1 12)
;-> 13
(bar2 12)
;-> 14

macro "tracer" (?)
------------------
Questa macro crea un file di log di tutte le funzioni eseguite (tracer).
Il codice seguente modifica il funzionamento di newLISP in modo che ogni funzione definita usando define aggiunga, quando valutata, il suo nome e i suoi argomenti in un file di log. Quando si esegue uno script, il file di log conterrà un record delle funzioni e degli argomenti che sono stati valutati.

(context 'tracer)

(define-macro (tracer:tracer farg)
  (set (farg 0)
    (letex (func (farg 0)
            arg (rest farg)
            arg-p (cons 'list (map (fn (x) (if (list? x) (first x) x))
                   (rest farg)))
            body (cons 'begin (args)))
            (lambda
                arg
                (append-file
                  (string (env "HOME") "/trace.log")
                  (string 'func { } arg-p "\n"))
             body))))

(context MAIN)

(constant (global 'newLISP-define) define)

; ridefinisce la funzione built-in "define"
(constant (global 'define) tracer)

Per verificare l'uso di questa macro occorre prima caricare lo script dalla REPL:

(load "tracer.lsp")

Il file di log generato contiene la lista di tutte le funzioni chiamate e gli argomenti che hanno ricevuto.

Nota: questa macro rallenta notevolmente l'esecuzione dei programmi.

macro "println-unix" (Lutz)
---------------------------
Questa macro permette di scrivere file con unix EOL (End Of Line) '\n' in windows.
In windows il carattere EOL vale '\r\n'.

(define-macro (println-unix)
    (apply print (map eval (args)))
    (print "\n"))

macro "multiple-replace" (Lutz)
-------------------------------
Questa macro permette di effettuare modifiche multiple ad un testo.

(set 'text "Sherlock Holmes")
(set 'repls '(("Sherlock" "Ellery") ("Holmes" "Queen")))

Codice standard:
(dolist (r repls)
    (replace (first r) text (last r)))

Macro:
(define-macro (replace-all)
    (dolist (r (eval (args 0)))
        (replace (first r) (eval (args 1)) (last r))))

(replace-all repls text)
;-> "Ellery Queen"
text
;-> "Ellery Queen"
Questo metodo permette di tenere insieme le coppie di sostituire nel caso ci sia una lista lunga di modifiche.

macro "destroy-func" (newdep)
-----------------------------
Questa macro permette di eseguire una funzione e poi eliminarla dal contesto.

(define-macro (destroy-func)
    (let (temp (eval (args)))
      (delete (args 0))
      temp))

(define (foo x) (+ x x))

(destroy-func foo 123)
;-> 246

(sym "foo" MAIN nil)
;-> nil ; il simbolo foo non esiste più

(foo 2)
;-> ERR: invalid function : (foo 2)

macro "rev-args" (Cormullion)
-----------------------------
Questa macro permette di eseguire una funzione/espressione con i parametri in ordine invertito.

(define-macro (rev-args expr)
  (apply (expr 0) (reverse (rest expr))))

(rev-args (div 3 6))
;-> 2

macro "define!" (Cormullion)
----------------------------
Questa macro permette di definire funzioni che hanno la variabile "_self" impostata con il loro nome.

(define-macro (define! farg)
  (set (farg 0)
    (letex (func   (farg 0)
            arg    (rest farg)
            arg-p  (cons 'list (map (fn (x) (if (list? x) (first x) x))
                     (rest farg)))
            body   (cons 'begin (args)))
           (lambda
               arg (let (_self 'func) body)))))

(define! (f a b c)
   (println "I'm " _self)
   (+ a b c))

(define! (g a b c)
   (println "and I'm " _self)
   (+ a b c))

(f 7 8 9)
;-> I'm f
;-> 24

(g 10 11 12)
;-> and I'm g
;-> 33

macro "second" (rickyboy)
-------------------------
Questa funzione estrae il secondo elemento di una lista e ritorna nil se questo elemento non esiste.

Codice standard:
(define (second xs)
  (if (> (length xs) 1) (xs 1)))

Macro:
(define-macro (second)
  (letex (xs (args 0)) (if (> (length xs) 1) (xs 1))))

Se abbiamo delle sequenze lunghe è meglio usare la macro poichè questa non crea una copia della sequenza, quindi è più veloce e utilizza meno memoria.

macro "->" e "->>" pipeline (William James, Johu)
-------------------------------------------------
Queste macro permettono di applicare una lista di funzioni una di seguito all'altra.

(context '->>)
(define-macro (->>:->> E form)
  (if (empty? (args))
    (if (list? form)
      (eval (push E form -1))
      (eval (list form E)))
    (eval (cons '->> (cons (list '->> E form) (args))))))

(context '->)
(define-macro (->:-> E form)
  (if (empty? (args))
    (if (list? form)
      (eval (cons (first form) (cons E (rest form))))
      (eval (list form E)))
    (eval (cons '-> (cons (list '-> E form) (args))))))

(context MAIN)

Supponiamo di voler applicare tre funzioni in in sequenza ad un argomento:

(exp (sqrt (abs -3)))
;-> 5.652233674034092

Con questa macro possiamo scrivere:
(-> -3 abs sqrt exp)
;-> 5.652233674034092

(-> (+ 2 1) abs sqrt exp)
;-> 5.652233674034092

La macro "->" prende il primo elemento come primo argomento della funzione:

(-> 8 (div 4))
;-> 2

La macro "->>" prende il primo elemento come ultimo argomento della funzione:

(->> 8 (div 4))
;-> 0.5

Un altro esempio, estraiamo da una lista associativa i valori che sono in feriori a 50 e li sommiamo:

(setq alist '((a 29)(b 25)(c 21)(d 64)))
(->> alist (map last) (filter (curry > 50)) (apply +))
;-> 75

Altro metodo di scrivere le due macro (johu):

(context 'MAIN:->>)
(define-macro (->>:->> E form)
  (letex (_func
            (if $args (cons '->> (cons (list '->> E form) $args))
                (list? form) (push E form -1)
                (list form E)))
  _func))

(context 'MAIN:->)
(define-macro (->:-> E form)
  (letex (_func
            (if $args (cons '-> (cons (list '-> E form) $args))
                (list? form) (push E form 1)
                (list form E)))
  _func))
(context MAIN)

Notare "(if $args" al posto di "(if (empty? (args))", chiaro e conciso.

Altro metodo di scrivere le due macro (William James):

(context '->>)
(define-macro (->>:->> E form)
  (eval
    (if $args
      (cons '->> (cons (list '->> E form) (args)))
      (if (list? form)
        (push E form -1)
        (list form E)))))

(context '->)
(define-macro (->:-> E form)
  (eval
    (if $args
      (cons '-> (cons (list '-> E form) (args)))
      (if (list? form)
        (cons (first form) (cons E (rest form)))
        (list form E)))))
(context MAIN)

macro "mvdolist" (johu)
-----------------------
Questa macro permette di usare indici multipli con la funzione dolist:

(define-macro (mvdolist)
  (letex (_vars (args 0 0)
          _vals (args 0 1)
          _body (cons 'begin (1 (args))))
    (local _vars
      (dolist (_x (explode _vals (length '_vars)))
        (bind (transpose (list '_vars _x)))
        _body))))

Esempi di utilizzo:
(mvdolist ( (i j k) '(1 2 3 4 5 6 7 8 9)) (println i "-" j "-" k))
;-> 1-2-3
;-> 4-5-6
;-> 7-8-9
(mvdolist ( (i j k) (sequence 1 9) ) (println i "-" j "-" k))
;-> 1-2-3
;-> 4-5-6
;-> 7-8-9
(mvdolist ( (i j k) (sequence 1 5) ) (println i "-" j "-" k))
;-> 1-2-3
;-> 4-5-nil

Altra macro simile:

(define-macro (mvdolist)
  (letex (_varlst (map list (args 0 0))
          _vars (args 0 0)
          _vals (args 0 1)
          _flag (and (= 3 (length (args 0))) (args 0 2))
          _body (cons 'begin (1 (args))))
    (let _varlst
      (dolist (_x (if _flag _vals (explode _vals (length '_vars))))
        (bind (transpose (list '_vars _x)))
        _body))))

Esempi di utilizzo:

(mvdolist ( (i j k) '((1 2 3)(4 5 6)(7 8 9)) ) (println i "-" j "-" k))
;-> (1 2 3)-(4 5 6)-(7 8 9)
(mvdolist ( (i j k) '((1 2 3)(4 5 6)(7 8 9)) true) (println i "-" j "-" k))
;-> 1-2-3
;-> 4-5-6
;-> 7-8-9
(mvdolist ( (i j k) (explode (sequence 1 9) 3) true) (println i "-" j "-" k))
;-> 1-2-3
;-> 4-5-6
;-> 7-8-9
(mvdolist ( (i j k) (explode (sequence 1 9) 4) true) (println i "-" j "-" k))
;-> 1-2-3
;-> 5-6-7
;-> 9-nil-nil
(mvdolist ( (i j k) (explode (sequence 1 9) 2) true) (println i "-" j "-" k))
;-> 1-2-nil
;-> 3-4-nil
;-> 5-6-nil
;-> 7-8-nil
;-> 9-nil-nil
(mvdolist ( (i j k) '(1 2 3) true) (println i "-" j "-" k))
;-> 1-1-1
;-> 2-2-2
;-> 3-3-3

Altra macro simile:

(define-macro (map-mv)
;(map-mv exp-functor nested-list)
   (letex (_func (args 0)
           _vals (args 1))
     (map (curry apply _func) _vals)))

(map-mv (fn (i j k) (println i "-" j "-" k)) (explode (sequence 1 9) 3))
;-> 1-2-3
;-> 4-5-6
;-> 7-8-9
(map-mv pow '((2 1) (2 2) (2 3)))
;-> (2 4 8)

macro "foreach" (Hans-Peter)
----------------------------
Questa macro è l'equivalente della funzione "foreach" del LISP e di Scheme.
Fondamentalmente "for-each" fa la stessa cosa della funzione "map", tranne il fatto che quest'ultima restituisce una lista, mentre "for-each" non ha un valore di ritorno definito (in Scheme).

(define-macro (foreach _foreachx _foreachlst)
  (eval (list 'dolist (list _foreachx _foreachlst)
                      (append (list 'begin) (args)))))

La seguente espressione protegge la macro "foreach" dalla sovrascittura.
(constant (global 'foreach))

Esempio di utilizzo:

(foreach i '(1 2 3 4) (println (* i i)))
;-> 1 4 9 16

Per vedere il risultato dell'espansione di una macro è possibile sostituire le funzione "eval" con la funzione "println":

(define-macro (foreach _foreachx _foreachlst)
  (println (list 'dolist (list _foreachx _foreachlst)
                         (append (list 'begin) (args)))))

(foreach i '(1 2 3 4) (println (* i i)))
;-> (dolist (i '(1 2 3 4))
;->  (begin
;->   (println (* i i))))
;-> (dolist (i '(1 2 3 4))
;->  (begin
;->   (println (* i i))))

Potremmo definire for-each anche senza definire una macro:

(setq foreach map)
(foreach (fn(x)(println(* x x))) '(1 2 3 4))
;-> 1
;-> 4
;-> 9
;-> 16
;-> (1 4 9 16)

Altro esempio fornito da Lutz:

(define-macro (foreach _x from _a to  _z _body)
  (for (_x (eval _a) (eval _z)) (eval _body)))

(foreach i from 1 to 5 (print _x { }))
;-> 1 2 3 4 5 " "


macro "doc" (Cormullion-jamesqiu-cameyo)
---------------------------------------
Questa macro permette di visualizzare il manuale di riferimento di una funzione.

(context 'doc)

(define-macro (doc:doc func-name)
  (let ((func-name (string func-name)))
     (set 'f (read-file {/c:/newlisp/newlisp_manual.html}))
     (set 'r (regex (string "<a name=\"" func-name "\"></a>") f))
     (set 'n0 (r 1))
     (set 'n1 ((regex "<a name=" f 0 (+ n0 (r 2))) 1))
     (set 'html-text (slice f n0 (- n1 n0)))
     (replace "<.*?>" html-text "" 0)
     (replace "&lt;"  html-text "<")
     (replace "&gt;"  html-text ">")
     (replace "&amp;" html-text "&")
     (replace "&nbsp;" html-text " ")
     (replace "&mdash" html-text "...")
     (replace "&rarr;" html-text "->")
     (replace "\n\n+" html-text "\n\n" 1)
     (replace "^\n+|\n+$" html-text "" 1)
     (replace "\t" html-text "" 1)
     ;(replace "[  ]" html-text " " 1)
     (println "--------------------------")
     (println html-text)
     (println "--------------------------")
     'end))

(context MAIN)

Esempio di utilizzo:

(doc curry)
(doc map)
(doc apply)
(doc println)

Purtroppo non funziona per i predicati (null?, zero?, ecc.)
(doc null?)
;-> ERR: invalid function in function set : (r 1)
;-> called from user function (doc null?)

macro "fnkeyword" (Lutz-Cormullion-cameyo)
------------------------------------------
Questa macro permette di passare argomenti con nome e valore alla macro:

(define-macro (fnkeyword)
   (local (len width height)
      (bind (args) true)
      (println "len:" len " width:" width " height:" height)
   ))

(fnkeyword (width 20) (height 30) (len 10))
;-> len:10 width:20 height:30

(fnkeyword (w 20) (h 30) (l 10))
;-> len:nil width:nil height:nil

Con una piccola modifica possiamo chiamare una funzione con i parametri passati ala macro:

(define-macro (fnkeyword func)
   (local (len width height)
      (bind (args) true)
      (println "len:" len " width:" width " height:" height)
      ((eval func) len width height)
   ))

(fnkeyword + (width 20) (height 30) (len 10))
;-> len:10 width:20 height:30
;-> 60

macro "ifnot" (cameyo)
----------------------
Questa macro implementa un "if negato".

(define-macro (ifnot _condition _else _then)
  (if (eval _condition)
      (eval _then)
      (eval _else)))

(ifnot (> 3 2) (setq a 4) (setq b 1))
;-> 1
(ifnot (< 3 2) (setq a 4) (setq b 1))
;-> 4

macro "until-0" (nallen05)
--------------------------
Questa macro implementa il controllo "until" con il test di confronto prefissato al valore zero:

(define-macro (until-0)
  (letex (zero-form (args 0)
         body      (cons 'begin (1 (args))))
   (let ($num nil)
    (until (= 0 (setq $num zero-form))
      body))))

Esempi di utilizzo:

(until-0 0 (println  $idx ":" $num " not 0"))
;-> nil

(until-0 (rand 10) (println  $idx ":" $num " not 0"))
;-> 0:5 not 0
;-> 1:6 not 0
;-> 2:4 not 0
;-> 3:1 not 0
;-> 4:9 not 0
;-> 5:9 not 0
;-> 6:5 not 0

macro "up-down" (William James)
-------------------------------
Questa macro simula una pseudo-closure utilizzando gensym.

(define (gensym:gensym)
  (sym (string "gensym-" (inc gensym:counter))))

(define-macro (closure varval-pairs body)
  (let (alist (map (fn(x) (list (x 0) (gensym) (eval (x 1))))
                   (explode varval-pairs 2)))
    (bind (map (fn (x) (rest x)) alist))
    (dolist (x alist)
      (set-ref-all (x 0) body (x 1)))
    body))

(set 'up-down
  (closure (a 0 b 99)
    (lambda () (list (++ a) (-- b)))))

Proviamo la funzione:

(up-down)
(1 98)
(up-down)
(2 97)
(up-down)
(3 96)

(println up-down)
;-> (lambda () (list (++ gensym:gensym-14) (-- gensym:gensym-15)))

Nota: la funzione gensym può essere scritta anche nel seguente modo:

(define (gensym:gensym)
  (sym (string "gs-" (sym (uuid)))))

Questo funziona perchè "uuid" genera una valore univoco. Comunque, la prima funzione "gensym" è leggermente più veloce e mantiene i simboli generati tutti nel relativo spazio dei nomi gensym. Se usiamo pochi valori, allora (sym (uuid)) è più pratico. Una pratica sicura è quella di definire le macro (fexprs) nel loro spazio dei nomi, che risolve anche il problema della cattura delle variabili creando una specie di chiusura lessicale.

macro "a-if"
------------
Un'altra macro che simula il controllo "if" con l'aggiunta di una variabile anaforica $it.

(define-macro (aif)
  (let ((_it (eval (args 0))))
    (if _it
      (eval (args 1))
      (eval (args 2)))))

Esempi d'uso:

(aif (> 4 2) (println _it) (println "else"))
;-> true
(aif (> 2 4) (println _it) (println "else"))
;-> else
(let (a 5) (aif a (println _it) (println "else")))
;-> 5

macro "loop" e "recur" (rickyboy)
----------------------
Macro che simulano le istruzioni

(constant '[loop/recur-marker] '[loop/recur-marker])

(define (loop- BODY-FN)
  (let (.args (args) .res nil)
    (while (begin
             (setq .res (apply BODY-FN .args))
             (when (and (list? .res) (not (empty? .res))
                        (= [loop/recur-marker] (first .res)))
               (setq .args (rest .res)))))
    .res))

(define (recur) (cons [loop/recur-marker] (args)))

(define (flat-shallow-pairs LIST)
  (let (i 0 acc '())
    (dolist (e LIST)
      (cond ((even? i) ; Indicator i is even = abscissa
             (cond ((and (list? e) (not (empty? e)))
                    (extend acc (0 2 (push nil e -1))))
                   ((symbol? e)
                    (push e acc -1)
                    (inc i))))
            ((odd? i) ; Indicator i is odd = ordinate
             (push e acc -1)
             (inc i))))
    acc))

(define (parms<-bindings BINDINGS)
  (map first (explode (flat-shallow-pairs BINDINGS) 2)))

(define-macro (loop INIT)
  (letn (.parms (parms<-bindings INIT)
         .body-fn (letex ([body] (args)
                          [parms] .parms)
                    (append '(fn [parms]) '[body]))
         .loop-call (letex ([body-fn] .body-fn
                            [parms] .parms)
                      (append '(loop- [body-fn]) '[parms])))
    (letex ([init] INIT [loop-call] .loop-call)
      (letn [init] [loop-call]))))

Vediamo due esempi di utilizzo delle macro:

(define (factorial x)
  (loop (x x acc 1)
    (if (< x 1)
        acc
        (recur (- x 1) (* x acc)))))

(factorial 10)
;-> 3628800

(define (fibo x)
  (loop (x x curr 0 next 1)
    (if (= x 0)
        curr
        (recur (- x 1) next (+ curr next)))))

(fibo 10)
;-> 55

macro "my-or" (Kazimir Majorinc)
--------------------------------
Questa macro simula la funzione boolena "or".

(set 'my-or
  (lambda-macro (x y)
     (first (list (eval (let ((temp (sym (append (string (last (symbols))) "+"))))
                    (expand
                     '(let ((temp (eval x)))
                            (if temp          ; Naive
                              temp          ; version
                              (eval y)))
                 'temp)))
             (delete (last (symbols)))    ))))

Esempio:

(setq temp 45)
(my-or 45 nil)
;-> 45
(my-or nil 45)
;-> 45

Commento di Lutz:
La soluzione corretta in newLISP è quella di evitare la cattura variabile in primo luogo racchiudendo il "my-or" in uno spazio dei nomi (contesto):

(define-macro (my-or:my-or)
   (let (my-or:temp (eval (args 0)))
      (if my-or:temp my-or: temp (eval (args 1)))))

(my-or 1 nil)
;-> 1
(my-or nil 1)
;-> 1

Questa funzione è più veloce e risolve il problema della cattura delle variabili.

Nelle versioni prcedenti del manuale di newLISP era riportata questa funzione di utilità per definire funzioni racchiuse automaticamente nel proprio contesto:

(define (def-static s body)
    (def-new 'body (sym s s)))

la funzione accetta un nuovo simbolo nome-funzione "s" e crea una nuova funzione racchiusa in uno spazio dei nomi. Qui "def-static" è usata per definire "my-or:my-or" come sopra trasformando la vecchia definizione in una nuova con ambito statico:

(def-static 'my-or
    (fn-macro (x y)
        (let (temp (eval x)) (if temp temp (eval y)))))

(my-or 1 nil)
;-> 1
(my-or nil 1)
;-> 1

In questo modo possiamo anche evitare di utilizzare (args ...) e nominare le variabili per una migliore leggibilità.

Non esiste il problema dell"esaurimento degli spazi dei nomi". Un overhead dello spazio dei nomi è costituito da nient'altro che un simbolo aggiuntivo, il simbolo di contesto. Potenzialmente possiamo avere milioni di contesti in newLISP senza alcun problema.

Un commento generale:

Invece di provare a emulare Scheme o altri LISP tradizionali, dovremmo enfatizzare le tipiche soluzioni di newLISP. Cercare di utilizzare le tecniche di Scheme in newLISP porta solo a un codice inefficiente e, spesso, brutto e newLISP viene percepito come un LISP di seconda classe a causa di ciò.

Proprio come Scheme è progettato attorno all'ambito lessicale e alle chiusure, newLISP è progettato attorno all'ambito dinamico e agli spazi dei nomi (contesti). Entrambi gli approcci sono progettati per evitare conflitti tra nomi di simboli e mantenere lo stato. Credo che il nuovo approccio LISP sia alla fine più facile da capire e più aperto all'esplorazione dei futuri paradigmi di programmazione.

Inoltre, newLISP non può generare contesti innestati, che introducono un complessità inutile.

Come nota a margine: il linguaggio non ha il meccanismo di "ricorsione della coda" (tail recursion) perché altrimenti la ricorsione sarebbe stato il principale meccanismo di controllo del flusso. Limitare il controllo del flusso alla ricorsione e alle continuazioni sarebbe stata una limitazione innaturale in newLISP, forse bella dal punto di vista matematico, ma ostica da usare e comprendere per le persone di altre discipline.
Lutz

Versione proposta da DrDave:

(define-macro (my-or)
   (let (temp (eval (args 0))
         temp1 (eval (args 1)))
     (if temp
         temp
         temp1)))

Versione proposta da Michael (però usa "or"):

(define-macro (my-or)
   (or (eval (args 0)) (eval (args 1)))
)

Versione proposta da newdep:

(define-macro (my-or)
 (let (temp
  (unless (eval (args 0))
   (eval (args 1))))
    temp))

Versione proposta da cgs1019:

Questa soluzione utilizza una funzione lambda per memorizzare il primo argomento valutato nella macro e rinviare la valutazione del secondo. Non è veloce come la soluzione presentata da Lutz, che ha un tempo di esecuzione di circa il 65% di questa, probabilmente perché  comporta una chiamata di funzione aggiuntiva. Ma almeno evita la necessità di creare un nuovo contesto solo per una semplice macro.

Il trucco è quello di usare una chiamata di funzione nidificata per trasferire argomenti nella funzione nidificata in modo da non dover usare alcuna variabile. Poiché (arg n) sono sempre locali, è impossibile la cattura delle variabili.

(define-macro (my-or)
  (
    (lambda ()
      (if (args 0)
        (args 0)
         (eval (args 1))
      )
    )
    (eval (args 0))
    (args 1)
  )
)

Possiamo riscriverla per capire meglio come funziona:

(define-macro (my-or)
  (let ( func (lambda () (if (args 0) (args 0) (eval (args 1)) )))
    (func (eval (args 0)) (args 1))
  )
)

cgs1019 utilizza un versione anonima di func. Questo è equivalente a:

((lambda (x) (+ x x)) 1)
;-> 2

macro "ncase" (Sammo, nigelbrown)
---------------------------------
Questa macro simula la funzione "case" con valori multipli di comparazione.

(define-macro (ncase _x)
    (eval (append (list 'case _x) (apply append (map expandit (rest (args)))))))

(define (expander c)
    (apply append (map expandit c)))

(define (expandit x)
    (if (list? (first x))
        ;((a b c) d e) --> ((a d e) (b d e) (c d e))
        (map (lambda (y) (append (list y) (rest x))) (first x))
    ;else
        ;(a d e) --> ((a d e))
        (list x) ))

Esempi:

(ncase "diane" () (("bob" "mary" "susie") 'friend) (("tim" "diane") 'boss) ("sam" 'self) ("sammo" 'clever-alias) (true 'stranger))
;-> boss

(ncase "bob" () (("bob" "mary" "susie") 'friend) (("tim" "diane") 'boss) ("sam" 'self) ("sammo" 'clever-alias) (true 'stranger))
;-> boss

(ncase 3 () ((1 3 5 7 9) "odd") (10 "ten") ((2 4 6 8) "even") (true "none"))
"odd"
(ncase 10 () ((1 3 5 7 9) "odd") (10 "ten") ((2 4 6 8) "even") (true "none"))
"ten"
(ncase 2 () ((1 3 5 7 9) "odd") (10 "ten") ((2 4 6 8) "even") (true "none"))
"even"
(ncase 35 () ((1 3 5 7 9) "odd") (10 "ten") ((2 4 6 8) "even") (true "none"))
"none"
(ncase 5 () ((1 3 5 7 9) "odd") (10 "ten") ((2 4 6 8) "even") (true "none"))

macro "+-" (Lutz)
-----------------
Questa macro permette di calcolare la seguente espressione:

(a + b - c + d - ...)

dove a,b,c,d,... sono valori numerici

(define-macro (+- )
  (let (signs (cons 1 (series 1 -1 (- (length (args)) 1))))
   (apply 'add (map 'mul (map eval (args)) signs))))

Esempi:

(+- 1 2 3 4 5)
;-> -1
(apply +- '(1 2 3 4))
;-> 4
(apply +- (sequence 1 5))
;-> -1
(+- 1.2 1.2 2.4)
;-> 0

Possiamo farlo anche con una funzione, che è anche più veloce (rickyboy).

(define (+-)
  (let (signs (cons 1 (series 1 -1 (- (length (args)) 1))))
    (apply add (map mul signs (args)))))

macro "try" (Lutz)
------------------
Questa macro permette di gestire errori come eccezioni.

(define-macro (try body else)
    (if (not (catch (eval body) 'result))
         (eval else)
         result))

(setq error-text "errore")
; now try this

(try (+ 3 4) (println error-text))
;-> 7

(try (xyz) (println error-text))
;-> errore

macro "+++" e "---" (Dmitry)
----------------------------
Queste macro simulano le funzioni di incremento/decremento "++" e "--".

(define-macro (+++ _a _b)
  (if (symbol? _a)
    (set _a (+ (eval _a) (or _b 1)))
  ;else
    (+ (eval _a) (or _b 1)) ))

(define (--- _a _b)
  (if (symbol? _a)
    (set _a (- (eval _a) (or _b 1)))
  ;else
    (- (eval _a) (or _b 1)) ))

Le seguenti versioni valutano l'espressione "_b" prima di essere usata, in questo modo possiamo scrivre: (+++ var (expression))

(define-macro (+++ _a _b)
  "(++ a b) - increment a by b. a can by either a symbol or a value"
  (if (symbol? _a)
    (set _a (+ (eval _a) (or (eval _b) 1)))
    (+ (eval _a) (or (eval _b) 1)) ))

(define-macro (--- _a _b)
  "(--- a b) - decrement a by b. a can by either a symbol or a value"
  (if (symbol? _a)
    (set _a (- (eval _a) (or (eval _b) 1)))
    (- (eval _a) (or (eval _b) 1)) ))

(--- (+ 3 3) (- 4 2))
;-> 4

Nota: "+++" e "---" funzionano solo con i numeri interi.

Infine, una versione senza utilizzare le macro:

(define (+++ _a01 _b01)
  "(++ int-a int-b) - increment int-a by int-b. int-a can be either a symbol or a value"
  (if (symbol? _a01)
    (set _a01 (+ (eval _a01) (or _b01 1)))
    (+ (eval _a01) (or _b01 1))))

(setq a 1)
(+++ 'a)
;-> 2
a
;-> 2

macro "dolist-index" (Lutz)
---------------------------
Questa macro simula la funzione "dolist".

(define-macro (dolist-index)
  (letex (var ((args) 0 0)
          lst ((args) 0 1)
          idx ((args) 0 2)
          body (cons 'begin (1 (args))))
          (setq idx 0)
          (dolist (var lst)
              body
              (inc idx) )
   )
)

(dolist-index (i '(a b c d e f) id) (println id ":" i))
0:a
1:b
2:c
3:d
4:e
5:f

Nota: l'uso di (args) rende la macro "igienica", ma l'utilizzo di un contesto e del relativo funtore di default rende il codice più leggibile e forse più veloce.

macro "rep-var" (Lutz)
----------------------
Questa macro permette di interpolare una variabile in una stringa.

(define-macro (rep-var str)
    (dolist (_v (args))
        (replace (append "#" (string _v)) (eval str) (eval _v))))

(setq var "pippo")
;-> "pippo"
(rep-var "Buonanotte #var" var)
;-> "Goodnight pippo"

macro "not-" e "if-" (Jeremy Dunn)
-----------------------------

;; Negate a boolean function
;; Write (not (= x y)) as (not- = x y)
(define-macro (not-) (not (eval (args))))

(setq x 2 y 3)
(not- = x y)
;-> true
(setq x 2 y 2)
(not- = x y)
;-> nil

;; Convert a boolean to an if statement
;; Write (if (= x 3) a b) as (if- = x 3 a b)
(define-macro (if-)
  (setq L (length (args)))
  (if (eval (0 (- L 2)(args)))
      (eval (nth -2 (args)))
      (eval (last (args)))
  ))

(if- > 4 5 (println "riga 1") (println "riga 2"))
;-> riga 2

(setq a (println "a"))
(setq b (println "b"))
(if- = 3 3 a b)
;-> "a"
(if- > 3 4 a b)
;-> "b"

macro "if*" (Cormullion)
------------------------
Questa macro simula un "if" senza "else", ma permette di eseguire multiple espressioni senza utilizzare la funzione "begin".

(define-macro (if* condition)
  (let (c (eval condition))
    (if c (map eval (args)))))

(if* true
   (println "uno")
   (println "due")
   (println "tre"))
;-> uno
;-> due
;-> tre
;-> ("uno" "due" "tre")

Comunque è meglio utilizzare la funzione "cond".

macro "defun" (kinghajj)
------------------------
Questa macro definisce la funzione "DEFUN" del Common LISP.

; This macro provides a classic defun.
; If I remember CL correctly, if an argument is prefixed with &, then it is not
; evaluated; that is hom CL makes macros. This macro checks if the argument name
; has a & at the start, and if it does it does not evaluate it. This makes it
; easy if you want to write a macro that needs no evaluate some arguments.
(define-macro (defun _name _args)
  (let (_body (args))
    ; go through to arguments
    (dolist (_arg _args)
        ; evaluate argument unless prefixed with &
        (unless (= (first (string _arg)) "&")
          (push (list 'eval _arg) _body)))
    ; create macro function
    (set _name (append (lambda-macro) (list _args) _body))))

Esempio:

(defun test (v1 &v2)
   (println "Got " v1 " and " &v2))

(test 37 (+ 40 2))
; => "Got 37 and (+ 40 2)"

macro "each" (Jeff)
-------------------
Questa macro implementa una struttura di controllo iterativa.

(define-macro (each object do iter)
  (set 'iter (trim (string iter) "|"))
  (dolist (obj (eval object))
          (eval (set (sym (eval iter)) obj))
          (catch (doargs (a)
                 (if (= a 'end) (throw nil) (eval a))))))

La sintassi è la seguente:

(each '(ruby is not a lisp) do |item| (println item) end)
;-> ruby
;-> is
;-> not
;-> a
;-> lisp

Altra versione senza "end" finale (rickyboy).

(define-macro (each object iter)
  (set 'iter (trim (string iter) "|"))
  (dolist (obj (eval object))
    (eval (set (sym (eval iter)) obj))
    (doargs (a) (eval a))))

(each '(ruby is not a lisp) |item| (println item))
;-> ruby
;-> is
;-> not
;-> a
;-> lisp

macro "my-define" (Cormullion, Fanda)
-----------------------------------
Questa macro crea una nuova versione di "define", in modo tale che quando viene chiamata la funzione che definisce, stampa i suoi argomenti (ad esempio su un file di log).

"define" crea una funzione/lista lambda. È necessario includere le funzioni di "print" nella nuova funzione da creare:

(define-macro (my-define @farg)
  (set (@farg 0)
    (letex (@fn (@farg 0)
            @arg (rest @farg)
            @arg-p (cons 'list (map (fn (@x) (if (list? @x) (first @x) @x)) (rest @farg)))
            @body (args))
      (append
           (lambda @arg (println "[" '@fn "] params: " @arg-p " args: " (args)))
        '@body))))

(constant (global 'define) my-define)

Esempi:

(define (f x) (+ x x))
;-> (lambda (x) (println "[" 'f "] params: " (list x) " args: " (args)) (+ x x))
(f 2)
;-> [f] params: (2) args: ()
;-> 4

(define (f (x 10) y) (+ x y))
;-> (lambda ((x 10) y) (println "[" 'f "] params: " (list x y) " args: " (args)) (+ x y))
(f 2 3)
;-> [f] params: (2 3) args: ()
;-> 5
(f 2 3 4 5)
;-> [f] params: (2 3) args: (4 5)
;-> 5

Nota: viene usato il carattere "@" (at) invece di "_" (underscore) perché in genere le macro hanno variabili che iniziano con "_" e quindi evitiamo il conflitto tra variabili.

Altra versione che ritorna anche il risultato della funzione:

(define-macro (my-define @farg)
  (set (@farg 0)
    (letex (@fn (@farg 0)
            @arg (rest @farg)
            @arg-p (cons 'list (map (fn (@x) (if (list? @x) (first @x) @x)) (rest @farg)))
            @body (cons 'begin (args)))
       (lambda @arg
         (println "[" '@fn "] params: " @arg-p " args: " (args))
         (println "[" '@fn "] result: " @body)))))

(constant (global 'define) my-define)

Esempi:

(define (f (x 10) y) (+ x y))
;-> (lambda ((x 10) y) (println "[" 'f "] params: " (list x y) " args: " (args))
  ;-> (println "[" 'f "] result: "  (begin  (+ x y))))
(f 2 3)
;-> [f] params: (2 3) args: ()
;-> [f] result: 5
;-> 5
(f 2 3 4 5)
;-> [f] params: (2 3) args: (4 5)
;-> [f] result: 5
;-> 5

macro "type" (Fanda)
--------------------
Questa macro permette di determinare il tipo dell'argomento.

(define-macro (type)
  (cond
    ((integer? (args 0)) "integer")
    ((float? (args 0)) "float")
    ((symbol? (args 0)) "symbol")
    ((string? (args 0)) "string")
    ((lambda? (args 0)) "lambda")
    ((macro? (args 0)) "macro")
    ((context? (args 0)) "context")
    ((list? (args 0)) "list")
    ((nil? (args 0)) "nil")
    (true nil)))

(type 1)
;-> "integer"

(type a)
;-> "symbol"

Un piccolo problema:

(type type)
;-> "symbol"
(macro? type)
;-> true

Nota: attenzione ad accettare troppi tipi di dati in una funzione. Soprattutto in un linguaggio con ambito dinamico, in cui è importante conoscere con sicurezza il tipo dei parametri in ingresso e di uscita.

macro "atag" (Lutz)
-------------------
Questa macro permette di formattare i tag HTML (JSON, XML).

(define-macro (atag )
  (append "<atag> " (join (map string (args)) " ") " </atag>"))

Esempio:

(atag a b c)
;-> "<atag> a b c </atag>"

Quindi l'idea è quella di definire una funzione o macro per ogni tag per formattarli agevolmente.

macro "func-lst" (Lutz)
-----------------------
Questa macro mostra come controllare quale parametro della macro sia una lista (cioè individuare quale indice ha il primo parametro di tipo lista).

(define-macro (func-lst) (nth (first (index list? (args))) (args)))
(func-lst 1 2 (a b c))
;-> (a b c)

(func-lst 1 2 (a b c) 4 5)
;-> (a b c)

Possiamo renderla più corta con la funzione "filter":

(define-macro (func-lst) (first (filter list? (args))))
(func-lst 1 2 (a b c) 4 5)
;-> (a b c)

Anche più corta con l'indicizzazione implicita (implicit indexing):

(define-macro (func-lst) ((filter list? (args)) 0))
(func-lst 1 2 (a b c) 4 5)
;-> (a b c)

macro "sq" (Jeremy Dunn)
------------------------
Questa macro effettua calcoli diversi in funzione del numero dei parametri:
un parametro: calcola il quadrato del parametro
N parametri: calcola la radice della somma dei quadrati dei parametri

;; This function takes one or more numbers as arguments. If there is a single
;; number the number is squared. If there is more than one number then the square
;; root of the sum of the squares (a^2 + b^2 + c^2 + ...)^1/2 is returned.
;; Example: (sq 3) -> 9
;;          (sq 2 3) -> 3.605551275
(define-macro (sq)
  (if (= (length (args)) 1)
      (mul (args 0)(args 0))
      (sqrt (apply add (map mul (args)(args))))))

macro "plist" (Jeff)
--------------------
Questa macro simula l'utilizzo delle property lists.

(define-macro (plist) (map rest (explode (args) 3)))

Esempio:

(println (plist :foo "bar" :baz "bat"))
;-> ((foo "bar") (baz "bat"))

macro "do" (Jeff)
-----------------
Ecco una macro che simula il controllo "do" del Common LISP (in realtà è più simile a do*, poiché usa "letn", piuttosto che "let" nella sua espansione):

(define-macro (do)
  (letex ((iter-forms (args 0))
        (break (args 1 0))
        (result (args 1 1))
        (body (cons begin (rest (rest (args))))))
   (letex ((init-forms (map (fn (form) (0 2 form)) 'iter-forms))
         (update-symbols (reverse (map first 'iter-forms)))
         (update-values (reverse (map last 'iter-forms))))
     (letn init-forms
      (do-until break body
              (map set 'update-symbols
                  (map eval 'update-values)))
      result))))

Questo è qualcosa che non si trova in newLISP. Tranne in casi specializzati come dolist, è più probabile che l'iterazione si verifichi su più variabili. La sintassi di questa macro è simile a quella del ciclo "for" (senza il valore del passo), con più espressioni init/update, quindi la lista della espressione di break e il risultato dell'espressione.

Ecco un esempio di fattoriale (da Ansi Common Lisp) che usa questo "do". Non ha nemmeno un corpo, perché i moduli di aggiornamento (update) fanno tutto il lavoro. Ho incluso un commento sulla posizione dove dove sarebbe il corpo.

(define (factorial n)
  (do ((j n (- j 1))
      (f 1 (* j f)))
     ((= j 0) f)
    ; (println j ", " f)
  ))

(println (factorial 10))
;-> 3628800

Sintassi:

(do ((sym1 init-form1 update-form1) [(sym2 init-form2 update-form2) ...])
     (exp-break sym-result) (expr-body*))

In altre parole, questa macro fa semplicemente la stessa cosa del ciclo "for", ma su più variabili, con una condizione di arresto e controllo sul valore restituito.

Considerazioni generali
-----------------------
L'idea alla base delle macro è quella di poter espandere la sintassi del linguaggio stesso quando necessario. Certo, le s-espressioni rendono questo meno necessario, dal momento che è possibile passare un lambda come "blocco di codice" a una funzione.

È generalmente accettato che l'utilizzo di macro per ottimizzare un programma è comunque una cattiva pratica. Le macro dovrebbero essere utilizzate per implementare funzionalità che non sarebbero altrimenti disponibili o che altrimenti richiederebbero la duplicazione della logica.

Le macro permettono di creare strutture sintattiche specifiche per scrivere un programma, spesso chiamati linguaggi specifici di dominio (DSL - Domain Specific Language). In questo modo la soluzione del problema viene definita (programmata) con espressioni (funzioni) che si adattano/descrivono meglio al dominio del problema stesso.

Nota: "define-macro" alone is just a "define" without arguments evaluation (Lutz).


=========================================================
 FOOP - PROGRAMMAZIONE FUNZIONALE ORIENTATA AGLI OGGETTI
=========================================================

La programmazione orientata agli oggetti funzionali (FOOP - Functional Object Oriented Programming) si basa sui seguenti cinque principi:

1) Gli attributi e i metodi delle classi sono memorizzati nello spazio dei nomi della classe di oggetti.

2) La funzione predefinita dello spazio dei nomi (functor) contiene il metodo di costruzione degli oggetti.

3) Un oggetto viene costruito utilizzando una lista, il cui primo elemento è il simbolo di contesto che descrive la classe dell'oggetto.

4) Il polimorfismo viene implementato usando l'operatore: (due punti), che seleziona la classe appropriata dall'oggetto.

5) Un oggetto target all'interno di una funzione dei metodi della classe è accessibile tramite la funzione "self".

I seguenti paragrafi sono una breve introduzione alla FOOP progettata da Michael Michaels:
http://neglook.com/

Al seguente indirizzo web potete trovare alcuni tutorial video sull'utilizzo della FOOP in newLISP:

http://neglook.com/index.cgi?page=newLISP

Classi e costruttori FOOP
-------------------------
Gli attributi e i metodi della classe sono memorizzati nello spazio dei nomi della classe di oggetti. Nessun dato dell'istanza di un oggetto è memorizzato in questo spazio dei nomi/contesto. Le variabili di dati nello spazio dei nomi della classe descrivono solo la classe di oggetti nel suo insieme, ma non contengono alcuna informazione specifica sull'oggetto. Un costruttore di oggetti FOOP generico può essere utilizzato come modello (template) per specifici costruttori di oggetti quando si creano nuove classi di oggetti con la funzione "new":

; built-in generic FOOP object constructor
(define (Class:Class)
    (cons (context) (args)))

; create some new classes

(new Class 'Rectangle)   → Rectangle
(new Class 'Circle)      → Circle

; create some objects using the default constructor

(set 'rect (Rectangle 10 20))   → (Rectangle 10 20)
(set 'circ (Circle 10 10 20))   → (Circle 10 10 20)

; create a list of objects
; building the list using the list function instead of assigning
; a quoted list ensures that the object constructors are executed

(set 'shapes (list (Circle 5 8 12) (Rectangle 4 8) (Circle 7 7 15)))
→ ((Circle 5 8 12) (Rectangle 4 8) (Circle 7 7 15))

Il costruttore FOOP generico è già predefinito e il codice FOOP può iniziare subito con (new Class ...).

Per motivi di stile, le nuove classi dovrebbero essere create solo nel contesto MAIN. Se si crea una nuova classe in uno spazio dei nomi diverso, il nome della nuova classe deve essere preceduto da MAIN e l'istruzione deve essere al livello superiore:

(context 'Geometry)

(new Class 'MAIN:Rectangle)
(new Class 'MAIN:Circle)

...

La creazione delle classi nello spazio dei nomi usando new riserva il nome della classe come contesto in newLISP e facilita i riferimenti diretti. Allo stesso tempo, viene definito un semplice costruttore per la nuova classe per creare istanze di nuovi oggetti. Come convenzione, si consiglia di iniziare i nomi delle classi in maiuscolo per segnalare che il nome sta per uno spazio dei nomi.

In alcuni casi, può essere utile sovrascrivere il costruttore semplice, creato durante la creazione della classe, con "new":

; overwrite simple constructor
(define (Circle:Circle x y radius)
    (list Circle x y radius))

Un costruttore può anche specificare i valori predefiniti:

; costruttore con valori predefiniti
(definisci (Cerchio: Cerchio (x 10) (y 10) (raggio 3))
    (elenco Cerchio x raggio y))

(Cerchio) → (Cerchio 10 10 3)
In molti casi il costruttore creato quando si utilizza new è sufficiente e non è necessario sovrascriverlo.

Oggetti e associazioni
----------------------
FOOP rappresenta gli oggetti come liste. Il primo elemento dell'elenco indica il tipo o la classe dell'oggetto, mentre gli elementi rimanenti contengono i dati. Le seguenti istruzioni definiscono due oggetti utilizzando uno dei costruttori definiti in precedenza:

(set 'myrect (Rectangle 5 5 10 20)) → (Rectangle 5 5 10 20)
(set 'mycircle (Circle 1 2 10)) → (Circle 1 2 10)

Un oggetto creato è identico alla funzione necessaria per crearlo (quindi FOOP). Gli oggetti nidificati possono essere creati in modo simile:

; create classes
(new Class 'Person)
(new Class 'Address)
(new Class 'City)
(new Class 'Street)

; create an object containing other objects
(set 'JohnDoe (Person (Address (City "Boston") (Street 123 "Main Street"))))
→ (Person (Address (City "Boston") (Street 123 "Main Street")))

Gli oggetti in FOOP non solo assomigliano a funzioni, ma assomigliano anche ad associazioni. La funzione assoc può essere utilizzata per accedere ai dati degli oggetti per nome:

(assoc Address JohnDoe) → (Address (City "Boston") (Street 123 "Main Street"))

(assoc (list Address Street) JohnDoe) → (Street 123 "Main Street")

In modo simile setf insieme ad assoc può essere usato per modificare i dati degli oggetti:

(setf (assoc (list Address Street) JohnDoe) '(Street 456 "Main Street"))
→ (Street 456 "Main Street")

Il numero civico "Street number" è stato cambiato da 123 a 456.

Si noti che nessuna delle dichiarazioni associate ad Address e Street contiene virgolette. Lo stesso vale per l'istruzione set: (set 'JohnDoe (Person ...)) per la parte di assegnazione dati. In entrambi i casi non trattiamo con simboli o con liste di simboli, ma piuttosto con contesti e oggetti FOOP che valutano su se stessi. Le virgolette non fanno alcuna differenza.

I due punti (colon) : operatore e polimorfismo
----------------------------------------------
In newLISP, il carattere due punti ":" viene utilizzato principalmente per connettere il simbolo di contesto con il simbolo che sta qualificando. In secondo luogo, la funzione due punti viene utilizzata in FOOP per risolvere l'applicazione di una funzione polimorfa.
Il codice seguente definisce due funzioni chiamate area, ognuna appartenente a un diverso spazio dei nomi/classe. Entrambe le funzioni avrebbero potuto essere definite in moduli diversi per una migliore separazione, ma in questo caso sono definite nello stesso file e senza istruzioni di contesto tra parentesi. Qui, solo i simboli rettangle:area e circle:area appartengono a spazi dei nomi diversi. I parametri locali p, c, dx e dy fanno tutti parte di MAIN, ma questo non è un problema.

;; class methods for rectangles

(define (Rectangle:area)
    (mul (self 3) (self 4)))

(define (Rectangle:move dx dy)
    (inc (self 1) dx)
    (inc (self 2) dy))

;; class methods for circles

(define (Circle:area)
    (mul (pow (self 3) 2) (acos 0) 2))

(define (Circle:move dx dy)
    (inc (self 1) dx)
    (inc (self 2) dy))

Prefissando il simbolo area con il carattere ":" (due punti), possiamo chiamare queste funzioni per ciascuna classe di oggetti. Sebbene non vi sia spazio tra i due punti e il simbolo che lo segue, newLISP li analizza come entità distinte. I due punti possono essere visti come una funzione che processa i parametri:

(:area myrect) → 200 ; same as (: area myrect)
(:area mycircle) → 314.1592654 ; same as (: area mycircle)

;; map class methods uses curry to enclose the colon operator and class function

(map (curry :area) (list myrect mycircle)) → (200 314.1592654)

(map (curry :area) '((Rectangle 5 5 10 20) (Circle 1 2 10))) → (200 314.1592654)

;; objects are mutable (since v10.1.8)

(:move myrect 2 3)
(:move mycircle 4 5)

myrect    → (Rectangle 7 8 10 20)
mycircle  → (Circle 5 7 10)

In questo esempio, il simbolo qualificato correttamente (rettangle:area o circle:area) viene costruito e applicato ai dati dell'oggetto in base al simbolo che segue i due punti e il nome del contesto (il primo elemento della lista che rappresenta l'oggetto).

Si noti che sebbene il chiamante specifica l'oggetto target della chiamata, la definizione del metodo non include l'oggetto come parametro. Quando si scrivono funzioni per modificare oggetti FOOP, viene utilizzata la funzione "self" per accedere e indicizzare l'oggetto.

Strutturare un programma FOOP grande
------------------------------------
In tutti gli esempi precedenti, i metodi delle funzioni della classe venivano scritti direttamente nello spazio dei nomi del contesto MAIN. Questo metodo funziona ed è adeguato per programmi piccoli scritti da un solo programmatore. Quando si scrivono sistemi più grandi, tutti i metodi di una classe dovrebbero essere rachhiusi da istruzioni di contesto per fornire un migliore isolamento delle variabili di parametro utilizzate e per creare una locazione isolata per le potenziali variabili di classe.

Le variabili di classe potrebbero essere utilizzate in questo esempio come contenitore per liste di oggetti, contatori o altre informazioni specifiche di una classe, ma non di un oggetto specifico. Il seguente codice riscrive l'esempio precedente in questo modo.

Ogni contesto/spazio dei nomi potrebbe essere memorizzato in un file aggiuntivo con lo stesso nome della classe contenuta. La creazione della classe, il codice di avvio e il codice di controllo principale si trovano nel file MAIN.lsp:

; file MAIN.lsp - declare all classes used in MAIN

(new Class 'Rectangle)
(new Class 'Circle)

; start up code

(load "Rectangle.lsp")
(load "Circle.lsp")

; main control code

; end of file

Ogni classe si trova in un file separato:

; file Rectangle.lsp - class methods for rectangles

(context Rectangle)

(define (Rectangle:area)
(mul (self 3) (self 4)))

(define (Rectangle:move dx dy)
(inc (self 1) dx)
(inc (self 2) dy))

; end of file

Segue la classe Circle:

; file Circle.lsp - class methods for circles

(context Circle)

(define (Circle:area)
    (mul (pow (self 3) 2) (acos 0) 2))

(define (Circle:move dx dy)
    (inc (self 1) dx)
    (inc (self 2) dy))

; end of file

Tutti gli insiemi delle funzioni di ogni classe sono ora separati lessicamente l'uno dall'altro.


=====================
 XML e S-espressioni
=====================

newLISP ha alcune funzioni che permettono di lavorare con i file XML. Vediamo la definizione di queste funzioni dal manuale ("xml-parse", "xml-type-tags" e "xml-error"):

***********************
>>>funzione XML-PARSE
***********************
sintassi: (xml-parse string-xml [int-options [sym-context [func-callback]]])

Analizza una stringa contenente XML ben formato, conforme a XML 1.0. xml-parse non esegue la convalida DTD. Viene saltata DTD (Document Type Declarations) e le relative istruzioni di elaborazione. Vengono analizzati i nodi di tipo ELEMENT, TEXT, CDATA e COMMENT e viene restituita una struttura lista newLISP. Quando un nodo elemento non ha attributi o nodi figlio, contiene invece una lista vuota. Gli attributi vengono restituiti come liste di associazioni, a cui è possibile accedere utilizzando "assoc". Quando xml-parse fallisce a causa di XML non valido, viene restituito nil e si può usare "xml-error" per accedere alle informazioni di errore.

(set 'xml 
  "<person name='John Doe' tel='555-1212'>nice guy</person>")

(xml-parse xml) 
;-> (("ELEMENT" "person" 
;->   (("name" "John Doe") 
;->    ("tel" "555-1212"))
;->   (("TEXT" "nice guy"))))

Modifica del processo di traduzione
-----------------------------------
Facoltativamente, è possibile specificare il parametro int-options per eliminare spazi bianchi, liste di attributi vuote e commenti. Può anche essere usato per trasformare i tag da stringhe in simboli. Un'altra funzione, xml-type-tags, serve per tradurre i tag XML. È possibile utilizzare le varie opzioni tramite i seguenti numeri:

opzione   descrizione
   1      suppress whitespace text tags
   2      suppress empty attribute lists
   4      suppress comment tags
   8      translate string tags into symbols
  16      add SXML (S-expression XML) attribute tags (@ ...)

Le opzioni possono essere combinate aggiungendo i numeri (ad esempio, 3 combina le opzioni per sopprimere gli spazi bianchi dei tag/informazioni di testo e le liste che hanno attributi vuoti).

I seguenti esempi mostrano come utilizzare le diverse opzioni:

XML source:
<?xml version="1.0" ?>
<DATABASE name="example.xml">
<!--This is a database of fruits-->
    <FRUIT>
        <NAME>apple</NAME>
        <COLOR>red</COLOR>
        <PRICE>0.80</PRICE>
    </FRUIT>

    <FRUIT>
        <NAME>orange</NAME>
        <COLOR>orange</COLOR>
        <PRICE>1.00</PRICE>
    </FRUIT>

    <FRUIT>
       <NAME>banana</NAME>
       <COLOR>yellow</COLOR>
       <PRICE>0.60</PRICE>
    </FRUIT>
</DATABASE>

Parsing senza alcuna opzione:

(xml-parse (read-file "example.xml"))
;-> (("ELEMENT" "DATABASE" (("name" "example.xml")) (("TEXT" "\r\n\t") 
;->   ("COMMENT" "This is a database of fruits") 
;->   ("TEXT" "\r\n\t") 
;->   ("ELEMENT" "FRUIT" () (("TEXT" "\r\n\t\t") ("ELEMENT" "NAME" () 
;->      (("TEXT" "apple"))) 
;->     ("TEXT" "\r\n\t\t") 
;->     ("ELEMENT" "COLOR" () (("TEXT" "red"))) 
;->     ("TEXT" "\r\n\t\t") 
;->     ("ELEMENT" "PRICE" () (("TEXT" "0.80"))) 
;->     ("TEXT" "\r\n\t"))) 
;->   ("TEXT" "\r\n\r\n\t") 
;->   ("ELEMENT" "FRUIT" () (("TEXT" "\r\n\t\t") ("ELEMENT" "NAME" () 
;->      (("TEXT" "orange"))) 
;->     ("TEXT" "\r\n\t\t") 
;->     ("ELEMENT" "COLOR" () (("TEXT" "orange"))) 
;->     ("TEXT" "\r\n\t\t") 
;->     ("ELEMENT" "PRICE" () (("TEXT" "1.00"))) 
;->     ("TEXT" "\r\n\t"))) 
;->   ("TEXT" "\r\n\r\n\t") 
;->   ("ELEMENT" "FRUIT" () (("TEXT" "\r\n\t\t") ("ELEMENT" "NAME" () 
;->      (("TEXT" "banana"))) 
;->     ("TEXT" "\r\n\t\t") 
;->     ("ELEMENT" "COLOR" () (("TEXT" "yellow"))) 
;->     ("TEXT" "\r\n\t\t") 
;->     ("ELEMENT" "PRICE" () (("TEXT" "0.60"))) 
;->     ("TEXT" "\r\n\t"))) 
;->   ("TEXT" "\r\n"))))

Gli elementi TEXT contenenti solo spazi bianchi rendono l'output molto confuso. Poiché il database in example.xml contiene solo dati, possiamo sopprimere spazi vuoti, liste vuote (senza attributi) e commenti con l'opzione (+ 1 2 4):

Filtrare gli spazi vuoti in TEXT, i COMMENT tag, e le liste con attributi vuoti:

(xml-parse (read-file "example.xml") (+ 1 2 4))
;-> (("ELEMENT" "DATABASE" (("name" "example.xml")) ( 
;->    ("ELEMENT" "FRUIT" (
;->      ("ELEMENT" "NAME" (("TEXT" "apple"))) 
;->      ("ELEMENT" "COLOR" (("TEXT" "red"))) 
;->      ("ELEMENT" "PRICE" (("TEXT" "0.80"))))) 
;->    ("ELEMENT" "FRUIT" (
;->      ("ELEMENT" "NAME" (("TEXT" "orange"))) 
;->      ("ELEMENT" "COLOR" (("TEXT" "orange"))) 
;->      ("ELEMENT" "PRICE" (("TEXT" "1.00"))))) 
;->    ("ELEMENT" "FRUIT" (
;->      ("ELEMENT" "NAME" (("TEXT" "banana"))) 
;->      ("ELEMENT" "COLOR" (("TEXT" "yellow"))) 
;->      ("ELEMENT" "PRICE" (("TEXT" "0.60"))))))))

L'output risultante sembra molto più leggibile, ma può ancora essere migliorato utilizzando simboli anziché stringhe per i tag "FRUIT", "NAME", "COLOR" e "PRICE", nonché eliminando i tag di tipo XML "ELEMENT" e "TEXT" completamente utilizzando la funzione "xml-type-tags".

Soppressione dei tag XML con "xml-type-tags" e traduzione dei tag di stringhe in tag di simboli:

;; suppress all XML type tags for TEXT and ELEMENT
;; instead of "CDATA", use cdata and instead of "COMMENT", use !--

(xml-type-tags nil 'cdata '!-- nil) 

;; turn on all options for suppressing whitespace and empty
;; attributes, translate tags to symbols

(xml-parse (read-file "example.xml") (+ 1 2 8))
→ ((DATABASE (("name" "example.xml")) 
     (!-- "This is a database of fruits") 
     (FRUIT (NAME "apple") (COLOR "red") (PRICE "0.80")) 
     (FRUIT (NAME "orange") (COLOR "orange") (PRICE "1.00")) 
     (FRUIT (NAME "banana") (COLOR "yellow") (PRICE "0.60"))))

Quando i tag vengono tradotti in simboli utilizzando l'opzione 8, è possibile specificare un contesto in sym-context. Se non viene specificato alcun contesto, tutti i simboli verranno creati all'interno del contesto corrente.

(xml-type-tags nil nil nil nil)
(xml-parse "<msg>Hello World</msg>" (+ 1 2 4 8 16) 'CTX)
;-> ((CTX:msg "Hello World"))

Se si specifica nil per i tag XLM di tipo TEXT ed ELEMENT, questi scompaiono. Allo stesso tempo, le parentesi delle liste di nodi figli rimosse in modo che i nodi figlio vengano ora visualizzati come membri della lista, a partire dal simbolo tag tradotto dai tag stringa "FRUIT", "NAME", eccetera.

Parsing in formato SXML (S-espressioni XML):

Utilizzando xml-type-tags per sopprimere tutti i tag di tipo XML, insieme ai numeri di opzione 1, 2, 4, 8 e 16, è possibile generare output in formato SXML:

(xml-type-tags nil nil nil nil)
(xml-parse (read-file "example.xml") (+ 1 2 4 8 16))
;-> ((DATABASE (@ (name "example.xml")) 
;->   (FRUIT (NAME "apple") (COLOR "red") (PRICE "0.80")) 
;->   (FRUIT (NAME "orange") (COLOR "orange") (PRICE "1.00")) 
;->   (FRUIT (NAME "banana") (COLOR "yellow") (PRICE "0.6

Se i tag XML originali contengono uno spazio di nomi (namespace) separato da un ":", i due 
punti verranno tradotti in un "." (dot) nel simbolo newLISP risultante.

Si noti che l'utilizzo dell'opzione numero 16 comporta l'aggiunta di un simbolo "@" (simbolo "at") alla lista degli attributi.

Vedi anche la funzione "xml-type-tags" per ulteriori informazioni sul parsing XML.

Parsing in un contesto specifico:

Durante i parsing delle espressioni XML, i tag XML vengono tradotti in simboli newLISP, quando viene specificata l'opzione 8. L'opzione "sym-context" specifica il contesto di destinazione per la creazione del simbolo:

(xml-type-tags nil nil nil nil)
(xml-parse (read-file "example.xml") (+ 1 2 4 8 16) 'CTX)
;-> ((CTX:DATABASE (@ (CTX:name "example.xml")) 
;->    (CTX:FRUIT (CTX:NAME "apple") (CTX:COLOR "red") (CTX:PRICE "0.80")) 
;->    (CTX:FRUIT (CTX:NAME "orange") (CTX:COLOR "orange") (CTX:PRICE "1.00")) 
;->    (CTX:FRUIT (CTX:NAME "banana") (CTX:COLOR "yellow") (CTX:PRICE "0.60"))))

Se il contesto non esiste, verrà creato. Se esiste, il carattere quiote "'" può essere omesso o il contesto può essere indicato da una variabile.

Utilizzare una funzione call back
---------------------------------
Normalmente, xml-parse non ritorna fino al termine del parsing. Usando l'opzione func-callback, xml-parse ritornerà, dopo ogni tag che si chiude, con la S-espressione generata e una posizione iniziale e lunghezza nell'XML sorgente:

;; demo callback feature
(define (xml-callback s-expr start size)
    (if (or (= (s-expr 0) 'NAME) (= (s-expr 0) 'COLOR) (= (s-expr 0) 'PRICE))
        (begin
            (print "parsed expression:" s-expr)
            (println ", source:" (start size example-xml))
        )
    )
)

(xml-type-tags nil 'cdata '!-- nil)
(xml-parse  (read-file "example.xml") (+ 1 2 8) MAIN xml-callback)

Il seguente output verrà generato dalla funzione call back "xml-callback":

parsed expression:(NAME "apple"), source:<NAME>apple</NAME>
parsed expression:(COLOR "red"), source:<COLOR>red</COLOR>
parsed expression:(PRICE "0.80"), source:<PRICE>0.80</PRICE>
parsed expression:(NAME "orange"), source:<NAME>orange</NAME>
parsed expression:(COLOR "orange"), source:<COLOR>orange</COLOR>
parsed expression:(PRICE "1.00"), source:<PRICE>1.00</PRICE>
parsed expression:(NAME "banana"), source:<NAME>banana</NAME>
parsed expression:(COLOR "yellow"), source:<COLOR>yellow</COLOR>
parsed expression:(PRICE "0.60"), source:<PRICE>0.60</PRICE>

La funzione di callback dell'esempio filtra i tag di interesse e li elabora man mano che si verificano.

**************************
>>>funzione XML-TYPE-TAGS
**************************
sintassi: (xml-type-tags [exp-text-tag exp-cdata-tag exp-comment-tag exp-element-tags])

Può sopprimere completamente o sostituire i tag di tipo XML "TEXT", "CDATA", "COMMENT" e "ELEMENT" con qualcos'altro specificato nei parametri.

Si noti che xml-type-tag eliminano o traducono solo i tag stessi, ma non sopprimono o modificano le informazioni taggate. Quest'ultimo viene fatto usando i numeri delle opzioni in xml-parse.

L'uso di xml-type-tags senza argomenti restituisce i tag di tipo correnti:

(xml-type-tags)
;-> ("TEXT" "CDATA" "COMMENT" "ELEMENT")

(xml-type-tags nil 'cdata '!-- nil)

Il primo esempio mostra solo i tag di tipo attualmente utilizzati. Il secondo esempio specifica la soppressione dei tag "TEXT" ed "ELEMENT" e mostra "cdata" e "!--" invece di CDATA e COMMENT.

**************************
>>>funzione XML-ERROR
**************************
sintassi: (xml-error)

Restituisce una lista di informazioni sull'errore dall'ultima operazione di "xml-parse". In caso contrario, restituisce nil se non si è verificato alcun errore. Il primo elemento contiene il testo che descrive l'errore e il secondo elemento è un numero che indica l'ultima posizione di scansione nel sorgente XML di origine, a partire da 0 (zero).

(xml-parse "<atag>hello</atag><fin")
;-> nil

(xml-error)
;-> ("expected closing tag: >" 18)

Convertire le S-espressioni in XML
----------------------------------

Come abbiamo visto, newLISP ha il supporto integrato per convertire un file in S-espressioni usando "xml-parse", ma non possiede la funzione inversa, cioè la possibilità di convertire una S-espressione in XML.
La seguente funzione può essere utilizzata per tradurre una S-espressione in XML:

;; translate s-expr to XML
;;
(define (expr2xml expr (level 0))
 (cond
   ((or (atom? expr) (quote? expr))
       (print (dup "  " level))
       (println expr))
   ((list? (first expr))
       (expr2xml (first expr) (+ level 1))
       (dolist (s (rest expr)) (expr2xml s (+ level 1))))
   ((symbol? (first expr))
       (print (dup "  " level))
       (println "<" (first expr) ">")
       (dolist (s (rest expr)) (expr2xml s (+ level 1)))
       (print (dup "  " level))
       (println "</" (first expr) ">"))
   (true
      (print (dup "  " level)
      (println "<error>" (string expr) "<error>")))
 ))

;; a lisp expression for a person

(set 'expr '(person
              (name "John Doe")
              (address (street "Main Street") (city "Anytown"))))

;; translate to XML with default indentation 0

(expr2xml expr)   =>

<person>
   <name>
     John Doe
   </name>
   <address>
       <street>
         Main Street
       </street>
       <city>
         Anytown
       </city>
   </address>
</person>

Il secondo parametro 0 è il livello di indentazione per l'espressione di tag più esterna.


================================================
 ANALISI DEI TEMPI DI ESECUZIONE DELLE FUNZIONI
================================================

Per analizzare i tempi di esecuzione delle funzioni newLISP mette a disposizione la funzione "time".

*****************
>>>funzione TIME
*****************
sintassi: (time exp [int-count)

Valuta l'espressione in exp e restituisce il tempo impiegato per la valutazione in millisecondi a virgola mobile. A seconda della piattaforma, vengono visualizzati o meno i decimali dei millisecondi.

(time (myprog x y z)) → 450.340
(time (myprog x y z) 10) → 4420.021

Nel primo esempio, sono trascorsi 450 millisecondi durante la valutazione (myprog x y z).
Il secondo esempio restituisce il tempo per dieci valutazioni di (myprog x y z).

Per vedere come utilizzare questa funzione ci serviamo del seguente problema:

Data un lista di n numeri, calcolare la somma massima di una sua sottolista, cioè, la somma più grande possibile di una sequenza di valori consecutivi nella lista. Da notare che possono esserci valori negativi nella lista. Per esempio, la lista (-2 2 4 -3 5 2 -6 2) ha la seguente sottolista con somma massima: (2 4 -3 5 2), la cui somma vale 10.

Possiamo risolvere il problema in tre modi diversi, ognuno con una complessità temporale differente.

Algoritmo A  -->  O(n^3)
------------------------
Il modo più semplice per risolvere il problema è passare attraverso tutte le possibili sottoliste, calcolare la somma dei valori di ogni sottolista e mantenere il valore della somma massima.

(define (A lst)
  (let ((out 0) (somma 0) (fine (- (length lst) 1)))
    (for (i 0 fine)
      (for (j i fine)
        (setq somma 0)
        (for (k i j)
          (setq somma (+ somma (lst k)))
        )
        (setq out (max out somma))
      )
    )
    out))

(setq lst '(-2 2 4 -3 5 2 -6 2))
(A lst)
;-> 10

La complessità temporale dell'algoritmo è O(n^3), perché è costituito da tre cicli annidati che attraversano la lista.

Algoritmo B  -->  O(n^2)
------------------------
Possiamo rendere l'algoritmo A più efficiente rimuovendo un ciclo. Ciò è possibile calcolando la somma nello stesso momento in cui l'indice destro della sottolista si muove.

(define (B lst)
  (let ((out 0) (somma 0) (fine (- (length lst) 1)))
    (for (i 0 fine)
      (setq somma 0)
      (for (j i fine)
        (setq somma (+ somma (lst j)))
        (setq out (max out somma))
      )
    )
    out))

(setq lst '(-2 2 4 -3 5 2 -6 2))
(B lst)
;-> 10

La complessità temporale dell'algoritmo è O(n^2), perché è costituito da due cicli annidati che attraversano la lista.

Algoritmo C  -->  O(n)
----------------------
Possiamo risolvere il problema in tempo O(n), cioè con un solo ciclo. L'idea è di calcolare per ciascuna posizione della lista la somma massima della sottolista che termina in quella posizione. A questo punto la risposta al problema è il massimo di quelle somme.
Vediamo come trovare la sottolista della somma massima che termina con la posizione k.
Ci sono due possibilità:
1. La sottolista contiene solo l'elemento nella posizione k.
2. La sottolista è costituita da una sottolista che termina in posizione k - 1, seguita dall'elemento in posizione k.
In quest'ultimo caso, poiché vogliamo trovare un sottolista con somma massima, la sottolista che termina alla posizione k - 1 dovrebbe anche avere la somma massima. Quindi, possiamo risolvere il problema in modo efficiente calcolando la somma massima della sottolista per ciascuna posizione finale da sinistra a destra.

(define (C lst)
  (let ((out 0) (somma 0) (fine (- (length lst) 1)))
    (for (i 0 fine)
        (setq somma (max (lst i) (+ somma (lst i))))
        (setq out (max out somma))
    )
    out))

(setq lst '(-2 2 4 -3 5 2 -6 2))
(C lst)
;-> 10

La complessità temporale dell'algoritmo è O(n), perché è costituito solo da un ciclo che attraversa la lista.

Nota: Questo è anche l'algoritmo ottimo perchè dobbiamo attraversare la lista almeno una volta con qualunque algoritmo.

Vediamo di calcolare la velocità delle tre funzioni. Prima prepariamo i dati, altrimenti il tempo di esecuzione calcolato includerebbe anche quello di creazione dei dati stessi.

Nota: per fare dei test di velocità è meglio utilizzare una REPL "nuova", cioè appena lanciata.

(silent
  ;10
  (setq lst01 (randomize (sequence -5 5)))
  ;100
  (setq lst02 (randomize (sequence -50 50)))
  ;1000
  (setq lst03 (randomize (sequence -500 500)))
  ;10000
  (setq lst04 (randomize (sequence -5000 5000)))
  ;100000
  (setq lst05 (randomize (sequence -50000 50000)))
  ;1000000
  (setq lst06 (randomize (sequence -500000 500000)))
)

Adesso possiamo calcolare i tempi di esecuzione delle tre funzioni, stampando anche il risultato della funzione per verificare che siano tutte corrette:

Funzione A
----------
(time (println (A lst01)))
;-> 14 ; risultato
;-> 0  ; tempo di esecuzione (msec)
(time (println (A lst02)))
;-> 466
;-> 16.982
(time (println (A lst03)))
;-> 8132
;-> 83572.628

Non proviamo (time (A lst04)) perchè... ci vuole troppo tempo.

Funzione B
----------
(time (println (B lst01)))
;-> 14
;-> 0
(time (println (B lst02)))
;-> 466
;-> 0.963
(time (println (B lst03)))
;-> 8132
;-> 359.068
(time (println (B lst04)))
;-> 315922
;-> 456891.876

Non proviamo (time (B lst05)) perchè... ci vuole troppo tempo.

Funzione C
----------

(time (println (C lst01)))
;-> 14
;-> 0.984
(time (println (C lst02)))
;-> 466
;-> 0.997
(time (println (C lst03)))
;-> 8132
;-> 2.061
(time (println (C lst04)))
;-> 315922
;-> 456891.442
(time (println (C lst05)))
;-> 9871843
;-> 15751.873

Non proviamo (time (C lst06)) perchè... ci vuole troppo tempo.

Ricapitoliamo i risultati:

|   Numero   | Tempo (msec) | Tempo (msec) | Tempo (msec) |
|  Elementi  | Algoritmo A  | Algoritmo B  | Algoritmo C  |
|   Lista    |   O(n^3)     |   O(n^2)     |   O(n)       |
+------------+--------------+--------------+--------------+
|    10      |         0    |         0    |        1     |
|    10^2    |        16    |         1    |        1     |
|    10^3    |     83572    |       359    |        2     |
|    10^4    |         -    |    456891    |      139     |
|    10^5    |         -    |         -    |    15751     |
|    10^6    |         -    |         -    |        -     |
|    10^7    |         -    |         -    |        -     |
+------------+--------------+--------------+--------------+

La tabella mostra chiaramente che l'algoritmo C è nettamente il migliore.

Comunque, in questo caso, possiamo utilizzare i vettori al posto delle liste con le stesse funzioni. Vediamo quanto migliorano i tempi di esecuzione.

Salviamo le funzioni in un file:

(save "ABC.lsp" 'A 'B 'C)

Partiamo con una REPL nuova e ricarichiamo le funzioni A, B e C:

(load "ABC.lsp")

Creiamo i vettori:

(silent
  ;10
  (setq ar01 (array 11 (randomize (sequence -5 5))))
  ;100
  (setq ar02 (array 101 (randomize (sequence -50 50))))
  ;1000
  (setq ar03 (array 1001 (randomize (sequence -500 500))))
  ;10000
  (setq ar04 (array 10001 (randomize (sequence -5000 5000))))
  ;100000
  (setq ar05 (array 100001 (randomize (sequence -50000 50000))))
  ;1000000
  (setq ar06 (array 1000001 (randomize (sequence -500000 500000))))
  ;10000000
  (setq ar07 (array 10000001 (randomize (sequence -5000000 5000000))))
)

Calcoliamo i tempi di esecuzione:

Funzione A
----------
(time (println (A ar01)))
;-> 14 ; risultato
;-> 0  ; tempo di esecuzione (msec)
(time (println (A ar02)))
;-> 466
;-> 10.952
(time (println (A ar03)))
;-> 8132
;-> 8519.551
(time (println (A ar04)))

Non proviamo (time (A ar04)) perchè anche in questo caso... ci vuole troppo tempo.

Funzione B
----------
(time (println (B ar01)))
;-> 14
;-> 0
(time (println (B ar02)))
;-> 466
;-> 1.066
(time (println (B ar03)))
;-> 8132
;-> 44.144
(time (println (B ar04)))
;-> 315922
;-> 4083.084
(time (println (B ar05)))
;-> 9871843
;-> 578540.698

Non proviamo (time (B ar06)) perchè... ci vuole troppo tempo.

Funzione C
----------

(time (println (C ar01)))
;-> 14
;-> 1.193
(time (println (C ar02)))
;-> 466
;-> 0.992
(time (println (C ar03)))
;-> 8132
;-> 0.985
(time (println (C ar04)))
;-> 315922
;-> 5.2
(time (println (C ar05)))
;-> 9871843
;-> 14.192
(time (println (C ar06)))
;-> 289944784
;-> 248.444
(time (println (C ar07)))
;-> 10435936563
;-> 3083.781

Ricapitoliamo i risultati :

|   Numero   | Tempo (msec) | Tempo (msec) | Tempo (msec) |
|  Elementi  | Algoritmo A  | Algoritmo B  | Algoritmo C  |
|   Lista    |   O(n^3)     |   O(n^2)     |   O(n)       |
+------------+--------------+--------------+--------------+
|    10      |         0    |         0    |        1     |
|    10^2    |        10    |         1    |        1     |
|    10^3    |      8519    |        44    |        1     |
|    10^4    |         -    |      4083    |        5     |
|    10^5    |         -    |   9871843    |       14     |
|    10^6    |         -    |         -    |      248     |
|    10^7    |         -    |         -    |     3083     |
+------------+--------------+--------------+--------------+

I vettori sono molto più veloci delle liste (perchè l'accesso non indicizzato delle liste è molto lento rispetto a quello dei vettori).

Per vedere la differenza di velocità tra le funzioni possiamo anche eseguirle un certo numero di volte con lo stesso input. Ad esempio:

(time (A ar02) 100)
;-> 937.535
(time (B ar02) 100)
;-> 46.79
(time (C ar02) 100)
;-> 0


==============
 UNIFICAZIONE
==============

Nella logica e nell'informatica, l'unificazione è un processo algoritmico di risoluzione di equazioni tra espressioni simboliche.

A seconda di quali espressioni (chiamate anche termini) possono verificarsi in un insieme di equazioni (chiamato anche problema di unificazione) e quali espressioni sono considerate uguali, vengono distinti diversi modelli (framework) di unificazione. 
Se in un'espressione sono consentite variabili di ordine superiore, ovvero variabili che rappresentano funzioni, il processo viene chiamato unificazione di ordine superiore (high-order unification), altrimenti unificazione di primo ordine (first-order unification). 
Se è necessaria una soluzione per rendere letteralmente uguali entrambi i lati di ciascuna equazione, il processo è chiamato unificazione sintattica o libera, altrimenti unificazione semantica o equazionale, o E-unificazione.

Una soluzione di un problema di unificazione è denotata come una sostituzione, cioè una mappatura che assegna un valore simbolico a ciascuna variabile delle espressioni del problema. Un algoritmo di unificazione dovrebbe calcolare per un dato problema un insieme di sostituzioni completo e minimo, cioè un insieme che copre tutte le sue soluzioni e non contiene membri ridondanti. A seconda del framework, un set di sostituzioni completo e minimo può avere al massimo uno, al massimo finitamente molti, o forse infinitamente molti membri, o può non esistere affatto. In alcuni framework è generalmente impossibile decidere se esiste una soluzione. Per l'unificazione sintattica del primo ordine, Martelli e Montanari [2] hanno fornito un algoritmo che segnala la non risolvibilità o calcola un insieme completo e minimo di sostituzioni singole contenente il cosiddetto unificatore più generale.

newLISP mette a disposizione la funzione "unify" per risolvere il problema dell'unificazione.

*******************
>>> funzione UNIFY
*******************
sintassi: (unify exp-1 exp-2 [list-env])

Valuta e confronta exp-1 ed exp-2. Le espressioni corrispondono se sono uguali o se una delle espressioni è una variabile non associata (unbound) (che sarebbe quindi associata all'altra espressione). Se le espressioni sono liste, vengono confrontate confrontando le sottoespressioni. Le variabili non associate iniziano con un carattere maiuscolo per distinguerle dai simboli. "unify" restituisce nil quando il processo di unificazione fallisce o restituisce una lista di associazioni di variabili in caso di successo. Quando nessuna variabile è stata associata, ma la corrispondenza è ancora riuscita, "unify" restituisce un elenco vuoto. newLISP utilizza l'algoritmo di unificazione di J. Alan Robinson modificato che applica correttamente il processi di associazione (vedi anche l'articolo di Peter Norvig su un bug comune dell'algoritmo di unificazione, che non è presente in questa implementazione).

Dalla versione 10.4.0 il simbolo di sottolineatura _ (ASCII 95) corrisponde a qualsiasi atomo, lista o variabile non associata e non viene mai associato.

Come "match", "unify" è spesso impiegato come parametro funtore in "find", "ref", "ref-all" e "replace".

Vediamo alcuni esempi:

(unify 'A 'A)  → ()  ; tautology

(unify 'A 123)  → ((A 123))  ; A bound to 123

(unify '(A B) '(x y))  → ((A x) (B y))  ; A bound to x, B bound to y

(unify '(A B) '(B abc))  → ((A abc) (B abc))  ; B is alias for A

(unify 'abc 'xyz)  → nil  ; fails because symbols are different

(unify '(A A) '(123 456))  → nil  ; fails because A cannot be bound to different values

(unify '(f A) '(f B))  → ((A B))  ; A and B are aliases

(unify '(f A) '(g B))  → nil  ; fails because heads of terms are different

(unify '(f A) '(f A B))  → nil  ; fails because terms are of different arity

(unify '(f (g A)) '(f B))  → ((B (g A)))  ; B bound to (g A)

(unify '(f (g A) A) '(f B xyz))  → ((B (g xyz)) (A xyz))  ; B bound to (g xyz) A to xyz

(unify '(f A) 'A)  → nil  ; fails because of infinite unification (f(f(f …)))

(unify '(A xyz A) '(abc X X))  →  nil ; indirect alias A to X doesn't match bound terms

(unify '(p X Y a) '(p Y X X))  → '((Y a) (X a)))  ; X alias Y and binding to 'a

(unify '(q (p X Y) (p Y X)) '(q Z Z))  → ((Y X) (Z (p X X)))  ; indirect alias

(unify '(A b _) '(x G z)) → ((A x) (G b)) ; _ matches atom z

(unify '(A b c _) '(x G _ z)) → ((A x) (G b)) ; _ never binds, matches c and z

(unify '(A b _) '(x G (x y z))) → ((A x) (G b)) ; _ matches list (x y z)

;; alcuni esempi presi da http://en.wikipedia.org/wiki/Unification_(computer_science)

"unify" può accettare, opzionalmente, un binding o una lista di associazioni in list-env. Ciò è utile quando si concatenano espressioni "unify" e devono essere inclusi i risultati delle precedenti associazioni "unify":

(unify '(f X) '(f 123))
;-> ((X 123))

(unify '(A B) '(X A) '((X 123)))
;-> ((X 123) (A 123) (B 123))

Nell'esempio precedente, X era associato a 123 in precedenza ed è incluso nella seconda istruzione per pre-associare X.

Uso di unify con expand
-----------------------
Notare che le variabili non sono effettivamente associate come assegnazione newLISP. Piuttosto, viene restituito una lista elenco di associazioni che mostra l'associazione logica. Una sintassi speciale della funzione "expand" può essere utilizzata per sostituire effettivamente le variabili associate con i loro termini:

(set 'bindings (unify '(f (g A) A) '(f B xyz)))
;-> ((B (g xyz)) (A xyz))

(expand '(f (g A) A) bindings)  
;-> (f (g xyz) xyz)

; or in one statement
(expand '(f (g A) A) (unify '(f (g A) A) '(f B xyz)))
;-> (f (g xyz) xyz)

Uso di unify con bind per destrutturare
---------------------------------------
La funzione "bind" può essere utilizzata per impostare variabili unificate:

(bind (unify '(f (g A) A) '(f B xyz)))
;-> xyz
A
;-> xyz
B
;-> (g xyz)

Questo può essere usato per destrutturare:

(set 'structure '((one "two") 3 (four (x y z))))
(set 'pattern '((A B) C (D E)))
(bind (unify pattern structure))

A ;-> one
B ;-> "two"
C ;-> 3
D ;-> four
E ;-> (x y z)

"unify" restituisce una lista associativa e "bind" lega le associazioni.

Model propositional logic with "unify"
--------------------------------------
L'esempio seguente mostra come simulare la logica proposizionale utilizzando "unify" ed "expand":

; if somebody is human, he is mortal -> (X human) :- (X mortal)
; socrates is human -> (socrates human)
; is socrates mortal? -> ?  (socrates mortal)

(expand '(X mortal)
         (unify '(X human) '(socrates human)))
;-> (socrates mortal)

Quello che segue è un esempio più complesso che mostra una piccola e funzionante implementazione del linguaggio PROLOG (Programming in Logic).

;; a small PROLOG implementation

(set 'facts '(
    (socrates philosopher)
    (socrates greek)
    (socrates human)
    (einstein german)
    (einstein (studied physics))
    (einstein human)
))

(set 'rules '(
    ((X mortal) <- (X human))
    ((X (knows physics)) <- (X physicist))
    ((X physicist) <- (X (studied physics)))
))

(define (query trm)
    (or  (when (find trm facts) true) (catch (prove-rule trm))))

(define (prove-rule trm)
    (dolist (r rules)
        (when (list? (set 'e (unify trm (first r))))
            (when (query (expand (last r) e))
                (throw true))))
    nil
)

Proviamo:

(query '(socrates human))
;-> true
(query '(socrates (knows physics)))
;-> nil
(query '(einstein (knows physics)))
;-> true

Il programma gestisce un database di fatti e un database di semplici regole "A è un fatto se B è un fatto". Un fatto è dimostrato vero se può essere trovato nel database dei fatti o se può essere dimostrato utilizzando una regola. Le regole possono essere annidate: ad esempio, per dimostrare che qualcuno (conosce la fisica), deve essere dimostrato vero che qualcuno è un fisico. Ma qualcuno è un fisico solo se quella persona ha studiato fisica. Il simbolo "<-" che separa i termini sinistro e destro delle regole non è richiesto e viene aggiunto solo per rendere più leggibile il database delle regole.

Questa implementazione non gestisce termini multipli nella parte destra delle regole (premesse), ma gestisce il backtracking del database delle regole per provare corrispondenze diverse. Non gestisce il backtracking nelle premesse multiple della regola. Ad esempio, se nella seguente regola "A se B e C e D", le premesse B e C hanno successo e D fallisce, un meccanismo di backtracking potrebbe dover tornare indietro e riunificare i termini B o A con fatti o regole diversi per far sì che D abbia successo.

L'algoritmo di cui sopra potrebbe essere scritto in modo diverso omettendo "expand" dalla definizione di prove-regola e passando l'ambiente "e" come argomento alle funzioni "unify" e "query".

L'apprendimento di fatti provati può essere implementato aggiungendoli al database dei fatti una volta che sono stati provati. Ciò renderebbero più veloci le query successive.

Le implementazioni PROLOG più grandi consentono anche la valutazione dei termini nelle regole. Ciò rende possibile implementare funzioni per svolgere altro lavoro durante l'elaborazione dei termini delle regole. La prova-regola potrebbe eseguire questo test per il simbolo eval in ogni termine della regola.

Riportiamo il post di Lutz Mueller dell'annuncio della funzione "unify":

----------------------------------------------------------------------------
Here is the long story: http://en.wikipedia.org/wiki/Unification

'unify' is implemented and will be released with development version 8.8.7 later this week.

In short 'unify' is some kind of logical comparison of list terms with logical binding of unbound variable to terms. 'unify' fails or succeeds depending on what you throw at it. It succeeds returning a list of variabe associations or an empty list and it fails returning 'nil'.

A function is worth a 1000 words so here is a snippet from the qa-dot file to test unify:

(define (test-unify)
    (and
        (= (unify 'X 123)
             '((X 123)))
        (= (unify '(Int Flt Str Sym Lst) '(123 4.56 "Hello" s '(a b c)))
             '((Int 123) (Flt 4.56) (Str "Hello") (Sym s) (Lst '(a b c))))
        (= (unify 'A 'A)
             '())
        (= (unify '(A B "hello") '("hi" A Z))
             '((A "hi") (B "hi") (Z "hello")))
        (= (unify '(A B) '(B abc))
             '((A abc) (B abc)))
        (= (unify '(B A)
             '(abc B)) '((B abc) (A abc)))
        (= (unify '(A A C D)
             '(B C 1 C)) '((B 1) (A 1) (C 1) (D 1)))
        (= (unify '(D C A A) '(C 1 C B))
             '((D 1) (C 1) (B 1) (A 1)))
        (= (unify '(f A) '(f (a b c)))
             '((A (a b c))))
        (= (unify '(A f) '((a b c) f))
             '((A (a b c))))
        (= (unify '(f (g A)) '(f B))
             '((B (g A))))
        (= (unify '(part X Y a) '(part Y X X))
             '((Y a) (X a)))
        (= (unify '(part X Y) '(part Y X))
             '((Y X)))
        (= (unify '(q (part X Y) (part Y X))
             '(q Z Z)) '((Y X) (Z (part X X))))
        (= (unify '(f (g A) A) '(f B xyz))
             '((B (g xyz)) (A xyz)))
        (= (unify '(A (g abc)) '(B A))
             '((B (g abc)) (A (g abc))))
        ;; with additional environment list
        (= (unify '(A (B) X) '(A (A) Z) '((A 1) (Z 4)))
            ' ((A 1) (Z 4) (B 1) (X 4)))
))

(test-unify)

'unify' takes 2 or (plus an optional environment list) terms and retuns an association list. From a logical point of view unification happens with all terms in parallel. Variables (in uppercase) are not actually bound (like with set) but a special form of 'expand' taking an association list of variables can be used to accomplish this.

'unify' is useful to write logic programming algorithms i.e. in AI Artificial Intelligence apps. A typical application would be Expert Systems or any knowledge based system where knowledge can be encoded in logical rules.

The release 8.9.0 out in June will contain a small implementation of a PROLOG like language using 'unify' and 'expand'. This Prolog context will be useful to write rule based systems.Here is the long story: http://en.wikipedia.org/wiki/Unification

'unify' is implemented and will be released with development version 8.8.7 later this week.
----------------------------------------------------------------------------


===================================
 STAMPARE CON print/println/format
===================================


Per stampare sulla REPL newLISP mette a disposizione tre funzioni:

1. La funzione "print" stampa i suoi argomenti.
2. La funzione "println" stampa i suoi argomenti e aggiunge un newline.
3. La funzione "format" formatta i suoi argomenti in una stringa.

Stamap semplice
---------------
Nel caso più semplice, print/println accetta un argomento: una stringa di caratteri da stampare. Questa stringa è composta da caratteri, ognuno dei quali viene stampato esattamente come appare.
Quindi print/println ("xyz") stampa semplicemente una x, poi una y e infine una z. Questa non è esattamente la stampa "formattata", ma è ancora la base di ciò che fa print/println.

Caratteri speciali naturali
---------------------------
Per identificare l'inizio della stringa, mettiamo una virgoletta doppia {"} all'inizio. Per identificare la fine della stringa mettiamo un'altra virgoletta doppia {"} alla fine. Ma cosa succede se vogliamo effettivamente stampare una virgoletta doppia?
Non possiamo inserire esattamente le virgolette doppie nel mezzo della stringa perché verrebbe scambiato per il marcatore di fine stringa. Le virgolette doppie sono un carattere speciale. Le normali regole di stampa di quello che vedi non si applicano.
Linguagi diversi adottano approcci diversi a questo problema. Alcuni richiedono che il carattere speciale venga immesso due volte. newLISP usa la barra rovesciata (backslash \) come carattere di escape per cambiare il significato del carattere successivo dopo di esso. Quindi, per stampare una virgoletta doppia, occorre digitare barra rovesciata (backslash) e virgolette doppie. Per stampare una barra rovesciata, è necessario eseguirne l'escape digitando un'altra barra rovesciata davanti ad essa. La prima barra rovesciata significa "dai al carattere successivo il suo significato alternativo". La seconda barra rovesciata ha il significato di "una barra rovesciata". Senza una barra rovesciata, i caratteri speciali hanno un significato speciale naturale. Con una barra rovesciata vengono stampati come appaiono.

Nota: in newLISP si possono utilizzare i doppi apici "" oppure le parentesi graffe { } per delimitare una stringa.

Ecco alcuni esempi:

(println "\\")
;-> \
(println "C:\\Windows\\System32\\")
;-> C:\Windows\System32\
(println "\"")
;-> "
(println {"})
;-> "
(println {\"})
;-> \"
(println "{}")
;-> {}
(println {{}})
;-> {}
(println """")
;-> ""
(println "%")
;-> %

Caratteri speciali alternativi
------------------------------
D'altra parte abbiamo anche caratteri che normalmente vengono stampati come ti aspetteresti, ma quando anteponi una barra rovesciata, poi diventano speciali. Un esempio è il carattere di nuova riga (newline). Per stampare una n, digitiamo semplicemente una n. Per stampare una nuova riga digitiamo \n, invocando così il significato alternativo di n, che è nuova riga (newline). Ecco un elenco parziale:

  +-------------------------------------+
  | Carattere  |  Descrizione           |
  +------------+------------------------+
  |    \a      |  audible alert (bell)  |
  |    \b      |  backspace             |
  |    \f      |  form feed             |
  |    \n      |  newline (linefeed)    |
  |    \r      |  carriage return       |
  |    \t      |  tab                   |
  |    \v      |  vertical tab          |
  +------------+------------------------+
  
(println "\t un tab")
;->          un tab
;-> "\t un tab"
(println "\t\t due tab")
;->                  due tab
;-> "\t\t due tab"
(println "riga 1\nriga 2")
;-> riga 1
;-> riga 2
;-> "riga 1\nriga 2"
(println "\n newline")
;-> 
;->  newline
;-> "\n newline"

Specifiche di formato
---------------------
La vera forza di print/println è quando viene utilizzata con la funzione "format" per stampare il contenuto delle variabili.

  sintassi: (format str-format exp-data-1 [exp-data-2 ... ])

La funzione "format" costruisce una stringa formattata da exp-data-1 utilizzando il formato specificato nella valutazione di str-format. Il formato specificato è simile al formato utilizzato per la funzione printf() nel linguaggio ANSI C. È possibile specificare due o più argomenti exp-data per più di un identificatore di formato in formato str-format. In altre parole, la funzione print/println si limita a stampare la stringa formattata da "format". Prendiamo ad esempio l'identificatore di formato %d. Questo identifica un numero. Quindi, è necessario fornire un numero per la stampa. Questo viene fatto aggiungendo un altro argomento all'istruzione print/println, come mostrato qui:

(setq anni 25)
(print (format "io ho %d anni\n" anni))
;-> io ho 25 anni

In questo esempio, "format" ha due argomenti. Il primo è una stringa: "io ho %d anni\n". Il secondo è un numero intero, anni.

La lista degli argomenti
------------------------
Quando "format" elabora i suoi argomenti, inizia a analizzare i caratteri che trova nel primo argomento, uno per uno. Quando trova una percentuale, sa di avere una specifica di formato. Passa all'argomento successivo e utilizza il suo valore, formattandolo in base a quella specifica di formato. Quindi torna a analizzare un carattere alla volta (dal primo argomento). Va bene includere più di una specifica di formato nella stringa di "format". In tal caso, la prima specifica di formato va con il primo argomento aggiuntivo, la seconda con il secondo e così via. Ecco un esempio:

(setq x 5 y 10)
(println (format "x vale %d e y vale %d\n" x y))
;-> x vale 5 e y vale 10

Percentuale "%"
--------------
La specifica di formato ha la seguente struttura:

  +----------------------------------------+
  |                                        |
  |  %[-][+][0][width][.][decimal]<id>[.]  |
  |                                        |
  +----------------------------------------+

dove:
   %         indica l'inizio dello specificatore di formato
  [-]        indica la giustificazione a destra
  [+]        indica la stampa del segno + (nei numeri positivi)
  [0]        indica il riempimento con 0
  [width]    indica la larghezza totale del numero (minima)
  [.]        separa i numeri witdh e decimal
  [decimal]  indica il numero di decimali (precisione)
  <id>       identificatore di formato
  [.]        inserisce "." nei numeri float con decimal = 0

e i termini racchiusi con le parentesi quadre [] sono opzionali.

Partiamo dall'inizio. Ogni specifica di formato inizia con un segno di percentuale "%" e termina con una lettera. Le lettere sono scelte per avere un significato mnemonico. Ecco un elenco parziale di identificatori di formato:

  +---------+------------------------------------+
  | Formato |   Descrizione                      |
  +---------+------------------------------------|
  |   %c    |   character (value 1 - 255)        |
  |   %s    |   text string                      |
  |   %d    |   decimal (32-bit)                 |
  |   %u    |   unsigned decimal (32-bit)        |
  |   %x    |   hexadecimal lowercase (base 16)  |
  |   %X    |   hexadecimal uppercase (base 16)  |
  |   %o    |   octal (32-bit)                   |
  |   %f    |   floating point                   |
  |   %e    |   scientific floating point        |
  |   %E    |   scientific floating point        |
  |   %g    |   general floating point           |
  |   %%    |   print a percent sign             |
  |   \\    |   print a backslash sign           |
  +---------+------------------------------------+

Per stampare un numero in modo semplice, l'identificatore di formato è %d. Di seguito sono riportati alcuni esempi:

(format "%d" 0)
;-> "0"
(format "%d" -7)
;-> "-7"
(format "%d" 1560133635)
;-> "1560133635"
(format "%d" -2035065302)
;-> "-2035065302"

Si noti che nel modo semplice, %d, non esiste una dimensione predeterminata per il risultato. "format" semplicemente crea una stringa con tutto lo spazio di cui ha bisogno.

L'opzione Larghezza
-------------------
Come abbiamo detto, la semplice stampa dei numeri non è sufficiente. Sono necessarie altre opzioni speciali, di cui la più importante è probabilmente l'opzione della larghezza. Scrivendo %5d, al numero vengono garantiti cinque spazi (di più se necessario, mai di meno). Questo è stato molto utile nella stampa di tabelle perché numeri piccoli e grandi occupano entrambi la stessa quantità di spazio (se utilizziamo un font monospace). Quindi, per stampare un numero con una certa larghezza (minima), ad esempio 5 spazi, l'identificatore di formato è %5d.
Di seguito sono riportati alcuni esempi:

(format "%5d" 0)
;-> "    0"
(format "%5d" -7)
;-> "   -7"
(format "%5d" 1560133635)
;-> "1560133635"
(format "%5d" -2035065302)
;-> "-2035065302"

Si noti che per numeri più corti, il risultato viene riempito con spazi iniziali. Per numeri eccessivamente lunghi non c'è riempimento e viene stampato il numero completo. Nell'uso normale, si dovrebbe rendere il campo abbastanza ampio per contenere il più grande numero atteso. Se i nostri numeri sono generalmente lunghi una, due o tre cifre, %3d è probabilmente adeguato. In caso di utilizzo anomalo, si potrebbe finire per formattare un numero troppo grande per il campo definito. print/println decide di stampare completamente tali numeri, anche se occupano troppo spazio. Questo perché è meglio stampare la risposta giusta e avere un aspetto brutto che stampare la risposta sbagliata e avere un aspetto carino.

Riempire lo spazio extra
------------------------
Quando si stampa un numero piccolo come 27 in un campo %5d, la domanda diventa quindi dove mettere il 27 e cosa inserire negli altri tre spazi. Potrebbe essere stampato nei primi due spazi, negli ultimi due spazi o forse nei due spazi centrali (se è possibile determinarlo). Gli spazi vuoti potrebbero essere riempiti con il carattere vuoto, o forse asterischi ("***27" o "27***" o "**27*"), o segni di dollaro ("$$$27") o segni di uguale ("===27"), o zeri iniziali (come "00027"). Questi caratteri extra sono spesso chiamati caratteri di "protezione dell'assegno" perché hanno lo scopo di impedire ai malintenzionati di modificare l'importo in dollari su un assegno stampato. È relativamente facile trasformare uno spazio in qualcos'altro. È più difficile cambiare un asterisco, un segno del dollaro o un segno di uguale. La funzione "format" di newLISP fornisce solo riempimento con spazi (sinistra o destra) e riempimento con zeri (solo a sinistra). Quindi se si desidera la protezione o la centratura con un carattere generico, è necessario utilizzare altri metodi. Ma anche senza queste possibilità, "format" ha molte opzioni utili.

L'opzione Giustificazione
-------------------------
Utilizzando "format" i numeri possono essere giustificati a sinistra (stampati a sinistra del campo) o a destra (stampati a destra del campo). Il modo più naturale per stampare i numeri sembra essere quello giustificato a destra con spazi iniziali. Questo è il significato del formato %5d: stampa un numero in base 10 in un campo di larghezza 5, con il numero allineato a destra e riempito con spazi. Per allineare il numero a sinistra, viene aggiunto un segno meno all'identificatore di formato. Per stampare un numero largo 5 spazi e giustificato a sinistra (allineato a sinistra), l'identificatore di formato è %-5d. Di seguito sono riportati alcuni esempi:

(format "%-5d" 0)
;-> "0    "
(format "%-5d" -7)
;-> "-7   "
(format "%-5d" 1560133635)
;-> "1560133635"
(format "%-5d" -2035065302)
;-> "-2035065302"

Come prima, per numeri più corti, il risultato viene riempito di spazi. Per numeri più lunghi non c'è riempimento e il numero non viene accorciato.

L'opzione Riempie-Zeri
----------------------
Per rendere le cose piacevoli è comune scrivere una data utilizzando gli zeri iniziali. Possiamo scrivere il 5 maggio 2003 come 05/05/2003. Potremmo anche scriverlo come 2003.05.05. Si noti che in entrambi i casi gli zeri iniziali non cambiano il significato. Lo fanno semplicemente allineare bene negli elenchi. Quando un numero è riempito con zero, gli zeri vanno sempre davanti e il numero risultante è giustificato sia a sinistra che a destra. In questo caso il segno meno non ha effetto. Per stampare un numero riempito con zero di 5 spazi, l'identificatore di formato è %05d. Di seguito sono riportati alcuni esempi:

(format "%05d" 0)
;-> "00000"
(format "%05d" -7)
;-> "-0007"
(format "%05d" 1560133635)
;-> "1560133635"
(format "%05d" -2035065302)
;-> "-2035065302"

I numeri più corti vengono riempiti con zeri iniziali. I numeri più lunghi rimangono invariati.

Il segno "+"
------------
I numeri negativi vengono sempre stampati con un segno meno. I numeri positivi e lo zero di solito non vengono stampati con un segno, ma è possibile farlo. Un segno più (+) nell'identificatore di formato permette quest. Per stampare un numero con segno di 5 spazi, l'identificatore di formato è %+5d. Di seguito sono riportati alcuni esempi:

(format "%+5d" 0)
;-> "   +0"
(format "%+5d" -7)
;-> "   -7"
(format "%+5d" 1560133635)
;-> "+1560133635"
(format "%+5d" -2035065302)
;-> "-2035065302"

Si noti che lo zero viene considerato come un numero positivo. I numeri più corti vengono riempiti con degli spazi (padded). I numeri più lunghi rimangono invariati. Più (+) e meno (-) non sono correlati. Entrambi possono essere visualizzati in un identificatore di formato. Di seguito sono riportati alcuni esempi:

(format "%-+5d" 0)
;-> "+0   "
(format "%-+5d" -7)
;-> "-7   "
(format "%-+5d" 1560133635)
;-> "+1560133635"
(format "%-+5d" -2035065302)
;-> "-2035065302"

Nota: in newLISP non esiste l'opzione "(+) invisibile" (rappresentata da uno spazio " "), cioè invece di stampare un (+) sui numeri positivi (e zero), stampiamo uno spazio dove andrebbe il segno. Questo può essere utile quando si vuole stampare numeri giustificati a sinistra in cui si desidera che i segni meno risaltino davvero. Vediamo due esempi:

(format "% -5d" -7)
;-> ERR: problem in format string in function format : "% -5d"
Risultato voluto: "-7   "
(format "% -5d" +7)
;-> ERR: problem in format string in function format : "% -5d"
Risultato voluto: " 7   "

Quindi newLISP non permette di inserire spazi vuoti nella specifica di formato.

"+" e "0"
---------
Ecco un altro esempio di combinazione contemporanea di due opzioni. Usando l'identificatore di formato %+05d otteniamo i seguenti risultati:

(format "%+05d" 0)
;-> "+0000"
(format "%+05d" -7)
;-> "-0007"
(format "%+05d" 1560133635)
;-> "+1560133635"
(format "%+05d" -2035065302)
;-> "-2035065302"

Ricordiamo che se allineiamo i numeri a sinistra otteniamo:

(format "%-+05d" 0)
;-> "+0   "
(format "%-+05d" -7)
;-> "-7   "
(format "%-+05d" 1560133635)
;-> "+1560133635"
(format "%-+05d" -2035065302)
;-> "-2035065302"

Flag
----
Le opzioni sono anche chiamate "flag" e vanno scritte nell'ordine [-][+][0]. Ecco un elenco parziale:

  +------------------------------------------------------------------+
  |  Flag     |  Effetto                                             |
  +-----------+------------------------------------------------------+
  |  nessuno  |  stampa normale (giustificazione a destra con spazi  |
  |  -        |  giustificazione a sinistra                          |
  |  +        |  stampa (+) per i numeri positivi                    |
  |  0        |  riempimento con zeri (a sinistra)                   |
  +-----------+------------------------------------------------------+

Dopo queste opzioni/flag, che sono opzionali, è possibile specificare la larghezza minima del campo.

Stampare stringhe
-----------------
L'opzione %s ci permette di stampare una stringa all'interno di una stringa. Ecco un esempio:

(setq tipo "ragazzo")
(format "%s è un %s\n" "Paolo" tipo)
;-> "Paolo è un ragazzo\n"
(print (format "%s è un %s\n" "Paolo" tipo))
;-> Paolo è un ragazzo

Il flag della giustificazione a sinistra (-) si applica anche alle stringhe, ma ovviamente il riempimento con zero, il segno più non hanno significato. Di seguito sono riportati alcuni esempi:

(format "%5s" "")
;-> "     "
(format "%5s" "a")
;-> "    a"
(format "%5s" "ab")
;-> "   ab"
(format "%5s" "abcdefg")
;-> "abcdefg"
(format "%-5s" "")
;-> "     "
(format "%-5s" "a")
;-> "a    "
(format "%-5s" "ab")
;-> "ab   "
(format "%-5s" "abcdefg")
;-> "abcdefg"

Numeri a virgola mobile (Floating Point)
----------------------------------------
I numeri in virgola mobile sono quelli come 3.1415 che hanno un punto decimale interno da qualche parte. Questo è in diverso dai normali numeri interi come 27 che non hanno punto decimale. Tutti gli stessi flag e regole si applicano ai numeri in virgola mobile come per i numeri interi, ma abbiamo alcune nuove opzioni. La più importante è quella per specificare quante cifre compaiono dopo il punto decimale. Questo valore (numero intero) è chiamato la "precisione" del numero. Di seguito sono riportati alcuni esempi per stampare questi numeri:

(setq e 2.718281828)
(format "%.0f" e) 
3
(format "%.0f." e) 
3.
(format "%.1f" e) 
2.7
(format "%.2f" e) 
2.72
(format "%.6f" e) 
2.718282
(format "%f" e) 
2.718282
(format "%.7f" e) 
2.7182818

Si noti che se vengono specificati un punto e un numero, il numero (la precisione) indica quante posizioni devono essere visualizzate dopo il punto decimale. Si noti che se per %f non sono specificati punti e precisione, il valore predefinito è %.6f (sei cifre dopo il punto decimale). Si noti che se viene specificata una precisione pari a zero, anche il punto decimale scompare. Se lo vogliamo stampare comunque, allora dobbiamo inserirlo appositamente (dopo l'identificatore di formato %f.). Possiamo specificare sia una larghezza che una precisione allo stesso tempo. Si noti in particolare che 5.2 indica una larghezza totale di cinque, con due cifre dopo il punto decimale. È molto comune e naturale pensare che significhi cinque cifre prima del decimale e due cifre dopo, ma non è corretto: significa cinque cifre in totale (considerando anche il punto come una cifra) con due cifre dopo il punto decimale. Dobbiamo stare attenti. Comunque l'eventuale troncamento delle cifre vale solo per le cifre dopo il punto decimale: la parte intera del numero viene sempre stampata completamente, anche se la larghezza è inferiore alla dimensione del numero. Di seguito sono riportati alcuni esempi:

(setq e 2.718281828)
2.718281828
(format "%f" e)
;-> "2.718282"
(format "%5.0f" e)
;-> "    3"
(format "%5.0f." e)
;-> "    3."
(format "%5.1f" e)
;-> "  2.7"
(format "%5.2f" e)
;-> " 2.72"
(format "%5.7f" e)
;-> "2.7182818"

Se la precisione è maggiore del numero delle cifre decimali del numero, allora vengono aggiunti degli zeri alla fine.
Se la precisione è minore del numero delle cifre decimali del numero, allora l'ultima cifra decimale viene arrotondata.

(setq x 1234.56789)
(format "%3.2f" x)
;-> "1234.57"
(format "%3.5f" x)
;-> "1234.56789"
(format "%11.5f" x)
;-> " 1234.56789"
(format "%10.6f" x)
;-> "1234.567890"
(format "%11.6f" x)
;-> "1234.567890"
(format "%12.6f" x)
;-> " 1234.567890"
(format "%12.4f" x)
;-> "   1234.5679"

Possiamo anche combinare la precisione con i flag che abbiamo visto in precedenza, per specificare la giustificazione a sinistra, gli zeri iniziali, i segni più, ecc.

(format "%5.1f" e)
;-> "  2.7"
(format "%-5.1f" e)
;-> "2.7  "
(format "%+5.1f" e)
;-> " +2.7"
(format "%-+5.1f" e)
;-> "+2.7 "
(format "%05.1f" e)
;-> "002.7"
(format "%+05.1f" e)
;-> "+02.7"

Progettare un formato di stampa
-------------------------------
Per definire un formato di stampa, il primo passo è decidere che tipi di oggetti occorre utilizzare. Se è un numero intero, un float, una stringa o un carattere, faremo scelte diverse sul formato di base da usare. La seconda domanda è quanto dovrebbe essere ampio il nostro campo. Di solito questa sarà la dimensione del numero più grande che ci aspettiamo di stampare in circostanze normali. 
Il test del formato di stampa deve essere effettuato utilizzando i valori estremi dei nostri oggetti (es. con una larghezza minima e massima dei numeri e delle stringhe che dobbiamo trattare).
Per analizzare una specifica di formato occorre utilizzare un processo di eliminazione per isolare le singole opzioni che intendiamo verificare. Per definire una specifica di formato occorre verificare ogni opzione durante la costruzione della specifica stessa.

Prima e dopo
------------
Un'altra cosa importante da tenere d'occhio è il prima, il mezzo e il dopo del numero stampato. In una specifica di formattazione come "x%5dz" c'è una "x" prima del numero e una "z" dopo il numero. La "x" e la "z" non fanno parte della specifica del formato, ma fanno parte del risultato stampato. Tutto il resto che viene stampato si trova "tra". Dopo aver determinato cosa c'è prima e cosa dopo, possiamo analizzare la specifica di formato vera e propria.

(format "x%5dz" 123)
;-> "x  123z"

Conclusioni
-----------
Le funzioni print/println/format sono uno strumento molto potente per stampare numeri e altri valori memorizzati nelle variabili. Con questo potere abbiamo anche una certa complessità. Presa tutta in una volta, la complessità fa sembrare lo strumento molto difficile da capire. Ma la complessità può essere facilmente suddivisa e spiegata in semplici funzionalità, tra cui larghezza, precisione, giustificazione e riempimento. Imparando a conoscere queste caratteristiche le attività di stampa saranno notevolmente semplificate.
Quindi per utilizzare efficacemente le funzioni di stampa occorre semplicemente... fare pratica.

Per finire vediamo altri esempi:

*** Formattazione numeri interi

Allineamento a destra
(format "%3d" 0))
;-> "  0"
(format "%3d" 123456789)
;-> "123456789"
(format "%+5d" -10)
;-> "  -10"
(format "%+5d" 10)
;-> "  +10"
(format "%12d" -123456789)
;-> "  -123456789"
(format "%12d" 123456789)
;-> "   123456789"
(format "%+12d" 123456789)

Allineamento a sinistra
(format "%-3d" 0)
;-> "0  "
(format "%-3d" 123456789)
;-> "123456789"
(format "%+5d" -10)
;-> "  -10"
(format "%-12d" -123456789)
;-> "-123456789  "
(format "%-12d" 123456789)
;-> "123456789   "
(format "%-+12d" 123456789)
;-> "+123456789  "

Riempimento con zeri
(format "%03d" 0)
;-> "000"
(format "%03d" 1)
;-> "001"
(format "%03d" 123456789)
;-> "123456789"
(format "%012d" 123456789)
;-> "000123456789"
(format "%05d" -10)
;-> "-0010"
(format "%012d" -123456789)
;-> "-00123456789"
(format "%-5d" -10)
;-> "-10  "
(format "%-+5d" 10)
;-> "+10  "

*** Formattazione numeri float

(format "%.1f" 10.3456)
;-> "10.3"
(format "%.2f" 10.3456)
;-> "10.35"
(format "%8.2f" 10.3456)
;-> "   10.35"
(format "%8.4f" 10.3456)
;-> " 10.3456"
(format "%08.2f" 10.3456)
;-> "00010.35"
(format "%-8.2f" 10.3456)
;-> "10.35   "
(format "%-8.2f" 101234567.3456)
;-> "101234567.35"

*** Formattazione stringhe

(format "%s"  "Ciao")
;-> "Ciao"
(format "%10s" "Ciao")
;-> "      Ciao"
(format "%-10s" "Ciao")
;-> "Ciao      "

Per finire vediamo un esempio con formattazione multipla:

(setq str '("mele" "fragole" "arance" "kiwi" "mango" "pere" "noci"))
(setq interi '(-11 100 0 -3 456 -1001 10000))
(setq mobile '(-0.0004 3456.12345 0.01 123456.7 0.123456 10 -100))

(for (i 0 6)
  (println (format "%-6s\t%5d\t%13.6f" (str i) (interi i) (mobile i))))
;-> mele      -11       -0.000400
;-> fragole   100     3456.123450
;-> arance      0        0.010000
;-> kiwi       -3   123456.700000
;-> mango     456        0.123456
;-> pere    -1001       10.000000
;-> noci    10000     -100.000000


====================
 CODICI ANSI ESCAPE
====================

Le sequenze di escape ANSI sono uno standard di codici per controllare la posizione del cursore, il colore, lo stile dei caratteri e altre opzioni sui video terminali di testo. Non tutti i terminali supportano completamente le sequenze di Escape.
In questo caso utilizziamo come terminale il "DOS command" di Windows 10 (windows console) che permette le sequenze ANSI (anche se non tutte sono disponibili) . Nel 2019 la microsoft ha rilasciato anche un altro terminale "windows terminal" che supporta tutte (o quasi) le sequenze.

Nota: l'output del testo qui stampato non è a colori (o grassetto, sottolineato, ecc.)... usate la REPL di newLISP per vedere i risultati reali delle sequenze ANSI.

Tutte le sequenze hanno la forma:

  ╔════════════╗
  ║  ESC[XXXm  ║
  ╚════════════╝

dove, ESC vale \027 (decimale) 
             o \033 (ottale) 
             o \u001b (unicode)
             0 \x1b esadecimale
             o ^[ (Ctrl-Key)
     e XXX è una serie di parametri separati da punto e virgola ";".

Per esempio, per rendere il testo rosso, grassetto e sottolineato (discuteremo altre opzioni di seguito) in newLISP possiamo scrivere:

(println "\027[31;1;4mPippo\027[0m")
;-> Pippo ;sul terminale in rosso, grassetto e sottolineato

Nota: nella console windows il grassetto viene rappresentato con il colore brillante (vedi sequenze sui colori)

Per modificare le caratteristiche dei caratteri (font) abbiamo a disposizione diverse sequenze elencate nella tabella seguente:

Tabella delle sequenze per le caretteristiche dei font
------------------------------------------------------

  +-----------------+---------+-------------------------------------+
  | Sequenza        | Reset   | Descrizione                         |
  +-----------------+---------+-------------------------------------+
  | ESC[1;34;G...Gm |         | Set graphics modes for cell (sep=;) |
  +-----------------+---------+-------------------------------------+
  | ESC[0m          |         | reset all modes (styles and colors) |
  +-----------------+---------+-------------------------------------+
  | ESC[1m          | ESC[22m | set bold mode                       |
  +-----------------+---------+-------------------------------------+
  | ESC[2m          | ESC[22m | set dim/faint mode                  |
  +-----------------+---------+-------------------------------------+
  | ESC[3m          | ESC[23m | set italic mode                     |
  +-----------------+---------+-------------------------------------+
  | ESC[4m          | ESC[24m | set underline mode                  |
  +-----------------+---------+-------------------------------------+
  | ESC[5m          | ESC[25m | set blinking mode                   |
  +-----------------+---------+-------------------------------------+
  | ESC[7m          | ESC[27m | set inverse/reverse mode            |
  +-----------------+---------+-------------------------------------+
  | ESC[8m          | ESC[28m | set hidden/invisible mode           |
  +-----------------+---------+-------------------------------------+
  | ESC[9m          | ESC[29m | set strikethrough mode              |
  +-----------------+---------+-------------------------------------+

Vediamo alcuni esempi:

Testo sottolineato (4m):
(println "\027[4mPippo\027[0m")

Testo in grassetto (1m) (colore brillante):
(println "\027[1mPippo\027[0m")

Le altre sequenze non funzionano nella console windows.

La tabella seguente elenca i codici che servono per modificare le caratteristiche estese dei caratteri (font):

╔═════════╦══════════════════════════════╦══════════════════════════════════╗
║ Codice  ║          Effetto             ║              Note                ║
╠═════════╬══════════════════════════════╬══════════════════════════════════╣
║ 0       ║ Reset / Normal               ║ all attributes off               ║
║ 1       ║ Bold or increased intensity  ║                                  ║
║ 2       ║ Faint (decreased intensity)  ║ Not widely supported             ║
║ 3       ║ Italic                       ║ Not widely supported             ║
║ 4       ║ Underline                    ║                                  ║
║ 5       ║ Slow Blink                   ║ less than 150 per minute         ║
║ 6       ║ Rapid Blink                  ║ MS-DOS ANSI.SYS. 150+ per minute ║
║ 7       ║ [[reverse video]]            ║ swap fore and back colors        ║
║ 8       ║ Conceal                      ║ Not widely supported             ║
║ 9       ║ Crossed-out                  ║ Characters marked for deletion   ║
║ 10      ║ Primary(default) font        ║                                  ║
║ 11–19   ║ Alternate font               ║ Select alternate font "n-10"     ║
║ 20      ║ Fraktur                      ║ hardly ever supported            ║
║ 21      ║ Bold off or Double Underline ║ not widely supported             ║
║ 22      ║ Normal color or intensity    ║ Neither bold nor faint           ║
║ 23      ║ Not italic, not Fraktur      ║                                  ║
║ 24      ║ Underline off                ║ Not singly or doubly underlined  ║
║ 25      ║ Blink off                    ║                                  ║
║ 27      ║ Inverse off                  ║                                  ║
║ 28      ║ Reveal                       ║ conceal off                      ║
║ 29      ║ Not crossed out              ║                                  ║
║ 30–37   ║ Set foreground color         ║ See color table                  ║
║ 38      ║ Set foreground color         ║ Next args: "5;n" or "2;r;g;b"    ║
║ 39      ║ Default foreground color     ║ implementation defined           ║
║ 40–47   ║ Set background color         ║ See color table below            ║
║ 48      ║ Set background color         ║ Next args: "5;n" or "2;r;g;b"    ║
║ 49      ║ Default background color     ║ implementation defined           ║
║ 51      ║ Framed                       ║                                  ║
║ 52      ║ Encircled                    ║                                  ║
║ 53      ║ Overlined                    ║                                  ║
║ 54      ║ Not framed or encircled      ║                                  ║
║ 55      ║ Not overlined                ║                                  ║
║ 60      ║ ideogram underline           ║ hardly ever supported            ║
║ 61      ║ ideogram double underline    ║ hardly ever supported            ║
║ 62      ║ ideogram overline            ║ hardly ever supported            ║
║ 63      ║ ideogram double overline     ║ hardly ever supported            ║
║ 64      ║ ideogram stress marking      ║ hardly ever supported            ║
║ 65      ║ ideogram attributes off      ║ reset the effects of all 60-64   ║
║ 90–97   ║ Set bright foreground color  ║ aixterm (not in standard)        ║
║ 100–107 ║ Set bright background color  ║ aixterm (not in standard)        ║
╚═════════╩══════════════════════════════╩══════════════════════════════════╝

Per quanto riguarda i colori abbiamo la sequenza:

  ╔══════════════════╗
  ║  ESC[back;forem  ║
  ╚══════════════════╝

dove "back" è il colore di Background e "fore" è il colore di Foreground.

Con le seguenti tabelle di colori: 

Tabella 8 Colori
----------------
  +---------+------------+------------+
  | Colore  | Foreground | Background |
  +---------+------------+------------+
  | Black   | 30         | 40         |
  +---------+------------+------------+
  | Red     | 31         | 41         |
  +---------+------------+------------+
  | Green   | 32         | 42         |
  +---------+------------+------------+
  | Yellow  | 33         | 43         |
  +---------+------------+------------+
  | Blue    | 34         | 44         |
  +---------+------------+------------+
  | Magenta | 35         | 45         |
  +---------+------------+------------+
  | Cyan    | 36         | 46         |
  +---------+------------+------------+
  | White   | 37         | 47         |
  +---------+------------+------------+
  | Default | 39         | 49         |
  +---------+------------+------------+
  | Reset   | 0          | 0          |
  +---------+------------+------------+

Nota: il colore "Reset" è il codice che ripristina tutti i colori e gli effetti di testo. 
Il colore "Default" ripristina solo i colori.

Esempi:

"pippo" in rosso su sfondo verde:
(println "\027[31;42m" "pippo")
;-> pippo

Ripristiniamo (Reset) i colori:
(println "\027[39;49m" "pippo")
;-> pippo

Tabella 8 colori brillanti
--------------------------
  +----------------+------------+------------+
  | Colore         | Foreground | Background |
  +----------------+------------+------------+
  | Bright-Black   | 90         | 100        |
  +----------------+------------+------------+
  | Bright-Red     | 91         | 101        |
  +----------------+------------+------------+
  | Bright-Green   | 92         | 102        |
  +----------------+------------+------------+
  | Bright-Yellow  | 93         | 103        |
  +----------------+------------+------------+
  | Bright-Blue    | 94         | 104        |
  +----------------+------------+------------+
  | Bright-Magenta | 95         | 105        |
  +----------------+------------+------------+
  | Bright-Cyan    | 96         | 106        |
  +----------------+------------+------------+
  | Bright-White   | 97         | 107        |
  +----------------+------------+------------+

Vediamo alcuni esempi in newLISP:

; COLORS
; basic color
(define black "\027[0;30m")
(define red "\027[0;31m")
(define green "\027[0;32m")
(define yellow "\027[0;33m")
(define blue "\027[0;34m")
(define magenta "\027[0;35m")
(define cyan "\027[0;36m")
(define white "\027[0;37m")
; bright color
(define black-b "\027[0;90m")
(define red-b "\027[0;91m")
(define green-b "\027[0;92m")
(define yellow-b "\027[0;93m")
(define blue-b "\027[0;94m")
(define magenta-b "\027[0;95m")
(define cyan-b "\027[0;96m")
(define white-b "\027[0;97m")
; restore color to default
(define reset-all "\027[39;49m")
; restore all to default
(define default-all "\027[0;0m")

Definiamo una tabella con i 16 colori:

(define col16 '(black red green yellow blue magenta cyan white
        black-b red-b green-b yellow-b blue-b magenta-b cyan-b white-b))

Stampiamo tutti i colori:

(dolist (c col16)
  (println (eval c) { } c)
)
;-> black
;-> red
;-> green
;-> yellow
;-> blue
;-> magenta
;-> cyan
;-> white
;-> black-b
;-> red-b
;-> green-b
;-> yellow-b
;-> blue-b
;-> magenta-b
;-> cyan-b
;-> white-b

Funzione che stampa num caratteri "." (dot) con colori random:

(define (dots num)
  (for (i 1 num)
    (print (eval (col16 (rand 15))) ".")))

(dots 100)
;-> ..................................................
;-> ..................................................

Tabella 256 colori
------------------
Per impostare i colori del testo scegliendo tra 256 colori possiamo utilizzare le seguenti due sequenze:

Imposta il colore del testo (foreground -> primo piano):

  ╔══════════════════╗
  ║  ESC[38;5;{ID}m  ║  Imposta il colore di primo piano (testo)
  ╚══════════════════╝

Imposta il colore dello sfondo del testo (background -> sfondo):

  ╔══════════════════╗
  ║  ESC[48;5;{ID}m  ║  Imposta il colore di sfondo
  ╚══════════════════╝

Dove {ID} deve essere sostituito con l'indice dei colori da 0 a 255 della tabella raffigurata nel file "ANSI-color.png" che si trova nella cartella "data". Comunque possiamo stampare questi colori con newLISP.

Funzione che modifica il colore di foreground:

(define (foreground color)
  (let (f (string "\027[38;5;" color "m"))
    (print f)))

Funzione che modifica il colore di background:

(define (background color)
  (let (b (string "\027[48;5;" color "m"))
    (print b)))

Espressione che stampa i 256 colori disponibili:

(for (i 0 255) (print (foreground i) i { }))
;-> 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27
;-> 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 
;-> 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 
;-> 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 
;-> 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 
;-> 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 
;-> 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 
;-> 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 
;-> 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 
;-> 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 
;-> 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 
;-> 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 
;-> 244 245 246 247 248 249 250 251 252 253 254 255

Naturalmente sul terminale l'output è a colori...

Colori RGB
----------
I terminali più moderni supportano Truecolor (RGB a 24 bit), che consente di impostare i colori di primo piano e di sfondo utilizzando i codici RGB (Red Green Blue).

Le sequenze di Escape sono le seguenti:

Imposta il colore in RGB del testo (foreground -> primo piano):

  ╔═════════════════════════╗
  ║  ESC[38;2;{r};{g};{b}m  ║ Imposta colore di primo piano in RGB (testo)
  ╚═════════════════════════╝

Imposta il colore in RGB dello sfondo del testo (background -> sfondo):
  
  ╔═════════════════════════╗
  ║  ESC[48;2;{r};{g};{b}m  ║ Imposta colore di sfondo in RGB
  ╚═════════════════════════╝
  
dove {r} = codice red, {g} = codice green e {b} = codice blue

Nota: la console di Windows non supporta queste sequenze per definire i colori in RGB.

Le sequenze ANSI della tabella seguente permettono di cancellare parti dello schermo:

Tabella sequenze di cancellazione
---------------------------------
  +----------+-------------------------------------------+
  | Sequenza | Descrizione                               |
  +----------+-------------------------------------------+
  | ESC[J    | clears the screen                         |
  +----------+-------------------------------------------+
  | ESC[0J   | clears from cursor until end of screen    |
  +----------+-------------------------------------------+
  | ESC[1J   | clears from cursor to beginning of screen |
  +----------+-------------------------------------------+
  | ESC[2J   | clears entire screen                      |
  +----------+-------------------------------------------+
  | ESC[K    | clears the current line                   |
  +----------+-------------------------------------------+
  | ESC[0K   | clears from cursor to end of line         |
  +----------+-------------------------------------------+
  | ESC[1K   | clears from cursor to start of line       |
  +----------+-------------------------------------------+
  | ESC[2K   | clears entire line                        |
  +----------+-------------------------------------------+

Vediamo alcuni esempi: 

Cancella interamente lo schermo:
(println "\027[2J")

Elimina l'intera riga:
(println "pluto\027[2K pippo")
;->       pippo

Le sequenze ANSI della tabella seguente permettono di posizionare il cursore nello schermo:

Tabella sequenze di controllo cursore
-------------------------------------
  +----------------------+--------------------------------------------------+
  | Sequenza             | Descrizione                                      |
  +----------------------+--------------------------------------------------+
  | ESC[H                | cursor to home position (0, 0)                   |
  +----------------------+--------------------------------------------------+
  | ESC[{line};{column}H | cursor to line #, column #                       |
  +----------------------+--------------------------------------------------+
  | ESC[{line};{column}f | cursor to line #, column #                       |
  +----------------------+--------------------------------------------------+
  | ESC[#A               | cursor up # lines                                |
  +----------------------+--------------------------------------------------+
  | ESC[#B               | cursor down # lines                              |
  +----------------------+--------------------------------------------------+
  | ESC[#C               | cursor right # columns                           |
  +----------------------+--------------------------------------------------+
  | ESC[#D               | cursor left # columns                            |
  +----------------------+--------------------------------------------------+
  | ESC[#E               | cursor to beginning of next line, # lines down   |
  +----------------------+--------------------------------------------------+
  | ESC[#F               | cursor to beginning of previous line, # lines up |
  +----------------------+--------------------------------------------------+
  | ESC[#G               | cursor to column #                               |
  +----------------------+--------------------------------------------------+
  | ESC[6n               | request cursor position (ESC[#;#R)               |
  +----------------------+--------------------------------------------------+
  | ESC7                 | save cursor position (DEC)                       |
  +----------------------+--------------------------------------------------+
  | ESC8                 | restores cursor to the last saved position (DEC) |
  +----------------------+--------------------------------------------------+
  | ESC[s                | save cursor position (SCO)                       |
  +----------------------+--------------------------------------------------+
  | ESC[u                | restores cursor to the last saved position (SCO) |
  +----------------------+--------------------------------------------------+

Nota: alcune sequenze, come il salvataggio e il ripristino dei cursori, non sono standard.

Come ultimo esempio vediamo l'utilizzo combinato di due sequenze: la prima posiziona il cursore in alto a sinistra (0,0) e la seconda cancella lo schermo:

(define (cls)
  (print "\027[H\027[2J"))

(cls)


=================================================================
 COMPLESSITÀ TEMPORALE DELLE OPERAZIONI ARITMETICHE FONDAMENTALI
=================================================================

La tabella seguente elenca la complessità computazionale di vari algoritmi per operazioni matematiche comuni.

Operazione        Input                   Output                      Algoritmo                            Complessità
----------------------------------------------------------------------------------------------------------------------
Addizione         due numeri da n cifre   un numero da (n+1) cifre    Addizione con riporto                Θ(n)
Sottrazione       due numeri da n cifre   un numero da (n+1) cifre    Sottrazione con prestito             Θ(n)
Moltiplicazione   due numeri da n cifre   un numero da 2*n cifre      Moltiplicazione standard             O(n^2)
Moltiplicazione   due numeri da n cifre   un numero da 2*n cifre      Algoritmo Karatsuba                  O(n^1.585) 
Moltiplicazione   due numeri da n cifre   un numero da 2*n cifre      Algoritmo 3-way Toom-Cook            O(n^1.465)
Moltiplicazione   due numeri da n cifre   un numero da 2*n cifre      Algoritmo k-way Toom-Cook            O(n^(log(2k-1))/log(k))
Moltiplicazione   due numeri da n cifre   un numero da 2*n cifre      Mixed Toom-Cook/Knuth                O(n*(2^sqrt(2*log(n)))*log(n)
Moltiplicazione   due numeri da n cifre   un numero da 2*n cifre      Algoritmo Schönhage–Strassen         O(n*log(n)*log(log(n))
Moltiplicazione   due numeri da n cifre   un numero da 2*n cifre      Algoritmo Furer                      O(n*log(n)*2^(2*log(n))))
Moltiplicazione   due numeri da n cifre   un numero da 2*n cifre      Algoritmo Harvey-Hoeven              O(n*log(n))
Divisione         due numeri da n cifre   un numero da n cifre        Divisione lunga standard             O(n^2)
Divisione         due numeri da n cifre   un numero da n cifre        Burnikel-Ziegler Divide-and-Conquer  O(M(n)*log(n))
Divisione         due numeri da n cifre   un numero da n cifre        Divisione Newton-Raphson             O(M(n)) 
Radice Quadrata   un numero da n cifre    un numero da n cifre        Metodo di Newton                     O(M(n))

dove M(n) rappresenta la complessità dell'algoritmo di moltiplicazione utilizzato.


==========================
 CODIFICA UNICODE E UTF-8
==========================

Nota che per molte lingue europee, il meccanismo "set-locale" è sufficiente per visualizzare set di caratteri non ASCII, purché ogni carattere sia presentato internamente come un byte. La codifica UTF-8 è necessaria solo per i set di caratteri multibyte come descritto in questo capitolo.

newLISP può essere compilato come un'applicazione abilitata per UTF-8. UTF-8 è una codifica multibyte del set di caratteri Unicode internazionale. Un newLISP abilitato per UTF-8 in esecuzione su un sistema operativo con UTF-8 abilitato può gestire qualsiasi carattere della locale installata.

I seguenti passaggi fanno funzionare UTF-8 con newLISP su un sistema operativo e una piattaforma specifici:

(1) Utilizzare uno dei makefile che terminano con "utf8" per compilare newLISP come applicazione UTF-8. Se nessun makefile UTF-8 è disponibile per la tua piattaforma, il normale makefile per il tuo sistema operativo contiene istruzioni su come cambiarlo per UTF-8.

Il programma di installazione binario di macOS contiene una versione abilitata per UTF-8 per impostazione predefinita.

(2) Abilita la locale UTF-8 sul tuo sistema operativo. Controlla e imposta una locale UTF-8 su Unix e sistemi operativi simili a Unix utilizzando il comando "locale" o la funzione "set-locale" all'interno di newLISP. Su Linux, le impostazioni internazionali possono essere modificate impostando la variabile di ambiente appropriata. L'esempio seguente usa bash per impostare le impostazioni internazionali degli Stati Uniti:

export LC_CTYPE=en_US.UTF-8

(3) Il newLISP abilitato per UTF-8 passa automaticamente alla locale trovata nel sistema operativo. Assicurati che la shell dei comandi sia abilitata per UTF-8. La versione statunitense di notepad.exe di WinXP può visualizzare caratteri con codifica Unicode UTF-8, ma la shell dei comandi no. Su Linux e altri Unix, la shell Xterm può essere utilizzata all'avvio come segue:

LC_CTYPE=en_US.UTF-8 xterm

La seguente procedura può ora essere utilizzata per verificare il supporto UTF-8. Dopo aver avviato newLISP, digitare:

(println (char 937)) ; visualizza il greco omega maiuscolo
(println (minuscolo (char 937))) ; visualizza omega minuscolo

Mentre l'omega maiuscolo (Ω) sembra una grande O su due piccole gambe, l'omega minuscolo (ω) ha una forma simile a una piccola w nell'alfabeto latino.

Nota: solo l'output di "println" verrà visualizzato come carattere. Il valore restituito da "println" apparirà sulla console come un carattere ASCII multi-byte.

Quando newLISP abilitato per UTF-8 viene utilizzato su un display non abilitato per UTF-8, sia l'output che il valore restituito saranno due caratteri. Questi sono i due byte necessari per codificare il carattere omega.

Funzioni che lavorano su caratteri UTF-8
----------------------------------------
Quando si utilizza newLISP abilitato per UTF-8, le seguenti funzioni di stringa funzionano su caratteri a uno o più byte anziché su limiti di byte a 8 bit:

+------------+----------------------------------------------------------+
| Funzione   | Descrizione                                              |
+------------+----------------------------------------------------------+
| char       | translates between characters and ASCII/Unicode          |
+------------+----------------------------------------------------------+
| chop       | chops characters from the end of a string                |
+------------+----------------------------------------------------------+
| date       | converts date number to string                           |
+------------+----------------------------------------------------------+
| dostring   | evaluates once for each character in a string            |
+------------+----------------------------------------------------------+
| explode    | transforms a string into a list of characters            |
+------------+----------------------------------------------------------+
| first      | gets first element in a list (car, head) or string       |
+------------+----------------------------------------------------------+
| last       | returns the last element of a list or string             |
+------------+----------------------------------------------------------+
| lower-case | converts a string to lowercase characters                |
+------------+----------------------------------------------------------+
| nth        | gets the nth element of a list or string                 |
+------------+----------------------------------------------------------+
| pop        | deletes an element from a list or string                 |
+------------+----------------------------------------------------------+
| push       | inserts a new element in a list or string                |
+------------+----------------------------------------------------------+
| rest       | gets all but the first element of a list (cdr) or string |
+------------+----------------------------------------------------------+
| select     | selects and permutes elements from a list or string      |
+------------+----------------------------------------------------------+
| title-case | converts the first character of a string to uppercase    |
+------------+----------------------------------------------------------+
| trim       | trims a string from both sides                           |
+------------+----------------------------------------------------------+
| upper-case | converts a string to uppercase characters                |
+------------+----------------------------------------------------------+

Tutte le altre funzioni stringa funzionano su byte a 8 bit. Quando le posizioni vengono restituite, come in "find" o "regex", sono singole posizioni di byte a 8 bit anziché posizioni di caratteri che possono essere multi-byte. Le funzioni "get-char" e "slice" non accettano offset di caratteri multibyte, ma offset a byte singolo, anche nelle versioni abilitate per UTF-8 di newLISP. La funzione "reverse" inverte un vettore di byte, non un vettore di caratteri. Le ultime tre funzioni possono ancora essere utilizzate per manipolare dati binari non testuali nella versione abilitata per UTF-8 di newLISP. Per far funzionare "slice" e "reverse" con le stringhe UTF-8, combinale con "explode" e "join".

Per abilitare UTF-8 in Perl Compatible Regular Expressions (PCRE) — usato da "directory", "find", "member", "parse", "regex", "regex-comp" e "replace" — impostare il numero dell'opzione di conseguenza (2048). Si noti che l'offset e le lunghezze nei risultati delle espressioni regolari sono sempre in conteggi di singoli byte. Per i dettagli, vedere la documentazione di "regex".

Usa "explode" per ottenere una matrice di caratteri UTF-8 e per manipolare i caratteri anziché i byte quando una funzione abilitata per UTF-8 non è disponibile:

(join (reverse (explode str))) ; inverte i caratteri UTF-8

Le funzioni stringa di cui sopra (spesso utilizzate per manipolare dati binari non testuali) ora funzionano sui limiti di caratteri, piuttosto che di byte, quindi è necessario prestare attenzione quando si utilizza la versione abilitata per UTF-8. La dimensione dei primi 127 caratteri ASCII, insieme ai caratteri nelle code page popolari come ISO 8859, è lunga un byte. Quando si lavora esclusivamente all'interno di queste tabelle codici, newLISP abilitato per UTF-8 non è richiesto. La sola funzione "set-locale" è sufficiente per il comportamento localizzato.

Funzioni disponibili solo su versioni abilitate per UTF-8
---------------------------------------------------------
+----------+----------------------------------------------------+
| Funzione | Descrizione                                        |
+----------+----------------------------------------------------+
| unicode  | converts UTF-8 or ASCII strings into USC-4 Unicode |
+----------+----------------------------------------------------+
| utf8     | converts UCS-4 Unicode strings to UTF-8            |
+----------+----------------------------------------------------+
| utf8len  | returns the number of UTF-8 characters in a string |
+----------+----------------------------------------------------+

Le prime due funzioni vengono utilizzate raramente in pratica, poiché la maggior parte dei file di testo Unicode è già codificata in UTF-8 (anziché UCS-4, che utilizza caratteri interi a quattro byte). Unicode può essere visualizzato direttamente quando si utilizza l'identificatore di formato "%ls".

Per ulteriori dettagli su UTF-8 e Unicode, consultare le domande frequenti su UTF-8 e Unicode per Unix/Linux di Markus Kuhn disponibili al seguente indirizzo web: https://www.cl.cam.ac.uk/~mgk25/unicode.html

=============================================================================

================

 FUNZIONI VARIE

================

In questo capitolo definiremo alcune funzioni che operano sulle liste e altre funzioni di carattere generale. Alcune di queste ci serviranno successivamente per risolvere i problemi che andremo ad affrontare.
Poichè newLISP permette sia lo stile funzionale che quello imperativo, le funzioni sono implementate in modo personale e possono essere sicuramente migliorate.

-------------
Tabella ASCII
-------------

ASCII (acronimo di American Standard Code for Information Interchange, Codice Standard Americano per lo Scambio di Informazioni) è un codice per la codifica di caratteri. Lo standard ASCII è stato pubblicato dall'American National Standards Institute (ANSI) nel 1968. Il codice era composto originariamente da 7 bit (2^7 = 128 caratteri).
I caratteri del codice ASCII sono di due tipi: stampabili e non stampabili (caratteri di controllo).
I caratteri stampabili sono 95 (da 32 a 126), mentre quelli non stampabili sono 33 (da 0 a 31 e il 127). Quindi il totale dei caratteri vale 95 + 33 = 128.
Scriviamo una funzione che crea una lista dei caratteri ASCII stampabili.

(define (asciiTable)
  (let (out '())
    (for (i 32 1024)
      (push (list i (char i)) out -1)
    )
    out
  )
)

(asciiTable)
;-> ((32 " ")  (33 "!")  (34 "\"") (35 "#")  (36 "$")  (37 "%")  (38 "&")
;->  (39 "'")  (40 "(")  (41 ")")  (42 "*")  (43 "+")  (44 ",")  (45 "-")
;->  (46 ".")  (47 "/")  (48 "0")  (49 "1")  (50 "2")  (51 "3")  (52 "4")
;->  (53 "5")  (54 "6")  (55 "7")  (56 "8")  (57 "9")  (58 ":")  (59 ";")
;->  (60 "<")  (61 "=")  (62 ">")  (63 "?")  (64 "@")  (65 "A")  (66 "B")
;->  (67 "C")  (68 "D")  (69 "E")  (70 "F")  (71 "G")  (72 "H")  (73 "I")
;->  (74 "J")  (75 "K")  (76 "L")  (77 "M")  (78 "N")  (79 "O")  (80 "P")
;->  (81 "Q")  (82 "R")  (83 "S")  (84 "T")  (85 "U")  (86 "V")  (87 "W")
;->  (88 "X")  (89 "Y")  (90 "Z")  (91 "[")  (92 "\\") (93 "]")  (94 "^")
;->  (95 "_")  (96 "`")  (97 "a")  (98 "b")  (99 "c")  (100 "d") (101 "e")
;->  (102 "f") (103 "g") (104 "h") (105 "i") (106 "j") (107 "k") (108 "l")
;->  (109 "m") (110 "n") (111 "o") (112 "p") (113 "q") (114 "r") (115 "s")
;->  (116 "t") (117 "u") (118 "v") (119 "w") (120 "x") (121 "y") (122 "z")
;->  (123 "{") (124 "|") (125 "}") (126 "~"))

In newLISP i caratteri numero 34 (doppi apici) e numero 92 (backslash) sono preceduti dal carattere di controllo '\' quando vengono stampati.

Altro metodo, applico (con "map") la funzione (list x (char(x))) ad ogni elemento della lista di numeri che va da 32 a 126 (sequence 32 126):

(define (ascii-list)
  (map (fn(x) (list x (char x))) (sequence 32 126)))

Altro metodo che mostra i valori Decimale, Ottale, Esadecimale e il carattere:

(define (ascii-info)
; ascii chart output from #32 - #126
  (println "Dec Oct Hex Chr") 
  (map (fn(x) (println (format "%-3d %-3o %-3x %s" x x x (char x))))
      (sequence 32 126))
  '-------------)

(ascii-info)
;-> Dec Oct Hex Chr
;-> 32  40  20
;-> 33  41  21  !
;-> 34  42  22  "
;-> 35  43  23  #
;-> 36  44  24  $
;-> 37  45  25  %
;-> 38  46  26  &
;-> 39  47  27  '
;-> 40  50  28  (
;-> 41  51  29  )
;-> 42  52  2a  *
;-> 43  53  2b  +
;-> 44  54  2c  ,
;-> 45  55  2d  -
;-> 46  56  2e  .
;-> 47  57  2f  /
;-> 48  60  30  0
;-> 49  61  31  1
;-> 50  62  32  2
;-> 51  63  33  3
;-> 52  64  34  4
;-> 53  65  35  5
;-> 54  66  36  6
;-> 55  67  37  7
;-> 56  70  38  8
;-> 57  71  39  9
;-> 58  72  3a  :
;-> 59  73  3b  ;
;-> 60  74  3c  <
;-> 61  75  3d  =
;-> 62  76  3e  >
;-> 63  77  3f  ?
;-> 64  100 40  @
;-> 65  101 41  A
;-> 66  102 42  B
;-> 67  103 43  C
;-> 68  104 44  D
;-> 69  105 45  E
;-> 70  106 46  F
;-> 71  107 47  G
;-> 72  110 48  H
;-> 73  111 49  I
;-> 74  112 4a  J
;-> 75  113 4b  K
;-> 76  114 4c  L
;-> 77  115 4d  M
;-> 78  116 4e  N
;-> 79  117 4f  O
;-> 80  120 50  P
;-> 81  121 51  Q
;-> 82  122 52  R
;-> 83  123 53  S
;-> 84  124 54  T
;-> 85  125 55  U
;-> 86  126 56  V
;-> 87  127 57  W
;-> 88  130 58  X
;-> 89  131 59  Y
;-> 90  132 5a  Z
;-> 91  133 5b  [
;-> 92  134 5c  \
;-> 93  135 5d  ]
;-> 94  136 5e  ^
;-> 95  137 5f  _
;-> 96  140 60  `
;-> 97  141 61  a
;-> 98  142 62  b
;-> 99  143 63  c
;-> 100 144 64  d
;-> 101 145 65  e
;-> 102 146 66  f
;-> 103 147 67  g
;-> 104 150 68  h
;-> 105 151 69  i
;-> 106 152 6a  j
;-> 107 153 6b  k
;-> 108 154 6c  l
;-> 109 155 6d  m
;-> 110 156 6e  n
;-> 111 157 6f  o
;-> 112 160 70  p
;-> 113 161 71  q
;-> 114 162 72  r
;-> 115 163 73  s
;-> 116 164 74  t
;-> 117 165 75  u
;-> 118 166 76  v
;-> 119 167 77  w
;-> 120 170 78  x
;-> 121 171 79  y
;-> 122 172 7a  z
;-> 123 173 7b  {
;-> 124 174 7c  |
;-> 125 175 7d  }
;-> 126 176 7e  ~
;-> -------------


--------------
Pari o dispari
--------------

Definiamo le funzioni "pari" e "dispari":

(define (pari n) (if (= n 0) true (dispari (- n 1))))

(define (dispari n) (if (= n 0) nil (pari (- n 1))))

(pari 5)
;-> nil
(pari 0)
;-> true
(dispari 0)
;-> nil
(dispari 5)
;-> true

Altro metodo (più veloce) per definire le funzioni "pari " e "dispari":

(define (pari n) (if (= (% n 2) 0) true nil))

(define (dispari n) (if (= (% n 2) 0) nil true))


-----
Crono
-----

Definiamo una funzione che prende un numero n come argomento e costruisce una lista con tutti i numeri da n fino a 1 in ordine decrescente:

(define (crono n)
  (if (<= n 0)
      '()
      (cons n (crono (- n 1)))
  )
)

; Nota: '() rappresenta la lista vuota

(crono 10)
;-> (10 9 8 7 6 5 4 3 2 1)


------------------------------
Cambiare di segno ad un numero
------------------------------

Primo metodo (sottrazione)
(setq n -1.24)
;-> -1.24
(setq n (sub 0 n))
;-> 1.24
(setq n (sub 0 n))
;-> -1.24

Secondo metodo (moltiplicazione)
(setq n -1.24)
;-> -1.24
(setq n (mul -1 n))
;-> 12.4
(setq n (mul -1 n))
;-> -1.24

Vediamo quale metodo è più veloce:

(map (lambda (x) (sub 0 x))  (sequence 1 10))
;-> (-1 -2 -3 -4 -5 -6 -7 -8 -9 -10)

(map (lambda (x) (mul -1 x)) (sequence 1 10))
;-> (map (lambda (x) (mul -1 x)) (sequence 1 10))

Test primo metodo:
(time (map (lambda (x) (sub 0 x))  (sequence 1 1000000)) 10)
;-> 906.196

Test secondo metodo:
(time (map (lambda (x) (mul -1 x)) (sequence 1 1000000)) 10)
;-> 906.343

I due metodi hanno la stessa velocità.

Terzo metodo (bitwise not "~") (valido solo per numeri interi)
(setq n -10)
;-> -10
(setq n (add (~ n) 1))
;-> 10
(setq n (add (~ n) 1))
;-> -10

Test terzo metodo:
(time (map (lambda (x) (add (~ n) 1)) (sequence 1 1000000)) 10)
;-> 1207.781

Questo metodo è più lento.

Quarto metodo (segno meno "-")
(setq n -10)
;-> 10
(setq n (- n))
;-> 10
(setq n (- n))
;-> -10

Test quarto metodo:
(time (map (lambda (x) (- n)) (sequence 1 1000000)) 10)
;-> 914.067

Stessa velocità dei primi due metodi, ma quest'ultimo è più leggibile.


----------------------------------
Moltiplicazione solo con addizioni
----------------------------------

Moltiplicare due numeri naturali (interi positivi)

(define (moltiplica n m)
  (local (p)
    (setq p 0)
    (while (> n 0)
      (setq p (+ p m))
      (-- n)
    )
    p
  )
)

(moltiplica 1 12)
;-> 12

(moltiplica 20 30)
;-> 600


------------------------------
Divisione solo con sottrazioni
------------------------------

Dividere due numeri naturali (interi positivi)

(define (dividi n m)
  (local (q r)
    (setq r n)
    (setq q 0)
    (while (>= r m)
      (++ q)
      (setq r (- r m))
    )
    (list q r)
  )
)

(dividi 10 3)
;-> (3 1)

(dividi 121 11)
;-> (11 0)


----------------------
Distanza tra due punti
----------------------

P1 = (x1, y1)
P2 = (x2, y2)

Distanza al quadrato (piano cartesiano):

(define (dist2 x1 y1 x2 y2)
  (add (mul (sub x1 x2) (sub x1 x2))
       (mul (sub y1 y2) (sub y1 y2)))
)

Distanza (piano cartesiano):

(define (dist x1 y1 x2 y2)
  (sqrt (add (mul (sub x1 x2) (sub x1 x2))
             (mul (sub y1 y2) (sub y1 y2))))
)

Distanza griglia manhattan (4 movimenti - esempio: torre):

(define (distM4 x1 y1 x2 y2)
  (add (abs (sub x1 x2)) (abs (sub y1 y2)))
)

Distanza griglia manhattan (8 movimenti - esempio: regina):

(define (distM8 x1 y1 x2 y2)
  (max (abs (sub x1 x2)) (abs (sub y1 y2)))
)

(dist 1 2 5 5)
;-> 5
(distM4 1 2 5 5)
;-> 7
(distM8 1 2 5 5)
;-> 4


---------------------------------
Conversione decimale <--> binario
---------------------------------

Questa funzione converte un numero decimale in un numero binario (lista):

(define (decimale2binario n)
  (reverse (d2b n)))

(define (d2b n)
  (if (zero? n) '(0)
      (cons (% n 2) (d2b (/ n 2)))
  )
)

(decimale2binario 1133)
;-> (1 0 0 0 1 1 0 1 1 0 1)

(decimale2binario 1233)
;-> (1 0 0 1 1 0 1 0 0 0 1)

(decimale2binario 2)
;-> (1 0)

(decimale2binario 0)
;-> (0)

Questa funzione converte un numero binario (lista) in un numero decimale:

(define (binario2decimale n)
  (b2d (reverse n)))

(define (b2d n)
    (if (null? n) 0
        (+ (first n) (* 2 (b2d (rest n))))
    )
)

(binario2decimale '(1 0 0 0 1 0 1 1 0 0 1))
;-> 1133

(binario2decimale '(1 0 0 1 1 0 1 0 0 0 1))
;-> 1233

(binario2decimale '(0))
;-> 0

Queste funzione converte un numero binario in un numero intero:

(define (bin2dec n)
  (if (zero? n) n
      (+ (% n 10) (* 2 (bin2dec (/ n 10))))))

(bin2dec 10001011001)
;-> 1113

(bin2dec 10011010001)
;-> 1233

(bin2dec 0)
;-> 0

Queste funzione converte un numero intero in un numero binario:

(define (dec2bin n)
   (if (zero? n) n
       (+ (% n 2) (* 10 (dec2bin(/ n 2))))
   )
)

(dec2bin 1133)
;-> 10001101101

(dec2bin 1233)
;-> 10011010001

(dec2bin 0)
;-> 0

(bin2dec (dec2bin 1133))
;-> 1133

(dec2bin (bin2dec 10011010001))
;-> 10011010001

Possiamo scrivere una funzione generale che converte un numero da una base (b1) ad un'altra base (b2):

(define (b1-b2 n b1 b2)
  (if (zero? n) n
      (+ (% n b2) (* b1 (b1-b2 (/ n b2) b1 b2)))))

(b1-b2 1133 10 2)
;-> 10001101101

(b1-b2 10001101101 2 10)
;-> 1133

Anche le funzioni predefinite "int" e "bits" di newLISP servono per convertire numeri da una base all'altra.

Vediamo alcuni esempi:

Converte una stringa esadecimale in decimale (il parametro 0 è il valore predefinito che viene restituito quando la conversione genera un errore):

(int "0xdecaff" 0 16)
;-> 14600959

Converte una stringa binaria nel numero decimale corrispondente:

(int "10101010" 0 2)
;-> 170

Converte un numero in una stringa o in una lista (1 -> true, 0 -> nil) che contiene il numero binario corrispondente:

(bits 170)
;-> "10101010"

(bits 170 true)
;-> (nil true nil true nil true nil true)

(int (bits 1234) 0 2)
;-> 1234


-------------------------------------
Conversione decimale <--> esadecimale
-------------------------------------

Questa funzione converte un numero intero positivo in una stringa esadecimale:

(define (d2h n)
  (local (digit x y)
    (setq digit "0123456789ABCDEF")
    (setq x (% n 16))
    (setq y (/ n 16))
    (if (= y 0) (nth x digit)
        (cons (nth x digit) (d2h y))
    )
  )
)

(define (dec2hex n)
  (if (= n 0) "0"
      (join (reverse(d2h n)))
  )
)

(dec2hex 16)
;-> "10"
(dec2hex 0)
;-> "0"
(dec2hex 100001)
;-> "186A1"

Questa funzione converte una stringa esadecimale in un numero intero positivo:

(define (hex2dec s)
  (local (digit val)
    (setq digit "0123456789ABCDEF")
    (setq val 0L)
    (dostring (c s)
      (setq val (+ (* val 16) (find (char c) digit)))
      ; la seguente istruzione converte la variabile val in un numero intero,
      ; quindi genera un risultato sbagliato quando superiamo il limite.
      ; Ponendo val prima del numero 16 forza newLISP a considerare big integer
      ; il risultato dell'operazione di moltiplicazione.
      ;(setq val (+ (* 16 val) (find (char c) digit)))
      ; Comunque usando 16L al posto di 16 tutto funziona:
      ;(setq val (+ (* 16L val) (find (char c) digit)))
    )
  )
)

(hex2dec "0")
;-> 0L

(hex2dec "FF")
;-> 255L

(hex2dec "0123456789ABCDEF")
;-> 81985529216486895L


(hex2dec "FFFFFFFFFFFFFFFFFFFF")
;-> 1208925819614629174706175L

Nota:
Se il numero esadecimale non è intero per trasformarlo in numero decimale bisogna:
- convertire la parte intera scrivendo la somma dei prodotti delle cifre del numero, per le potenze decrescenti del 16.
- convertire la parte frazionaria scrivendo la somma dei prodotti delle cifre del numero, per le potenze crescenti negative del 16.


-------------------------------
Conversione decimale --> romano
-------------------------------

; roman.lsp
; Sam Cox December 8, 2003
;
; LM 2003/12/12: took out type checking of n
;
;
; This function constructs a roman numeral representation from its positive
; integer argument, N.  For example,
;
;     (roman 1988) --> MCMLXXXVIII
;
; The Roman method of writing numbers uses two kinds of symbols: the basic
; symbols are I=1, X=10, C=100 and M=1000; the auxiliary symbols are V=5,
; L=50 and D=500. A rule prescribes that the symbol for the larger number
; always stands to the left of that for the smaller number. An exception
; is motivated by the desire to use as few symbols as possible. For
; example, the number nine can be represented as VIIII (5+4) or IX (10-1);
; the latter is preferred.  Therefore, if the symbol of a smaller number
; stands at the left, the corresponding number has to be subtracted, not
; added.  It is not permitted to place several basic symbols or an
; auxiliary symbol in front.  For example, use CML for 950 instead of LM.
; ---
; The VNR Encyclopedia of Mathematics, W. Gellert, H. Kustner, M. Hellwich,
; and H. Kastner, eds., Van Nostrand Reinhold Company, New York, 1975.

(define (roman n)
        (roman-aux "" n (first *ROMAN*) (rest *ROMAN*)))

(define (roman-aux result n pair remaining)
    (roman-aux-2 result n (first pair) (second pair) remaining))

(define (roman-aux-2 result n val rep remaining)
    (if
        (= n 0)
            result
        (< n val)
            (roman-aux result n (first remaining) (rest remaining))
        ;else
            (roman-aux-2 (append result rep) (- n val) val rep remaining)))

(define (second x) (nth 1 x))

(setq *ROMAN*
         '(( 1000  "M" )
           (  999 "IM" )
           (  990 "XM" )
           (  900 "CM" )
           (  500  "D" )
           (  499 "ID" )
           (  490 "XD" )
           (  400 "CD" )
           (  100  "C" )
           (   99 "IC" )
           (   90 "XC" )
           (   50  "L" )
           (   49 "IL" )
           (   40 "XL" )
           (   10  "X" )
           (    9 "IX" )
           (    5  "V" )
           (    4 "IV" )
           (    1  "I" )))

In versione ricorsiva:

(define (->roman n)
    (let (roman-a '((1000 "M") (100  "C") (99 "IC") (90 "XC") (50  "L") (49 "IL")
                    (40 "XL")  (10  "X") (9 "IX") (5  "V") (4 "IV") (1  "I")))
      (define (roman-aux result n pair remaining)
          (roman-aux-2 result n (pair 0) (pair 1) remaining))
      (define (roman-aux-2 result n val rep remaining)
          (if (= n 0)  result
              (< n val) (roman-aux result n (remaining 0) (1 remaining))
              (roman-aux-2 (append result rep) (- n val) val rep remaining)))
      (roman-aux "" n (roman-a 0) (1 roman-a))))

(->roman 1234)
;-> "MCCXXXIV"


------------------------------------
Conversione numero intero <--> lista
------------------------------------

Vediamo due funzioni per convertire da numero intero a lista:

(define (int2list n)
  (let (out '())
    (while (!= n 0)
      (push (% n 10) out)
      (setq n (/ n 10))
    )
    out
  )
)

(int2list 1234567890)
;-> (1 2 3 4 5 6 7 8 9 0)

(define (int2list2 n)
  (map int (explode (string n))))

(int2list2 1234567890)
;-> (1 2 3 4 5 6 7 8 9 0)

Vediamo quale delle due è più veloce:

(time (int2list 9223372036854775807) 100000)
;-> 332.671

(time (int2list2 9223372036854775807) 100000)
;-> 442.561

Vediamo tre funzioni per convertire da lista a numero intero:

(define (list2int lst)
  (let (n 0)
    (for (i 0 (- (length lst) 1))
      (setq n (+ n (* (lst i) (pow 10 (- (length lst) i 1)))))
    )
  )
)

(list2int '(1 2 3 4 5 6 7 8 9 0))
;-> 1234567890

(define (list2int2 lst)
  (int (join (map string lst))))

(list2int2 '(1 2 3 4 5 6 7 8 9 0))
;-> 1234567890

(define (list2int3 lst)
  (let (n 0)
    (dolist (el lst) (setq n (+ el (* n 10))))))

(list2int3 '(1 2 3 4 5 6 7 8 9 0))
;-> 1234567890

Vediamo quale delle tre è più veloce:

(time (list2int '(9 2 2 3 3 7 2 0 3 6 8 5 4 7 7 5 8 0 7)) 100000)
;-> 622.365

(time (list2int2 '(9 2 2 3 3 7 2 0 3 6 8 5 4 7 7 5 8 0 7)) 100000)
;-> 855.138

(time (list2int3 '(9 2 2 3 3 7 2 0 3 6 8 5 4 7 7 5 8 0 7)) 100000)
;-> 234.349

Ricapitoliamo:

(define (int2list n)
  (let (out '())
    (while (!= n 0)
      (push (% n 10) out)
      (setq n (/ n 10))) out))

(int2list 1282738374847)
;-> (1 2 8 2 7 3 8 3 7 4 8 4 7)

(define (int2list2 n) (map sym (explode (string n))))

(int2list2 1282738374847)
;-> (1 2 8 2 7 3 8 3 7 4 8 4 7)

(time (dotimes (x 1e6) (int2list x)))
;-> 1143.595
(time (dotimes (x 1e6) (int2list2 x)))
;-> 1866.541

(time (dotimes (x 1e7) (int2list x)))
;-> 12979.094
(time (dotimes (x 1e7) (int2list2 x)))
;-> 17760.076


-------------------------------
Numeri casuali in un intervallo
-------------------------------

Generare un numero casuale n tale che: a <= n <= b

(define (rand-range a b)
  (if (> a b) (swap a b))
  (+ a (rand (+ (- b a) 1)))
)

(rand-range 1 10)
;-> 1

Facciamo un test sulla distribuzione dei risultati:

(define (test n a b)
  (local (vec r)
    (setq vec (array 10 '(0)))
    (for (i 0 n)
      (setq r (rand-range a b))
      (++ (vec r))
    )
    vec
  )
)

(test 100000 1 5)
;-> (0 19828 20179 20076 20263 19655 0 0 0 0)

(test 100000 0 9)
;-> (9855 9809 9951 10199 9978 10006 9934 10110 10058 10101)


-------------------
Calcolo proporzione
-------------------

Calcolare il valore ignoto (che viene rappresentato con il numero zero) di una proporzione: A/B = C/D

(define (proporzione a b c d)
        ; nessuno zero: controllo proporzione
  (cond ((= '(0) (count '(0) (list a b c d)))
         (= (div a b) (div c d)))
        ; numero zeri maggiore di 1: nil
        ((!= '(1) (count '(0) (list a b c d))) nil)
        ; numero zeri uguale a 1: calcolo proporzione...
        ((= a 0) (div (mul b c) d))
        ((= b 0) (div (mul a d) c))
        ((= c 0) (div (mul a d) b))
        ((= d 0) (div (mul b c) a))
  )
)

(proporzione 4 2 10 0)
;-> 5
(proporzione 0 2 10 5)
;-> 4
(proporzione 4 2 0 5)
;-> 10
(proporzione 4 0 10 5)
;-> 2
(proporzione 4 3 0 0)
;-> nil
(proporzione 10 5 4 3)
;-> nil
(proporzione 10 5 4 2)
;-> true


----------------------------------------
Estrarre l'elemento n-esimo da una lista
----------------------------------------

; ======================================
; (n-esimo n lst)
; Estrae l'elemento n-esimo da una lista
; ======================================

(define (n-esimo n lst)
  (if (= lst '()) '()
    (if (= n 0)
        (first lst)
        (n-esimo (- n 1) (rest lst))
    )
  )
)

(n-esimo 1 '(1 (2 3) 4))
;-> (2 3)

(n-esimo 0 '(1 (2 3) 4))
;-> 1

(n-esimo 5 '(1 (2 3) 4))
;-> ()


------------------------------------
Verificare se una lista è palindroma
------------------------------------

; ======================================
; (palindroma? lst)
; Controlla se la lista lst è palindroma
; ======================================
(define (palindroma? lst)
  (= lst (reverse (copy lst))))

Nota: senza la funzione "copy", la condizione (= lst (reverse lst)) è sempre vera (perchè (reverse lst) è una funzione distruttiva.

(palindroma? '(n e w L I S P))
;-> nil

(palindroma? '(e p r e s a l a s e r p e))
;-> true


--------------------------------------
Verificare se una stringa è palindroma
--------------------------------------

(define (palindroma? str)
  (= str (reverse (copy str))))

(palindroma? "ababa")
;-> true

Vediamo una soluzione con gli indici:

(define (palindroma? str)
  (catch
    (local (start end)
      (setq start 0)
      (setq end (- (length str) 1))
        (while (< start end)
          (if (!= (str start) (str end)) (throw nil))
          (++ start)
          (-- end)
        )
      true
    );local
  );catch
)

(palindroma? "epresalaserpe")
;-> true

(palindroma? "abbai")
;-> nil


------------------------------------
Verificare se un numero è palindromo
------------------------------------

(define (palindromo? num)
  (let (str (string num))
    (= str (reverse (copy str)))))

(palindromo? 1234321)
;-> true

(define (palinum? num)
  (let ((val 0) (copia num))
    (until (null? num)
      (setq val (+ (* 10 val) (% num 10)))
      (setq num (/ num 10))
    )
    (= val copia)
  )
)

(palinum? 1234321)
;-> true

(time (map palindromo? (sequence 100000 110000)) 200)
;-> 1535.427

(time (map palinum? (sequence 100000 110000)) 200)
;-> 2778.158


---------------
Zippare N liste
---------------

La funzione "zip" prende due liste e raggruppa in coppie gli elementi delle due liste che hanno lo stesso indice.
Il risultato è una lista costituita da sottoliste con due elementi ciascuna.La lunghezza della lista è uguale a quella della lista più corta (cioè, la funzione deve fermarsi quando termina una delle due liste).

; zippa due liste
(define (zip l1 l2)
  (if (or (null? l1) (null? l2))
      '()
      (cons (list (first l1) (first l2))
            (zip (rest l1) (rest l2)))))

Se una delle due liste è vuota, allora ritorna la lista vuota. Altrimenti, formiamo una lista dei primi elementi di ciascuna lista e la associamo alla versione zippata delle parti rimanenti di ciascuna lista. Il risultato è la nostra lista formata da sottoliste di due elementi.

(zip '(1 2 3) '(a b c))
;-> ((1 a) (2 b) (3 c))

(zip '(1 2 3) '(a))
;-> ((1 a))

(zip '(1) '(a b c))
;-> ((1 a))

(zip '(1 3 5) '(2 4 6))
;-> ((1 2) (3 4) (5 6))

Possiamo scrivere la funzione "zip" utilizzando "map" e "apply":

; zip due liste
(define (zip l1 l2) (map list l1 l2))

(zip '(1 2 3) '(a b c))
;-> ((1 a) (2 b) (3 c))

(zip '(1 2 3) '(a))
;-> ((1 a) (2) (3))

(zip '(1) '(a b c))
;-> ((1 a))

Questa ultima funzione può essere facilmente estesa per trattare N liste:

; zippa N liste
(define (zip lst)
  (apply map (cons list lst)))

(zip '((1 a x) (2 b y)))
;-> ((1 2) (a b) (x y))

(zip '((1 2) (a b) (x y)))
;-> (1 a x) (2 b y))

Calcoliamo il tempo di esecuzione:

(time (zip '((1 a x) (2 b y))) 100000)
;-> 78.116 msec

La funzione "zip" è uguale alla funzione che traspone una matrice (scambia le righe con le colonne). Poichè newLISP fornisce la funzione "transpose" possiamo scrivere:

(transpose '((1 2 3) (a b c)))
;-> ((1 a) (2 b) (3 c))

Quindi la funzione che zippa N liste diventa:

; =============================================
; (zip lst)
; Zippa (traspone) una lista di liste (matrice)
; =============================================
; zippa N liste
(define (zip lst)
  (transpose lst))

(zip '((1 a x) (2 b y)))
;-> ((1 2) (a b) (x y))

Calcoliamo il tempo di esecuzione e notiamo che è più veloce della funzione iniziale:

(time (zip '((1 a x) (2 b y))) 100000)
;-> 31.87 msec


--------------------------------------------------------------
Sostituire gli elementi di una lista con un determinato valore
--------------------------------------------------------------

Si tratta di sostituire tutti gli elementi di una lista con un determinato valore con un altro valore.

La funzione è la seguente:

(define (sostituisci x y lst)
    (if (null? lst) '()
      (if (= x (first lst))
        (cons y (sostituisci x y (rest lst)))
        (cons (first lst) (sostituisci x y (rest lst)))
      )
    )
)

(sostituisci 'd 'K '(a b c d 1 2 3 d))
;-> (a b c K 1 2 3 K)

Per rimpiazzare tutti gli elementi di una lista che hanno un determinato valore possiamo utilizzare la funzione built-in "replace":

(setq lst '(a b c d 1 2 3 d))
(replace 'd lst 'K)
;-> (a b c K 1 2 3 K)

(setq lst '((a b) (c d) (1 2 (3 d))))
(replace '(c d) lst 'K)
;-> ((a b) K (1 2 (3 d)))

Purtroppo "replace" non funziona quando vogliamo modificare un atomo che si trova all'interno di una lista nidificata:

(setq lst '((a b) (c d) (1 2 (3 d))))
(replace 'd lst 'K)
;-> ((a b) (c d) (1 2 (3 d)))

In questo caso dobbiamo utilizzare la funzione "set-ref-all":

(setq lst '((a b) (c d) (1 2 (3 d))))
(set-ref-all 'd lst 'K)
;-> ((a b) K (1 2 (3 K)))


-------------------------------------
Raggruppare gli elementi di una lista
-------------------------------------

La funzione "raggruppa" utilizza la ricorsione, prima raggruppiamo la prima parte della lista (presa con la funzione "take"), poi richiamiamo la stessa funzione "raggruppa" sulla lista rimanente (presa con la funzione "drop").

La funzione "take" restituisce i primi n elementi di una lista:

(define (take n lst) (slice lst 0 n))

La funzione "drop" restituisce tutti gli elementi di una lista tranne i primi n (cioè vengono esclusi dalla lista risultante i primi n elementi della lista passata:

(define (drop n lst) (slice lst n))

Adesso possiamo scrivere la funzione "raggruppa":

(define (raggruppa n lst)
   (if (null? lst) '()
      (cons (take n lst) (raggruppa n (drop n lst)))
   )
)

(setq lst '(0 1 2 3 4 5 6 7 8 9))
(raggruppa 2 lst)
;-> ((0 1) (2 3) (4 5) (6 7) (8 9))
(raggruppa 3 lst)
;-> ((0 1 2) (3 4 5) (6 7 8) (9))

(setq lst '(1 2 3 4 5 6 7 8 9 10 11 12))
(raggruppa 2 (raggruppa 2 lst))
;-> (((1 2) (3 4)) ((5 6) (7 8)) ((9 10) (11 12)))

Con newLISP possiamo utilizzare anche la funzione "explode".


-----------------------------------
Enumerare gli elementi di una lista
-----------------------------------

; =====================================================
; (emumera lst)
; Crea una nuova lista numerando gli elementi di lst
; =====================================================
(define (enumera lst)
  (local (out)
    (cond ((null? lst) '())
          (true (setq out '())
                (dolist (el lst)
                  ;(push (list $idx el) _out)
                  ;(push (list $idx el) _out -1)
                  (extend out (list(list $idx el)))
                )
                ;(reverse _out)
          )
    )
  )
)

(enumera '(a b c))
;-> ((0 a) (1 b) (2 c))

(enumera '((a b) (c d) e))
;-> ((0 (a b)) (1 (c d)) (2 e))

Oppure:

(define (enumera lst)
  (map list (sequence 0 (sub (length lst) 1)) lst))

(enumera '(a b c))
;-> ((0 a) (1 b) (2 c))

(enumera '((a b) (c d) e))
;-> ((0 (a b)) (1 (c d)) (2 e))

Oppure:

(map (fn (x) (list $idx x)) '((a b) (c d) e))
;-> ((0 (a b)) (1 (c d)) (2 e))


-----------------------------------------------------------
Creare una stringa come ripetizione di un carattere/stringa
-----------------------------------------------------------

newLISP possiede la funzione "dup" che funzione anche con i simboli:

(dup "A" 6)       → "AAAAAA"
(dup "A" 6 true)  → ("A" "A" "A" "A" "A" "A")
(dup "A" 0)       → ""
(dup "AB" 5)      → "ABABABABAB"
(dup 9 7)         → (9 9 9 9 9 9 9)
(dup 9 0)         → ()
(dup 'x 8)        → (x x x x x x x x)
(dup '(1 2) 3)    → ((1 2) (1 2) (1 2))
(dup "\000" 4)    → "\000\000\000\000"
(dup "*")         → "**"

Proviamo a scrivere la nostra funzione:

; =====================================================
; (duplica str num)
; Duplica la stringa str per num volte
; =====================================================

(define (duplica str num , newstr)
  (local (newstr)
    (setq newstr "")
    (dotimes (x num)
      (extend newstr str)
    )
   )
)

(duplica "prova" 4)
;-> "provaprovaprovaprova"


--------------------------------------------------
Massimo annidamento di una lista ("s-espressione")
--------------------------------------------------

La seguente funzione calcola il livello massimo di annidamento di una lista:

(define (annidamento lst)
  (cond ((null? lst) 0)
        ((atom? lst) 0)
        (true (max (+ 1 (annidamento (first lst)))
                   (annidamento (rest lst))))
  )
)

Il trucco sta nell'utilizzare la funzione "max" per scoprire quale ramo della ricorsione è il più profondo, notando che ogni volta che ricorraimo su first aggiungiamo un altro livello.

(annidamento '())
;-> 0
(annidamento '(a b))
;-> 1
(annidamento '((a)))
;-> 2
(annidamento '(a (b) ((c)) d e f))
;-> 3
(annidamento '(a (((b c d))) (e) ((f)) g))
;-> 4
(annidamento '(a (((b c (d)))) (e) ((f)) g))
;-> 5

rickyboy:

(define (nesting lst)
  (if (null? lst) 0
      (atom? lst) 0
      (+ 1 (apply max (map nesting lst)))))

fdb:

(define (nesting lst prev (t 0))
   (if (= lst prev)
      t
     (nesting (flat lst 1) lst (inc t))))

(nesting '(a (((b c (d)))) (e) ((f)) g))
;-> 5


-------------------------------
Run Length Encode di una lista
-------------------------------

Esempio: (rle '(a a a b b c c a d d))
;-> ((3 a) (2 b) (2 c) (1 a) (2 d))

Implementiamo il metodo di compressione Run Length Encoding ad una lista. Gli elementi consecutivi duplicati sono codificati come liste (N E) dove N è il numero di duplicati dell'elemento E.

; =====================================================
; (rle-encode lst)
; Codifica una lista con il metodo Run Length Encoding
; =====================================================
(define (rle-encode lst)
  (local (palo conta out)
    (cond ((= lst '()) '())
          (true
           (setq out '())
           (setq palo (first lst))
           (setq conta 0)
           (dolist (el lst)
              ; se l'elemento è uguale al precedente aumentiamo il suo conteggio
              (if (= el palo) (++ conta)
                  ; altrimenti costruiamo la coppia (conta el) e la aggiungiamo al risultato
                  (begin (push (list conta palo) out -1)
                         (setq conta 1)
                         (setq palo el)
                  )
              )
           )
           (push (list conta palo) out -1)
          )
    )
    out
  )
)

(rle-encode '(a a a a b c c a a d e e e e f))
;-> ((4 a) (1 b) (2 c) (2 a) (1 d) (4 e) (1 f))


------------------------------
Run Length Decode di una lista
------------------------------

Esempio: (rle-decode '((3 a) (2 b) (2 c) (1 a) (2 d)))
;-> (a a a b b c c a d d))

; =====================================================
; (rle-decode lst)
; Decodifica una lista compressa con il metodo Run Length Encoding
; =====================================================
(define (rle-decode lst)
  (local (out)
    (cond ((= lst '()) '())
          (true
           (setq out '())
           (dolist (el lst)
              (extend out (dup (last el) (first el)))
           )
          )
    )
    out
  )
)

(rle-decode '((3 a) (2 b) (2 c) (1 a) (2 d)))
;-> (a a a b b c c a d d))

(rle-decode '((4 a) (1 b) (2 c) (2 a) (1 d) (4 e) (1 f)))
;-> (a a a a b c c a a d e e e e f)

(rle-decode (rle-encode '(a a a a b c c a a d e e e e f)))
;-> (a a a a b c c a a d e e e e f)


-----------------------------------------------
Massimo Comun Divisore e Minimo Comune Multiplo
-----------------------------------------------

In inglese:
GCD -> Greatest Common Divisor
LCM -> Least Common Multiple

; =============================================
; (my-gcd x1 x2 x3 ... xn)
; Calcola il massimo comun divisore di N numeri
; =============================================
(define (gcd_ a b) ; gcd funzione ausiliaria
  (let (r (% b a))
    (if (= r 0) a (gcd_ r a))))

(gcd_ 12 30)
;-> 6

(define-macro (my-gcd)
  ; ritorna il massimo comun divisore di tutti i numeri interi passati
  (apply gcd_ (args) 2))

(my-gcd 12 30 4)
;-> 2

; =============================================
; (my-lcm x1 x2 x3 ... xn)
; Calcola il minimo comune multiplo di N numeri
; =============================================
(define (lcm_ a b)
  ; lcm funzione ausiliaria
  (/ (* a b) (gcd_ a b)))

(lcm_ 12 30)
;-> 60

(define-macro (my-lcm)
  ; ritorna il minimo comune multiplo di tutti i numeri interi passati
  (apply lcm_ (args) 2))

(my-lcm 12 60 130)
;-> 780

Possiamo anche utilizzare una funzione lambda al posto della funzione ausiliaria:

(define-macro (lcm)
  (apply (fn (x y) (/ (* x y) (gcd_ x y))) (args) 2))

(lcm 12 60 130)
;-> 780


-----------------
Funzioni booleane
-----------------

; =====================================================
; Funzioni booleane e bitwise
; nand, nor, xor xnor
; =====================================================

;; boolean functions
(define (nand a b) (not (and a b)))
(define (nor a b) (not (or a b)))
(define (xor a b) (if (nand a b) (or a b) nil))
(define (xnor a b) (not (xor a b)))

;; bitwise versions:
(define (~& a b) (~ (& a b))) ; nand, bitwise
(define (~| a b) (~ (| a b))) ; nor, bitwise
;; xor is already in the language as ^
(define (~^ a b) (~ (^ a b))) ; xnor, bitwise


-------------------------------
Estrazione dei bit di un numero
-------------------------------

; Restituisce il bit n-esimo del numero intero positivo x
; indice zero
(define (bit n x)
    (if (< x 0) (setq x (sub 0 x))) ; solo numeri positivi
    (& (>> x (- n 1)) 1)
)

(bits 123)
;-> 1111011

(bit 1 123) ;-> 1
(bit 2 123) ;-> 1
(bit 3 123) ;-> 0
(bit 4 123) ;-> 1
(bit 5 123) ;-> 1
(bit 6 123) ;-> 1
(bit 7 123) ;-> 1

Per i big-integer possiamo usare la seguente funzione:

; Compute "bits" for bigint and int
(constant 'MAXINT (pow 2 62))
(define (prep s) (string (dup "0" (- 62 (length s))) s))
(define (bitsL n)
    (if (<= n MAXINT) (bits (int n))
      (string (bitsL (/ n MAXINT))
              (prep (bits (int (% n MAXINT)))))))

(bitsL 191934985723489057239845792384579823475981L)
;->"100011010000001011110101011010001101010110100111011110110000000110001010
;-> 110011011000001001000100010111101011011011010101000001110100001101"


---------------------------------------------------
Conversione gradi decimali <--> gradi sessagesimali
---------------------------------------------------

; =====================================================
; (dd-to-dms degrees)
; Converte gradi decimali in gradi, minuti, secondi
; =====================================================

(define (dd-to-dms degrees)
  (local (udegree d m s)
    (if (> 0.0 degrees)
        (setq udegree (abs degrees))
        (setq udegree degrees)
    )
    (setq d (int udegree))
    (setq m (int (mul 60.0 (sub udegree d))))
    (setq s (mul 3600.0 (sub udegree d (div m 60.0))))
    (if (> 0.0 degrees) (set 'd (sub d 0)))
    ;(println d { } m { } s { })
    (list d m s)
    ;result d m s
  )
)

(dd-to-dms 30.263888889)
;-> 30 15 50.00000040000145

; =====================================================
; (dms-to-decimal degrees minutes seconds)
; Converte gradi, minuti, secondi in gradi decimali
; =====================================================

(define (dms-to-dd degrees minutes seconds)
  (local (dd)
    (if (< 0.0 degrees)
        (setq dd (add degrees (div minutes 60.0) (div seconds 3600.0)))
        (setq dd (add degrees (- 0.0 (div minutes 60.0)) (- 0.0 (div seconds 3600.0))))
    )
    result dd
  )
)

(dms-to-dd 30.0 15.0 50.0)
;-> 30.26388888888889


------------------------
Conversione RGB <--> HSV
------------------------

Conversione di un colore dallo spazio RGB (Red, Green, Blu) allo spazio HSV (Hue Saturation Value) e viceversa. Per ulteriori informazioni consultare il sito:

http://www.easyrgb.com/en/math.php

R, G e B input range  = 0 ÷ 255
H, S e V output range = 0 ÷ 1.0

Conversione RGB -> HSV:

(define (rgb2hsv r g b)
  (local (h s v var-r var-g var-b var-min var-max del-max del-r del-g del-b)
    (setq var-r (div r 255))
    (setq var-g (div g 255))
    (setq var-b (div b 255))
    (setq var-min (min var-r var-g var-b)) ; valore minimo di RGB
    (setq var-max (max var-r var-g var-b)) ; valore massimo di RGB
    (setq del-max (sub var-max var-min))   ; delta RGB
    (setq v var-max)
    (cond ((= 0 del-max) (setq h 0) (setq s 0)) ; tono di grigio
           (true ; colore
              (setq s (div del-max var-max))
              (setq del-r (div (add (div (sub var-max var-r) 6) (div del-max 2)) del-max))
              (setq del-g (div (add (div (sub var-max var-g) 6) (div del-max 2)) del-max))
              (setq del-b (div (add (div (sub var-max var-b) 6) (div del-max 2)) del-max))
              (cond ((= var-r var-max) (setq h (sub del-b del-g)))
                    ((= var-g var-max) (setq h (add (div 1 3) (sub del-r del-b))))
                    ((= var-b var-max) (setq h (add (div 2 3) (sub del-g del-r))))
                    (true println "errore")
              )
              (if (< h 0) (setq h (add 1 h)))
              (if (> h 1) (setq h (sub 1 h)))
           );end true
    )
    (list h s v)
  );end local
)

(rgb2hsv 255 255 255)
;-> (0 0 1)

(rgb2hsv 0 0 0)
;-> (0 0 0)

(rgb2hsv 80 80 80)
;-> (0 0 0.3137254901960784)

(rgb2hsv 155 55 20)
;-> (0.04320987654320985 0.8709677419354838 0.6078431372549019)

Conversione HSV -> RGB:

(define (hsv2rgb h s v)
  (local (r g b var-h var-i var-1 var-2 var-3 var-4 var-r var-g var-b)
    (cond ((= 0 s) (setq r (mul v 255)) (setq g (mul v 255)) (setq b (mul v 255)))
          (true
             (setq var-h (mul h 6))
             (if (= var-h 6) (setq var-h 0)) ; h deve essere minore di 1
             (setq var-i (floor var-h))
             (setq var-1 (mul v (sub 1 s)))
             (setq var-2 (mul v (sub 1 (mul s (sub var-h var-i)))))
             (setq var-3 (mul v (sub 1 (mul s (sub 1 (sub var-h var-i))))))
             (cond ((= 0 var-i) (setq var-r v)     (setq var-g var-3) (setq var-b var-1))
                   ((= 1 var-i) (setq var-r var-2) (setq var-g v)     (setq var-b var-1))
                   ((= 2 var-i) (setq var-r var-1) (setq var-g v)     (setq var-b var-3))
                   ((= 3 var-i) (setq var-r var-1) (setq var-g var-2) (setq var-b v))
                   ((= 4 var-i) (setq var-r var-3) (setq var-g var-1) (setq var-b v))
                   (true        (setq var-r v    ) (setq var-g var-1) (setq var-b var-2))
             )
             (setq r (mul var-r 255))
             (setq g (mul var-g 255))
             (setq b (mul var-b 255))
          )
    );end cond
    (list r g b)
  );end local
)

(hsv2rgb 0 0 1)
;-> (255 255 255)

(hsv2rgb 0 0 0)
;-> (0 0 0)

(hsv2rgb 0 0 0.3137254901960784)
;-> (80 80 80)

(hsv2rgb 0.04320987654320985 0.8709677419354838 0.6078431372549019)
;-> (155 54.99999999999998 20.00000000000001)

(hsv2rgb 0.5 0.5 0.5)
;-> (63.75 127.5 127.5)

(rgb2hsv 63.75 127.5 127.5)
;-> (0.4999999999999999 0.5 0.5)


-------------------------------
Calcolo della media di n numeri
-------------------------------

; =====================================================
; (media lst) oppure (media x1 x2 ... xn)
; Calcola la media di n numeri
; =====================================================

(define (media)
  (if (or (= (args) '()) (= (args) '(()) )) nil
    (if (= (length (args)) 1) ;controlla se args è una lista o una serie di numeri
        (div (apply add (first (args))) (length (first (args))))
        (div (apply add (args)) (length (args)))
    )
  )
)

(media)
;-> nil

(media '())
;-> nil

(media 1 2 3)
;-> 2

(media '(1 2 3 4 5 6 7 8 9))
;-> 5

(media (sequence 1 9999))
;-> 5000

(setq lst '(1 2 3 4 5 6))
(media lst)
;-> 3.5


----------
Istogramma
----------

Data una lista disegnare l'istogramma dei valori.
Deve essere possibile passare un parametro che indica che la lista passata non è una lista di frequenze, ma una lista di valori: in tal taso occorre calcolare la lista delle frequenze prima di disegnare l'istogramma.

Le seguenti espressioni creano una lista di valori con 1000 elementi ("res"):

(setq res '())
(for (i 0 999)
  (push (rand 11) res -1)
)
(length res)

Le seguenti espressioni creano la lista delle frquenzze della lista "res":

(setq f (array 11 '(0)))
(dolist (el res)
  (println el)
  (++ (f (- el 1)))
)

f
;-> (80 98 86 83 86 99 90 106 80 84 108)

La seguente funzione disegna l'istogramma, se il parametro "calc" vale true, allora calcola la lista delle frequenze dalla lista passata:

(define (istogramma lst hmax (calc nil))
  (local (unici linee hm scala f-lst)
    (if calc
      ;calcolo la lista delle frequenze partendo da lst
      (begin
        ;trovo quanti numeri diversi ci sono nella lista
        (setq unici (length (unique lst)))
        ;creo la lista delle frequenze
        (setq f-lst (array unici '(0)))
        ; calcolo dei valori delle frequenze
        (dolist (el lst)
          (++ (f-lst (- el 1)))
        )
      )
      ;else
      ;lst è la lista delle frequenze
      (begin (setq f-lst lst))
    )
    (setq hm (apply max f-lst))
    (setq scala (div hm hmax))
    (setq linee (map (fn (x) (round (div x scala))) f-lst))
    (dolist (el linee)
      ;(println (format "%3d %s %0.2f" (add $idx 1) (dup "*" el) (f-lst $idx)))
      (println (format "%3d %s %4d" $idx (dup "*" el) (f-lst $idx)))
    )
  );local
)

(istogramma f 20)
;->   0 ***************   80
;->   1 ******************   98
;->   2 ****************   86
;->   3 ***************   83
;->   4 ****************   86
;->   5 ******************   99
;->   6 *****************   90
;->   7 ********************  106
;->   8 ***************   80
;->   9 ****************   84
;->  10 ********************  108

(istogramma res 20 true)
;->   0 ***************   80
;->   1 ******************   98
;->   2 ****************   86
;->   3 ***************   83
;->   4 ****************   86
;->   5 ******************   99
;->   6 *****************   90
;->   7 ********************  106
;->   8 ***************   80
;->   9 ****************   84
;->  10 ********************  108


--------------------
Stampare una matrice
--------------------

(define (print-matrix matrix)
  (local (row col nmax nmin digit fmtstr)
    ; converto matrice in lista ?
    (if (array? matrix) (setq matrix  (array-list matrix)))
    ; righe della matrice
    (setq row (length matrix))
    ; colonne della matrice (da rivedere)
    (setq col (length (first matrix)))
    ; valore massimo
    (setq nmax (string (apply max (flat matrix))))
    ; valore minimo
    (setq nmin (string (apply min (flat matrix))))
    ; calcolo spazio per i numeri
    (setq digit (add 1 (max (length nmax) (length nmin))))
    ; creo stringa di formattazione
    (setq fmtstr (append "%" (string digit) "d"))
    ; stampa
    (for (i 0 (sub row 1))
      (for (j 0 (sub col 1))
        (print (format fmtstr (matrix i j)))
      )
      (println)
    )
  )
)

Con alcune modifiche la funzione può essere usata per stampare matrici di interi, floating-point e/o stringhe:

(define (print-matrix matrix)
  (local (row col lenmax digit fmtstr)
    ; converto matrice in lista?
    (if (array? matrix) (setq matrix  (array-list matrix)))
    ; righe della matrice
    (setq row (length matrix))
    ; colonne della matrice
    (setq col (length (first matrix)))
    ; valore massimo della lunghezza di un elemento (come stringa)
    (setq lenmax (apply max (map length (map string (flat matrix)))))
    ; calcolo spazio per gli elementi
    (setq digit (+ 1 lenmax))
    ; creo stringa di formattazione
    (setq fmtstr (append "%" (string digit) "s"))
    ; stampa la matrice
    (for (i 0 (- row 1))
      (for (j 0 (- col 1))
        (print (format fmtstr (string (matrix i j))))
      )
      (println)
    )
  nil))

(setq m '((1 2 3) (4 5 6) (7 8 9)))
(print-matrix m)
;-> 1 2 3
;-> 4 5 6
;-> 7 8 9

(setq m '((1111 -20000 3) (4 5 66) (7 8 999)))
(print-matrix m)
;-> 1111 -20000      3
;->    4      5     66
;->    7      8    999

(setq m '(("11.11" "2" "3") ("4" "55.555" "66") ("7" "8" "999")))
(print-matrix m)
;-> 11.11      2      3
;->     4 55.555     66
;->     7      8    999

(setq m '((1234.5 "bb" "ccc") (111 "lungo" "f") ("hh" "kkk" "zzzz")))
(print-matrix m)
;-> 1234.5     bb    ccc
;->    111  lungo      f
;->     hh    kkk   zzzz


----------------------------
Retta passante per due punti
----------------------------

(define (retta2p x1 y1 x2 y2)
  (local (m q)
    (cond ((zero? (sub x1 x2))
              (setq m (div 1 0))
              (setq q 0)
          )
          ((zero? (sub y1 y2))
              (setq m 0)
              (setq q y1)
          )
          (true
              (setq m (div (sub y1 y2) (sub x1 x2)))
              (setq q (sub y1 (mul m x1)))
          )
    )
    (list m q)
  )
)

(retta2p 2 -3 3 -1)
;-> (2 -7)

(retta2p 2 2 3 3)
;-> (1 0)

;retta verticale
(retta2p 2 4 2 3)
;-> (1.#INF 0)

;retta orizzontale
(retta2p 1 4 2 4)
;-> (0 4)


------------------------------------
Coordinate dei punti di una funzione
------------------------------------

Supponiamo di avere la seguente funzione e di voler ottenere una serie di coordinate (x,y):

y = f(x) = (3*x^2 - 4*x + 6)

Definiamo la funzione:

(define (fx x) (add (mul 3 (mul x x)) (- (mul 4 x)) 6))

Vogliamo calcolare 5 coppie di coordinate con x che va da 10 a 20.

Prima generiamo i valori delle x:

(setq l (sequence 10 20 2))
;-> (10 12 14 16 18 20)

Poi generiamo i valori delle y:

(setq k (map fx l))
;-> (266 390 538 710 906 1126)

Poi uniamo le due liste:

(transpose (list l k))
;-> ((10 266) (12 390) (14 538) (16 710) (18 906) (20 1126))

Possiamo scrivere una funzione che restituisce le coppie di coordinate:

(define (coordFX funzione xi xf passo)
  (local (lstX lstY)
    (setq lstX (sequence xi xf passo))
    (setq lstY (map funzione lstX))
    (transpose (list lstX lstY))
  )
)

(coordFX fx 10 20 2)
;-> ((10 266) (12 390) (14 538) (16 710) (18 906) (20 1126))

Definiamo la funzionde quadrato:

(define (gx x) (mul x x))

(coordFX gx 1 10 1)
;-> ((1 1) (2 4) (3 9) (4 16) (5 25) (6 36) (7 49) (8 64) (9 81) (10 100))


-----------------------------------
Leggere e stampare un file di testo
-----------------------------------

;==================================
; (stampa file)
; Legge e stampa un file di testo
; Il parametro "file" è una stringa
;==================================

(define (stampa file)
  (local (afile linea)
    (setq afile (open file "read"))
    (while (read-line afile)
      (setq linea (current-line))
      (println linea)
    )
    (close afile)
  )
)

(stampa "stampa.txt")
;-> riga 1 del file da stampare
;-> riga 2 del file da stampare
;-> fine del file
;-> true


--------------------------------------
Criptazione e decriptazione di un file
--------------------------------------

La funzione "encrypt" di newLISP funziona in modo biunivoco:
(encrypt (encrypt "testo")) = "testo".
In altre parole una doppia criptazione restituisce il file originale, quindi possiamo scrivere una funzione unica:

;========================================
; Cripta/Decripta un file con buffer read
;========================================
(define (cripta inputfile outputfile key)
  (local (infile outfile crypt)
    (setq infile (open inputfile "read"))
    (setq outfile (open outputfile "write"))
    (while (!= (read infile buffer 256) nil)
        (setq crypt (encrypt buffer key))
        (write outfile crypt 256)
        ;(print (encrypt buffer key))
    )
    (close infile)
    (close outfile)
  )
)

Per criptare un file:
(cripta "testo.txt" "testo.enc" "chiave")

Per decriptare un file:
(cripta "testo.enc" "testo.out" "chiave")


-------------------------
Funzioni per input utente
-------------------------

*********************
>>>funzione READ-KEY
*********************
sintassi: (read-key)

Legge un tasto dalla tastiera e restituisce un valore intero. Per i tasti di navigazione, è necessario effettuare più di una chiamata read-key. Per i tasti che rappresentano i caratteri ASCII, il valore di ritorno è lo stesso su tutti i Sistemi Operativi, ad eccezione dei tasti di navigazione e di altre sequenze di controllo come i tasti funzione, nel qual caso i valori di ritorno possono variare in base ai diversi SO e alle configurazioni.

(read-key)  → 97  ; after hitting the A key
(read-key)  → 65  ; after hitting the shifted A key
(read-key)  → 10  ; after hitting [enter] on Linux
(read-key)  → 13  ; after hitting [enter] on Windows

(while (!= (set 'c (read-key)) 1) (println c))

L'ultimo esempio può essere utilizzato per verificare le sequenze di ritorno dalla navigazione e dai tasti funzione. Per interrompere il ciclo, premere Ctrl-A.

Notare che "read-key" funziona solo quando newLISP è in esecuzione in una shell Unix o nella shell dei comandi di Windows. Non funziona nelle gui Java newLISP-GS e Tcl/Tk newLISP-Tk. Non funziona neanche nelle shared library newwLISP di UNIX o nella DLL newLISP di Windows (Dynamic Link Library).

; =====================================================
; yes-no
; Ask user to input "Y" or "N" (all other keys)
; =====================================================

(define (yes-no message)
  (print message)
  (if (= "Y" (upper-case (read-line)))
    true
    nil
  )
)

(yes-no "Do you want to exit (y/n)? ")

; =====================================================
; input-symbol
; Ask user to input a symbol
; read-line function return a string
; =====================================================

(define (input-symbol message)
  (print message)
  ; a symbol can't begin with number
  (while (number? (int (read-line)))
    (print message)
  )
  (sym (current-line))
)

(input-symbol "Insert a symbol: ")


; =====================================================
; input-string
; Ask user to input a string
; read-line function return a string
; =====================================================

(define (input-string message)
  (print message)
  (while (not (string? (read-line)))
    (print message)
  )
  (current-line)
)

(input-string "Insert a string: ")

; =====================================================
; input-number
; Ask user to input a number (float)
; =====================================================

(define (input-number message)
  (print message)
  (while (not (number? (float (read-line))))
    (print message)
  )
  (float (current-line))
)

(input-number "Insert a number: ")

; =====================================================
; input-integer
; Ask user to input a number
; =====================================================

(define (input-integer message)
  (print message)
  (while (not (integer? (int (read-line))))
    (print message)
  )
  (int (current-line))
)

(input-integer "Insert an integer: ")


----------------
Emettere un beep
----------------

newLISP emette un suono/beep quando si stampa il carattere 'bell':

(println (char 7))
;-> "\007"

; =============================================
; (beep)
; Emette un beep
; =============================================
(define (beep)
  (silent (print (char 7))))

La funzione "silent" sopprime l'output sulla console, quindi non compare "\007".

(beep)

Può essere utile per segnalare il termine delle operazioni.


---------------------------------------
Disabilitare l'output delle espressioni
---------------------------------------

La funzione "silent" è simile a "begin": valuta una sequenza di espressioni sopprimendo l'output e il prompt. Per ritornare al prompt occorre premere "invio" due volte.

(silent (setq a 10) (println a))
;-> 10 ; premere "invio" due volte per ritornare al prompt

Un modo elegante per ritornare al prompt senza intervento dell'utente è il seguente:

; funzione che ritorna al prompt dopo una chiamata a "silence"
(define (resume) (print "\r\n> "))

; funzione generica
(define (myfunction) "valore di ritorno")

; Come utilizzare il metodo:
(silent (myfunction) (print "Fatto") (resume))

Ad esempio, per disabilitare l'output del valore di ritorno delle espressioni "print" e "println" possiamo usare le seguenti funzioni:

(define (sprint) (silent (apply print (args)) (resume)))
(define (sprintln) (silent (apply print (args)) (resume)))

Vediamo le differenze:

(println "normale")
;-> normale
;-> "normale"
(sprintln "normale")
;-> normale

(print "semplice")
;-> semplice"semplice"
(sprint "semplice")
;-> semplice


-----------------------------------------------------
Trasformare una lista di stringhe in lista di simboli
-----------------------------------------------------

Partendo da una stringa:

(setq str "Questa è la stringa da convertire")
;-> "Questa è la stringa da convertire"

Creiamo una lista di stringhe:

(setq lst (parse str))
;-> ("Questa" "è" "la" "stringa" "da" "convertire")

Infine convertiamo la lista di stringhe in lista di simboli:

(map sym lst)
;-> (Questa è la stringa da convertire)


-----------------------------------------------------
Trasformare una lista di simboli in lista di stringhe
-----------------------------------------------------

Convertiamo una lista di simboli in una lista di stringhe:

(map string '(uno due tre))
;-> ("uno" "due" "tre")

Con una macro possiamo passare tutti i simboli senza usare una lista:

(define-macro (str-m) (map string (args)))
;-> (lambda-macro () (map string (args)))

(str-m uno due tre)
;-> ("uno" "due" "tre")

Una funzione non risolve il problema perchè prima di applicare "string" i parametri (args) vengono valutati (a nil):

(define (str-f) (map string (args)))

(str-f uno due tre)
;-> ("nil" "nil" "nil")


--------------------------
Simboli creati dall'utente
--------------------------

Per vedere quali simboli crea la nostra funzione possiamo utilizzare il seguente procedimento:
1) lanciare una nuova REPL
2) impostare i simboli attuali su una variabile:
   (setq prima (symbols))
3) Lanciare la funzione
4) impostare i nuovi simboli su una variabile:
   (setq dopo (symbols))
5) Effettuare la differenza tra le due variabili:
   (difference dopo prima)

Esempio:
1) lancio una nuova REPL
2) creo una lista con i simboli attuali:
  (setq prima (symbols))
3) Scrivo la funzione:
  (define (doppio x) (mul x x))
4) creo una lista con i nuovi simboli:
  (setq dopo (symbols))
5) calcolo la differenza tra le due liste di simboli:
  (difference dopo prima)
;-> (dopo doppio x)

La seguente funzione restituisce una lista con due sottoliste, la prima sottolista contiene i nomi delle funzioni definite dall'utente (lambda), mentra la seconda sottolista contiene tutti gli altri simboli definiti dall'utente.

Definite la seguente funzione in una nuova sessione di newLISP (una nuova REPL) e poi eseguitela:

(define (user-symbols)
  (local (func other)
    (setq func '())
    (setq other '())
    (dolist (el (symbols))
      (if (lambda? (eval el))  (push el func -1))
      (if (and (not (lambda? (eval el)))
               (not (primitive? (eval el)))
               (not (protected? el))
               (not (global? el)))
          (push el other -1))
    )
    (list func other)
  )
)

(user-symbols)
;-> ((module user-symbols) (el func other))

Versione modificata:

(define (user-symbols)
  (local (_func _other)
    (setq _func '())
    (setq _other '())
    (dolist (_el (symbols))
      (if (and (lambda? (eval _el))
               (not (= _el 'user-symbols)))
          (push _el _func -1))
      (if (and (not (lambda? (eval _el)))
               (not (primitive? (eval _el)))
               (not (protected? _el))
               (not (global? _el))
               (not (= _el '_func))
               (not (= _el '_other))
               (not (= _el '_el)))
          (push _el _other -1))
    )
    (list _func _other)
  )
)

(user-symbols)
;-> ((module) ()) ; from a fresh REPL of newLISP


-------------------------------------------------
Il programma è in esecuzione? (progress display)
-------------------------------------------------

Qualche volta abbiamo bisogno di sapere se un programma è in esecuzione (e a che punto si trova) oppure si è bloccato in qualche parte del nostro codice. Ci sono due metodi per questo:
il primo metodo stampa ciclicamente una serie di simboli sulla console per dimostrare che il programma sta girando:

(define (controllo)
    (setq i 1)
    (dotimes (x 100000)
      (case i
        (1 (print "wait... |\r"))
        (2 (print "wait... /\r"))
        (3 (print "wait... -\r"))
        (4 (print "wait... \\\r"))
        (true "errore")
      )
      (inc i)
      (if (> i 4) (setq i 1))
    )
    (println "Programma terminato")
)

Il programma stampa ciclicamente un carattere della serie "|", "/". "-", "\\".
Poichè ad ogni print stampiamo anche un "carriage return" (\r) stampiamo sempre sulla stessa linea a partire dalla colonna zero. Questo genera la semplice animazione che vedete quando eseguite la funzione.

(controllo)
;-> wait... (animazione dei caratteri)
;-> Programma terminato
;-> "Programma terminato"

Per migliorare l'output possiamo scrivere:

(define (resume) (print "\r\n> "))

(silent (controllo) (resume))
;-> Programma terminato

Possiamo diminuire il numero dei caratteri nell'animazione scegliendo due caratteri ":" e "-":

(define (controllo)
    (setq i 0)
    (dotimes (x 100000)
      (if (= 0 i) (print "wait... :\r")
                  (print "wait... -\r")
      )
      (inc i)
      (if (> i 1) (setq i 0))
    )
    (println "Programma terminato")
)

(silent (controllo) (resume))
;-> wait... (animazione dei caratteri)
;-> Programma terminato

Il secondo metodo è più informativo, poichè visualizza il valore della iterazione corrente:

(define (controllo)
    (setq iter 10000000)
    (dotimes (x 100000000)
      ; ogni iter iterazioni stampiamo il valore
      (if (= 0 (mod x iter)) (print "Iter: " x "\r"))
    )
    (println "Programma terminato")
)

(silent (controllo) (resume))
;-> Iter: 0 ... ;-> Iter: 900000000
;-> Programma terminato

Da notare che entrambi i metodi rallentano leggermente l'esecuzione del programma.


-----------------------------
Ispezionare una cella newLISP
-----------------------------

Per conoscere il contenuto (tipo) di una cella lisp possiamo utilizzare la funzione "dump".

****************
>>>funzione DUMP
****************
sintassi: (dump [exp])

Mostra i contenuti binari di una nuova cella LISP. Senza argomenti, questa funzione restituisce un elenco di tutte le celle Lisp. Quando viene fornito exp, viene valutato e il contenuto della cella Lisp viene restituito in una lista.

(dump 'a)
;-> (9586996 5 9578692 9578692 9759280)

(dump 999)
;-> (9586996 130 9578692 9578692 999)

L'elenco contiene i seguenti indirizzi di memoria e informazioni:

offset  descrizione
0       indirizzo di memoria della cella Lisp
1       cella->tipo: maggiore/minore, vedi newLISP.h per i dettagli
2       cella->successivo: puntatore alla linked list
3       cella->aux:
           lunghezza della stringa + 1 o
           low (little endian) o high (big endian) word di numero intero a 64 bit o
           low word di double float IEEE 754
4       cella->contenuto:
           indirizzo della stringa/simbolo o
           high (little endian) o low (big endian) word di numero intero a 64 bit o
           high di double float IEEE 754

Questa funzione è utile per modificare i bit di tipo nelle celle o per hackerare altre parti dei nuovi interni di LISP.

La seguente funzione estrae il tipo di dato contenuto in una cella newLISP:

(define (type x) (& 15 (nth 1 (dump x))))

(type nil)
;-> 0            ;; nil
(type true)
;-> 1            ;; true
(type 123)
;-> 2            ;; integer
(type 1.23)
;-> 3            ;; float
(type "abcd")
;-> 4            ;; string
(type 'asymbol)
;-> 5            ;; symbol
(type MAIN)
;-> 6            ;; context
(type +)
;-> 7            ;; primitive
;; 8             ;; imports cdecl, dll
;; 9             ;; imports ffi
(type ''asym)
;-> 10           ;; quote
(type '(1 2 3))
;-> 11           ;; list expression
(type type)
;-> 12           ;; lambda
;; 13            ;; fexpr
;; 14            ;; array
;; 15            ;; dynamic symbol

Vedere il file newLISP.h nel programma sorgente per conoscere i bit superiori e il loro significato (e anche altre cose).

Un altro metodo simile:

(define types '("nil" "true" "int" "float" "string" "symbol" "context"
    "primitive" "import" "ffi" "quote" "expression" "lambda" "fexpr" "array"
    "dyn_symbol"))

(define (typeof v)
    (types (& 0xf ((dump v) 1))))


-----------------------------------
Informazioni sul sistema (sys-info)
-----------------------------------

Possiamo ottenere diverse informazioni sul sistema in uso utilizzando la funzione "sys-info".

********************
>>>funzione SYS-INFO
********************
sintassi: (sys-info [int-idx])

Chiamando sys-info senza int-idx viene restituito un elenco di informazioni sulle risorse. Dieci valori interi che hanno il seguente significato:

valore descrizione
  0     Numero di celle Lisp
  1     Numero massimo di celle Lisp (costante)
  2     Numero di simboli
  3     Livello di valutazione / ricorsione dell'ambiente
  4     Livello di stack dell'ambiente
  5     Numero massimo di chiamate allo stack (costante)
  6     Pid del processo genitore oppure 0
  7     Pid del processo newLISP
  8     Numero della versione come costante intera
  9     Costanti del sistema operativo:
        linux = 1, bsd = 2, osx = 3, solaris = 4, windows = 6, os/2 = 7, cygwin = 8, tru64 unix = 9, aix = 10, android = 11
        il bit 11 è impostato per le versioni ffilib (Extended Import/Callback API) (aggiungere 1024)
        il bit 10 è impostato per le versioni IPv6 (aggiungere 512)
        il bit  9 è impostato per le versioni a 64 bit (modificabili a runtime) (aggiungere 256)
        il bit  8 è impostato per le versioni UTF-8 (aggiungere 128)
        il bit  7 è aggiunto per le versioni di libreria (aggiungere 64)

I numeri da 0 a 9 indicano il valore dell'indice int-idx (opzionale) nella lista restituita.

Si consiglia di utilizzare gli indici da 0 a 5 (includendo) "Numero massimo di chiamate allo stack costante") e utilizzare gli offset negativi da -1 a -4 per accedere alle ultime quattro voci nella lista delle informazioni di sistema. Le future nuove voci verranno inserite dopo l'indice 5. In questo modo i programmi scritti precedentemente non dovranno essere modificati.

Quando si usa int-idx, verrà restituito un solo elemento della lista.

(sys-info) → (429 268435456 402 1 0 2048 0 19453 10406 ​​1155)
(sys-info 3) → 1
(sys-info -2) → 10406 ​​;; versione 10.4.6

Il numero relativo al massimo di celle Lisp può essere modificato tramite l'opzione della riga di comando -m. Per ogni megabyte di memoria di celle Lisp, è possibile allocare 64k celle Lisp. La profondità massima dello stack di chiamata può essere modificata utilizzando l'opzione della riga di comando -s.

(bits (sys-info -1))
;-> "10110000110"
1 --> ffilib ON
0 --> IPv6 OFF
1 --> 64bit ON
1 --> UTF-8 ON
0 --> library OFF
0 --> (free)
0 --> (free)
0110 --> 6 = windows

Per rendere più leggibili le informazioni scriviamo la funzione "sysinfo":

(define (sysinfo)
  (local (info num num$ so)
    (setq info (sys-info))
    (println "Number of Lisp cells: " (info 0))
    (println "Maximum number of Lisp cells constant: " (info 1))
    (println "Number of symbols: " (info 2))
    (println "Evaluation/recursion level: " (info 3))
    (println "Environment stack level: " (info 4))
    (println "Maximum call stack constant: " (info 5))
    (println "Pid of the parent process or 0: " (info -4))
    (println "Pid of running newLISP process: " (info -3))
    (println "Version number as an integer constant: " (info -2))
    (setq num (sys-info -1))
    (setq num$ (bits num))
    (setq so (int (slice num$ (- (length num$) 4)) 0 2))
    (print "Operating System: ")
    (case so
        (1  (println "linux"))
        (2  (println "bsd"))
        (3  (println "osx"))
        (4  (println "solaris"))
        (5  (println "nil"))
        (6  (println "windows"))
        (7  (println "os/2"))
        (8  (println "cygwin"))
        (9  (println "tru64 unix"))
        (10 (println "aix"))
        (11 (println "android"))
        (true (println so))
    );case
    ; ffilib -> bit 11
    (print "ffilib: ")
    (if (zero? (& (>> num 10) 1)) (println "no") (println "yes"))
    ; IPV6 -> bit 10
    (print "IPV6: ")
    (if (zero? (& (>> num 9) 1)) (println "no") (println "yes"))
    ; 64 bit -> bit 9
    (print "64 bit: ")
    (if (zero? (& (>> num 8) 1)) (println "no") (println "yes"))
    ; utf8 -> bit 8
    (print "UTF-8: ")
    (if (zero? (& (>> num 7) 1)) (println "no") (println "yes"))
    ; library -> bit 7
    (print "library: ")
    (if (zero? (& (>> num 6) 1)) (println "no") (println "yes"))
    info
  )
)
(sys-info)
(sysinfo)
;-> Number of Lisp cells: 983
;-> Maximum number of Lisp cells constant: 576460752303423488
;-> Number of symbols: 425
;-> Evaluation/recursion level: 4
;-> Environment stack level: 1
;-> Maximum call stack constant: 2048
;-> Pid of the parent process or 0: 0
;-> Pid of running newLISP process: 6884
;-> Version number as an integer constant: 10705
;-> Operating System: windows
;-> ffilib: yes
;-> IPV6: no
;-> 64 bit: yes
;-> UTF-8: yes
;-> library: no
;-> (959 576460752303423488 425 2 0 2048 0 6884 10705 1414)


------------------------------------
Valutazione di elementi di una lista
------------------------------------

Supponiamo di aver creato la seguente lista:

(setq lst '( ((+ 6 2) (a) 2) ((- 2 5) (b) 5) ))
;-> (((+ 6 2) (a) 2) ((- 2 5) (b) 5))

La lista ha due elementi ((+ 6 2) (a) 2) e ((- 2 5) (b) 5).

Adesso vogliamo valutare il primo elemento di ogni sottolista: (+ 6 2) e (- 2 5).

Aggiorniamo questo elemento con la sua valutazione:

(dolist (el lst) (setf (first (lst $idx)) (eval (first el))))

Vediamo il risultato:

lst
;-> ((8 (a) 2) (-3 (b) 5))


---------------------------------------
Download tutti i file da una pagina web
---------------------------------------

La seguente funzione permette di scaricare tutti i file da una pagina web.

; get-all.lsp
; cameyo 2019
; scarica tutti i file da una pagina web
; get all downloadable files from a webpage

; get the page
(setq page (get-url "http://newlisp.digidep.net/"))
(setq page (get-url "http://landoflisp.com/source.html"))

; find files (*.lsp)
(setq filesA (find-all {href="(.*\.lsp)"} page $1))

; find files (*.jpg)
(setq filesB (find-all {href="(.*\.jpg)"} page $1))

(setq allfiles (union filesA filesB))

(dolist (file allfiles)
        (write-file file (get-url (string "http://newlisp.digidep.net/scripts/" file)))
        (println "->" file))

Esempio:

(change-dir "c:/temp")
(setq page (get-url "http://landoflisp.com/source.html"))
(setq allfiles (find-all {href="(.*\.lisp)"} page $1))
(dolist (file allfiles)
        (write-file file (get-url (string "http://landoflisp.com/source.html" file)))
        (println "-> " file))
;-> -> guess.lisp
;-> -> wizards_game.lisp
;-> -> graph-util.lisp
;-> -> wumpus.lisp
;-> -> orc-battle.lisp
;-> -> evolution.lisp
;-> -> robots.lisp
;-> -> webserver.lisp
;-> -> dice_of_doom_v1.lisp
;-> -> svg.lisp
;-> -> wizard_special_actions.
;-> -> lazy.lisp
;-> -> dice_of_doom_v2.lisp
;-> -> dice_of_doom_v3.lisp
;-> -> dice_of_doom_v4.lisp


-------------------------------------
Conversione numero da cifre a lettere
-------------------------------------

Vogliamo convertire un numero da cifre a lettere, ad esempio:

10421 -> diecimilaquattrocentoventuno

Questo problema è più difficile da risolvere per la lingua italiana che per quella inglese a causa delle cifre 1 ("uno") e 8 ("otto") che modifica la lettura del numero (es. ventuno e non ventiuno, trentotto e non trantaotto).

Come prima cosa definiamo alcune liste:

  ; la cifra 1
  (setq un "Un")
  ; le dieci cifre - codeA
  (setq cifre '("Zero" "Uno" "Due" "Tre" "Quattro" "Cinque" "Sei" "Sette"
    "Otto" "Nove"))
  ; i primi venti numeri - code
  (setq venti '("Zero" "Uno" "Due" "Tre" "Quattro" "Cinque" "Sei" "Sette"
    "Otto" "Nove" "Dieci" "Undici" "Dodici" "Tredici" "Quattordici"
    "Quindici" "Sedici" "Diciassette" "Diciotto" "Diciannove"))
  ; le decine - codeB
  (setq decine '("" "" "Venti" "Trenta" "Quaranta" "Cinquanta"
    "Sessanta" "Settanta" "Ottanta" "Novanta"))
  ; le decine senza vocali - codeB1
  (setq dcn    '("" "" "Vent" "Trent" "Quarant" "Cinquant"
    "Sessant" "Settant" "Ottant" "Novant"))
  ; il numero 100
  (setq cento "Cento")
  ; multipli con la cifra 1 - codeC
  (setq multiplo '("" "Mille" "Milione" "Miliardo" "Bilione" "Biliardo"
    "Trilione" "Triliardo" "Quadrilione" "Quadriliardo"))
  ; multipli con la cifra diversa da 1 - codeC1
  (setq multipli '("" "Mila" "Milioni" "Miliardi" "Bilioni" "Biliardi"
    "Trilioni" "Triliardi" "Quadrilioni" "Quadriliardi"))

Poichè la lettura di un numero procede per gruppi di tre (partendo da sinistra) scriviamo una funzione che converte in lettere un numero con 3 cifre. I numeri con una o due cifre devono essere riempiti con degli zeri: 000,001,002,...,999.
L'algoritmo controlla a quale cifra si riferisce (unita, decine o centinaia) e crea la stringa relativa. La creazione della stringa avviene scegliendo la lista corretta in base al valore della cifra e verificando se la cifra vale 1 o 8.

(define (triple num)
  (local (lst res)
    (setq res "")
    ; lista delle cifre
    (setq lst (map int (explode (string num))))
    (dolist (el lst)
      (cond ((= el 0) nil)
            (true (cond ((= $idx 2) ; cifra unita ?
                          (if (!= 1 (lst 1)) ; ultime 2 cifre > 19 ?
                              (setq res (append res (cifre el)))))
                        ((= $idx 1) ; cifra decine ?
                          (if (= el 1) ; ultime 2 cifre < 20 ?
                            ; prendo il numero da 11 a 19
                            (setq res (append res (venti (+ 9 el (lst 2)))))
                            ; oppure prendo le decine
                            (if (or (= 1 (lst 2)) (= 8 (lst 2))) ; numero finisce con 1 o con 8?
                              ; prendo le decine senza vocale finale
                              (setq res (append res (dcn el)))
                              ; oppure prendo le decine con vocale finale
                              (setq res (append res (decine el))))))
                        ((= $idx 0) ; cifra centinaia ?
                          (if (= el 1) ; cifra centinaia = 1 ?
                              ; prendo solo "cento"
                              (setq res (append res cento))
                              ; prendo il numero e "cento"
                              (setq res (append res (venti el) cento))))
                  )
            )
      )
    )
    res
  )
)

Proviamo la funzione:

(triple "010")
;-> Dieci
(triple "070")
;-> "Settanta"
(triple "999")
;-> "NoveCentoNovantaNove"
(triple "007")
;-> "Sette"
(triple "000")
;-> ""
(triple 100)
;-> "Cento"
(triple "001")
;-> "Uno"
(triple "016")
;-> "Sedici"
(triple "020")
;-> Venti
(triple "011")
;-> "Undici"
(triple "071")
;-> "SettantUno"
(triple "021")
;-> "Ventuno"
(triple "088")
;-> "OttantOtto"

Adesso definiamo una funzione che formatta un numero. La funzione prende un numero da formattare in stringa, un numero che rappresenta la lunghezza della stringa finale e un carattere con cui viene riempita la stringa se il numero ha una lunghezza inferiore alla lunghezza della stringa finale.

(define (pad num len ch)
  (local (out)
    (setq out (string num))
    (while (> len (length out))
      (setq out (string ch out)))
  out
  )
)

(pad 1256 8 "0")
;-> "00001256"

(pad 124623 3 "0")
;-> "124623"

(pad 1 3 "0")
;-> "001"

Ora possiamo stampare tutti i numeri da 1 (uno) a 100 (cento):

(for (i 1 100) (println i { - } (triple (pad i 3 "0"))))
;-> 1 - Uno
;-> 2 - Due
;-> 3 - Tre
;-> 4 - Quattro
;-> 5 - Cinque
;-> 6 - Sei
;-> 7 - Sette
;-> 8 - Otto
;-> 9 - Nove
;-> 10 - Dieci
;-> 11 - Undici
;-> ...
;-> 89 - OttantaNove
;-> 90 - Novanta
;-> 91 - NovantUno
;-> 92 - NovantaDue
;-> 93 - NovantaTre
;-> 94 - NovantaQuattro
;-> 95 - NovantaCinque
;-> 96 - NovantaSei
;-> 97 - NovantaSette
;-> 98 - NovantaOtto
;-> 99 - NovantaNove
;-> 100 - Cento

La funzione finale utilizza la funzione "triple" e tiene conto del numero (indice) della tripla a cui si riferisce per la creazione della stringa risultato.

(define (numero num)
  (local (lst tri val out)
    (setq out "")
    (if (= (string num) "0")
      (setq out "zero")
      (begin
        ; calcola il numero di triplette
        (if (zero? (% (length (string num)) 3))
            (setq tri (/ (length (string num)) 3))
            (setq tri (+ (/ (length (string num)) 3) 1))
        )
        ; formatta in stringa il numero (padding)
        ; e crea una lista con tutte le triplette
        (setq lst (explode (pad (string num) (* 3 tri) "0") 3))
        ; ciclo per la creazione della stringa finale
        (dolist (el lst)
          ; creazione del numero rappresentato dalla tripletta
          (setq val (triple el))
          ; controllo se tale numero vale "Uno"
          (if (= val "Uno")
            (cond ((= $idx (- (length lst) 1)) ; primo gruppo a destra ?
                  (setq out (append out val))) ; aggiungo solo "Uno"
                  ((= $idx (- (length lst) 2)) ; secondo gruppo a destra ?
                  (setq out (string out (multiplo (- tri 1))))) ;aggiungo solo "Mille"
                  ;altrimenti aggiungo "Un" e il codice corrispondente
                  (true (setq out (string out "Un" (multiplo (- tri 1)))))
            )
            (if (!= val "") ; se la tripletta vale "000" --> val = ""
              (setq out (string out val (multipli (- tri 1)))))
          )
          (-- tri)
          ;(println (triple el))
        )
        out
      )
    )
  )
)

(numero "2001001")
;-> "DueMilioniMilleUno"
(numero "1000000")
;-> "UnMilione"
(numero "12345670")
;-> "DodiciMilioniTreCentoQuarantaCinqueMilaSeiCentoSettanta"
(numero "2401001024")
;-> "DueMiliardiQuattroCentoUnoMilioniMilleVentiQuattro"
(numero "1111111111")
;-> "UnMiliardoCentoUndiciMilioniCentoUndiciMilaCentoUndici"
(numero "888881")
;-> "OttoCentoOttantOttoMilaOttoCentoOttantUno"

(for (i 0 100) (println i { - } (numero i)))
;-> 0 - zero
;-> 1 - Uno
;-> 2 - Due
;-> 3 - Tre
;-> 4 - Quattro
;-> 5 - Cinque
;-> 6 - Sei
;-> 7 - Sette
;-> 8 - Otto
;-> 9 - Nove
;-> 10 - Dieci
;-> 11 - Undici
;-> ...
;-> 88 - OttantOtto
;-> 89 - OttantaNove
;-> 90 - Novanta
;-> 91 - NovantUno
;-> 92 - NovantaDue
;-> 93 - NovantaTre
;-> 94 - NovantaQuattro
;-> 95 - NovantaCinque
;-> 96 - NovantaSei
;-> 97 - NovantaSette
;-> 98 - NovantOtto
;-> 99 - NovantaNove
;-> 100 - Cento


--------------------------------------
Punto a destra o sinistra di una linea
--------------------------------------

Data una linea e un punto, determinare se il punto si trova a destra o a sinistra della linea.
Utilizziamo il prodotto vettoriale (cross-product) tra due vettori.
Se il prodotto è maggiore di zero, allora il punto si trova a sinistra della linea.
Se il prodotto è minore di zero, allora il punto si trova a destra della linea.
Se il prodotto è uguale a zero, allora il punto si trova sulla linea.

(cross (point-a point-b point-c)
  (((b.X - a.X)*(c.Y - a.Y) - (b.Y - a.Y)*(c.X - a.X))))

dove:
a = primo punto della linea
b = secondo punto della linea
c = punto da verificare

Nel caso in cui la linea è orizzontale:
Se il prodotto è maggiore di zero, allora il punto si trova sopra la linea.
Se il prodotto è minore di zero, allora il punto si trova sotto la linea.
Se il prodotto è uguale a zero, allora il punto si trova sulla linea.

Esempio:

      |         .
      |         .PL2
      |         O
      |         .
      |         .
      |         .      P4
      |         .     X
      |   P3    .
      |     X   .
      |         .
      |         .
      |    P1   .PL1
      |   X     O
      |         .        P2
      |         .       X
      |         .
   -------------.--------------------
      |         .

(setq PL1 '(5 2))
(setq PL2 '(5 8))
(setq P1 '(2 3))
(setq P2 '(9 1))
(setq P3 '(3 6))
(setq P4 '(8 7))

(define (sinistra? PL1 PL2 P)
  (local (pl1.x pl1.y pl2.x pl2.y p.x p.y)
    (setq pl1.x (first PL1) pl1.y (last PL1))
    (setq pl2.x (first PL2) pl2.y (last PL2))
    (setq p.x (first P) p.y (last P))
    (> (sub (mul (sub pl2.x pl1.x) (sub p.y pl1.y))
            (mul (sub pl2.y pl1.y) (sub p.x pl1.x))) 0)
  )
)

(sinistra? PL1 PL2 P1)
;-> true
(sinistra? PL1 PL2 P2)
;-> nil
(sinistra? PL1 PL2 P3)
;-> true
(sinistra? PL1 PL2 P4)
;-> nil


----------------------------------------------
Creazione di un poligono da una lista di punti
----------------------------------------------

Data una lista di punti, costruire un poligono semplice (non autointersecante) con tutti i punti.

Ordiniamo i punti in base all'angolo creato con l'asse X quando si traccia una linea attraverso il punto e il punto più basso a destra (sinistra).
Se due o più punti formano lo stesso angolo con l'asse X (cioè sono allineati rispetto al punto di riferimento), questi punti devono essere ordinati in base alla distanza dal punto di riferimento.

Di seguito il codice che implementa questo algoritmo:

Funzione di confronto angoli usata dalla funzione "sort":

(define (angleCompare a b)
  (local (left)
    (setq left (isLeft p0 a b))
    (if (= left 0)
      (distCompare a b);
      (> left 0)
    )
  )
)

Funzione di confronto distanze usata dalla funzione "sort":

(define (distCompare a b)
  (local (distA distB)
    (setq distA (add (mul (sub (first p0) (first a)) (sub (first p0) (first a)))
                    (mul (sub (last p0)  (last a))  (sub (last p0)  (last a)))))
    (setq distB (add (mul (sub (first p0) (first b)) (sub (first p0) (first b)))
                    (mul (sub (last p0)  (last b))  (sub (last p0)  (last b)))))
    (> distA distB)
  )
)

Funzione che ritorna la posizione di un punto rispetto ad una retta:

(define (isLeft p0 a b)
  (sub (mul (sub (first a) (first p0)) (sub (last b) (last p0)))
       (mul (sub (first b) (first p0)) (sub (last a) (last p0))))
)

(define (crea-poligono lst)
  (local (p0 hull out)
    ; trova il punto più in basso (e più a sinistra)
    (setq hull (lst 0))
    (for (i 1 (- (length lst) 1))
      (if (<= (last (lst i)) (last hull))
          (if (= (last (lst i)) (last hull))
              (if (> (first (lst i)) (first hull))
                  (setq hull (lst i)))
              (setq hull (lst i))
          )
      )
    )
    (setq p0 hull)
    ;(println hull)
    (sort lst angleCompare)
  )
)

Vediamo alcuni esempi:

Esempio 1:

(setq P1 '(0 0))
(setq P2 '(90 10))
(setq P3 '(30 40))
(setq P4 '(80 50))
(setq P5 '(50 60))
(setq P6 '(10 100))
(setq P7 '(20 20))
(setq P8 '(30 10))

(setq points (list P1 P2 P3 P4 P5 P6 P7 P8))

(setq lista (crea-poligono points))
;-> ((90 10) (30 10) (80 50) (20 20) (50 60) (30 40) (10 100) (0 0))

Per verificare il risultato scriviamo una funzione che crea un file postscript (che viene poi convertito con ghostscript tramite un programma batch):

(define (disegna lista-punti file)
  (local (xc yc punti)
    (module "postscript.lsp")
    ; setup iniziale
    ; creazione sfondo nero
    (ps:goto 0 0)
    (ps:fill-color 0 0 0)
    (ps:line-color 0 0 0)
    (ps:rectangle 612 792 true)
    ; tipo giunzione (1 = round)
    (ps:line-join 1)
    ; spessore linea
    (ps:line-width 0.25)
    ;colore linea
    (ps:line-color 220 220 220)
    ;colore riempimento
    (ps:fill-color 255 20 20)
    ; coordinate centro della pagina
    (setq xc (/ 612 2))
    (setq yc (/ 792 2))
    ; punti da tracciare
    (setq punti lista-punti)
    ; Inizia a disegnare dal centro pagina partendo dal primo punto
    (ps:goto (+ xc (first (punti 0))) (+ yc (last (punti 0))))
    ; Sposto il primo punto alla fine (chiusura del poligono)
    (push (pop punti) punti -1)
    ; Disegna il poligono
    (dolist (el punti)
      ; disegna linea dalla posizione corrente al punto passato come parametro
      (ps:drawto (+ xc (first el)) (+ yc (last el)))
      ; disegna un punto alla posizione corrente
      (ps:circle 1 true)
    )
    ; salva il file postscript
    ;(ps:save "poly.ps")
    (ps:save (string file ".ps"))
    ; conversione del file .ps al file .pdf (ghostscript)
    ;(! (string "ps2pdf poly.ps poly.pdf")
    (! (string "ps2pdf " file ".ps " file ".pdf"))
  )
)

Creiamo i file "poly-1.ps" e "poly-1.pdf":

(disegna lista "poly-1")

Esempio 2:

(setq P1 '(20 20))
(setq P2 '(40 80))
(setq P3 '(30 50))
(setq P4 '(50 10))
(setq P5 '(70 40))
(setq P6 '(70 70))
(setq P7 '(80 20))
(setq P8 '(30 10))

(setq points (list P1 P2 P3 P4 P5 P6 P7 P8))

(setq lista (crea-poligono points))
;-> ((80 20) (70 40) (70 70) (40 80) (30 50) (20 20) (30 10) (50 10))

Creiamo i file "poly-2.ps" e "poly-2.pdf":

(disegna lista "poly-2")

Esempio 3:

(setq P1 '(80 90))
(setq P2 '(50 90))
(setq P3 '(70 70))
(setq P4 '(40 70))
(setq P5 '(60 50))
(setq P6 '(80 30))
(setq P7 '(40 40))
(setq P8 '(20 30))
(setq P9 '(60 20))

(setq points (list P1 P2 P3 P4 P5 P6 P7 P8 P9))

(setq lista (crea-poligono points))
;-> ((80 30) (80 90) (70 70) (60 50) (50 90) (40 70) (40 40) (20 30) (60 20))

Creiamo i file "poly-3.ps" e "poly-3.pdf":

(disegna lista "poly-3")

Esempio 4:

(setq P1 '(20 20))
(setq P2 '(40 50))
(setq P3 '(100 20))
(setq P4 '(60 30))
(setq P5 '(80 50))

(setq points (list P1 P2 P3 P4 P5))

(setq lista (crea-poligono points))
;-> ((80 50) (40 50) (60 30) (20 20) (100 20))

Creiamo i file "poly-4.ps" e "poly-4.pdf":

(disegna lista "poly-4")

Esempio 5:

(setq P1 '(20 20))
(setq P2 '(40 80))
(setq P3 '(30 50))
(setq P4 '(50 10))
(setq P5 '(70 40))
(setq P6 '(70 70))
(setq P7 '(80 20))
(setq P8 '(30 10))
(setq P9 '(120 50))
(setq P10 '(50 40))

(setq points (list P1 P2 P3 P4 P5 P6 P7 P8 P9 P10))

(setq lista (crea-poligono points))
;-> ((80 20) (120 50) (70 40) (70 70) (50 40) (40 80) (30 50) (20 20) (30 10) (50 10))

Creiamo i file "poly-5.ps" e "poly-5.pdf":

(disegna lista "poly-5")

Nota: questo algoritmo non trova il percorso minimo tra i punti.


-------------------------------------
Percorso minimo di una lista di punti
-------------------------------------

Data una lista di punti, costruire il poligono (percorso chiuso) che ha lunghezza minima.

Questo problema assomiglia a quello del commesso viaggiatore (Travelling Salesman Problem), ma in questo caso, potenzialmente, ogni punto è connesso con tutti gli altri (grafo completo non orientato).
L'algoritmo che adottiamo è abbastanza brutale: generiamo tutte le permutazioni dei punti e calcoliamo la somma totale della distanza tra i punti per ogni permutazione. La permutazione che ha la distanza minima è la soluzione.
Questo metodo limita fortemente il numero di punti che possiamo analizzare in tempi accettabili.

Funzione per calcolare le permutazioni:

(define (perm lst)
  (local (i indici out)
    (setq indici (dup 0 (length lst)))
    (setq i 0)
    (setq out (list lst))
    (while (< i (length lst))
      (if (< (indici i) i)
          (begin
            (if (zero? (% i 2))
              (swap (lst 0) (lst i))
              (swap (lst (indici i)) (lst i))
            )
            ;(println lst);
            (push lst out -1)
            (++ (indici i))
            (setq i 0)
          )
          (begin
            (setf (indici i) 0)
            (++ i)
          )
       )
    )
    out
  )
)

(length (perm '(0 1 2 3 4 5 6 7)))
;-> 40320

Supponiamo di avere i seguenti punti.

Esempio 1:

(setq P1 '(0 0))
(setq P2 '(90 10))
(setq P3 '(30 40))
(setq P4 '(80 50))
(setq P5 '(50 60))
(setq P6 '(10 100))
(setq P7 '(20 20))
(setq P8 '(30 10))

(setq points (list P1 P2 P3 P4 P5 P6 P7 P8))

Funzione per calcolare il quadrato della distanza tra due punti (questo è sufficiente per il confronto tra due distanze):

(define (quad-dist p q)
  (add
    (mul (sub (first q) (first p)) (sub (first q) (first p)))
    (mul (sub (last q) (last p)) (sub (last q) (last p)))))

(quad-dist P2 P1)
;-> 8200
(quad-dist P3 P2)
;-> 4500

Adesso definiamo la funzione finale:

(define (tsp lst)
  (local (permutazioni sol points dist dist-min)
    ; creazione permutazioni dei punti
    (setq permutazioni (perm lst))
    ; distanza minima iniziale
    (setq dist-min '99999999)
    (dolist (p permutazioni)
      (setq dist 0)
      ; calcola somma della distanza tra tutti i punti di una permutazione
      (for (i 1 (- (length p) 1))
        (setq dist (add dist (quad-dist (p i) (p (- i 1)))))
      )
      ; aggiunge distanza tra ultimo e primo punto (percorso chiuso)
      (setq dist (add dist (quad-dist (p 0) (p (- (length p) 1)))))
      ;controllo distanza minima
      (if (< dist dist-min)
          (begin
            (setq dist-min dist)
            (setq sol p))
            ;(println p { } dist-min)
      )
    )
    sol
  )
)

Proviamo la funzione:

(setq lista (tsp points))
;-> ((0 0) (20 20) (30 40) (10 100) (50 60) (80 50) (90 10) (30 10))

Per verificare il risultato scriviamo una funzione che crea un file postscript (che viene poi convertito con ghostscript in pdf tramite un programma batch):

(define (disegna lista-punti file)
  (local (xc yc punti)
    (module "postscript.lsp")
    ; setup iniziale
    ; creazione sfondo nero
    (ps:goto 0 0)
    (ps:fill-color 0 0 0)
    (ps:line-color 0 0 0)
    (ps:rectangle 612 792 true)
    ; tipo giunzione (1 = round)
    (ps:line-join 1)
    ; spessore linea
    (ps:line-width 0.25)
    ;colore linea
    (ps:line-color 220 220 220)
    ;colore riempimento
    (ps:fill-color 255 20 20)
    ; coordinate centro della pagina
    (setq xc (/ 612 2))
    (setq yc (/ 792 2))
    ; punti da tracciare
    (setq punti lista-punti)
    ; Inizia a disegnare dal centro pagina partendo dal primo punto
    (ps:goto (+ xc (first (punti 0))) (+ yc (last (punti 0))))
    ; Sposto il primo punto alla fine (chiusura del poligono)
    (push (pop punti) punti -1)
    ; Disegna il poligono
    (dolist (el punti)
      ; disegna linea dalla posizione corrente al punto passato come parametro
      (ps:drawto (+ xc (first el)) (+ yc (last el)))
      ; disegna un punto alla posizione corrente
      (ps:circle 1 true)
    )
    ; salva il file postscript
    ;(ps:save "poly.ps")
    (ps:save (string file ".ps"))
    ; conversione del file .ps al file .pdf (ghostscript)
    ; ps2pdf.bat
    ;(! (string "ps2pdf poly.ps poly.pdf")
    (! (string "ps2pdf " file ".ps " file ".pdf"))
  )
)

Creiamo i file "tsp-1.ps" e "tsp-1.pdf":

(disegna lista "tsp-1")

Esempio 2:

(setq P1 '(20 20))
(setq P2 '(40 80))
(setq P3 '(30 50))
(setq P4 '(50 10))
(setq P5 '(70 40))
(setq P6 '(70 70))
(setq P7 '(80 20))
(setq P8 '(30 10))

(setq points (list P1 P2 P3 P4 P5 P6 P7 P8))

(setq lista (tsp points))
;-> ((20 20) (30 50) (40 80) (70 70) (70 40) (80 20) (50 10) (30 10))

Creiamo i file "tsp-2.ps" e "tsp-2.pdf":

(disegna lista "tsp-2")

Esempio 3:

(setq P1 '(80 90))
(setq P2 '(50 90))
(setq P3 '(70 70))
(setq P4 '(40 70))
(setq P5 '(60 50))
(setq P6 '(80 30))
(setq P7 '(40 40))
(setq P8 '(20 30))
(setq P9 '(60 20))

(setq points (list P1 P2 P3 P4 P5 P6 P7 P8 P9))

(setq lista (tsp points))
;-> ((80 30) (60 50) (70 70) (80 90) (50 90) (40 70) (40 40) (20 30) (60 20))

Creiamo i file "tsp-3.ps" e "tsp-3.pdf":

(disegna lista "tsp-3")

Esempio 4:

(setq P1 '(20 20))
(setq P2 '(40 50))
(setq P3 '(100 20))
(setq P4 '(60 30))
(setq P5 '(80 50))

(setq points (list P1 P2 P3 P4 P5))

(setq lista (tsp points))
;-> ((40 50) (20 20) (60 30) (100 20) (80 50))

Creiamo i file "tsp-4.ps" e "tsp-4.pdf":

(disegna lista "tsp-4")

Esempio 5:

(setq P1 '(20 20))
(setq P2 '(40 80))
(setq P3 '(30 50))
(setq P4 '(50 10))
(setq P5 '(70 40))
(setq P6 '(70 70))
(setq P7 '(80 20))
(setq P8 '(30 10))
(setq P9 '(120 50))
(setq P10 '(50 40))

(setq points (list P1 P2 P3 P4 P5 P6 P7 P8 P9 P10))

(time (setq lista (tsp points)))
;-> 37307.071

lista
;-> ((50 10) (30 10) (20 20) (30 50) (40 80) (70 70) (120 50) (80 20) (70 40) (50 40))

Creiamo i file "tsp-5.ps" e "tsp-5.pdf":

(disegna lista "tsp-5")

Nota: Con questo algoritmo possiamo calcolare al massimo dieci punti (altrimenti il calcolo delle permutazioni richiederebbe troppo tempo).


---------------------------
Utilizzo del protocollo ftp
---------------------------

newLISP mette a disposizione un modulo per il download e l'upload di file tramite il protocollo ftp.

Esempio:

; ftp: ftp://ftpzone.data
; remote folder: temp
; Utente    Password    Diritti
; ------    --------    -------
; user1     pwd1        lettura
; user2     pwd2        lettura/scrittura

; load ftp module
(module "ftp.lsp")

; primitive functions
;; (FTP:get <str-user-id> <str-password> <str-host> <str-dir> <str-file-name>)
;; (FTP:put <str-user-id> <str-password> <str-host> <str-dir> <str-file-name>)

(set 'FTP:debug-mode true)

; Upload file:

(FTP:put "user2" "pwd2" "ftpzone.data" "temp" "filename.ext")
;-> true

; Download file:

(FTP:get "user2" "pwd2" "ftpzone.data" "temp" "filename.ext")
;-> true


--------------------------------------
Normalizzazione di una lista di numeri
--------------------------------------

Supponiamo di avere una lista di numeri che devono essere trasformati in un altro sistema di coordinate. Ad esempio una lista di coordinate geografiche che devono essere convertite per poter essere visualizzate sullo schermo o stampate con un plotter (cioè nel sistema di riferimento che usa lo schermo o il plotter).
In questo caso le coordinate geografiche rappresentano un punto di coordinate (x, y) ovvero (long, lat). Quindi useremo una trasformazione lineare in due dimensioni (2D).
Nota: la trasformazione lineare può essere applicata solo se l'estensione della zona geografica è limitata, cioè se possiamo approssimare la zona geografica con un piano cartesiano (in altre parole se possiamo trascurare la curvatura terrestre).

Questa è la lista delle coordinate geografiche:

(setq geo '((12.41142785 43.66627426)
            (12.65043641 43.55027395)
            (12.67496872 43.62171555)
            (12.78785627 43.95023854)
            (12.83323383 43.70941544)
            (12.90976429 43.90989685)
            (12.93863011 43.49932483)))

Poichè le coordinate hanno 8 cifre significative, possiamo moltiplicarle per 1e8 (in modo da avere numeri interi).

(setq geo (map (fn (x) (list (int (mul (first x) 1e8)) (int (mul (last x) 1e8)))) geo))
;-> ((1241142785 4366627426)
;->  (1265043641 4355027395)
;->  (1267496872 4362171555)
;->  (1278785627 4395023854)
;->  (1283323383 4370941544)
;->  (1290976429 4390989685)
;->  (1293863011 4349932483))

(integer? (first (first geo)))
;-> true

(setq long (first (first geo)))
;-> 1241142785
(setq lat (last (first geo)))
;-> 4366627426

Le coordinate hanno i seguenti limiti:

 1200000000 <= long <= 1300000000  --> (1300000000 - 1200000000) = 100000000
 4200000000 <= lat <= 4300000000   --> (4300000000 - 4200000000) = 100000000

Poichè i limiti definiscono un quadrato (100000000 e 100000000), per mantenere i rapporti di proporzione dobbiamo convertire queste coordinate in un piano cartesiano quadrato (10x10 o 200x200 o 150x150 ecc.)

Supponiamo che i limiti delle coordinate piane siano (0,0) e (100,100).
Possiamo scrivere:

(setq long-min 1200000000)
(setq long-max 1300000000)
(setq lat-min 4200000000)
(setq lat-max 4300000000)
(setq x-min 0)
(setq x-max 100)
(setq y-min 0)
(setq y-max 100)

Calcoliamo il fattore di scala nelle due dimensioni x e y:

(setq scala-x (div (sub x-max x-min) (sub long-max long-min)))
;-> 1e-006
(setq scala-y (div (sub y-max y-min) (sub lat-max lat-min)))
;-> 1e-006

Adesso possiamo scrivere le formule di trasformazione da una coordinata geografica (geo-long, geo-lat) ad una coordinata piana (x, y):

x = (geo-long - long-min) * scala-x
y = (geo-lat  -  lat-min) * scala-y

Esempio:

Coordinata geografica da convertire:

(setq geo-long 1241142785)
(setq geo-lat 4366627426)

Formula di trasformazione:

(setq x (mul (sub geo-long long-min) scala-x))
;-> 41.142785
(setq y (mul (sub geo-lat lat-min) scala-y))
;-> 166.627426

Controlliamo la correttezza della trasformazione:

Punto di mezzo
(setq geo-long 1250000000)
(setq geo-lat 4250000000)
(setq x (mul (sub geo-long long-min) scala-x))
;-> 50
(setq y (mul (sub geo-lat lat-min) scala-y))
;-> 50

Punto iniziale
(setq geo-long 1200000000)
(setq geo-lat 4200000000)
(setq x (mul (sub geo-long long-min) scala-x))
;-> 0
(setq y (mul (sub geo-lat lat-min) scala-y))
;-> 0

Punto finale
(setq geo-long 1300000000)
(setq geo-lat 4300000000)
(setq x (mul (sub geo-long long-min) scala-x))
;-> 100
(setq y (mul (sub geo-lat lat-min) scala-y))
;-> 100

Vediamo ora il calcolo senza premoltiplicare le coordinate per 1e8:

(setq geo '((12.41142785 43.66627426)
            (12.65043641 43.55027395)
            (12.67496872 43.62171555)
            (12.78785627 43.95023854)
            (12.83323383 43.70941544)
            (12.90976429 43.90989685)
            (12.93863011 43.49932483)))
(setq long-min 12)
(setq long-max 13)
(setq lat-min 42)
(setq lat-max 43)
(setq x-min 0)
(setq x-max 100)
(setq y-min 0)
(setq y-max 100)
(setq scala-x (div (sub x-max x-min) (sub long-max long-min)))
(setq scala-y (div (sub y-max y-min) (sub lat-max lat-min)))
(setq x (mul (sub geo-long long-min) scala-x))
(setq y (mul (sub geo-lat lat-min) scala-y))

Punto iniziale
(setq geo-long 12)
(setq geo-lat 42)
(setq x (mul (sub geo-long long-min) scala-x))
;-> 0
(setq y (mul (sub geo-lat lat-min) scala-y))
;-> 0

Punto di mezzo
(setq geo-long 12.5)
(setq geo-lat 42.5)
(setq x (mul (sub geo-long long-min) scala-x))
;-> 50
(setq y (mul (sub geo-lat lat-min) scala-y))
;-> 50

Punto finale
(setq geo-long 13)
(setq geo-lat 43)
(setq x (mul (sub geo-long long-min) scala-x))
;-> 100
(setq y (mul (sub geo-lat lat-min) scala-y))
;-> 100

Abbiamo ottenuto gli stessi risultati.

La funzione che effettua la trasformazione ha i seguenti parametri:

1. lista delle coordinate (es. geo)
2. longitudine coordinata geografica minima  (es. 1200000000)
3. longitudine coordinata geografica massima (es. 1300000000)
4. latitudine  coordinata geografica minima  (es. 4200000000)
5. latitudine  coordinata geografica massima (es. 4300000000)
6. X minima coordinate piane
7. X massima coordinate piane
8. Y minima coordinate piane
9. Y massima coordinate piane

(define (trasf-coord punti long-min long-max lat-min lat-max x-min x-max y-min y-max)
  (local (x y scale-x scale-y out)
    (setq scala-x (div (sub x-max x-min) (sub long-max long-min)))
    (setq scala-y (div (sub y-max y-min) (sub lat-max lat-min)))
    (dolist (geo punti)
      (setq x (round (mul (sub (first geo) long-min) scala-x)))
      (setq y (round (mul (sub (last geo) lat-min) scala-y)))
      (push (list x y) out -1)
    )
  )
)

(setq geo '((12.41142785 43.66627426)
            (12.65043641 43.55027395)
            (12.67496872 43.62171555)
            (12.78785627 43.95023854)
            (12.83323383 43.70941544)
            (12.90976429 43.90989685)
            (12.93863011 43.49932483)))

(trasf-coord geo 12 13 42 43 0 100 0 100)
;-> ((41 167) (65 155) (67 162) (79 195) (83 171) (91 191) (94 150))


----------------------------
Trasformazione omografica 2D
----------------------------

Una omografia è una relazione tra punti di due spazi tali per cui ogni punto di uno spazio corrisponde ad uno ed un solo punto del secondo spazio. Si basa su concetti geometrici e matematici abbastanza complessi, noti come "coordinate omogenee" e "piani proiettivi", la cui spiegazione non rientra nell'ambito di questo documento.

Giusto per dare un'idea semplificata, il familiare "piano cartesiano" è composto da un insieme di punti che hanno una correlazione uno-a-uno con coppie di numeri reali, ovvero X-Y sui due assi. Il "piano proiettivo" invece è un superset di quel piano reale dove per ogni punto consideriamo anche tutte le possibili (infinite) rette verso lo spazio.

In questo scenario ogni punto 2D può essere proiettato su qualsiasi altro piano nello spazio.

Sulla base di questi concetti viene definita "omografia tra 2 piani" la trasformazione dei punti di un piano ad un altro piano.

La trasformazione omografica si basa sulle seguenti formule.

Formule di trasformazione omografica

     a*x + b*y + c              d*x + e*y + f
X = ---------------        Y = ---------------
     g*x + h*y + 1              g*x + h*y + 1

Dove X-Y sono le coordinate da calcolare nel secondo sistema di riferimento, date le coordinate x-y nel primo sistema di riferimento in funzione degli 8 parametri di trasformazione a, b, c, d, e, f, g, h.

a = fattore di scala fisso in direzione X con scala Y invariata.
b = fattore di scala in direzione X proporzionale alla distanza Y dall'origine.
c = traslazione dell'origine in direzione X.
d = fattore di scala in direzione Y proporzionale alla distanza X dall'origine.
e = fattore di scala fisso in direzione Y con scala X invariata.
f = traslazione dell'origine in direzione Y.
g = fattore di scala proporzionale X e Y in funzione di X.
h = fattore di scala proporzionale X e Y in funzione di Y.

Quindi, avendo queste 8 incognite, sono richiesti almeno 4 punti noti in entrambi i sistemi. In altre parole, dati 4 punti in un piano, esiste sempre una relazione che li trasforma nei corrispondenti 4 punti in un altro piano.

La trasformazione omografica viene utilizzata per la georeferenziazione di mappe oppure per correggere un'immagine prospettica (es. per generare una vista "in pianta" di un edificio da una foto "prospettica").

Le formule precedenti possono essere trasformate (tramite manipolazione algebrica) nella matrice di trasformazione omografica che ci consente di calcolare gli 8 parametri di trasformazione risolvendo il sistema lineare A*z = B.

Dati i quattro punti di partenza e i quattro punti di destinazione possiamo scrivere 8 equazioni:

        a*x(i) + b*y(i) + c                 d*x(i) + e*y(i) + f
X(i) = ---------------------        Y(i) = ---------------------
        g*x(i) + h*y(i) + 1                 g*x(i) + h*y(i) + 1

per 1 <= i <= 4

Queste 8 equazioni possono essere trasformate nel sistema lineare:

x1*a + y1*b + c - x1*X1*g - y1*X1*h = X1
x2*a + y2*b + c - x2*X2*g - y2*X2*h = X2
x3*a + y3*b + c - x3*X3*g - y3*X3*h = X3
x4*a + y4*b + c - x4*X4*g - y4*X4*h = X4
x1*d + y1*e + f - x1*Y1*g - y1*Y1*h = Y1
x2*d + y2*e + f - x2*Y2*g - y2*Y2*h = Y2
x3*d + y3*e + f - x3*Y3*g - y3*Y3*h = Y3
x4*d + y4*e + f - x4*Y4*g - y4*Y4*h = Y4

Che ha la seguente matrice di rappresentazione A*z = B:

| x1 y1  1  0  0  0 -x1*X1 -y1*X1 |   | a |   | X1 |
| x2 y2  1  0  0  0 -x2*X2 -y2*X2 |   | b |   | X2 |
| x3 y3  1  0  0  0 -x3*X3 -y3*X3 |   | c |   | X3 |
| x4 y4  1  0  0  0 -x4*X4 -y4*X4 | * | d | = | X4 |
|  0  0  0 x1 y1  1 -x1*Y1 -y1*Y1 |   | e |   | Y1 |
|  0  0  0 x2 y2  1 -x2*Y2 -y2*Y2 |   | f |   | Y2 |
|  0  0  0 x3 y3  1 -x3*Y3 -y3*Y3 |   | g |   | Y3 |
|  0  0  0 x4 y4  1 -x4*Y4 -y4*Y4 |   | h |   | Y4 |

matrice A:

  A[0][0] = x1  A[0][1] = y1  A[0][2] = 1  A[0][3] = 0   A[0][4] = 0   A[0][5] = 0  A[0][6] = -(X1*x1)  A[0][7] = -(X1*y1)
  A[1][0] = x2  A[1][1] = y2  A[1][2] = 1  A[1][3] = 0   A[1][4] = 0   A[1][5] = 0  A[1][6] = -(X2*x2)  A[1][7] = -(X2*y2)
  A[2][0] = x3  A[2][1] = y3  A[2][2] = 1  A[2][3] = 0   A[2][4] = 0   A[2][5] = 0  A[2][6] = -(X3*x3)  A[2][7] = -(X3*y3)
  A[3][0] = x4  A[3][1] = y4  A[3][2] = 1  A[3][3] = 0   A[3][4] = 0   A[3][5] = 0  A[3][6] = -(X4*x4)  A[3][7] = -(X4*y4)
  A[4][0] = 0   A[4][1] = 0   A[4][2] = 0  A[4][3] = x1  A[4][4] = y1  A[4][5] = 1  A[4][6] = -(Y1*x1)  A[4][7] = -(Y1*y1)
  A[5][0] = 0   A[5][1] = 0   A[5][2] = 0  A[5][3] = x2  A[5][4] = y2  A[5][5] = 1  A[5][6] = -(Y2*x2)  A[5][7] = -(Y2*y2)
  A[6][0] = 0   A[6][1] = 0   A[6][2] = 0  A[6][3] = x3  A[6][4] = y3  A[6][5] = 1  A[6][6] = -(Y3*x3)  A[6][7] = -(Y3*y3)
  A[7][0] = 0   A[7][1] = 0   A[7][2] = 0  A[7][3] = x4  A[7][4] = y4  A[7][5] = 1  A[7][6] = -(Y4*x4)  A[7][7] = -(Y4*y4)

matrice B (termini noti):

    B[0][0] = X1
    B[1][0] = X2
    B[2][0] = X3
    B[3][0] = X4
    B[4][0] = Y1
    B[5][0] = Y2
    B[6][0] = Y3
    B[7][0] = Y4

vettore incognite z:

    z[0] = a
    z[1] = b
    z[2] = c
    z[3] = d
    z[4] = e
    z[5] = f
    z[6] = g
    z[7] = h

Una volta calcolati questi 8 parametri (a, b, c, d, e, f, g, h) possiamo utilizzare le formule di trasformazione omografica per convertire qualsiasi punto dal primo sistema di riferimento al secondo.

Nota: I quattro punti iniziali devono essere non allineati a tre a tre (cioè non ci devono essere tre punti allineati).

Esempio:

       |
    13 |
    12 |                       #3
    11 |
    10 |
     9 |
     8 |                 #4
     7 |
     6 | o4      o3
     5 |
     4 |                         #2
     3 |
     2 |                   #1
     1 | o1     o2
   ---------------------------------------
       | 1 2 3 4 5 6 7 8 9 101112131415

I punti sono i seguenti:

Iniziale  --> Finale
o1 (1 1)  --> #1 (10 2)
o2 (5 1)  --> #2 (13 4)
o3 (5 5)  --> #3 (12 12)
o4 (1 5)  --> #4 (9 8)

(setq x1 1 y1 1)
(setq x2 5 y2 1)
(setq x3 5 y3 5)
(setq x4 1 y4 5)

(setq X1 10  Y1 2)
(setq X2 13 Y2 4)
(setq X3 12 Y3 12)
(setq X4 9  Y4 8)

Utilizziamo la seguente funzione per risolvere il sistema lineare:

(define (solve-linsys matrice noti)
  (local (dim detm det-i sol copia)
    (setq dim (length matrice))
    (setq sol '())
    (setq copia matrice)
    (setq detm (det copia))
    ; la soluzione è indeterminata se il determinante vale zero.
    (if (= detm 0) (setq sol nil)
    ;(println detm)
      (for (i 0 (- dim 1))
        (for (j 0 (- dim 1))
          (setf (copia j i) (noti j))
        )
        ; 0.0 -> "det" restituisce 0 (invece di nil),
        ; quando la matrice è singolare
        (setq det-i (det copia 0.0))
        (push (div det-i detm) sol -1)
        (setq copia matrice)
      );endfor
    );endif
    sol
  );local
)

(solve-linsys '((2 1 1) (4 -1 1) (-1 1 2)) '(1 -5 5))
 -> (-1 2 1)

Calcoliamo i parametri:

(setq r0 (list x1 y1  1  0  0  0 (- (mul x1 X1)) (- (mul y1 X1))))
(setq r1 (list x2 y2  1  0  0  0 (- (mul x2 X2)) (- (mul y2 X2))))
(setq r2 (list x3 y3  1  0  0  0 (- (mul x3 X3)) (- (mul y3 X3))))
(setq r3 (list x4 y4  1  0  0  0 (- (mul x4 X4)) (- (mul y4 X4))))
(setq r4 (list  0  0  0 x1 y1  1 (- (mul x1 Y1)) (- (mul y1 Y1))))
(setq r5 (list  0  0  0 x2 y2  1 (- (mul x2 Y2)) (- (mul y2 Y2))))
(setq r6 (list  0  0  0 x3 y3  1 (- (mul x3 Y3)) (- (mul y3 Y3))))
(setq r7 (list  0  0  0 x4 y4  1 (- (mul x4 Y4)) (- (mul y4 Y4))))
;-> (1 1 1 0 0 0 -10 -10)
;-> (5 1 1 0 0 0 -65 -13)
;-> (5 5 1 0 0 0 -60 -60)
;-> (1 5 1 0 0 0 -9 -45)
;-> (0 0 0 1 1 1 -2 -2)
;-> (0 0 0 5 1 1 -20 -4)
;-> (0 0 0 5 5 1 -60 -60)
;-> (0 0 0 1 5 1 -8 -40)

(setq matrix (list r0 r1 r2 r3 r4 r5 r6 r7))
;-> ((1 1 1 0 0 0 -10 -10)
;->  (5 1 1 0 0 0 -65 -13)
;->  (5 5 1 0 0 0 -60 -60)
;->  (1 5 1 0 0 0 -9 -45)
;->  (0 0 0 1 1 1 -2 -2)
;->  (0 0 0 5 1 1 -20 -4)
;->  (0 0 0 5 5 1 -60 -60)
;->  (0 0 0 1 5 1 -8 -40))

(setq noti (list X1 X2 X3 X4 Y1 Y2 Y3 Y4))
;-> (10 13 12 9 2 4 12 8)

(setq sol (solve-linsys matrix noti))
;-> (0.05000000000000014 -0.3833333333333334 9.666666666666666 0.2666666666666667 1.266666666666667
;->  0.3333333333333333 -0.04999999999999998 -0.01666666666666667)

(setq a (sol 0))
(setq b (sol 1))
(setq c (sol 2))
(setq d (sol 3))
(setq e (sol 4))
(setq f (sol 5))
(setq g (sol 6))
(setq h (sol 7))

Adesso possiamo trasformare qualunque punto dal sistema di riferimento iniziale al sistema di riferimento finale utilizzando le fornule di trasformazione omografica:

     a*x + b*y + c              d*x + e*y + f
X = ---------------        Y = ---------------
     g*x + h*y + 1              g*x + h*y + 1

(define (toX x y)
  (round (div (add (mul a x) (mul b y) c) (add (mul g x) (mul h y) 1)) -1))

(define (toY x y)
  (round (div (add (mul d x) (mul e y) f) (add (mul g x) (mul h y) 1)) -1))

Verifichiamo la trasformazione dei quattro punti iniziali:

(1 1)  -->  (10 2)
(5 1)  -->  (13 4)
(5 5)  -->  (12 12)
(1 5)  -->  (9 8)

(list (toX 1 1) (toY 1 1))
;-> (10 2)

(list (toX 5 1) (toY 5 1))
;-> (13 4)

(list (toX 5 5) (toY 5 5))
;-> (12 12)

(list (toX 1 5) (toY 1 5))
;-> (9 8)

Proviamo con altri punti:

(list (toX 3 3) (toY 3 3))
;-> (10.8 6.2)

(list (toX 5 3) (toY 5 3))
;-> (12.5 7.8)

Con questo metodo siamo in grado di prendere un file di coordinate geografiche (es. in formato geojson) e visualizzarlo sul monitor oppure creare un file postscript.


------------------------------------
Numeri primi successivi e precedenti
------------------------------------

Dato un numero intero n vogliamo determinare il primo numero primo successivo a n e il primo numero primo precedente a n.

Prima scriviamo la funzione che verifica se un numero è primo:

(define (primo? n)
  (if (< n 2) nil
      (= 1 (length (factor n)))))

Poi scriviamo due funzioni separate "primo+" e "primo-".

(define (primo+ num)
  (local (found val)
    (setq found nil)
    (setq val (+ num 1))
    (until found
      (if (primo? val)
          (setq found true)
          (++ val)
      )
    )
    val
  )
)

(primo+ 50)
;-> 53

(define (primo- num)
  (local (found val)
    (setq found nil)
    (setq val (- num 1))
    (until found
      (if (primo? val)
          (setq found true)
          (-- val)
      )
    )
    val
  )
)

(primo- 50)
;-> 47

(primo+ 2)
;-> 3


----------------------------
Giorno Giuliano (Julian day)
----------------------------

Il giorno giuliano (Julian Day, JD) è il numero di giorni passati dal mezzogiorno del lunedì 1 gennaio 4713 a.C. (-4712 1 1), che viene considerato il giorno 0 (zero) del calendario giuliano.
Il sistema dei giorni giuliani fornisce un singolo sistema di datazione che permette di lavorare con differenti calendari (in pratica è un metodo di normalizzazione delle date).

La formula per il calcolo del giorno giuliano è la seguente:

  JDN = (1461 × (Y + 4800 + (M − 14)/12))/4 + (367 × (M − 2 − 12 × ((M − 14)/12)))/12 − (3 × ((Y + 4900 + (M - 14)/12)/100))/4 + D − 32075

dove Y = Year  (anno)
     M = Month (mese)
     D = Day   (giorno)

Nota: le divisioni sono tutte intere, i resti vengono scartati.

Preferisco usare le formule (equivalenti) definite da Claus Tondering in "Calendar FAQ" e disponibili al seguente indirizzo web:

 https://stason.org/TULARC/society/calendars/index.html

In cui si trovano molte informazioni interessanti sulle date e sui vari calendari creati dall'uomo.

Vediamo l'algoritmo per il calcolo del giorno giuliano.

Calcolare le seguenti variabili ausiliarie:

  a = (14-month)/12
  y = year + 4800 - a
  m = month + 12*a - 3

Per una data nel calendario Gregoriano:

  JD = day + (153*m + 2)/5 + y*365 + y/4 - y/100 + y/400 - 32045

Per una data nel calendario Giuliano:

  JD = day + (153*m + 2)/5 + y*365 + y/4 - 32083

Il calendario Gregoriano viene utilizzato per le date che vanno dal 15 ottobre 1582 d.C. in avanti e il calendario Giuliano viene utilizzato per le date precedenti al 4 ottobre 1582.

Nota: Il calendario Giuliano non ha nulla in comune con il giorno giuliano.
Il calendario Giuliano fu introdotto da Giulio Cesare nel 45 AC ed era di uso comune fino al 1500, quando i paesi iniziarono ad utilizzare il calendario Gregoriano.

Scriviamo la funzione per il calcolo del numero del giorno giuliano partendo da una data del calendario Gregoriano:

(define (julian-g year month day)
  (local (a y m)
    (setq a (/ (- 14 month) 12))
    (setq y (+ year 4800 (- a)))
    (setq m (+ month (* 12 a) (- 3)))
    (+ day (/ (+ (* 153 m) 2) 5) (* y 365) (/ y 4) (- (/ y 100)) (/ y 400) (- 32045))
  )
)

(julian-g 2019 11 11)
;-> 2458799

(julian-g 2019 11 12)
;-> 2458800

Nota: per gli anni Avanti Cristo (Before Christ) occorre prima convertire l'anno A.C. in un anno negativo (es. 10 A.C. = -9).

Le "Idi di Marzo", il giorno dell'assassinio di Giulio Cesare avvenuto il 15 marzo del 44 A.C.

(julian-g -43 3 15)
;-> 1705428

Scriviamo la funzione per il calcolo del numero del giorno giuliano partendo da una data del calendario Giuliano:

(define (julian-j year month day)
  (local (a y m)
    (setq a (/ (- 14 month) 12))
    (setq y (+ year 4800 (- a)))
    (setq m (+ month (* 12 a) (- 3)))
    (+ day (/ (+ (* 153 m) 2) 5) (* y 365) (/ y 4) (- 32083))
  )
)

(julian-j 2019 11 11)
;-> 2458812

(julian-j 2019 11 12)
;-> 2458813

Verifichiamo il primo giorno del periodo giuliano:

(julian-j -4712 01 01)
;-> 0

Per convertire un giorno giuliano in una data del calendario Gregoriano o Giuliano utilizziamo il seguente algoritmo:

Per il calendario Gregoriano:

  a = JD + 32044
  b = (4*a + 3)/146097
  c = a - (b*146097)/4

Per il calendario Giuliano:

  a = 0
  b = 0
  c = JD + 32082

Poi, per entrambi i calendari:

  d = (4*c + 3)/1461
  e = c - (1461*d)/4
  m = (5*e + 2)/153

Infine calcoliamo la data:

  giorno = e - (153*m + 2)/5 + 1
  mese   = m + 3 - 12*(m/10)
  anno   = b*100 + d - 4800 + m/10

Scriviamo la funzione che converte da giorno giuliano a data Gregoriana (anno mese giorno):

(define (date-g JD)
  (local (a b c d e m)
    (setq a (+ JD 32044))
    (setq b (/ (+ (* 4 a) 3) 146097))
    (setq c (- a (/ (* b 146097) 4)))
    (setq d (/ (+ (* 4 c) 3) 1461))
    (setq e (- c (/ (* 1461 d) 4)))
    (setq m (/ (+ (* 5 e) 2) 153))
    (list
      (+ (* b 100) d (- 4800) (/ m 10))
      (+ m 3 (- (* 12 (/ m 10))))
      (+ e (- (/ (+ (* 153 m) 2) 5)) 1)
    )
  )
)

(julian-g 2019 11 11)
;-> 2458799
(date-g 2458799)
;-> (2019 11 11)

(julian-g 2019 11 12)
;-> 2458800
(date-g 2458800)
;-> (2019 11 12)

(julian-g -43 3 15)
;-> 1705428
(date-g 1705428)
;-> (-43 3 15)

Scriviamo la funzione che converte da giorno giuliano a data Giuliana (anno mese giorno):

(define (date-j JD)
  (local (a b c d e m)
    (setq a 0)
    (setq b 0)
    (setq c (+ JD 32082))
    (setq d (/ (+ (* 4 c) 3) 1461))
    (setq e (- c (/ (* 1461 d) 4)))
    (setq m (/ (+ (* 5 e) 2) 153))
    (list
      (+ (* b 100) d (- 4800) (/ m 10))
      (+ m 3 (- (* 12 (/ m 10))))
      (+ e (- (/ (+ (* 153 m) 2) 5)) 1)
    )
  )
)

(julian-j 2019 11 11)
;-> 2458812
(date-j 2458812)
;-> (2019 11 11)

(julian-j 2019 11 12)
;-> 2458813
(date-j 2458813)
;-> (2019 11 12)

(julian-j -4712 01 01)
;-> 0
(date-j 0)
;-> (-4712 1 1)

Adesso vediamo come trovare il giorno della settimana partendo da un giorno giuliano.

Sistema anglosassone
Se la settimana comincia (giorno 0) con la Domenica (Sunday), allora risulta:

  Sun Mon Tue Wed Thu Fri Sat
  Dom Lun Mar Mer Gio Ven Sab
   0   1   2   3   4   5   6

  giorno = mod(JD + 1, 7)

Sistema ISO internazionale
Se la settimana comincia (giorno 1) con il Lunedi (Monday), allora risulta:

  Mon Tue Wed Thu Fri Sat Sun
  Lun Mar Mer Gio Ven Sab Dom
   1   2   3   4   5   6   7

  giorno = mod(J, 7) + 1

(define (jd-day JD) (+ (% JD 7) 1))

(julian-g -43 3 15)
;-> 1705428
(date-g 1705428)
;-> (-43 3 15)
(jd-day 1705428)
;-> 5 ; Caio Giulio Cesare è morto di Venerdi

Le date formano uno spazio affine. Ciò significa che il risultato della sottrazione di due date non è un'altra data, ma piuttosto un intervallo di tempo. Ad esempio, il risultato della sottrazione del 1 gennaio 2013 dal 2 gennaio 2013 è l'intervallo di tempo di un giorno. Non è un'altra data.

In uno spazio affine, ci sono due tipi di oggetti, chiamati "punti" e "vettori". In questo caso i punti sono "date" e i vettori sono gli "intervalli" (numero di giorni). Con questi oggetti è possibile eseguire le seguenti operazioni:

Operazione                      Risultato
  data1 - data2                   intervallo
  data + intervallo               data
  data - intervallo               data
  intervallo1 + intervallo2       intervallo
  intervallo1 - intervallo2       intervallo

Si noti in particolare che non è possibile sommare due date.

Quindi con le funzioni che abbiamo definito (julian-g, date-g, jd-day ecc.) possiamo effettuare tutte le operazioni elencate sopra. Ad esempio, supponiamo di voler calcolare la differenza tra il 22 aprile 2010 e il 28 novembre 2012:

Calcoliamo il giorno giuliano per ognuna delle due date:

(setq jd1 (julian-g 2010 4 22))
;-> 2455309
(setq jd2 (julian-g 2012 11 28))
;-> 2456260

e poi calcoliamo la differenza:

(setq diff (- jd2 jd1))
;-> 951

Un altro esempio: che giorno della settimana sarà il natale del 2020 ?

(jd-day (julian-g 2020 12 25))
;-> 5 ;venerdi


-------------------------
Punto interno al poligono
-------------------------

Dato un poligono e un punto, determinare se il punto è interno o esterno al poligono.

Un metodo per verificare la presenza di un punto all'interno di una regione è il teorema della curva di Jordan. In sostanza, dice che un punto è all'interno di un poligono se, per qualsiasi raggio da questo punto, c'è un numero dispari di intersezioni del raggio con i segmenti (lati) del poligono. Questo vale per tutti i poligoni (concavi, convessi, con isole). Occorre considerare il caso particolare in cui il raggio interseziona uno o più vertici del poligono.

Esempio:

     |
  14 |           X---------X
     |          /           \
     |         /             \
  11 |        /         X-----X
     |       /          |
     |      /           |
   8 |     X     p1     X
     |      \           /
   6 |    p2 \         /
     |        \       /
     |         \     /
     |          \   /
     |           \ /
   1 |            X
     |
  ---------------------------------
     |     5     12     18 21 24

Rappresentazione degli oggetti punto e poligono:

pnt -> (x y)

poly ((x0 y0) (x1 y1) (x2 y2) (x3 y3) ... (xn yn))

Definiamo prima la funzione:

(define (point-in-polygon? pnt poly)
  (local (numpoint i j res)
    (setq numpoint (length poly))
    (setq res nil)
    (setq i 0)
    (setq j (- numpoint 1))
    (while (< i numpoint)
      (if (and (!= (> (last (poly i)) (last pnt)) (> (last (poly j)) (last pnt)))
               (< (first pnt)
                  (add (div (mul (sub (first (poly j)) (first (poly i)))
                                 (sub (last pnt) (last (poly i))))
                            (sub (last (poly j)) (last (poly i))))
                       (first (poly i)))))
          (setq res (not res))
      )
      (setq j i)
      (setq i (+ i 1))
    )
    ; check if point is equal to a vertex of polygon
    (dolist (el poly)
      (if (and (= (first el) (first pnt))
               (= (last el) (last pnt)))
          (setq res true)))
    res
  )
)

Altra versione con variabili ausiliarie:

(define (point-in-polygon? pnt poly)
  (local (numpoint i j res a b)
    (setq numpoint (length poly))
    (setq res nil)
    (setq i 0)
    (setq j (- numpoint 1))
    (while (< i numpoint)
      (setq a (mul (sub (first (poly j)) (first (poly i)))
                   (sub (last pnt) (last (poly i)))))
      (setq b (sub (last (poly j)) (last (poly i))))
      (if (and (!= (> (last (poly i)) (last pnt)) (> (last (poly j)) (last pnt)))
               (< (first pnt) (add (div a b) (first (poly i)))))
          (setq res (not res))
      )
      (setq j i)
      (setq i (+ i 1))
    )
    ; check if point is equal to a vertex of polygon
    (dolist (el poly)
      (if (and (= (first el) (first pnt))
               (= (last el) (last pnt)))
          (setq res true)))
    res
  )
)


Poligono:
(setq poligono '((12 1) (5 8) (12 14) (21 14) (24 11) (18 11) (18 8)))
(setq poligono '((12 1) (5 8) (12 14) (21 14) (24 11) (18 11) (18 8) (12 1)))

Punto interno p1:
(setq p1 '(12 8))

Punto esterno P2:
(setq p2 '(5 6))

(point-in-polygon? p1 poligono)
;-> true

(point-in-polygon? p2 poligono)
;-> nil

(point-in-polygon? '(21 12) poligono)
;-> true

(point-in-polygon? '(12 11) poligono)
;-> true

(point-in-polygon? '(21 10) poligono)
;-> nil

(point-in-polygon? '(5 11) poligono)
;-> nil

I punti del poligono appartengono al poligono:

(point-in-polygon? '(5 8) poligono)
;-> true

(point-in-polygon? '(21 14) poligono)
;-> true

(point-in-polygon? '(12 1) poligono)
;-> true

Spiegazione rapida:
Supponendo che il punto si trovi sulla coordinata y, la funzione calcola semplicemente le posizioni x in cui ciascuna dei lati (non orizzontali) del poligono interseziona con y. Conta il numero di posizioni x che sono inferiori alla posizione x del tuo punto. Se il numero di posizioni x è dispari, il punto è all'interno del poligono.
Un altro modo di visualizzare questo metodo: tracciamo una linea dall'infinito direttamente al tuo punto. Quando questa linea attraversa un lato del poligono siamo all'interno del poligono. Quando attraversiamo di nuovo un lato del poligono, allora siamo fuori. Nuova intersezione, dentro... e così via.

Spiegazione approfondita:

https://stackoverflow.com/questions/8721406/how-to-determine-if-a-point-is-inside-a-2d-convex-polygon

Il metodo esamina un "raggio" che inizia nel punto testato e si estende all'infinito sul lato destro dell'asse X. Per ogni segmento poligonale, controlla se il raggio lo attraversa. Se il numero totale di attraversamenti di segmenti è dispari, il punto testato viene considerato all'interno del poligono, altrimenti è esterno.

Per capire come viene calcolata la traversata, considerare la seguente figura:

              v2
              o
             /
            / c (intersezione)
  o -------- x ----------------------> all'infinito
  t       /
         /
        /
       o
       v1

Affinché si verifichi l'intersezione, test.y deve essere compreso tra i valori y dei vertici del segmento (v1 e v2). Questa è la prima condizione dell'istruzione if nel metodo. In questo caso, la linea orizzontale deve intersecare il segmento. Resta solo da stabilire se l'intersezione avviene alla destra del punto testato o alla sua sinistra. Ciò richiede di trovare la coordinata x del punto di intersezione, che è:

              t.y - v1.y
c.x = v1.x + ----------- * (v2.x - v1.x)
             v2.y - v1.y

Tutto ciò che resta da fare è esaminare i casi particolari:

Se v1.y == v2.y il raggio percorre il segmento e quindi il segmento non ha influenza sul risultato. In effetti, la prima parte dell'istruzione if restituisce false in quel caso.
Il codice moltiplica prima e solo successivamente divide. Questo viene fatto per supportare differenze molto piccole tra v1.x e v2.x, che potrebbero portare a uno zero dopo la divisione, a causa dell'arrotondamento.

Poi, viene il problema dell'incrocio esattamente su un vertice. Considera i seguenti due casi:

           o                    o
           |                     \     o
           | A1                C1 \   /
           |                       \ / C2
  o--------x-----------x------------x--------> all'infinito
          /           / \
      A2 /        B1 /   \ B2
        /           /     \
       o           /       o
                  o

Ora, per verificare se funziona, occorre controllare cosa viene restituito per ciascuno dei 4 segmenti dalla condizione if nel corpo del metodo. Scopriamo che i segmenti sopra il raggio (A1, C1, C2) ricevono un risultato positivo, mentre quelli sotto di esso (A2, B1, B2) ricevono un risultato negativo. Ciò significa che il vertice A contribuisce con un numero dispari (1) al conteggio dei passaggi, mentre B e C contribuiscono con un numero pari (0 e 2, rispettivamente), che è esattamente ciò che si desidera. A è davvero un vero incrocio del poligono, mentre B e C sono solo due casi di "sorvolo".

Infine viene verificato il caso in cui il punto è uguale ad uno dei vertici del poligono.

Vedi anche:

https://stackoverflow.com/questions/217578/how-can-i-determine-whether-a-2d-point-is-within-a-polygon


-------------------
Prodotto cartesiano
-------------------

In matematica il prodotto cartesiano di due insiemi A e B è l'insieme delle coppie ordinate (a,b) con a in A e b in B:

A x B = [(a,b): a in A e b in B]

Per esempiop, date due liste A = (1 2) e B = (3 4) il loro prodotto cartesiano vale:

(1 2) x (3 4) = ((1 3) (1 4) (2 3) (2 4))

cioè tutte le coppie formate dall'unione di ogni elemento della lista A con ogni elemento della lista B.

Nota: Il prodotto cartesiano non è commutativo: (A x B) != (B x A)

La funzione per calcolare il prodotto cartesiano di due liste è la seguente:

(define (cp lst1 lst2)
  (let (out '())
    (if (or (null? lst1) (null? lst2))
        nil
        (dolist (el1 lst1)
          (dolist (el2 lst2)
            (push (list el1 el2) out -1))))))

(cp '(1 2) '(3 4))
;-> ((1 3) (1 4) (2 3) (2 4))

(cp '(3 4) '(1 2))
;-> ((3 1) (3 2) (4 1) (4 2))

(cp '(1 2) '())
;-> nil

(cp '() '(1 2))
;-> nil

(cp '(1 2 3) '(4 5))
;-> ((1 4) (1 5) (2 4) (2 5) (3 4) (3 5))

Il prodotto cartesiano può essere esteso alla composizione di n insiemi considerando l'insieme delle n-uple ordinate:

A1 x A2 x ... x An = [(a1,a2,...,an): a(i) in A(i) per i=1..n]

Il prodotto cartesiano è naturalmente associativo:

A1 x A2 x ... x An = A1 x (A2 x ... x An)

Per calcolare il prodotto cartesiano di più liste (comunque racchiuse in una lista) potremmo applicare la funzione "apply":

(apply cp '((1 2) (3 4) (5 6)) 2)
;-> (((1 3) 5) ((1 3) 6) ((1 4) 5) ((1 4) 6) ((2 3) 5) ((2 3) 6) ((2 4) 5) ((2 4) 6))

Il risultato è corretto, dobbiamo solo togliere le parentesi ad ogni elemento della lista:

((1 3) 5) --> (1 3 5)
((1 3) 6) --> (1 3 6)
((1 4) 5) --> (1 4 5)
...
((2 4) 6) --> (2 4 6)

Scriviamo la funzione che calcola il prodotto cartesiano di tutte le sotto-liste di una lista:

(define (prodotto-cartesiano lst-lst)
  (let (out '())
    (dolist (el (apply cp lst-lst 2))
      (push (flat el) out -1))))

(prodotto-cartesiano '((1 2) (3 4) (5 6)))
;-> ((1 3 5) (1 3 6) (1 4 5) (1 4 6) (2 3 5) (2 3 6) (2 4 5) (2 4 6))

(prodotto-cartesiano '((1 2 3) (4) (5 6)))
;-> ((1 4 5) (1 4 6) (2 4 5) (2 4 6) (3 4 5) (3 4 6))

(prodotto-cartesiano '((1 5) (2 6) (3 7) (4 8 9)))
;-> ((1 2 3 4) (1 2 3 8) (1 2 3 9) (1 2 7 4) (1 2 7 8) (1 2 7 9) (1 6 3 4)
;->  (1 6 3 8) (1 6 3 9) (1 6 7 4) (1 6 7 8) (1 6 7 9) (5 2 3 4) (5 2 3 8)
;->  (5 2 3 9) (5 2 7 4) (5 2 7 8) (5 2 7 9) (5 6 3 4) (5 6 3 8) (5 6 3 9)
;->  (5 6 7 4) (5 6 7 8) (5 6 7 9))

(prodotto-cartesiano '((1 2 3) (1) (500 100)))
;-> ((1 1 500) (1 1 100) (2 1 500) (2 1 100) (3 1 500) (3 1 100))

(prodotto-cartesiano '((1 2) (3 4)))
;-> ((1 3) (1 4) (2 3) (2 4))

Da notare che i risultati sono diversi nel caso di liste annidate:

(cp '(1 2 (3 4)) '((4 (3)) (5) (6)))
;-> ((1 (4 (3))) (1 (5)) (1 (6)) (2 (4 (3))) (2 (5))
;-> (2 (6)) ((3 4) (4 (3))) ((3 4) (5)) ((3 4) (6)))

(prodotto-cartesiano '((1 2 (3 4)) ((4 (3)) (5) (6))))
;-> ((1 4 3) (1 5) (1 6) (2 4 3) (2 5) (2 6) (3 4 4 3) (3 4 5) (3 4 6))
(prodotto-cartesiano '((1 2 3 4) (4 3 5 6)))
;-> ((1 4) (1 3) (1 5) (1 6) (2 4) (2 3) (2 5) (2 6)
;-> (3 4) (3 3) (3 5) (3 6) (4 4) (4 3) (4 5) (4 6))

Prodotto cartesiano di funzioni
-------------------------------
Se f è una funzione da A in B e g una funzione da C in }D, si definisce come loro prodotto cartesiano e si denota con f x g la funzione da A x C in B x D data da:

[f x g](a,c) = [f(a), g(c)]

(Abbiamo distinto le parentesi che delimitano argomenti di funzione () dalle parentesi che delimitano coppie ordinate [])

Esempio:

(define (pcf f g lst1 lst2)
  (let (out '())
    (if (or (null? lst1) (null? lst2))
        nil
        (dolist (el1 lst1)
          (dolist (el2 lst2)
            (push (list (f el1) (g el2)) out -1))))))

(define (f x) x)
(define (g x) (* x x))

(pcf f g (sequence 1 3) (sequence 1 3))
;-> ((1 1) (1 4) (1 9) (2 1) (2 4) (2 9) (3 1) (3 4) (3 9))


------------------------------
Insieme delle parti (powerset)
------------------------------

Dato un insieme L, l'insieme delle parti di L, scritto P(L), è l'insieme di tutti i sottoinsiemi di L. Questa collezione di insiemi viene anche detta insieme potenza di L.
Se l'insieme L ha n elementi, allora l'insieme delle parti ha 2^n elementi.

Esempio:
(setq L '(1 2 3))
(powerset-i L)
;-> ((3 2 1) (3 2) (3 1) (3) (2 1) (2) (1) ())
(length (powerset-i L))
;-> 8

Scriviamo una funzione ricorsiva cha calcola l'insieme potenza:

(define (powerset lst)
  (if (empty? lst)
      (list '())
      (let ( (element (first lst))
             (p (powerset (rest lst))))
           (append (map (fn (subset) (cons element subset)) p) p) )))

(powerset '(a b c))
;-> ((a b c) (a b) (a c) (a) (b c) (b) (c) ())

Adesso scriviamo una funzione iterativa cha calcola l'insieme potenza:

(define (powerset-i lst)
  (define (loop res s)
    (if (empty? s)
      res
      (loop (append (map (lambda (i) (cons (first s) i)) res) res) (rest s))))
  (loop '(()) lst))

Vediamo la differenza di velocità tra le due funzioni:

(time (powerset '(1 2 3 4 5 6 7 8 9 10 15 16)) 1000)
;-> 2906.498

(time (powerset-i '(1 2 3 4 5 6 7 8 9 10 15 16)) 1000)
;-> 3672.166


-----------------
Terne pitagoriche
-----------------

Una terna pitagorica è costituita da tre numeri interi positivi a, b e c con a < b < c tale che a^2 + b^2 = c^2. Ad esempio, i tre numeri 3, 4 e 5 formano una tripla pitagorica perché 3^2 + 4^2 = 9 + 16 = 25 = 5^2.

Scrivere una funzione per generare tutte le terne pitagoriche.

Esistono diversi metodi per generare le terne pitagoriche ad esempio l'algoritmo di Hall:

Se (a b c) è una terna pitagorica primitiva, allora lo sono anche:

  (a – 2b + 2c,  2a – b + 2c,  2a – 2b + 3c)

  (a + 2b + 2c,  2a + b + 2c,  2a + 2b + 3c)

  (-a + 2b + 2c, 2a + b + 2c, -2a + 2b + 3c)

Comunque per generare tutte le terne pitagoriche useremo il metodo di Dickson:

Per trovare soluzioni intere a x^2 + y^2 = z^2, trovare degli interi positivi r, s, t tali che r^2 = 2st sia un quadrato perfetto.
Quindi calcolare la terna pitagorica (x y z):

  x = r + s, y = r + t, z = r + s + t

Notiamo che r è un numero intero pari e che s e t sono fattori di (r ^ 2) / 2. Tutte le terne pitagoriche possono essere trovate con questo metodo. Quando s e t sono coprimi, la terna viene detta primitiva.

Nota: Una terna (x y z) viene detta primitiva quando x e y sono coprimi. Una terna primitiva (x y z) genera infinite terne non primitive moltiplicando i termini per un qualunque numero intero positivo n.

Esempio:

Terna primitiva: (3 4 5)       n
Terna non primitiva: (3 4 5) * 2 ==> (6 8 10)
Terna non primitiva: (3 4 5) * 3 ==> (9 12 15)
...

Il metodo di Dickson genera tutte le terne pitagoriche, anche quelle simmetriche (quelle in cui vengono scambiati i valori di x e y). Esempio: (3 4 5) e (4 3 5) sono due terne pitagoriche distinte.

La seguente funzione restituisce n terne pigatoriche:

(define (terne n)
  (local (a b c r f1 f2 idx somma continua out)
    (setq r 2)
    (setq f1 1)
    (setq idx 0)
    (while (< idx n)
      (setq continua true)
      (while continua
      ; calcola i fattori s (f1) e t (f2) del prossimo r^2/2
      ; e inserisci l'equazione per s e t
        (cond ((zero? (% (/ (* r r) 2) f1))
                (setq f2 (/ (/ (* r r) 2) f1))
                (setq a (+ r f1))
                (setq b (+ r f2))
                (setq c (+ r f1 f2))
                (++ f1)
                (setq continua nil)
                (push (list a b c) out -1))
                ; se f1 è maggiore di r^2/2, passa alla r successiva
                ; e imposta il fattore f1 a 1
              ((= f1 (+ (/ (* r r) 2) 1))
                (setq r (+ r 2))
                (setq f1 1))
              (true (++ f1))
        )
      )
      (++ idx)
    )
    out))

Calcoliamo le prime venti terne pitagoriche (primitive e non primitive):

(terne 20)
;-> ((3 4 5) (4 3 5) (5 12 13) (6 8 10) (8 6 10) (12 5 13) (7 24 25)
;->  (8 15 17) (9 12 15) (12 9 15) (15 8 17) (24 7 25) (9 40 41)
;->  (10 24 26) (12 16 20) (16 12 20) (24 10 26) (40 9 41) (11 60 61)
;->  (12 35 37))

Se vogliamo estrarre solo le terne primitive usiamo la funzione "filter" con il seguente predicato che verifica se i primi due numeri di una terna sono coprimi:

(define (coprimi? lst) (= (gcd (first lst) (first (rest lst))) 1))

(coprimi? '(3 4 5))
;-> true

Estraiamo solo le terne primitive:

(filter coprimi? (terne 20))
;-> ((3 4 5) (4 3 5) (5 12 13) (12 5 13) (7 24 25) (8 15 17) (15 8 17)
;->  (24 7 25) (9 40 41) (40 9 41) (11 60 61) (12 35 37))

Se vogliamo eliminare le terne simmetriche possiamo ordinare tutte le terne e poi rimuovere tutti i duplicati:

(unique (map (fn(x) (sort x)) (filter coprimi? (terne 20))))
;-> ((3 4 5) (5 12 13) (7 24 25) (8 15 17) (9 40 41) (11 60 61) (12 35 37))


---------------------------------
Calcolo di e con il metodo spigot
---------------------------------

Definiamo una funzione che calcola il numero di Eulero usando l'algoritmo di Rabinowitz e Wagon.

Il numero di Eulero "e" vale (con 500 cifre dopo la virgola):

2.71828182845904523536028747135266249775724709369995957496696762772407663
0353547594571382178525166427427466391932003059921817413596629043572900334
2952605956307381323286279434907632338298807531952510190115738341879307021
5408914993488416750924476146066808226480016847741185374234544243710753907
7744992069551702761838606261331384583000752044933826560297606737113200709
3287091274437470472306969772093101416928368190255151086574637721112523897
844250569536967707854499699679468644549059879316368892300987931

Di seguito lo pseudo-codice dell'algoritmo come riportato nell'articolo di Rabinowitz e Wagon:

Algorithm e-spigot:

1. Initialize:
   Let the first digit be 2 and
   initialize an array A of length n + 1 to (1, 1, 1, . . . , 1).
2. Repeat n − 1 times:
   Multiply by 10: Multiply each entry of A by 10.
   Take the fractional part: Starting from the right,
                             reduce the ith entry of A modulo i + 1,
                             carrying the quotient one place left.
   Output the next digit: The final quotient is the next digit of e.

Questa è l'implementazione in newLISP:

(define (spigot-e n)
  (local (vec cifra out)
    (setq out '())
    ; vettore con n elementi tutti di valore 1
    (setq vec (array n '(1)))
    (for (i 0 (- n 1))
      (setq cifra 0)
      (for (j (- n 1) 0 -1)
        (setf (vec j) (+ (* 10 (vec j)) cifra))
        (setq cifra (/ (vec j) (+ j 2)))
        (setf (vec j) (% (vec j) (+ j 2)))
      )
      (push cifra out -1))
    out))

(spigot-e 10)
;-> (7 1 8 2 8 1 8 2 6 1)

Un aspetto negativo di questo algoritmo è che le ultime cifre calcolate non sono corrette (soprattutto quando calcoliamo poche cifre). Questo problema può essere risolto in maniera pratica calcolando più cifre di quelle necessarie, in quanto l'algoritmo è molto veloce (calcolando 50 cifre in più siamo al sicuro fino a miliardi di cifre...).

Calcoliamo il numero "e" con 500 cifre dopo la virgola:

(join (map string (spigot-e 499)))
;-> "7182818284590452353602874713526624977572470936999595749669676277240766303535475945713821785251664274274663919320030599218174135966290435729003342952605956307381323286279434907632338298807531952510190115738341879307021540891499348841675092447614606680822648001684774118537423454424371075390777449920695517027618386062613313845830007520449338265602976067371132007093287091274437470472306969772093101416928368190255151086574637721112523897844250569536967707854499699679468644549059879316368892300987931"

In questo caso tutte le cifre sono corrette.


-----------
Calcolo IVA
-----------

Due funzioni per calcolare l'IVA (Imposta Valore Aggiunto) e per scorporare l'IVA.

(define (iva+ value iva-perc)
  (mul value (add 1 (div iva-perc 100))))

(iva+ 100 20)
;-> 120

(iva+ 80 20)
;-> 96

(define (iva- value iva-perc)
  (div value (add 1 (div iva-perc 100))))

(iva- 96 20)
;-> 80


-----------------------
Numeri casuali distinti
-----------------------

Generare una lista ordinata con N numeri casuali distinti tra loro compresi tra "a" e "b".

Usiamo la funzione "rand-range" per generare un numero compreso tra "a" e "b":

(define (rand-range a b)
  (if (> a b) (swap a b))
  (+ a (rand (+ (- b a) 1))))

Crea una lista con tutti i valori di una hashmap:

(define (getValues hash)
  (local (out)
    (dolist (cp (hash))
      (push (cp 1) out -1)
    )
  out))

Poi scriviamo la funzione richiesta:

(define (sample n a b)
  (local (value out)
    ; creazione di un hashmap
    (new Tree 'hset)
    (until (= (length (hset)) n)
      ; genera valore casuale
      (setq value (rand-range a b))
      ; inserisce valore casuale nell'hash
      (hset (string value) value))
      ; assegnazione dei valori dell'hasmap ad una lista
      (setq out (getValues hset))
      ; eliminazione dell'hashmap
      (delete 'hset)
      (sort out)))

(sample 50 1 1000)
;-> (52 58 71 97 103 107 111 128 131 135 160 203 219 221
;->  225 240 284 291 294 301 307 324 397 416 428 474 530
;->  547 623 651 744 763 773 779 790 807 821 826 837 839
;->  851 859 875 921 930 936 965 970 980 988)

Nota: La chiamata (sample 50 1 25) non termina mai. Per correttezza dovremmo inserire un controllo che verifica se "n" è maggiore di "(b - a + 1)", nel qual caso non esiste una lista con 50 numeri diversi con un intervallo minore della dimensione della lista. Il caso limite è quando risulta n = (b - a + 1):

(sample 10 1 10)
;-> (1 2 3 4 5 6 7 8 9 10)

Invece la seguente chiamata non termina mai:

(sample 10 1 9)
Premere Ctrl+C per fermare l'elaborazione...
;-> ERR: received SIGINT - in function length
;-> called from user function (sample 10 1 9)>

Riscriviamo la funzione inserendo il controllo:

(define (sample n a b)
  (local (value out)
    (cond ((> n (+ b (- a) 1)) '()) ; controllo
          (true
            ; creazione di un hashmap
            (new Tree 'hset)
            (until (= (length (hset)) n)
              ; genera valore casuale
              (setq value (rand-range a b))
              ; inserisce valore casuale nell'hash
              (hset (string value) value))
              ; assegnazione dei valori dell'hasmap ad una lista
              (setq out (getValues hset))
              ; eliminazione dell'hashmap
              (delete 'hset)
              (sort out)))))

(sample 10 1 10)
;-> (1 2 3 4 5 6 7 8 9 10)

Adesso quando risulta n > (b - a + 1) la funzione restituisce la lista vuota:

(sample 10 1 9)
;-> ()

Un metodo generico per estrarre n elementi casuali diversi da una lista di elementi è quello di mischiare gli elementi della lista e poi prendere i primi n:

(define (samples num lst)
  (if (> num (length lst)) '()
      (sort (slice (randomize lst) 0 num ))))

(samples 5 (sequence 1 10))
;-> (1 2 5 8 10)

(samples 11 (sequence 1 10))
;-> (1 2 3 4 5 6 7 8 9 10)

(samples 5 (explode "abcdefghijklmnopqrstuvwxyz"))
;-> ("a" "f" "m" "n" "t")

Questo metodo è molto veloce, ma richiede una lista con tutti gli elementi.


-----------------------------------------------------
Numeri casuali con distribuzione discreta predefinita
-----------------------------------------------------

Supponiamo di voler generare uno dei seguenti eventi (a b c d) con le seguenti probabilità associate (0.05 0.15 0.35 0.45). In altre parole, se generiamo 1000 eventi la distribuzione deve essere uguale a quella predefinita: 50 a, 150 b, 350 c e 450 d (più o meno).

Nota: la somma delle probabilità deve valere 1.0.

Definiamo gli intervalli:

1) (0.00, 0.05) --> probabilità 5%
2) (0.05, 0.20) --> probabilità 15% (0.20 = 0.05 + 0.15)
3) (0.20, 0.55) --> probabilità 35% (0.55 = 0.20 + 0.35)
4) (0.55, 1.00) --> probabilità 45% (1.00 = 0.55 + 0.45)

(setq intervalli '(0.0 0.05 0.2 0.55 1.0))

Adesso generiamo un numero casuale R:

- se R cade nell'intervallo 1 [0.00, 0.05],
  allora si verifica l'evento "a" --> indice 0
- se R cade nell'intervallo 2 (0.05, 0.20],
  allora si verifica l'evento "b" --> indice 1
- se R cade nell'intervallo 3 (0.20, 0.55],
  allora si verifica l'evento "c" --> indice 2
- se R cade nell'intervallo 4 (0.55, 1.00],
  allora si verifica l'evento "d" --> indice 3

La funzione genera un numero da 0 a (n-1) che rappresenta l'indice del valore di probabilità nella lista delle probabilità:

(define (rand-prob probs)
  (local (out inter cur val found)
    (setq found nil)
    (setq inter '(0.0))
    (setq cur 0)
    ; creazione della lista degli intervalli
    (dolist (el probs)
      ;(setq cur (round (add cur el) -4))
      (push cur inter -1)
    )
    ; l'ultimo valore della lista degli intervalli deve valere 1
    (if (!= (last inter) 1) (println "Errore: somma probabilita diversa da 1"))
    ;(print inter)
    ; generazione numero random con probabilità predefinite
    (setq val (random))
    (setq out nil)
    ; ricerca in quale intervallo cade il numero random
    ; e restituisce l'indice corrispondente
    (for (i 0 (- (length inter) 2) 1 found)
      (if (and (>= val (inter i)) (<= val (inter (+ i 1))))
        (begin
        (setq out i)
        (setq found true))
      )
    )
    out))

Proviamo con l'esempio iniziale:

(setq p '(0.05 0.15 0.35 0.45))

(rand-prob p)
;-> 2

Verifichiamo la funzione generando 1000000 valori che popolano un vettore di frequenze:

(setq vet (array 4 '(0)))
;-> (0 0 0 0)
(for (i 0 999999) (++ (vet (rand-prob p))))
vet
;-> (50177 150075 348712 451036)
Il risultato segue bene la distribuzione perfetta che vale (50000 150000 350000 450000).

Calcoliamo la somma dei valori del vettore:
(apply + vet)
;-> 1000000

Facciamo un'altra prova:

(setq p '(0.02 0.08 0.7 0.2))
(setq vet (array 4 '(0)))
;-> (0 0 0 0)
(for (i 0 999999) (++ (vet (rand-prob p))))
vet
;-> (19887 79869 699932 200312)

Sembra che tutto funzioni correttamente.


------------------------------
Generatore di stringhe casuali
------------------------------

Scrivere una funzione che genera stringhe casuali di lunghezza prefissata.

Lettere minuscole:
(char 97)
;-> "a"
(char 122)
;-> "z"
(setq lower (map char (sequence 97 122)))
;-> ("a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m"
;->  "n" "o" "p" "q" "r" "s" "t" "u" "v" "w" "x" "y" "z")
(length lower)
;-> 26

Lettere maiuscole:
(char 65)
;-> "A"
(char 90)
;-> "Z"
(setq upper (map char (sequence 65 90)))
;-> ("A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M"
;->  "N" "O" "P" "Q" "R" "S" "T" "U" "V" "W" "X" "Y" "Z")
(length upper)
;-> 26

Vocali:
(setq vowels '("a" "e" "i" "o" "u"))

Consonanti:
(setq consonants '("b" "c" "d" "f" "g" "h" "j" "k" "l" "m" "n" "p" "q" "r" "s" "t" "v" "w" "x" "y" "z"))

(setq upper-rnd (map char (randomize (sequence 65 90))))
;-> ("A" "P" "G" "V" "Q" "B" "N" "Y" "W" "D" "M" "X" "J"
;->  "T" "R" "F" "E" "U" "C" "O" "Z" "L" "I" "K" "H" "S")

Generatore di interi tra [a, b]:

(define (rand-range a b)
  (if (> a b) (swap a b))
  (+ a (rand (+ (- b a) 1))))

Estrae un carattere casuale da una lista:

(define (rand-char lst) (lst (rand (length lst))))

(rand-char lower)
;-> "c"

Il più semplice dei generatori casuali utilizza la funzione "rand-char" per creare una stringa di lunghezza n con caratteri presi dall'alfabeto alfa:

(define (rand-string n alfa)
  (let (out '())
    (dotimes (i n)
      (push (rand-char alfa) out -1))
      (join out)))

(rand-string 10 lower)
;-> "unhwsyyodm"

(rand-string 10 upper)
;-> "YTCPKTPOJD"

(rand-string 10 vowels)
;-> "eiuiuoeaoi"

Adesso ci proponiamo di scrivere una funzione che genera stringhe "leggibili". Per stringa "leggibile" intendiamo una stringa che segue le regole generali della lingua italiana e quindi può essere letta senza difficoltà (es. "unhwsyyodm" è illeggibile).
Vediamo alcune di queste regole (che hanno quasi sempre delle eccezioni):
1) non ci sono tre vocali di seguito (eccez. aiuola)
2) non ci sono tre consonanti di seguito (eccez. strada)
3) non ci sono quattro consonanti di seguito
4) alcune consonanti non possono essere doppie (es. hh, yy, xx, ww)
5) ecc.

La funzione che implementiamo segue le seguenti regole di costruzione:

a) Inizia con una consonante
b) segue una vocale
c) può seguire:
   c1) una consonante (percentuale di probabilità 60%)
   c2) due consonanti uguali (nn,rr,tt,...) (30%)
   c3) due consonanti diverse (fr,pr,tr,sf,...) (15%)
   c4) tre consonanti diverse (sfr, str, ttr,...) (5%)
d) segue una vocale
e) ritornare al punto a)

Cominciamo a definire quali sono le consonanti doppi possibili.

(define (doppia lst)
  (let (out '())
    (dolist (el lst)
      (push (string el el) out -1))))

(doppia consonants)
;-> ("bb" "cc" "dd" "ff" "gg" "hh" "jj" "kk" "ll" "mm" "nn" "pp"
;->  "qq" "rr" "ss" "tt" "vv" "ww" "xx" "yy" "zz")

Eliminiamo "hh", "jj", "kk", ,"qq", "ww", "xx" e "yy".

(setq doppie '("bb" "cc" "dd" "ff" "gg" "ll" "mm" "nn" "pp" "rr" "ss" "tt" "zz"))

Adesso analizziamo le consonanti diverse.

(setq lettere '("b" "c" "d" "f" "g" "l" "m" "n" "p" "q" "r" "s" "t" "v"))

Generiamo tutte le doppie:

(define (cp lst1 lst2 func)
  (let (out '())
    (if (or (null? lst1) (null? lst2))
        nil
        (dolist (el1 lst1)
          (dolist (el2 lst2)
            (push (func el1 el2) out -1))))))

(difference (unique (cp lettere lettere string)) (doppia lettere))
;-> ("bc" "bd" "bf" "bg" "bl" "bm" "bn" "bp" "bq" "br" "bs" "bt" "bv"
;->  "cb" "cd" "cf" "cg" "cl" "cm" "cn" "cp" "cq" "cr" "cs" "ct" "cv"
;->  "db" "dc" "df" "dg" "dl" "dm" "dn" "dp" "dq" "dr" "ds" "dt" "dv"
;->  "fb" "fc" "fd" "fg" "fl" "fm" "fn" "fp" "fq" "fr" "fs" "ft" "fv"
;->  "gb" "gc" "gd" "gf" "gl" "gm" "gn" "gp" "gq" "gr" "gs" "gt" "gv"
;->  "lb" "lc" "ld" "lf" "lg" "lm" "ln" "lp" "lq" "lr" "ls" "lt" "lv"
;->  "mb" "mc" "md" "mf" "mg" "ml" "mn" "mp" "mq" "mr" "ms" "mt" "mv"
;->  "nb" "nc" "nd" "nf" "ng" "nl" "nm" "np" "nq" "nr" "ns" "nt" "nv"
;->  "pb" "pc" "pd" "pf" "pg" "pl" "pm" "pn" "pq" "pr" "ps" "pt" "pv"
;->  "qb" "qc" "qd" "qf" "qg" "ql" "qm" "qn" "qp" "qr" "qs" "qt" "qv"
;->  "rb" "rc" "rd" "rf" "rg" "rl" "rm" "rn" "rp" "rq" "rs" "rt" "rv"
;->  "sb" "sc" "sd" "sf" "sg" "sl" "sm" "sn" "sp" "sq" "sr" "st" "sv"
;->  "tb" "tc" "td" "tf" "tg" "tl" "tm" "tn" "tp" "tq" "tr" "ts" "tv"
;->  "vb" "vc" "vd" "vf" "vg" "vl" "vm" "vn" "vp" "vq" "vr" "vs" "vt")

Scegliamo "br", "cl", "cr", "dr", "fl", "fr", "gl", "gn", "gr", "lg", "pl", "pr", "rb", "rc" , "rs", "sb", "sc", "sf", "sl", "sm", "sp", "st", "tr".

(setq doppie-div '("br" "cl" "cr" "dr" "fl" "fr" "gl" "gn" "gr" "lg" "pl" "pr" "rb" "rc"  "rs" "sb" "sc" "sf" "sl" "sm" "sp" "st" "tr"))

Vediamo le triple consonanti:

(setq triple '("sfr" "str" "ttr"))

Funzione che estrae un elemento casuale dalla lista passata:

(define (rand-list lst) (lst (rand (length lst))))

(rand-list doppie)
;-> "cc"
(rand-list doppie-div)
;-> "dr"

Infine scriviamo la funzione che genera parole casuali "leggibili":

(define (rand-word iter)
  (local (out)
    (setq out '())
    (dotimes (i iter)
      (push (rand-list consonants) out -1)
      (push (rand-list vowels) out -1)
      (case (rand 4)
            (0 (push (rand-list consonants) out -1))
            (1 (push (rand-list doppie) out -1))
            (2 (push (rand-list doppie-div) out -1))
            (3 (push (rand-list triple) out -1))
            (true (println "error")))
      (push (rand-list vowels) out -1))
    (join out)))

(rand-word 2)
;-> "fuzzarazza"

Dieci parole casuali:

(dotimes (x 10) (println (rand-word (+ 1 (rand 2)))))
;-> nistra
;-> kattru
;-> riscumexu
;-> dusfri
;-> cadidosbo
;-> sestruvela
;-> guledavo
;-> bissinopa
;-> xunototto
;-> paslo

Il passo successivo sarebbe quello di definire una percentuale di probabilità predefinita ad ogni evento casuale, per esempio:
c1) una consonante (percentuale di probabilità 60%)
c2) due consonanti uguali  (30%)
c3) due consonanti diverse (15%)
c4) tre consonanti diverse (5%)

Inoltre sarebbe interessante modificare o definire altre regole di costruzione.


--------------------
Inverso di un numero
--------------------

Per calcolare l'inverso di un numero basta dividere 1 (uno) per il numero stesso. Comunque il newLISP è più veloce non includere il numero 1 nella divisione. Infatti risulta:

(= (div 1 2) (div 2))
;-> true

Calcoliamo la velocità dei due metodi:

(time (div 1 2) 10000000)
;-> 319.685

(time (div 2) 10000000)
;-> 264.999

Quindi la funzione inversa può essere scritta nel modo seguente:

(define (inv x) (if (zero? x) nil (div x)))

(inv 10)
;-> 0.1

(inv 0)
;-> nil


-----------------
Crivello di Atkin
-----------------

Il crivello di Atkin è un algoritmo per calcolare tutti i numeri primi fino ad dato numero intero.
Potete trovare maggiori informazioni sul sito web:

https://it.wikipedia.org/wiki/Crivello_di_Atkin

(define (atkin n)
  (local (primi up m j)
    (setq primi (array (+ n 1) '(nil)))
    (setf (primi 2) true)
    (setf (primi 3) true)
    (setq up (int (ceil (sqrt n))))
    (for (x 1 (- up 1))
      (for (y 1 (- up 1))
        (setq m (+ (* 4 x x) (* y y)))
        (if (and (<= m n) (or (= (% m 12) 1) (= (% m 12) 5)))
            (setf (primi m) (not (primi m)))
        )
        (setq m (+ (* 3 x x) (* y y)))
        (if (and (<= m n) (= (% m 12) 7))
            (setf (primi m) (not (primi m)))
        )
        (setq m (- (* 3 x x) (* y y)))
        (if (and (> x y) (<= m n) (= (% m 12) 11))
            (setf (primi m) (not (primi m)))
        )
      )
    )
    (for (i 5 up)
      (if (primi i)
        (begin
        (setq j (* i i))
        (while (< j n)
          (setf (primi j) nil)
          (setq j (+ j (* i i)))
        )
        )
      )
    )
    ; converte i valori true del vettore in numeri interi (primi)
    (filter integer? (map (fn(x) (if (= x true) $idx)) primi))
  )
)

(atkin 100)
;-> (2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)

Vediamo il tempo di esecuzione:

(time (atkin 1e6))
;-> 1046.776
(time (atkin 1e7))
;-> 10329.198

Vediamo un'altra funzione per calcolare i numeri primi fino ad un dato numero:

(define (sieve-to n)
   (setq arr (array (+ n 1)) lst '(2))
   (for (x 3 n 2)
      (when (not (arr x))
         (push x lst -1)
         (for (y (* x x) n (* 2 x) (> y n))
            (setf (arr y) true))))
   lst
)

Controlliamo che le due funzioni producano risultati uguali:

(= (sieve-to 100000) (atkin 100000))
;-> true

Vediamo il tempo di esecuzione:

(time (sieve-to 1e7))
;-> 1932.644


-------------------------------
Esponenziazione modulare veloce
-------------------------------

In alcuni calcoli/algoritmi (per esempio il test di primalità di Miller-Rabin) è necessario calcolare l'espressione:

(b^e % m)

Esistono dei metodi per effettuare questo calcolo in modo più veloce. Invece di calcolare la potenza e poi il modulo, possiamo effettuare il calcolo in modo integrato.

Primo metodo:

(define (powmod b e m)
  (local (r)
    (cond ((= m 1) (setq r 0))
          (true
            (setq r 1L)
            (setq b (% b m))
            (while (> e 0)
              (if (= (% e 2) 1) (setq r (% (* r b) m)))
              (setq e (/ e 2))
              (setq b (% (* b b) m))
            )
          )
    )
    r))

Secondo metodo:

(define (modexpt b e M)
  (cond
    ((zero? e) 1L)
    ((even? e) (modexpt (% (* b b) M) (/ e 2L) M))
    ((odd? e) (% (* b (modexpt b (- e 1L) M)) M))))

(time (modexpt 1234L 55555456844L 7L) 10000)
;-> 421.888
(time (powmod 1234L 55555456844L 7L) 10000)
;-> 437.499
(time (modexpt 1234L 55555456844L 7L) 10000)
;-> 421.888
(time (powmod 1234L 55555456844L 7L) 10000)
;-> 421.874

Terzo metodo (standard):

(** x p) calcola la potenza di due numeri interi (x^p):

(define (** x p)
  (let (y 1L)
    (dotimes (i p)
      (set 'y (* y x)))))

(time (% (** 1234L 55555L) 7L))
;-> 1484.471

Praticamente, il terzo metodo è inutilizzabile.

Quarto metodo:

(define (pm a b q)
  (let (out 1L)
    (while (> b 0)
      (if (odd? b)
          (setq out (% (* out a) q)))
      (setq a (% (* a a) q))
      (setq b (/ b 2)))
    out))

(time (modexpt 1234L 955555456844L 7344L) 100000)
;-> 3107.794
(time (powmod 1234L 955555456844L 7344L) 100000)
;-> 3129.95
(time (pm 1234L 955555456844L 7344L) 100000)
;-> 2195.76


-------------
random sample
-------------

In statistica, un "random sample" è un sottoinsieme di elementi (un campione) scelti da un insieme più ampio. Ogni elemento viene scelto casualmente in modo tale che ogni elemento abbia la stessa probabilità di essere scelto in qualsiasi fase durante il processo di campionamento e ogni sottoinsieme di k elementi abbia la stessa probabilità di essere scelto come campione di qualsiasi altro sottoinsieme di k elementi. Questo processo e questa tecnica viene chiamata "campionamento casuale semplice" (simple random sample).

La seguente funzione "random-sample" non è corretta, in quanto può generare numeri uguali (non distinti).

(define (random-sample n k)
  (let (out '())
    (for (i 1 k)
      (push (+ 2 (rand n)) out)
    )
    out))

La seguente "random-sample" è corretta e seleziona k numeri distinti dai numeri 1..n.

(define (random-sample n k)
  ; newLISP start with the same sequence without "seed"
  (seed (time-of-day))
  (slice (randomize (sequence 1 n)) 0 k))

Invece questa "random-sample" seleziona k numeri distinti da una lista
Se n è un numero, allora la lista vale (1 2 ... n).
Altrimenti n deve essere una lista di elementi distinti.

(define (random-sample n k)
  ; newLISP start with the same sequence without "seed"
  (seed (time-of-day))
  (cond ((integer? n)
         (slice (randomize (sequence 1 n)) 0 k))
        ((list? n)
         (slice (randomize n) 0 k))
        (true nil)))

(random-sample 100 10)
;-> (73 30 87 32 20 74 91 2 82 36)

(random-sample '(a v f j k o l) 3)
;-> (j v l)

Nota: queste ultime due funzioni sono inutilizzabili per valori di n grandi, infatti la funzione "sequence" richiederebbe troppa memoria per generare la lista di numeri da 1 a n.

Possiamo scrivere una funzione che utilizza una hashmap. Continuiamo a generare un numero casuale e lo inseriamo nella hashmap fino a che non abbiamo k numeri casuali. La hashmap si preoccupa di gestire le eventuali collisioni (numeri casuali già estratti).

(define (random-sample1 n k)
  (let ((out '()) (r 0))
    (new Tree 'Hash)
    (while (< (length (Hash)) k)
      (setq r (+ 1 (rand n)))
      (Hash r r)
    )
    (dolist (el (Hash)) (push (el 1) out -1))
    (delete 'Hash)
    out
  )
)

Chiaramente questa funzione è efficiente quando il valore di n è almeno un ordine di grandezza superiore al valore di k.

(random-sample1 100 10)
;-> (11 26 38 4 57 60 70 73 77 87)

(length (unique (random-sample1 1000 1000)))
;-> 1000

Un altro problema viene dal fatto che la cancellazione della hashmap (delete 'Hash) è una funzione molto lenta. Allora proviamo ad eliminare tutti gli elementi della hashmap:

(define (random-sample n k)
  (let ((out '()) (r 0))
    (new Tree 'Hash)
    (while (< (length (Hash)) k)
      (setq r (+ 1 (rand n)))
      (Hash r r)
    )
    (dolist (el (Hash)) (push (el 1) out -1))
    ; delete Hash elements
    (dolist (el out) (Hash el nil))
    ;(delete 'Hash)
    out
  )
)

(random-sample 10 3)
;-> (4 5 6)

Vediamo la velocità:

(time (random-sample1 1000 100) 1000)
;-> 1125.599
(time (random-sample 1000 100) 1000)
;-> 940.62

(time (random-sample1 100000 1000) 100)
;-> 7111.842
(time (random-sample 100000 1000) 100)
;-> 7116.742

Nessun miglioramento sostanziale.


-------------------------------
Funzioni di Mobius e di Mertens
-------------------------------

La funzione di Mobius, indicata con mu(n), è una funzione che trova impiego in teoria dei numeri per classificare i numeri interi positivi in una di tre categorie possibili secondo la scomposizione in fattori.

La funzione viene definita assegnando a μ(n) i seguenti valori:

−1 se n è scomponibile in un numero dispari di fattori primi distinti.
   (se n ha un numero dispari di fattori primi non ripetuti)
Per esempio μ(435) = −1 perché 435 = 3 × 5 × 29, ha tre fattori primi. Per gli scopi di questa funzione, un numero primo è considerato avere un fattore primo, in sé, quindi μ(p) = −1.

0 se n ha uno o più fattori primi ripetuti.
Per esempio μ(436) = 0 perché 436 = 22 × 109 = 2 × 2 × 109, poiché gli esponenti significano che un fattore accade due volte o più nella scomposizione in fattori.

+1 se n è scomponibile in un numero pari di fattori primi distinti.
   (se n ha un numero pari di fattori non ripetuti)
Per esempio μ(437) = 1 perché 437 = 19 × 23. Si assume anche che μ(1) = 1, considerando che abbia una scomposizione in 0 fattori primi.

Per convenzione mu(1) = 1.

Questa è una funzione aritmetica moltiplicativa, cioè se h e k sono interi positivi coprimi, allora risulta: mu(h*k) = mu(h) * mu(k).

Sequenza OESIS: A008683

(setq A008683 '(
 1 -1 -1 0 -1 1 -1 0 0 1 -1 0 -1 1 1
 0 -1 0 -1 0 1 1 -1 0 0 1 0 0 -1 -1
 -1 0 1 1 1 0 -1 1 1 0 -1 -1 -1 0 0
 1 -1 0 0 0 1 0 -1 0 1 0 1 1 -1 0 -1
 1 0 0 1 -1 -1 0 1 -1 -1 0 -1 1 0 0 1 -1))

(length A008683)
;-> 78

(define (mobius n)
  (let (f (factor n))
    (cond ((= n 1) 1)
          ; se n ha fattori primi distinti...
          ((= f (unique f))
           ; se dispari -> -1, altrimenti -> 1
           (if (odd? (length f)) -1 1))
          ;se n ha fattori primi non distinti (ripetuti)
          (true 0))))

(mobius 6)
;-> 1

(= A008683 (map mobius (sequence 1 78)))
;-> true

La funzione di Mertens indicata con M(x) è la sommatoria della funzione di Mobius:

M(x) = Sum[n 1 x] (mu(n))

Sequenza OESIS: A002321

(setq A002321 '(
 1 0 -1 -1 -2 -1 -2 -2 -2 -1 -2 -2 -3 -2
 -1 -1 -2 -2 -3 -3 -2 -1 -2 -2 -2 -1 -1 -1
 -2 -3 -4 -4 -3 -2 -1 -1 -2 -1 0 0 -1 -2
 -3 -3 -3 -2 -3 -3 -3 -3 -2 -2 -3 -3 -2 -2
 -1 0 -1 -1 -2 -1 -1 -1 0 -1 -2 -2 -1 -2
 -3 -3 -4 -3 -3 -3 -2 -3 -4 -4 -4))

(length A002321)
;-> 81

(define (mertens x)
  (apply + (map mobius (sequence 1 x))))

(mertens 3)
;-> -1

(= A002321 (map mertens (sequence 1 81)))
;-> true


---------------------
Quadruple pitagoriche
---------------------

Una quadrupla pitagorica è costituita da quattro numeri interi positivi a, b, c e d tali che a ≤ b ≤ c ≤ d e a² + b² + c² = d². Ad esempio, (2 3 6 7) è una quadrupla pitagorica perché 2² + 3² + 6² = 4 + 9 + 36 = 49 = 7².

Scrivere un programma che conteggi le quadruple pitagoriche con a, b, c minore o uguale a 1000.

(define (isqrt n) (int (sqrt n)))

(define (pyquad n)
  (local (a b c d s out)
    (for (a 1 n)
      (for (b a n)
        (for (c b n)
          (setq s (+ (* a a) (* b b) (* c c)))
          (setq d (isqrt s))
          (if (= (* d d) s) (push (list a b c d) out -1)))))
    out))

(time (setq pq (pyquad 1000)))
;-> 59196.872

(length pq)
;-> 85490

(slice pq 0 20)
;-> ((1 2 2 3) (1 4 8 9) (1 6 18 19) (1 8 32 33) (1 10 50 51)
;->  (1 12 12 17) (1 12 72 73) (1 14 98 99) (1 16 128 129)
;->  (1 18 30 35) (1 18 162 163) (1 20 200 201) (1 22 46 51)
;->  (1 22 242 243) (1 24 288 289) (1 26 338 339) (1 28 76 81)
;->  (1 28 392 393) (1 30 450 451) (1 32 100 105))

Test del risultato:

(define (test a b c d)
  (= (* d d) (+ (* a a) (* b b) (* c c))))

(test 36 399 448 601)
;-> true

(dolist (el pq)
  (if (= (test (el 0) (el 1) (el 2) (el 3)) true)
    (println el)))


-------------------------
Lista dei contesti attivi
-------------------------

Per generare la lista di tutti i contesti (context) definiti nella sessione corrente possiamo utilizzare la seguente funzione:

(define (contexts-lst)
  (filter context? (map eval (symbols))))

(contexts-lst)
;-> (Class MAIN Tree)

Nota: i simboli che rappresentano i contesti si trovano sempre nel contesto MAIN.

------------------------------
Conversione lista <--> stringa
------------------------------

(setq lst '(1 a 2 b 3 c))

(define (lst2str lst)
  (join (map string lst) " "))

(lst2str lst)
;-> "1 a 2 b 3 c"

(define (str2lst str)
  (map sym (parse str)))

(str2lst "1 a 2 b 3 c")
;-> (1 a 2 b 3 c)


----------------
Funzione butlast
----------------

Questa funzione restituisce la lista o la stringa passata senza gli ultimi n elementi (default n=1):

(define (butlast list-or-string n)
  (chop list-or-string (or n 1)))

(butlast "pippo" 2)
;-> "pip"

(butlast '(1 2 3 4 5))
;-> (1 2 3 4)


-----------------------------------------
Lista di tutte le partizioni di un numero
-----------------------------------------

Dato un numero intero positivo n, generare tutti i modi unici possibili per rappresentare n come somma di numeri interi positivi.

La soluzione crea una lista con tutte le partizioni ordinate (anche i numeri di ogni partizione sono ordinati). Il metodo è quello di ottenere la partizione successiva usando i valori della partizione corrente. Memorizziamo ogni partizione in un vettore "part". Inizializziamo part[0] a n, dove n è il numero di input. Ad ogni iterazione inseriamo la partizione corrente (cioè il vettore "part") nella lista e quindi aggiorniamo il vettore "part" per memorizzare la partizione successiva. Quindi il problema principale è ottenere la partizione successiva da una determinata partizione.

I passaggi per ottenere la partizione successiva dalla partizione corrente sono i seguenti:
- Ci viene data la partizione corrente in "part" e le sue dimensioni.
- Dobbiamo aggiornare "part" per memorizzare la prossima partizione.
- I valori in "part" devono essere ordinati in ordine non crescente.

1) Trovare il valore (non-uno) (cioè diverso da 1) più a destra in "part" e memorizzare il conteggio di 1 incontrati prima di un valore non-uno in una variabile temp-value (Indica la somma dei valori sul lato destro che devono essere aggiornati). Assegna alla variabile k il valore dell'indice relativo al numero non-uno.

2) Diminuire il valore di part[k] di 1 e aumentare temp-value di 1.
Ora ci possono essere due casi:
a) Se part[k] è maggiore o uguale a temp-value. Questo è un caso semplice (abbiamo il corretto ordine in una nuova partizione). Assegnare temp-value a part[k + 1] e part[0..(k + 1)] è la nostra nuova partizione.
b) Altrimenti (questo è un caso interessante, considera part[] iniziale come [3, 1, 1, 1], part[k] è diminuito da 3 a 2, temp-value è aumentato da 3 a 4, la partizione successiva vale essere [2, 2, 2]).

3) Copiare part[k] nella posizione successiva, incrementare k e ridurre il conteggio di part[k] fino a che part[k] è inferiore a temp-value. Infine, assegnare temp-value a part[k + 1] e part[0..(k + 1)] è la nostra nuova partizione. Questo passaggio è come dividere temp-value in termini di part[k] (4 è diviso in 2 parti).

Vediamo l'implementazione dell'algoritmo:

(define (partnumber n)
  (catch
  (local (part k temp-value out)
    (setq out '())
    (setq part (array n '(0)))
    (setq k 0)
    (setf (part k) n)
    ; Questo ciclo prima aggiunge la partizione corrente alla lista
    ; poi genera la partizione successiva.
    ; Il ciclo termina quando la partizione corrente è costituita da tutti 1.
    (while true
      ; Aggiunge la partizione corrente alla lista delle soluzioni
      (push (slice part 0 (+ k 1)) out -1)
      ;
      ; Genera la partizione successiva
      ;
      ; Trova il valore non-uno più a destra di part[]
      ; Aggiorna anche il valore di temp-value
      ; (cioè quanti valori possono essere inseriti)
      (setq temp-value 0)
      (while (and (>= k 0) (= (part k) 1))
        (setq temp-value (+ temp-value (part k)))
        (-- k)
      )
      ; se k < 0, tutti i valori valgono 1
      ; quindi non ci sono altre partizioni da generare
      (if (< k 0) (throw out))
      ; Decrementa part[k] trovato sopra e calcola il valore di temp-value
      (setf (part k) (- (part k) 1))
      (++ temp-value)
      ; Se rem_val è maggiore, allora l'ordine è violato.
      ; Divide temp-value in diversi valori di dimensione part[k] e
      ; copia questi valori in posizioni diverse dopo part[k]
      (while (> temp-value (part k))
        (setf (part (+ k 1)) (part k))
        (setq temp-value (- temp-value (part k)))
        (++ k)
      )
      ; Copia rem_val nella posizione successiva e incrementa la posizione
      (setf (part (+ k 1)) temp-value)
      (++ k)
    )
  );local
  );catch
)

Proviamo la funzione:

(partnumber 1)
;-> ((1))

(partnumber 3)
;-> ((3) (2 1) (1 1 1))

(partnumber 5)
;-> ((5) (4 1) (3 2) (3 1 1) (2 2 1) (2 1 1 1) (1 1 1 1 1))

(length (partnumber 40))
;-> 37338

Possiamo usare anche la ricorsione per risolvere questo problema. Consideriamo ogni intero i da 1 a n e lo aggiungiamo all'output e poi usiamo la ricorsione per gli elementi rimanenti [i..n] con somma ridotta n-i. Per evitare di generare una permutazione, ogni combinazione viene costruita in ordine non decrescente. Se si raggiunge una combinazione con la somma data, allora la aggiungiamo all'elenco delle soluzioni.

(define (part-aux i num idx)
  (if (zero? num)
      ; se la somma diventa num, aggiungi questa soluzione
      (push (slice lst 0 idx) out -1)
  )
  ; necessario per evitare che il ciclo "for"
  ; sia operativo anche quando (i > num)
  ; (conteggio inverso)
  (if (<= i num) (begin
      ; inizia dall'elemento precedente nella combinazione fino a num
      (for (j i num)
        ;assegna l'elemento corrente all'indice corrente
        (setf (lst idx) j)
        ; ricorsione con somma ridotta
        (part-aux j (- num j) (+ idx 1))))))

(define (partition num)
  (local (lst out)
    (setq lst (array num '(0)))
    (setq out '())
    (part-aux 1 num 0)
    out))

(partition 5)
;-> ((5) (4 1) (3 2) (3 1 1) (2 2 1) (2 1 1 1) (1 1 1 1 1))

(length (partition 40))
;-> 37338

Vediamo la differenza di velocità delle due funzioni:

(time (println (length (partition 60))))
;-> 966467
;-> 2166.237
(time (println (length (partnumber 60))))
;-> 966467
;-> 3125.434

(time (println (length (partition 80))))
;-> 15796476
;-> 51805.942

(time (println (length (partnumber 80))))
;-> 15796476
;-> 94370.516

La versione ricorsiva è più veloce.

Se vogliamo trovare solo il numero di partizioni (senza generarle tutte) la situazione è abbastanza complicata. Non si conosce un metodo per calcolare esattamente il numero di partizioni di un dato numero n, cioè una funzione o un algoritmo per calcolare p(n) direttamente. Comunque esiste una definizione ricorsiva di p(n) che permette di calcolarla utilizzando i valori precedenti.

Su wikipedia si trova che la funzione generatrice per p(n) vale:

p(n) = p(n - 1) + p(k - 2) - p(k - 5) - p(k - 7) + p(k - 12) + p(k - 15) - p(k - 22) ...

dove p(0) = 1 e p(n) = 0 per n < 0.

La sequenza dei numeri k da utilizzare è data dalla formula dei numeri pentagonali generalizzati:

f(k) = k*(3k-1)/2 che vale sia per k negativo che per k positivo.

Questa formula può essere generata nel modo seguente:

    | (m/2 + 1)    se (k mod 2) = 0,
k = |
    | (-m/2 - 1)   altrimenti

I segni della funzione seguono lo schema +, +, -, -, +, +, -, -,...

Quindi partendo dal primo valore della sequenza possiamo calcolare quella successiva e cosi via.

(define (part-num num)
  (local (n p-vec segno penta continua i j val)
    (setq p-vec (array (+ num 1) '(0)))
    (setf (p-vec 0) 1)
    (setq continua true)
    (setq n 1)
    (while (<= n num)
      (setq i 0)
      (setq penta 1)
      (while (<= penta n)
        (if (> (% i 4) 1)
            (setq segno -1)
            (setq segno 1))
        (setf (p-vec n) (+ (p-vec n) (* segno (p-vec (- n penta)))))
        (++ i)
        (if (zero? (% i 2))
            (setq j (+ (/ i 2) 1))
            (setq j (- (+ (/ i 2) 1))))
        (setq penta (/ (* j (- (* 3 j) 1)) 2))
      )
      (++ n)
    )
    p-vec))

(part-num 50)
;-> (1 1 2 3 5 7 11 15 22 30 42 56 77 101 135 176 231 297 385 490
;->  627 792 1002 1255 1575 1958 2436 3010 3718 4565 5604 6842
;->  8349 10143 12310 14883 17977 21637 26015 31185 37338 44583
;->  53174 63261 75175 89134 105558 124754 147273 173525 204226)


---------------------------
Algoritmo di Euclide esteso
---------------------------

MCD -> Massimo Comun Divisore
GCD -> Greatest Common divisor

Mentre l'algoritmo euclideo calcola solo il massimo comune divisore (MCD) di due interi a e b, la versione estesa trova anche un modo per rappresentare MCD in termini di a e b, cioè coefficienti x e y per i quali:

a*x + b*y = mcd(a, b)

Da notare che possiamo sempre trovare una tale rappresentazione, ad esempio mcd(55,80) = 5 quindi possiamo rappresentare 5 come una combinazione lineare con i termini 55 e 80:

55*3 + 80*(−2) = 5

Versione generale:

(define (gcdex a b)
  (local (x y lastx lasty temp)
    (setq x 0)
    (setq y 1)
    (setq lastx 1)
    (setq lasty 0)
    (while (not (zero? b))
      (setq q (div a b))
      (setq r (% a b))
      (setq a b)
      (setq b r)
      (setq temp x)
      (setq x (- lastx (* q x)))
      (setq lastx temp)
      (setq temp y)
      (setq y (- lasty (* q y)))
      (setq lasty temp)
    )
    ; Adesso la variabile a contiene il valore di gcd
    ;(println a { } b { } x { } y { } lastx { } lasty)
    (list a lastx lasty)))

(gcdex 120 23)
;-> (1 -9 47)

(gcdex 8 -6)
;-> (2 1 1)

Versione ricorsiva:

(define (gcd-ext a b)
    (cond ((zero? b)
           (setq x 1 y 0)
           a)
          (true
           (setq g (gcd-ext b (% a b)))
           (setq x1 x y1 y)
           (setq x y1)
           (setq y (- x1 (mul y1 (div a b))))
           (abs g)
    ))

(gcd-ext 18 24)
;-> 6

Versione iterativa:

(define (gcd-ext a b)
  (local (x y x1 y1 a1 b1 q)
    (setq x 1 y 0 x1 0 y1 1 a1 a b1 b)
    (while (!= b1 0)
      (setq q (/ a1 b1))
      (map set '(x x1) (list x1 (- x (* q x1))))
      (map set '(y y1) (list y1 (- y (* q y1))))
      (map set '(a1 b1) (list b1 (- a1 (* q b1))))
    )
    (abs a1)))

(gcd-ext 18 24)
;-> 6

(gcd-ext 18 -24)
;-> 6

(gcd-ext 15 -18)
;-> 3

(gcd-ext 4 -12)
;-> 4

(gcd-ext 0 12)
;-> 12

(gcd-ext -2 0)
;-> 2

Nota: Il gcd non cambia in caso di cambio di segno dei numeri:

gcd (a,b) = gcd (a,-b)= gcd (-a,b) = gcd (-a,-b)


----------------------------------
Punti casuali in una circonferenza
----------------------------------

La seguente funzione genera n punti casuali (x,y) interni ad un cerchio di raggio predefinito con centro in C(raggio, raggio).

(define (rand-xy-circle raggio n)
  (local (x y cx cy out i)
    (setq out '())
    (setq i 1)
    (while (<= i n)
      (setq x (mul (random) (mul raggio 2)))
      (setq y (mul (random) (mul raggio 2)))
      (if (< (add (mul (sub x raggio) (sub x raggio))
                  (mul (sub y raggio) (sub y raggio)))
              (mul raggio raggio))
          (begin
            (push (list x y) out -1)
            (++ i)))
    )
    out))

Possiamo verificare il risultato utilizzando un foglio elettronico:
1) generare e salvare n punti casuali
   (setq punti (rand-xy-circle 50 100))
   (save "punti.txt" 'punti)
2) importare il file punti.txt su un foglio elettronico
3) modificare il foglio in modo che ci siamo due colonne (una per la coordinata x e una per la coordinata y)
3) generare un grafico scatter-plot (x,y) con le coordinate dei punti.

Potremmo calcolare questi punti casuali utilizzando le coordinate polari (r,theta):

(define (rand-xy-circle raggio n)
  (local (x y cx cy r theta out)
    (setq out '())
    (for (i 1 n)
      (setq r (mul (random) raggio))
      (setq theta (mul (random) (mul 2 3.141592653589793)))
      (setq x (add raggio (mul r (cos theta))))
      (setq y (add raggio (mul r (sin theta))))
      (push (list x y) out -1)
    )
    out))

(setq punti (rand-xy-circle 5 10000))
(save "punti-polar.txt" 'punti)

Purtroppo questo metodo non è corretto, in quanto i punti tendono a concentrarsi intorno al centro della circonferenza (vedi immagine "punti-cerchio.png").


---------------------------------
Esponenziazione (potenza) binaria
---------------------------------

L'esponenziazione binaria (nota anche come esponenziazione per quadratura) è un trucco che consente di calcolare una potenza utilizzando solo O(log n) moltiplicazioni (invece delle O(n) richieste dall'approccio normale).
Questo metodo può essere utilizzato con qualsiasi operazione che abbia la proprietà dell'associatività:

(X op Y) op Z = X op (Y op Z)

Elevare a alla potenza di n è espresso ingenuamente come moltiplicazione per a fatto n − 1 volte: a*n = a*a* ... *a. Tuttavia, questo approccio non è pratico per grandi valori di a o n.

a^(b+c) = a^b * a^c  e  a^(2b) = a^b * a^b = (a^b)^2

L'idea dell'esponenziazione binaria è quella di suddividere le operazioni usando la rappresentazione binaria dell'esponente.

Scriviamo n in base 2, ad esempio:

3^13 = 3^(1101) = 3^8 * 3^4 * 3^1

Poiché il numero n ha esattamente |log2 n| + 1 cifre in base 2, dobbiamo solo eseguire O(log n) moltiplicazioni, se conosciamo le potenze a^1, a^2, a^4, a^8,…, a^|(log n)|.

Quindi abbiamo solo bisogno di conoscere un modo veloce per calcolarli. Fortunatamente questo è molto semplice, poiché un elemento nella sequenza è solo il quadrato dell'elemento precedente.

3^1 = 3
3^2 = (3^1)^2 = 3^2 = 9
3^4 = (3^2)^2 = 9^2 = 81
3^8 = (3^4)^2 = 81^2 = 6561

Quindi, per ottenere la risposta finale per 3^13, dobbiamo solo moltiplicarne tre di loro (saltando 3^2 perché il bit corrispondente in n non è impostato): 313 = 6561 * 81 * 3 = 1594323

La complessità finale di questo algoritmo è O(log n): dobbiamo calcolare (log n) potenze di a, quindi dobbiamo fare al massimo (log n) moltiplicazioni per ottenere la risposta finale.

Il seguente approccio ricorsivo esprime la stessa idea:

se n=0             ==>   a^n = 1

se n>0 e pari      ==>   a^n = (a^(n/2))^2

se n>0 e dispari   ==>   a^n = (a^((n-1)/2))^2

Versione ricorsiva:

(define (bin-pow-rec a b)
  (let (res 1L)
  (cond ((= b 0) 1)
        (true
          (setq res (bigint (bin-pow-rec a (/ b 2))))
          (if (= (% b 2) 1)
              (* res res a)
              (* res res))))))

(bin-pow-rec 2L 4L)
;-> 16L
(bin-pow-rec 7L 253L)
;-> 64536309039243386456273720567782680383746852777261605536920302
;-> 93074941615183644305679310302734520060591237478898870576089992
;-> 31319516198255060066433347506256253995870956010633721063187612
;-> 1518137796636277520794018407L

Versione iterativa:

(define (bin-pow a b)
  (let (res 1L)
    (while (> b 0)
      (if (= (% b 2) 1)
          (setq res (* res a)))
      (setq a (* a a))
      (setq b (/ b 2))
    )
  res))

(bin-pow 7L 253L)
;-> 64536309039243386456273720567782680383746852777261605536920302
;-> 93074941615183644305679310302734520060591237478898870576089992
;-> 31319516198255060066433347506256253995870956010633721063187612
;-> 1518137796636277520794018407L

Vediamo un'applicazione di questo metodo calcolando in modo efficiente una potenza modulo un numero. In altre parole, il problema è quello di calcolare (a^b mod m).

Poiché l'operatore modulo non interferisce con la moltiplicazione:

(a*b mod m) = ((a mod m) * (b mod m)) mod m)

(% (* 5 6) 4)
;-> 2
(* (% 5 4) (% 6 4))
;-> 2

(% (* 11 76) 14)
;-> 10
(% (* (% 11 14) (% 76 14)) 14)
;-> 10

possiamo utilizzare direttamente lo stesso codice della versione iterativa e sostituire semplicemente ogni moltiplicazione con una moltiplicazione modulare:

(define (bin-pow-mod a b m)
  (let (res 1L)
    (setq a (% a m))
    (while (> b 0)
      (if (= (% b 2) 1)
          (setq res (* res (% a m))))
      (setq a (* a (% a m)))
      (setq b (/ b 2))
    )
  res))

Per ottenere il risultato come big-integer occorre passare gli argomenti come big-integer.

(bin-pow-mod 7L 111L 6L)
;-> 1L


----------------------
Permutazioni circolari
----------------------

Le permutazioni circolari sono un tipo particolare di permutazioni semplici. Quando gli elementi di una permutazione sono disposti in maniera circolare, in modo che non sia possibile individuare il primo e l'ultimo elemento, si parla di permutazione ciclica o circolare o in linea chiusa.

Il numero delle permutazioni circolari di n oggetti vale: (n - 1)!

Vediamo la dimostrazione seguendo un esempio:

lista = A B C
permutazioni semplici = (A B C) (B A C) (B C A) (A C B) (C A B) (C B A)

Se rappresentiamo queste permutazioni intorno ad un cerchio, notiamo che alcune di loro sono equivalenti:

      A           B           B           A           C           C
    C   B       C   A       A   C       B   C       B   A       A   B
     (1)         (2)         (3)         (4)         (5)         (6)

La (1), la (3) e la (5) sono equivalenti (sono tutte rotazioni una dell'altra).
La (2), la (4) e la (6) sono equivalenti (sono tutte rotazioni una dell'altra).

Quindi abbiamo solo due permutazioni circolari uniche. Poichè il numero di permutazioni semplici vale n!, ed ogni permutazione semplice ha n permutazioni circolari equivalenti, possiamo calcolare il numero di permutazioni circolari in questo modo:

numero_permutazioni_circolari(n) = numero_permutazioni_semplici(n) / n = n!/n = (n - 1)!

Le permutazioni circolari possono essere generate tenendo fisso un elemento e calcolando le permutazioni semplici degli altri elementi. Questo metodo produce il seguente algoritmo:

1) estrarre il primo elemento della lista originale
2) calcolare tutte le permutazioni della lista senza il primo elemento
3) aggiungere il primo elemento della lista originale di fronte ad ogni permutazione semplice.

Funzione che calcola le permutazioni semplici:

(define (perm lst)
  (local (i indici out)
    (setq indici (dup 0 (length lst)))
    (setq i 0)
    ; aggiungiamo la lista iniziale alla soluzione
    (setq out (list lst))
    (while (< i (length lst))
      (if (< (indici i) i)
          (begin
            (if (zero? (% i 2))
              (swap (lst 0) (lst i))
              (swap (lst (indici i)) (lst i))
            )
            (push lst out -1)
            (++ (indici i))
            (setq i 0)
          )
          (begin
            (setf (indici i) 0)
            (++ i)
          )
       )
    )
    out))

(perm '(A B C))
;-> ((A B C) (B A C) (C A B) (A C B) (B C A) (C B A))

Adesso scriviamo la funzione per il calcolo delle permutazioni circolari:

(define (perm-circ lst)
  (let (head (pop lst))
    (sort (map (fn(x) (push head x)) (sort (perm lst))))))

(perm-circ '(A B C))
;-> ((A B C) (A C B))

Verifichiamo i risultati della nostra funzione confrontandoli con quelli esatti contenuti nelle liste test4, test5 e test6.

(setq test4 '((A B C D) (A B D C) (A C B D) (A C D B) (A D B C) (A D C B)))

(= (perm-circ '(A B C D)) test4)
;-> true

(setq test5 '((A B C D E) (A B C E D) (A B D C E) (A B D E C) (A B E C D) (A B E D C) (A C B D E)
(A C B E D) (A C D B E) (A C D E B) (A C E B D) (A C E D B) (A D B C E) (A D B E C) (A D C B E)
(A D C E B) (A D E B C) (A D E C B) (A E B C D) (A E B D C) (A E C B D) (A E C D B) (A E D B C) (A E D C B)))

(= (perm-circ '(A B C D E)) test5)
;-> true

(setq test6
'((A B C D E F) (A B C D F E) (A B C E D F) (A B C E F D) (A B C F D E)
  (A B C F E D) (A B D C E F) (A B D C F E) (A B D E C F) (A B D E F C)
  (A B D F C E) (A B D F E C) (A B E C D F) (A B E C F D) (A B E D C F)
  (A B E D F C) (A B E F C D) (A B E F D C) (A B F C D E) (A B F C E D)
  (A B F D C E) (A B F D E C) (A B F E C D) (A B F E D C) (A C B D E F)
  (A C B D F E) (A C B E D F) (A C B E F D) (A C B F D E) (A C B F E D)
  (A C D B E F) (A C D B F E) (A C D E B F) (A C D E F B) (A C D F B E)
  (A C D F E B) (A C E B D F) (A C E B F D) (A C E D B F) (A C E D F B)
  (A C E F B D) (A C E F D B) (A C F B D E) (A C F B E D) (A C F D B E)
  (A C F D E B) (A C F E B D) (A C F E D B) (A D B C E F) (A D B C F E)
  (A D B E C F) (A D B E F C) (A D B F C E) (A D B F E C) (A D C B E F)
  (A D C B F E) (A D C E B F) (A D C E F B) (A D C F B E) (A D C F E B)
  (A D E B C F) (A D E B F C) (A D E C B F) (A D E C F B) (A D E F B C)
  (A D E F C B) (A D F B C E) (A D F B E C) (A D F C B E) (A D F C E B)
  (A D F E B C) (A D F E C B) (A E B C D F) (A E B C F D) (A E B D C F)
  (A E B D F C) (A E B F C D) (A E B F D C) (A E C B D F) (A E C B F D)
  (A E C D B F) (A E C D F B) (A E C F B D) (A E C F D B) (A E D B C F)
  (A E D B F C) (A E D C B F) (A E D C F B) (A E D F B C) (A E D F C B)
  (A E F B C D) (A E F B D C) (A E F C B D) (A E F C D B) (A E F D B C)
  (A E F D C B) (A F B C D E) (A F B C E D) (A F B D C E) (A F B D E C)
  (A F B E C D) (A F B E D C) (A F C B D E) (A F C B E D) (A F C D B E)
  (A F C D E B) (A F C E B D) (A F C E D B) (A F D B C E) (A F D B E C)
  (A F D C B E) (A F D C E B) (A F D E B C) (A F D E C B) (A F E B C D)
  (A F E B D C) (A F E C B D) (A F E C D B) (A F E D B C) (A F E D C B)))

(= (perm-circ '(A B C D E F)) test6)
;-> true


------------------------------
Crivello di Eratostene Lineare
------------------------------

Vediamo un algoritmo che utilizza il crivello Eratostene per calcolare tutti i numeri primi fino a n.
L'algoritmo è stato preso dal seguente articolo:
David Gries, Jayadev Misra. A Linear Sieve Algorithm for Finding Prime Numbers [1978]

(define (euclide-linear n)
  (local (lp pr j)
    (setq lp (array (+ n 1) '(0)))
    (setq pr '())
    (for (i 2 n)
      (if (zero? (lp i))
        (begin
          (setf (lp i) i)
          (push i pr -1)
        )
      )
      ;(println "lp= " lp)
      ;(println "pr= " pr)
      (setq j 0)
      (while (and (< j (length pr)) (<= (pr j) (lp i)) (<= (* i (pr j)) n))
        (setf (lp (* i (pr j))) (pr j))
        (++ j)
      )
    )
    (println lp)
    pr))

(euclide-linear 100)
;-> (0 0 2 3 2 5 2 7 2 3 2 11 2 13 2 3 2 17 2 19 2 3 2 23 2 5 2 3 2 29
;->  2 31 2 3 2 5 2 37 2 3 2 41 2 43 2 3 2 47 2 7 2 3 2 53 2 5 2 3 2 59
;->  2 61 2 3 2 5 2 67 2 3 2 71 2 73 2 3 2 7 2 79 2 3 2 83 2 5 2 3 2 89
;->  2 7 2 3 2 5 2 97 2 3 2)
;-> (2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)

L'implementazione è lenta per (n > 1e5), perchè anche se l'algoritmo è lineare (cioè O(n)) noi utilizziamo una lista che ha un tempo di accesso non lineare.

Per verificare questa affermazione è sufficiente analizzare i tempi di esecuzione del seguente esempio:

1) Lista

; Assegnazione di un valore a tutti i 100000 elementi di una lista
(define (lista)
  (let  (lst (sequence 1 100000))
    (for (i 0 99999)
      (setf (lst i) i)
    )
  ))

(time (lista))
;-> 8006.047

Proviamo definendo la lista come variabile globale:

(silent (setq lst (dup 0 100000)))

(define (lista) (for (i 0 99999) (setf (lst i) i)))

(time (lista))
;-> 6824.776

2) Vettore

; Assegnazione di un valore a tutti i 100000 elementi di un vettore
(define (vettore)
  (let  (vet (array 100000 (sequence 1 100000)))
    (for (i 0 99999)
      (setf (vet i) i)
    )
  ))

(time (vettore))
;-> 5.984

Proviamo definendo il vettore come variabile globale:

(silent (setq vet (array 100000 '(0))))

(define (vettore) (for (i 0 99999) (setf (vet i) i)))

(time (vettore))
;-> 0

Come si può notare il vettore è estremamente più veloce di una lista.

Questo risultato porta a considerare un ulteriore aspetto nell'analisi della complessità temporale di un algoritmo: il tempo delle operazioni di lettura e scrittura delle strutture dati utilizzate per implementare l'algoritmo.


----------------------------
Area di un poligono semplice
----------------------------

Calcolare l'area di un poligono semplice (cioè senza autointersezioni) conoscendo tutte le coordinate dei vertici (ordinate in sequenza clockway (cw) o counterclockway (ccw)).

Possiamo attraversare tutti i lati e aggiungere le aree trapezoidali delimitate da ciascun lato e l'asse x. L'area deve essere calcolata con il segno in modo che l'area extra sarà sottratta. La formula è la seguente:

A = ∑(p,q)[(px−qx)*(py+qy)/2]

Questo formula viene chiamata teorema di Shoelace.

Rappresentiamo il poligono come una lista di punti. Ogni punto è una sottolista (x y).

(define (area polygon)
  (local (res)
    (setq res 0)
    (for (i 0 (- (length polygon) 2))
      (setq res (add res
                     (mul (sub (polygon i 0) (polygon (+ i 1) 0))
                          (add (polygon i 1) (polygon (+ i 1) 1)))))
    )
    (abs (div res 2))))

(setq poly '((0 0) (5 0) (5 5) (0 5) (0 0)))
(area poly)
;-> 25

(setq poly '((4 9) (8 9) (14 3) (7 3) (7 6) (4 6) (4 9)))
(area poly)
;-> 33

(setq poly '((2 6) (4 4) (6 6) (8 4) (10 4) (10 1) (9 1) (7 3) (4 3) (2 1) (2 6)))
(area poly)
;-> 20
(area (reverse poly))
;-> 20

Proviamo con due poligoni cartografici in proiezione Gauss-Boaga Fuso Est:

(setq poly
'((2520848.18 4800614.41)
(2520030.65 4800291.95)
(2520382.42 4799998.81)
(2520460.58 4800207.27)
(2520454.07 4799529.79)
(2520600.65 4799777.33)
(2520828.64 4799552.59)
(2521219.49 4799767.56)
(2521151.09 4800148.64)
(2520854.7 4800217.04 )
(2521112 4800389.67   )
(2520587.62 4800327.78)
(2521447.49 4800679.55)
(2520900.3 4800770.75 )
(2520848.18 4800614.41)))

(area poly)
;-> 731651.7139001787

(setq poly
'((2522369.25 4801321.2 )
(2521502.86 4801946.56)
(2521079.44 4801444.97)
(2522232.45 4800526.46)
(2521926.29 4801184.4 )
(2522714.5 4800291.95 )
(2522356.22 4800936.86)
(2522369.25 4801321.2 )))

(area poly)
;-> 882538.1518998221


--------------------
Rango di una matrice
--------------------

Il rango di una matrice è il maggior numero di righe/colonne linearmente indipendenti della matrice. Il rango non è definito solo per le matrici quadrate. Il rango di una matrice può anche essere definito come l'ordine più grande di qualsiasi minore diverso da zero nella matrice.
Lascia che la matrice sia rettangolare e abbia dimensione N × M. Nota che se la matrice è quadrata e il suo determinante è diverso da zero, il rango è N (= M), altrimenti sarà inferiore.
Algoritmo
Cerchiamo il rango usando l'eliminazione gaussiana. Eseguiremo le stesse operazioni di quando vogliamo risolvere il sistema o trovare il suo determinante. Ma se in qualsiasi passaggio nella colonna i-esima non ci sono righe con una elemento non vuota tra quelle che non abbiamo già selezionato, allora saltiamo questo passaggio. Altrimenti, se abbiamo trovato una riga con un elemento diverso da zero nella i-esima colonna durante l'i-esima fase, allora contrassegniamo questa riga come selezionata, aumentiamo il rango di uno (inizialmente il rango è impostato uguale a 0) ed eseguiamo le normali operazioni di rimozione di questa riga dal resto.
Questo algoritmo viene eseguito in O(n3).

(define (rango matrix)
  (local (n m j p rank row-sel eps break)
    (setq eps 1e-9)
    (setq n (length matrix)) ;righe
    (setq m (length (matrix 0))) ;colonne
    (println "n, m = " n {, } m)
    (setq row-sel (array n '(nil)))
    (setq rank 0)
    (for (i 0 (- m 1))
      (setq j 0)
      (setq break nil)
      (while (and (< j n) (not break))
        (if (and (not (row-sel j)) (> (abs(matrix j i)) eps))
            (setq break true)
            (++ j)
        )
      )
      (if (!= j n)
          (begin
            (++ rank)
            (setf (row-sel j) true)
            (if (< i (- m 1))
              (for (p (+ i 1) (- m 1))
                ;(println "j p i: " j { } p { } i)
                (setf (matrix j p) (div (matrix j p) (matrix j i)))
              )
            )
            (for (k 0 (- n 1))
              (if (and (!= k j) (> (abs(matrix k i)) eps))
                  (if (< i (- m 1))
                    (for (p (+ i 1) (- m 1))
                      (setf (matrix k p) (sub (matrix k p) (mul (matrix j p) (matrix k i))))
                    )
                  )
              )
            )
          )
      )
    )
    rank))

(rango '((1 1 1) (2 2 2) (3 3 3)))
;-> 1

(rango '((1 1 2) (4 2 2) (3 8 9)))
;-> 3

(rango '((10 2 -4 -2) (4 2 2 1) (6 0 -6 -3)))
;-> 2


----------------------------------------------
Operazioni tra coppie di elementi di una lista
----------------------------------------------

La seguente funzione applica l'operatore op ad ogni coppia di elementi di una lista:
el(1) op el(2), el(2) op el(3), el(3) op el(4), ..., el(n-1) op el(n)

(define (do-pair lst func rev)
  (if rev
      (map func (chop lst) (rest lst))
      (map func (rest lst) (chop lst))))

quando rev = true:
el(1) op el(2), el(2) op el(3), el(3) op el(4), ..., el(n-1) op el(n)

quando rev = nil:
el(2) op el(1), el(3) op el(2), el(4) op el(3), ..., el(n) op el(n-1)

(do-pair '(4 7 11 16 18) -)
;-> (3 4 5 2)
3 = 7 - 4
4 = 11 - 7
...

(do-pair '(4 7 11 16 18) - true)
;-> (-3 -4 -5 -2)
-3 = 4 - 7
-4 = 7 - 11
...

Possiamo anche passare una funzione utente come operatore:

(define (quad x y) (+ (* x x) (* y y)))

(do-pair '(1 2 3 4) quad)
;-> (5 13 25)


-----------------------------------
Polinomio interpolatore di Lagrange
-----------------------------------

Dato un insieme di n + 1 punti (xi, yi), il polinomio interpolatore di Lagrange è un polinomio di grado <= n, tale che passa attraverso tutti gli n + 1 punti.

Viene calcolato come:

Pn(x) = Sum[i 0 n] (Li(x) * yi)

dove (x0, y0), (x1, y1), ..., (xn, yn) sono gli n + 1 punti dati.

e Li(x) = Prod[j 0 n, j != i] ((x - xj) / (xi - xj))

Possiamo quindi calcolare la coordinata y di un generico valore x utilizzando il polinomio interpolatore di Lagrange:

Vediamo di implementare un programma che trova questo valore y partendo da una lista di punti e da un valore x.

; Funzione che calcola Li(x)
(define (li i n xcoord x)
  (let (prod 1)
    (for (j 0 n)
      (if (!= j i)
        (setq prod (mul prod (div (sub x (xcoord j)) (sub (xcoord i) (xcoord j)))))
      )
    )
    prod))

; Funzione per calcolare Pn(x)
; dove Pn è il polinomio interpolatore di Lagrange di grado n
(define (pn n xcoord ycoord x)
  (let (sum 0)
    (for (i 0 n)
      (setq sum (add sum (mul (li i n xcoord x) (ycoord i))))
    )
    sum))

(define (lagrange xcoord ycoord x)
  (pn (- (length xcoord) 1) xcoord ycoord x))

Proviamo la funzione:

(setq xval '(5 7 11 13 17))
(setq yval '(150 392 1452 2366 5202))
(lagrange xval yval 9.0)
;-> 810

(setq xval '(2 2.75 4))
(setq yval '(0.5 0.363636 0.25))
(lagrange xval yval 3.0)
;-> 0.3295450666666667

(setq pt '((1 1) (2 4) (3 9)))
(setq xval '(1 2 3))
(setq yval '(1 4 9))
(lagrange xval yval 2.5)
;-> 6.25

Adesso possiamo riunire il tutto in una funzione unica:

(define (lagrange lst-pt x)
  (local (sum u l)
    (setq sum 0.0)
    (for (i 0 (- (length lst-pt) 1))
      (setq u 1.0 l 1.0)
      (for (j 0 (- (length lst-pt) 1))
        (if (!= j i)
          (setq u (mul u (sub x (lst-pt j 0)))
                l (mul l (sub (lst-pt i 0) (lst-pt j 0))))
        )
      )
      (setq sum (add sum (mul (div u l) (lst-pt i 1))))
    )
    sum))

(setq pt '((5 150) (7 392) (11 1452) (13 2366) (17 5202)))
(lagrange pt 9.0)
;-> 810 ;809.9

(setq pt '((2 0.5) (2.75 0.363636) (4 0.25)))
(lagrange pt 3.0)
;-> 0.3295450666666667

(setq pt '((1 1) (2 4) (3 9)))
(lagrange pt 2.5)
;-> 6.25

Possiamo anche determinare i coefficienti del polinomio interpolatore di Lagrange:

(define (lagrange-coeff pts)
  (local (coeff newcoeff idx)
    (setq coeff (array (length pts) '(0)))
    (for (m 0 (- (length pts) 1))
      (setq newcoeff (array (length pts) '(0)))
      (if (> m 0)
        (begin
        (setf (newcoeff 0) (sub (div (pts 0 0) (sub (pts m 0) (pts 0 0)))))
        (setf (newcoeff 1) (div 1 (sub (pts m 0) (pts 0 0)))))
        (begin
        (setf (newcoeff 0) (sub (div (pts 1 0) (sub (pts m 0) (pts 1 0)))))
        (setf (newcoeff 1) (div 1 (sub (pts m 0) (pts 1 0)))))
      )
      (setq idx 1)
      (if (= m 0) (setq idx 2))
      (for (n idx (- (length pts) 1))
        (if (!= m n)
          (begin
          (for (nc (- (length pts) 1) 1)
            (setf (newcoeff nc) (add (mul (newcoeff nc) (sub (div (pts n 0) (sub (pts m 0) (pts n 0)))))
                                     (div (newcoeff (- nc 1)) (sub (pts m 0) (pts n 0)))))
          )
          (setf (newcoeff 0) (mul (newcoeff 0) (sub (div (pts n 0) (sub (pts m 0) (pts n 0)))))))
        )
      )
      (for (nc 0 (- (length pts) 1))
        (setf (coeff nc) (add (coeff nc) (mul (pts m 1) (newcoeff nc))))
      )
    )
    coeff))

(setq punti '((2 2) (4 5) (3 -2) (6 0) (7 2) (10 8)))

(lagrange-coeff punti)
;-> (300.5 -360.3511904761905 158.7202380952381 -32.26339285714285 3.05654761904762 -0.1086309523809524)

La soluzione esatta vale:

- 73/672*x^5 + 1027/336*x^4 - 7227/224*x^3 + 26665/168*x^2 - 60539/168*x - 601/2

(div -73 672)
;-> -0.1086309523809524
(div 1027 336)
;-> 3.056547619047619
(div -7227 224)
;-> -32.26339285714285
(div 26665 168)
;-> 158.7202380952381
(div -60539 168)
;-> -360.3511904761905
(div 601 2)
;-> 300.5

(setq punti '((3 2) (4 -1) (2 6) (6 0)))
(lagrange-coeff punti)
;-> (13 -2.166666666666671 -1 0.1666666666666666)

La soluzione esatta vale:  1/6*x^3 - x^2 - 13/6*x + 13

Proviamo con un polinomio conosciuto a priori: 3x^3 - 2x^2 + 5x + 4

(define (poly x) (add (mul 3 x x x) (mul -2 x x) (mul 5 x) 4))
(poly 0)
;-> 4
(poly 1)
;-> 10
(poly 2)
;-> 30
(poly 3)
;-> 82

(lagrange-coeff '((0 4) (1 10) (2 30) (3 82)))
;-> (4 5 -2 2.999999999999998)


-------------------------------
Moltiplicativo modulare inverso
-------------------------------

Un moltiplicativo modulare inverso di un intero a è un intero x tale che a*x è congruente a 1 rispetto al modulo m.  Nella notazione standard dell'aritmetica modulare questa congruenza è scritta come:

a*x ≡ 1 (mod m)

che è il modo abbreviato di scrivere l'affermazione che m divide (esattamente) la quantità a*x - 1, o, in altre parole, il resto dopo aver diviso a*x per l'intero m è 1. In altre parole:

a*x = 1 + k*m (dove k è un numero intero)

Se a ha un modulo inverso m, allora ci sono un numero infinito di soluzioni di questa congruenza che formano una classe di congruenza rispetto a questo modulo.
Si può dimostrare che un tale inverso esiste se e solo se a e m sono coprimi.

(define (modular-multiplicative-inverse a n)
  (local (t nt r nr q tmp out)
    (if (< n 0)
        (setq n (abs n)))
    (if (< a 0)
        (setq a (- n (% (- 0 a) n))))
    (setq t 0)
    (setq nt 1)
    (setq r n)
    (setq nr (mod a n))
    (while (not (zero? nr))
        (setq q (int (div r nr)))
        (setq tmp nt)
        (setq nt (sub t (mul q nt)))
        (setq t tmp)
        (setq tmp nr)
        (setq nr (sub r (mul q nr)))
        (setq r tmp))
    (if (> r 1)
        (setq out nil))
    (if (< t 0)
        (setq out (add t n))
        (setq out t))
    out))

(modular-multiplicative-inverse 42 2017)
;-> 1969


---------------------------
Radice n-esima di un numero
---------------------------

(define (nth-root n a)
  (let ((x1 a)
	(x2 (div a n)))
  (until (= x1 x2)
    (setq x1 x2
	        x2 (div (add (mul x1 (- n 1)) (div a (pow x1 (- n 1))))
		              n))
  )
  x2))

(nth-root 3 8)
;-> 2
(pow 8 (div 3))
;-> 2

(nth-root 25 100)
;-> 1.202264434617413
(pow 100 (div 25))
;-> 1.202264434617413

(nth-root 4 30.5)
;-> 2.350038405769921
(pow 30.5 (div 4))
;-> 2.350038405769921


------------------------------
Prodotto scalare (dot-product)
------------------------------

Funzione per calcolare il prodotto scalare, noto anche come dot-product, di due vettori di lunghezza arbitraria:

(define (dot-product x y)
  (apply add (map mul x y)))

(dot-product '(1 3) '(-2 -1))
;-> -5
(dot-product '(1 3 -5) '(4 -2 -1))
;-> 3

-----------------------------------
Prodotto vettoriale (cross-product)
-----------------------------------

Funzione per calcolare il prodotto vettoriale, noto anche come cross-product, di due vettori in 3 dimesioni:

(define (cross-product x y)
  (let ((xlen (length x)) (ylen (length y)))
    (cond ((or (zero? xlen) (zero? ylen)) '())
          ((or (!= 3 xlen) (!= 3 ylen)) '())
          ((!= xlen ylen) '())
          (true
            (list (sub (mul (x 1) (y 2)) (mul (x 2) (y 1)))
                  (sub (mul (x 2) (y 0)) (mul (x 0) (y 2)))
                  (sub (mul (x 0) (y 1)) (mul (x 1) (y 0))))))))

(cross-product '(3 -5 4) '(2 6 5))
;-> (-49 -7 28)
(cross-product '(2 3 4) '(5 6 7))
(-3 6 -3)


----------------------------------
Angolo tra due direzioni (bearing)
----------------------------------

Trovare l'angolo che è il risultato della sottrazione b2 - b1, dove b1 e b2 sono gli angoli delle direzioni.
Gli angoli di input sono espressi nell'intervallo da -180 a +180 gradi.
Il risultato è espresso nell'intervallo compreso tra -180 e +180 gradi.

(define (bearing b1 b2) (sub (mod (add (mod (sub b1 b2) 360.0) 540.0) 360.0) 180.0))

(bearing- 20 45)
;-> -25
(bearing- -45 45)
;-> -90
(bearing- 85 90)
;-> -5
(bearing- -95 90)
;-> 175

Per la navigazione, potremmo voler sapere se b1 è a sinistra o a destra di b2. (Si presume che esattamente 0 non sia un caso valido)

(define (bearings-left-right b1 b2)
  (if (> (sub (mod (sub (add b1 540) b2) 360) 180) 0)
      'left
      'right))

(bearings-left-right -20 -21)
(bearings-left-right 20 35)
;-> right
(bearings-left-right -95 90)
;-> left


-------------------
URL encoder/decoder
-------------------

URL encoder
-----------
Fornire una funzione per convertire una stringa fornita in una rappresentazione di codifica URL (encode).
Nella codifica URL, caratteri speciali, caratteri di controllo e caratteri estesi vengono convertiti in un simbolo di percentuale seguito da un codice esadecimale a due cifre. Quindi un carattere spazio codifica in %20 all'interno della stringa.

Per gli scopi di questa attività, tutti i caratteri tranne 0-9, A-Z e a-z richiedono la conversione, quindi i seguenti caratteri richiedono tutti la conversione per impostazione predefinita:

Codici di controllo ASCII (intervalli di caratteri 00-1F esadecimale (0-31 decimale) e 7F (127 decimale).
Simboli ASCII (intervalli di caratteri 32-47 decimali (20-2F hex))
Simboli ASCII (intervalli di caratteri 58-64 decimali (3A-40 hex))
Simboli ASCII (intervalli di caratteri 91-96 decimali (5B-60 hex))
Simboli ASCII (intervalli di caratteri 123-126 decimali (7B-7E hex))
Caratteri estesi con codici carattere da 128 decimali (80 esadecimale) e superiori.

Esempio
La stringa "http://foo bar/" verrebbe codificata come "http%3A%2F%2Ffoo%20bar%2F".

;; simple encoder
;; (source http://www.newlisp.org/index.cgi?page=Code_Snippets)
(define (url-encode str)
  (replace {([^a-zA-Z0-9])} str (format "%%%2X" (char $1)) 0))

(url-encode "http://foo bar/")
;-> "http%3A%2F%2Ffoo%20bar%2F"
(url-encode "google.com/search?q=`Abdu'l-Bahá")
;-> "google%2Ecom%2Fsearch%3Fq%3D%60Abdu%27l%2DBah%A0"
(url-decode "google%2Ecom%2Fsearch%3Fq%3D%60Abdu%27l%2DBah%A0")
"google.com/search?q=`Abdu'l-Bahá"


URL decoder
-----------
Il problema (l'opposto della codifica (encode) URL e distinto dal parser URL) è fornire una funzione per convertire una stringa codificata in URL nella sua forma originale non codificata (decode).

Esempi
   La stringa codificata "http% 3A% 2F% 2Ffoo% 20bar% 2F" dovrebbe essere ripristinata nel formato non codificato "http: // foo bar /".
   La stringa codificata "google.com/search?q=%60Abdu%27l-Bah%C3%A1" dovrebbe tornare alla forma non codificata "google.com/search?q=`Abdu'l-Bahá".

;; universal decoder, works for ASCII and UTF-8
;; (source http://www.newlisp.org/index.cgi?page=Code_Snippets)

(define (url-decode url (opt nil))
  (if opt (replace "+" url " "))
  (replace "%([0-9a-f][0-9a-f])" url (pack "b" (int $1 0 16)) 1))

(url-decode "http%3A%2F%2Ffoo%20bar%2F")
;-> "http://foo bar/"
(url-decode "google.com/search?q=%60Abdu%27l-Bah%C3%A1")
;-> "google.com/search?q=`Abdu'l-Bah├í"


-----------------
Funzione gamma-ln
-----------------

newLISP fornisce una funzione predefinita per la funzione Gamma.

********************
>>>funzione gammaln
********************
sintassi: (gammaln num-x)

Calcola il logaritmo della funzione Gamma in num-x.

(exp (gammaln 6))
;-> 119.9999999999998

L'esempio utilizza l'uguaglianza di n! = gamma (n + 1) per calcolare il valore fattoriale di 5.

La funzione Log Gamma è anche correlata alla funzione Beta, da cui si può derivare:

Beta(z,w) = Exp(Gammaln(z) + Gammaln(w) - Gammaln(z+w))

L'implementazione che segue è stata presa dal libro "Numerical Recipes in C" e convertita in newLISP:

(define (gamma-ln xx)
  (local (x tmp y ser cof)
    (setq cof '(57.1562356658629235 -59.5979603554754912
	14.1360979747417471 -0.491913816097620199 .339946499848118887e-4
	.465236289270485756e-4 -.983744753048795646e-4 .158088703224912494e-3
	-.210264441724104883e-3 .217439618115212643e-3 -.164318106536763890e-3
	.844182239838527433e-4 -.261908384015814087e-4 .368991826595316234e-5))
    (setq x xx y xx)
	  (setq tmp (add x 5.24218750000000000))
	  (setq tmp (sub (mul (add x 0.5) (log tmp)) tmp))
	  (setq ser 0.999999999999997092)
    (for (j 0 13) (setq ser (add ser (div (cof j) (setq y (add y 1))))))
    (add tmp (log (div (mul 2.5066282746310005 ser) x)))
  ))

(gamma-ln 10)
;-> 12.80182748008147
(gammaln 10)
;-> 12.80182748008196

(exp (gamma-ln 6))
;-> 119.9999999999998

Vediamo se le due funzioni danno risultati uguali:

(for (i 1 1000000)
  (if (> (abs (sub (gammaln i) (gamma-ln i))) 1e-8)
   (println i)))
;-> nil

Nota: con l'aumentare del valore dell'argomento, aumenta la differenza tra le due funzioni.

Come al solito la funzione predefinita è molto più veloce:

(time (map gammaln (sequence 1 1000000)))
;-> 80.842

(time (map gamma-ln (sequence 1 1000000)))
;-> 2410.738


--------------------
select per i vettori
--------------------

La funzione primitiva "select" funziona solo con le liste e le stringhe. Scriviamo una funzione analoga per i vettori:

(setq lst '(3 5 6 7 1 9))
(select lst '(2 4))
;-> (6 1)
(select lst '(-1 0))
;-> (9 3)

(setq vet (array (length lst) lst))
;-> (3 5 6 7 1 9)

Versione iterativa:

(define (select-array arr lst-idx)
  (let (lst-val '())
    (dolist (idx lst-idx)
      (push (arr idx) lst-val -1)
    )
    (array (length lst-val) lst-val)
  )
)

(select-array vet '(0 1))
;-> (3 5)

(select-array vet '(0 1 -1))
;-> (3 5 9)

(select-array vet '(-1 -2 -3 0 1 2))
;-> (9 1 7 3 5 6)

(select-array vet '(3 3 3))
;-> (7 7 7)

(select-array vet '(0 1 6))
;-> ERR: array index out of bounds in function push : 6
;-> called from user function (select-array vet '(0 1 6))

(array? (select-array vet '(4 1)))
;-> true

Versione funzionale:

(define (select-array2 arr lst-idx)
    (array (length lst-idx)
           (map (fn(x) (arr x)) lst-idx))
)

(select-array2 vet '(0 1))
;-> (3 5)

(select-array2 vet '(0 1 -1))
;-> (3 5 9)

(select-array2 vet '(-1 -2 -3 0 1 2))
;-> (9 1 7 3 5 6)

(select-array2 vet '(3 3 3))
;-> (7 7 7)

(select-array2 vet '(0 1 6))
;-> ERR: array index out of bounds in function map : 6
;-> called from user function (select-array2 vet '(0 1 6))

(array? (select-array2 vet '(4 1)))
;-> true

Versione che utilizza "select":

(define (select-array3 arr lst-idx)
  (array (length lst-idx) (select (array-list arr) lst-idx)))

(select-array3 vet '(0 1))
;-> (3 5)

(select-array3 vet '(0 1 -1))
;-> (3 5 9)

(select-array3 vet '(-1 -2 -3 0 1 2))
;-> (9 1 7 3 5 6)

(select-array3 vet '(3 3 3))
;-> (7 7 7)

(select-array3 vet '(0 1 6))
;-> ERR: invalid list index
;-> called from user function (select-array3 vet '(0 1 6))

(array? (select-array3 vet '(4 1)))
;-> true

Vediamo quale delle tre funzioni è la più veloce:

Vettore con centomila elementi (da 1 a 100000)
(silent (setq t (array 100000 (sequence 1 100000))))

Lista con diecimila indici (da 0 a 9999 mischiati)
(silent (setq ind (randomize (sequence 0 9999))))

(time (select-array t ind) 100)
;-> 187.451

(time (select-array2 t ind) 100)
;-> 187.449

(time (select-array3 t ind) 100)
;-> 6375.477

La funzione "select-array3" è molto lenta, allora proviamo la velocità della funzione primitiva "select":

Lista con centomila elementi (da 1 a 100000)
(silent (setq tlist (sequence 1 100000)))

(time (select tlist ind) 100)
;-> 4297.146

Scriviamo una versione di "select" che usa "select-array":

(define (select-list lst lst-idx)
  (array-list (select-array (array (length lst) lst) lst-idx)))

(setq lst '(3 5 6 7 1 9))

(select-list lst '(0 1))
;-> (3 5)

(select-list lst '(0 1 -1))
;-> (3 5 9)

(select-list lst '(-1 -2 -3 0 1 2))
;-> (9 1 7 3 5 6)

(select-list lst '(3 3 3))
;-> (7 7 7)

(select-list lst '(0 1 6))
;-> ERR: array index out of bounds in function push : 6
;-> called from user function (select-array (array (length lst) lst) lst-idx)
;-> called from user function (select-list lst '(0 1 6))

(list? (select-list lst '(4 1)))
;-> true

(time (select-list tlist ind) 100)
;-> 281.184

(div 4297.146 281.184)
;-> 15.282327

La funzione-utente "select-list" è 15 volte più veloce della funzione primitiva "select".

Il risultato è abbastanza strano, quindi facciamo un test con una lista con pochi valori (100):

Lista con cento elementi (da 1 a 100)
(setq alist (sequence 1 100))

Lista con cento indici (da 0 a 99 mischiati)
(setq aind (randomize (sequence 0 99)))

Proviamo la nostra funzione "select-list":
(time (select-list alist aind) 100000)
;-> 1116.293

Proviamo la funzione integrata "select":
(time (select alist aind) 100000)
;-> 294.371

Questa volta è più veloce la funzione integrata.
Quindi con pochi elementi conviene usare "select", mentre con tanti elementi conviene usare "select-list".


-----------------------------
Lunghezza di un numero intero
-----------------------------

Chiamiamo L(n) la lunghezza di un numero intero n.

       10^(d-1) <= n < 10^d
(d - 1)*log(10) <= log(n) < d*log(10)
        (d - 1) <= log(n)/log(10) < d
              d <= log10(n) + 1 < d + 1
              d = floor(1 + log10(n))
           L(n) = floor(1 + log10(n))

Scriviamo la funzione:

(define (len-num n)
  (floor (+ (log (abs n) 10) 1)))

(setq x 1234525454553452)
(len-num x)
;-> 16
La funzione integrata "length" calcola anche la lunghezza di un numero intero:
(length x)
;-> 16

(len-num (- x))
;-> 16
(length (- x))
;-> 16

Se passiamo un numero in virgola mobile, allora viene restituita solo la lunghezza della parte intera:
(length 1.345)
;-> 1
(len-num 1.345)
;-> 1
(length 0.345)
;-> 1
(len-num 0.345)
;-> 1
(length 10.345)
;-> 2
(len-num 10.345)
;-> 2

Vediamo la differenza di velocità:

(time (len-num x) 1000000)
;-> 140.583

(time (length x) 1000000)
;-> 78.098


---------------
Normalizzazione
---------------

Formula generale per normalizzare una lista di numeri nell'intervallo (a,b):

              (val - min-val)*(b - a)
new-val = a + -----------------------
                (max-val - min-val)

Con a=0 e b=1 la formula diventa:

              (val - min-val)
new-val = -----------------------
            (max-val - min-val)

(setq nums '(2 4 10 6 8 4))

(define (normalizza01 lst)
  (local (hi lo out)
    (setq out '())
    (setq hi (apply max lst))
    (setq lo (apply min lst))
    (dolist (val lst)
      (push (div (mul (sub val lo) ((sub hi lo)) out -1))
    out))

(normalizza01 nums)
;-> (0 0.25 1 0.5 0.75 0.25)

Adesso scriviamo la funzione generale:

(define (normalizza lst a b)
  (local (hi lo out)
    (setq out '())
    (setq hi (apply max lst))
    (setq lo (apply min lst))
    (dolist (val lst)
      (push (add a (div (mul (sub val lo) (sub b a)) (sub hi lo))) out -1))
    out))

(normalizza nums 0 1)
;-> (0 0.25 1 0.5 0.75 0.25)

(normalizza nums 100 200)
;-> (100 125 200 150 175 125)

(time (normalizza nums 100 200) 100000)
;-> 171.568

Questo è corretto, ma non efficiente. È una trasformazione lineare, quindi possiamo precalcolare la parte costante e riscrivere la formula:

                                       (b - a)
new-val = a + (val - min-val) * -----------------------
                                  (max-val - min-val)

(define (normalizza lst a b)
  (local (hi lo k out)
    (setq out '())
    (setq hi (apply max lst))
    (setq lo (apply min lst))
    (setq k (div (sub b a) (sub hi lo)))
    (dolist (val lst)
      (push (add a (mul (sub val lo) k)) out -1))
    out))

(normalizza nums 0 1)
;-> (0 0.25 1 0.5 0.75 0.25)

(normalizza nums 100 200)
;-> (100 125 200 150 175 125)

(time (normalizza nums 100 200) 100000)
;-> 128.655


---------
Papersize
---------

Una funzione per calcolare le dimensioni standard dei fogli di carta per la stampa. I risultati sono in milllimetri.

; side: misura del lato (float)
; k: numero del formato (int)
(define (side k)
    (if (< k 2)
        (if (= k 0) s0 s1)       ; misure conosciute
        (div (side (- k 2)) 2))) ; piegando due volte la lunghezza dei lati si dimezza

(define (papersize type k)
  (local (s0 s1)
    (cond ((= type 'A)
           (setq s0 (mul 1000 (pow 2 (div 1 4))))
           (setq s1 (div s0 (sqrt 2))))
          ((= type 'B)
           (setq s0 (mul 1000 (sqrt 2)))
           ;(setq s1 (div s0 (sqrt 2)))
           (setq s1 (mul 1000 1)))
          ((= type 'C)
           (setq s0 (mul 1000 (pow 8 (div 1 8))))
           (setq s1 (div s0 (sqrt 2))))
    )
    (list (side (+ k 1)) (side k))))

(papersize 'A 4)
;-> (210.2241038134286 297.3017787506803)

(for (i 0 10) (println (format "%d %d" ((papersize 'A i) 0) ((papersize 'A i) 1))))
;-> 840 1189
;-> 594 840
;-> 420 594
;-> 297 420
;-> 210 297
;-> 148 210
;-> 105 148
;-> 74 105
;-> 52 74
;-> 37 52
;-> 26 37

(for (i 0 10) (println (format "%d %d" ((papersize 'B i) 0) ((papersize 'B i) 1))))
;-> 1000 1414
;-> 707 1000
;-> 500 707
;-> 353 500
;-> 250 353
;-> 176 250
;-> 125 176
;-> 88 125
;-> 62 88
;-> 44 62
;-> 31 44

(for (i 0 10) (println (format "%d %d" ((papersize 'C i) 0) ((papersize 'C i) 1))))
;-> 917 1296
;-> 648 917
;-> 458 648
;-> 324 458
;-> 229 324
;-> 162 229
;-> 114 162
;-> 81 114
;-> 57 81
;-> 40 57
;-> 28 40


----------------------------------------------
Verificare se due numeri hanno lo stesso segno
----------------------------------------------

Due numeri hanno lo stesso segno se la loro moltiplicazione è maggiore di zero.
Oppure controllando se il test "maggiori di zero" è uguale per entrambi i numeri.

(define (same-sign x y) (= (> x 0) (> y 0)))

(same-sign 2 2)
;-> true
(same-sign -2 2)
;-> nil
(same-sign -2 -2)
;-> true
(same-sign 2 -2)
;-> nil


-------------------------
Suddivisione di una lista
-------------------------

Una funzione per dividere una lista in sotto-liste: data una lista di input da dividere e una lista di lunghezze delle sotto-liste, restituire una lista di sotto-liste che hanno le lunghezze richieste. Ad esempio: dividendo la lista (1 2 2 3 3 3) in sotto-liste di lunghezze (1 2 3) restituire la lista delle sotto-liste ((1) (2 2) (3 3 3)).
Gli eventuali elementi aggiuntivi finali della lista di input vengono ignorati.
Gli eventuali elementi mancanti alla fine della lista di input vengono ignorati.

Vediamo passo-passo come funziona (i = indice iniziale, q = quanti elementi prendere):

(setq lst '(a b c d e))
(setq d '(2 1 2))
(setq i 0 q (d 0))
(slice lst i q)
;-> (a b)

(setq i (+ i q) q (d 1))
(slice lst i q)
;-> (c)

(setq i (+ i q) q (d 2))
(slice lst i q)
;-> (d e)

Adesso possiamo scrivere la funzione finale:

(define (subdivide lst lst-len)
  (let ((i 0) (q 0) (out '()))
    (dolist (el lst-len)
      (setq i (+ i q))
      (setq q el)
      (push (slice lst i q) out -1)
    )
    out))

(setq lst '(a b c d e f))
(setq d '(2 1 2))
(subdivide lst d)
;-> ((a b) (c) (d e))

(setq lst '(a b c d))
(setq d '(2 1 2))
(subdivide lst d)
;-> ((a b) (c) (d))

(setq lst '(a b c d))
(setq d '(5))
(subdivide lst d)
;-> ((a b c d))

(setq lst '(a b c d))
(setq d '(2))
(subdivide lst d)
;-> ((a b))

(setq lst '(a b c d e f g h i j))
(setq d '(1 2 3 4))
(subdivide lst d)
;-> ((a) (b c) (d e f) (g h i j))


-------------------
Stampo di un numero
-------------------

Questa funzione conta le occorrenze di ogni cifra di un numero. Il risultato è un numero intero da una a dieci cifre che chiameremo "stampo". La n-esima cifra del risultato rappresenta quante volte la cifra "n" si ripete nel numero dato.

Esempio: (number-stamp 121232) = 1320
perché "3" appare una volta (1) , "2" tre volte (3), "1" due volte (2) e "0" zero volte (0).

Due numeri che sono permutazione uno dell'altro hanno lo stesso "stampo" (e viceversa).

Scriviamo diverse versioni di questa funzione e poi verifichiamo quale sia la più veloce.

Prima versione:

(define (number-stamp1 num)
  (let ((out 0) (digit 0) (pos 0) (i 0))
    (while (> num 0)
      (setq digit (% num 10))
      (setq num (/ num 10))
      (setq pos 1)
      (if (> digit 0)
          (for (i 1 digit)
            (setq pos (* 10 pos))
          )
      )
      (setq out (+ out pos))
    )
    out))

(number-stamp1 121232)
;-> 1320
(number-stamp1 1234567890)
;-> 1111111111
(number-stamp1 12345678901234567890)
;-> 2222222222

Seconda versione:

(define (number-stamp2 num)
  (let ((lst-num '()) (out 0))
    (while (!= num 0)
      (push (% num 10) lst-num)
      (setq num (/ num 10))
    )
    ; create output number from list of digit's count
    (dolist (el (count '(9 8 7 6 5 4 3 2 1 0) lst-num))
      (setq out (+ el (* out 10)))
    )
    out))

Vediamo se producono risultati uguali:

(= (map number-stamp1 (sequence 1 100000)) (map number-stamp2 (sequence 1 100000)))
;-> true

Terza versione:

(define (number-stamp3 num)
  (let ((ar (array 10 '(0))) (out 0))
    ; fill array with the count of digits
    (while (> num 0)
      (++ (ar (% num 10)))
      (setq num (/ num 10))
    )
    ; create output number from array
    (for (i 9 0)
      (setq out (+ (ar i) (* out 10)))
    )
    out))

Vediamo se producono risultati uguali:

(= (map number-stamp2 (sequence 1 100000)) (map number-stamp3 (sequence 1 100000)))
;-> true

Adesso vediamo i tempi di esecuzione:

(time (map number-stamp1 (sequence 1 1000000)))
;-> 2534.422

(time (map number-stamp2 (sequence 1 1000000)))
;-> 2437.09

(time (map number-stamp3 (sequence 1 1000000)))
;-> 1900.202

La terza versione è la più veloce.


------------------------------
Conversione vettore <--> lista
------------------------------

Per convertire un vettore in una lista abbiamo una funzione primitiva "array-list":

(setq vet (array 6 '(1 3 3 9 2 8)))
(setq lst (array-list vet))
;-> (1 3 3 9 2 8)

(list? lst)
;-> true
(array? lst)
;-> nil
(list? vet)
;-> nil
(array? vet)
;-> true

Per convertire una lista in un vettore scriviamo una funzione "list-array" utilizzando il metodo di assegnazione di valori ad un vettore durante la sua creazione:

(define (list-array lst)
  (array (length lst) lst))

(setq lst '(1 2 3 4 5))
(setq vet (list-array lst))
;-> (1 2 3 4 5)

(list? lst)
;-> true
(array? lst)
;-> nil
(list? vet)
;-> nil
(array? vet)
;-> true


----
one?
----

La seguente funzione non serve a niente, è solo per estetica, ma a me piace.

(define (one? num) (= num 1))

(one? 1)
;-> true
(one? 1.0)
;-> true
(one? 0)
;-> nil


----------------------------
Algoritmo Knuth-Morris-Pratt
----------------------------

L'algoritmo di Knuth-Morris-Pratt (algoritmo KMP) permette di trovare le occorrenze di una stringa (pattern di ricerca) S in un testo T. La caratteristica consiste nel pretrattamento della stringa da cercare in modo che, in caso di non-corrispondenza, non sia necessario riesaminare i caratteri precedenti. Questo permette all'algoritmo di minimizzare il numero di confronti necessari. La complessità temporale vale O(n+k), dove n è la lunghezza del testo e k è la lunghezza della stringa.

L'algoritmo è stato inventato da Knuth e Pratt, e indipendentemente da J. H. Morris nel 1975.

(define (max-border-len str)
  (local (lenstr mbl k)
    (setq lenstr (length str))
    (setq mbl (array lenstr '(0)))
    ; lunghezza del bordo corrente
    (setq k 0)
    (for (i 1 (- lenstr 1))
      (while (and (!= (str k) (str i)) (> k 0))
        ; diversi: prova il prossimo bordo
        (setq k (mbl (- k 1)))
      )
      ; ultimo carattere uguale?
      (if (= (str k) (str i))
        ; aumenta la lunghezza del bordo
        (++ k)
      )
      ; trovato bordo massimo di str (partendo da i + 1)
      (setf (mbl i) k)
    )
    mbl))

(max-border-len "AAAABABABAB")
;-> (0 1 2 3 0 1 0 1 0 1 0)

(max-border-len "massimo")
;-> (0 0 0 0 0 1 0)

(max-border-len "pippo")
;-> (0 0 1 1 0)

(max-border-len "abracadabra")
;-> (0 0 0 1 0 1 0 1 2 3 4)

(max-border-len "aaaaa")
;-> (0 1 2 3 4)

(define (knuth-morris-pratt str txt)
  (local (sep mbl lenstr out)
    (setq out '()) ; lista di output
    ; Il carattere sep non deve essere presente
    ; ne in txt ne in str
    (setq sep "~") ; carattere speciale non usato
    (setq mbl (max-border-len (string str sep txt)))
    (setq lenstr (length str))
    (dolist (el mbl)
      (if (= el lenstr) ; trovato un bordo della lunghezza di str
        ; inizio del bordo in txt
        ; stringa str trovata in txt
        (push (- $idx (* 2 lenstr)) out -1)
      )
    )
    out))

(knuth-morris-pratt "abra" "abracadabra")
;-> (0 7)

(knuth-morris-pratt "a" "ababababa")
;-> (0 2 4 6 8)

(knuth-morris-pratt "a" "aaaaa")
;-> (0 1 2 3 4)

(ref-all "a" (explode "aaaaa"))
;-> ((0) (1) (2) (3) (4))

(knuth-morris-pratt "ABAB" "ABABDABACDABABCABAB")
;-> (0 10 15)


--------------------------
Heap binario (Binary Heap)
--------------------------

Un heap binario è un albero binario con le seguenti proprietà:

1) È un albero completo (tutti i livelli sono completamente riempiti tranne forse l'ultimo livello e l'ultimo livello ha tutte le chiavi il più a sinistra possibile). Questa proprietà del Binary Heap lo rende adatto per essere archiviato in un vettore (array).

2) Un Binary Heap può essere Min-Heap o Max-Heap. In un Binary Heap minimo (Min-Heap), la chiave alla radice deve essere minima tra tutte le chiavi presenti in heap binario. La stessa proprietà deve essere ricorsivamente vera per tutti i nodi dell'albero binario. Un Binary Heap massimo (Max-Heap) è simile a Min-Heap.

L'Heap binario soddisfa la proprietà di ordinamento.

L'ordinamento può essere di due tipi:

1. Proprietà Min-Heap: il valore di ogni nodo è maggiore o uguale al valore del suo genitore, con il valore minimo alla radice.

2. Proprietà Max-Heap: il valore di ogni nodo è minore o uguale al valore del suo genitore, con il valore massimo alla radice.

Esempi di Min-Heap:

          10                  10
         /  \               /    \
       20    100          15      30
      /                  /  \    /  \
    30                  40  50  100 40

Come viene rappresentato l'Heap binario?

Poichè un Heap binario è un albero binario completo possiamo rappresentato con un array. L'elemento radice sarà in Array[0]. La tabella seguente mostra gli indici di altri nodi per l'i-esimo nodo, ovvero Array[i]:
Array[(i - 1) / 2]  Restituisce il nodo genitore
Array[(2 * i) + 1] Restituisce il nodo figlio sinistro
Array[(2 * i) + 2] Restituisce il nodo figlio destro

Il metodo di attraversamento utilizzato per ottenere la rappresentazione dell'array è l'ordine dei livelli:

            (0)
           1
          / \
         /   \
    (1) /     \ (2)
       3       6
      / \     /
     /   \   /
    5     9 8
 (3)   (4)   (5)

    (1 3 6 5 9 8)
     0 1 2 3 4 5

Operazioni di base su un Min-Heap:

1) get-min(): restituisce l'elemento radice di Min Heap. La complessità temporale di questa operazione è O(1).

2) extract-min(): rimuove l'elemento minimo da MinHeap. La complessità temporale di questa operazione è O(Logn) poiché questa operazione deve mantenere la proprietà heap (chiamando min-heapify()) dopo aver rimosso root.

3) decrease-key(): diminuisce il valore della chiave. La complessità temporale di questa operazione è O(Logn). Se il valore della chiave di diminuzione di un nodo è maggiore del genitore del nodo, non è necessario fare nulla. Altrimenti, dobbiamo attraversare l'albero per correggere la proprietà heap violata.

4) increase-key(): aumenta il valore della chiave. La complessità temporale di questa operazione è O(Logn). Se il valore della chiave encreases di un nodo è inferiore al genitore del nodo, non è necessario fare nulla. Altrimenti, dobbiamo attraversare l'albero per correggere la proprietà heap violata.

5) insert-key(): l'inserimento di una nuova chiave richiede tempo O(Logn). Aggiungiamo una nuova chiave alla fine dell'albero. Se la nuova chiave è maggiore del suo genitore, non è necessario fare nulla. Altrimenti, dobbiamo attraversare l'albero per correggere la proprietà heap violata.

6) delete-key(): Anche l'eliminazione di una chiave richiede tempo O(Logn). Sostituiamo la chiave da cancellare con meno infinito chiamando decrement-key(). Dopo decrement-key(), il valore meno infinito deve raggiungere root, quindi chiamiamo extract-min() per rimuovere la chiave.

7) change-value-key(): modifica il valore di una chiave. La complessità temporale di questa operazione è O (Logn). Se il nuovo valore della chiave è uguale al valore della chiave del suo genitore, non è necessario fare nulla. Altrimenti, dobbiamo spostarci verso l'alto per correggere la proprietà heap violata.

Di seguito è riportata l'implementazione delle operazioni di base per un Min-Heap:

; Dimensione massima dell'heap
(setq heap-max-size 100)

; Dimensione corrente del'heap
(setq heap-current-size 0)

; definizione del vettore di heap
(setq heap (array heap-max-size '(nil)))

; Ritorna l'indice genitore (parent) per l'indice specificato
(define (parent key) (/ (- key 1) 2))

; Ritorna l'indice sinistro (left) per l'indice specificato
(define (left key) (+ (* key 2) 1))

; Ritorna l'indice destro (left) per l'indice specificato
(define (right key) (+ (* key 2) 2))

; Restituisce la chiave minima (la chiave alla radice) di min-heap
(define (get-min) (heap 0))

; Restituisce e rimuove la chiave minima (la chiave alla radice) di min-heap
(define (extract-min)
  (local (root)
    (cond ((<= heap-current-size 0) 9223372036854775807)
          ((= heap-current-size 1)
          (-- heap-current-size)
          (heap 0))
          ; Store the minimum value and remove it from heap
          (true
            (setq root (heap 0))
            (setf (heap 0) (heap (- heap-current-size 1)))
            (-- heap-current-size)
            (min-heapify 0)
            root))))

; Diminuisce il valore della chiave a new-val.
; (Si suppone che new-val sia minore di heap[key])
(define (decrease-key key new-val)
  (if (> new-val (heap key)) (println "error: decrease-key"))
  ; Aggiorna il valore
  (setf (heap key) new-val)
  ; Aggiusta la proprietà min-heap se è stata violata
  (while (and (!= key 0) (< (heap key) (heap (parent key))))
    (swap (heap key) (heap (parent key)))
    (setq key (parent key))
  ))

; Aumenta il valore della chiave a new-val.
; (Si suppone che new-val sia maggiore di heap[key])
(define (increase-key key new-val)
  (if (< new-val (heap key)) (println "error: increase-key"))
  ; Aggiorna il valore
  (setf (heap key) new-val)
  (min-heapify key))

; Inserisce una nuova chiave
(define (insert-key key)
  (let (i heap-current-size)
    (cond ((= heap-current-size heap-max-size) nil)
          (true
            ; Prima inserisce la chiave alla fine
            (setf (heap i) key)
            (++ heap-current-size)
            ; Poi aggiusta la proprietà min-heap se è stata violata
            (while (and (!= i 0) (< (heap i) (heap (parent i))))
              (swap (heap i) (heap (parent i)))
              (setq i (parent i))
            ))
    )
    true))

; Elimina la chiave in corrispondenza dell'indice specificato.
; Prima ha riduce il valore a meno infinito, poi chiama extract-min()
(define (delete-key key)
  (decrease-key key -9223372036854775808)
  (extract-min))

; Metodo ricorsivo per "min-heapify" un sotto-albero
; con la radice in un dato indice
; Questo metodo presuppone che i sotto-alberi siano già "min-heapify"
(define (min-heapify key)
  (local (l r smallest)
    (setq l (left key))
    (setq r (right key))
    (setq smallest key)
    (if (and (< l heap-current-size) (< (heap l) (heap smallest)))
        (setq smallest l)
    )
    (if (and (< r heap-current-size) (< (heap r) (heap smallest)))
        (setq smallest r)
    )
    (if (!= smallest key) (begin
        (swap (heap key) (heap smallest))
        (min-heapify smallest))
    )))

; Cambia il valore di una chiave
(define (change-value-key key new-val)
  (cond ((= (heap key) new-val) new-val)
        ((< (heap key) new-val)
          (increase-key key new-val))
        ((> (heap key) new-val)
          (decrease-key key new-val))
  ))

Adesso possiamo definire un Min-Heap e provare alcune funzioni:

(setq heap-max-size 11)
(setq heap-current-size 0)
(setq heap (array heap-max-size '(nil)))
(insert-key 3)
(insert-key 2)
(delete-key 1)
(insert-key 15)
(insert-key 5)
(insert-key 4)
(insert-key 45)
(extract-min)
;-> 2
(get-min)
;-> 4
(decrease-key 2 1)
(get-min)
;-> 1
heap
;-> (1 15 4 45 45 nil nil nil nil nil nil)
heap-current-size
;-> 4

Nota: l'ultimo termine del min-heap (45) non viene considerato, infatti se inseriamo un nuovo valore:

(insert-key 46)
heap
;-> (1 15 4 45 46 nil nil nil nil nil nil)

il valore viene sovrascritto.


----------
Flood Fill
----------

Un'immagine è rappresentata da una matrice 2-D di numeri interi, ogni numero intero rappresenta il valore (da 0 a 65535) del colore dei pixel dell'immagine.

Data una coordinata (x, y) che rappresenta il pixel iniziale (riga e colonna) e un valore di colore (colore-nuovo) per il pixel, colorare tutti i pixel connessi a (x, y) con il nuovo colore.
Alla fine, restituire l'immagine modificata.

L'algoritmo "Flood fill" individua un punto all'interno dell'area/matrice e, a partire da quel punto, colora tutto quello che ha intorno fermandosi solo quando incontra un confine, ovvero un pixel di colore differente.

L'algoritmo richiede 2 parametri: il pixel iniziale e il colore di riempimento. La formulazione più semplice è ricorsiva. Si individua un pixel qualsiasi appartenente all'area da colorare, si controllano i vicini e se hanno un colore uguale lo si cambia con quello scelto, altrimenti si prosegue.

Flood-fill (pixel(x y), colore-nuovo):
 0. colore-prima = colore pixel(x y)
 1. Se il colore di pixel è diverso da colore-prima, termina.
 2. Imposta il colore di pixel a colore-nuovo.
 3. Esegui Flood-fill (pixel ad ovest di pixel colore-nuovo).
    Esegui Flood-fill (pixel a nord di pixel colore-nuovo).
    Esegui Flood-fill (pixel ad est di pixel colore-nuovo).
    Esegui Flood-fill (pixel a sud di pixel colore-nuovo).
 4. Termina.

(define (flood-fill img x y new-color)
  (local (old-color dir max-x max-y)
    (setq max-x (length img))
    (setq max-y (length (img 0)))
    (setq dir '((0 1) (0 -1) (1 0) (-1 0)))
    ;------------------
    ; recursive fill
    (define (fill x y)
    (catch
      (local (new-x new-y)
        (setq old-color (img x y))
        (if (= old-color new-color) (throw img))
        (setf (img x y) new-color)
        (for (i 0 (- (length dir) 1))
          (setq new-x (+ x (dir i 0)))
          (setq new-y (+ y (dir i 1)))
          (cond ((or (< new-x 0) (>= new-x max-x) (< new-y 0) (>= new-y max-y)) nil)
                ((!= (img new-x new-y) old-color) nil)
                (true (fill new-x new-y))
          )
        )
        img)))
     ;------------------
     (fill x y)))

Proviamo la funzione:

(setq image '((1 1 1)
              (1 1 0)
              (1 0 1)))

(flood-fill image 0 0 2)
;-> ((2 2 2) 
;->  (2 2 0) 
;->  (2 0 1))

(flood-fill image 2 2 2)
;-> ((1 1 1) 
;->  (1 1 0) 
;->  (1 0 2))

(setq image '(
      (0 0 1 0 1 1 1 1 0 0 0 1 1 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1)
      (1 0 1 1 1 0 1 1 1 1 1 0 1 1 1 1 0 1 0 1 0 1 0 0 1 1 1 1 1 1)
      (0 0 1 0 1 0 0 1 1 1 1 1 1 1 0 1 1 0 1 1 1 0 1 0 1 0 1 0 1 0)
      (1 0 1 1 0 1 0 1 0 1 0 1 0 1 1 1 1 1 1 1 1 0 1 0 0 0 1 1 1 1)
      (1 0 1 1 1 1 0 1 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
      (0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
      (0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
      (0 0 0 0 0 0 1 0 0 0 0 0 1 1 1 1 0 0 1 1 1 1 0 1 1 1 1 0 1 1)
      (1 1 0 1 1 1 0 1 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 1 1 0 1 0 1 0)
      (1 0 0 1 1 1 1 1 1 0 0 0 0 0 0 1 1 1 0 1 1 0 0 0 1 1 1 0 0 1)
      (1 0 0 0 0 0 1 1 1 0 0 0 1 1 1 0 0 1 1 0 0 0 0 1 1 0 0 1 1 1)
      (0 0 0 1 1 1 1 0 0 0 0 1 1 1 0 0 0 1 1 0 0 1 1 1 1 0 0 0 1 1)
      (1 0 0 1 1 1 0 0 0 1 1 1 0 0 0 0 1 1 0 1 0 0 0 1 1 1 0 0 0 1)
      (1 1 0 0 0 1 1 1 0 0 0 0 0 0 0 1 1 1 1 1 1 0 1 1 1 0 1 1 1 0)
      (1 1 1 0 1 1 0 1 1 1 0 0 1 1 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 1)
      (1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 1 0 1 0 1 0 1 0 1)
      (0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 0 1 0 1 0 1 1)
      (0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 0 1 0 1 0 1 1)))

(flood-fill image 0 0 8)
;-> ((8 8 1 0 1 1 1 1 0 0 0 1 1 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1) 
;->  (1 8 1 1 1 8 1 1 1 1 1 0 1 1 1 1 0 1 0 1 0 1 8 8 1 1 1 1 1 1)
;->  (8 8 1 0 1 8 8 1 1 1 1 1 1 1 0 1 1 0 1 1 1 8 1 8 1 8 1 0 1 0)
;->  (1 8 1 1 0 1 8 1 8 1 8 1 8 1 1 1 1 1 1 1 1 8 1 8 8 8 1 1 1 1)
;->  (1 8 1 1 1 1 8 1 8 1 8 1 8 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8)
;->  (8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8)
;->  (8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8)
;->  (8 8 8 8 8 8 1 8 8 8 8 8 1 1 1 1 8 8 1 1 1 1 8 1 1 1 1 8 1 1)
;->  (1 1 8 1 1 1 0 1 1 8 1 8 1 8 1 0 1 8 1 0 1 8 1 1 1 0 1 8 1 0)
;->  (1 8 8 1 1 1 1 1 1 8 8 8 8 8 8 1 1 1 0 1 1 8 8 8 1 1 1 8 8 1)
;->  (1 8 8 8 8 8 1 1 1 8 8 8 1 1 1 8 8 1 1 8 8 8 8 1 1 0 0 1 1 1)
;->  (8 8 8 1 1 1 1 8 8 8 8 1 1 1 8 8 8 1 1 8 8 1 1 1 1 0 0 0 1 1)
;->  (1 8 8 1 1 1 8 8 8 1 1 1 8 8 8 8 1 1 0 1 8 8 8 1 1 1 0 0 0 1)
;->  (1 1 8 8 8 1 1 1 8 8 8 8 8 8 8 1 1 1 1 1 1 8 1 1 1 0 1 1 1 0)
;->  (1 1 1 8 1 1 8 1 1 1 8 8 1 1 8 8 8 8 8 8 8 8 8 1 1 0 0 0 1 1)
;->  (1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 1 1 1 8 1 8 1 0 1 0 1 0 1)
;->  (8 8 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 1 1 8 1 8 8 1 0 1 0 1 1)
;->  (8 8 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 1 1 8 1 8 8 1 0 1 0 1 1))


-----------------
Poligoni convessi
-----------------

Determinare se un poligono è convesso. Il poligono è rappresentato da una lista di punti.

Un poligono è convesso se la componente z di tutti i prodotti incrociati (cross-product) ha lo stesso segno.
Questo metodo funziona con i poligoni semplici (senza lati auto-intersecanti) e assume che i vertici siano ordinati (in senso orario o in senso antiorario).

(define (convex? polygon)
(catch
  (local (len dx1 dy1 dx2 dy2 i1 i2 cur pre)
    (setq len (length polygon))
    (setq pre 0) (setq cur 0)
    (for (i 0 (- len 1))
      (setq i1 (+ i 1))
      (if (>= i1 len) (setq i1 (- i1 len)))
      (setq i2 (+ i 2))
      (if (>= i2 len) (setq i2 (- i2 len)))
      (setq dx1 (sub (polygon i1 0) (polygon i 0)))
      (setq dy1 (sub (polygon i1 1) (polygon i 1)))
      (setq dx2 (sub (polygon i2 0) (polygon i1 0)))
      (setq dy2 (sub (polygon i2 1) (polygon i1 1)))
      (setq cur (sub (mul dx1 dy2) (mul dx2 dy1)))
      (if (!= cur 0)
          (if (or (and (> cur 0) (< pre 0)) (and (< cur 0) (> pre 0)))
              (throw nil)
              (setq pre cur)
          )
      )
    )
    true)))

(convex? '((0 0) (1 0) (1 1) (0 1)))
;-> true
(convex? '((0 0) (2 0) (2 2) (0 2) (0 0)))
;-> true
(convex? '((0 0) (2 0) (2 2) (1 1) (0 2)))
;-> nil
(convex? '((0 0) (2 0) (2 2) (1 2) (0 2)))
;-> true
(convex? '((0 0) (2 0) (2 2) (1 1.9) (0 2)))
;-> nil
(convex? '((0 0) (2 0) (2 2) (1 1.999999999999999) (0 2)))
;-> nil
(convex? '((0 0) (2 0) (2 2) (1 1.9999999999999999) (0 2)))
;-> true


----------------------
Variazione percentuale
----------------------

Scrivere una funzione che calcola la variazione percentuale tra due numeri x e y.

(define (delta% x y)
  (div (mul (sub y x) 100) x))

(delta% 50 100)
;-> 100

(delta% 100 50)
;-> -50

(delta% 20 60)
;-> 200

(delta% 60 20)
;-> -66.66666666666667


-------------------------------
Grafico di coppie di coordinate
-------------------------------

Scrivere una funzione che disegna il grafico di una lista di coppie di coordinate, in altre parole disegna il grafico di una serie di punti.

Liste distinte di coordinate x e y per i punti:
(setq lst-x '(1 4 -5 2 10 -6 15))
(setq lst-y '(3 4 6 -2 12 -8 12))

Unione delle due liste di coordinate in una lista di punti:
(setq lst-xy (map list lst-x lst-y))
;-> ((1 3) (4 4) (-5 6) (2 -2) (10 12) (-6 -8) (15 12))

Divisione della lista di punti in due liste di coordinate x e y:
(setq lst-x (map first lst-xy))
(setq lst-y (map last  lst-xy))

Il metodo per stampare i punti al terminale utilizza una matrice di caratteri per simulare un sistema cartesiano di coordinate x e y. La mappatura delle celle della matrice con il sistema cartesiano è il seguente:

- la coordinata (0,0) della matrice si trova in alto a sinistra, mentre la coordinata (0,0) del sistema cartesiano si trova in basso a destra. Questo comporta che prima di stampare la matrice occorrerà invertire le sue righe.

- la coordinata x del punto è la colonna della matrice e la coordinata y è la riga, cioè:
  P(x,y) = Matrice(row,col) = Matrice(y,x)

Prima di tutto ci serve una funzione che normalizza una lista di valori in un intervallo (val-min, val-max):

(define (normal-zero lst-num val-min val-max)
  (local (hi lo k out)
    (setq out '())
    (setq hi (apply max lst-num))
    (setq lo (apply min lst-num))
    (setq k (div (sub val-max val-min) (sub hi lo)))
    (dolist (val lst-num)
      (push (add val-min (mul (sub val lo) k)) out -1)
    )
    ; Valore dello 0 nella lista normalizzata
    (push (add val-min (mul (sub 0 lo) k)) out)
    out))

(normal-zero lst-x -6 15)
;-> (0 1 4 -5 2 10 -6 15)
(normal-zero lst-x 0 30)
;-> (8.571428571428571 10 14.28571428571429 1.428571428571429
;->  11.42857142857143 22.85714285714286 0 30)

Adesso possiamo scrivere la funzione che disegna i punti sul terminale. QUesta funzione prende come parametri la lista di punti, la larghezza (in caratteri) del grafico e l'altezza (in caratteri) del grafico.

(define (plot lst-xy width height)
  (local (lst-x lst-y x-min x-max y-min y-max
          range-x range-y xx yy zero-x zero-y matrix)
    ; crea lista delle x
    (setq lst-x (map first lst-xy))
    ; crea lista delle y
    (setq lst-y (map last  lst-xy))
    ; calcola valori min,max x
    (setq x-min (apply min lst-x))
    (setq x-max (apply max lst-x))
    ; calcola valori min,max x
    (setq y-min (apply min lst-y))
    (setq y-max (apply max lst-y))
    ; calcolo intervallo valori x
    (setq range-x (sub x-max x-min))
    ; calcolo intervallo valori y
    (setq range-y (sub y-max y-min))
    ; calcolo valori normalizzati lista x
    ; (i valori vengono arrotondati e poi resi interi)
    (setq xx (normal-zero lst-x 0 width))
    (setq xx (map (fn(w) (int (round w))) xx))
    ; estrazione valore dello zero x normalizzato
    (setq zero-x (pop xx))
    ; calcolo valori normalizzati lista y
    (setq yy (normal-zero lst-y 0 height))
    (setq yy (map (fn(w) (int (round w))) yy))
    ; estrazione valore dello zero y normalizzato
    (setq zero-y (pop yy))
    ; Creazione matrice di caratteri di stampa
    ; Matrice = Sistema di coordinate (row col)
    ; x --> colonna della matrice
    ; y --> riga della matrice
    ; Valore cella vuota: " "
    (setq matrix (array (+ height 2) (+ width 2) '(" ")))
    ; Inserisce asse x sulla matrice
    ;(for (i 0 (- (length (matrix 0)) 1))
    ;  (setf (matrix zero-y i) "·")
    ;)
    ; asse x nella matrice
    (if (and (>= zero-y 0) (< zero-y (+ height 2)))
        (for (i 0 (- (length (matrix 0)) 1))
          (setf (matrix zero-y i) "·")
        )
    )
    ; Inserisce asse y sulla matrice
    ;(for (i 0 (- (length matrix) 1))
    ;  (setf (matrix i zero-x) "·")
    ;)
    ; asse y nella matrice
    (if (and (>= zero-x 0) (< zero-x (+ width 2)))
        (for (i 0 (- (length matrix) 1))
          (setf (matrix i zero-x) "·")
        )
    )
    ; Inserisce punti (x y) nella matrice
    ; (inserisce "■" nelle celle (y x) della matrice)
    (for (i 0 (- (length xx) 1))
      (setf (matrix (yy i) (xx i)) "■")
    )
    ; Inserisce origine degli assi (0 0) nella matrice.
    ; se l'origine è un punto della lista
    ;(if (= (matrix zero-y zero-x) "■")
    ;    ; allora inserisce "0"
    ;    (setf (matrix zero-y zero-x) "O")
    ;    ; altrimenti inserisce "●"
    ;    (setf (matrix zero-y zero-x) "∙")
    ;)
    ; (0,0) nella matrice
    (if (and (>= zero-x 0) (>= zero-y 0)
             (< zero-x (+ width 2)) (< zero-y (+ height 2)))
        (if (= (matrix zero-y zero-x) "■")
            (setf (matrix zero-y zero-x) "O")
            (setf (matrix zero-y zero-x) "∙")
        )
    )    
    ; stampa valori reali min e max
    (println (format "x: %-12.3f %-12.3f" x-min x-max))
    (println (format "y: %-12.3f %-12.3f" y-min y-max))
    ; stampa matrice di caratteri
    ; (le righe della matrice vengono invertite)
    (dolist (el (reverse (array-list matrix)))
      (println " " (join el))
    )
    'end))

Facciamo alcune prove:

(plot lst-xy 60 30)
;-> x: -6.000       15.000
;-> y: -8.000       12.000
;->                   ·
;->                   ·                            ■             ■
;->                   ·
;->                   ·
;->                   ·
;->                   ·
;->                   ·
;->                   ·
;->                   ·
;->                   ·
;->     ■             ·
;->                   ·
;->                   ·
;->                   ·           ■
;->                   ·  ■
;->                   ·
;->                   ·
;->                   ·
;->                   ·
;->  ·················●············································
;->                   ·
;->                   ·
;->                   ·     ■
;->                   ·
;->                   ·
;->                   ·
;->                   ·
;->                   ·
;->                   ·
;->                   ·
;->                   ·
;->  ■                ·

(setq coppie (map list (sequence 0 20) (sequence 0 10)))
(plot coppie 40 20)
;-> x: 0.000        20.000
;-> y: 0.000        20.000
;->  ·
;->  ·                                       ■
;->  ·                                     ■
;->  ·                                   ■
;->  ·                                 ■
;->  ·                               ■
;->  ·                             ■
;->  ·                           ■
;->  ·                         ■
;->  ·                       ■
;->  ·                     ■
;->  ·                   ■
;->  ·                 ■
;->  ·               ■
;->  ·             ■
;->  ·           ■
;->  ·         ■
;->  ·       ■
;->  ·     ■
;->  ·   ■
;->  · ■
;->  O·········································

Nota: nel terminale del DOS il rapporto proporzionale tra la larghezza e l'altezza dei caratteri varia con il tipo di font, ma varia tra 1/2 e 1/2.5.

Proviamo a disegnare una funzione matematica. Prima scriviamo una funzione che genera i punti della funzione:

(define (func-points func min-val max-val step)
  (let (pts '())
    (for (i min-val max-val step)
      (push (list i (func i)) pts -1))))

Adesso disegniamo il grafico della funzione seno (sin):

(plot (func-points sin -6.3 6.3 0.01) 60 20)
;-> x: -6.300       6.300
;-> y: -1.000       1.000
;->                                ·
;->        ■■■■                    ·     ■■■■
;->       ■■  ■■                   ·    ■■  ■■
;->      ■■    ■■                  ·   ■■    ■■
;->     ■■      ■■                 ·  ■■      ■■
;->     ■        ■                 ·  ■        ■
;->    ■■        ■■                · ■■        ■■
;->    ■          ■                · ■          ■
;->   ■■          ■■               ·■■          ■■
;->   ■            ■               ·■            ■
;->  ■■            ■■              ■■            ■■
;->  ■··············■··············O··············■··············■·
;->                 ■■            ■■              ■■            ■■
;->                  ■            ■·               ■            ■
;->                  ■■          ■■·               ■■          ■■
;->                   ■          ■ ·                ■          ■
;->                   ■■        ■■ ·                ■■        ■■
;->                    ■        ■  ·                 ■        ■
;->                    ■■      ■■  ·                 ■■      ■■
;->                     ■■    ■■   ·                  ■■    ■■
;->                      ■■  ■■    ·                   ■■  ■■
;->                       ■■■■     ·                    ■■■■

Disegniamo una superellisse.
Una superellisse è una figura geometrica definita come l'insieme di tutti i punti (x, y) tali che:

  |x/a|ⁿ + |y/b|ⁿ = 1

dove n, a e b sono numeri positivi.

La curva è data dalle equazioni parametriche (con parametro t che non ha una interpretazione geometrica elementare):

x(t) = |cos(t)|^2/n * a * sgn(cos(t))
y(t) = |sin(t)|^2/n * b * sgn(sin(t))

Funzione che genera i punti della superellisse:

(define (super-xy n a b)
  (local (x y out)
    (setq out '())
    (for (t 0 1000 0.1)
      (setq x (mul (pow (abs (cos t)) (div 2 n)) a (sgn (cos t))))
      (setq y (mul (pow (abs (sin t)) (div 2 n)) b (sgn (sin t))))
      (push (list x y) out -1)
    )
    out))

(plot (super-xy 2 200 200) 60 25)
;-> x: -200.000     200.000
;-> y: -200.000     200.000
;->                                ·
;->                        ■■■■■■■■■■■■■■■■■
;->                  ■■■■■■■       ·       ■■■■■■■
;->              ■■■■■             ·             ■■■■■
;->           ■■■■                 ·                 ■■■■
;->         ■■■                    ·                    ■■■
;->       ■■■                      ·                      ■■■
;->      ■■                        ·                        ■■
;->     ■■                         ·                         ■■
;->    ■■                          ·                           ■
;->   ■■                           ·                           ■■
;->  ■■                            ·                            ■■
;->  ■                             ·                             ■
;->  ■                             ·                             ■
;->  ■·····························●·····························■·
;->  ■                             ·                             ■
;->  ■■                            ·                            ■■
;->   ■■                           ·                           ■■
;->    ■■                          ·                          ■■
;->     ■■                         ·                         ■■
;->      ■■                        ·                        ■■
;->       ■■■                      ·                      ■■■
;->         ■■■                    ·                    ■■■
;->           ■■■■                 ·                 ■■■■
;->              ■■■■■             ·             ■■■■■
;->                  ■■■■■■■       ·       ■■■■■■■
;->                        ■■■■■■■■■■■■■■■■■

(plot (super-xy 0.5 1 1) 50 25)
;-> x: -1.000       1.000
;-> y: -1.000       1.000
;->                           ·
;->                           ■
;->                           ■
;->                           ■
;->                          ■■■
;->                          ■·■
;->                         ■■·■■
;->                         ■ · ■
;->                        ■■ · ■■
;->                      ■■■  ·  ■■■
;->                     ■■    ·    ■■
;->                  ■■■      ·      ■■■
;->              ■■■■■        ·        ■■■■■
;->  ■■■■■■■■■■■■■            ·            ■■■■■■■■■■■■■
;->  ■■■■■■■■■■■■■············●············■■■■■■■■■■■■■·
;->              ■■■■■        ·        ■■■■■
;->                  ■■■      ·      ■■■
;->                     ■■    ·    ■■
;->                      ■■■  ·  ■■■
;->                        ■■ · ■■
;->                         ■ · ■
;->                         ■■·■■
;->                          ■·■
;->                          ■■■
;->                           ■
;->                           ■
;->                           ■

Disegniamo un'altra funzione: 

      (x*x)
y = --------- - 2
     (2 - x)

(define (gg x)
  (sub (div (mul x x) (sub 2 x)) 2))

(plot (func-points gg -2 1.5 0.01) 40 20)
;-> x: -2.000       1.500
;-> y: -2.000       2.500
;->                         ·
;->                         ·                ■
;->                         ·                ■
;->                         ·                ■
;->                         ·               ■
;->                         ·               ■
;->                         ·               ■
;->                         ·               ■
;->                         ·              ■■
;->                         ·              ■
;->                         ·              ■
;->                         ·             ■■
;->  ·······················●·············■····
;->                         ·            ■■
;->                         ·            ■
;->                         ·           ■■
;->                         ·          ■■
;->  ■■■■                   ·         ■■
;->     ■■■■■               ·        ■■
;->         ■■■■■           ·       ■■
;->             ■■■■■■■     ·    ■■■
;->                   ■■■■■■■■■■■■

(plot (func-points gg -4 -0.5 0.01) 40 20)
;-> x: -4.000       -0.500
;-> y: -1.900       0.667
;-> 
;->  ■■
;->   ■■
;->     ■■
;->      ■■■
;->        ■■
;->  ········■■································
;->           ■■■
;->             ■■■
;->               ■■
;->                 ■■
;->                  ■■■
;->                    ■■■
;->                      ■■■
;->                        ■■■
;->                          ■■■
;->                            ■■■
;->                              ■■■
;->                                ■■■
;->                                   ■■■
;->                                     ■■■■
;->                                        ■■■

(plot (func-points gg -8 1.6 0.01) 60 30)
;-> x: -8.000       1.600
;-> y: -2.000       4.400
;->                                                    ·
;->  ■■                                                ·         ■
;->   ■■                                               ·         ■
;->    ■■                                              ·         ■
;->      ■■                                            ·         ■
;->       ■■                                           ·         ■
;->        ■■■                                         ·         ■
;->          ■■                                        ·         ■
;->           ■■                                       ·         ■
;->             ■■                                     ·        ■
;->              ■■                                    ·        ■
;->               ■■■                                  ·        ■
;->                 ■■                                 ·        ■
;->                  ■■■                               ·        ■
;->                    ■■                              ·        ■
;->                     ■■■                            ·        ■
;->                       ■■                           ·        ■
;->                        ■■■                         ·        ■
;->                          ■■                        ·       ■
;->                           ■■■                      ·       ■
;->                             ■■                     ·       ■
;->                              ■■■                   ·       ■
;->  ······························■■··················∙·······■···
;->                                 ■■■                ·      ■■
;->                                   ■■               ·      ■
;->                                    ■■■             ·      ■
;->                                      ■■■           ·     ■■
;->                                        ■■■         ·     ■
;->                                          ■■■       ·    ■■
;->                                            ■■■     ·   ■■
;->                                              ■■■■  ·  ■■
;->                                                 ■■■■■■■

Dobbiamo ammettere che "gnuplot" è sicuramente meglio...

Nota: per migliorare il grafico si potrebbe usare l'algoritmo di bresenham per le linee (cioè, per quei punti che distano più di una unità (in x e in y) dal punto successivo).


---------------------------------
Sottosequenza crescente più lunga
---------------------------------

Dato una lista non ordinata di interi, trovare la lunghezza della sottosequenza crescente più lunga (anche non contigua).

Sia max[i] la lunghezza della sottosequenza crescente più lunga finora. 
Se un elemento prima di i è minore di lst[i], allora max[i] = max(max[i], max[j]+1).

La sequente funzione calcola la lunghezza della sottosequenza crescente più lunga:

(define (lis lst)
  (local (len vet out)
    (setq out 1)
    (setq len (length lst))
    (setq vet (array len '(1)))
    (for (i 0 (- len 1))
      (setq j 0)
      (while (< j i)
        (if (> (lst i) (lst j))
            (setf (vet i) (max (vet i) (+ (vet j) 1)))
        )
        (++ j)
      )
      (setq out (max (vet i) out))
    )
    out))

(lis '(10 9 2 5 3 7 101 18))
;-> 4

Se vogliamo ottenere i valori della sottosequenza possiamo seguire l'algoritmo presentato su wikipedia:

(define (long-inc-sub X)
(local (N P M L lo hi mid newL Pk S)
  (setq N (length X))
  (setq P (array N '(0)))
  (setq M (array (+ N 1) '(0)))
  (setq L 0)
  (for (i 0 (- N 1))
    ; Binary search for the largest positive j ≤ L
    ; such that X[M[j]] < X[i]
    (setq lo 1)
    (setq hi L)
    (while (<= lo hi)
      (setq mid (int (ceil (div (+ lo hi) 2))))
      (if (< (X (M mid)) (X i))
          (setq lo (+ mid 1))
          (setq hi (- mid 1))
      )
    )
    ; After searching, lo is 1 greater than the
    ; length of the longest prefix of X[i]    
    (setq newL lo)
    ; The predecessor of X[i] is the last index of 
    ; the subsequence of length newL-1    
    (setf (P i) (M (- newL 1)))
    (setf (M newL) i)
    (if (> newL L)
        ; If we found a subsequence longer than any we've
        ; found yet, update L
        (setq L newL)
    )
  )
  ; Reconstruct the longest increasing subsequence
  (setq S '())
  (setq k (M L))
  (for (i (- L 1) -2)
    (push (X k) S)
    (setq k (P k))
  )
  (slice S 2)))

(long-inc-sub '(0 8 4 12 2 10 6 14 1 9 5 13 3 11 7 15))
;-> (0 2 6 9 11 15)
(long-inc-sub '(3 2 6 4 5 1))
;-> (2 4 5)
(long-inc-sub '(10 9 2 5 3 7 101 18))
;-> (2 3 7 18)


------------------------------------
Conversione stringa <--> big-integer
------------------------------------

Vediamo come convertire una stringa in un big-integer e viceversa.

; Maximum value of int64
(setq MAX-INT)  9223372036854775807)
; Minimum value of int64
(setq MIN-INT) -9223372036854775808)

Definiamo una stringa numerica maggiore di MAX-INT:

(setq s "99223372036854775807")
;-> 99223372036854775807

Se convertiamo con la funzione "int" otteniamo un risultato errato a causa dell'overflow:
(int s)
;-> -1

Però possiamo utilizzare la funzione "eval-string":

(setq num (eval-string s))
;-> 99223372036854775807L
(length s)
;-> 20
(length num)
;-> 20

Attenzione alle lunghezze dei due tipi integer e string.

Definiamo una stringa numerica minore di MIN-INT:

(setq s "-99223372036854775808")
"-99223372036854775808"
(int s)
;-> -1
(setq num (eval-string s))
;-> -9223372036854775808L
(length s)
;-> 21 ; il segno "-" è un carattere
(length num)
;-> 20

Riconvertiamo il numero big-integer in stringa:

(setq q (string num))
;-> "-99223372036854775808L" ; nota la L finale
(length q)
;-> 22 ; il segno "-" e "L" sono due caratteri

Riconvertiamo la stringa in numero big-integer:
(setq num (eval-string q))
;-> -99223372036854775808L
(length num)
;-> 20

Quindi possiamo scrivere la seguente funzione:

(define (str-int str)
  (eval-string str))

(str-int "2315369")
;-> 2315369
(str-int "23153234812357131369")
;-> 23153234812357131369L
(str-int "-23153234812357131369L")
;-> -23153234812357131369L


---------------------------
Dismutazioni (Derangements)
---------------------------

Nel calcolo combinatorio vengono dette dismutazioni (o sconvolgimenti, o permutazioni complete) le permutazioni di un insieme tali che nessun elemento appare nella sua posizione originale. In altre parole, uno dismutazione è una permutazione che non ha punti fissi.
Non esiste alcuna dismutazione per un insieme di un solo elemento, ne esiste 1 per un insieme di 2 elementi, 2 per un insieme di 3 elementi, 9 per uno di 4 elementi, ad esempio, le 9 dismutazioni possibili della parola "ABCD" sono:

  BADC BCDA BDAC
  CADB CDAB CDBA
  DABC DCAB DCBA

Il simbolo matematico che rappresenta la dismutazione è: !n

Per calcolare il numero di dismutazioni !n di un insieme esistono due formule:

1)  !n = (n - 1)*(!(n-1) + !(n-2)),  dove !0 = 1 e !1 = 0

2)  !n = n*!(n-1) + (-1)^n,  dove !0 = 1 e !1 = 0

           n  (-1)^i
3)  !n = n!∑----------,  per n >= 0
           0    i!

Sequenza OEIS A000166:
  1, 0, 1, 2, 9, 44, 265, 1854, 14833, 133496, 1334961, 14684570,
  176214841, 2290792932, 32071101049, 481066515734, 7697064251745,
  130850092279664, 2355301661033953, 44750731559645106, 895014631192902121,
  18795307255050944540, 413496759611120779881, 9510425471055777937262, ...

Versione ricorsiva con la formula 1:

(define (dismut1 num)
  (cond ((= num 0) 1L)
        ((= num 1) 0L)
        (true
          (* (- num 1) (+ (dismut1 (- num 1)) (dismut1 (- num 2)))))))

(dismut1 5)
;-> 44
(dismut1 10L)
;-> 1334961L
(dismut2 30L)
;-> 97581073836835777732377428235481L

Versione più efficiente (programmazione dinamica) che memorizza i risultati di dismut(num-1) e dismut(num-2) in una lista per usi futuri:

(define (dismut2 num)
  (let (dis (array (+ num 1) '(0)))
    (setf (dis 0) 1L)
    (setf (dis 1) 0L)
    (setf (dis 2) 1L)
      ; Riempie dis[0..n] dal basso verso l'alto
      ; usando la formula ricorsiva sopra
      (for (i 3 num)
        ;(setf (dis i) (* (- i 1) (+ (dis (- i 1)) (dis (- i 2)))))
        (setf (dis i) (* (+ (dis (- i 1)) (dis (- i 2))) (- i 1)))
    )
    (dis num)))

(dismut2 5)
;-> 44L
(dismut2 10L)
;-> 1334961L
(dismut2 30L)
;-> 97581073836835777732377428235481L

Una versione ancora migliore utilizza solo due variabili per memorizzare i valori dis(n-1) e dis(n-2) (che sono gli unici che servono per calcolare dis(n)):

(define (dismut3 num)
  (cond ((= num 0) 1L)
        ((= num 1) 0L)
        ((= num 2) 1L)
        (true
          (let ((a 0L) (b 1L) (cur 0L))
            (for (i 3 num)
              (setq cur (* (+ a b) (- i 1)))
              (setq a b)
              (setq b cur)
            )
            b))))

(dismut3 5)
;-> 44L
(dismut3 10L)
;-> 1334961L
(dismut3 30L)
;-> 97581073836835777732377428235481L

Vediamo una funzione che utilizza la programmazione dinamica con la formula ricorsiva 2:

(define (dismut4 num)
  (cond ((= num 0) 1L)
        ((= num 1) 0L)
        ((= num 2) 1L)
        (true
          (let ((a 1L) (cur 0L))
            (for (i 3 num)
              (if (odd? i)
                (setq cur (- (* a i) 1))
                (setq cur (+ (* a i) 1))
                ;(setq cur (+ (* a i) (pow -1L i)))
              )
              (setq a cur)
            )
            cur))))

(dismut4 5)
;-> 44L
(dismut4 10L)
;-> 1334961L
(dismut4 30L)
;-> 97581073836835777732377428235481L

Vediamo i tempi di esecuzione di queste funzioni:

(time (dismut1 30L) 10)
;-> 13621.586

(time (dismut2 40L) 10000)
;-> 173.538

(time (dismut3 40L) 10000)
;-> 166.555

(time (dismut4 40L) 10000)
;-> 164.588

La seconda funzione "dismut2" memorizza tutti i valori di dis(i) per i = 0..num, quindi possiamo usarla per calcolare il numero di dismutazioni di tutti i numeri da 0 fino a num:

(define (dismut-to num)
  (let (dis (array (+ num 1) '(0)))
    (setf (dis 0) 1L)
    (setf (dis 1) 0L)
    (setf (dis 2) 1L)
      (for (i 3 num)
        (setf (dis i) (* (+ (dis (- i 1)) (dis (- i 2))) (- i 1)))
    )
    dis))

(dismut-to 20)
;-> (1L 0L 1L 2L 9L 44L 265L 1854L 14833L 133496L 1334961L 14684570L
;->  176214841L 2290792932L 32071101049L 481066515734L 7697064251745L
;->  130850092279664L 2355301661033953L 44750731559645106L
;->  895014631192902121L)

Per generare la lista delle dismutazioni di un insieme di elementi possiamo usare la funzione delle permutazioni con una modifica: inseriamo la permutazione corrente nella lista delle dismutazioni solo se soddisfa al vincolo che nessun elemento appare nella sua posizione originale.

Funzione che verifica se la lista corrente "lst" può essere una dismutazione (confronto con la lista originale "base"):

(define (dis?)
(catch
  (let (ok true)
    (dolist (el lst)
      (if (= el (base $idx))
        (throw nil)))
    ok)))

Nota: non passiamo le liste "lst" e "base" alla funzione "dis?" perchè perderemmo in velocità (ricorda che newLISP fa una copia di ogni parametro passato ad una funzione). Questo è possibile grazie all'ambito dinamico di newLISP.

(define (dism lst)
"Generates all dismutations without repeating from a list of items"
  (local (i indici out base)
    ; lista originale
    (setq base lst)
    (setq indici (dup 0 (length lst)))
    (setq i 0)
    ; non aggiungiamo la lista iniziale alla soluzione
    ; perchè non è una dismutazione
    ; (setq out (list lst))
    (setq out '())
    (while (< i (length lst))
      (if (< (indici i) i)
          (begin
            (if (zero? (% i 2))
              (swap (lst 0) (lst i))
              (swap (lst (indici i)) (lst i))
            )
            ;(println lst)
            ; inseriamo la permutazione corrente solo se ogni elemento
            ; non appare nella sua posizione originale
            (if (dis?)
              (push lst out -1)
            )
            (++ (indici i))
            (setq i 0)
          )
          (begin
            (setf (indici i) 0)
            (++ i)
          )
       )
    )
    out))

(sort (dism '(A B C D)))
;-> ((B A D C) (B C D A) (B D A C) 
;->  (C A D B) (C D A B) (C D B A)
;->  (D A B C) (D C A B) (D C B A))

Vediamo il tempo di esecuzione:

(time (println (length (dism '(a b c d e f g h i j)))))
;-> 1334961
;-> 7603.603


-------------------------
Stampa lista come tabella
-------------------------

La funzione seguente prende una lista e la stampa come una tabella con il seguente formato grafico:

lista = ((1 2 3 4 5) ("a" "b" "c" "d" "e") (-1 -2 -3 -4 -5) (aa bb cc dd ee) (-11 -12 -13 -14 -15))

Nota: la lista deve essere una matrice con tutti i valori e con più di una riga.

Nota: la stampa avviene con tutti i valori allineati a sinistra

  +-----+-----+-----+-----+-----+
  | 1   | 2   | 3   | 4   | 5   |
  +-----+-----+-----+-----+-----+
  | a   | b   | c   | d   | e   |
  +-----+-----+-----+-----+-----+
  | -1  | -2  | -3  | -4  | -5  |
  +-----+-----+-----+-----+-----+
  | aa  | bb  | cc  | dd  | ee  |
  +-----+-----+-----+-----+-----+
  | -11 | -12 | -13 | -14 | -15 |
  +-----+-----+-----+-----+-----+

Per facilitare la formattazione di stampa convertiamo tutti i valori in stringa con la seguente funzione che ci permette di applicare una funzione a tutti gli elementi di una lista annidata:

(define (map-all f lst)
  (let (result '())
    (dolist (el lst)
      (if (list? el)
        (push (map-all f el) result -1)
        (push (f el) result -1)))
    result))

Adesso possiamo scrivere la funzione di stampa della lista:

(define (print-table lst)
  (local (tab plus minus ver rows cols col-len-max len-max
          line-len line ind)
    ; conversione di tutti i valori della lista in stringa
    (setq tab (map-all string lst))
    ; caratteri grafici
    (setq plus "+")
    (setq minus "-")
    (setq ver "|")
    ; calcolo righe e colonne della lista
    (setq rows (length tab))
    (setq cols (length (tab 0)))
    ; vettore per le lunghezze massime dei valori di ogni colonna
    (setq col-len-max (array cols '(0)))
    ; calcola la lunghezza massima dei valori di ogni colonna
    (for (c 0 (- cols 1))
      (setq len-max 0)
      (for (r 0 (- rows 1))
        (setf len-max (max len-max (length (tab r c))))
      )
      (setf (col-len-max c) len-max)
    )
    ;(println col-len-max)
    ; lunghezza della linea =
    ; (somma delle lunghezze massime) +
    ; (2 spazi x ogni colonna) +
    ; (colonne + 1 per "|")
    (setq line-len (+ (apply + col-len-max) (* cols 2) (+ cols 1)))
    (setq line (dup minus line-len))
    (setf (line 0) plus)
    (setf (line -1) plus)
    ; calcola i limiti di stampa dei valori
    ; (inserisce "+" nella linea "line")
    (setq ind 1)
    (dolist (c col-len-max)
      (setq ind (+ ind 2 c))
      (setf (line ind) "+")
      (++ ind)
    )
    ; stampa della lista come tabella
    (dolist (r tab)
      (println line)
      (dolist (c r)
        (print ver { } c (dup " " (- (col-len-max $idx) (length c))) { })
      )
      (println ver)
    )
    (println line)
  'nil))

(setq lst '((1 2 3 4 5) ("a" "b" "c" "d" "e") (-1 -2 -3 -4 -5) (aa bb cc dd ee) (-11 -12 -13 -14 -15)))
(print-table lst)
;-> +-----+-----+-----+-----+-----+
;-> | 1   | 2   | 3   | 4   | 5   |
;-> +-----+-----+-----+-----+-----+
;-> | a   | b   | c   | d   | e   |
;-> +-----+-----+-----+-----+-----+
;-> | -1  | -2  | -3  | -4  | -5  |
;-> +-----+-----+-----+-----+-----+
;-> | aa  | bb  | cc  | dd  | ee  |
;-> +-----+-----+-----+-----+-----+
;-> | -11 | -12 | -13 | -14 | -15 |
;-> +-----+-----+-----+-----+-----+

(setq lst '((1 2 "pippo") ("paperino" "pluto" -98784749) (-1000 -100000 "tre")))
(print-table lst)
;-> +----------+---------+-----------+
;-> | 1        | 2       | pippo     |
;-> +----------+---------+-----------+
;-> | paperino | pluto   | -98784749 |
;-> +----------+---------+-----------+
;-> | -1000    | -100000 | tre       |
;-> +----------+---------+-----------+

(setq lst '((1) (-2) (pippo)))
(print-table lst)
;-> +-------+
;-> | 1     |
;-> +-------+
;-> | -2    |
;-> +-------+
;-> | pippo |
;-> +-------+

=============================================================================

==========================

 newLISP 99 PROBLEMI (28)

==========================

Questi problemi sono stati creati inizialmente per essere risolti con il linguaggio Prolog.
Poi è stata la volta dei linguaggi Lisp, Haskell e Scheme... e adesso newLISP.
Potete trovare l'elenco completo dei problemi al sito:

https://www.ic.unicamp.br/~meidanis/courses/mc336/2006s2/funcional/L-99_Ninety-Nine_Lisp_Problems.html
http://beta-reduction.blogspot.com/search/label/L-99%3A%20Ninety-Nine%20Lisp%20Problems

In questo capitolo vengono risolti solo i primi 28 problemi relativi alla elaborazione di liste. Molti problemi successivi al numero 28 sono risolti in altri capitoli di questo documento e sono contrassegnati con il simbolo (+).

Elenco problemi
---------------

Elaborazione di liste
---------------------
N-99-01 Estrarre l'ultimo elemento di una lista
N-99-02 Estrarre il penultimo elemento di una lista
N-99-03 Estrarre il k-esimo elemento di una lista
N-99-04 Determinare il numero di elementi di una lista
N-99-05 Invertire una lista
N-99-06 Determinare se una lista è palindroma
N-99-07 Appiattire una lista annidata
N-99-08 Elimina gli elementi duplicati consecutivi di una lista
N-99-09 Unire gli elementi duplicati consecutivi di una lista in sottoliste.
N-99-10 Run-length encode di una lista
N-99-11 Run-length encode di una lista (modificato)
N-99-12 Run-length decode di una lista
N-99-13 Run-length encode di una lista (diretto)
N-99-14 Duplicare gli elementi di una lista
N-99-15 Replicare per n volte gli elementi di una lista
N-99-16 Eliminare gli elementi da una lista per ogni k
N-99-17 Dividere una lista in due parti (la lunghezza della prima lista è un parametro)
N-99-18 Estrarre una parte di una lista
N-99-19 Ruotare una lista di N posti a sinistra
N-99-20 Eliminare l'elemento k-esimo di una lista
N-99-21 Inserire un elemento in una data posizione di una lista
N-99-22 Creare una lista che contiene tutti i numeri interi di un intervallo
N-99-23 Estrarre un dato numero di elementi da una lista in maniera casuale (random)
N-99-24 Lotto: estrarre N numeri differenti da un intervallo 1..M
N-99-25 Generare le permutazioni degli elementi di una lista
N-99-26 Generare le combinazioni di K oggetti distinti tra gli N elementi di una lista
N-99-27 Raggruppare gli elementi di un insieme in sottoinsiemi disgiunti.
N-99-28 Ordinare una lista in base alla lunghezza delle sottoliste

Arithmetic (Aritmetica)
-----------------------
N-99-31  Determine whether a given integer number is prime (+)
N-99-32  Determine the greatest common divisor of two positive integer numbers (+)
N-99-33  Determine whether two positive integer numbers are coprime (+)
N-99-34  Calculate Euler's totient function phi(m) (+)
N-99-35  Determine the prime factors of a given positive integer (+)
N-99-36  Determine the prime factors of a given positive integer (2) (+)
N-99-37  Calculate Euler's totient function phi(m) (improved) (+)
N-99-38  Compare the two methods of calculating Euler's totient function
N-99-39  A list of prime numbers (+)
N-99-40  Goldbach's conjecture
N-99-41  A list of Goldbach compositions

Logic and Codes (Logica e Codici)
---------------------------------
N-99-46  Truth tables for logical expressions (+)
N-99-47  Truth tables for logical expressions (2) (+)
N-99-48  Truth tables for logical expressions (3) (+)
N-99-49  Gray code (+)
N-99-50  Huffman code

Binary trees (Alberi Binari)
----------------------------
N-99-54A Check whether a given term represents a binary tree
N-99-55  Construct completely balanced binary trees
N-99-56  Symmetric binary trees
N-99-57  Binary search trees (dictionaries)
N-99-58  Generate-and-test paradigm
N-99-59  Construct height-balanced binary trees
N-99-60  Construct height-balanced binary trees with a given number of nodes
N-99-61  Count the leaves of a binary tree
N-99-61A Collect the leaves of a binary tree in a list
N-99-62  Collect the internal nodes of a binary tree in a list
N-99-62B Collect the nodes at a given level in a list
N-99-63  Construct a complete binary tree
N-99-64  Layout a binary tree (1)
N-99-65  Layout a binary tree (2)
N-99-66  Layout a binary tree (3)
N-99-67  A string representation of binary trees
N-99-68  Preorder and inorder sequences of binary trees
N-99-69  Dotstring representation of binary trees
N-99-70  Tree construction from a node string

Multiway Trees (Alberi n-ari)
-----------------------------
N-99-70B Check whether a given term represents a multiway tree
N-99-70C Count the nodes of a multiway tree
N-99-71  Determine the internal path length of a tree
N-99-72  Construct the bottom-up order sequence of the tree nodes
N-99-73  Lisp-like tree representation

Graphs (Grafi)
--------------
N-99-80  Conversions
N-99-81  Path from one node to another one
N-99-82  Cycle from a given node
N-99-83  Construct all spanning trees
N-99-84  Construct the minimal spanning tree
N-99-85  Graph isomorphism
N-99-86  Node degree and graph coloration
N-99-87  Depth-first order graph traversal (alternative solution)
N-99-88  Connected components (alternative solution)
N-99-89  Bipartite graphs

Miscellaneous Problems (Problemi Vari)
--------------------------------------
N-99-90  Eight queens problem (+)
N-99-91  Knight's tour (+)
N-99-92  Von Koch's conjecture 
N-99-93  An arithmetic puzzle
N-99-94  Generate K-regular simple graphs with N nodes
N-99-95  English number words (+)
N-99-96  Syntax checker (alternative solution with difference lists)
N-99-97  Sudoku (+)
N-99-98  Nonograms
N-99-99  Crossword puzzle

=======================================================
N-99-01 Estrarre l'ultimo elemento di una lista
=======================================================

(define (ultimo lst)
  (if (null? lst) nil
    (if (null? (rest lst))  ; se è rimasto solo un elemento allora...
        (first lst)         ; prendilo
        (ultimo (rest lst)) ; altrimenti processa il resto della lista
    )
  )
)

(ultimo '(1 2 3))
;-> 3

(ultimo '())
;-> ()

Funzione newLISP predefinita: (last lst)

(last '(1 2 3))
;-> 3

(last '())
;-> ERR: list is empty in function last : '()


=======================================================
N-99-02 Estrarre il penultimo elemento di una lista
=======================================================

(define (penultimo lst)
  (when (not (null? (rest lst)))
    (if (null? (rest (rest lst)))
      (first lst)
      (penultimo (rest lst))
    )
  )
)

(penultimo '(1 2 3))
;-> 2

(penultimo '(1 2))
;-> 1

(penultimo '(1))
;-> nil


=======================================================
N-99-03 Estrarre il k-esimo elemento di una lista
=======================================================

Nota: il primo elemento della lista ha indice zero (zero-based index)

(define (k-esimo lst k)
  (if (< (length lst) (+ k 1))
    nil
    (if (= k 0)
      (first lst)
      (k-esimo (rest lst) (- k 1))
    )
  )
)

(k-esimo '(1 2 3 4 5) 4)
;-> 5

(k-esimo '(1 2 3 4 5) 6)
;-> nil

(k-esimo '() 1)
;-> nil

(k-esimo '() 0)
;-> nil

Funzione predefinita newLISP: (nth int-index lst)

(nth 4 '(1 2 3 4 5))
;-> 5

(nth 6 '(1 2 3 4 5))
;-> ERR: invalid list index in function nth

(nth 0 '())
;-> ERR: invalid list index in function nth


=======================================================
N-99-04 Determinare il numero di elementi di una lista
=======================================================

(define (lunghezza lst)
  (if (null? lst)
    0
    (+ 1 (lunghezza (rest lst)))))

(lunghezza '((1 2) 1 4 (3) 5))
;-> 5

(lunghezza '())
;-> 0

Funzione predefinita newLISP: (length lst)

(length '((1 2) 1 4 (3) 5))
;-> 5

(length '())
;-> 0


=======================================================
N-99-05 Invertire una lista
=======================================================

Per invertire una lista, possiamo salvare il primo elemento, invertire il resto, quindi inserire il vecchio primo elemento in fondo al "resto invertito".

(define (inverti lst)
    (if (null? lst)
        lst
        (append (inverti (rest lst)) (list (first lst)))))

(inverti '(1 2 3))
;-> (3 2 1)

Comunque questo approccio è abbastanza inefficiente, perchè la funzione "append" ha bisogno di attraversare ripetutamente il risultato per aggiungere elementi in fondo.

Allora usiamo una versione ricorsiva in coda (tail-recursive).

Possiamo capire meglio questa implementazione tail-recursive se la scomponiamo in due funzioni, una funzione principale e una funzione di "aiuto".

(define (inverti-aiuto lst acc)
  (if (null? lst)
      acc
      (inverti-aiuto (rest lst) (cons (first lst) acc))))

(define (inverti2 lst)
  (inverti-aiuto lst '()))

(inverti2 '(1 2 3))
;-> (3 2 1)

La differenza principale è che costruire il risultato nel parametro acc significa che possiamo usare la funzione "cons" e non aver bisogno di attraversare ripetutamente il risultato per aggiungere elementi in fondo ad esso (che è ciò che faceva "append" nella funzione precedente).

fold-left e fold-right
----------------------
Per invertire una lista possiamo anche "ripiegare a sinistra (left folding)" la lista in una nuova lista costruita utilizzando la funzione "cons".

(define (inverti-fold lst)
  (fold-left cons '() lst))

Per capire il funzionamento bisogna conoscere come funziona la funzione "fold-left".
Supponiamo di voler sommare una lista di numeri (1 2 3 4). Il modo più immediato è il seguente:

1 + 2 + 3 + 4

In altre parole, abbiamo inserito l'operatore "+" in mezzo ad ogni elemento. Valutiamo l'espressione:

((1 + 2) + 3) + 4

(3 + 3) + 4

6 + 4  ⇒  10

La funzione "fold-left" fa esattamente questo: prende una procedura binaria, un valore iniziale e una lista. Nel nostro caso la procedura è "+", il valore iniziale è 0 e la lista è (1 2 3 4). Vediamo la stessa valutazione in termini di s-espressioni in notazione prefissa.

(fold-left + '(1 2 3 4) 0)

(+ 4 (+ 3 (+ 2 (+ 1 0))))

(+ 4 (+ 3 (+ 2 1)))

(+ 4 (+ 3 3))

(+ 4 6)  ==>  10

Il valore iniziale è importante perchè se la lista di input è vuota, allora questo è il valore che ritorna la funzione "fold-left".

(fold-left + '() 0)  ==>  0

Così possiamo definire una funzione somma in termini di "fold-left":

(define (somma lst) (fold-left + lst 0))

(somma '(1 2 3 4))   ==>  10

(somma '())          ==>  0

La procedura "fold-left" riduce la lista ad un singolo valore, quindi nel caso dell'inversione riduciamo la lista di ingresso ad una singola lista di uscita.

Vediamo un altro esempio di applicazione di "fold-left":

Rivediamo brevemente la valutazione della somma: la procedura è l'operatore "+" e il valore inziale vale zero.

(fold-left + '(1 2 3 4) 0)

(+ 4 (+ 3 (+ 2 (+ 1 0))))

(+ 4 (+ 3 (+ 2 1)))

(+ 4 (+ 3 3))

(+ 4 6)  ==>  10

Adesso vediamo la valutazione della funzione inverti. La procedura con cui "ripieghiamo" la lista è "cons" e il valore iniziale è la lista vuota '().

(fold-left cons '(1 2 3) '())

(cons 3 (cons 2 (cons 1 '())))

(cons 3 (cons 2 '(1)))

(cons 3 '(2 1))

==> '(3 2 1)

Implementiamo la funzione "fold-left":

(define (fold-left op lst init)
    (if (null? lst) init
        (fold-left op
               (rest lst)
               (op (first lst) init))))

(fold-left - '(1 2 3 4) 0)
;-> 2

(fold-left - '(4 3 2 1) 0)
;-> -2

Per completezza implementiamo anche la funzione "fold-right":

(define (fold-right op lst init)
    (if (null? lst) init
        (op
            (first lst)
            (fold-right op (rest lst) init))))

(fold-right - '(1 2 3 4) 0)
;-> -2

Vediamo la valutazione di questa funzione:

(fold-right - (- 1 (- 2 (- 3 (- 4 0)))))
  (- 1 (- 2 (- 3 (- 4 0))))
= (- 1 (- 2 (- 3 4)))
= (- 1 (- 2 -1))
= (- 1 3)
= -2

Altro esempio:

(fold-right - '(4 3 2 1) 0)
;-> 2

La funzione "fold-right" con operatore "cons" e la lista vuota '() come valore iniziale, produce una copia della lista passata.

(fold-right cons '(4 3 2 1) '())
;-> (4 3 2 1)

Ritorniamo al nostro problema, scriviamo la funzione inverti-fold e vediamo come funziona la valutazione:

(define (inverti-fold lst)
  (fold-left cons lst '()))

(inverti-fold '(1 2 3)) ; ==> ?

;; prima iterazione
(cons 1 '())    ; ==> '(1)

;; seconda iterazione
(cons 2 '(1))   ; ==> '(2 1)

;; terza iterazione
(cons 3 '(2 1)) ; ==> '(3 2 1)

(inverti-fold '(1 2 3 4 5 6 7 8 9))
;-> (9 8 7 6 5 4 3 2 1)

Funzione predefinita newLISP: (reverse lst)

Vediamo il tempo di esecuzione di queste funzioni:

(inverti '(1 2 3 4 5 6 7 8 9))
;-> (9 8 7 6 5 4 3 2 1)
(time (inverti '(1 2 3 4 5 6 7 8 9)) 100000)
;-> 296.81

(inverti2 '(1 2 3 4 5 6 7 8 9))
;-> (9 8 7 6 5 4 3 2 1)
(time (inverti2 '(1 2 3 4 5 6 7 8 9)) 100000)
;-> 281.463

(inverti-fold '(1 2 3 4 5 6 7 8 9))
;-> (9 8 7 6 5 4 3 2 1)

(time (inverti-fold '(1 2 3 4 5 6 7 8 9)) 100000)
;-> 281.237

(reverse '(1 2 3 4 5 6 7 8 9))
;-> (9 8 7 6 5 4 3 2 1)

(time (reverse '(1 2 3 4 5 6 7 8 9)) 100000)
; 15.622

Morale: implementate le funzioni per conto vostro in modo da imparare nuovi metodi, ma usate quelle predefinite (se esistono).


=======================================================
N-99-06 Determinare se una lista è palindroma
=======================================================

(define (palindroma? lst)
  (= lst (reverse (copy lst))))

(palindroma? '(e p r e s a l a s e r p e))
;-> true

(palindroma? '(e p r e s a l))
;-> nil


=======================================================
N-99-07 Appiattire una lista annidata
=======================================================

Una lista piatta e' una lista senza sottoliste, cioe' una lista costituita solo da atomi.

(define (piatta lst)
  (if (null? lst)
      '()
      (if (atom? lst)
          (list lst)
          (append (piatta (first lst)) (piatta (rest lst)))
      )
   )
)

(piatta '((1 2) ((2 (3)) (4 4)) (((7)))))
;-> (1 2 2 3 4 4 7)

Note:
Punto primo
La definizione ha tre casi:
a) l'argomento e' la lista vuota: restituisce una lista vuota;
b) l'argomento non e' una lista, quindi e' un atomo: allora lo mettiamo in lista con la funzione "list";
c) in tutti gli altri casi ci sono chiamate ricorsive per appiattire il primo elemento e il resto della lista, ed aggiungere i due risultati con "append".
Punto secondo
 Usa i due predicati "null?" ed "atom?".
Punto terzo
 Contiene due chiamate ricorsive sulle parti "first" e "rest" della lista.

Questi tre punti sono caratteristici per ogni funzione che lavora sulle liste di liste.

Funzione predefinita newLISP: (flat lst)

(flat '((1 2) ((2 (3)) (4 4)) (((7)))))
;-> (1 2 2 3 4 4 7)

Possiamo anche specificare quante annidamenti vogliamo rimuovere:

(flat '((1 2) ((2 (3)) (4 4)) (((7)))) 1)
;-> (1 2 (2 (3)) (4 4) ((7)))

(flat '((1 2) ((2 (3)) (4 4)) (((7)))) 2)
;-> (1 2 2 (3) 4 4 (7))


=======================================================
N-99-08 Elimina gli elementi duplicati consecutivi di una lista
=======================================================

Se una lista ordinata contiene elementi ripetuti, devono essere sostituiti con una singola copia dell'elemento. L'ordine degli elementi non deve essere cambiato.

Esempio: (elimina-duplicati '(1 1 1 2 2 3 4 4 5 5 5 6 6 6)) ==> (1 2 3 4 5 6)

(define (elimina-duplicati lst)
    (cond ((null? lst) '())
          ((null? (rest lst)) lst)
          ((= (first lst) (first (rest lst))) (elimina-duplicati (rest lst)))
          (true (cons (first lst) (elimina-duplicati (rest lst))))
    )
)

(elimina-duplicati '(1 1 1 2 2 3 4 4 5 5 5 6 6 6))
;-> (1 2 3 4 5 6)

(elimina-duplicati '(a a b b c c c))
;-> (a b c)


=======================================================
N-99-09 Unire gli elementi duplicati consecutivi di una lista in sottoliste
=======================================================

(define (raggruppa lst)
  (if (= lst '()) '()
    (cons (gruppo lst) (raggruppa (striscia lst)))
  )
)

(define (gruppo lst)
    (cond ((= lst '()) '())
          ((= (rest lst) '()) lst)
          ((= (first lst) (first (rest lst)))
              (cons (first lst) (gruppo (rest lst))))
          (true (list (first lst)))
    )
)

(define (striscia lst)
    (cond ((= lst '()) '())
          ((= (rest lst) '()) '())
          ((= (first lst) (first (rest lst)))
              (striscia (rest lst)))
          (true (rest lst))
    )
)

(raggruppa '(a a a a b c c a a d e e e e))
;-> ((a a a a) (b) (c c) (a a) (d) (e e e e))

(raggruppa '(a a))
;-> ((a a))


=======================================================
N-99-10 Run-length encode di una lista
=======================================================

Implementiamo il metodo di compressione Run Length Encoding ad una lista. Gli elementi consecutivi duplicati sono codificati come liste (N E) dove N è il numero di duplicati dell'elemento E.

newLISP permette di utilizzare diversi stili di programmazione, infatti per questo problema scriveremo la funzione di rle encode sia in uno stile imperativo (iterativo), che in uno stile funzionale (ricorsivo).

Cominciamo con la versione imperativa (iterativa).

; =====================================================
; (rle-encode lst)
; Codifica una lista con il metodo Run Length Encoding
; =====================================================
(define (rle-encode lst)
  (local (palo conta out)
    (cond ((= lst '()) '())
          (true
           (setq out '())
           (setq palo (first lst))
           (setq conta 0)
           (dolist (el lst)
              ; se l'elemento è uguale al precedente aumentiamo il suo conteggio
              (if (= el palo) (++ conta)
                  ; altrimenti costruiamo la coppia (conta el) e la aggiungiamo al risultato
                  (begin (extend out (list(list conta palo)))
                         (setq conta 1)
                         (setq palo el)
                  )
              )
           )
           ; aggiungiamo l'ultima coppia di valori
           (extend out (list(list conta palo)))
          )
    )
    out
  )
)

(rle-encode '(a a a a b c c a a d e e e e f))
;-> ((4 a) (1 b) (2 c) (2 a) (1 d) (4 e) (1 f))

Adesso scriviamo la stessa funzione in stile funzionale (ricorsiva).

Abbiamo bisogno di una funzione di supporto (helper) che ha come argomento aggiuntivo il conteggio degli elementi duplicati. Si controllano i primi due elementi l'uno con l'altro:
- se sono uguali si richiama la funzione di supporto sul resto della lista aumentando il conteggio
- se sono diversi si costruisce (con la funzione cons) il risultato parziale e poi si richiama la funzione di supporto sul resto della lista con il conteggio pari a uno.

(define (encode lst)
  (define (helper lst conta)
    (cond ((null? lst) '())
          ((null? (rest lst)) (cons (cons conta lst)))
          ((= (first lst) (first (rest lst))) (helper (rest lst) (+ conta 1)))
          (true (cons (cons conta (first lst)) (helper (rest lst) 1)))
    )
  )
  (helper lst 1))

(encode '(a a a a b c c a a d e e e e f))
;-> ((4 a) (1 b) (2 c) (2 a) (1 d) (4 e) (1 f))

(encode '())
;-> ()

Vediamo la differenza di velocità tra le due funzioni (iterativa e ricorsiva).

Versione iterativa

(rle-encode '(a a a a b c c a a d e e e e f))
;-> ((4 a) (1 b) (2 c) (2 a) (1 d) (4 e) (1 f))

(time (rle-encode '(a a a a b c c a a d e e e e f)) 50000)
;-> 187.481

Versione ricorsiva:

(encode '(a a a a b c c a a d e e e e f))
;-> ((4 a) (1 b) (2 c) (2 a) (1 d) (4 e) (1 f))

(time (encode '(a a a a b c c a a d e e e e f)) 50000)
;-> 468.707

La versione iterativa è 2.5 volte più veloce.


=======================================================
N-99-11 Run-length encode di una lista (modificato)
=======================================================

A differenza dell'esercizio precedente se un elemento non ha duplicati, allora viene semplicemente copiato nella lista risultante.
Solo gli elementi con duplicati assumono la forma (num elemento).

Esempio:
(rle-encode-2 '(a a a a b c c a a d e e e e))
;-> ((4 a) b (2 c) (2 a) d (4 e))

(define (car x)    (first x))
(define (cdr x)    (rest x))
(define (caar x)   (first (first x)))
(define (cadr x)   (first (rest x)))
(define (cadar x)  (first (rest (first x))))

Riscriviamo in un altro modo la funzione per il metodo rle encode standard:

(define (raccogli lst1)
  (define (raccogli-aux lst1 lst2)
    (cond ((null? lst1) '())
          ((and (not (null? (cdr lst1)))
                (= (car lst1) (cadr lst1)))
           (raccogli-aux (cdr lst1) (cons (car lst1) lst2)))
          (true (cons (cons (car lst1) lst2) (raccogli-aux (cdr lst1) '())))))
  (raccogli-aux lst1 '()))

(raccogli '(a a a a b c c a a d e e e e))
;-> ((a a a a) (b) (c c) (a a) (d) (e e e e))

(define (rle-encode-1 lst1)
  (define (rle-encode-1-aux lst1)
    (cond ((null? lst1) '())
          (true (cons (cons (length (car lst1)) (cons (caar lst1) '()))
                      (rle-encode-1-aux (cdr lst1))))))
  (rle-encode-1-aux (raccogli lst1)))

(rle-encode-1 '(a a a a b c c a a d e e e e))
;-> ((4 a) (1 b) (2 c) (2 a) (1 d) (4 e))

Adesso definiamo la funzione per il metodo rle encode modificato:

(define (rle-encode-2 lst1)
  (define (rle-encode-2-aux lst1)
    (cond ((null? lst1) '())
          ((= 1 (caar lst1)) (cons (cadar lst1) (rle-encode-2-aux (cdr lst1))))
          (true (cons (car lst1) (rle-encode-2-aux (cdr lst1))))))
  (rle-encode-2-aux (rle-encode-1 lst1)))

(rle-encode-2 '(a a a a b c c a a d e e e e))
;-> ((4 a) b (2 c) (2 a) d (4 e))


=======================================================
N-99-12 Run-length decode di una lista
=======================================================

Esempio: (rle-decode '((3 a) (2 b) (2 c) (1 a) (2 d)))
;-> (a a a b b c c a d d))

; =====================================================
; (rle-decode lst)
; Decodifica una lista compressa con il metodo Run Length Encoding
; =====================================================
(define (rle-decode lst)
  (local (out)
    (cond ((= lst '()) '())
          (true
           (setq out '())
           (dolist (el lst)
              (extend out (dup (last el) (first el)))
           )
          )
    )
    out
  )
)

(rle-decode '((3 a) (2 b) (2 c) (1 a) (2 d)))
;-> (a a a b b c c a d d))

(rle-decode '((4 a) (1 b) (2 c) (2 a) (1 d) (4 e) (1 f)))
;-> (a a a a b c c a a d e e e e f)

(rle-decode (rle-encode '(a a a a b c c a a d e e e e f)))
;-> (a a a a b c c a a d e e e e f)


=======================================================
N-99-13 Run-length encode di una lista (diretto)
=======================================================

Implementare il metodo di compressione dei dati run-length encode direttamente. Cioè non creare in modo esplicito le sottoliste che contengono l'elemento duplicato, come nel problema P09, ma contarli direttamente. Come nel problema P11, semplificare la lista dei risultati sostituendo le liste dei singleton (1 X) con X.

(define (rle-encode-direct lst1)
  (define (rle-encode-direct-aux lst1 n)
    (cond ((null? lst1) '())
          ((and (not (null? (cdr lst1))) (= (car lst1) (cadr lst1)))
                                         (rle-encode-direct-aux (cdr lst1) (+ 1 n)))
          (true (if (= n 0)
                    (cons (car lst1)
                          (rle-encode-direct-aux (cdr lst1) 0))
                    (cons (list (+ 1 n) (car lst1))
                          (rle-encode-direct-aux (cdr lst1) 0))))))
  (rle-encode-direct-aux lst1 0))

(rle-encode-direct '(a a a a b c c a a d e e e e))
;-> ((4 a) b (2 c) (2 a) d (4 e))


=======================================================
N-99-14 Duplicare gli elementi di una lista
=======================================================

Esempio: (duplicare '(a b c c d)) ==> (a a b b c c c c d d)

(define (duplica xs)
    (if (null? xs) '()
      (cons (car xs)
            (cons (car xs) (duplica (cdr xs))))))

(define (duplicare lst)
    (if (null? lst) '()
      (cons (first lst)
            (cons (first lst) (duplicare (rest lst))))))

(duplicare '(a b c))
;-> (a a b b c c)

(duplicare '((a b) c (d (e))))
;-> ((a b) (a b) c c (d (e)) (d (e)))


=======================================================
N-99-15 Replicare per n volte gli elementi di una lista
=======================================================

Esempio: (replica '(a b c) 3)  ==>  (a a a b b b c c c)

(define (ripeti x n)
  (if (zero? n) '()
      (cons x (ripeti x (- n 1)))))

(define (replica lst n)
  (if (null? lst) '()
      (append (ripeti (first lst) n) (replica (rest lst) n))))

(replica '(a b c) 3)
;-> (a a a b b b c c c)

(replica '(a b c) 1)
;-> (a b c)

(replica '(a b c) 0)
;-> ()

(replica '((a) (b c) d) 2)
;-> ((a) (a) (b c) (b c) d d)


=======================================================
N-99-16 Eliminare gli elementi da una lista per ogni k
=======================================================

Esempio: (elimina-ogni '(a b c d e f g) 2) ==> (a c e g)

 (define (elimina-ogni lst k)
   (define (helper lst k lst-orig)
     (if (null? lst) '()
       (if (= k 1) (helper (rest lst) lst-orig lst-orig)
         (cons (first lst) (helper (rest lst) (- k 1) lst-orig)))))
   (helper lst k k))

(elimina-ogni '(a b c d e f g) 2)
;-> (a c e g)

(elimina-ogni '(a b c d e f g) 3)
;-> (a b d e g)

(elimina-ogni '(a b c d e f g) 1)
;-> ()

(elimina-ogni '(a b c d e f g) 0)
;-> (a b c d e f g)


=======================================================
N-99-17 Dividere una lista in due parti (la lunghezza della prima lista è un parametro)
=======================================================

(define (divide-lista lst n)
  (define (divide-aux lst lst2 n)
    (cond ((null? lst) (list lst2 '()))
          ((= n 0)     (list lst2 lst))
          (true        (divide-aux (rest lst) (append lst2 (list (first lst))) (- n 1)))))
  (divide-aux lst '() n))

(divide-lista '(a b c d e f g h i k) 3)
;-> ((a b c) (d e f g h i k))

(divide-lista '(a b c d e f g h i k) 12)
;-> ((a b c d e f g h i k) ())

(divide-lista '() 3)
;-> (() ())


=======================================================
N-99-18 Estrarre una parte di una lista
=======================================================

Dati due indici, I e K, creare una lista contenente gli elementi tra l'I-esimo e il K-esimo della lista originale (entrambi i limiti inclusi). Il primo elemento ha indice 1 (uno).

(define (prendi-1 lst n)
  (if (or (zero? n) (null? lst)) '()
      (cons (first lst) (prendi-1 (rest lst) (- n 1)))))

(define (estrai-1 lst start end)
  (cond ((null? lst) '())
        ((> start 1)  (estrai-1 (rest lst) (- start 1) (- end 1)))
        (true         (prendi-1 lst end))))

(estrai-1 '(a b c d e f g h i k) 3 7)
;-> (c d e f g)

(estrai-1 '(a b c d e f g h i k) 35 35)
;-> ()

(estrai-1 '(a b c d e f g h i k) 1 2)
;-> (a b)

Se invece consideriamo che il primo elemento ha indice 0 (zero), basta modificare la funzione estrai in questo modo:
1) da (> start 1) a (> start 0)
2) da (prendi lst end) a (prendi lst (+ end 1))

(define (prendi-0 lst n)
  (if (or (zero? n) (null? lst)) '()
      (cons (first lst) (prendi-0 (rest lst) (- n 1)))))

(define (estrai-0 lst start end)
  (cond ((null? lst) '())
        ((> start 0)  (estrai-0 (rest lst) (- start 1) (- end 1)))
        (true         (prendi-0 lst (+ end 1)))))

(estrai-0 '(a b c d e f g h i k) 3 7)
;-> (d e f g h)

(estrai-0 '(a b c d e f g h i k) 3 3)
;-> (d)

(estrai-0 '(a b c d e f g h i k) 0 1)
;-> (a b)


=======================================================
N-99-19 Ruotare una lista di N posti a sinistra
=======================================================

(define (divide-lista lst n)
  (define (divide-aux lst lst2 n)
    (cond ((null? lst) (list lst2 '()))
          ((= n 0)     (list lst2 lst))
          (true        (divide-aux (rest lst) (append lst2 (list (first lst))) (- n 1)))))
  (divide-aux lst '() n))

(define (ruota-lista lst1 n)
  (if (or (null? lst1) (= n 0))
      lst1
      (if (> n 0)
          (let (lst2 (divide-lista lst1 n))
            (append (cadr lst2) (car lst2)))
          (let (lst2 (divide-lista lst1 (+ n (length lst1))))
            (append (cadr lst2) (car lst2))))))

(ruota-lista '(a b c d e f g h) 3)
;-> (d e f g h a b c)

(ruota-lista '(a b c d e f g h) -2)
;-> (g h a b c d e f)


=======================================================
N-99-20 Eliminare l'elemento k-esimo di una lista
=======================================================

Il primo elemento della lista ha indice 0 (zero).

(define (elimina-a lst k)
  (if (< k 0)
      (reverse (elimina-a (reverse lst) (- k)))
      (cond ((null? lst) '())
            ((= k -1)    lst)
            ((= k 0)     (rest lst))
            (true        (cons (first lst) (elimina-a (rest lst) (- k 1)))))))

(elimina-a '(a b c d e) 2)
;-> (a b d e)

(elimina-a '(a b c d e) 0)
;-> (b c d e)

(elimina-a '(a b c d e) -2)
;-> (a b d e)

(elimina-a '(a b c d e) 25)
;-> (a b c d e)


=======================================================
N-99-21 Inserire un elemento in una data posizione di una lista
=======================================================

Il primo elemento della lista ha indice 1 (uno).

Esempio: (inserisci-a 'z '(a b c d) 2)  ==>  (a z b c d)

(define (inserisci-a x lst k)
  (if (< k 0)
      (reverse (inserisci-a x (reverse lst) (- k)))
      (cond ((zero? k)   lst)
            ((= k 0)     (cons x lst))
            ((null? lst) '())
            (true        (cons (first lst) (inserisci-a x (rest lst) (- k 1)))))))

(inserisci-a 'alfa '(a b c d) 2)
;-> (a alfa b c d)

(inserisci-a 'alfa '(a b c d) -2)
;-> (a b c alfa d)

(inserisci-a 'alfa '(a b c d) 0)
;-> (a b c d)

(inserisci-a 'alfa '() 2)
;-> ()

(inserisci-a 'alfa '() 1)
;-> (alfa)

(inserisci-a 'alfa '(a b c d) 1000)
;-> (a b c d)


=======================================================
N-99-22 Creare una lista che contiene tutti i numeri interi di un intervallo
=======================================================

(define (seq start end (step 1))
  (cond ((= start end) (list end))
        ((> start end) '())
        (true (cons start (seq (+ start step) end step)))
  )
)

(seq 1 10)
;-> (1 2 3 4 5 6 7 8 9 10)

(seq 1 10 2)
;-> (1 3 5 7 9)

Un altro metodo per la stessa funzione (gestisce anche intervalli decrescenti):

(define (range lower upper)
  (define (helper lower upper)
    (if (> lower upper) '()
        (cons lower (helper (+ lower 1) upper))))
  (if (> lower upper)
    (reverse (helper upper lower))
    (helper lower upper)))

(range 1 10)
;-> (1 2 3 4 5 6 7 8 9 10)

(range 10 2)
(;-> (10 9 8 7 6 5 4 3 2)


=======================================================
N-99-23 Estrarre un dato numero di elementi da una lista in maniera casuale (random)
=======================================================

(define (estrai-random lst n)
  (slice (randomize lst) 0 n))

(estrai-random '(a b c d e f g h) 3)
;-> (h g b)


=======================================================
N-99-24 Lotto: estrarre N numeri differenti da un intervallo 1..M
=======================================================

(define (lotto-estrai n m)
  (estrai-random (sequence 1 m) n))

(lotto-estrai 6 90)
;-> (61 7 3 83 28 29)

(lotto-estrai 90 90)
;-> (69 76 37 47 81 8 90 55 13 53 26 78 61 64 30 79 11 17 72 42 86 41 45 33 73 80 19
;->  65 75 23 39 32 36 16 82 4 43 67 31 15 63 12 29 1 48 28 6 77 9 38 60 74 25 40 51
;->  10 89 18 88 46 71 50 7 2 22 68 35 70 20 57 49 59 44 54 87 62 34 21 56 84 85 3 2
;->  7 66 58 5 52 14 83 24)


=======================================================
N-99-25 Generare le permutazioni degli elementi di una lista
=======================================================

Prima definizione (ordine lessicografico):

(define (rimuovi x lst)
  (cond
    ((null? lst) '())
    ((= x (first lst)) (rimuovi x (rest lst)))
    (true (cons (first lst) (rimuovi x (rest lst))))))

(define (permutazioni lst)
  (cond
    ((= (length lst) 1)(list lst))
    (true (apply append(map(lambda (i) (map (lambda (j)(cons i j))
                                            (permutazioni (rimuovi i lst)))) lst)))))

(permutazioni '(1 2 3))
;-> ((1 2 3) (2 1 3) (2 3 1) (1 3 2) (3 1 2) (3 2 1))

Seconda definizione:

(define (insert l n e)
  (if (= 0 n)
      (cons e l)
      (cons (first l)
            (insert (rest l) (- n 1) e))))

(define (seq start end)
  (if (= start end)
      (list end)
      (cons start (seq (+ start 1) end))))

(define (permute l)
  (if (null? l) '(())
      (apply append (map (lambda (p)
                           (map (lambda (n) (insert p n (first l))) (seq 0 (length p))))
                         (permute (rest l))))))

(permute '(1 2 3))
;-> ((1 2 3) (2 1 3) (2 3 1) (1 3 2) (3 1 2) (3 2 1))

Usiamo la funzione di sistema "sequence" al posto della funzione utente "seq":

(define (insert lst n e)
  (if (= 0 n)
      (cons e lst)
      (cons (first lst)
            (insert (rest lst) (- n 1) e))))

(define (permutations l)
  (if (null? l) '(())
      (apply append (map (lambda (p)
                           (map (lambda (n) (insert p n (first l))) (sequence 0 (length p))))
                         (permutations (rest l))))))

(permutations '(1 2 3))
;-> ((1 2 3) (2 1 3) (2 3 1) (1 3 2) (3 1 2) (3 2 1))

(time (length (permutazioni '(0 1 2 3 4 5 6 7 8 9))))
;-> 45412.572

(time (length (permute '(0 1 2 3 4 5 6 7 8 9))))
;-> 13398.311

(time (length (permutations '(0 1 2 3 4 5 6 7 8 9))))
;-> 18024.311 ; Strano: "sequence" è più lenta di "seq".

Possiamo creare le permutazioni utilizzando l'algoritmo di Heap ( https://en.wikipedia.org/wiki/Heap%27s_algorithm ).
Questo algoritmo produce tutte le permutazioni scambiando un elemento ad ogni iterazione.

(define (perm lst)
  (local (i indici out)
    (setq indici (dup 0 (length lst)))
    (setq i 0)
    ; aggiungiamo la lista iniziale alla soluzione
    (setq out (list lst))
    (while (< i (length lst))
      (if (< (indici i) i)
          (begin
            (if (zero? (% i 2))
              (swap (lst 0) (lst i))
              (swap (lst (indici i)) (lst i))
            )
            ;(println lst);
            (push lst out -1)
            (++ (indici i))
            (setq i 0)
          )
          (begin
            (setf (indici i) 0)
            (++ i)
          )
       )
    )
    out
  )
)

(length (perm '(0 1 2 3 4 5 6 7 8 9)))
;-> 36628800

(time (length (perm '(0 1 2 3 4 5 6 7 8 9))))
;-> 3928.519

Questa funzioni è la più veloce tra tutte quelle presentate.


=======================================================
N-99-26 Generare le combinazioni di K oggetti distinti tra gli N elementi di una lista
=======================================================

(define (combinazioni k nlst)
  (cond ((zero? k)     '(()))
        ((null? nlst)  '())
        (true
          (append (map (lambda (k-1) (cons (first nlst) k-1))
                       (combinazioni (- k 1) (rest nlst)))
                  (combinazioni k (rest nlst))))))

(combinazioni 2 '(1 2 3 4))
;-> ((1 2) (1 3) (1 4) (2 3) (2 4) (3 4))

(combinazioni 3 '(1 2 3 4))
;-> ((1 2 3) (1 2 4) (1 3 4) (2 3 4))

(combinazioni 1 '(a b c))
;-> ((a) (b) (c))

(combinazioni 2 '(a b c))
;-> ((a b) (a c) (b c))

(combinazioni 3 '(a b c))
;-> ((a b c))


=======================================================
N-99-27 Raggruppare gli elementi di un insieme in sottoinsiemi disgiunti
=======================================================

(define (car lst) (first lst))
(define (cdr lst) (rest lst))

(define (combination k xs)
  (cond ((null? xs) '())
        ((= k 1) (map list xs))
        (true (append (map (lambda (x) (cons (car xs) x))
                           (combination (- k 1) (cdr xs)))
                      (combination k (cdr xs))))))

(combination 2 '(1 2 3 4))
;-> ((1 2) (1 3) (1 4) (2 3) (2 4) (3 4))

(define (group gs lst)
   (define (ciclo gs xss lst)
     (cond ((null? gs) xss)
           ((null? xss) '())
           (true
            (letn ((xs (car xss)) (resto (filter (lambda (e) (not (member e xs))) lst)))
              (append (map (lambda (ys) (list xs ys))
                           (ciclo (cdr gs) (combination (car gs) resto) resto))
                      (ciclo gs (cdr xss) lst))))))
   (ciclo (cdr gs) (combination (car gs) lst) lst))

(group '(2 2 3) '(luca vale andrea eva tommy roby vero))
;-> (((luca vale) ((andrea eva) (tommy roby vero)))
;->  ((luca vale) ((andrea tommy) (eva roby vero)))
;->  ((luca vale) ((andrea roby) (eva tommy vero)))
;->  ((luca vale) ((andrea vero) (eva tommy roby)))
;->  ((luca vale) ((eva tommy) (andrea roby vero)))
;->  ((luca vale) ((eva roby) (andrea tommy vero)))
;->  ((luca vale) ((eva vero) (andrea tommy roby)))
;->  ((luca vale) ((tommy roby) (andrea eva vero)))
;->  ((luca vale) ((tommy vero) (andrea eva roby)))
;->  ((luca vale) ((roby vero) (andrea eva tommy)))
;->  ((luca andrea) ((vale eva) (tommy roby vero)))
;->  ((luca andrea) ((vale tommy) (eva roby vero)))
;->  ((luca andrea) ((vale roby) (eva tommy vero)))
;->  ((luca andrea) ((vale vero) (eva tommy roby)))
;->  ((luca andrea) ((eva tommy) (vale roby vero)))
;->  ((luca andrea) ((eva roby) (vale tommy vero)))
;->  ((luca andrea) ((eva vero) (vale tommy roby)))
;->  ((luca andrea) ((tommy roby) (vale eva vero)))
;->  ((luca andrea) ((tommy vero) (vale eva roby)))
;->  ((luca andrea) ((roby vero) (vale eva tommy)))
;->  ((luca eva) ((vale andrea) (tommy roby vero)))
;->  ((luca eva) ((vale tommy) (andrea roby vero)))
;->  ((luca eva) ((vale roby) (andrea tommy vero)))
;->  ((luca eva) ((vale vero) (andrea tommy roby)))
;->  ((luca eva) ((andrea tommy) (vale roby vero)))
;->  ((luca eva) ((andrea roby) (vale tommy vero)))
;->  ((luca eva) ((andrea vero) (vale tommy roby)))
;->  ((luca eva) ((tommy roby) (vale andrea vero)))
;->  ((luca eva) ((tommy vero) (vale andrea roby)))
;->  ((luca eva) ((roby vero) (vale andrea tommy)))
;->  ((luca tommy) ((vale andrea) (eva roby vero)))
;->  ((luca tommy) ((vale eva) (andrea roby vero)))
;->  ((luca tommy) ((vale roby) (andrea eva vero)))
;->  ((luca tommy) ((vale vero) (andrea eva roby)))
;->  ((luca tommy) ((andrea eva) (vale roby vero)))
;->  ((luca tommy) ((andrea roby) (vale eva vero)))
;->  ((luca tommy) ((andrea vero) (vale eva roby)))
;->  ((luca tommy) ((eva roby) (vale andrea vero)))
;->  ((luca tommy) ((eva vero) (vale andrea roby)))
;->  ((luca tommy) ((roby vero) (vale andrea eva)))
;->  ((luca roby) ((vale andrea) (eva tommy vero)))
;->  ((luca roby) ((vale eva) (andrea tommy vero)))
;->  ((luca roby) ((vale tommy) (andrea eva vero)))
;->  ((luca roby) ((vale vero) (andrea eva tommy)))
;->  ((luca roby) ((andrea eva) (vale tommy vero)))
;->  ((luca roby) ((andrea tommy) (vale eva vero)))
;->  ((luca roby) ((andrea vero) (vale eva tommy)))
;->  ((luca roby) ((eva tommy) (vale andrea vero)))
;->  ((luca roby) ((eva vero) (vale andrea tommy)))
;->  ((luca roby) ((tommy vero) (vale andrea eva)))
;->  ((luca vero) ((vale andrea) (eva tommy roby)))
;->  ((luca vero) ((vale eva) (andrea tommy roby)))
;->  ((luca vero) ((vale tommy) (andrea eva roby)))
;->  ((luca vero) ((vale roby) (andrea eva tommy)))
;->  ((luca vero) ((andrea eva) (vale tommy roby)))
;->  ((luca vero) ((andrea tommy) (vale eva roby)))
;->  ((luca vero) ((andrea roby) (vale eva tommy)))
;->  ((luca vero) ((eva tommy) (vale andrea roby)))
;->  ((luca vero) ((eva roby) (vale andrea tommy)))
;->  ((luca vero) ((tommy roby) (vale andrea eva)))
;->  ((vale andrea) ((luca eva) (tommy roby vero)))
;->  ((vale andrea) ((luca tommy) (eva roby vero)))
;->  ((vale andrea) ((luca roby) (eva tommy vero)))
;->  ((vale andrea) ((luca vero) (eva tommy roby)))
;->  ((vale andrea) ((eva tommy) (luca roby vero)))
;->  ((vale andrea) ((eva roby) (luca tommy vero)))
;->  ((vale andrea) ((eva vero) (luca tommy roby)))
;->  ((vale andrea) ((tommy roby) (luca eva vero)))
;->  ((vale andrea) ((tommy vero) (luca eva roby)))
;->  ((vale andrea) ((roby vero) (luca eva tommy)))
;->  ((vale eva) ((luca andrea) (tommy roby vero)))
;->  ((vale eva) ((luca tommy) (andrea roby vero)))
;->  ((vale eva) ((luca roby) (andrea tommy vero)))
;->  ((vale eva) ((luca vero) (andrea tommy roby)))
;->  ((vale eva) ((andrea tommy) (luca roby vero)))
;->  ((vale eva) ((andrea roby) (luca tommy vero)))
;->  ((vale eva) ((andrea vero) (luca tommy roby)))
;->  ((vale eva) ((tommy roby) (luca andrea vero)))
;->  ((vale eva) ((tommy vero) (luca andrea roby)))
;->  ((vale eva) ((roby vero) (luca andrea tommy)))
;->  ((vale tommy) ((luca andrea) (eva roby vero)))
;->  ((vale tommy) ((luca eva) (andrea roby vero)))
;->  ((vale tommy) ((luca roby) (andrea eva vero)))
;->  ((vale tommy) ((luca vero) (andrea eva roby)))
;->  ((vale tommy) ((andrea eva) (luca roby vero)))
;->  ((vale tommy) ((andrea roby) (luca eva vero)))
;->  ((vale tommy) ((andrea vero) (luca eva roby)))
;->  ((vale tommy) ((eva roby) (luca andrea vero)))
;->  ((vale tommy) ((eva vero) (luca andrea roby)))
;->  ((vale tommy) ((roby vero) (luca andrea eva)))
;->  ((vale roby) ((luca andrea) (eva tommy vero)))
;->  ((vale roby) ((luca eva) (andrea tommy vero)))
;->  ((vale roby) ((luca tommy) (andrea eva vero)))
;->  ((vale roby) ((luca vero) (andrea eva tommy)))
;->  ((vale roby) ((andrea eva) (luca tommy vero)))
;->  ((vale roby) ((andrea tommy) (luca eva vero)))
;->  ((vale roby) ((andrea vero) (luca eva tommy)))
;->  ((vale roby) ((eva tommy) (luca andrea vero)))
;->  ((vale roby) ((eva vero) (luca andrea tommy)))
;->  ((vale roby) ((tommy vero) (luca andrea eva)))
;->  ((vale vero) ((luca andrea) (eva tommy roby)))
;->  ((vale vero) ((luca eva) (andrea tommy roby)))
;->  ((vale vero) ((luca tommy) (andrea eva roby)))
;->  ((vale vero) ((luca roby) (andrea eva tommy)))
;->  ((vale vero) ((andrea eva) (luca tommy roby)))
;->  ((vale vero) ((andrea tommy) (luca eva roby)))
;->  ((vale vero) ((andrea roby) (luca eva tommy)))
;->  ((vale vero) ((eva tommy) (luca andrea roby)))
;->  ((vale vero) ((eva roby) (luca andrea tommy)))
;->  ((vale vero) ((tommy roby) (luca andrea eva)))
;->  ((andrea eva) ((luca vale) (tommy roby vero)))
;->  ((andrea eva) ((luca tommy) (vale roby vero)))
;->  ((andrea eva) ((luca roby) (vale tommy vero)))
;->  ((andrea eva) ((luca vero) (vale tommy roby)))
;->  ((andrea eva) ((vale tommy) (luca roby vero)))
;->  ((andrea eva) ((vale roby) (luca tommy vero)))
;->  ((andrea eva) ((vale vero) (luca tommy roby)))
;->  ((andrea eva) ((tommy roby) (luca vale vero)))
;->  ((andrea eva) ((tommy vero) (luca vale roby)))
;->  ((andrea eva) ((roby vero) (luca vale tommy)))
;->  ((andrea tommy) ((luca vale) (eva roby vero)))
;->  ((andrea tommy) ((luca eva) (vale roby vero)))
;->  ((andrea tommy) ((luca roby) (vale eva vero)))
;->  ((andrea tommy) ((luca vero) (vale eva roby)))
;->  ((andrea tommy) ((vale eva) (luca roby vero)))
;->  ((andrea tommy) ((vale roby) (luca eva vero)))
;->  ((andrea tommy) ((vale vero) (luca eva roby)))
;->  ((andrea tommy) ((eva roby) (luca vale vero)))
;->  ((andrea tommy) ((eva vero) (luca vale roby)))
;->  ((andrea tommy) ((roby vero) (luca vale eva)))
;->  ((andrea roby) ((luca vale) (eva tommy vero)))
;->  ((andrea roby) ((luca eva) (vale tommy vero)))
;->  ((andrea roby) ((luca tommy) (vale eva vero)))
;->  ((andrea roby) ((luca vero) (vale eva tommy)))
;->  ((andrea roby) ((vale eva) (luca tommy vero)))
;->  ((andrea roby) ((vale tommy) (luca eva vero)))
;->  ((andrea roby) ((vale vero) (luca eva tommy)))
;->  ((andrea roby) ((eva tommy) (luca vale vero)))
;->  ((andrea roby) ((eva vero) (luca vale tommy)))
;->  ((andrea roby) ((tommy vero) (luca vale eva)))
;->  ((andrea vero) ((luca vale) (eva tommy roby)))
;->  ((andrea vero) ((luca eva) (vale tommy roby)))
;->  ((andrea vero) ((luca tommy) (vale eva roby)))
;->  ((andrea vero) ((luca roby) (vale eva tommy)))
;->  ((andrea vero) ((vale eva) (luca tommy roby)))
;->  ((andrea vero) ((vale tommy) (luca eva roby)))
;->  ((andrea vero) ((vale roby) (luca eva tommy)))
;->  ((andrea vero) ((eva tommy) (luca vale roby)))
;->  ((andrea vero) ((eva roby) (luca vale tommy)))
;->  ((andrea vero) ((tommy roby) (luca vale eva)))
;->  ((eva tommy) ((luca vale) (andrea roby vero)))
;->  ((eva tommy) ((luca andrea) (vale roby vero)))
;->  ((eva tommy) ((luca roby) (vale andrea vero)))
;->  ((eva tommy) ((luca vero) (vale andrea roby)))
;->  ((eva tommy) ((vale andrea) (luca roby vero)))
;->  ((eva tommy) ((vale roby) (luca andrea vero)))
;->  ((eva tommy) ((vale vero) (luca andrea roby)))
;->  ((eva tommy) ((andrea roby) (luca vale vero)))
;->  ((eva tommy) ((andrea vero) (luca vale roby)))
;->  ((eva tommy) ((roby vero) (luca vale andrea)))
;->  ((eva roby) ((luca vale) (andrea tommy vero)))
;->  ((eva roby) ((luca andrea) (vale tommy vero)))
;->  ((eva roby) ((luca tommy) (vale andrea vero)))
;->  ((eva roby) ((luca vero) (vale andrea tommy)))
;->  ((eva roby) ((vale andrea) (luca tommy vero)))
;->  ((eva roby) ((vale tommy) (luca andrea vero)))
;->  ((eva roby) ((vale vero) (luca andrea tommy)))
;->  ((eva roby) ((andrea tommy) (luca vale vero)))
;->  ((eva roby) ((andrea vero) (luca vale tommy)))
;->  ((eva roby) ((tommy vero) (luca vale andrea)))
;->  ((eva vero) ((luca vale) (andrea tommy roby)))
;->  ((eva vero) ((luca andrea) (vale tommy roby)))
;->  ((eva vero) ((luca tommy) (vale andrea roby)))
;->  ((eva vero) ((luca roby) (vale andrea tommy)))
;->  ((eva vero) ((vale andrea) (luca tommy roby)))
;->  ((eva vero) ((vale tommy) (luca andrea roby)))
;->  ((eva vero) ((vale roby) (luca andrea tommy)))
;->  ((eva vero) ((andrea tommy) (luca vale roby)))
;->  ((eva vero) ((andrea roby) (luca vale tommy)))
;->  ((eva vero) ((tommy roby) (luca vale andrea)))
;->  ((tommy roby) ((luca vale) (andrea eva vero)))
;->  ((tommy roby) ((luca andrea) (vale eva vero)))
;->  ((tommy roby) ((luca eva) (vale andrea vero)))
;->  ((tommy roby) ((luca vero) (vale andrea eva)))
;->  ((tommy roby) ((vale andrea) (luca eva vero)))
;->  ((tommy roby) ((vale eva) (luca andrea vero)))
;->  ((tommy roby) ((vale vero) (luca andrea eva)))
;->  ((tommy roby) ((andrea eva) (luca vale vero)))
;->  ((tommy roby) ((andrea vero) (luca vale eva)))
;->  ((tommy roby) ((eva vero) (luca vale andrea)))
;->  ((tommy vero) ((luca vale) (andrea eva roby)))
;->  ((tommy vero) ((luca andrea) (vale eva roby)))
;->  ((tommy vero) ((luca eva) (vale andrea roby)))
;->  ((tommy vero) ((luca roby) (vale andrea eva)))
;->  ((tommy vero) ((vale andrea) (luca eva roby)))
;->  ((tommy vero) ((vale eva) (luca andrea roby)))
;->  ((tommy vero) ((vale roby) (luca andrea eva)))
;->  ((tommy vero) ((andrea eva) (luca vale roby)))
;->  ((tommy vero) ((andrea roby) (luca vale eva)))
;->  ((tommy vero) ((eva roby) (luca vale andrea)))
;->  ((roby vero) ((luca vale) (andrea eva tommy)))
;->  ((roby vero) ((luca andrea) (vale eva tommy)))
;->  ((roby vero) ((luca eva) (vale andrea tommy)))
;->  ((roby vero) ((luca tommy) (vale andrea eva)))
;->  ((roby vero) ((vale andrea) (luca eva tommy)))
;->  ((roby vero) ((vale eva) (luca andrea tommy)))
;->  ((roby vero) ((vale tommy) (luca andrea eva)))
;->  ((roby vero) ((andrea eva) (luca vale tommy)))
;->  ((roby vero) ((andrea tommy) (luca vale eva)))
;->  ((roby vero) ((eva tommy) (luca vale andrea))))


=======================================================
N-99-28 Ordinare una lista in base alla lunghezza delle sottoliste
=======================================================

Calcoliamo le lunghezze delle sottoliste:

(map length '((a b c) (d e) (f g h) (d e) (i j k l) (m n) (o)))
;-> (3 2 3 2 4 2 1)

Definiamo una funzione che crea una lista con la seguente struttura:
((indice-lista lunghezza-lista)...(indice-lista lunghezza-lista))

(define (enumera-lunghezza lst)
  (local (out)
    (cond ((null? lst) '())
          (true (setq out '())
                (dolist (el lst)
                  ;(push (list $idx el) _out)
                  (extend out (list(list $idx (length el))))
                )
                ;(reverse _out)
          )
    )
  )
)

(setq lst '((a b c) (d e) (f g h) (d e) (i j k l) (m n) (o)))
(enumera-lunghezza lst)
;-> ((0 3) (1 2) (2 3) (3 2) (4 4) (5 2) (6 1))

Adesso ordiniamo questa lista in base al secondo elemento di ogni sottolista (che rappresenta la lunghezza della sottolista originale)

(define (comp x y)
    (>= (last x) (last y)))

(sort (enumera-lunghezza lst) comp)
;-> ((4 4) (0 3) (2 3) (1 2) (3 2) (5 2) (6 1))

Adesso possiamo creare la lista ordinata utilizzando come indice il primo elemento di ogni sottolista:

(define (ordina-lunghezza lst)
  (local (out)
    (cond ((null? lst) '())
          (true (setq out '())
                (setq lst-t (sort (enumera-lunghezza lst) comp))
                (dolist (el lst-t)
                  (extend out (list (nth (first el) lst)))
                )
          )
    )
  )
)

(ordina-lunghezza '((a b c) (d e) (f g h) (d e) (i j k l) (m n) (o)))
;-> ((i j k l) (a b c) (f g h) (d e) (d e) (m n) (o))

=============================================================================

==============

 ROSETTA CODE

==============

https://rosettacode.org/wiki/Category:Programming_Tasks

Rosetta Code è un sito di programmazione "chrestomathy" (proviene dal greco χρηστομάθεια e significa "desiderio di imparare"). L'idea è di risolvere/presentare la soluzione per lo stesso problema in quanti più linguaggi possibili, per dimostrare le analogie e le differenze dei linguaggi, e per aiutare chi conosce un linguaggio ad apprenderne un altro.
Il sito contiene moltissimi problemi risolti in più di 800 linguaggi (non tutti problemi sono stati risolti con tutti i linguaggi).
Di seguito vengono presentanti molti di questi problemi e la loro soluzione.
Per avere una migliore comprensione si consiglia di provare a risolverli per conto proprio prima di leggere la soluzione.

Nota: in questo capitolo vengono risolti circa 100 problemi presenti sul sito Rosetta Code (in ordine sparso). Molti altri problemi elencati nel sito e non qui presenti sono risolti in altri capitoli di questo documento.

--------
FIZZBUZZ
--------

Scrivere un programma che stampa i numeri interi da 1 a 100 (inclusi).
Ma:
- per multipli di tre, stampa Fizz (invece del numero)
- per multipli di cinque, stampa Buzz (invece del numero)
- per multipli di entrambi tre e cinque, stampa FizzBuzz (invece del numero)

(define (fizzbuzz)
  (for (i 1 100)
    (cond ((= 0 (% i 15)) (println "FizzBuzz"))
          ((= 0 (% i 3))  (println "Fizz"))
          ((= 0 (% i 5))  (println "Buzz"))
          (true           (println i))
    )
  )
)

(fizzbuzz)

Vediamo ora una generalizzazione del problema. Occorre scrivere una funzione che accetta una lista di fattori e una lista di parole associate. Un ulteriore parametro permette di specificare il numero massimo da stampare.
Come esempio possiamo usiare la seguente lista associativa:

(3 "Fizz")
(5 "Buzz")
(7 "Baxx")

Nel caso in cui un numero sia un multiplo di almeno due fattori, stampare ciascuna delle parole associate a tali fattori nell'ordine dal fattore minore a quello maggiore. Ad esempio, il numero 15 è un multiplo di entrambi 3 e 5, allora stampa FizzBuzz. Se il numero massimo vale 105, occorre stampare FizzBuzzBaxx perché è un multiplo di 3, 5 e 7.

(setq lst '((3 "Fizz") (5 "Buzz") (7 "Baxx")))

(define (fizzbuzzG n lst)
  (local (out)
    (for (i 1 n)
      (setq out "")
      (dolist (el lst)
        (if (= 0 (% i (first el))) (setq out (append out (last el))))
      )
      (if (= out "") (setq out (string i)))
      (print out {, })
    )
  )
)

(fizzbuzzG 20 lst)
;-> 1, 2, Fizz, 4, Buzz, Fizz, Baxx, 8, Fizz, Buzz, 11,
;-> Fizz, 13, Baxx, FizzBuzz, 16, 17, Fizz, 19, Buzz

(setq lst '((2 "Fizz") (3 "Buzz") (5 "Baxx")))

(fizzbuzzG 30 lst)
;-> 1, Fizz, Buzz, Fizz, Baxx, FizzBuzz, 7, Fizz, Buzz, FizzBaxx, 11,
;-> FizzBuzz, 13, Fizz, BuzzBaxx, Fizz, 17, FizzBuzz, 19, FizzBaxx, Buzz,
;-> Fizz, 23, FizzBuzz, Baxx, Fizz, Buzz, Fizz, 29, FizzBuzzBaxx


------------
NUMERI PRIMI
------------

In matematica, un numero primo (in breve anche primo) è un numero intero positivo che ha esattamente due divisori distinti. In modo equivalente si può definire come un numero naturale maggiore di 1 che è divisibile solamente per 1 e per sé stesso. Al contrario, un numero maggiore di 1 che abbia più di due divisori è detto composto.
L'algoritmo di base per calcolare i numeri primi è il cosiddetto Crivello di Eratostene.
Di seguito è riportato l'algoritmo che trova tutti i numeri primi minori o uguali a un intero dato n con il metodo di Eratostene:

1) Creare una lista di numeri interi consecutivi da 2 a n: (2, 3, 4, ..., n).

2) Inizialmente, sia p uguale a 2, il primo numero primo.

3) A partire da p^2, contare ad incrementi di p e marca nella lista tutti quei numeri che sono maggiori o uguali a p^2 stesso. Questi numeri saranno p(p + 1), p(p + 2), p(p + 3), ecc.

4) Trova nella lista il primo numero maggiore di p che non è marcato. Se non esiste tale numero, allora fermati -> algoritmo terminato). Altrimenti, lascia p uguale a questo numero (che è il prossimo primo), e ripeti dal punto 3.

Quando l'algoritmo termina, tutti i numeri nell'elenco che non sono contrassegnati sono primi.

(setq n 1000)
;definiamo un vettore di n+1 elementi tutti con valore true
;al termine dell'algoritmo i valori del vettore "primi" che hanno valore true sono numeri primi ()
(setq primi (array (add 1 n) '(true)))
(setq p 2)

(while (<= (* p p) n)
  (if (= (primi p) true)) ; se primi[p} non è cambiato, allora è un numero primo)
  ; Poniamo a nil tutti i multipli di p che sono maggiori o uguali al quadrato di p
  ; I numeri che sono multipli di p e sono minori di p^2 sono già stati marcati (posti a nil).
  (for (i (* p p) n p) (setq (primi i) nil))
  (++ p)
)

; stampiamo solo gli indici del vettore primi che hanno valore true (cioè sono numeri primi).
(for (p 2 n 1)
   (if (= (primi p) true)
      (print p { })
   )
)

Adesso possiamo scrivere la funzione completa:

(define (Eratostene n)
  (local (primi p)
    (setq primi (array (add 1 n) '(true)))
    (setq p 2)
    (while (<= (* p p) n)
      (if (= (primi p) true))
      (for (i (* p p) n p) (setq (primi i) nil))
      (++ p)
    )
    (for (p 2 n 1)
      (if (= (primi p) true)
          (print p { })
      )
    )
  )
)

(Eratostene 1000)
;-> 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113
;-> 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241
;-> 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383
;-> 389 397 401 409 419 421 431 433 439 443 449 457 461 463 467 479 487 491 499 503 509 521 523
;-> 541 547 557 563 569 571 577 587 593 599 601 607 613 617 619 631 641 643 647 653 659 661 673
;-> 677 683 691 701 709 719 727 733 739 743 751 757 761 769 773 787 797 809 811 821 823 827 829
;-> 839 853 857 859 863 877 881 883 887 907 911 919 929 937 941 947 953 967 971 977 983 991 997

Se vogliamo sapere soltanto se un certo numero è primo possiamo utilizzare altri metodi.
Il test di primalità più semplice è la "prova della divisione": dato un numero n, controlla se ogni numero intero m, che va da 2 a sqrt(n), divide precisamente n (la divisione non lascia resto). Se n è divisibile per uno qualsiasi dei valori di m allora n è composto, altrimenti è primo.

Ad esempio, per testare la primalità di 100 con questo metodo, considera tutti i divisori interi di 100:

2, 4, 5, 10, 20, 25, 50

Il fattore più grande è 100/2 = 50. Questo è vero per tutti n: tutti i divisori sono inferiori o uguali a n/2. Ispezionando i divisori, si determina che alcuni di essi sono ridondanti. L'elenco dei divisori può essere scritto come:

100 = 2 × 50 = 4 × 25 = 5 × 20 = 10 × 10 = 20 × 5 = 25 × 4 = 50 × 2

che dimostra la ridondanza. Una volta testato il divisore 10, che è sqrt(100), il primo divisore è semplicemente il dividendo di un precedente divisore. Pertanto, è possibile eliminare i divisori di prova superiori a sqrt(n). Tutti i numeri pari maggiori di 2 possono anche essere eliminati, poiché se un numero pari può dividere n, anche 2 può dividere quel numero.

Diamo un'occhiata ad un altro esempio e usiamo la prova della divisione per testare la primalità di 17. Poiché ora sappiamo che non abbiamo bisogno di testare usando divisori superiori a sqrt(n), abbiamo solo bisogno di usare divisori interi minori o uguali a sqrt(17) circa uaguale 4.12. Quindi sarebbero 2, 3 e 4. Come detto sopra, possiamo saltare 4 perché se 4 divide precisamente 17, 2 deve anche dividere precisamente 17, che avremmo già controllato prima. Questo ci lascia solo con 2 e 3. Dopo la divisione, troviamo che 17 non è divisibile per 2 o 3, e possiamo confermare che 17 deve essere primo.

L'algoritmo può essere ulteriormente migliorato osservando che tutti i numeri primi sono della forma 6k ± 1, con l'eccezione di 2 e 3. Ciò è dovuto al fatto che tutti gli interi possono essere espressi come (6k + i) per alcuni interi k e per i = - 1, 0, 1, 2, 3 o 4, poi 2 divide (6k + 0), (6k + 2), (6k + 4) e 3 divide (6k + 3). Quindi, un metodo più efficiente è quello di verificare se n è divisibile per 2 o 3, quindi controllare tutti i numeri della forma (6k ± 1 <= sqrt(n)). Questo è 3 volte più veloce di testare tutti i valori di m.
Lo pseudocodice della funzione è il seguente:

 function is_prime(n)
     if n ≤ 3
        return n > 1
     else if n mod 2 = 0 or n mod 3 = 0
        return false
     let i ← 5
     while i * i ≤ n
        if n mod i = 0 or n mod (i + 2) = 0
            return false
        i ← i + 6
     return true

Adesso scriviamo la nostra funzione:

(define (primo? n)
  (setq out true) ; il numero viene considerato primo fino a che non troviamo un divisore preciso
  (cond ((<= n 3) (setq out true))
        ((or (= (% n 2) 0) (= (% n 3) 0)) (setq out nil))
        (true (setq i 5)
              (while (<= (* i i) n)
                (if (or (= (% n i) 0) (= (% n (+ i 2)) 0)) (setq out nil))
                (setq i (+ i 6))
              )
        )
  )
  out
)

(primo? 100)
;-> nil

(primo? 3347833720307)
;-> nil

(primo? 100000017239)
;-> true

Calcoliamo il tempo di esecuzione:

(time (primo? 3347833720307) 100)
;-> 9468.2
(time (primo? 100000017239) 100)
;-> 1640.4

newLISP mette a disposizione la funzione "factor" per calcolare i fattori primi di un numero.
Ad esempio:

(factor 67456)
;-> (2 2 2 2 2 2 2 17 31)

"factor" restituisce una lista con i numeri della scomposizione in fattori del numero fornito.
Possiamo scrivere un'altra funzione per verificare se un dato numero è primo:
se la lunghezza della lista restituita dalla funzione "factor" vale 1, allora il numero è primo.

(define (primo-a? n)
  (= 1 (length (factor n))))

(primo-a? 3347833720307)
;-> nil
(primo-a? 100000017239)
;-> true

Poichè "factor" è una funzione predefinita (compilata) è molto veloce. Se proviamo a migliorare la nostra funzione (ad esempio eliminando i numeri pari dalla fattorizzazione) otteniamo miseri risultati:

(define (primo-b? n)
  (if (even? n) nil
      (= 1 (length (factor n)))))

(primo-b? 3347833720307)
;-> nil
(primo-b? 100000017239)
;-> true

Adesso vediamo la velocità di esecuzione delle due funzioni primo-a e primo-b:

(time (primo-a? 3347833720307) 100)
;-> 203.1
(time (primo-a? 100000017239) 100)
;-> 156.2

(time (primo-b? 3347833720307) 100)
;-> 203.2
(time (primo-b? 100000017239) 100)
;-> 156.2

Ci sono miglioramenti sostanziali tra "primo-a?" e "primo-b?", comunque entrambe sono circa 10 volte più veloci della funzione "primo?".

Nota: le funzioni "primo-a" e "primo-b" non funzionano con i big integer perchè la funzione "factor" non funziona con i big integer. Il numero massimo possibile (int64) vale: 9223372036854775807.

Riscriviamo la nostra funzione "primo?" in modo da funzionare con i big integer:

(define (primoBig? n)
  (local (out i)
    (setq out true) ; il numero viene considerato primo fino a che non troviamo un divisore preciso
    (cond ((<= n 3L) (setq out true))
          ((or (= (% n 2L) 0L) (= (% n 3L) 0L)) (setq out nil))
          (true (setq i 5L)
                (while (<= (* i i) n)
                  (if (or (= (% n i) 0L) (= (% n (+ i 2L)) 0L)) (setq out nil))
                  (setq i (+ i 6L))
                )
          )
    )
    out
  )
)

(primoBig? 3347833720307)
;-> nil
(primoBig? 100000017239)
;-> true

La funzione è lenta con numeri grandi:

(time (primoBig? 3347833720307) 100)
;-> 17672.8

(time (primoBig? 100000017239) 100)
;-> 3066.7

E raggiunge rapidamente il limite pratico di utilizzo con i big integer:

(primoBig? 1111235916285193) ; numero con 16 cifre
;-> true

(time (primoBig? 1111235916285193)) ; numero con 16 cifre
;-> 3250.1

(primoBig? 76912895956636885) ; numero con 17 cifre
;->  nil
(time (primoBig? 76912895956636885))
;-> 27235.75

Adesso scriviamo una funzione che fattorizza un numero raggruppando i termini uguali.
Ad esempio (fattorizza 45) deve produrre ((3 2) (5 1)), cioè 45 = 3^2 * 5^1.

(define (fattorizza x)
  (local (fattori unici)
    (setq fattori (factor x))
    (setq unici (unique fattori))
    (transpose (list unici (count unici fattori)))
    ;(map list unici (count unici fattori))
  )
)

(fattorizza 45)
;-> ((3 2) (5 1))

(fattorizza 232792560)
;-> ((2 4) (3 2) (5 1) (7 1) (11 1) (13 1) (17 1) (19 1))

(time (fattorizza 232792560) 100000)
;-> 342.6

(factor 9223372036854775807)
;-> (7 7 73 127 337 92737 649657)

(fattorizza 9223372036854775807)
;-> ((7 2) (73 1) (127 1) (337 1) (92737 1) (649657 1))

Può essere utile avere due funzioni che ricostruiscono il numero originale partendo dai due tipi di fattorizzazione:

Operazione inversa di "factor":

(setq f (factor 45))
;-> (3 3 5)

(setq num-f (apply * f))
;-> 45

Operazione inversa di "fattorizza":

(setq fg (fattorizza 45))
;-> ((3 2) (5 1))

(setq num-fg (apply * (map (lambda (x) (pow (first x) (last x))) fg)))
;-> 45

(setq fg (fattorizza 232792560))
;-> ((2 4) (3 2) (5 1) (7 1) (11 1) (13 1) (17 1) (19 1))

(setq num-fg (apply * (map (lambda (x) (pow (first x) (last x))) fg)))
;-> 232792560

Adesso scriviamo una funzione che converte il risultato di "fattorizza" nel risultato di "factor". Per esempio, ((2 3) (3 4)) --> (2 2 2 3 3 3 3)

(define (fattorizza-factor lst-fattori)
  (define (crea lst) (dup (first lst) (last lst)))
  (flat (map crea lst-fattori))
)

(crea '(2 3))
;-> (2 2 2)

(fattorizza-factor '((2 3) (3 4)))
;-> (2 2 2 3 3 3 3)

(fattorizza-factor (fattorizza 2301))
;-> (3 13 59)

(fattorizza-factor (fattorizza 29))
;-> (29)

Per finire scriviamo una funzione "fattori-primi" che fa lo stesso lavoro di "factor":

(define (fattori-primi numero)
  (define (fattori divisore numero)
    (if (> (* divisore divisore) numero)
        (list numero)
        (if (= (mod numero divisore) 0)
            (cons divisore (fattori divisore (/ numero divisore)))
            (fattori (+ divisore 1) numero)
        )
    )
  )
  (fattori 2L numero)
)

(fattori-primi 3434344L)
;-> (2L 2L 2L 151L 2843L)

(apply * (fattori-primi 3434344L))
;-> 3434344L

(factor 3434344L)
;-> (2 2 2 151 2843)

Ricordiamo che il valore massimo per i numeri int64 è 9223372036854775807.

(factor 9223372036854775807L)
;-> (7 7 73 127 337 92737 649657)

(fattori-primi 9223372036854775807L)
;-> ERR: call or result stack overflow in function > : *

Purtroppo "fattori-primi" è una funzione ricorsiva che consuma tutto lo stack di newLISP.

Proviamo allora a scrivere una versione iterativa che funziona con i big integer:

(define (fattori-primi n)
  (local (fp lim i)
    (setq fp '())
    (while (zero? (% n 2L))  ; quante volte il numero 2 divide esattamente il numero n
      (setq fp (cons 2L fp))
      (setq n (/ n 2L))
    )
    ; adesso n è un numero dispari
    (setq i 3L)
    (setq lim (sqrt n))
    (while (<= i lim)
      (while (zero? (% n i))  ; quante volte il numero "i" divide esattamente il numero n
        (setq fp (cons i fp))
        (setq n (/ n i))
      )
      (setq i (+ 2L i))
    )
    ; questa condizione verifica il caso che il numero n sia un numero primo maggiore di 2
    (if (> n 2L) (setq fp (cons n fp)))
    (reverse fp)
  )
)

(fattori-primi 256)
;-> (2L 2L 2L 2L 2L 2L 2L 2L)

(fattori-primi 3434344L)
;-> (2L 2L 2L 151L 2843L)

Questa volta la funzione "fattori-primi" produce i risultati corretti, ma è molto lenta con numeri grandi:

(time (fattori-primi 9223372036854775807L))
;-> 432092.716 ; 7 minuti e 12 secondi

(time (factor 9223372036854775807L))
;-> 1.998 ;

(fattori-primi 9223372036854775808L)
;-> (2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L
;->  2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L
;->  2L 2L 2L 2L 2L 2L 2L 2L 2L)

(time (fattori-primi 9223372036854775808L))
;-> 0

(factor 9223372036854775808L)
;-> ERR: number out of range in function factor

Attenzione: la funzione è molto lenta con numeri grandi.

(fattori-primi 9223372036854775809L)
;-> (3L 3L 3L 19L 43L 5419L 77158673929L)

(apply * '(3L 3L 3L 19L 43L 5419L 77158673929L))
;-> 9223372036854775809L

(time (fattori-primi 9223372036854775809L))
;-> 551342.497 ; 9 minuti e 11 secondi

Altra funzione che controlla se un numero è primo:

(define (isPrime n)
  (local (idx step out)
    (setq out true)
    (cond ((or (= n 2) (= n 3)) true)
          ((or (< n 2) (= (% n 2) 0) (= (% n 3) 0)) nil)
          (true
            (setq idx 5 step 2)
            (while (<= (* idx idx) n)
              (if (= 0 (% n idx)) (setq out nil))
              (setq idx (+ idx step))
              (setq step (- 6 step ))
            )
            out
          )
    )
  )
)

(isPrime 100)
;-> nil

(isPrime 18376353439383)
;-> nil

(isPrime 113)
;-> true

(factor 18376353439383)
;-> (3 850261 7204201)

(for (i 2 100000) (if (and (isPrime i) (> (length (factor i)) 1)) (println "error: " i)))
;-> nil

Vediamo un post di fdb sul forum di newLISP:

Funzione (factor) che calcola i numeri primi fino a n:

(define (primes-to n , (out '(2)))
  (for (i 3 n 2)
    (unless (rest (factor i))
      (push i out -1)
    )
  )
  out
)

(length (primes-to 1000000))
;-> 78498

(time (primes-to 1000000))
;-> 640.006

Funzione (Eratostene) che calcola i numeri primi fino a n:

(define (sieve-to n)
   (setq arr (array (+ n 1)) lst '(2))
   (for (x 3 n 2)
      (when (not (arr x))
         (push x lst -1)
         (for (y (* x x) n (* 2 x) (> y n))
            (setf (arr y) true))))
   lst
)

(length (sieve-to 1000000))
;-> 78498

(time (sieve-to 1000000))
;-> 251.022

Funzione che applica una operazione ad ogni coppia di elementi di una lista:
el(1) op el(2), el(2) op el(3), el(3) op el(4), ..., el(n-1) op (el n)

(define (funlist lst func rev)
  (if rev
      (map func (chop lst) (rest lst))
      (map func (rest lst) (chop lst)))))

Differenza/distanza tra gli elementi:

(funlist '(4 7 11 16 18) -)
;-> (3 4 5 2)

Somma tra gli elementi:

(funlist '(4 7 11 16 18) +)
;-> (11 18 27 34)

Calcoliamo le distanze tra le coppie di numeri primi contigui:

(funlist (sieve-to 1000) -)
;-> (1 2 2 4 2 4 2 4 6 2 6 4 2 4 6 6 2 6 4 2 6 4 6 8 4 2 4 2 4 14 4 6 2 10 2 6 6 4 6
;->  6 2 10 2 4 2 12 12 4 2 4 6 2 10 6 6 6 2 6 4 2 10 14 4 2 4 14 6 10 2 4 6 8 6 6 4
;->  6 8 4 8 10 2 10 2 6 4 6 8 4 2 4 12 8 4 8 4 6 12 2 18 6 10 6 6 2 6 10 6 6 2 6 6 4
;->  2 12 10 2 4 6 6 2 12 4 6 8 10 8 10 8 6 6 4 8 6 4 8 4 14 10 12 2 10 2 4 2 10 14 4
;->  2 4 14 4 2 4 20 4 8 10 8 4 6 6 14 4 6 6 8 6)

Contiamo la frequenza delle distanze:

(define (freq lst)
   (let (ulist (unique (sort lst)))
      (map list ulist (count ulist lst))))

(freq (funlist (sieve-to 1000) -))
;-> ((1 1) (2 35) (4 40) (6 44) (8 15) (10 16) (12 7) (14 7) (18 1) (20 1))

Ordiniamo le frequenze:

(define (comp x y) (>= (last x) (last y)))

(sort (freq (funlist (sieve-to 1000000) -)) comp)
;-> ((6 13549) (2 8169) (4 8143) (12 8005) (10 7079) (8 5569)
;->  (18 4909) (14 4233) (16 2881) (24 2682) (20 2401) (22 2172)
;->  (30 1914) (28 1234) (26 1175) (36 767)  (34 557)  (32 550)...
;->  ...(114 1))

La distanza più frequente tra due numeri primi vale 6.


---------------
NUMERI DI SMITH
---------------

I numeri di Smith sono numeri in cui la somma delle cifre decimali che compongono il numero è uguale alla somma delle cifre decimali dei suoi fattori primi escluso 1.
Per definizione, tutti i numeri primi sono esclusi in quanto (naturalmente) soddisfano questa condizione!

Esempio utilizzando il numero 166
I fattori primi di 166 sono: 2 x 83 = 166
Somma tutte le loro cifre decimali: 2 + 8 + 3 = 13
Somma le cifre decimali di 166: 1 + 6 + 6 = 13
Allora, il numero 166 è un numero Smith.

Scrivere un programma per trovare tutti i numeri Smith inferiori a 10000.

Le seguenti istruzioni verificano se un numero x è un numero di Smith:

(setq x 1234567890)
;-> 1234567890
(setq s (string x))
;-> "1234567890"
(setq a (slice (explode s) 0))
;-> ("1" "2" "3" "4" "5" "6" "7" "8" "9" "0")
(setq b (apply + (map int a)))
;-> 45

(setq f (factor x))
;-> (2 3 3 5 3607 3803)
(setq sf (apply string f))
;-> "233536073803"
(setq af (slice (explode sf) 0))
;-> ("2" "3" "3" "5" "3" "6" "0" "7" "3" "8" "0" "3")
(setq bf (apply + (map int af)))
;-> 43
(if (= b bf) true nil)
;-> nil

Adesso possiamo scrivere la funzione richiesta:

(define (smith? x)
  (local (s aa b f sf af bf)
    (cond
      ((bigint? x) -1) ; do not work with big integer
      ( true
          (setq s (string x))
          (setq a (slice (explode s) 0))
          (setq b (apply + (map int a)))
          (setq f (factor x))
          (if (= 1 (length f)) (setq f '(0))) ; trovato numero primo
          (setq sf (apply string f))
          (setq af (slice (explode sf) 0))
          (setq bf (apply + (map int af)))
          (= b bf)
          ;(if (= b bf) true nil)
      )
    )
  )
)

(smith? 166)
;-> true
(smith? 1234567890)
;-> nil
(smith? 123456789012938347464736374657484756578)
;-> -1

(define (smith10000)
  (let (n '())
    (for (i 1 10000)
      (if (smith? i) (setq n (append (list i) n)))
    )
    (println (reverse n))
    (println "Fino a 10000 ci sono " (length n) " numeri di Smith.")
  )
)

(smith10000)
;-> (4 22 27 58 85 94 121 166 202 265 274 319 346 355 378 382 391 438 454 483 517 526
;->  535 562 576 588 627 634 636 645 648 654 663 666 690 706 728 729 762 778 825 852
;->  861 895 913 915 922 958 985 1086 1111 1165 1219 1255 1282 1284 1376 1449 1507 1581
;->  1626 1633 1642 1678 1736 1755 1776 1795 1822 1842 1858 1872 1881 1894 1903 1908
;->  1921 1935 1952 1962 1966 2038 2067 2079 2155 2173 2182 2218 2227 2265 2286 2326
;->  2362 2366 2373 2409 2434 2461 2475 2484 2515 2556 2576 2578 2583 2605 2614 2679
;->  2688 2722 2745 2751 2785 2839 2888 2902 2911 2934 2944 2958 2964 2965 2970 2974
;->  3046 3091 3138 3168 3174 3226 3246 3258 3294 3345 3366 3390 3442 3505 3564 3595
;->  3615 3622 3649 3663 3690 3694 3802 3852 3864 3865 3930 3946 3973 4054 4126 4162
;->  4173 4185 4189 4191 4198 4209 4279 4306 4369 4414 4428 4464 4472 4557 4592 4594
;->  4702 4743 4765 4788 4794 4832 4855 4880 4918 4954 4959 4960 4974 4981 5062 5071
;->  5088 5098 5172 5242 5248 5253 5269 5298 5305 5386 5388 5397 5422 5458 5485 5526
;->  5539 5602 5638 5642 5674 5772 5818 5854 5874 5915 5926 5935 5936 5946 5998 6036
;->  6054 6084 6096 6115 6171 6178 6187 6188 6252 6259 6295 6315 6344 6385 6439 6457
;->  6502 6531 6567 6583 6585 6603 6684 6693 6702 6718 6760 6816 6835 6855 6880 6934
;->  6981 7026 7051 7062 7068 7078 7089 7119 7136 7186 7195 7227 7249 7287 7339 7402
;->  7438 7447 7465 7503 7627 7674 7683 7695 7712 7726 7762 7764 7782 7784 7809 7824
;->  7834 7915 7952 7978 8005 8014 8023 8073 8077 8095 8149 8154 8158 8185 8196 8253
;->  8257 8277 8307 8347 8372 8412 8421 8466 8518 8545 8568 8628 8653 8680 8736 8754
;->  8766 8790 8792 8851 8864 8874 8883 8901 8914 9015 9031 9036 9094 9166 9184 9193
;->  9229 9274 9276 9285 9294 9296 9301 9330 9346 9355 9382 9386 9387 9396 9414 9427
;->  9483 9522 9535 9571 9598 9633 9634 9639 9648 9657 9684 9708 9717 9735 9742 9760
;->  9778 9840 9843 9849 9861 9880 9895 9924 9942 9968 9975 9985)
;-> Fino a 10000 ci sono 376 numeri di Smith.


-----------------
NUMERI DI HAMMING
-----------------

I numeri di Hamming sono numeri della forma:

        H = 2^i × 3^j × 5^k

dove: i, j, k ≥ 0

Scrivere un programma per calcolare i numeri di hamming nel corretto ordine.

Questa funzione restituisce il più piccolo tra due numeri (anche big integer):

(define (minimo x y) (if (< x y) x y))

(define (hamming n bool)
  (local (h i j k x2 x3 x5)
    (setq h (array n '(0L))) ; utilizziamo un vettore big integer
    (setf (h 0) 1L)
    (setq i 0L)  (setq j 0L)  (setq k 0L)
    (setq x2 2L)  (setq x3 3L)  (setq x5 5L)
    (for (m 1 (-- n) 1)
      (setf (h m) (minimo x2 (minimo x3 x5)))
      ;(setf (h m) (min x2 (min x3 x5))) ; la funzione "min" non funziona con i big integer
      (if (= (h m) x2) (begin (++ i) (setq x2 (* (h i) 2L))))
      (if (= (h m) x3) (begin (++ j) (setq x3 (* (h j) 3L))))
      (if (= (h m) x5) (begin (++ k) (setq x5 (* (h k) 5L))))
    )
    (if bool h (last h)) ; se bool = true, allora resitutuisce tutti i numeri, altrimenti solo l'ultimo
  )
)

(hamming 20 true)
;-> (1L 2L 3L 4L 5L 6L 8L 9L 10L 12L 15L 16L 18L 20L 24L 25L 27L 30L 32L 36L)

(hamming 1691)
;-> 2125764000L

(hamming 1000000)
;-> 519312780448388736089589843750000000000000000000000000000000000000000000000000000000L

(time (hamming 1000000))
;-> 2130.027 (millisecondi)


-----------------
NUMERI DI CATALAN
-----------------

I numeri di Catalan formano una successione di numeri naturali utile in molti calcoli combinatori. Prendono il nome dal matematico belga Eugène Charles Catalan.
Esistono diverse definizioni equivalenti per calcolare questi numeri.
Prendiamo in considerazione una definizione ricorsiva:

C(0) = 1

         2*(2*n - 1)
C(n) = --------------- * C(n-1)
           (n + 1)

Quindi scriviamo una funzione che utilizza i big integer per il calcolo:

(define (catalan n)
  (if (< n 2) 1L
      (/ (* (- (* 4L n) 2L) (catalan (- n 1L))) (+ n 1L))
  )
)

(catalan 5L)
;-> 42L

(catalan 500L)
;-> 53949748691703906090941056611971112873483434819670316767942689642041003733637164
;-> 45082085507475097208889473175349731459177688817366281036278441002389211945617238
;-> 83202123256952806711505149177419849031086149939116975191706558395784192643914160
;-> 118616272189452807591091542120727401415762287153293056320L

Questa funzione genera un errore di stack-overflow per valori superiori di 512:

(catalan 513L)
;-> ERR: call or result stack overflow in function * : -
;-> called from user function (catalan (- n 1L))

Possiamo scrivere anche una versione iterativa, ma non possiamo usare i big-integer poichè la divisione altera il risultato, quindi dobbiamo usare i floating-point.
Utilizziamo una funzione diversa:

C(0) = C(1) = 1

C(n) = Prod[ (n + k)/k ] (dove k va da 2 a n) (per n > 1)

Iterativo
Non possiamo usare i big integer poichè la divisione altera il risultato, quindi dobbiamo usare i floating-point.

(define (catalan-i n)
  (let (res 1.0)
    (for (k 2 n)
        (setq res (mul res (div (add n k) k)))
    )
  )
)

(catalan-i 5L)
;-> 41.99999999999999

(ceil (catalan-i 5L))
;-> 42

(catalan-i 500L)
;-> 5.394974869170395e+296

Però possiamo usare un'altra definizione dei numeri Catalani per utilizzare i big-integer:

C(n) = binomiale(2n n) / (n + 1)

(define (binom num k)
  (if (> k num)
    0
    (let (r 1L)
      (for (d 1 k)
        (setq r (/ (* r num) d))
        (-- num)
      )
      r)))

(define (min-big a b) (if (< a b) a b))

(define (catalan-big n)
  (/ (binom (* 2 n) n) (+ 1L n)))

(map catalan-big (sequence 1 20))
;-> (1L 2L 5L 14L 42L 132L 429L 1430L 4862L 16796L
;->  58786L 208012L 742900L 2674440L 9694845L 35357670L
;->  129644790L 477638700L 1767263190L 6564120420L)

(time (catalan 500L) 1000)
;-> 634.693

(time (catalan-big 500L) 1000)
;-> 540.585

(= (map catalan (sequence 1 100)) (map catalan-big (sequence 1 100)))
;-> true


------------------
NUMERI DI KAPREKAR
------------------

Un numero intero positivo è un numero di Kaprekar se la rappresentazione decimale del suo quadrato può essere divisa una volta in due parti costituite da numeri interi positivi che sommano al numero originale.
Si noti che una divisione risultante in una parte costituita esclusivamente da 0 non è valida, poiché 0 non è considerato positivo.
Per convenzione 1 è un numero di Kaprekar.

(setq x 45)
;-> 45
(setq xx (* x x))
;-> 2025
(setq s (string (* x x)))
;-> "2025"

(for (i 0 (length s))
  (setq num1 (int (slice s 0 i) 0 10))
  (setq num2 (int (slice s i (length s)) 0 10))
  (println num1 { } num2)
)
;-> 0 2025
;-> 2 25
;-> 20 25 (la loro somma vale 45, quindi 45 è un numero di Kaprekar)
;-> 202 5
;-> 2025 0

Adesso possiamo scrivere la funzione:

(define (kaprekar? n)
  (local (kap i xx s num1 num2)
    (setq kap nil)
    (setq i 0)
    (setq xx (* n n))
    (setq s (string xx))
    (while (and (<= i (length s)) (= kap nil))
      (setq num1 (int (slice s 0 i) 0 10))
      (setq num2 (int (slice s i (length s)) 0 10))
      (if (and (> num2 0) (= n (+ num1 num2))) (setq kap true))
      (++ i)
    )
    kap
  )
)

(kaprekar? 1)
;-> true
(kaprekar? 10)
;-> nil
(kaprekar 2223)
;-> true

(define (kaprekar10000)
  (let (out '())
    (for (j 1 10000)
      (if (kaprekar? j) (setq out (append (list j) out)))
    )
    (println (reverse out))
    (println "Fino a 10000 ci sono " (length out) " numeri di Kaprekar.")
  )
)

(kaprekar10000)
;-> (1 9 45 55 99 297 703 999 2223 2728 4879 4950 5050 5292 7272 7777 9999)
;-> Fino a 10000 ci sono 17 numeri di Kaprekar.

(define (kaprekar1milione)
  (setq out '())
  (for (m 1 1000000)
    (if (kaprekar? m) (setq out (append (list m) out)))
  )
  (println (reverse out))
  (println "Fino a 1000000 ci sono " (length out) " numeri di Kaprekar.")
)

(kaprekar1milione)
;-> (1 9 45 55 99 297 703 999 2223 2728 4879 4950 5050 5292 7272 7777 9999 17344 22222
;->  38962 77778 82656 95121 99999 142857 148149 181819 187110 208495 318682 329967 351352
;->  356643 390313 461539 466830 499500 500500 533170 538461 609687 627615 643357 648648
;->  670033 681318 791505 812890 818181 851851 857143 961038 994708 999999)
;-> Fino a 1000000 ci sono 54 numeri di Kaprekar.

(time (kaprekar1milione))
;-> 11532 (millisecondi)


-------------
NUMERI FELICI
-------------

Un numero felice è definito dal seguente processo:
Iniziando con un numero intero positivo, sostituisci il numero con la somma dei quadrati delle sue cifre e ripeti il processo fino a quando il numero è uguale a 1 (dove rimarrà), o si genera un ciclo infinito che non include 1. Quei numeri per cui questo processo finisce in 1 sono numeri felici, mentre quelli che non terminano in 1 sono numeri infelici.
Vediamo un esempio:

(setq lista '())
;-> ()
(setq x 31)
;-> 31
(setq s (string x))
;-> "31"
(setq a (slice (explode s) 0))
;-> ("3" "1")
(setq b (apply + (map (lambda (x) (* (int x) (int x)))  a)))
;-> 10 (3*3 + 1*1)

(cond ((= b 1) (setq felice true) (setq continua nil))
      ((!= (ref b lista) nil) (setq felice nil) (setq continua nil))
      (true (setq lista (cons b lista)) (setq n b))
)

se (b = 1) allora (felice = true) e (continua = nil)                  ;(il numero è felice)
se (b si trova nella lista) allora (felice = nil) e (continua = nil)  ;(il numero non è felice)
altrimenti inserisci il numero nella lista e continua                 ;continua creazione lista

(define (felice? n)
  (local (continua lista x s a b)
    (setq continua true)
    (setq lista '())
    (setq x n)
    (while (= continua true)
      (setq s (string x))
      (setq a (slice (explode s) 0))
      (setq b (apply + (map (lambda (x) (* (int x) (int x)))  a)))
      (cond ((= b 1) (setq felice true) (setq continua nil))
            ((!= (ref b lista) nil) (setq felice nil) (setq continua nil))
            (true (setq lista (cons b lista)) (setq x b))
      )
    )
    felice
  )
)

(felice? 10)
;-> true
(felice? 11)
;-> nil
(felice? 31)
;-> true

(define (felici1000)
  (let (out '())
    (for (j 1 1000)
      (if (felice? j) (setq out (append (list j) out)))
    )
    (println (reverse out))
    (println "Fino a 1000 ci sono " (length out) " numeri felici.")
  )
)

(felici1000)
;-> (1 7 10 13 19 23 28 31 32 44 49 68 70 79 82 86 91 94 97 100 103 109 129 130 133 139
;->  167 176 188 190 192 193 203 208 219 226 230 236 239 262 263 280 291 293 301 302
;->  310 313 319 320 326 329 331 338 356 362 365 367 368 376 379 383 386 391 392 397
;->  404 409 440 446 464 469 478 487 490 496 536 556 563 565 566 608 617 622 623 632
;->  635 637 638 644 649 653 655 656 665 671 673 680 683 694 700 709 716 736 739 748
;->  761 763 784 790 793 802 806 818 820 833 836 847 860 863 874 881 888 899 901 904
;->  907 910 912 913 921 923 931 932 937 940 946 964 970 973 989 998 1000)
;-> Fino a 1000 ci sono 143 numeri felici.


-----------------
NUMERI PRIMORIALI
-----------------

I numeri primoriali sono quelli formati moltiplicando i numeri primi successivi.
La serie di numeri primoriali vale:

   primoriale (0) = 1 (per definizione)
   primoriale (1) = 2 (2)
   primoriale (2) = 6 (2 * 3)
   primoriale (3) = 30 (2 * 3 * 5)
   primoriale (4) = 210 (2 * 3 * 5 * 7)
   primoriale (5) = 2310 (2 * 3 * 5 * 7 * 11)
   primoriale (6) = 30030 (2 * 3 * 5 * 7 * 11 * 13)
   ...

Per esprimere questo matematicamente, primoriale(n) è il prodotto dei primi n numeri primi (successivi):

primorial(n) = prod[prime(k)] (con k che va da 1 a n)

Un metodo semplice, anche se relativamente lento, è quello di generare n numeri primi con il metodo di Eratostene e poi calcolare i numeri primoriali.
Il teorema dei numeri primi ci dice che l'ennesimo numero primo viene delimitato dalla seguente espressione:

n*ln(n) + n*ln(ln(n)) - 1 < p(n) < n*ln(n) + n*ln(ln(n)) per n ≥ 6

La funzione è la seguente (utilizza i big integer):

(define (primoriale n bool)
  (local (pn maxnum primi p sum)
    (cond ((= n 0L) (setq pn '(1L)))
          ((= n 1L) (setq pn '(1L 2L)))
          (
            (if (<= n 6L) (setq maxnum 20L)
                (setq maxnum (ceil (mul n (add (log n) (log (log n)))))) ; limite superiore
            )
            ;(println maxnum)
            ; generiamo la lista con tutti i numeri primi esistenti fino a maxnum
            (setq primi (array (+ 1L maxnum) '(true)))
            (setq p 2L)
            (while (<= (* p p) maxnum)
              (if (= (primi p) true))
              (for (i (* p p) maxnum p) (setq (primi i) nil))
              (++ p)
            )
            (setq lista-primi '())
            (for (p 2L maxnum)
              (if (= (primi p) true)
                  ;(print p { })
                  (setq lista-primi (cons p lista-primi))
              )
            )
            (reverse lista-primi) ; funzione distruttiva (cambia direttamente lista-primi)
            ;(println lista-primi)
            ;(println (length lista-primi))
            (if (> n (length lista-primi)) (println "Errore")
                ; Calcoliamo i numeri primoriali fino a n
                (begin
                  (setq pn '(1L))
                  (setq sum 1L)
                  (for (i 0L (- n 1L))
                    ;(println {i =} i)
                    (for (k 0L i)
                      ;(println k)
                      (setq sum (* sum (nth k lista-primi)))
                    )
                    (setq pn (cons sum pn))
                    (setq sum 1L)
                  )
                  (reverse pn)
                  ; risultato
                  (if (= bool true) pn
                      (last pn)
                  )
                )
            )
          )
    ); end cond
  )
)

(primoriale 0)
;-> 1L

(primoriale 1)
;-> (1L 2L)

(primoriale 6 true)
;-> (1L 2L 6L 30L 210L 2310L 30030L)

(primoriale 10 true)
;-> (1L 2L 6L 30L 210L 2310L 30030L 510510L 9699690L 223092870L 6469693230L)

(primoriale 20 true)
;-> (1L 2L 6L 30L 210L 2310L 30030L 510510L 9699690L 223092870L 6469693230L 200560490130L
;->  7420738134810L 304250263527210L 13082761331670030L 614889782588491410L 32589158477190044730L
;->  1922760350154212639070L 117288381359406970983270L 7858321551080267055879090L
;->  557940830126698960967415390L)

(primoriale 20)
;-> 557940830126698960967415390L

(primoriale 40)
;-> 166589903787325219380851695350896256250980509594874862046961683989710L


---------------
NUMERI PERFETTI
---------------

Un numero è perfetto quando è uguale alla somma dei suoi divisori propri.
Oppure, un numero è perfetto quando è uguale alla metà della somma di tutti i suoi divisori positivi (incluso se stesso).
I divisori propri di un numero sono tutti i divisori del numero tranne il numero stesso.
Ad esempio, i divisori di 6 sono {1,2,3,6}, mentre i divisori propri di 6 sono {1,2,3}.
Inoltre, poichè 1 + 2 + 3 = 6, allora 6 è un numero perfetto.
Si conoscono pochi numeri perfetti perchè diventano enormi velocemente.

Per calcolare questi numeri scriviamo per primo una funzione che restituisce i divisori propri di un numero:

(define (divisori n)
  (local (lista-div m i)
    (setq lista-div '(1)) ; aggiungo il numero 1
    (setq m (int (sqrt n)))
    (setq i 2)
    (while (<= i m)
        (if (zero? (% n i))   ; se 'i' è divisore di 'n'
            (if (= i (/ n i)) ; se entrambi i divisori sono gli stessi aggiungine uno,
                              ; altrimenti aggiungili entrambi
              ;(setq lista-div (cons i lista-div))
              ;(setq lista-div (cons (/ n i) (cons i lista-div)))
              (push i lista-div -1)
              (begin (push i lista-div -1) (push (/ n i) lista-div -1))
            )
        )
        (++ i)
    )
    ;(push n lista-div -1) ; aggiungo il numero stesso
    (sort lista-div)
  )
)

(divisori 128)
;-> (1 2 4 8 16 32 64)

(divisori 20)
;-> (1 2 4 5 10)

(define (perfetto? n)
  (if (= n (apply + (divisori n))) true nil)
)

(perfetto? 6)
;-> true

(perfetto? 8)
;-> nil

(define (perfetti n)
  (let (res '())
    (for (x 2 n)
      (if (= true (perfetto? x)) (setq res (cons x res)))
    )
    (reverse res)
  )
)

(perfetti 10000)
;-> (6 28 496 8128)

La funzione è corretta, ma molto lenta. Proviamo a scrivere una versione ottimizzata:

(define (perfetto-fast? n)
  (local (somma q)
    (cond ((< n 2) (setq somma nil))
          ((!= (mod n 2) 0) (setq somma nil)) ; i numeri dispari non sono perfetti
          (true (setq somma 1)
                (for (i 2 (sqrt n))
                    (if (= (mod n i) 0) (begin (setq somma (+ somma i))
                                                (setq q (/ n i))
                                                (if (> q i) (setq somma (+ somma q)))
                                          )
                    )
                )
          )
    )
    (= n somma)
  )
)

(perfetto-fast? 6)
;-> true

(perfetto-fast? 8128)
;-> true

(perfetto-fast? 33550336)
;-> true

(define (perfetti-fast n)
  (let (res '())
    (for (x 2 n)
      (if (= true (perfetto-fast? x)) (setq res (cons x res)))
    )
    (reverse res)
  )
)

(perfetti-fast 10000)
;-> (6 28 496 8128)

Non provare ad eseguire (perfetti-fast 35000000) per trovare il prossimo numero perfetto (che vale 33550336) perchè impiega molto tempo (alcune ore sul mio computer).

Vediamo la differenza di velocità:

(time (perfetti 10000) 100)
;-> 12625.9

(time (perfetti-fast 10000) 100)
;-> 6797.5

(div 12625.9 6797.5)
;-> 1.857432879735197

La funzione "perfetti-fast" è 1.86 volte più veloce della funzione "perfetti".

Nota: i numeri perfetti hanno come espressione binaria p valori uguali a uno seguiti da (p-1) zeri (con p numero primo). Qui il numero tra parentesi denota la base in cui il numero viene espresso:

6(10)        = 110(2)
28(10)       = 11100(2)
496(10)      = 111110000(2)
4128(10)     = 1111111000000(2)
33550336(10) = 1111111111111000000000000(2)

Proviamo con il numero 17 (17 valori 1 seguiti da 16 valori 0)
(binary2decimal "111111111111111110000000000000000")
(perfetto-fast? 8589869056)
;-> true

Quindi possiamo cercare i numeri perfetti con il seguente algoritmo:
1) Prendere il primo numero primo pk ()
2) Costruire il numero binario con pk volte 1 e (pk - 1) volte 0
3) Convertire il numero in decimale
4) Controllare se il numero covertito è perfetto
5) Prendere il successivo numero primo e ripeti dal passo 2)

Prima di tutto definiamo una funzione che converte una stringa binaria in un numero decimale (big integer):

(define (binary2decimal b)
  (local (l d r d)
    (setq l (length b))
    (setq d 0L)
    (setq r (reverse b))
    (dostring (c r)
      ;(println c { } (char c) { } $idx)
      (setq d (+ d (* (int (char c)) (pow 2 $idx))))
    )
  )
)

(binary2decimal "1111111")
;-> 127L

(binary2decimal "1111111111111000000000000")
;-> 33550336L

Adesso scriviamo la funzione per trovare i numeri perfetti con il nostro algoritmo:

(define (perfetti-primi)
  (local (primi res ns dp)
    ; lista di numeri primi (attenzione che la funzione "divisori" è lenta)
    (setq primi '(2L 3L 5L 7L 11L 13L 17L 19L 23L))
    (setq res '())
    (dolist (p primi)
      ; creo il numero binario
      (setq ns (join (list (dup "1" p) (dup "0" (- p 1)))))
      ; converto il numero binario in decimale
      (setq dp (binary2decimal ns))
      ; se il numero decimale è perfetto, allora lo stampo
      (if (= dp (apply + (divisori dp))) (print dp { (} p {), }))
    )
  )
)

(perfetti-primi)
;-> 6L (2L), 28L (3L), 496L (5L), 8128L (7L), 33550336L (13L),
;-> 8589869056L (17L), 137438691328L (19L), nil

(perfetto-fast? 2305843008139952128)
;-> true ; ma ci vuole tanto tempo


----------------
NUMERI AMICABILI
----------------

Due interi N e M sono considerati coppia di numeri amicabili se N != M e la somma dei divisori propri di N è uguale a M e la somma dei divisori propri di M è uguale a N.
I divisori propri di un intero positivo N sono quei numeri, diversi da N, che dividono N senza resto.
Per N > 1 includeranno sempre 1, ma per N == 1 non ci sono divisori propri.

Scrivere una funzione per trovare le coppie di numeri amicabili fino a N = 100.000

(define (somma-divisori n)
  (local (res m i)
    (setq res 0)
    (setq m (sqrt n))
    (setq i 2)
    (while (<= i m)
        (if (zero? (% n i))   ; se 'i' è un divisore di 'n'
            (if (= i (/ n i)) ; se entrambi i divisori sono uguali...
              (setq res (+ res i)) ; aggiungili una volta
              (setq res (+ res i (/ n i))) ; altrimenti aggiungili entrambi
            )
        )
        (setq i (+ i 1))
    )
    res
  )
)

(somma-divisori 10)
;-> 7

(define (somma-divisori-propri n)
  (+ 1 (somma-divisori n))
)

(define (amicabili)
  (local (spd spd2)
    (for (j 1 100000)
        (setq spd (somma-divisori-propri j))
        (setq spd2 (somma-divisori-propri spd))
        (if (and (= j spd2) (!= spd spd2))
            (println j { } spd)
        )
    )
  )
)

(amicabili)
;-> 220 284
;-> 284 220
;-> 1184 1210
;-> 1210 1184
;-> 2620 2924
;-> 2924 2620
;-> 5020 5564
;-> 5564 5020
;-> 6232 6368
;-> 6368 6232
;-> 10744 10856
;-> 10856 10744
;-> 12285 14595
;-> 14595 12285
;-> 17296 18416
;-> 18416 17296
;-> 63020 76084
;-> 66928 66992
;-> 66992 66928
;-> 67095 71145
;-> 69615 87633
;-> 71145 67095
;-> 76084 63020
;-> 79750 88730
;-> 87633 69615
;-> 88730 79750


-----------------
NUMERI PERNICIOSI
-----------------

Un numero pernicioso è un numero intero positivo il cui conteggio della popolazione è un numero primo.
Il numero di abitanti (popolazione) è il numero di uno (1) nella rappresentazione binaria di un numero intero non negativo.

Esempio
22 (che è 10110 in binario) ha un numero di abitanti pari a 3, che è primo, e quindi 22 è un numero pernicioso.

Funzione per verificare se un numero è primo:

(define (primo? n)
  (= 1 (length (factor n))))

Funzione che conta elementi in una lista:

(define (conta item lst)
    (cond ((null? lst) 0)
          ((= (first lst) item) (+ 1 (conta item (rest lst))))
          (true (conta item (rest lst)))))

(conta 'a '(a b c a n a c a a d f))
;-> 5

Funzione predefinita che conta elementi in una lista:

(count '(a) '(a b c a n a c a a d f))
;-> (5)

Funzione che converte un numero decimale in un numero binario:

(define (decimal2binary n)
  (cond ((zero? n) '())
        (true (cons (% n 2)
                    (decimal2binary (/ n 2))))))

(decimal2binary 63)
;-> (1 1 1 1 1 1)

Funzione che verifica se un numero è pernicioso:

(define (pernicioso? n)
  (local (np)
    (setq np (count '(1) (decimal2binary n)))
    (if (= true (primo? (first np))) true nil)
  )
)

(pernicioso? 22)
;-> true

Funzione che calcola i numeri perniciosi fino a n:

(define (perniciosi n)
  (let (res '())
    (for (x 2 n)
      (if (= true (pernicioso? x)) (setq res (cons x res)))
    )
    (reverse res)
  )
)

(perniciosi 25)
;-> (3 5 6 7 9 10 11 12 13 14 17 18 19 20 21 22 24 25)


--------------------
NUMERI DI MUNCHAUSEN
--------------------

Un numero di Munchausen è un numero naturale n la cui somma di cifre (in base 10), ciascuna (tranne la cifra zero) elevata alla potenza di se stessa, è uguale a n.

Ad esempio: 3435 = 3^3 + 4^4 + 3^3 + 5^5

Precalcoliamo i valori delle potenze:

(setq powers (cons '0 (map (lambda (x) (pow x x)) (sequence 1 9))))
;-> (0 1 4 27 256 3125 46656 823543 16777216 387420489)

Facciamo una prova:
(setq a (explode (string 3435)))
;-> ("3" "4" "3" "5")
(setq b (map int a))
;-> (3 4 3 5)
(apply + (map (lambda (x) (nth x powers)) b))
;-> 3435

Adesso definiamo la funzione che verifica se un dato numero è di Munchausen:

(define (munchausen n)
  (apply + (map (lambda (x) (nth x powers)) (map int (explode (string n)))))
)

(munchausen 3435)
;-> 3435

(munchausen 438579088)
;-> 438579088

Infine scriviamo la funzione che ricerca i numeri di Munchausen:

(define (cerca-munchausen m)
  (local (powers)
    (setq powers (cons '0 (map (lambda (x) (pow x x)) (sequence 1 9))))
    ;-> (0 1 4 27 256 3125 46656 823543 16777216 387420489)
    (dotimes (i m)
      (if (= i (munchausen i)) (println i))
    )
  )
)

(cerca-munchausen 10000)
;-> 1
;-> 3435
;-> nil

(time (cerca-munchausen 500000000))
;-> 0
;-> 1
;-> 3435
;-> 438579088
;-> 1814539.27 ; millisecondi (circa 30 minuti)


-------------------
SEQUENZA DI COLLATZ
-------------------

La sequenza di numeri di Collatz (o Hailstone) può essere generata da un numero intero positivo iniziale, n da:

   se n è 1, la sequenza termina.
   se n è pari anche allora il successivo n della sequenza vale n / 2
   se n è dispari allora il successivo n della sequenza vale (3 * n) + 1

(define (collatz n)
  (if (= n 1) '(1)
    (cons n (collatz (if (even? n) (/ n 2) (+ 1 (* 3 n)))))))

(define (collatz-lenght n)
  (length (collatz n))
)

(collatz 13123)
;-> (13123 39370 19685 59056 29528 14764 7382 3691 11074 5537 16612 8306 4153 12460
;->  6230 3115 9346 4673 14020 7010 3505 10516 5258 2629 7888 3944 1972 986 493 1480 740
;->  370 185 556 278 139 418 209 628 314 157 472 236 118 59 178 89 268 134 67 202 101 304
;->  152 76 38 19 58 29 88 44 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1)

(collatz-lenght 13123)
;-> 77

Ecco una espressione che prende un numero e calcola la relativa lunghezza della sequenza di Collatz (scritta da Cormullion):

(let(f(fn(x)(cond((= x 1)0)((odd? x)(++(f(++(* 3 x)))))(1(++(f(>> x)))))))(f(int(read-line))))

10
;-> 6


------------
PERMUTAZIONI
------------

Una permutazione è un modo di ordinare in successione oggetti distinti.
Il numero delle permutazioni di n elementi vale: n!.

; =====================================================
; (permutazioni lst)
; Permutazioni di n elementi
; senza ripetizioni
; =====================================================

(define (remove x lst)
  (cond
    ((null? lst) '())
    ((= x (first lst))(remove x (rest lst)))
    (true (cons (first lst) (remove x (rest lst))))))

(define (permutazioni lst)
  (cond
    ((= (length lst) 1)(list lst))
    (true (apply append(map(lambda (i) (map (lambda (j)(cons i j))
                                            (permutazioni (remove i lst)))) lst)))))

(permutazioni '(1 2 3))
;-> ((1 2 3) (2 1 3) (2 3 1) (1 3 2) (3 1 2) (3 2 1))

Come funziona?

Quali sono le permutazioni di una lista e come le troveresti?

Le permutazioni di una lista con un singolo elemento sono la lista stessa.
Le permutazioni di (1 2) sono l'insieme: [(1 2) (2 1)].
Le permutazioni di (1 2 3) sono l'insieme: [(1 2 3) (1 3 2) (2 3 1) (2 1 3) (3 1 2) (3 2 1)]

In generale ci sono n! permutazioni in un elenco di lunghezza n - abbiamo n scelte per il primo elemento, e una volta che abbiamo scelto quello, (n-1) scelte per il secondo elemento, (n-2) per il terzo elemento, e così via. Questa diminuzione dei gradi di libertà ci suggerisce di trovare le permutazioni di un elenco di lunghezza n in termini di permutazioni di un elenco di lunghezza (n - 1), e così via fino a raggiungere le permutazioni di un elenco di elementi singoli.
Si scopre che le permutazioni di una lista sono precisamente l'insieme [elemento anteposto alle permutazioni di [lista - elemento], per ogni elemento nella lista].

Osservando il caso (1 2 3) si conferma che questo è vero - abbiamo 1 che prece (2 3) e (3 2), che sono le permutazioni di (2 3), 2 che precede (1 3) e (3 1) e così via. Questa operazione di anteporre l'elemento alla sottolista potrebbe essere definita come:

(define (prepend j)
  (cons element j))

e l'operazione per applicarlo a tutte le permutazioni della sottolista potrebbe essere:

(map prepend (permutazioni sublist))

Questa operazione è molto onerosa (considerando che hanno tutti la stessa forma), quindi utilizziamo un approccio lambda che cattura il valore dell'elemento considerato. L'operazione che vogliamo diventa:

(map (lambda (j) (cons element j)) (permutazioni sublist))

Adesso vogliamo applicare questa operazione ad ogni elemento della lista, quindi utilizziamo la funzione map con un'altra funzione lambda:

(map (lambda (element)
       (lambda (j) (cons element j) (permutazioni sublist)))
     list)

Sembra che vada tutto bene, ma c'è un problema: ogni ciclo di ricorsione prende un elemento e lo converte in una lista. Questo va bene per una lista di lunghezza 1, ma per liste più lunghe ogni elemento genera un annidamento della lista. Per inserire allo stesso livello ogni permutazione generata dobbiamo utilizzare la funzione (apply append...).
Adesso l'unica cosa che manca è come generare la prima sottolista? Questo viene ottenuto utilizzando la funzione "remove": la sottolista è uguale a (remove element list).
La funzione "remove" elimina l'elemento x dalla lista lst:

(remove '1 '(1 2 3 1 1))
;-> (2 3)

In definitiva l'istruzione completa è la seguente:

(apply append (map (lambda (i) (lambda (j) (cons i j))
                               (permutazioni (remove i lst))) lst))

che risove tutti i casi tranne quello base che viene preso in conasiderazione da:

((= (length lst) 1)(list lst))

Questo è tutto, ma per capire meglio la funzione "permutazioni" facciamo un esempio partendo dall'interno e proseguendo verso l'esterno.
Applichiamo l'espressione interna (permutazioni (remove i lst)) ad uno degli elementi:

(define lst '(1 2 3))
(define i 1)
(permutazioni (remove i lst))
;-> ((2 3) (3 2))

L'espressione rimuove un elemento e genera, ricorsivamente, le permutazioni del resto della lista.
Adesso applichiamo map con la funzione lambda sulle permutazioni ottenute:

(define j 1)
(map (lambda (j) (cons i j)) (permutazioni (remove i lst)))
;-> ((1 2 3) (1 3 2))

Quindi il map interno produce tutte le permutazioni per un dato i (in questo caso i=1)
Il map esterno assicura che tutte le permutazioni sono generate considerando tutti gli elementi della lista lst come primo elemento:

(map (lambda (i) (map (lambda (j) (cons i j))
                      (permutazioni (remove i lst))))
     lst)
;-> (((1 2 3) (1 3 2)) ((2 1 3) (2 3 1)) ((3 1 2) (3 2 1)))

Ma questo genera troppe liste innestate, quindi l'applicazione di append appiattisce una lista di liste:

(append '(1 2) '(3 4) '(5 6))
;-> (1 2 3 4 5 6)

(apply append '(((1 2 3) (1 3 2)) ((2 1 3) (2 3 1)) ((3 1 2) (3 2 1))))
;-> ((1 2 3) (1 3 2) (2 1 3) (2 3 1) (3 1 2) (3 2 1))

In questo modo otteniamo la lista corretta delle permutazioni.

Anche la seguente funzione calcola le permutazioni, ma con un metodo diverso:

(define (insert lst n e)
  (if (= 0 n)
      (cons e lst)
      (cons (first lst)
            (insert (rest lst) (- n 1) e))))

(define (permutazioni l)
  (if (null? l) '(())
      (apply append (map (lambda (p)
                           (map (lambda (n)
                                  (insert p n (first l)))
                                (sequence 0 (length p))))
                         (permutazioni (rest l))))))

(permutazioni '(1 2 3))
;-> ((1 2 3) (2 1 3) (2 3 1) (1 3 2) (3 1 2) (3 2 1))

Possiamo creare le permutazioni utilizzando l'algoritmo di Heap ( https://en.wikipedia.org/wiki/Heap%27s_algorithm ).
Questo algoritmo produce tutte le permutazioni scambiando un elemento ad ogni iterazione.

(define (perm lst)
  (local (i indici out)
    (setq indici (dup 0 (length lst)))
    (setq i 0)
    ; aggiungiamo la lista iniziale alla soluzione
    (setq out (list lst))
    (while (< i (length lst))
      (if (< (indici i) i)
          (begin
            (if (zero? (% i 2))
              (swap (lst 0) (lst i))
              (swap (lst (indici i)) (lst i))
            )
            ;(println lst);
            (push lst out -1)
            (++ (indici i))
            (setq i 0)
          )
          (begin
            (setf (indici i) 0)
            (++ i)
          )
       )
    )
    out
  )
)

(perm '(a b c))
;-> ((a b c) (b a c) (c a b) (a c b) (b c a) (c b a))

(perm '(a b b))
;-> ((a b b) (b a b) (b a b) (a b b) (b b a) (b b a))

(length (perm '(0 1 2 3 4 5 6 7 8 9)))
;-> 36628800

(time (length (perm '(0 1 2 3 4 5 6 7 8 9))))
;-> 3928.519

; =====================================================
; (perm-rep k lst)
; Permutazioni di k elementi su n elementi
; con ripetizioni
; =====================================================

Il numero di permutazioni con ripetizione di n elementi distinti presi a k vale: n!/(n - k)!

Per trovare un metodo può essere utile scrivere alcuni risultati per valori piccoli di N e vedere se riesciamo a estrapolare uno schema:

LISTA = (a b)
DIMENSIONE  (ELEMENTI DELLA PERMUTAZIONE)
0           ( () )
1           ( (a) (b) )
2           ( (a a) (a b) (b a) (b b) )
3           ( (a a a) (a a b) (a b a) (a b b) (b a a) ... )

Quindi fondamentalmente quello che vogliamo fare è, dato R = (permutazioni n elementi), ottenere (permutazioni (+ n 1) elementi) prendendo ogni permutazione P in R, e quindi per ogni elemento E in LISTA, uniamo E a P per creare una nuova permutazione e la memorizziamo in una lista. Questo possiamo farlo con MAP annidate:

(define (perm-rep k lst)
  (if (zero? k) '(())
      (flat (map (lambda (p)          ; For each permutation we already have:
                 (map (lambda (e)     ; For each element in the set:
                        (cons e p))   ; Add the element to the perm'n.
                      elements))
               (permutations (- k 1) elements))))

Dobbiamo usare "flat" per la funzione esterna "map", perché la MAP interna crea liste di nuove permutazioni e dobbiamo unire queste liste insieme per creare un'unica lista (piatta) delle permutazioni che vogliamo.

(define (perm-rep k lst)
  (if (zero? k) '(())
      (flat (map (lambda (p) (map (lambda (e) (cons e p)) lst))
                         (perm-rep (- k 1) lst)) 1)))

(perm-rep 2 '(a b c))
;-> ((a a) (b a) (c a) (a b) (b b) (c b) (a c) (b c) (c c))

(perm-rep 2 '(a b b))
((a a) (b a) (b a) (a b) (b b) (b b) (a b) (b b) (b b))


------------
COMBINAZIONI
------------

; =====================================================
; (combinazioni k nlst)
; Calcola le combinazioni di k elementi da n elementi
; senza ripetizione
; =====================================================

(define (combinazioni k nlst)
  (cond ((zero? k)     '(()))
        ((null? nlst)  '())
        (true
          (append (map (lambda (k-1) (cons (first nlst) k-1))
                       (combinazioni (- k 1) (rest nlst)))
                  (combinazioni k (rest nlst))))))

(combinazioni 2 '(1 2 3 4))
;-> ((1 2) (1 3) (1 4) (2 3) (2 4) (3 4))

(combinazioni 3 '(1 2 3 4))
;-> ((1 2 3) (1 2 4) (1 3 4) (2 3 4))

(combinazioni 1 '(a b c))
;-> ((a) (b) (c))

(combinazioni 2 '(a b c))
;-> ((a b) (a c) (b c))

(combinazioni 3 '(a b c))
;-> ((a b c))

; =====================================================
; (comb-rep k nlst)
; Calcola le combinazioni di k elementi da n elementi
; con ripetizione
; =====================================================
(define (comb-rep k lst)
  (cond ((= k 0) '(()))
        ((null? lst) '())
        (true
         (append (map (lambda (x) (cons (first lst) x))
                      (comb-rep (- k 1) lst))
                 (comb-rep k (rest lst))))))

(comb-rep 2 '(a b))
;-> ((a a) (a b) (b b))
(comb-rep 2 '(1 2 3 4))
;-> ((1 1) (1 2) (1 3) (1 4) (2 2) (2 3) (2 4) (3 3) (3 4) (4 4))
(comb-rep 2 '(1 2 3))
;-> ((1 1) (1 2) (1 3) (2 2) (2 3) (3 3))
(comb-rep 3 '(1 2 3))
;-> ((1 1 1) (1 1 2) (1 1 3) (1 2 2) (1 2 3) (1 3 3) (2 2 2) (2 2 3) (2 3 3) (3 3 3))


----------------
REGOLA DI HORNER
----------------

Calcolare il valore del polinomio: y = 6*x^3 - 4*x^2 + 7*x - 19 per x = 3.
La regola di Horner è un algoritmo inventato da William George Horner che permette di valutare un polinomio: Pn(x) = a(0)*x^n + a(1)*x^(n-1) +...+ a(n-1)*x + a(n) svolgendo n addizioni ed n moltiplicazioni (algoritmo ottimale). Infatti è possibile riscrivere il polinomio nella forma:

Pn(x) = a(n) + x*(a(n-1) + x*(a(n-2) + ... + x*(a(1) + a(0)*x)...))

Pertanto, il valore di tale polinomio si può calcolare sfruttando la definizione ricorsiva:

p(0) = a(0)
p(k+1) = p(k)*x + a(k+1)

Scriviamo la funzione prima in stile funzionale:

(define (horner lst x)
  (define (*horner lst x acc)
    (if (null? lst) acc
        (*horner (rest lst) x (+ (* acc x) (first lst)))))
  (*horner (reverse lst) x 0))

(horner '(-19 7 -4 6) '3)
;-> 128

Adesso la scriviamo in stile iterativo:

(define (horner-i lst-coeffs x)
  (local (acc)
    (setq acc 0)
    (reverse lst-coeffs) ; funzione distruttiva
    (dolist (el lst-coeffs)
      ;acc = acc * x + c
      (setq acc (add (mul acc x) el))
    )
    acc
  )
)

(horner-i '(-19 7 -4 6) '3)
;-> 128

Vediamo un altro modo di scrivere la funzione in stile funzionale:

(define (horner-f lst x)
  (cond ((null? lst) '0)
        (true (+ (first lst) (* x (horner-f (rest lst) x))))))

(horner-f '(-19 7 -4 6) '3)
;-> 128


-------------------------------
PROBLEMA DELLO ZAINO (KNAPSACK)
-------------------------------

Il problema dello zaino, detto anche problema di Knapsack, è un problema di ottimizzazione combinatoria definito nel modo seguente:
Dato uno zaino che può supportare determinato peso e dati N oggetti, ognuno dei quali caratterizzato da un peso e un valore, il problema si propone di scegliere quali di questi oggetti mettere nello zaino per ottenere il maggiore valore senza eccedere il peso sostenibile dallo zaino stesso.
In maniera formale la formulazione del problema diventa:
- ognuno degli N oggetti possiede un peso p(i) e un valore v(i)
- il valore W indica il peso massimo sopportabile dallo zaino;
- la possibilità che un oggetto venga inserito o meno nello zaino è espressa dalle variabili intere x(i)
La funzione obiettivo è:

max Z = Sum(ci*xi) (per i=1..N)

Con i vincoli:

W <= Sum(wi*xi) (per i=1..N)

Si indichino con w{i} il peso dell'i-esimo oggetto e con c{i} il suo valore. Si vuole massimizzare il valore totale rispettando il vincolo che il peso totale sia minore o uguale al peso massimo consentito W. Definiamo A(i,j) come il massimo valore che può essere trasportato con uno zaino di capacità j <= W avendo a disposizione solo i primi "i" oggetti.

Si può definire A(i,j) ricorsivamente come segue:

A(0,j) = 0
A(i,0) = 0
A(i,j) = A(i-1,j) se w(i) > j
A(i,j) = max[A(i-1,j), A(i-1,j-w(i)) + c(i)] se w(i) <= j.}

Cerchiamo di risolvere il problema con la forza bruta: calcolo tutte le combinazioni di oggetti con il relativo valore e poi scelgo quella combinazione che ha il valore maggiore (potrebbero esserci più di una combinazione con valore massimo).
I dati sono rappresentati da una lista i cui elementi hanno la seguente struttura:

(nome peso valore)

Supponiamo che la lista iniziale sia la seguente:

(setq k '((a 2 3) (b 3 4) (c 4 5) (d 5 6)))
;-> ((a 2 3) (b 3 4) (c 4 5) (d 5 6))

Definiamo tre funzioni che estraggono le liste dei nomi, dei pesi e dei valori:

(define (getNomi lst) (map (fn(x) (first x)) lst))
(define (getPesi lst) (map (fn(x) (first (rest x))) lst))
(define (getValori lst) (map (fn(x) (last x)) lst))

(setq nomi (getNomi k))
;-> (a b c d)
(setq pesi (getPesi k))
;-> (2 3 4 5)
(setq valori (getValori k))
;-> (3 4 5 6)

Questa è la funzione per generare le combinazioni:

(define (combinazioni k nlst)
  (cond ((zero? k)     '(()))
        ((null? nlst)  '())
        (true
          (append (map (lambda (k-1) (cons (first nlst) k-1))
                       (combinazioni (- k 1) (rest nlst)))
                  (combinazioni k (rest nlst))))))

(combinazioni 2 '(3 4 5 6))
;-> ((3 4) (3 5) (3 6) (4 5) (4 6) (5 6))

Dobbiamo generare le combinazioni (dei valori) relative a tutte le possibili liste (quindi quelle di qualunque lunghezza):

(setq allv '())
(for (i 1 (length valori))
  (extend allv (combinazioni i valori))
)
;-> ((3) (4) (5) (6) (3 4) (3 5) (3 6) (4 5) (4 6) (5 6) (3 4 5) (3 4 6) (3 5 6)
;->  (4 5 6) (3 4 5 6))

Notare che il numero di combinazioni da cansiderare vale (2^elementi + 1).
Ad esempio con 22 elementi dobbiamo considerare (pow 2 22) = 4194304 combinazioni.

Adesso dobbiamo calcolare la somma dei valori di ogni sottolista (peso):

(setq sumv (map (fn (x) (apply + x)) allv))
;-> (3 4 5 6 7 8 9 9 10 11 12 13 14 15 18)

Cerchiamo il valore massimo
(setq valmax (apply max sumvOK))
;-> 10

Adesso dobbiamo eliminare tutti i valori che sono superiori al peso massimo W:
(setq W 10)

(setq sumvOK (map (fn(x) (if (> x W) 0 x)) sumv))
;-> (3 4 5 6 7 8 9 9 10 0 0 0 0 0 0)

Troviamo gli indici dei valori che hanno valore massimo (10):
(setq sol-idx (flat (ref-all 10 sumvOK)))
;-> (8)

Adesso cerchiamo i valori che concorrono a creare il valore massimo:
(setq val-max '())
(dolist (el sol-idx)
  (push (allv el) val-max -1)
)
;-> ((4 6))

Troviamo gli indici degli elementi che hanno valore 4 e 6:

(setq ele-idx '())
(dolist (el val-max)
  (setq item '())
  (dolist (x el)
    (setq vv (ref x valori))
    (push (list (nomi vv) (valori vv)) item -1)
  )
  (push item ele-idx -1)
)
;-> (((b 4) (d 6)))

Finalmente abbiamo trovato la soluzione.

Come abbiamo anticipato, si può trovare la soluzione calcolando A(n,W). Per farlo in modo efficiente si può usare una tabella che memorizza i calcoli fatti precedentemente (memoization o programmazione dinamica). Questa soluzione impiegherà quindi un tempo proporzionale a O(nW)} e uno spazio anch'esso proporzionale a O(nW).

(define (knapsack C items)
  (define (getNomi lst) (map (fn(x) (first x)) lst))
  (define (getPesi lst) (map (fn(x) (first (rest x))) lst))
  (define (getValori lst) (map (fn(x) (last x)) lst))
  (local (table x name weight val cp n nome peso valore)
    ;creazione i vettori dei dati
    (setq n (length items))
    (setq name (getNomi items))
    (setq weight (getPesi items))
    (setq val (getValori items))
    (setq table (array (add n 1) (add C 1) '(0)))
    ;(for (i 0 (sub n 1)) (setf (table i 0) 0))
    ;(for (j 0 (sub n 1)) (setf (table 0 j) 0))
    (for (i 1 n)
      (for (cp 1 C)
        (if (<= (weight (sub i 1)) cp)
            (begin
              ;(println (weight (sub i 1)) { } (val (sub i 1)))
              (setq x (sub cp (weight (sub i 1))))
              (setf (table i cp) (max (add (val (sub i 1)) (table (sub i 1) x))
                                      (table (sub i 1) cp)))
            )
        ;else
            (begin
              (setf (table i cp)  (table (sub i 1) cp))
            )
        )
      )
    )
    ;(println (table n C))
    ; Selezione elementi della soluzione
    (setq res '())
    (setq cp C)
    (setq ptot 0)
    (setq vtot 0)
    (for (i n 1 -1)
      (setq aggiunto (!= (table i cp) (table (sub i 1) cp)))
      (if aggiunto
        (begin
           (setq nome (name (sub i 1)))
           (setq peso (weight (sub i 1)))
           (setq valore (val (sub i 1)))
           (push (list nome peso valore) res)
           (setq ptot (add ptot peso))
           (setq vtot (add vtot valore))
           (setq cp (sub cp peso))
        )
      )
    )
    (println "Valore: " vtot { } "Peso: " ptot)
    res
  )
)

(setq item '((maps 9 150) (compass 13 35) (water 153 200) (sandwich 50 160)
             (glucose 15 60) (tin 68 45) (banana 27 60) (apple 39 40)
             (cheese 23 30) (beer 52 10) (suntan-cream 11 70) (camera 32 30)
             (T-shirt 24 15) (trousers 48 10) (umbrella 73 40)
             (waterproof-trousers 42 70) (waterproof-overclothes 43 75)
             (note-case 22 80) (sunglasses 7 20) (towel 18 12) (socks 4 50)
             (book 30 10)
            ))

(knapsack 400 items)
;-> Valore: 1030 Peso: 396
;-> ((maps 9 150) (compass 13 35) (water 153 200) (sandwich 50 160) (glucose 15 60)
;->  (banana 27 60) (suntan-cream 11 70) (waterproof-trousers 42 70) (waterproof-overclothes 43 75)
;->  (note-case 22 80) (sunglasses 7 20) (socks 4 50))


----------------------
GIORNO DELLA SETTIMANA
----------------------

Dato anno, mese e giorno, determinare il giorno della settimana.
Esistono diversi algoritmi per risolvere questo problema.

La prima funzione utilizza la regola di Zeller per calcolare il giorno della settimana nel calendario gregoriano prolettico (Domenica = 0)

(define (dayZ year month day)
  (local (adjust mm yy d)
    (setq adjust (/ (- 14 month) 12))
    (setq mm (+ month (* 12 adjust) (- 2)))
    (setq yy (- year adjust))
    (setq d (% (+ day (/ (- (* 13 mm) 1) 5) yy (/ yy 4) (- (/ yy 100)) (/ yy 400)) 7))
  )
)

(dayZ 2019 6 2)
;-> 0

La seconda funzione usa l'algoritmo di Gauss per determinare il giorno della settimana.
Questo metodo vale per il calendario gregoriano.
La funzione seguente è presa dal sito di newLISP (Lutz Mueller).

(define (dayG year month day) ; 0..6 --> Domenica..Sabato
    (letn ( d day
            m (+ (% (- month 3) 12) 1)
            Y (if (> m 10) (- year 1) year)
            y (% Y 100)
            c (/ (- Y y) 100)
            w (add d (floor (sub (mul 2.6 m) 0.2)) y (floor (div y 4)) (floor (div c 4)) (- (mul c 2)))
            w (% w 7)
          )
       (if (< w 0) (inc w 7) w))
)

(dayG 2019 6 2)
;-> 0

La terza funzione usa l'algoritmo di Tomohiko Sakamoto. Anche questo metodo vale per il calendario gregoriano.

Vediamo come funziona l'algoritmo.
Il 1 gennaio dell'anno 1 D.C. è un lunedì nel calendario gregoriano.
Prendiamo in considerazione il primo caso in cui non abbiamo anni bisestili, quindi il numero totale di giorni in ogni anno è 365. Gennaio ha 31 giorni cioè 7*4+3 giorni, quindi il giorno del 1° febbraio sarà sempre 3 giorni prima della giornata del 1° gennaio. Ora febbraio ha 28 giorni (esclusi gli anni bisestili) che è il multiplo esatto di 7 (7 * 4 = 28) Quindi non ci saranno cambiamenti nel mese di marzo e sarà anche 3 giorni prima del giorno del 1° gennaio dell'anno rispettivo. Considerando questo modello, se creiamo un vettore del numero iniziale di giorni per ogni mese, avremo: t = (0, 3, 3, 6, 1, 4, 6, 2, 5, 0, 3, 5).
Ora diamo un'occhiata al caso reale quando ci sono anni bisestili. Ogni 4 anni, il nostro calcolo guadagnerà un giorno in più. Tranne ogni 100 anni quando non lo guadagna. Tranne ogni 400 anni quando lo guadagna. Come inseriamo questi giorni aggiuntivi? Basta aggiungere y / 4 - y / 100 + y / 400. Si noti che tutta la divisione è una divisione intera. Questo aggiunge esattamente il numero richiesto di giorni bisestili. Ma qui c'è un problema, il giorno bisestile è il 29 febbraio e non il 0 gennaio. Ciò significa che l'anno corrente non deve essere conteggiato per il calcolo del giorno bisestile per i primi due mesi. Supponiamo che se il mese fosse gennaio o febbraio, abbiamo sottratto 1 dall'anno. Ciò significa che durante questi mesi, il valore y/4 sarà quello dell'anno precedente e non verrà conteggiato. Se sottraiamo 1 dai valori t[] di ogni mese dopo febbraio? Ciò riempirebbe il vuoto e il problema degli anni bisestili verrà risolto. In altre parole, dobbiamo apportare le seguenti modifiche:
1. t[] diventa (0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4).
2. se m corrisponde a Gen/Feb (ovvero, i mesi < 3) diminuiamo y di 1.
3. l'incremento annuo all'interno del modulo è ora y + y/4 - y/100 + y/400 al posto di y.

Adesso possiamo scrivere la funzione:

(define (dayT year month day) ; 0..6 --> Domenica..Sabato
  (local (t d)
    (setq t '(0 3 2 5 0 3 5 1 4 6 2 4))
    (if (< month 3) (-- year))
    (setq d (% (add year (/ year 4) (/ (- year) 100) (/ year 400) (t (- month 1)) day) 7))
  )
)

(dayT 2019 6 2)
;-> 0

(dayZ 2017 7 13) ;-> 4
(dayG 2017 7 13) ;-> 4
(dayT 2017 7 13) ;-> 4

(dayZ 2012 8 15) ;-> 3
(dayG 2012 8 15) ;-> 3
(dayT 2012 8 15) ;-> 3

(dayZ 2456 12 24) ;-> 0
(dayG 2456 12 24) ;-> 0
(dayT 2456 12 24) ;-> 0


-------------------
TRIANGOLO DI PASCAL
-------------------

Il triangolo di Pascal (o di Tartaglia) è una matrice triangolare formata dai coefficienti binomiali (ossia dai coefficienti dello sviluppo del binomio (a + b) elevato ad una qualsiasi potenza n - Esempio: (a + b)^2 = 1*a^2 + 2*a*b + 1*b^2).

Ecco un triangolo con 9 linee, in cui le righe e le colonne sono state numerate (a base zero):

         colonne
         0  1  2  3  4  5  6  7  8
righe
    0    1  0  0  0  0  0  0  0  0
    1    1  1  0  0  0  0  0  0  0
    2    1  2  1  0  0  0  0  0  0
    3    1  3  3  1  0  0  0  0  0
    4    1  4  6  4  1  0  0  0  0
    5    1  5 10 10  5  1  0  0  0
    6    1  6 15 20 15  6  1  0  0
    7    1  7 21 35 35 21  7  1  0
    8    1  8 28 56 70 56 28  8  1

dove ogni elemento della matrice vale: matrice[riga][colonna] = binomiale[n, k]

Tutte le righe iniziano e terminano con il numero 1.

Ogni riga ha un elemento in più rispetto al suo predecessore.

Definiamo una funzione che calcola il triangolo di Pascal utilizzando i coeffiecienti binomiali.
La prima funzione permette di calcolare il coefficiente binomiale di n,k.

(define (binomiale n k)
  (local (M q)
    (setq M (array (+ n 1) (+ k 1) '(0)))
    (for (i 0 n)
      (setq q (min i k))
      (for (j 0 q)
        (if (or (= j 0) (= j i))
          (setq (M i j) 1)
          (setq (M i j) (+ (M (- i 1) (- j 1)) (M (- i 1) j)))
        )
      )
    )
    (M n k)
  );local
)

(binomiale 5 0)
;-> 1
(binomiale 5 3)
;-> 10

Poi definiamo la funzione che crea il triangolo di Pascal:

(define (pascal n)
  (local (P)
    (setq P (array n n '(0)))
    (for (riga 0 (- n 1))
      (for (i 0 riga)
        (setf (P riga i) (binomiale riga i))
      )
    )
    ; disabilitare la seguente istruzione per calcolare la velocità
    (print-matrix P)
  )
)

Definiamo la funzione che stampa la matrice:

(define (print-matrix matrix)
  (local (row col nmax nmin digit fmtstr)
    ; converto matrice in lista ?
    (if (array? matrix) (setq matrix  (array-list matrix)))
    ; righe della matrice
    (setq row (length matrix))
    ; colonne della matrice (da rivedere)
    (setq col (length (first matrix)))
    ; valore massimo
    (setq nmax (string (apply max (flat matrix))))
    ; valore minimo
    (setq nmin (string (apply min (flat matrix))))
    ; calcolo spazio per i numeri
    (setq digit (add 1 (max (length nmax) (length nmin))))
    ; creo stringa di formattazione
    (setq fmtstr (append "%" (string digit) "d"))
    ; stampa
    (for (i 0 (sub row 1))
      (for (j 0 (sub col 1))
        (print (format fmtstr (matrix i j)))
      )
      (println)
    )
  )
)

(pascal 9)
;-> 1  0  0  0  0  0  0  0  0
;-> 1  1  0  0  0  0  0  0  0
;-> 1  2  1  0  0  0  0  0  0
;-> 1  3  3  1  0  0  0  0  0
;-> 1  4  6  4  1  0  0  0  0
;-> 1  5 10 10  5  1  0  0  0
;-> 1  6 15 20 15  6  1  0  0
;-> 1  7 21 35 35 21  7  1  0
;-> 1  8 28 56 70 56 28  8  1

Il matematico tedesco Stifel ha scoperto che gli elementi del triangolo di Pascal hanno la seguente proprietà (nota come Relazione di Stifel):

Se col = 0 o row = col,
  P(row,col) = 1

Se row >= col,
  P(row,col) = P(row-1,col) + P(row-1,col-1)

dove (row >= 0) e (col >= 0)

Quindi possiamo definire una nuova funzione per calcolare il triangolo di Pascal utilizzando la relazione di Stifel:

(define (pascalS n)
  (local (P)
    (setq P (array n n '(0L)))
    (for (row 0 (- n 1))
      (for (col 0 row)
        (if (or (= col 0) (= row col))
            (setf (P row col) 1L)
            (setf (P row col) (+ (bigint (P (- row 1) col)) (bigint  (P (- row 1) (- col 1)))))
        )
      )
    )
    ; disabilitare la seguente istruzione per calcolare la velocità
    (print-matrix P)
  );local
)

(pascalS 9)
;-> 1  0  0  0  0  0  0  0  0
;-> 1  1  0  0  0  0  0  0  0
;-> 1  2  1  0  0  0  0  0  0
;-> 1  3  3  1  0  0  0  0  0
;-> 1  4  6  4  1  0  0  0  0
;-> 1  5 10 10  5  1  0  0  0
;-> 1  6 15 20 15  6  1  0  0
;-> 1  7 21 35 35 21  7  1  0
;-> 1  8 28 56 70 56 28  8  1

(pascalS 14)
;-> 1    0    0    0    0    0    0    0    0    0    0    0    0    0
;-> 1    1    0    0    0    0    0    0    0    0    0    0    0    0
;-> 1    2    1    0    0    0    0    0    0    0    0    0    0    0
;-> 1    3    3    1    0    0    0    0    0    0    0    0    0    0
;-> 1    4    6    4    1    0    0    0    0    0    0    0    0    0
;-> 1    5   10   10    5    1    0    0    0    0    0    0    0    0
;-> 1    6   15   20   15    6    1    0    0    0    0    0    0    0
;-> 1    7   21   35   35   21    7    1    0    0    0    0    0    0
;-> 1    8   28   56   70   56   28    8    1    0    0    0    0    0
;-> 1    9   36   84  126  126   84   36    9    1    0    0    0    0
;-> 1   10   45  120  210  252  210  120   45   10    1    0    0    0
;-> 1   11   55  165  330  462  462  330  165   55   11    1    0    0
;-> 1   12   66  220  495  792  924  792  495  220   66   12    1    0
;-> 1   13   78  286  715 1287 1716 1716 1287  715  286   78   13    1

Per vedere quale funzione è più veloce commentiamo nelle due funzioni la riga che contiene l'istruzione per stampare la matrice:

; (print-matrix P)


(time (pascal 30) 100)
;-> 2914.029

(time (pascalS 30) 100)
;-> 34.966

La seconda funzione è velocissima perchè non calcola tutti i coefficienti binomiali, ma riempie la matrice ricorsivamente con una relazione matematica.

Per finire vediamo come calcolare la riga n-esima del triangolo di Pascal (valida anche per i big integer):

(define (pascaln n)
  (local (out)
    (setq out '(1L))
    (for (k 0 (- n 1))
      (push (/ (* (out k) (- n k)) (+ k 1)) out -1)
    )
    out
  )
)

(pascaln 9)
;-> (1L 9L 36L 84L 126L 126L 84L 36L 9L 1L)

(pascaln 20)
;-> (1L 20L 190L 1140L 4845L 15504L 38760L 77520L 125970L 167960L 184756L 167960L 125970L
;->  77520L 38760L 15504L 4845L 1140L 190L 20L 1L)

Questa funzione sfrutta la seguente identità matemetica sulle combinazioni:

C(n, k+1) = C(n,k) * (n-k) / (k+1)

Quindi iniziamo con C(n, 0) = 1 e poi calcoliamo il resto della riga usando questa identità, cioè moltiplichiamo ogni volta l'elemento precedente per (n-k)/(k+1).
Ricordiamo che il coefficiente binomiale rappresenta il numero di scelte di k elementi tra quelli di un insieme di n elementi (numero di combinazioni semplici).


------------
CODICE MORSE
------------

Il codice Morse è un metodo per trasmettere informazioni, utilizzando sequenze standardizzate di brevi e lunghi segni o impulsi, comunemente noti come punti e linee ("dot and dashes"), per le lettere, i numeri e i caratteri speciali di un messaggio.
Originariamente creato per il telegrafo elettrico di Samuel Morse verso la metà del 1830, fu anche ampiamente utilizzato per le prime comunicazioni radio a partire dal 1890.

Rappresentazione del codice

A  • −         N  − •         0  − − − − −     .  • − • − • −
B  − • • •     O  − − −       1  • − − − −     ,  − − • • − −
C  − • − •     P  • − − •     2  • • − − −     :  − − − • • •
D  − • •       Q  − − • −     3  • • • − −     ?  • • − − • •
E  •           R  • − •       4  • • • • −     =  − • • • −
F  • • − •     S  • • •       5  • • • • •     -  − • • • • −
G  − − •       T  −           6  − • • • •     (  − • − − •
H  • • • •     U  • • −       7  − − • • •     )  − • − − • −
I  • •         V  • • • −     8  − − − • •    {"} • − • • − •
J  • − − −     W  • − −       9  − − − − •     '  • − − − − •
K  − • −       X  − • • −                      /  − • • − •
L  • − • •     Y  − • − −                      @  • − − • − •
M  − −         Z  − − • •                      !  − • − • − −
                                               " "  "       "

Il codice Morse internazionale è composto da 5 elementi:

1) Impulso breve, punto (dot o "dit"): "dot duration" vale una unità di tempo
2) Impulso lungo, linea (dash o "dah"): "dash duration" vale tre unità di tempo
3) Intervallo di divisione tra dot e dash di un carattere: vale una unità di tempo
4) Intervallo breve (tra le lettere): vale tre unità di tempo
5) Intervallo lungo (tra le parole): vale sette unità di tempo

Il codice Morse viene trasmesso come un codice digitale usando solo due stati (acceso e spento). Il codice Morse può essere rappresentato come un codice binario: 1 acceso e 0 spento. Quindi una sequenza di codice Morse è costituita da una combinazione delle seguenti cinque stringhe di bit:

1) Impulso breve, punto (dot o "dit"): "dot duration" 1
2) Impulso lungo, linea (dash o "dah"): "dash duration" 111
3) Intervallo di divisione tra dot e dash di un carattere: 0
4) Intervallo breve (tra le lettere): 000
5) Intervallo lungo (tra le parole): 0000000

Notare che gli impulsi e gli intervalli (zeri) sono alternati: punti e linee sono sempre separati da uno degli intervalli vuoti e che gli intervalli sono sempre separati da un punto o da una linea.

In termini di spazio invece che di tempo, abbiamo:

1) Un punto (dot) occupa uno spazio "."
2) Una linea (dash) occupa 3 spazi "---"
3) Le parti di ogni lettera sono separate da uno spazio " "
4) Tra due lettere intercorrono 3 spazi. "   "
5) Tra due parole intercorrono 7 spazi.  "       "

Per scrivere le funzioni di conversione abbiamo bisogno di creare due liste di associazione:

; Lista di associazione carattere --> codice morse
(setq alfa-morse '(
("A"  ". -")
("B"  "- . . .")
("C"  "- . - .")
("D"  "- . .")
("E"  ".")
("F"  ". . - .")
("G"  "- - .")
("H"  ". . . .")
("I"  ". .")
("J"  ". - - -")
("K"  "- . -")
("L"  ". - . .")
("M"  "- -")
("N"  "- .")
("O"  "- - -")
("P"  ". - - .")
("Q"  "- - . -")
("R"  ". - .")
("S"  ". . .")
("T"  "-")
("U"  ". . -")
("V"  ". . . -")
("W"  ". - -")
("X"  "- . . -")
("Y"  "- . - -")
("Z"  "- - . .")
("0"  "- - - - -")
("1"  ". - - - -")
("2"  ". . - - -")
("3"  ". . . - -")
("4"  ". . . . -")
("5"  ". . . . .")
("6"  "- . . . .")
("7"  "- - . . .")
("8"  "- - - . .")
("9"  "- - - - .")
("."  ". - . - . -")
(","  "- - . . - -")
(":"  "- - - . . .")
("?"  ". . - - . .")
("="  "- . . . -")
("-"  "- . . . . -")
("("  "- . - - .")
(")"  "- . - - . -")
("\""  ". - . . - .")
("'"  ". - - - - .")
("/"  "- . . - .")
("@"  ". - - . - .")
("!"  "- . - . - -")
(" "  "       ")))

Sottolineato  ". . - - . -"
. - . . - .
; Lista di associazione codice morse --> carattere
(setq morse-alfa (map (fn (n) (list (last n) (first n))) alfa-morse))

(lookup "A" alfa-morse)
;-> ". -"
(lookup "−" morse-alfa)
;-> "T"

Adesso possiamo scrivere la funzione che converte un messaggio di testo in una lista di codici morse:

(define (morse2alfa msg)
  (let (out '())
    (dolist (ch (explode msg))
      (if (lookup ch alfa-morse)
          (push (lookup ch alfa-morse) out -1)
          (push "$$$" out -1)
          ;(print (lookup ch alfa-morse){   })
          ;(print "$$$"{   })
      )
    )
    out
  )
)

(setq msg "Testo da tradurre.")
; conversione del messaggio in lettere maiuscole
(setq msg (upper-case msg))

(morse2alfa msg)
;-> ("-" "." ". . ." "-" "- - -" "       " "- . ." ". -" "       " "-" ". - ." ". -"
;->  "- . ." ". . -" ". - ." ". - ." "." ". - . - . -")

Definiamo la funzione inversa che converte da una lista di codici morse ad una lista di caratteri:

(define (alfa2morse msg)
  (let (out '())
    (dolist (ch msg)
      (if (lookup ch morse-alfa)
          (push (lookup ch morse-alfa) out -1)
          (push "$$$" out -1)
      )
    )
    out
  )
)

(join (alfa2morse (morse2alfa msg)))
;-> "TESTO DA TRADURRE."

(setq msg {Testo "da tradurre})
(setq msg (upper-case msg))
(println (join (alfa2morse (morse2alfa msg))))
;-> "TESTO \"DA TRADURRE"
(println (join (alfa2morse (morse2alfa msg))))
;-> TESTO "DA TRADURRE


-------------------
PROBLEMA DI BABBAGE
-------------------

Qual è il più piccolo intero positivo il cui quadrato termina con le cifre 269.696?
Lettera di Charles Babbage a Lord Bowden, 1837.

Notiamo che solo i numeri che terminano con 4 o 6 posoono produrre un quadrato che ha il numero 6 come ultima cifra.

Inoltre risulta:

(sqrt 269696)
;-> 519.3226357477594

quindi qualsiasi numero inferiore a 520 produce un quadrato più piccolo di 269.696.
Allora, il numero più piccolo da provare vale 574.

(define (babbage)
  (catch
    (local (num quadrato)
      (setq num 524)
      (setq quadrato (* num num))
      (while true
        ; eleva il numero al quadrato
        (setq quadrato (* num num))
        ; controlla se è il numero cercato
        (if (= (slice (string quadrato) -6 6) "269696")
          ; numero trovato
          (throw (list num quadrato))
        )
        ; aumenta in numero di 2
        ; adesso il numero termina con la cifra 6
        (setq num (+ num 2))
        ; eleva il numero al quadrato
        (setq quadrato (* num num))
        ; controlla se è il numero cercato
        (if (= (slice (string quadrato) -6 6) "269696")
          ; numero trovato
          (throw (list num quadrato))
        )
        ; aumenta in numero di 8
        ; adesso il numero termina con la cifra 4
        (setq num (+ num 8))
      );while
    );local
  );catch
)

(babbage)
;-> (25264 638269696)

(time (babbage))
;-> 15.627


------------------
CIFRARIO DI CESARE
------------------

Il cifrario di Cesare è uno dei più antichi algoritmi crittografici conosciuti. È un cifrario a sostituzione monoalfabetica in cui ogni lettera del messaggio in chiaro è sostituita nel messaggio cifrato dalla lettera che si trova un certo numero di posizioni dopo (o prima) nell'alfabeto. La sostituzione avviene lettera per lettera, analizzando il testo dall'inizio alla fine.
Il cifrario prende il nome da Giulio Cesare, che lo utilizzava per proteggere i suoi messaggi segreti. Cesare utilizzava in genere una chiave di 3 per il cifrario. A quel tempo il metodo era sicuro perché la maggior parte della gente spesso non era neanche in grado di leggere.

Definiamo il nostro alfabeto:
(setq alfa (explode "ABCDEFGHIJKLMNOPQRSTUVWXYZ"))
;-> ("A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O" "P" "Q" "R" "S" "T" "U" "V" "W" "X" "Y" "Z")

Definiamo l'alfabeto di partenza:
(setq s1 alfa)
;-> ("A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O" "P" "Q" "R" "S" "T" "U" "V" "W" "X" "Y" "Z")

Definiamo l'alfabeto di arrivo (con chiave 3):
(setq s2 (rotate (copy alfa) -3))
;-> ("D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O" "P" "Q" "R" "S" "T" "U" "V" "W" "X" "Y" "Z" "A" "B" "C")

Creiamo la lista di associazione tra le lettere in chiaro e le lettere cifrate:

(setq codice (transpose (list s1 s2)))
;-> (("A" "D") ("B" "E") ("C" "F") ("D" "G") ("E" "H") ("F" "I") ("G" "J")
;->  ("H" "K") ("I" "L") ("J" "M") ("K" "N") ("L" "O") ("M" "P") ("N" "Q")
;->  ("O" "R") ("P" "S") ("Q" "T") ("R" "U") ("S" "V") ("T" "W") ("U" "X")
;->  ("V" "Y") ("W" "Z") ("X" "A") ("Y" "B") ("Z" "C"))

Creiamo la lista di associazione tra le lettere cifrate e le lettere in chiaro:

(setq anticodice (transpose (list s2 s1)))
;-> (("D" "A") ("E" "B") ("F" "C") ("G" "D") ("H" "E") ("I" "F") ("J" "G")
;->  ("K" "H") ("L" "I") ("M" "J") ("N" "K") ("O" "L") ("P" "M") ("Q" "N")
;->  ("R" "O") ("S" "P") ("T" "Q") ("U" "R") ("V" "S") ("W" "T") ("X" "U")
;->  ("Y" "V") ("Z" "W") ("A" "X") ("B" "Y") ("C" "Z"))

Funzione di conversione da chiaro a cirato:

(define (chiaro-cifrato msg)
  (let (out '())
    (dolist (ch (explode (upper-case msg)))
      (if (lookup ch codice)
          (push (lookup ch codice) out -1)
          (push "$" out -1)
      )
    )
    (join out)
  )
)

(setq msg "Testo da tradurre")

(chiaro-cifrato msg)
;-> "WHVWR$GD$WUDGXUUH"

Funzione di conversione da cifrato a chiaro:

(define (cifrato-chiaro msg)
  (let (out '())
    (dolist (ch (explode (upper-case msg)))
      (if (lookup ch anticodice)
          (push (lookup ch anticodice) out -1)
          (push "$" out -1)
      )
    )
    (join out)
  )
)

(cifrato-chiaro "WHVWR$GD$WUDGXUUH")
;-> "TESTO$DA$TRADURRE"

Scriviamo una funzione generica che codifica e decodifica ed ha come parametro la chiave (numero):

(define (cesare msg tipo key)
  (local (s1 s2 codice anticodice)
    (setq out '())
    (setq s1 (explode "ABCDEFGHIJKLMNOPQRSTUVWXYZ"))
    (setq s2 (rotate (copy s1) (- key)))
    (setq codice (transpose (list s1 s2)))
    (setq anticodice (transpose (list s2 s1)))
    (cond ((= tipo 0)
           (dolist (ch (explode (upper-case msg)))
              (if (lookup ch codice)
                  (push (lookup ch codice) out -1)
                  (push "$" out -1)
              )
           ))
          ((= tipo 1)
           (dolist (ch (explode (upper-case msg)))
              (if (lookup ch anticodice)
                  (push (lookup ch anticodice) out -1)
                  (push "$" out -1)
              )
           ))
          (true (println "tipo: 0 -> cifra, 1 -> decifra"))
    );cond
    (join out)
  ); local
)

(cesare "TESTO DA TRADURRE" 0 3)
;-> "WHVWR$GD$WUDGXUUH"

(cesare "WHVWR$GD$WUDGXUUH" 1 3)
;-> "TESTO$DA$TRADURRE"

(cesare "newLISP is great" 0 6)
;-> "TKCROYV$OY$MXKGZ"

(cesare "TKCROYV$OY$MXKGZ" 1 6)
;-> "newLISP$IS$GREAT"

(cesare "newLISP is great" 2 6)
;-> tipo: 0 -> cifra, 1 -> decifra


--------------------
CIFRARIO DI VIGENERE
--------------------

Il cifrario di Vigenère è il più semplice dei cifrari polialfabetici. Il metodo è una generalizzazione del cifrario di Cesare: invece di spostare la lettera da cifrare di un numero fisso di posti, questa viene spostata di un numero di posti variabile, determinato in base ad una parola chiave, che deve essere conosciuta sia dal mittente che dal destinatario. La chiave (detta anche "verme") deve essere ripetuta per tutta la lunghezza del messaggio.
Per esempio:

Testo in chiaro: RICERCARETESORO
Verme          : VERMEVERMEVERMEVE
Testo cifrato  : MMTQVXEIQXZWFDS

Il testo cifrato si ottiene spostando la lettera chiara di un numero fisso di caratteri, pari al numero ordinale della lettera corrispondente del verme. Di fatto si esegue una somma aritmetica tra l'ordinale dei caratteri in chiaro (A = 0, B = 1, C = 2...) e quello del verme. Superando l'ultima lettera, Z, si ricomincia dalla A, secondo la logica delle aritmetiche modulari.

Il vantaggio rispetto ai cifrari monoalfabetici (come il cifrario di Cesare) è dovuto al fatto che il testo è cifrato con n alfabeti cifranti. In questo modo, la stessa lettera viene cifrata (se ripetuta consecutivamente) n volte e questo rende più complessa la crittoanalisi del testo.

Possiamo usare una funzione matematica per la cifratura e la decifratura:

L = Lunghezza del cifrario = Numero caratteri alfabeto (26)

Numero prima lettera del cifrario "A" = 0

Numero ultima lettera del cifrario "Z" = 25

a = Numero della lettera della parola in Chiaro (0-25)

b = Numero della lettera della parola Chiave/Verme (0-25)

c = Numero della lettera della parola Cifrata (0-25)

Formula per cifrare/criptare: n = a + b (mod L)

Formula per decifrare/decriptare: n = c - b + L

r = floor(n / L)

x = n - ( L * r ) = Numero della lettera della parola in Chiaro/Cifrata (0-25)

La funzione si basa sulla somma/sottrazione dei numeri delle lettere e sulla divisione per la lunghezza del cifrario per ottenere il numero della lettera cercata. Per avere sempre un numero n positivo (anche per la decriptazione) basta aggiungere la lunghezza del cifrario L, in quanto verrà poi eliminata grazie al metodo con cui calcoliamo r.

Esempio di criptazione per il carattere "R":

L = 26
a[R] = 17
b[V] = 21
n = 17 + 21 = 38
r = 38 / 26 = 1,461... = 1
x = 38 - ( 26 * 1 ) = 38 - 26 = 12
lettera(12) = M

Esempio di decriptazione per il carattere "M":

L = 26
b[V] = 21
c[M] = 12
n = 12 - 21 + 26 = 17
r = 17 / 26 = 0,653... = 0
x = 17 - ( 26 * 0 ) = 17 - 0 = 17
lettera(17) = R

; messaggio in chiaro
(setq msg "RICERCARETESORO")
; costruzione il cifrario
(setq cifrario "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
;-> "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
(setq lettere (explode cifrario))
;-> ("A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M"
;->  "N" "O" "P" "Q" "R" "S" "T" "U" "V" "W" "X" "Y" "Z")
; liste di associazione lettera <--> numero
(setq char-num (map (fn (x) (list x $idx)) (explode cifrario)))
;-> (("A" 0) ("B" 1) ("C" 2) ("D" 3) ("E" 4) ("F" 5) ("G" 6)
;->  ("H" 7) ("I" 8) ("J" 9) ("K" 10) ("L" 11) ("M" 12) ("N" 13)
;->  ("O" 14) ("P" 15) ("Q" 16) ("R" 17) ("S" 18) ("T" 19) ("U" 20)
;->  ("V" 21) ("W" 22) ("X" 23) ("Y" 24) ("Z" 25))
(setq num-char (map (fn (x) (list $idx x)) (explode cifrario)))
;-> ((0 "A") (1 "B") (2 "C") (3 "D") (4 "E") (5 "F") (6 "G") (7 "H")
;->  (8 "I") (9 "J") (10 "K") (11 "L") (12 "M") (13 "N") (14 "O")
;->  (15 "P") (16 "Q") (17 "R") (18 "S") (19 "T") (20 "U") (21 "V")
;->  (22 "W") (23 "X") (24 "Y") (25 "Z"))
; la chiave è il valore del verme ripetuto per tutta la lunghezza del messaggio
(setq chiave (slice (dup verme (+ (/ (length msg) (length verme)) 1)) 0 (length msg) 1))
;-> "VERMEVERMEVERME"
(setq L (length cifrario))
;-> 26

cifratura:

(dolist (el (explode msg))
  (setq a (lookup el char-num))
  (setq b (lookup (chiave $idx) char-num))
  ;(println a { } b)
  (setq n (% (+ a b) L))
  (setq r (/ n L))
  (setq x (- n (* L r)))
  ;(println n { } r { } x)
  (print (lookup x num-char))
)
;-> MMTQVXEIQXZWFDS

Adesso scriviamo le due funzioni di cifratura/decifratura tenendo conto dei caratteri del messaggio che non si trovano nel cifrario (alfabeto). Inoltre aggiungiamo uno spazio " " al nostro alfabeto.

Funzione di cifratura:

(define (vige-cifra msg verme)
  (local (cifrario lettere char-num num-char chiave L out)
    (setq out '())
    (setq msg (upper-case msg))
    (setq verme (upper-case verme))
    ; costruzione del cifrario
    (setq cifrario "ABCDEFGHIJKLMNOPQRSTUVWXYZ ")
    (setq lettere (explode cifrario))
    ; liste di associazione lettera <--> numero
    (setq char-num (map (fn (x) (list x $idx)) (explode cifrario)))
    (setq num-char (map (fn (x) (list $idx x)) (explode cifrario)))
    ; la chiave è il valore del verme ripetuto per tutta la lunghezza del messaggio
    (setq chiave (slice (dup verme (+ (/ (length msg) (length verme)) 1)) 0 (length msg) 1))
    (setq L (length cifrario))
    ; ciclo di cifratura del messaggio
    (dolist (el (explode msg))
      ; controllo caratteri sconosciuti
      (cond ((or (nil? (lookup el char-num)) (nil? (lookup (chiave $idx) char-num)))
             (push "$" out -1)
            )
            (true
              (setq a (lookup el char-num))
              (setq b (lookup (chiave $idx) char-num))
              ;(println a { } b)
              (setq n (% (+ a b) L))
              (setq r (/ n L))
              (setq x (- n (* L r)))
              ;(println n { } r { } x)
              ;(print (lookup x num-char))
              (push (lookup x num-char) out -1)
            )
      );cond
    );dolist
    (join out)
  );local
)

(setq msg "CIFRARIO DI VIGENERE")
(vige-cifra msg "VERME")
;-> "XMWCELMELHCDLUKZRVCI"

(define (vige-decifra msg verme)
  (local (cifrario lettere char-num num-char chiave L out)
    (setq out '())
    (setq msg (upper-case msg))
    (setq verme (upper-case verme))
    ; costruzione del cifrario
    (setq cifrario "ABCDEFGHIJKLMNOPQRSTUVWXYZ ")
    (setq lettere (explode cifrario))
    ; liste di associazione lettera <--> numero
    (setq char-num (map (fn (x) (list x $idx)) (explode cifrario)))
    (setq num-char (map (fn (x) (list $idx x)) (explode cifrario)))
    ; la chiave è il valore del verme ripetuto per tutta la lunghezza del messaggio
    (setq chiave (slice (dup verme (+ (/ (length msg) (length verme)) 1)) 0 (length msg) 1))
    (setq L (length cifrario))
    ; ciclo di cifratura del messaggio
    (dolist (el (explode msg))
      ; controllo caratteri sconosciuti
      (cond ((or (nil? (lookup el char-num)) (nil? (lookup (chiave $idx) char-num)))
             (push "$" out -1)
            )
            (true
              (setq c (lookup el char-num))
              (setq b (lookup (chiave $idx) char-num))
              ;(println c { } b)
              (setq n (+ (- c b) L))
              (setq r (/ n L))
              (setq x (- n (* L r)))
              ;(println n { } r { } x)
              ;(print (lookup x num-char))
              (push (lookup x num-char) out -1)
            )
      );cond
    );dolist
    (join out)
  );local
)

(setq msg "XMWCELMELHCDLUKZRVCI")
(vige-decifra msg "VERME")
;-> "CIFRARIO DI VIGENERE"


---------
ANAGRAMMI
---------

Quando due o più parole sono composte dagli stessi caratteri, ma in un ordine diverso, vengono chiamate anagrammi.
Usando l'elenco di parole: http://wiki.puzzlers.org/pub/wordlists/unixdict.txt trovare l'insieme di anagrammi che ha il maggior numero di parole (elementi).

Leggiamo tutto il file in una stringa:
(setq datafile (read-file "unixdict1.txt"))

Trasformiamo questa stringa in una lista di stringhe delimitate dal carattere di fine linea (eol - end of line). La funzione "parse" fa proprio questo, suddivide una stringa in sottostringhe basandosi su un delimitatore (in windows il delimitatore di fine linea è "\r\n", mentre su UNIX è "\n"):

(setq data (parse datafile "\r\n"))

Se volessi convertire le stringhe in simboli:
(setq data (map sym data))
;-> (10th 1st 2nd 3rd 4th 5th 6th 7th 8th 9th a a&m a&p a's aaa aaas aarhus aaron aau
;->  aba ababa aback abacus abalone abandon abase abash abate abater abbas abbe abbey
;->  abbot abbott abbreviate abc abdicate abdomen abdominal abduct abe abed abel abelian
;->  abelson aberdeen abernathy aberrant aberrate abet)

Creazione di una lista ordinata in cui ogni elemento è formato dalla parola ordinata e dalla parola di partenza:
(setq lst (sort (map (fn (x) (list (join (sort (explode x))) x)) data)))
;-> (("&am" "a&m") ("&ap" "a&p") ("'as" "a's") ("01ht" "10th")
;->  ("1st" "1st") ("2dn" "2nd") ("3dr" "3rd") ("4ht" "4th")
;->  ("5ht" "5th") ("6ht" "6th") ("7ht" "7th") ("8ht" "8th")
;->  ("9ht" "9th") ("a" "a") ("aaa" "aaa") ("aaabb" "ababa")
;->  .......

Scriviamo una funzione che utilizza un metodo molto simile al Run-Length Encoding: raggruppa le parole che hanno lo stesso anagramma:

(define (rle lst)
  (local (palo conta ana out)
    (cond ((= lst '()) '())
          (true
           (setq out '())
           (setq ana '())
           (setq palo (first (first lst)))
           (setq conta 0)
           (dolist (el lst)
              ; se l'elemento è uguale al precedente aumentiamo il suo conteggio
              ; e aggiungiamo l'anagramma alla lista degli anagrammi
              (if (= (first el) palo)
                  (begin (++ conta)
                         (push (last el) ana -1)
                  )
                  ; altrimenti costruiamo la lista (conta ana)
                  ; poi la aggiungiamo al risultato
                  ; e azzeriamo le variabili
                  (begin (push conta ana)
                         (push ana out -1)
                         (setq conta 1)
                         (setq palo (first el))
                         (setq ana (rest el))
                  )
              )
           )
           ; aggiungiamo l'ultima coppia di valori al risultato
           (push conta ana)
           (push ana out -1)
          )
    )
    out
  )
)

(rle lst)
;-> ((1 "a&m") (1 "a&p") (1 "a's") (1 "10th") (1 "1st") (1 "2nd") (1 "3rd")
;->  (1 "4th") (1 "5th") (1 "6th") (1 "7th") (1 "8th") (1 "9th") (1 "a") (1 "aaa")
;->  .....

Quindi la soluzione è la seguente:

  (silent (setq datafile (read-file "unixdict.txt")))
  (silent (setq data (parse datafile "\n")))
  (silent (setq lst (sort (map (fn (x) (list (join (sort (explode x))) x)) data))))
  (silent (rle lst))
  (slice (sort (rle lst) >) 0 10)

Scriviamo la funzione:

(define (solveAna)
  (setq datafile (read-file "unixdict.txt"))
  (setq data (parse datafile "\n"))
  (setq lst (sort (map (fn (x) (list (join (sort (explode x))) x)) data)))
  (rle lst)
  (slice (sort (rle lst) >) 0 10)
)

(solveAna)
;-> ((5 "evil" "levi" "live" "veil" "vile")
;->  (5 "elan" "lane" "lean" "lena" "neal")
;->  (5 "caret" "carte" "cater" "crate" "trace")
;->  (5 "angel" "angle" "galen" "glean" "lange")
;->  (5 "alger" "glare" "lager" "large" "regal")
;->  (5 "abel" "able" "bale" "bela" "elba")
;->  (4 "resin" "rinse" "risen" "siren")
;->  (4 "pare" "pear" "rape" "reap")
;->  (4 "nepal" "panel" "penal" "plane")
;->  (4 "mate" "meat" "tame" "team"))

(time (solveAna))
;-> 265.205 ;la funzione è molto veloce.

Usando il file "60000_parole_italiane.txt" otteniamo:

(solveAna)
;-> ((9 "avresti" "restavi" "stivare" "svitare" "versati"
;->     "vestira" "viraste" "vistare" "vistera")
;->  (8 "riavesti" "stiverai" "sviterai" "vestiari" "vestirai"
;->     "visitare" "visitera" "visterai")
;->  (8 "aperti" "aprite" "pareti" "patrie" "perita"
;->     "pietra" "rapite" "ripeta")
;->  (7 "cernite" "cretine" "incerte" "recenti" "recinte" "tenerci" "trincee")
;->  (7 "cavero" "covare" "covera" "creavo" "recavo" "revoca" "vorace")
;->  (7 "argenti" "girante" "granite" "ingrate" "integra" "regnati" "ritenga")
;->  (6 "piastre" "prestai" "rapiste" "sparite" "sperati" "spirate")
;->  (6 "piastra" "rapasti" "raspati" "sparati" "sparita" "spirata")
;->  (6 "perso" "porse" "poser" "preso" "prose" "spero")
;->  (6 "parati" "patria" "pirata" "rapati" "rapita" "tarpai"))

Adesso scriviamo una funzione che controlla se due parole sono anagrammi l'una dell'altra:

(define (anagram? str1 str2)
  (if (or (null? str1) (null? str2)) nil
      (if (!= (length str1) (length str2)) nil
          (if (= (sort (explode str1)) (sort (explode str2)))
              true
              nil
          )
      )
  )
)

(anagram? "pippo" "poppi")
;-> true

(anagram? "abcdefghi" "abcdefghij")
;-> nil

(anagram? "abcdefghi" "abcdefghj")
;-> nil

(time (anagram? "pippipappopoppi" "poppipappopippi") 10000)
;-> 71.007

Se le parole utilizzano solo le lettere maiuscole, allora possiamo scrivere la funzione con un altro algoritmo:

(define (anagram? str1 str2)
  (local (vec ret)
    (if (or (null? str1) (null? str2)) (setq ret nil)
        (if (!= (length str1) (length str2)) (setq ret nil)
          (begin
            (setq ret true)
            (setq str1 (upper-case str1))
            (setq str2 (upper-case str2))
            (setq vec (array 26 '(0)))
            (dostring (ch str1) (++ (vec (- ch 65))))
            (dostring (ch str2) (-- (vec (- ch 65))))
            (while (and ret (< i (length str1)))
               (if (!= (vec i) 0) (setq ret nil))
               (++ i)
            )
          )
        )
    )
    ;(println vec)
    ret
  );local
)

(anagram? "pippo" "poppi")
;-> true

(anagram? "abcdefghi" "abcdefghij")
;-> nil

(anagram? "abcdefghi" "abcdefghj")
;-> nil

(time (anagram? "pippipappopoppi" "poppipappopippi") 10000)
;-> 73.007

Per finire vediamo due funzioni per generare tutti gli anagrammi di una parola.
Il primo dei due algoritmi è stato fornito da Sam Cox e funziona direttamente sulla stringa stessa. Sottosezioni ricorsive della stringa vengono esplose, ruotate e poi unite per formare una nuova stringa.

(define (anagrams s)
    (if (<= (length s) 1)
        (list s)
        (flat (map (fn (n) (aux (rotate-string s n)))
                          (sequence 1 (length s))))))

(define (aux rs)
    (map (fn (x) (append (first rs) x)) (anagrams (rest rs))))

(define (rotate-string s n)
    (join (rotate (explode s) n)))

(anagrams "lisp")
;-> ("psil" "psli" "pils" "pisl" "plsi" "plis" "silp" "sipl" "slpi"
;->  "slip" "spil" "spli" "ilps" "ilsp" "ipsl" "ipls" "islp" "ispl"
;->  "lpsi" "lpis" "lsip" "lspi" "lips" "lisp")

(time (anagrams "newLISP") 100)
;-> 1979.796

Il secondo algoritmo si basa su un algoritmo di permutazioni generalmente applicabile. La funzione permutazioni genera tutte le possibili permutazioni di offset nella stringa, quindi applica tali permutazioni.

(define (permutations lst)
  (if (= (length lst) 1)
   lst
   (apply append (map (fn (rot)
                      (map (fn (perm) (cons (first rot) perm))
                           (permutations (rest rot))))
                      (rotations lst)))))

(define (rotations lst)
  (map (fn (x) (rotate lst)) (sequence 1 (length lst))))

(define (anagrams str)
  (map (fn (perm) (select str perm))
       (permutations (sequence 0 (- (length str) 1)))))

(anagrams "lisp")
;-> ("psil" "psli" "pils" "pisl" "plsi" "plis" "silp" "sipl" "slpi"
;->  "slip" "spil" "spli" "ilps" "ilsp" "ipsl" "ipls" "islp" "ispl"
;->  "lpsi" "lpis" "lsip" "lspi" "lips" "lisp")

(time (anagrams "newLISP") 100)
;-> 1571.798

Nota: numero di anagrammi = fattoriale(numero di caratteri)


------------------
NUMERI PRIMI CUBAN
------------------

Il nome "cuban" non ha nulla a che fare con Cuba, ma ha a che fare con il fatto che i cubi (le terze potenze) hanno un ruolo nella sua definizione.

I primi cuban sono tutti i numeri primi p che soddisfano:

p = (x^3 - y^3)/(x - y),    dove x = y + 1

I numeri primi cuban sono stati nominati nel 1923 da Allan Joseph Champneys Cunningham.

La seguente funzione brute-force è abbastanza veloce per trovare i numeri primi cubani sotto a 10000:

(define (isprime? n)
  (if (< n 2) nil
    (if (= 1 (length (factor n))))))

(define (primi_cuban N)
  (local (cubani cubo1 cubo2 conta i diff)
    (setq cubani (array (+ N 1) '(0L)))
    (setq cubo1 1L)
    (setq conta 0)
    (setq i 1L)
    (catch
      (while true
        (setq cubo2 (* i i i))
        (setq diff (- cubo2 cubo1))
        (if (isprime? diff)
          (begin
            (if (<= conta N) (setf (cubani conta) diff))
            (if (= conta N) (throw nil))
            (++ conta)
          )
        )
        (setq cubo1 cubo2)
        (++ i)
      )
    );catch
    cubani
  );local
)

(primi_cuban 100)
;-> (7L 19L 37L 61L 127L 271L 331L 397L 547L 631L 919L 1657L 1801L 1951L 2269L 2437L
;->  2791L 3169L 3571L 4219L 4447L 5167L 5419L 6211L 7057L 7351L 8269L 9241L 10267L 11719L
;->  12097L 13267L 13669L 16651L 19441L 19927L 22447L 23497L 24571L 25117L 26227L 27361L
;->  33391L 35317L 42841L 45757L 47251L 49537L 50311L 55897L 59221L 60919L 65269L 70687L
;->  73477L 74419L 75367L 81181L 82171L 87211L 88237L 89269L 92401L 96661L 102121L 103231L
;->  104347L 110017L 112327L 114661L 115837L 126691L 129169L 131671L 135469L 140617L
;->  144541L 145861L 151201L 155269L 163567L 169219L 170647L 176419L 180811L 189757L
;->  200467L 202021L 213067L 231019L 234361L 241117L 246247L 251431L 260191L 263737L
;->  267307L 276337L 279991L 283669L 285517L)

(time (primi_cuban 1000))
;-> 46.869
(time (primi_cuban 5000))
;-> 922.045
(time (primi_cuban 10000))
;-> 3797.161
(time (primi_cuban 20000))
;-> 16017.151
(time (primi_cuban 30000))
;-> 37065.96
(time (primi_cuban 50000))
;-> 108592.154
(time (primi_cuban 100000))
;-> 455520.319


--------------
DATA DI PASQUA
--------------

Calcolo della data di pasqua per gli anni 1583 a 4099
La domenica di Pasqua è la domenica successiva alla luna piena Paschal (PFM).
Questo algoritmo è un'interpretazione aritmetica del metodo EDS "Easter Dating Method" sviluppato da Ron Mallen 1985.
Poichè i valori vengono ricavati in modo sequenziale da calcoli inter-dipendenti, non modificare l'ordine dei calcoli !
L'operatore / rappresenta la divisione intera, ad esempio: 30 / 7 = 4
Tutte le variabili sono tipi di dati interi.
Per maggiori informazioni: https://www.assa.org.au/edm

(define (pasqua y)
  (local (FirstDig Remain19 temp tA tB tC tD tD)
    (setq FirstDig (/ y 100)) ; prime 2 cifre anno
    (setq Remain19 (% y 19))   ; cifre restanti anno
    ;calcola data PFM
    (setq temp (+ (/ (- FirstDig 15) 2) 202 (- (* 11 Remain19))))
    (if (find FirstDig '(21 24 25 27 28 29 30 31 32 34 35 38))
      (setq temp (- temp 1))
    )
    (if (find FirstDig '(33 36 37 39 40))
      (setq temp (- temp 2))
    )
    (setq temp (% temp 30))
    (setq tA (+ temp 21))
    (if (= temp 29) (setq tA (- tA 1)))
    (if (and (= temp 28) (> Remain19 10)) (setq tA (- tA 1)))
    ; trova la domenica successiva
    (setq tB (% (- tA 19) 7))
    (setq tC (% (- 40 FirstDig) 4))
    (if (= tC 3) (setq tC (+ tC 1)))
    (if (> tC 1) (setq tC (+ tC 1)))
    (setq temp (% y 100))
    (setq tD (% (+ temp (/ temp 4)) 7))
    (setq tE (+ (% (- 20 tB tC tD) 7) 1))
    (setq d (+ tA tE))
    ;data
    (if (> d 31)
      (setq d (- d 31) m 4)
      (setq m 3)
    )
    (list d m y)
  );local
)

(pasqua 2000)
;-> (23 4 2000)

Definiamo una funzione che calcola tutte le domeniche di Pasqua partendo dall'anno x fino all'anno y:

(define (pasque x y)
  (for (i x y)
    (print (pasqua i) { })
    (if (= (% (+ (- i x) 1) 5) 0) (println { }))
  )
  'fine
)

(pasque 2020 2029)
;-> (12 4 2020) (4 4 2021) (17 4 2022) (9 4 2023) (31 3 2024)
;-> (20 4 2025) (5 4 2026) (28 3 2027) (16 4 2028) (1 4 2029)
;-> fine


-----------------
EQUAZIONE DI PELL
-----------------

L'equazione di Pell (detta anche equazione di Pell-Fermat) è un'equazione diofantina della forma:

x^2 - n*y^2 = 1

dove il parametro "n" è un numero intero positivo non quadrato.
L'equazione ha soluzioni intere per x e y.

Trovare la soluzione più piccola dell'equazione di Pell per n = 61, 109, 181, 277.

(define (Pell n)
  (local (z r x y e1 e2 f1 f2 A B t1 t2)
    (setq x (bigint (int (sqrt n))))
    (setq y x)
    (setq z 1L)
    (setq r (* x 2))
    (setq e1 1L e2 0L)
    (setq f1 0L f2 1L)
    (catch
      (while true
        (setq y (bigint (- (* r z) y)))
        (setq z (bigint (/ (- n (* y y)) z)))
        (setq r (bigint (/ (+ x y) z)))
        (setq t1 e1) (setq t2 e2)
        (setq e1 t2)
        (setq e2 (bigint (+ (* t2 r) t1)))
        (setq t1 f1) (setq t2 f2)
        (setq f1 t2)
        (setq f2 (bigint (+ (* t2 r) t1)))
        (setq A f2)
        (setq B e2)
        (setq t1 A) (setq t2 B)
        (setq B t1)
        (setq A (bigint (+ (* t1 x) t2)))
        (if (= (- (* A A) (* B B n)) 1) (throw (list A B)))
        ;(println (format "z = %s\nr = %s\nx = %s\ny = %s" (string z) (string r) (string x) (string y)))
        ;(println (format "e1 = %s\ne2 = %s\nf1 = %s\nf2 = %s" (string e1) (string e2) (string f1) (string f2)))
        ;(println (format "A = %s\nB = %s" (string A) (string B)))
        ;(read-line)
      );while
    );catch
  );local
)

(Pell 61)
;-> (1766319049L 226153980L)

(Pell 109)
;-> (158070671986249L 15140424455100L)

(Pell 181)
;-> (2469645423824185801L 183567298683461940L)

(Pell 277)
;-> (159150073798980475849L 9562401173878027020L)

Se passiamo un numero quadrato, otteniamo un errore:

(Pell 4)
;-> ERR: division by zero
;-> called from user function (Pell 4)

Troviamo le soluzione dell'equazione di Pell per n = [1..100].

(define (Pell100)
  (for (i 1 100)
    (if (= (sqrt i) (int (sqrt i))) (println i {:})
        (println i {:  }(Pell i))
    )
  )
)

(Pell100)
;-> 1:
;-> 2:  (3L 2L)
;-> 3:  (2L 1L)
;-> 4:
;-> 5:  (9L 4L)
;-> 6:  (5L 2L)
;-> 7:  (8L 3L)
;-> 8:  (3L 1L)
;-> 9:
;-> 10:  (19L 6L)
;-> 11:  (10L 3L)
;-> 12:  (7L 2L)
;-> 13:  (649L 180L)
;-> 14:  (15L 4L)
;-> 15:  (4L 1L)
;-> 16:
;-> 17:  (33L 8L)
;-> 18:  (17L 4L)
;-> 19:  (170L 39L)
;-> 20:  (9L 2L)
;-> 21:  (55L 12L)
;-> 22:  (197L 42L)
;-> 23:  (24L 5L)
;-> 24:  (5L 1L)
;-> 25:
;-> 26:  (51L 10L)
;-> 27:  (26L 5L)
;-> 28:  (127L 24L)
;-> 29:  (9801L 1820L)
;-> 30:  (11L 2L)
;-> 31:  (1520L 273L)
;-> 32:  (17L 3L)
;-> 33:  (23L 4L)
;-> 34:  (35L 6L)
;-> 35:  (6L 1L)
;-> 36:
;-> 37:  (73L 12L)
;-> 38:  (37L 6L)
;-> 39:  (25L 4L)
;-> 40:  (19L 3L)
;-> 41:  (2049L 320L)
;-> 42:  (13L 2L)
;-> 43:  (3482L 531L)
;-> 44:  (199L 30L)
;-> 45:  (161L 24L)
;-> 46:  (24335L 3588L)
;-> 47:  (48L 7L)
;-> 48:  (7L 1L)
;-> 49:
;-> 50:  (99L 14L)
;-> 51:  (50L 7L)
;-> 52:  (649L 90L)
;-> 53:  (66249L 9100L)
;-> 54:  (485L 66L)
;-> 55:  (89L 12L)
;-> 56:  (15L 2L)
;-> 57:  (151L 20L)
;-> 58:  (19603L 2574L)
;-> 59:  (530L 69L)
;-> 60:  (31L 4L)
;-> 61:  (1766319049L 226153980L)
;-> 62:  (63L 8L)
;-> 63:  (8L 1L)
;-> 64:
;-> 65:  (129L 16L)
;-> 66:  (65L 8L)
;-> 67:  (48842L 5967L)
;-> 68:  (33L 4L)
;-> 69:  (7775L 936L)
;-> 70:  (251L 30L)
;-> 71:  (3480L 413L)
;-> 72:  (17L 2L)
;-> 73:  (2281249L 267000L)
;-> 74:  (3699L 430L)
;-> 75:  (26L 3L)
;-> 76:  (57799L 6630L)
;-> 77:  (351L 40L)
;-> 78:  (53L 6L)
;-> 79:  (80L 9L)
;-> 80:  (9L 1L)
;-> 81:
;-> 82:  (163L 18L)
;-> 83:  (82L 9L)
;-> 84:  (55L 6L)
;-> 85:  (285769L 30996L)
;-> 86:  (10405L 1122L)
;-> 87:  (28L 3L)
;-> 88:  (197L 21L)
;-> 89:  (500001L 53000L)
;-> 90:  (19L 2L)
;-> 91:  (1574L 165L)
;-> 92:  (1151L 120L)
;-> 93:  (12151L 1260L)
;-> 94:  (2143295L 221064L)
;-> 95:  (39L 4L)
;-> 96:  (49L 5L)
;-> 97:  (62809633L 6377352L)
;-> 98:  (99L 10L)
;-> 99:  (10L 1L)
;-> 100:


----------------------------
PUNTEGGIO NUMERICO (RANKING)
----------------------------

Il punteggio numerico dei concorrenti (ranking) mostra se uno è migliore, uguale o peggiore di un altro in base ai risultati ottenuti in una  o più competizioni.
Il punteggio numerico di un concorrente può essere assegnato in diversi modi:

  1) Ordinale (I concorrenti prendono il successivo numero intero disponibile. I punteggi uguali non sono trattati diversamente).

  2) Standard (I punteggi uguali condividono quello che sarebbe stato il loro primo numero ordinale).

  3) Denso (I punteggi uguali condividono il successivo numero intero disponibile).

  4) Modificato (I punteggi uguali condividono quello che sarebbe stato il loro ultimo numero ordinale).

  5) Frazionale (I punteggi uguali condividono la media di quello che sarebbe stato il loro numero ordinale)

Scrivere una funzione per ognuno dei cinque metodi di calcolo elencati.

Lista di concorrenti e relativi risultati:

  44 Solomon
  42 Jason
  42 Errol
  41 Garry
  41 Bernard
  41 Barry
  39 Stephen

Tipi di punteggi:

  Ordinal Ranking    Standard Ranking    Dense Ranking
  ---------------    ----------------    -------------
  1  44  Solomon     1  44  Solomon      1  44  Solomon
  2  42  Jason       2  42  Jason        2  42  Jason
  3  42  Errol       2  42  Errol        2  42  Errol
  4  41  Garry       4  41  Garry        3  41  Garry
  5  41  Bernard     4  41  Bernard      3  41  Bernard
  6  41  Barry       4  41  Barry        3  41  Barry
  7  39  Stephen     7  39  Stephen      4  39  Stephen
  
  Modified Ranking   Fractional Ranking
  ----------------   ------------------
  1  44  Solomon     1.0  44  Solomon
  3  42  Jason       2.5  42  Jason
  3  42  Errol       2.5  42  Errol
  6  41  Garry       5.0  41  Garry
  6  41  Bernard     5.0  41  Bernard
  6  41  Barry       5.0  41  Barry
  7  39  Stephen     7.0  39  Stephen

Definiamo una lista che contiene i concorrenti e i relativi risultati:

(setq lst '((44 Solomon) (42 Jason) (42 Errol) (41 Garry) (41 Bernard) (41 Barry) (39 Stephen)))

Ordinal rank
------------
(define (ordinal-rank lst)
  (println "Ordinal rank")
  (for (i 0 (- (length lst) 1))
    (println (format "%d  %d  %s" (+ i 1) (first (lst i)) (string (last (lst i)))))
  )
  'fine)

(ordinal-rank lst)
;-> Ordinal rank
;-> 1  44  Solomon
;-> 2  42  Jason
;-> 3  42  Errol
;-> 4  41  Garry
;-> 5  41  Bernard
;-> 6  41  Barry
;-> 7  39  Stephen

Standard rank
-------------
(define (standard-rank lst)
  (let (j 1)
    (println "Standard rank")
    (for (i 0 (- (length lst) 2))
      (println (format "%d  %d  %s" j (first (lst i)) (string (last (lst i)))))
      (if (< (first (lst (+ i 1))) (first (lst i)))
        (setq j (+ i 2))
      )
    )
    (println (format "%d  %d  %s" j (first (last lst)) (string (last (last lst)))))
  )
  'fine)

(standard-rank lst)
;-> Standard rank
;-> 1  44  Solomon
;-> 2  42  Jason
;-> 2  42  Errol
;-> 4  41  Garry
;-> 4  41  Bernard
;-> 4  41  Barry
;-> 7  39  Stephen

Dense rank
----------
(define (dense-rank lst)
  (let (j 1)
    (println "Dense rank")
    (for (i 0 (- (length lst) 2))
      (println (format "%d  %d  %s" j (first (lst i)) (string (last (lst i)))))
      (if (< (first (lst (+ i 1))) (first (lst i)))
        (++ j)
      )
    )
    (println (format "%d  %d  %s" j (first (last lst)) (string (last (last lst)))))
  )
  'fine)

(dense-rank lst)
;-> Dense rank
;-> 1  44  Solomon
;-> 2  42  Jason
;-> 2  42  Errol
;-> 3  41  Garry
;-> 3  41  Bernard
;-> 3  41  Barry
;-> 4  39  Stephen

Modified rank
-------------
(define (find-uguali val idx)
  (let (out 1)
    (while (and (< (+ idx 1) len) (= val (lst (+ idx 1) 0)))
      (++ out)
      (++ idx)
    )
    out))

(define (modified-rank lst)
  (local (len rank uguali i j k)
    (setq len (length lst))
    (println "Modified rank")
    (setq rank 0)
    (setq i 0)
    (while (< i len)
      ; valore corrente
      (setq cur (lst i 0))
      ; quanti sono i numeri uguali a quello corrente?
      (setq same (find-uguali cur i))
      ; calcola il rank per il valore corrente
      (setq rank (+ rank same))
      ; stampa tutti quelli che hanno lo stesso valore corrente
      (for (j 0 (- same 1))
        (if (zero? i)
          (println 1 { } (lst (+ i j) 0) { } (lst (+ i j) 1))
          (println rank { } (lst (+ i j) 0) { } (lst (+ i j) 1))
        )
      )
      (setq i (+ i same))
    )
    'fine))

(modified-rank lst)
;-> Modified rank
;-> 1 44 Solomon
;-> 3 42 Jason
;-> 3 42 Errol
;-> 6 41 Garry
;-> 6 41 Bernard
;-> 6 41 Barry
;-> 7 39 Stephen

Fractional rank
---------------
(define (find-uguali val idx)
  (let (out 1)
    (while (and (< (+ idx 1) len) (= val (lst (+ idx 1) 0)))
      (++ out)
      (++ idx)
    )
    out))

(define (fractional-rank lst)
  (local (len cur pos rank uguali i j pos)
    (setq len (length lst))
    (println "Fractional rank")
    (setq rank 0)
    (setq i 0)
    (while (< i len)
      ; valore corrente
      (setq cur (lst i 0))
      ; quanti sono i numeri uguali a quello corrente?
      (setq uguali (find-uguali cur i))
      ; calcola il rank per il valore corrente
      (setq pos (+ i 1))
      (setq rank (div (apply + (sequence pos (+ pos uguali (- 1)))) uguali))
      (for (j 0 (- uguali 1))
        (if (zero? i)
          (println "1.0" { } (lst (+ i j) 0) { } (lst (+ i j) 1))
          (println (format "%3.1f %s %s" 
                    rank (string (lst (+ i j) 0)) (string (lst (+ i j) 1))))
        )
      )
      (setq i (+ i uguali))
    )
    'fine))

(fractional-rank lst)
;-> Fractional rank
;-> 1.0 44 Solomon
;-> 2.5 42 Jason
;-> 2.5 42 Errol
;-> 5.0 41 Garry
;-> 5.0 41 Bernard
;-> 5.0 41 Barry
;-> 7.0 39 Stephen

Proviamo con una lista che contiene risultati diversi:

  44 Solomon
  44 Jason
  42 Errol
  41 Garry
  41 Bernard
  39 Barry
  39 Stephen

(setq lst '((44 Solomon) (44 Jason) (42 Errol) (41 Garry) (41 Bernard) (39 Barry) (39 Stephen)))

(ordinal-rank lst)
;-> Ordinal rank
;-> 1  44  Solomon
;-> 2  44  Jason
;-> 3  42  Errol
;-> 4  41  Garry
;-> 5  41  Bernard
;-> 6  39  Barry
;-> 7  39  Stephen

(standard-rank lst)
;-> Standard rank
;-> 1  44  Solomon
;-> 1  44  Jason
;-> 3  42  Errol
;-> 4  41  Garry
;-> 4  41  Bernard
;-> 6  39  Barry
;-> 6  39  Stephen

(dense-rank lst)
;-> Dense rank
;-> 1  44  Solomon
;-> 1  44  Jason
;-> 2  42  Errol
;-> 3  41  Garry
;-> 3  41  Bernard
;-> 4  39  Barry
;-> 4  39  Stephen

(modified-rank lst)
;-> Modified rank
;-> 1 44 Solomon
;-> 1 44 Jason
;-> 3 42 Errol
;-> 5 41 Garry
;-> 5 41 Bernard
;-> 7 39 Barry
;-> 7 39 Stephen

(fractional-rank lst)
;-> Fractional rank
;-> 1.0 44 Solomon
;-> 1.0 44 Jason
;-> 3.0 42 Errol
;-> 4.5 41 Garry
;-> 4.5 41 Bernard
;-> 6.5 39 Barry
;-> 6.5 39 Stephen


-----------------
LEGGE DI BENDFORD
-----------------

La legge di Benford, chiamata anche legge della prima cifra, si riferisce alla distribuzione di frequenza delle cifre in molte (ma non tutte) fonti di dati reali.

In questa distribuzione, il numero 1 si presenta come la prima cifra circa il 30% delle volte, mentre i numeri più grandi si verificano in quella posizione meno frequentemente: 9 come prima cifra meno del 5% delle volte. Questa distribuzione delle prime cifre è uguale alle larghezze di una griglia con scala logaritmica.

La legge di Benford riguarda anche la distribuzione prevista per cifre oltre la prima, che si avvicina ad una distribuzione uniforme.

È stato riscontrato che questo risultato si applica a un'ampia varietà di set di dati, tra cui bollette elettriche, indirizzi stradali, quotazioni azionarie, numero di abitanti, tassi di mortalità, lunghezze dei fiumi, costanti fisiche e matematiche e processi descritti dalle leggi di potenza (che sono molto comune in natura). Tende ad essere più preciso quando i valori sono distribuiti su più ordini di grandezza.

Si dice che una serie di numeri soddisfa la legge di Benford se le cifre iniziali (1..9) si verificano con probabilità:

P(d) = log10(d + 1) - log10(d) = log10(1 + 1/d)

(define (P)
  (let (out '())
    (for (i 1 9)
      (push (mul 100 (log (add 1 (div 1 i)) 10)) out -1)
    )
  )
)

(setq bend (P))
;-> (30.10299956639812 17.60912590556812  12.49387366082999
;->   9.69100130080564  7.918124604762481  6.694678963061322
;->   5.799194697768673 5.115252244738128  4.575749056067514)

Scriviamo una funzione per calcolare la distribuzione delle prime cifre significative (non zero) in un insieme di numeri, quindi confrontare la distribuzione effettiva rispetto a quella attesa (cioè quella di Bendford). La funzione ha come parametro il nome del file che contiene l'insieme dei numeri.

Come primo esempio utilizziamo come insieme di dati i primi 1000 numeri di fibonacci.
Scriviamo una funzione che crea un file di testo con i primi 1000 numeri di fibonacci.

Funzione che calcola il numero di fibonacci di un numero n:

(define (fibo-i n)
  (local (a b c)
    (setq a 0L b 1L c 0L)
    (for (i 0 (- n 1))
      (setq c (+ a b))
      (setq a b)
      (setq b c)
    )
    a
  )
)

Funzione che crea un file con n numeri di Fibonacci (un numero per ogni riga).

(define (fibfile file n)
  (local (outfile)
    (setq outfile (open file "write"))
    (for (i 1 n)
      (write-line outfile (string (fibo-i i)))
    )
    (close outfile)
  )
)

(fibfile "fibo1000.txt" 1000)
;-> true

Adesso scriviamo la funzione per verificare la legge di Bendford. La prima versione della funzione crea il vettore con le frequenze:

(define (bendford file)
  (local (infile val data)
    (setq data (array 10 '(0)))
    ; leggiamo i numeri dal file
    (setq infile (open file "read"))
    (while (read-line infile)
      ; (current-line) restituisce una stringa
      (setq val (int ((current-line) 0)))
      ;aggiorniamo il vettore delle frequenze
      (++ (data val))
    )
    (close infile)
     data
  )
)

(setq out (bendford "fibo1000.txt"))
;-> (0 301 177 125 96 80 67 56 53 45)

Verifichiamo il risultato:
(apply + out)
;-> 1000

Adesso scriviamo la versione finale:

(define (bendford file)
  (local (infile val data dataB perc-freq-reali perc-freq-attese)
    (setq data (array 10 '(0)))
    ; leggiamo i numeri dal file
    (setq infile (open file "read"))
    (while (read-line infile)
      ; (current-line) restituisce una stringa
      (setq val (int ((current-line) 0)))
      ;aggiorniamo il vettore delle frequenze
      (++ (data val))
    )
    (close infile)
    (setq data (array-list data))
    ; calcoliamo le percentuali delle frequenze reali
    (setq somma (apply add data))
    (setq perc-freq-reali (map (fn (x) (mul 100 (div x somma))) data))
    ;(println perc-freq-reali)
    ; calcoliamo le percentuali delle frequenze attese (Bendford)
    (setq perc-freq-attese '(0))
    (for (i 1 9)
      (push (mul 100 (log (add 1 (div 1 i)) 10)) perc-freq-attese -1)
    )
    ;(println perc-freq-attese)
    ;calcoliamo la differenza tra le due percentuali di ogni cifra
    (setq diff (map sub perc-freq-attese perc-freq-reali))
    ;stampiamo i risultati
    (println {     %att     %real     diff})
    (for (i 1 9)
      (println (format "%d %8.2f %8.2f %+8.2f"
               i (perc-freq-attese i) (perc-freq-reali i) (diff i)))
    )
    '-----------------------------
  )
)

(bendford "fibo1000.txt")
     %att     %real     diff
1    30.10    30.10    +0.00
2    17.61    17.70    -0.09
3    12.49    12.50    -0.01
4     9.69     9.60    +0.09
5     7.92     8.00    -0.08
6     6.69     6.70    -0.01
7     5.80     5.60    +0.20
8     5.12     5.30    -0.18
9     4.58     4.50    +0.08
-----------------------------

I primi 1000 numeri di Fibonacci rispettano la legge di Bendford.

Proviamo con un altro insieme di dati: i numeri primi.

(bendford "primi5000.txt")
;->      %att     %real     diff
;-> 1    30.10    23.86    +6.24
;-> 2    17.61    22.58    -4.97
;-> 3    12.49    21.94    -9.45
;-> 4     9.69    18.72    -9.03
;-> 5     7.92     2.62    +5.30
;-> 6     6.69     2.70    +3.99
;-> 7     5.80     2.50    +3.30
;-> 8     5.12     2.54    +2.58
;-> 9     4.58     2.54    +2.04
;-> -----------------------------

I primi 5000 numeri Primi non sembra che rispettino la legge di Bendford.

Proviamo con un altro insieme di dati: 10000 cifre decimali di pi greco.

(bendford "pigreco10000.txt")
;->      %att     %real     diff
;-> 1    30.10    10.26   +19.84
;-> 2    17.61    10.21    +7.40
;-> 3    12.49     9.74    +2.75
;-> 4     9.69    10.12    -0.43
;-> 5     7.92    10.46    -2.54
;-> 6     6.69    10.21    -3.52
;-> 7     5.80     9.70    -3.90
;-> 8     5.12     9.48    -4.36
;-> 9     4.58    10.14    -5.56
;-> -----------------------------

Le prime 10000 cifre decimali di pi greco non sembra che rispettino la legge di Bendford.

Proviamo con i primi 100000 numeri.

(define (numeri file n)
  (local (outfile)
    (setq outfile (open file "write"))
    (for (i 1 n)
      (write-line outfile (string i))
    )
    (close outfile)
  )
)

(numeri "numeri100000.txt" 100000)
;-> true

(bendford "numeri100000.txt")
;->      %att     %real     diff
;-> 1    30.10    11.11   +18.99
;-> 2    17.61    11.11    +6.50
;-> 3    12.49    11.11    +1.38
;-> 4     9.69    11.11    -1.42
;-> 5     7.92    11.11    -3.19
;-> 6     6.69    11.11    -4.42
;-> 7     5.80    11.11    -5.31
;-> 8     5.12    11.11    -6.00
;-> 9     4.58    11.11    -6.54
;-> -----------------------------

Le prime cifre dei numeri naturali hanno una distribuzione uniforme.

Proviamo con un altro insieme di dati: la lunghezza dei fiumi italiani (6226).

(bendford "fiumi.txt")
;->      %att     %real     diff
;-> 1    30.10    26.10    +4.00
;-> 2    17.61    12.19    +5.42
;-> 3    12.49    11.05    +1.44
;-> 4     9.69    11.84    -2.15
;-> 5     7.92    10.62    -2.70
;-> 6     6.69     8.79    -2.09
;-> 7     5.80     7.65    -1.85
;-> 8     5.12     6.73    -1.61
;-> 9     4.58     5.04    -0.47
;-> -----------------------------

Le lunghezze dei fiumi seguono abbastanza la legge di Bendford.


----------
CALENDARIO
----------

Unix e Linux hanno il comando "cal" per stampare il calendario corrente. Un programma ancora più completo è GNU "gcal" (con alcune funzionalità esoteriche). Per windows non esiste niente di simile, allora scriviamo una funzione che stampa il calendario dell'anno corrente o di un'anno definito (anno > 1752).
Ci servono due funzioni ausiliarie, una per il calcolo del giorno della settimana a partire da una data e un'altra per calcolare se un anno è bisestile.

Giorno della settimana

(define (giorno year month day) ; 0..6 --> Domenica..Sabato
  (local (t d)
    (setq t '(0 3 2 5 0 3 5 1 4 6 2 4))
    (if (< month 3) (-- year))
    (setq d (% (add year (/ year 4) (/ (- year) 100) (/ year 400) (t (- month 1)) day) 7))
  )
)

(giorno 2019 7 17)
;-> 3

Anno bisestile

(define (leap? year)
  (cond ((= (% year 400) 0) true) ; divisibile per 400
        ((= (% year 100) 0) nil)  ; divisibile per 100, ma non per 400
        ((= (% year 4) 0) true)   ; divisibile per 4, ma non per 100 e 400
        (true nil)                ; non divisibile per 4 o 100 o 400
  )
)

(leap? 1900)
;-> nil

La funzione integrata "now" fornisce le seguenti informazioni:

(now)
;-> (2019 7 18 8 15 43 236522 199 4 120 2)

Ecco il significato dei numeri interi (11) restituiti dalla funzione "now":

Descrizione                       Valore

 1) year                          Gregorian calendar
 2) month                         (1–12)
 3) day                           (1–31)
 4) hour                          (0–23) UTC
 5) minute                        (0–59)
 6) second                        (0–59)
 7) microsecond                   (0–999999) OS-specific, millisecond resolution
 8) day of current year           Jan 1st is 1
 9) day of current week           (1–7) starting Monday
10) time zone offset in minutes   west of GMT including daylight savings bias
11) daylight savings time type    (0–6) on Linux/Unix or (0–2) on MS Windows

(define (cal anno)
  (local (startNum startNum day month numDays pad)
    (setq day '((1 Lunedi) (2 Martedi) (3 Mercoledi) (4 Giovedi) (5 Venerdi) (6 Sabato) (7 Domenica)))
    (setq month '((GENNAIO 31) (FEBBRAIO 28) (MARZO 31) (APRILE 30) (MAGGIO 31) (GIUGNO 30)
      (LUGLIO 31) (AGOSTO 31) (SETTEMBRE 30) (OTTOBRE 31) (NOVEMBRE 30) (DICEMBRE 31)))
    (if (or (= anno nil) (<= anno 1752)) (setq anno (first (now))))
    ; if (anno < 1753) then anno = (first (now))
    ; primo giorno dell'anno (numero)
    (setq startNum (giorno anno 1 1))
    ; (1: lunedi ... 7: domenica)
    (if (= startNum 0) (setq startNum 7))
    (setq startDay (lookup startNum day))
    ; anno bisestile?
    (if (leap? anno) (setf (last (month 1)) 29))
    ; stampa anno
    (println (format "\n%d\n" anno))
    (setq ultimo startNum)
    (for (i 0 11)
      ; stampa mese
      ;(println (format "%s" (first (month i))))
      (println (first (month i)))
      ; stampa intestazione giorni
      (println "Lu Ma Me Gi Ve Sa Do")
      ; calcola e stampa lo spazio di inizio del primo giorno
      (setq pad (dup " " (* (- ultimo 1) 3)))
      (print pad)
      ; giorni del mese
      (setq numDays (lookup (first (month i)) month))
      (for (j 1 numDays)
        (print (format "%2d " j))
        ; se il giorno è Domenica (e non è l'ultimo del mese), allora andiamo a capo
        (if (and (= (giorno anno (+ i 1) j) 0) (!= j numDays))  (println { }))
      )
      ; ultimo giorno stampato
      (setq ultimo (+ 1 (giorno anno (+ i 1) (lookup (first (month i)) month))))
      (println "\n")
    )
    '--------------------
  )
)

(cal 2020)

2020

GENNAIO                FEBBRAIO               MARZO
Lu Ma Me Gi Ve Sa Do   Lu Ma Me Gi Ve Sa Do   Lu Ma Me Gi Ve Sa Do
       1  2  3  4  5                   1  2                      1
 6  7  8  9 10 11 12    3  4  5  6  7  8  9    2  3  4  5  6  7  8
13 14 15 16 17 18 19   10 11 12 13 14 15 16    9 10 11 12 13 14 15
20 21 22 23 24 25 26   17 18 19 20 21 22 23   16 17 18 19 20 21 22
27 28 29 30 31         24 25 26 27 28 29      23 24 25 26 27 28 29
                                              30 31

APRILE                 MAGGIO                 GIUGNO
Lu Ma Me Gi Ve Sa Do   Lu Ma Me Gi Ve Sa Do   Lu Ma Me Gi Ve Sa Do
       1  2  3  4  5                1  2  3    1  2  3  4  5  6  7
 6  7  8  9 10 11 12    4  5  6  7  8  9 10    8  9 10 11 12 13 14
13 14 15 16 17 18 19   11 12 13 14 15 16 17   15 16 17 18 19 20 21
20 21 22 23 24 25 26   18 19 20 21 22 23 24   22 23 24 25 26 27 28
27 28 29 30            25 26 27 28 29 30 31   29 30

LUGLIO                 AGOSTO                 SETTEMBRE
Lu Ma Me Gi Ve Sa Do   Lu Ma Me Gi Ve Sa Do   Lu Ma Me Gi Ve Sa Do
       1  2  3  4  5                   1  2       1  2  3  4  5  6
 6  7  8  9 10 11 12    3  4  5  6  7  8  9    7  8  9 10 11 12 13
13 14 15 16 17 18 19   10 11 12 13 14 15 16   14 15 16 17 18 19 20
20 21 22 23 24 25 26   17 18 19 20 21 22 23   21 22 23 24 25 26 27
27 28 29 30 31         24 25 26 27 28 29 30   28 29 30
                       31

OTTOBRE                NOVEMBRE               DICEMBRE
Lu Ma Me Gi Ve Sa Do   Lu Ma Me Gi Ve Sa Do   Lu Ma Me Gi Ve Sa Do
          1  2  3  4                      1       1  2  3  4  5  6
 5  6  7  8  9 10 11    2  3  4  5  6  7  8    7  8  9 10 11 12 13
12 13 14 15 16 17 18    9 10 11 12 13 14 15   14 15 16 17 18 19 20
19 20 21 22 23 24 25   16 17 18 19 20 21 22   21 22 23 24 25 26 27
26 27 28 29 30 31      23 24 25 26 27 28 29   28 29 30 31
                       30

Nota: L'output della funzione stampa tutti i mesi uno di seguito all'altro.


--------------
CARTE DA GIOCO
--------------

Crea una struttura dati e le funzioni associate per definire e manipolare un mazzo di carte da gioco.
Il mazzo dovrebbe contenere 54 carte uniche.

Le funzioni devono includere la capacità di:

1) crea un nuovo mazzo
2) mischiare il mazzo (shuffle)
3) Estrarre una carta dal mazzo
4) Stampare il contenuto del mazzo

Ogni carta deve avere un valore e un seme che costituiscono il codice univoco della carta.

Per chi ha i caratteri utf-8 può usare la definizione seguente:

(setq semi '("♥" "♦" "♣" "♠"))

Definiamo una funzione che crea un mazzo di carte:

(define (crea-carte)
  (local (semi numeri indice carte)
    ; definiamo i semi delle carte
    (setq semi '(Cuori Quadri Fiori Picche))
    ; definiamo i numeri delle carte
    (setq numeri '(Asso Due Tre Quattro Cinque Sei Sette Otto Nove Dieci Jack Donna Re))
    ; creiamo il mazzo di carte: (1 (Asso Cuori)) (2 (Due Cuori)) ...
    (setq carte '())
    (setq indice 0)
    (dolist (seme semi)
      (push (map (fn (x) (list (+ $idx 1 indice) (list x seme))) numeri) carte -1)
      (++ indice 13)
    )
    ; togliamo un livello alla lista carte (da 4 elementi passa a 52 elementi)
    (setq carte (flat carte 1))
    ; aggiungiamo i Jolly (le matte)
    (push '(53 (Matta Jolly)) carte -1)
    (push '(54 (Matta Jolly)) carte -1)
    carte
  )
)

(setq mazzo (crea-carte))
;-> ((1 (Asso Cuori)) (2 (Due Cuori)) (3 (Tre Cuori)) (4 (Quattro Cuori))
;->  (5 (Cinque Cuori)) ...
;->  ...
;->  (51 (Donna Picche)) (52 (Re Picche)) (53 (Matta Jolly)) (54 (Matta Jolly)))

Definiamo una funzione che mischia le carte:

(define (mischia mazzo)
  (seed (time-of-day))
  (randomize mazzo)
)

(setq partita (mischia mazzo))
;-> ((34 (Otto Fiori)) (30 (Quattro Fiori)) (26 (Re Quadri))...
;->  ... (21 (Otto Quadri)) (37 (Jack Fiori)))

Per la funzione di estrazione possiamo usare la funzione integrata "pop" estraendo la prima carta del mazzo:

(define (estrai mazzo) (pop mazzo))

Però qualcosa non funziona:

(length partita)
;-> 54

(estrai partita)
;-> (34 (Otto Fiori))

(length partita)
;-> 54

Abbiamo estratto la prima carta, ma non è stata eliminata dal mazzo perchè alla funzione estrai viene passata una copia del mazzo "partita".
Per risolvere il problema definiamo un mazzo come contesto, in questo modo newLISP passa la variabile definita per riferimento.

(setq p:p (mischia mazzo))
;-> ((26 (Re Quadri)) (12 (Donna Cuori)) ...
;->  ... (9 (Nove Cuori)) (43 (Quattro Picche)))

Vediamo se funziona:

(length p)
;-> 54

(estrai p)
;-> (26 (Re Quadri))

(length p)
;-> 53

Sembra che vada tutto bene. Senza utilizzare i contesti avremmo dovuto applicare la funzione "pop" direttamente sulla variabile mazzo.

Infine definiamo una funzione che stampa le carte del mazzo:

(define (stampa-tutto mazzo)
  (dolist (carta mazzo)
    (print (format "%18s" (string (last carta))))
    (if (= (% (+ $idx 1) 4) 0) (println))
  )
)

(stampa-tutto partita)
;->   (Otto Quadri)     (Matta Jolly)      (Tre Picche)     (Donna Fiori)
;->   (Otto Picche)   (Cinque Picche)       (Sei Fiori)        (Re Fiori)
;->    (Otto Fiori)     (Matta Jolly)     (Jack Picche)   (Quattro Fiori)
;->     (Sei Cuori)        (Re Cuori)     (Sette Cuori)       (Due Cuori)
;->  (Sette Picche)      (Nove Cuori)     (Dieci Cuori)       (Due Fiori)
;->     (Re Picche)     (Nove Quadri)      (Sei Quadri)       (Tre Cuori)
;->   (Asso Picche)     (Sette Fiori)      (Sei Picche)    (Sette Quadri)
;->   (Donna Cuori)     (Jack Quadri)    (Cinque Fiori)      (Jack Cuori)
;->     (Tre Fiori)    (Cinque Cuori)      (Otto Cuori)    (Donna Picche)
;->    (Jack Fiori)       (Re Quadri)      (Asso Cuori)      (Nove Fiori)
;-> (Cinque Quadri)  (Quattro Quadri)  (Quattro Picche)    (Donna Quadri)
;->    (Due Picche)    (Dieci Picche)      (Tre Quadri)     (Dieci Fiori)
;->    (Asso Fiori)     (Asso Quadri)    (Dieci Quadri)     (Nove Picche)
;-> (Quattro Cuori)      (Due Quadri)


----------------------
GENERATORE DI PASSWORD
----------------------

Creare un programma per la generazione di password contenenti caratteri ASCII casuali dai seguenti gruppi:
lettere minuscole:  (a..z)
lettere maiuscole:  (A..Z)
cifre numeriche:    (0..9)
caratteri speciali: (# ! $ % & ( ) * + , - . / : ; < = > ? @ [ ] ^ _ { | } ~)

Le password generate devono includere almeno un carattere di ciascuno dei seguenti quattro gruppi):

1) lettera minuscola,
2) lettera maiuscola,
3) cifra numerica,
4) carattere speciale

La funzione ha come parametri la lunghezza della password e il numero di password da generare.

La funzione deve anche escludere la creazione di password con i seguenti caratteri visualmente simili:

1) Il lI
2) 1l l1
3) 1I I1
4) O0 0O
5) 5S S5
6) Z2 2Z

(define (gen-pwd num lun stampa)
  (local (pwd g g0 g1 g2 g3 gv out)
    (cond ((or (< num 1) (< lun 4)) (setq out nil) (println "parametri errati"))
          (true
            ; inizializza il generatore random
            (seed (time-of-day))
            (setq out '())
            (setq g0 (explode "abcdefghijklmnopqrstuvwxyz"))
            (setq g1 (explode "ABCDEFGHIJKLMNOPQRSTUVWXYZ"))
            (setq g2 (explode "0123456789"))
            (setq g3 (explode "#!$%&()*+,-./:;<=>?@[]^_{|}~"))
            ; ciclo numero di password
            (for (i 1 num)
              (setq pwd '())
              ; aggiungiamo un carattere per ogni gruppo
              (push (g0 (rand 26)) pwd -1)
              (push (g1 (rand 26)) pwd -1)
              (push (g2 (rand 10)) pwd -1)
              (push (g3 (rand 28)) pwd -1)
              ; ciclo genera password di lunghezza lun
              (if (> lun 4)
                (begin
                  (for (j 1 (- lun 4))
                    (setq g (rand 4))
                    (if (= g 0) (push (g0 (rand 26)) pwd -1)
                      (if (= g 1) (push (g1 (rand 26)) pwd -1)
                        (if (= g 2) (push (g2 (rand 10)) pwd -1)
                          (if (= g 3) (push (g3 (rand 28)) pwd -1)))))
                  )
                )
              )
              ; randomize per mischiare i caratteri
              ; soprattuto per i primi quattro che altrimenti
              ; seguirebbero una regola fissa
              (setq pwd (join (randomize pwd)))
              ; controllo caratteri visualmente simili
              ; (Il lI) (1l l1) (1I I1) (O0 0O) (5S S5) (Z2 2Z)
              (if (setq idx (find "Il" pwd)) (setq (pwd idx) (g3 (rand 28))))
              (if (setq idx (find "ll" pwd)) (setq (pwd idx) (g3 (rand 28))))
              (if (setq idx (find "1l" pwd)) (setq (pwd idx) (g3 (rand 28))))
              (if (setq idx (find "l1" pwd)) (setq (pwd idx) (g3 (rand 28))))
              (if (setq idx (find "1I" pwd)) (setq (pwd idx) (g3 (rand 28))))
              (if (setq idx (find "I1" pwd)) (setq (pwd idx) (g3 (rand 28))))
              (if (setq idx (find "0O" pwd)) (setq (pwd idx) (g3 (rand 28))))
              (if (setq idx (find "O0" pwd)) (setq (pwd idx) (g3 (rand 28))))
              (if (setq idx (find "5S" pwd)) (setq (pwd idx) (g3 (rand 28))))
              (if (setq idx (find "S5" pwd)) (setq (pwd idx) (g3 (rand 28))))
              (if (setq idx (find "Z2" pwd)) (setq (pwd idx) (g3 (rand 28))))
              (if (setq idx (find "2Z" pwd)) (setq (pwd idx) (g3 (rand 28))))
              (if stampa (println pwd))
              (push pwd out -1)
            );for
          );true
    );cond
    out
  );local
)

(gen-pwd 2 8)
;-> ("BPT=v+8s" "M&I9^o0L")

(gen-pwd 1 3)
;-> parametri errati
;-> nil

(gen-pwd 1 4)
;-> ("M5}g")

(gen-pwd 6 12)
;-> ("Jrfh.F2~uEtd" "ljR8[=3VYoSH" "|0J4u^4dv0{9"
;->  "87HFP;{u6ini" "M3w|1:4],G4m" "3@LH5Q*E00mv")

Funzione che controlla la presenza di caratteri visualmente simili:

(define (test pwd)
  (for (i 1 100000)
    (setq pwd (first (gen-pwd 1 21)))
    (if (or (find "Il" pwd) (find "ll" pwd) (find "1l" pwd)
            (find "l1" pwd) (find "1I" pwd) (find "I1" pwd)
            (find "0O" pwd) (find "O0" pwd) (find "5S" pwd)
            (find "S5" pwd) (find "Z2" pwd) (find "2Z" pwd))
        (println pwd)
    )
  )
)

(test pwd)
;-> nil


-------------------
CALCOLO DI PI GRECO
-------------------

Pi greco è un numero irrazionale (cioè non può essere il rapporto di due numeri interi) e trascendente (cioè non è una radice di un polinomio con coefficienti razionali.

Pi greco vale: 3.141592653589793238462643383279502884197169399375105820974....

I matematici hanno trovato differenti serie matematiche che, se calcolate sommando un numero infinito di termini, generano un'approssimazione sufficientemente accurata di pi greco per un numero abbastanza grande di decimali.
Alcune di esse sono talmente complesse da richiedere dei supercomputer per calcolarle.
Vediamo alcuni algoritmi per il calcolo del numero pigreco.
Uno dei più semplici è l'algoritmo basato sulla serie di Gregory-Leibniz. Anche se non è molto efficiente, genera un numero sempre più vicino a pi greco ad ogni iterazione, arrivando ad una approssimazione sufficientemente accurata con 10 cifre decimali con 500.000 iterazioni.

Serie di Gregory-Leibniz:

Pi = 4 * (1 - 1/3 + 1/5 - 1/7 + 1/9 - 1/11 + ...)

Pi = (4/1) - (4/3) + (4/5) - (4/7) + (4/9) - (4/11) + ... + (-i)^i/(2*i + 1) + ...

Definiamo la funzione:

(define (pow10? i)
  (while (> i 10)
    (setq i (div i 10)))
  (= i 10)
)

(define (pigrecoGL iter)
  (local (sum fac i denom myterm)
    (setq sum 0)
    (setq fac 1)
    (setq i 1)
    (while (<= i iter)
      (setq denom (- (mul 2 i ) 1))
      (setq myterm (div fac denom))
      (setq sum (add sum myterm))
      (setq fac (mul -1 fac))
      (if (pow10? i)
        (print (format "%d iterazioni: PI = %16.12f.\n" i (mul 4 sum)))
      )
      (++ i)
    )
  );local
)

(pigrecoGL 10000000)
;-> Con 10 termini PI vale:   3.041839618929.
;-> Con 100 termini PI vale:   3.131592903559.
;-> Con 1000 termini PI vale:   3.140592653840.
;-> Con 10000 termini PI vale:   3.141492653590.
;-> Con 100000 termini PI vale:   3.141582653590.
;-> Con 1000000 termini PI vale:   3.141591653590.
;-> Con 10000000 termini PI vale:   3.141592553590.
Valore reale pi greco:              3.141592653589

Un'altra serie infinita per calcolare pi greco è quella di Nilakantha. Anche se più leggermente più complessa, converge a pi greco molto più velocemente della formula di Leibniz.

Serie di Nilakantha:

pigrecoN = 3 + 4/(2*3*4) - 4/(4*5*6) + 4/(6*7*8) - 4/(8*9*10) + 4/(10*11*12) - (4/(12*13*14) ...

(define (pigrecoN iter)
  (local (val based frac num den i)
    (setq val 3)
    (setq based 2)
    (setq i 1)
    (setq num 4)
    (while (<= i iter)
      (setq den (* based (+ based 1) (+ based 2)))
      (setq val (add val (div num den)))
      (++ based 2)
      (setq num (- num))
      (++ i)
      (if (= (% i 100) 0)
        (print (format "Con %d termini PI vale: %16.12f.\n" i val))
      )
    )
  )
)

(pigrecoN 500)
;-> Con 100 termini PI vale:   3.141592903559.
;-> Con 200 termini PI vale:   3.141592684839.
;-> Con 300 termini PI vale:   3.141592662849.
;-> Con 400 termini PI vale:   3.141592657496.
;-> Con 500 termini PI vale:   3.141592655590.
Valore reale pi greco:         3.141592653589

Serie di Eulero:

(pigreco^2)/6 = sum[1,∞] 1/(i*i)

(define (pigrecoL iter)
  (local (val i)
      (setq i 1)
      (setq val 0)
      (while (<= i iter)
        (setq val (add val (div 1 (mul i i))))
        (if (= (% i 100000) 0)
          (print (format "Iterazioni: %d   PI: %16.12f\n" i (sqrt (mul val 6))))
        )
        (++ i)
      )
      (sqrt (mul val 6))
  )
)

(pigrecoL 1000000)
;-> Iterazioni: 100000   PI:   3.141583104326
;-> Iterazioni: 200000   PI:   3.141587878950
;-> Iterazioni: 300000   PI:   3.141589470495
;-> Iterazioni: 400000   PI:   3.141590266268
;-> Iterazioni: 500000   PI:   3.141590743732
;-> Iterazioni: 600000   PI:   3.141591062041
;-> Iterazioni: 700000   PI:   3.141591289405
;-> Iterazioni: 800000   PI:   3.141591459928
;-> Iterazioni: 900000   PI:   3.141591592557
;-> Iterazioni: 1000000  PI:   3.141591698661
Valore reale pi greco:         3.141592653589


---------------
NUMERI DI LUCAS
---------------

I numeri di Lucas sono simili ai numeri di Fibonacci. I numeri di Lucas sono definiti come la somma dei suoi due termini immediatamente precedenti. Ma qui i primi due termini sono 2 e 1 mentre nei numeri di Fibonacci i primi due termini sono rispettivamente 0 e 1.

Matematicamente, i numeri di Lucas sono definiti come:

 L(0) = 2
 L(1) = 1
 L(n) = L(n-2) + L(n-1), per n > 1.

I primi numeri di Lucas sono i seguenti numeri interi:

2, 1, 3, 4, 7, 11, 18, 29, 47, 76, 123, ...

Scriviamo una funzione che restituisce l'ennesimo numero di Lucas.

Versione ricorsiva:

(define (lucas n)
  (if (zero? n)
      2
      (if (= 1 n)
      1
      (+ (lucas (- n 1)) (lucas (- n 2))))))

(map lucas (sequence 0 10))
;-> (2 1 3 4 7 11 18 29 47 76 123)

(lucas 30)
;-> 1860498

Versione iterativa O(n):

(define (lucas-i n)
  (local (a b c)
    (setq a 2 b 1)
    (if (zero? n)
        a
        (if (= 1 n)
            b
            (for (i 2 n)
              (setq c (+ a b))
              (setq a b)
              (setq b c)
            )
        )
    )
  )
)

(map lucas-i (sequence 0 10))
;-> (2 1 3 4 7 11 18 29 47 76 123)

(lucas-i 30)
;-> 1860498

Vediamo la differenza di velocità:

(time (lucas 30))
;-> 500.961

(time (lucas-i 30))
;-> 0

La versione iterativa è molto più veloce della versione ricorsiva.
Esistono algoritmi ancora più veloci per il calcolo dei numeri di Lucas che utilizzano le operazioni tra matrici.


------------------------------------
LOGARITMO INTERO DI UN NUMERO INTERO
------------------------------------

Il logaritmo intero base b di un numero n è il numero di volte in cui il numero b può essere moltiplicato per se stesso senza superare n.

Scrivere una funzione che calcola il logaritmo intero di un numero intero.

Funzione ricorsiva:

(define (ilog n b)
  (if (zero? n) -1
    (+ (ilog (/ n b) b) 1L)))

(ilog 1818272126126126 3)
;-> 31

Verifichiamo la correttezza della funzione:

(for (i 1 1e6)
  (if (!= (ilog i 10) (int (log i 10)))
    (println "error: " i { } (ilog i 10) { } (log i 10))
  )
)
;-> error: 1000 3 3
;-> error: 1000000 6 5.999999999999999

Questi errori sono dovuti alla mancanza di precisione dei numeri floating-point, non a bug della  funzione "ilog".

Vediamo la velocità della funzione:

(time (for (i 1 1000000) (ilog i 10)))
;-> 1294.672

(time (for (i 1 1000000) (int (log i 10))))
;-> 114.881

Se cambio la base (es. 2) "ilog" aumenta il tempo, mentre "log" rimane costante) !!!

(time (for (i 1 1000000) (ilog i 2)))
;-> 4015.893

(time (for (i 1 1000000) (int (log i 2))))
;-> 109.365

Nota: Per la funzione "log" vale: logb(n) = x, n = b^x. Questo non è vero per la funzione "ilog".

Versione iterativa:

(define (ilog n b)
  (let (out -1)
    (while (!= n 0)
      ;(++ out)
      (setq n (/ n b))
      (setq out (+ out 1))
    )
    out
  )
)

(ilog 1818272126126126 3)
;-> 31

Verifichiamo la correttezza della funzione:

(for (i 1 1e6)
  (if (!= (ilog i 10) (int (log i 10)))
    (println "error: " i { } (ilog i 10) { } (log i 10))
  )
)
;-> error: 1000 3 3
;-> error: 1000000 6 5.999999999999999

Questi errori sono dovuti alla mancanza di precisione dei numeri floating-point, non a bug della  funzione "ilog".

Vediamo la velocità della funzione:

(time (for (i 1 1000000) (ilog i 10)))
;-> 1015.882

Se cambio la base (es. 2) "ilog" aumenta il tempo, mentre "log" rimane costante) !!!

(time (for (i 1 1000000) (ilog i 2)))
;-> 2797.303

(time (for (i 1 1000000) (int (log i 2))))
;-> 109.365

Versione iterativa (big integer):

(define (ilog n b)
  (let (out -1L)
    (while (!= n 0)
      ;(++ out)
      (setq n (/ n b))
      (setq out (+ out 1L))
    )
    out
  )
)

(ilog 1818272126126126 3)
;-> 31L

Verifichiamo la correttezza della funzione:

(for (i 1 1e6)
  (if (!= (ilog i 10) (int (log i 10)))
    (println "error: " i { } (ilog i 10) { } (log i 10))
  )
)
;-> error: 1000 3L 3
;-> error: 1000000 6L 5.999999999999999

Questi errori sono dovuti alla mancanza di precisione dei numeri floating-point, non a bug della  funzione "ilog".

(setq a (log 1000 10))
;-> 3

Trasformo il float "a" in integer:
(int a)
;-> 2
Non è il risultato che ci aspettavamo.

Il problema risiede nella perdita di precisione dei calcoli in virgola mobile:
(setq a (format "%16.16f" (log 1000 10)))
;-> "2.9999999999999996"

Vediamo la velocità della funzione:

(time (for (i 1 1000000) (ilog i 10)))
;-> 1687.71

Se cambio la base (es. 2 ilog aumenta il tempo, mentre log rimane costante) !!!

(time (for (i 1 1000000) (ilog i 2)))
;-> 4359.772


--------------------
NUMERI DI CARMICHAEL
--------------------

In teoria dei numeri, un numero di Carmichael è un intero positivo composto n che soddisfa la congruenza

 b^(n-1) ≡ 1 mod n

per tutti gli interi b che sono coprimi con n o, equivalentemente, che verificano la congruenza

 b^n ≡ b mod n

per ogni b.

Il piccolo teorema di Fermat afferma che tutti i numeri primi hanno quella proprietà, ma il viceversa non è vero: ad esempio  2^(341) mod 341, ma 341 non è primo, essendo il prodotto di 11 e 31. Un numero tale che b^n ≡ b mod n è detto pseudoprimo di Fermat rispetto alla base b. I numeri di Carmichael sono pseudoprimi di Fermat in ogni base, cioè assoluti.

I numeri di Carmichael passano in ogni caso il test di primalità di Fermat pur essendo composti: la loro esistenza impedisce di utilizzare questo test per certificare con sicurezza la primalità di un numero, mentre rimane utilizzabile per dimostrare che un numero è composto.

I numeri di Carmichael sono tutti dispari.

Scriviamo una funxione che controlla se un dato numero è un numero di Carmichael:

(define (fattorizza x)
  (letn (fattori (factor x)
         unici (unique fattori))
    (transpose (list unici (count unici fattori)))))
    ;(map list unici (count unici fattori))))

(fattorizza 45)
;-> ((3 2) (5 1))

(fattorizza 561)
;-> ((3 1) (11 1) (17 1))

(define (carmichael? n)
  (local (out fattori)
    (setq out true)
    (cond ((or (= n 1) (even? n) (= 1 (length (factor n)))) (setq out nil))
          (true
            (setq fattori (fattorizza n))
            (dolist (f fattori (= out nil))
              (if (> (f 1) 1) (setq out nil))
              (if (!= (% (- n 1) (- (f 0) 1)) 0) (setq out nil))
            )
          )
    )
    out
  )
)

Scriviamo una funzione che calcola i numeri di Carmichael fino al numero n:

(define (carmichael n)
  (let (out '())
    (for (i 3 n 2)
      (if (carmichael? i) (push i out -1))
    )
  out
  )
)

(carmichael 1000000)
;-> (561 1105 1729 2465 2821 6601 8911 10585 15841 29341 41041 46657 52633 62745 63973
;->  75361 101101 115921 126217 162401 172081 188461 252601 278545 294409 314821 334153
;->  340561 399001 410041 449065 488881 512461 530881 552721 656601 658801 670033 748657
;->  825265 838201 852841 997633)

(time (carmichael 1000000))
;-> 2043.545

(define (carmichael n)
  (filter carmichael? (sequence 3 n 2)))

(time (carmichael 1000000))
;-> 3510.422


------------------------------------------
RADICE QUADRATA INTERA DI UN NUMERO INTERO
------------------------------------------

Calcolare la radice quadrata intera di un numero n.

Primo metodo:

(define (isqrt1 n)
  (local (xn xn1)
    (setq xn 1)
    (setq xn1 (/ (+ xn (/ n xn)) 2))
    (while (> (abs (- xn1 xn)) 1)
      (setq xn xn1)
      (setq xn1 (/ (+ xn (/ n xn)) 2))
    )
    (while (> (* xn1 xn1) n) (-- xn1))
    xn1
  )
)

(isqrt1 900)
;-> 30

(isqrt1 899)
;-> 29

(isqrt1 6074020096)
;-> 77936

(time (map isqrt1 (sequence 2 1e6)))
;-> 4980.122

Test di correttezza:

(for (i 2 1e6) (if (!= (isqrt1 (* i i)) (sqrt (* i i))) (println "error: " (* i i)) ))
;-> nil

Secondo metodo (algoritmo babilonese):

(define (isqrt2 n)
  (let ((x n) (y 1))
    (while (> x y)
      (setq x (/ (+ x y) 2))
      (setq y (/ n x))
    )
    x
  )
)

(isqrt2 900)
;-> 30

(isqrt2 899)
;-> 29

(isqrt2 6074020096)
;-> 77936

(time (map isqrt2 (sequence 2 1e6)))
;-> 3630.086

Test di correttezza:

(for (i 2 1e6) (if (!= (isqrt2 (* i i)) (sqrt (* i i))) (println "error: " (* i i)) ))
;-> nil

Terzo metodo:

(define (isqrt3 n) (int (sqrt n)))

(isqrt3 900)
;-> 30

(isqrt3 899)
;-> 29

(isqrt3 6074020096)
;-> 77936

(time (map isqrt3 (sequence 2 1e6)))
;-> 150.086

Test di correttezza:

(for (i 2 1e6) (if (!= (isqrt3 (* i i)) (sqrt (* i i))) (println "error: " (* i i)) ))
;-> nil

Quarto metodo (big integer):

(define (isqrt4 n)
  (catch
    (local (start mid end out)
      (setq start 1L)
      (setq end (bigint (/ n 2)))
      (while (<= start end)
        (setq mid (/ (+ start end) 2))
        (if (= n (* mid mid)) (throw mid))
        (if (< (* mid mid) n)
          (begin (setq start (+ mid 1)) (setq out mid))
          (setq end (- mid 1))
        )
      )
      (throw out)
    )
  )
)

oppure:

(define (isqrt4 n)
  (local (start mid end trovato out)
    (setq start 1L)
    (setq end (bigint (/ n 2)))
    (while (and (<= start end) (= trovato nil))
      (setq mid (/ (+ start end) 2))
      (if (= n (* mid mid))
          (begin (setq out mid) (setq trovato true))
          (if (< (* mid mid) n)
            (begin (setq start (+ mid 1)) (setq out mid))
            (begin (setq end (- mid 1))  (setq out mid)))
      )
    )
    out
  )
)

(isqrt4 900)
;-> 30L

(isqrt4 899)
;-> 29L

(isqrt4 6074020096)
;-> 77936L

(time (map isqrt4 (sequence 2 1e6)))
;-> 26274.627

Test di correttezza:

(for (i 2 1e6)
  (setq j (bigint i))
  (if (!= (isqrt4 (* j j)) (sqrt (* j j)))
    (begin (println "error: " (* j j)))))
;-> nil


-----------------------
COPPIE DI PRIMI GEMELLI
-----------------------

Due numeri sono primi gemelli se n e (n + 2) sono entrambi primi.
Le coppie di primi gemelli sono infinite, ma la loro frequenza diminuisce con l'aumentare di n.

Usiamo la seguente funzione per verificare se un numero n è primo:

(define (primo? n)
  (if (even? n) nil
      (= 1 (length (factor n)))))

(primo? 11)
;-> true

Definiamo una funzione per verificare se un numero n ha un gemello:

(define (gemelli? n) (if (and (primo? n) (primo? (+ n 2)))))

(gemelli? 5)
;-> true

Definiamo una funzione che trova tutte le coppie di gemelli dal numero a (dispari) al numero b:

(define (coppieGemelli a b)
  (local (somma)
    (setq somma 0)
    ;(for (i a b) (if (gemelli? i) (println (++ somma) { } i { } (+ i 2))))
    (for (i a b 2) (if (gemelli? i) (++ somma)))
    somma
  )
)

Con: (for (i a b) (if (gemelli? i) (println (++ somma) { } i { } (+ i 2))))

(coppieGemelli 3 1000)
;-> 1 3 5         2 5 7
;-> 3 11 13       4 17 19
;-> 5 29 31       6 41 43
;-> 7 59 61       8 71 73
;-> 9 101 103     10 107 109
;-> 11 137 139    12 149 151
;-> 13 179 181    14 191 193
;-> 15 197 199    16 227 229
;-> 17 239 241    18 269 271
;-> 19 281 283    20 311 313
;-> 21 347 349    22 419 421
;-> 23 431 433    24 461 463
;-> 25 521 523    26 569 571
;-> 27 599 601    28 617 619
;-> 29 641 643    30 659 661
;-> 31 809 811    32 821 823
;-> 33 827 829    34 857 859
;-> 35 881 883

Con: (for (i a b 2) (if (gemelli? i) (++ somma)))

Calcoliamo la velocità della funzione:

(time (coppieGemelli 3 2e7))
;-> 46361.619

Adesso definiamo una funzione "pairs" che restituisce una lista con tutte le coppie di primi gemelli dal numero a al numero b.

Prima scriviamo la funzione "twin?" che dato un numero n restituisce la coppia di primi n e (n + 2) oppure nil:

(define (twin? n)
  (if (and (primo? n) (primo? (+ n 2)))
    (list n (+ n 2))
    nil
  )
)

(twin? 9)
;-> nil

(twin? 881)
;-> (881 883)

(define (pairs a b)
  (filter true? (map twin? (sequence a b)))
)

(pairs 3 1000)
;-> ((3 5) (5 7) (11 13) (17 19) (29 31) (41 43) (59 61) (71 73) (101 103) (107 109)
;->  (137 139) (149 151) (179 181) (191 193) (197 199) (227 229) (239 241) (269 271)
;->  (281 283) (311 313) (347 349) (419 421) (431 433) (461 463) (521 523) (569 571)
;->  (599 601) (617 619) (641 643) (659 661) (809 811) (821 823) (827 829) (857 859)
;->  (881 883))

(length (pairs 3 1000))
;-> 35

Calcoliamo la velocità della funzione:

(time (pairs 3 2e7))
;-> 47479.457

Adesso definiamo la stessa funzione, ma in modo imperativo:

(define (pairs-i a b)
  (local (idx out)
    (setq idx a)
    (while (< idx b)
      (if (and (primo? idx) (primo? (+ idx 2)))
        (push (list idx (+ idx 2)) out -1)
      )
      (++ idx 2)
    )
    out
  )
)

(length (pairs-i 3 1000))
;-> 35

(time (pairs-i 3 2e7))
;-> 44355.696

Adesso riscriviamo la funzione ottimizzata (non ricalcoliamo un numero primo quando troviamo una coppia):

(define (pairs-i a b)
  (local (idx found out)
    (setq found nil)
    (setq idx a)
    ; solo il numero 5 appartiene a due coppie di numeri primi gemelli
    (setq out '((3 5) (5 7)))
    (while (< idx b)
      (if (and (primo? idx) (primo? (+ idx 2)))
        (begin
        (push (list idx (+ idx 2)) out -1)
        (setq found true))
      )
      (if found (++ idx 4) (++ idx 2))
      (setq found nil)
    )
    out
  )
)

(length (pairs-i 7 1000))
;-> 35

(time (pairs-i 7 2e7))
;-> 43177.908

Questo è il miglior risultato ottenuto in termini di velocità.

Cerchiamo di capire dove la funzione spende il tempo maggiore. Proviamo a testare solo la parte che calcola i numeri primi:

(define (test-a a b)
  (local (idx out)
    (setq idx a)
    (while (< idx b)
      (if (and (primo? idx) (primo? (+ idx 2))))
      (++ idx 2)
    )
  )
)

(time (test-a 3 2e7))
;-> 44295.723

Come avevamo intuito, quasi tutto il tempo di esecuzione della funzione è dedicato al calcolo dei numeri primi.

Calcoliamo la distanza tra le coppie di numeri primi:

(define (dist-pairs a b)
  (local (idx base out)
    (setq idx a)
    (setq base 3)
    (while (< idx b)
      (if (and (primo? idx) (primo? (+ idx 2)))
        (begin
          (push (- idx base) out -1)
          (setq base idx))
      )
      (++ idx 2)
    )
    out
  )
)

(dist-pairs 5 1000)
;-> (2 6 6 12 12 18 12 30 6 30 12 30 12 6 30 12 30 12
;->  30 36 72 12 30 60 48 30 18 24 18 150 12 6 30 24)

(silent (setq dp6 (dist-pairs 5 1e6)))
(length dp6)
;-> 8168

Infine salviamo dp6 come file di testo (per esempio per plottare i dati con un altro programma):

(save "dist-coppie.txt" 'dp6)
;-> true

Sul forum di newLISP, raph.ronnquist ha fornito due funzioni per calcolare le coppie:

(define (pairs-i a b)
  (let ((out (list)) (x nil))
    (for (y (if (odd? a) a (inc a)) b 2)
      (if (1 (factor y)) (setf y nil) x (push (list x y) out -1))
      (setf x y))
    out))

(length (pairs-i 3 1000))
;-> 35

(time (pairs-i 3 2e7))
;-> 40072.606

La seconda funzione sfrutta la seguente idea. Per migliorare la velocità (nei numeri grandi) possiamo controllare se il modulo di un generico prodotto di primi include uno dei numeri primi del prodotto.
Il codice è il seguente:

(define (pairs-i1 a b)
  (let ((out (list)) (x nil) (FX (* 2 3 5 7 11 13)) (M 0))
    (for (y (if (odd? a) a (inc a)) b 2)
      (if (if (< y FX) (1 (factor y))
             (or (= (setf M (% y FX))) (if (factor M) (<= ($it 0) 13)) (1 (factor y))))
        (setf y nil)
        x (push (list x y) out -1))
      (setf x y))
    out))

In questo esempio viene utilizzato il prodotto di primi (* 2 3 5 7 11 13). Per numeri maggiori di questo, controlla se il modulo è un prodotto di uno di quei numeri primi, nel qual caso il numero nel suo insieme è divisibile per quel numero primo (e quindi non è un numero primo). In particolare, la fattorizzazione del modulo è in genere più veloce perchè filtra tutti i numeri controllati dal modulo.

(time (pairs-i1 3 2e7))
;-> 29964.396

Il miglioramento di velocità per la gestione di grandi numeri è significativo (+ 25%).


----------------
NUMERI SEMIPRIMI
----------------

Un numero semi-primo è un numero che è il prodotto di due numeri primi.
Algoritmo:
1) Trovare un divisore del numero d1.
2) Dividere il numero per d1 per ottenere un secondo divisore d2.
3) Se d1 e d2 sono entrambi primi, allora il numero originale è semiprimo.
4) ripetere 1), 2) e 3) per tutti i divisori del numero.

Scriviamo una funzione che verifica se un numero è primo:

(define (primo? n)
  (if (and (!= n 2) (even? n)) nil
      (= 1 (length (factor n)))))

Scriviamo una funzione che verifica se un numero è semiprimo:

(define (semiprimo? num)
  (local (d2 out)
    (for (d1 2 (int (+ (sqrt num) 1)) 1 (= out true))
      (if (= (% num d1) 0)
        (setq d2 (/ num d1)
              out (and (primo? d1) (primo? d2)))
      )
    )
    out
  )
)

(semiprimo? 21)
;-> true

(semiprimo? 4)
;-> true

Scriviamo una funzione che calcola i numeri semiprimi fino a n:

(define (semiprimi n)
  (let (out '())
    (for (i 2 n)
      (if (semiprimo? i) (push i out -1))
    )
  out
  )
)

(semiprimi 100)
;-> (4 6 9 10 14 15 21 22 25 26 33 34 35 38 39 46 49 51 55
;->  57 58 62 65 69 74 77 82 85 86 87 91 93 94 95)

(length (semiprimi 1000))
;-> 299

(time (map semiprimi (sequence 10 1000)))
;-> 1473.389

Per migliorare la velocità possiamo inglobare il controllo dei numeri primi all'interno del ciclo while:

(define (semiprimo? num)
  (let ((cnt 0) (i 2))
    (while (and (< cnt 2) (<= (* i i) num))
      (while (zero? (% num i))
        (setq num (/ num i))
        (++ cnt)
      )
      (++ i)
    )
    (if (> num 1) (++ cnt))
    (= cnt 2)
  )
)

(semiprimi 100)
;-> (4 6 9 10 14 15 21 22 25 26 33 34 35 38 39 46 49 51 55
;->  57 58 62 65 69 74 77 82 85 86 87 91 93 94 95)

(length (semiprimi 1000))
;-> 299

(time (map semiprimi (sequence 10 1000)))
;-> 1056.916


--------------
NUMERI COPRIMI
--------------

Due numeri a e b sono detti coprimi (o primi tra loro o relativamente primi) se e solo se essi non hanno nessun divisore comune eccetto 1 e -1 o, in modo equivalente, se il loro massimo comune divisore è 1, cioè MCD(a,b) = 1.

(define (coprimi? a b) (= (gcd a b) 1))

(coprimi? 10 11)

(define (coprimi n)
  (let ((out '()))
    (for (i 0 n)
      (for (j i n)
      ;(for (j (+ i 1) n)
        (if (coprimi? i j) (push (list i j) out -1))
      )
    )
    out
  )
)

(coprimi 10)
;-> ((0 1) (1 1) (1 2) (1 3) (1 4) (1 5) (1 6) (1 7) (1 8) (1 9)
;->  (1 10) (2 3) (2 5) (2 7) (2 9) (3 4) (3 5) (3 7) (3 8) (3 10)
;->  (4 5) (4 7) (4 9) (5 6) (5 7) (5 8) (5 9) (6 7) (7 8) (7 9)
;->  (7 10) (8 9) (9 10))

Due teoremi interessanti sui numeri coprimi:

Teorema: Numeri naturali consecutivi n e (n + 1) sono sempre coprimi.

(coprimi? 310 311)
;-> true

Teorema: La probabilità che due interi scelti a caso siano coprimi tra loro è 6/(π^2).

Un altro metodo per calcolare tutte le coppie di coprimi è quello di utilizzare la sequenza di Farey.
La sequenza di Farey F(n), per ogni numero naturale positivo n, è definita come l'insieme ordinato secondo l'ordine crescente di tutti i numeri razionali irriducibili (cioè tali che numeratore e denominatore siano coprimi) espressi sotto forma di frazione con numeratore e denominatore compresi tra zero e n.

La seguente funzione genera la n-esima sequenza di Farey in ordine crescente o decrescente:

(define (farey n desc)
  (local (a b c d k p q out)
    (setq out '())
    (setq a 0 b 1 c 1 d n)
    ;(println a { } b)
    (if desc (setq a 1 c (- n 1)))
    (push (list a b) out -1)
    (while (or (and (<= c n) (not desc)) (and (> a 0) desc))
      (setq k (int (div (+ n b) d)))
      (setq p (- (* k c) a))
      (setq q (- (* k d) b))
      (setq a c b d c p d q)
      (push (list a b) out -1)
      ;(println a { } b)
    )
    out
  )
)

(farey 3)
;-> ((0 1) (1 3) (1 2) (2 3) (1 1))

(farey 10)
;-> ((0 1) (1 10) (1 9) (1 8) (1 7) (1 6) (1 5) (2 9) (1 4) (2 7)
;->  (3 10) (1 3) (3 8) (2 5) (3 7) (4 9) (1 2) (5 9) (4 7) (3 5)
;->  (5 8) (2 3) (7 10) (5 7) (3 4) (7 9) (4 5) (5 6) (6 7) (7 8)
;->  (8 9) (9 10) (1 1))

Verifichiamo che le due funzioni "coprimi" e "farey" generano le stesse sequenze :

(= (coprimi 100) (sort (farey 100)))
;-> true

Vediamo la differenza delle due funzioni in termini di velocità:

(time (map coprimi (sequence 10 500)))
;-> 6391.329

(time (map farey (sequence 10 500)))
;-> 7297.73

Ottimizziamo un pò la funzione "farey":

(define (farey1 n)
  (local (a b c d k p q out)
    (setq out '())
    (setq a 0 b 1 c 1 d n)
    ;(println a { } b)
    (push (list a b) out -1)
    ;(while (or (and (<= c n) (not desc)) (and (> a 0) desc))
    (while (<= c n)
      ;(setq k (int (div (+ n b) d)))
      (setq k (/ (+ n b) d))
      (setq p (- (* k c) a))
      (setq q (- (* k d) b))
      (setq a c b d c p d q)
      (push (list a b) out -1)
      ;(println a { } b)
    )
    out
  )
)

(= (coprimi 100) (sort(farey1 100)))
;-> true

(time (map farey1 (sequence 10 500)))
;-> 6469.966

Le due funzioni hanno la stessa velocità.

Insiemi di numeri coprimi
-------------------------
Un insieme di interi S = {a1, a2, .... an} può anche essere chiamato coprimo o "setwise coprimo" se il massimo comune divisore di tutti gli elementi dell'insieme è 1. Ad esempio, gli interi 6, 10, 15 sono coprimi perché 1 è l'unico numero intero positivo che li divide tutti.
Se ogni coppia in un insieme di interi è coprimo, allora l'insieme è detto coprimo a coppie o "pairwise coprimo". Un insieme di interi S = {a1, a2, .... an} è "pairwise coprimo" se il minimo comune multiplo di tutti i numeri è uguale al prodotto di tutti i numeri.
La condizione paiwise coprimo è più forte della condizione setwise coprimo. Ogni insieme finito pairwise coprimo è anche setwise coprimo, ma non è vero il contrario. Ad esempio, gli interi 4, 5, 6 sono (setwise) coprimi (perché l'unico intero positivo che li divide tutti è 1), ma non sono coprimi a coppie (perché mcd (4, 6) = 2).
Il concetto di coprimalità a coppie è importante come ipotesi in molti risultati nella teoria dei numeri, come il teorema cinese dei resti.
È possibile che un insieme infinito di interi sia coprimo a coppie, ad esempio l'insieme di tutti i numeri primi.


-------------------------------------------------
FATTORIZZAZIONE DI UN NUMERO INTERO (BIG INTEGER)
-------------------------------------------------

La fattorizzazione a ruota è un miglioramento del metodo della divisione di prova per la fattorizzazione a numeri interi.

Il metodo della divisione di prova consiste nel dividere il numero da fattorizzare successivamente per i primi numeri interi (2, 3, 4, 5, ...) fino a trovare un divisore. Con la fattorizzazione a ruota, si parte da una lista (base) dei primi numeri primi. Quindi si genera l'elenco, chiamato la ruota, degli interi che sono coprimi con tutti i numeri della base. Quindi, per trovare il divisore più piccolo del numero da fattorizzare, lo si divide in successione per i numeri nella base e nella ruota.

Con la base {2, 3}, questo metodo riduce il numero di divisioni a 1/3 <34% del numero necessario per la divisione di prova. Basi più grandi riducono ulteriormente questa proporzione. Ad esempio, con base da {2, 3, 5} a 8/30 <27%, mentre con una base da {2, 3, 5, 7} a 48/210 <23%.

Esempio

Con la base dei primi 3 numeri primi {2, 3, 5}, il "primo giro" della ruota è costituito da:

7, 11, 13, 17, 19, 23, 29, 31.

Il secondo giro si ottiene aggiungendo il prodotto della base 2 * 3 * 5 = 30, ai numeri del primo giro. Il terzo giro si ottiene aggiungendo 30 al secondo giro e così via.
Da notare che gli incrementi tra due elementi consecutivi della ruota, cioè

dist = [4, 2, 4, 2, 4, 6, 2, 6],

rimangono gli stessi dopo ogni giro.

Nota: (setq MAXINT 9223372036854775807)

Scriviamo la funzione per fattorizzare un numero:

(define (factorbig n)
  (local (f k i dist out)
    ; distanze tra due elementi consecutivi della ruota (wheel)
    (setq dist '(0 4 2 4 2 4 6 2 6))
    (setq out '())
    (while (zero? (% n 2))
      (push '2L out -1)
      (setq n (/ n 2)))
    (while (zero? (% n 3))
      (push '3L out -1)
      (setq n (/ n 3)))
    (while (zero? (% n 5))
      (push '5L out -1)
      (setq n (/ n 5)))
    (setq k 7L i 1)
    (while (<= (* k k) n)
      (if (zero? (% n k))
        (begin
        (push k out -1)
        (setq n (/ n k)))
        (begin
        (setq k (+ k (dist i)))
        (if (< i 8) (++ i) (setq i 1)))
      )
    )
    (if (> n 1) (push (bigint n) out -1))
    out
  )
)

(factorbig 9223372036854775809L)
;-> (3L 3L 3L 19L 43L 5419L 77158673929L)

(time (factorbig 9223372036854775809L))
;-> 50.947

(apply * '(3L 3L 3L 19L 43L 5419L 77158673929L))
;-> 9223372036854775809L

Controlliamo se "factorbig" e "factor" producono lo stesso risultato (fino ad un milione):

(= (map factorbig (sequence 2 1e6)) (map factor (sequence 2 1e6)))
;-> true

Proviamo con un numero di 20 cifre:

(time (println (factorbig 92233720368547758091L)))
;-> (7L 13L 1013557366687338001L)
;-> 182879.379 ; 3 minuti e 2 secondi

(apply * '(7L 13L 1013557366687338001L))
;-> 92233720368547758091L

Più è grande il valore dei fattori maggiore è il tempo di esecuzione.

(time (println (factorbig 1013557366687338001L)))
;-> (1013557366687338001L)
;-> 179855.465 ; 3 minuti

Invece nel seguente esempio il calcolo è immediato:

2^64 = 18446744073709551616

(setq d 18446744073709551616L)

(factorbig d)
;-> (2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L
;->  2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L
;->  2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L
;->  2L 2L 2L 2L)

Calcoliamo la differenza di velocità tra "factorbig" e "factor":

(time (map factorbig (sequence 2 1e5)))
;-> 1453.157

(time (map factor (sequence 2 1e5)))
;-> 78.108

(time (map factorbig (sequence 2 1e6)))
;-> 33469.801 ; 33 secondi

(time (map factor (sequence 2 1e6)))
;-> 1027.95

La funzione integrata "factor" è molto più veloce, ma non funzione con i big integer.

Possiamo migliorare le prestazioni della funzione utilizzando una base più grande:

(2 3 5 7)

Vediamo come calcolare la lista delle distanze. Prima occorre generare i numeri della ruota, cioè tutti gli interi coprimi con la base fino al numero (+ (* 2 3 5 7) 11) = 221

Funzione per calcolare i coprimi:

(define (coprimi? a b) (= (gcd a b) 1))

Funzione che verifica se un numero appartiene alla ruota:

(define (wheel7 n) (and (coprimi? n 2) (coprimi? n 3) (coprimi? n 5) (coprimi? n 7)))

Funzione che crea la ruota dei numeri:

(define (dowheel7)
  (let (out '())
    (for (i 2 221) (if (wheel7 i) (push i out -1)))
  )
)

(dowheel7)
;-> (11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113
;->  121 127 131 137 139 143 149 151 157 163 167 169 173 179 181 187 191 193 197 199
;->  209 211 221)

Per calcolare le distanze tra due elementi consecutivi della ruota usiamo la seguente funzione:

(define (creadist lst) (map - (rest lst) (chop lst)))

(creadist (dowheel7))
;-> (2 4 2 4 6 2 6 4 2 4 6 6 2 6 4 2 6 4 6 8 4 2 4 2 4 8 6 4 6 2 4 6 2 6 6 4 2 4 6 2
;-> 6 4 2 4 2 10 2 10)

Adesso possiamo scrivere la nuova funzione di fattorizzazione con base (2 3 5 7):

(define (factorbig n)
  (local (f k i dist out)
    ; Distanze tra due elementi consecutivi della ruota (wheel)
    (setq dist (array 48 '(2 4 2 4 6 2 6 4 2 4 6 6 2 6 4 2 6 4
                           6 8 4 2 4 2 4 8 6 4 6 2 4 6 2 6 6 4
                           2 4 6 2 6 4 2 4 2 10 2 10)))
    (setq out '())
    (while (zero? (% n 2)) (push '2L out -1) (setq n (/ n 2)))
    (while (zero? (% n 3)) (push '3L out -1) (setq n (/ n 3)))
    (while (zero? (% n 5)) (push '5L out -1) (setq n (/ n 5)))
    (while (zero? (% n 7)) (push '7L out -1) (setq n (/ n 7)))
    (setq k 11L i 0)
    (while (<= (* k k) n)
      (if (zero? (% n k))
        (begin
        (push k out -1)
        (setq n (/ n k)))
        (begin
        ;(++ k (dist i))
        (setq k (+ k (dist i)))
        (if (< i 47) (++ i) (setq i 0)))
      )
    )
    (if (> n 1) (push (bigint n) out -1))
    out
  )
)

(factorbig 9223372036854775809L)
;-> (3L 3L 3L 19L 43L 5419L 77158673929L)

(time (factorbig 9223372036854775809L))
;-> 46.875

(apply * '(3L 3L 3L 19L 43L 5419L 77158673929L))
;-> 9223372036854775809L

Controlliamo se "factorbig" e "factor" producono lo stesso risultato (fino ad un milione):

(= (map factorbig (sequence 2 1e5)) (map factor (sequence 2 1e5)))
;-> true
(= (map factorbig (sequence 2 1e6)) (map factor (sequence 2 1e6)))
;-> true

Proviamo con un numero di 20 cifre:

(time (println (factorbig 92233720368547758091L)))
;-> (7L 13L 1013557366687338001L)
;-> 150515.93

Questa funzione "factorbig" impiega 30 secondi in meno di quella precedente (con la base (2 3 5) la funzione impiegava 180 secondi).

Calcoliamo la differenza di velocità tra "factorbig" e "factor":

(time (map factorbig (sequence 2 1e5)))
;-> 1406.559

(time (map factor (sequence 2 1e5)))
;-> 78.108

(time (map factorbig (sequence 2 1e6)))
;-> 28834.221 ; 29 secondi

(time (map factor (sequence 2 1e6)))
;-> 1027.95


------------------------------------------
POTENZA DI DUE NUMERI INTERI (BIG INTEGER)
------------------------------------------

Utilizziamo una soluzione ricorsiva per calcolare x^n usando il metodo divide & conquer:

power(x, n) =     power(x, n/2) * power(x, n/2)     (se n è pari)
power(x, n) = x * power(x, n/2) * power(x, n/2)     (se n è dispari)

(define (ipow x n)
  (cond ((zero? n) 1)
        ((even? n) (ipow (* x x) (/ n 2)))
        (true (* x (ipow (* x x) (/ (- n 1) 2))))))

(ipow 3 7)
;-> 2187

(ipow -2 15)
;-> -32768

Il metodo può essere migliorato notando che calcoliamo due volte lo stesso sotto-problema (power (x, n/2) per ogni chiamata ricorsiva. Possiamo ottimizzare la funzione calcolando e memorizzando la soluzione del sotto-problema solo una volta.

(define (ipow x n)
  (local (pot out)
    (if (zero? n)
        (setq out 1L)
        (begin
          (setq pot (ipow x (/ n 2)))
          (if (odd? n) (setq out (* x pot pot))
                       (setq out (* pot pot)))
        )
    )
    out
  )
)

(ipow -2 15)
;-> -32768

Controlliamo se la soluzione genera gli stessi risultati della funzione built-in pow(n m):

(for (i 1 15)
  (for (j 1 15)
    (if (!= (pow i j) (ipow i j))
      (println "error: " i ", " j))
  )
)
;-> nil

(setq MAXINT 9223372036854775807)

(ipow 10 53)
;-> -8169529724050079744 ;errore di overflow

Passando gli argomenti come big integer otteniamo il risultato corretto:

(ipow 10L 53L)
;-> 100000000000000000000000000000000000000000000000000000L

(ipow 3L 8L)
;-> 6561L

Complessità temporale: O(log(n))

Potete trovare un algoritmo più efficiente che utilizza il metodo delle "addiction chain" nel libro di Donald Knuth "The Art of Computer Programming".

Questa è una versione brute-force fornita da Lutz su forum di newLISP:

(define (** x p)
    (let (y 1L)
        (dotimes (i p)
            (set 'y (* y x)))))

(** 10 53)
;-> 100000000000000000000000000000000000000000000000000000L

(= (ipow 10L 53L) (** 10 53))
;-> true

(time (ipow 12345L 12345L) 100)
;-> 2572.051

(time (** 12345L 12345L) 100)
;-> 9752.167


--------------------
NUMERI DI TRIBONACCI
--------------------

La serie tribonacci è una generalizzazione della sequenza di Fibonacci in cui ogni termine è la somma dei tre termini precedenti.

La sequenza Tribonacci:

0, 0, 1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504, 927, 1705, 3136, 5768, 10609, 19513, 35890, 66012, 121415, 223317, 410744, 755476, 1389537, 2555757, 4700770, 8646064, 15902591, 29249425, 53798080, 98950096, 181997601, 334745777, 615693474, 1132436852...

Forma generale del numero Tribonacci:

a(n) = a(n-1) + a(n-2) + a(n-3)

dove: a(0) = a(1) = 0, a(2) = 1

Scrivere una funzione che calcola l'n-esimo numero di Tribonacci.

Soluzione ricorsiva:

(define (trib n)
  (if (or (= n 2) (= n 1) (zero? n))
      0
      (if (= n 3)
          1
          (+ (trib (- n 1)) (trib (- n 2)) (trib (- n 3)))
      )
  )
)

(trib 10)
;-> 44

(map trib (sequence 1 10))
;-> (0 0 1 1 2 4 7 13 24 44)

Complessità temporale: O(2^n) (esponenziale)

Una soluzione migliore è utilizzare la programmazione dinamica (cioè memorizzando e poi utilizzando i valori calcolati precedentemente):

(define (trib n)
  (local (a b c val)
    (setq a 0 b 0 c 1 val 0)
    (if (or (= 0 n) (= n 1) (= n 2))
        (setq val 0)
        (if (= n 3)
            (setq val 1)
            (for (i 3 (- n 1))
              (setq val (+ a b c))
              (setq a b b c c val)
            )
        )
    )
    val
  )
)

(map trib (sequence 1 10))
;-> (0 0 1 1 2 4 7 13 24 44)

Complessità temporale: O(n) (lineare)

Scriviamo una versione per i big-integer:

(define (trib-big n)
  (local (a b c val)
    (setq a 0L b 0L c 1L val 0L)
    (if (or (= 0 n) (= n 1) (= n 2))
        (setq val 0L)
        (if (= n 3)
            (setq val 1L)
            (for (i 3 (- n 1))
              (setq val (+ a b c))
              (setq a b b c c val)
            )
        )
    )
    val
  )
)

(trib-big 1000L)
;-> 443382579490226307661986241584270009256355236429858450381499235934108943134478901646797270328593836893366107162717822510963842586116043942479088674053663996392411782672993524690287662511197858910187264664163782145563472265666010074477859199789932765503984125240893L

Calcoliamo il limite del rapporto tra due numeri consecutivi di Tribonacci:

(div (trib-big 1000L) (trib-big 999L))
;-> 1.839286755214161

Esiste un algoritmo ancora più veloce che utilizza la moltiplicazioni tra matrici, ma la funzione "trib-big" è sufficientemente veloce.


-------------
NUMERI EUREKA
-------------

Un numero intero è un numero eureka se la somma delle potenze delle sue cifre, con le potenze crescenti in aumento, è uguale al numero stesso. Ad esempio, 89 è un numero eureka perché 8^1 + 9^2 = 89 e 1306 è un numero eureka perché 1^1 + 3^2 + 6^4 = 1306.
Scrivere una funzione per calcolare i numeri eureka fino al milione.
Maggiori informazioni:

https://oeis.org/A032799

Precalcoliamo i valori delle potenze (da 1 a 9) di ogni cifra. Per comodità creiamo una lista/matrice 10x10 "pot" in modo che si possa scrivere:

(pot 2 4)
;-> 16

(define (creapotenze)
  (let ((out '()) (row '()))
    (dotimes (i 10)
      (dotimes (j 10)
        (push (pow i j) row -1)
      )
      (push row out -1)
      (setq row '())
    )
    out
  )
)

(setq pot (creapotenze))
;-> ((1 0 0 0 0 0 0 0 0 0)
;->  (1 1 1 1 1 1 1 1 1 1)
;->  (1 2 4 8 16 32 64 128 256 512)
;->  (1 3 9 27 81 243 729 2187 6561 19683)
;->  (1 4 16 64 256 1024 4096 16384 65536 262144)
;->  (1 5 25 125 625 3125 15625 78125 390625 1953125)
;->  (1 6 36 216 1296 7776 46656 279936 1679616 10077696)
;->  (1 7 49 343 2401 16807 117649 823543 5764801 40353607)
;->  (1 8 64 512 4096 32768 262144 2097152 16777216 134217728)
;->  (1 9 81 729 6561 59049 531441 4782969 43046721 387420489))

Proviamo:

(pot 7 7)
;-> 823543

(pow 7 7)
;-> 823543

Da notare che possiamo calcolare numeri con al massimo 10 cifre, poichè la matrice "pot" contiene solo le prime dieci potenze (da 0 a 9) di ogni cifra (da 0 a 9).

Funzione che converte un intero in una lista di cifre

(define (int2list n)
  (let (out '())
    (while (!= n 0)
      (push (% n 10) out)
      (setq n (/ n 10))
    )
    out
  )
)

(define (eureka num)
  (local (somma d out)
    (setq out '())
    (setq somma 0)
    (for (i 0 num)
      (setq j i)
      ; valore della potenza della cifra meno significativa
      ; cioè la cifra più a destra
      (setq d (length (string j)))
      ; somma delle potenze di ogni cifra
      ; partendo dalla cifra meno significativa (da destra)
      ; stop somma se somma > i (è più lento !!!)
      ;(while (and (!= j 0) (<= somma i))
      (while (!= j 0)
        (setq somma (+ somma (pot (% j 10) d)))
        (setq j (/ j 10))
        (-- d)
      )
      ; numero eureka?
      (if (= i somma) (push i out -1))
      (setq somma 0)
    )
    out
  )
)

(eureka 1e6)
;-> (0 1 2 3 4 5 6 7 8 9 89 135 175 518 598 1306 1676 2427)

(time (eureka 1e6))
;-> 2226.745

(eureka 3e6)
;-> (0 1 2 3 4 5 6 7 8 9 89 135 175 518 598 1306 1676 2427 2646798)

(time (eureka 3e6))
;-> 7266.561

Proviamo a riscrivere la funzione in stile funzionale.

Funzione che converte un numero in un a lista di cifre:

(define (int2list n)
  (let (out '())
    (while (!= n 0)
      (push (% n 10) out)
      (setq n (/ n 10))) out))

Funzione che calcola i numeri eureka:

(define (eureka2 num)
  (let (out '())
    (dotimes (x num)
      (if (= x (apply + (map (fn (x) (pot x (+ $idx 1))) (int2list x))))
          (push x out -1)
      )
    )
    out
  )
)

(eureka2 1e6)
;-> (0 1 2 3 4 5 6 7 8 9 89 135 175 518 598 1306 1676 2427)

(time (eureka2 1e6))
;-> 2408

(eureka 3e6)
;-> (0 1 2 3 4 5 6 7 8 9 89 135 175 518 598 1306 1676 2427)

(time (eureka2 3e6))
;-> 7908.93

La versione iterativa è leggermente più veloce.

Il prossimo numero eureka vale: 12157692622039623539.
La nostra funzione non è in grado di calcolarlo...in tempo.

I numeri eureka sono un numero finito e l'ultimo termine ha un massimo di 22 cifre. Perchè?

Dato un numero naturale n di m cifre. Risulta che:

10^(m-1) <= n

e

n <= 9 + 9^2 + ... 9^m = 9*(9^m-1)/8 < (9^(m+1))/8

Quindi:

10^(m-1) < (9^(m+1))/8.

Facendo il logaritmo di entrambe le parti e risolvendo l'equazione si ottiene: m < 22.97.


-------------------
ABITAZIONI MULTIPLE
-------------------

Autore: Dinesman, 1968

I signori Baker, Cooper, Fletcher, Miller e Smith vivono su piani diversi in un condominio che ha cinque piani. Si conoscono le seguenti informazioni:

1) Baker non vive all'ultimo piano.
2) Cooper non vive al piano inferiore.
3) Fletcher non vive né al piano superiore né al piano inferiore.
4) Miller vive a un piano più alto di Cooper.
5) Smith non vive su un piano adiacente a quello di Fletcher.
6) Fletcher non vive su un piano adiacente a quello di Cooper.

Dove vivono tutti?

Possiamo risolvere questo problema utilizzando la funzione non-deterministica "amb".

(define (dove n)
  (local (i baker cooper fletcher miller smith found)
    (setq i 1 found nil)
    ; inizializzazione generatore random
    ; la funzione "amb" usa il generatore random
    (seed (time-of-day))
    (while (and (< i n) (= found nil))
      ; genera una disposizione random degli inquilini
      (setq baker (amb 1 2 3 4 5))
      (setq cooper (amb 1 2 3 4 5))
      (setq fletcher (amb 1 2 3 4 5))
      (setq miller (amb 1 2 3 4 5))
      (setq smith (amb 1 2 3 4 5))
      ; controllo dei vincoli
      (if (and (not (= baker 5))
               (not (= cooper 1))
               (not (= fletcher 5))
               (not (= fletcher 1))
               (> miller cooper)
               (not (= (abs (- smith fletcher)) 1))
               (not (= (abs (- fletcher cooper)) 1))
               (= (list baker cooper fletcher miller smith)
                  (unique (list baker cooper fletcher miller smith))))
          (begin ; soluzione trovata
            (setq found true)
            ; commentare println quando si usa la funzione "time"
            ;(println (list baker cooper fletcher miller smith))
            ;(println i)
          )
      )
      (++ i)
    )
    (if (not found)
        ; commentare println quando si usa la funzione "time"
        ;(println "...nessuna soluzione con " n " tentativi.")
        ;(println "...risolto.")
    )
  )
)

Il parametro n serve per limitare i tentativi di prova, altrimenti la funzione potrebbe girare all'infinito se la soluzione non esiste.

(dove 100)
;-> ...nessuna soluzione con 100 tentativi.

(dove 1000)
;-> (3 2 4 5 1)
;-> 293
;-> ...risolto

Il programma non è deterministico, infatti:

(dove 1000)
;-> ...nessuna soluzione con 1000 tentativi.

(dove 2000)
;-> ...nessuna soluzione con 2000 tentativi.

(dove 10000)
;-> (3 2 4 5 1)
;-> 224
;-> ...risolto.

(dove 10000)
;-> (3 2 4 5 1)
;-> 416
;-> ...risolto.

(dove 10000)
;-> (3 2 4 5 1)
;-> 3302
;-> ...risolto.

Un programma non deterministico ha un tempo di esecuzione variabile ogni volta che viene eseguito.

Possiamo scrivere anche una funzione deterministica che risolve il problema.
Numero di posizioni:
(* 5 5 5 5 5)
;-> 3125

(define (dove-d)
  (let (found nil)
    (for (baker 1 5 1 found)
     (for (cooper 1 5 1 found)
      (for (fletcher 1 5 1 found)
       (for (miller 1 5 1 found)
        (for (smith 1 5 1 found)
          ; controllo dei vincoli
          (if (and (not (= baker 5))
                   (not (= cooper 1))
                   (not (= fletcher 5))
                   (not (= fletcher 1))
                   (> miller cooper)
                   (not (= (abs (- smith fletcher)) 1))
                   (not (= (abs (- fletcher cooper)) 1))
                   (= (list baker cooper fletcher miller smith)
                      (unique (list baker cooper fletcher miller smith))))
              (begin ; soluzione trovata
                (setq found true)
                ; commentare println quando si usa la funzione "time"
                ;(println (list baker cooper fletcher miller smith))
              )
          );if
    )))));fors
    ; commentare println quando si usa la funzione "time"
    ;(if (not found) (println "nessuna soluzione."))
  );let
)

(dove-d)
;-> (3 2 4 5 1)

Vediamo la differenza di velocità tra le due funzioni.

Funzione non-deterministica (non ha un tempo di esecuzione costante):

(time (dove 100000) 1000)
;-> 1440.525

(time (dove 100000) 1000)
;-> 1126.112

Funzione deterministica (ha un tempo di esecuzione costante):

(time (dove-d) 1000)
;-> 838.496

(time (dove-d) 1000)
;-> 535.417

Comunque con diversi tentativi si possono ottenere risultati sorprendenti con la funzione non-deterministica:

(time (dove 100000) 1000)
;-> 392.759

In questo caso è stata più veloce della funzione deterministica.


------------------
TOZIENTE DI EULERO
------------------

La funzione φ (phi) di Eulero o funzione toziente, è una funzione definita, per ogni intero positivo n, come il numero degli interi compresi tra 1 e n che sono coprimi con n. Ad esempio, phi(8) = 4 poiché i numeri coprimi di 8 sono quattro: 1, 3, 5 e 7.

Funzione per verificare se due numeri sono coprimi:

(define (coprimi? a b) (= (gcd a b) 1))

Funzione per calcolare il toziente:

(define (toziente-coprimi num)
  (let (toz 0)
    (dotimes (i (- num 1))
      ;(println (+ i 1) { } num { } (coprimi? (+ i 1) num))
      (if (coprimi? (+ i 1) num)
          (++ toz)
          toz))))

(toziente-coprimi 8)
;-> 4
(toziente-coprimi 10090)
;-> 4032
(toziente-coprimi 5e6)
;-> 2000000

Questa funzione ha complessità temporale O(n).

Un'altro metodo per calcolare il toziente è quello di utilizzare la seguente formula:

phi(n) = n * [(1 - 1/p(1)) * (1 - 1/p(2)) * ... * (1 - 1/p(r))]

dove p(1), p(2), ... p(r) sono i fattori primi distinti del numero n.

Utilizzando la fattorizzazione, il problema ha la stessa complessità temporale di quella della fattorizzazione di un numero O(sqrt n).

(define (toziente-factor num)
  (let ((result num) (p 2))
    ; Per ogni fattore primo di n (fattore p),
    ; moltiplica il risultato per (1 - 1/p)
    (while (<= (* p p) num)
      ; Controlla se p è un fattore primo
      (if (= 0 (% num p))
          ; Se è vero, allora aggiorna num e il risultato
          (begin
          (while (= 0 (% num p)) (setq num (/ num p)))
          (setq result (mul result (sub 1 (div 1 p))))
          )
      )
      (++ p)
    )
    ; Se n ha un fattore primo maggiore di sqrt (n)
    ; (Può esserci al massimo uno di questi fattori primi)
    (if (> num 1)
        (setq result (mul result (sub 1 (div 1 num))))
    )
    (round result 0)
  )
)

(toziente-factor 8)
;-> 4
(toziente-factor 10090)
;-> 4032
(toziente-factor 5e6)
;-> 2000000

Per evitare i calcoli floating-point possiamo utilizzare il seguente metodo: contare tutti i fattori primi e i loro multipli e sottrarre questo conteggio da n per ottenere il valore della funzione toziente (i fattori primi e i multipli di fattori primi non hanno gcd = 1).

I passi da seguire sono i seguenti:

1) Inizializza il risultato come num
2) Considera ogni numero 'p' (dove 'p' varia da 2 a num).
    Se p divide n, procedi come segue
    a) Sottrai tutti i multipli di p da 1 a n (tutti i multipli di p
       hanno gcd maggiore di 1 (almeno p) con num)
    b) Aggiorna n dividendolo ripetutamente per p.
3) Se il valore ridotto di num è superiore a 1, rimuovi tutti i multipli
    di num dal risultato.

(define (toziente-factor-int num)
  (let ((result num) (i 2))
    (while (<= (* i i) num)
      (if (= 0 (% num i))
          (begin
          (while (= 0 (% num i)) (setq num (/ num i)))
          (setq result (- result (/ result i)))
          )
      )
      (++ i)
    )
    (if (> num 1)
        (setq result (- result (/ result num)))
    )
    result
  )
)

(toziente-factor-int 8)
;-> 4
(toziente-factor-int 10090)
;-> 4032
(toziente-factor-int 5e6)
;-> 2000000

Adesso scriviamo una nuova funzione per il calcolo del toziente utilizzando le primitive di newLISP (in stile LISP):

(define (toziente num)
    (if (= num 1) 1
    (round (mul num (apply mul (map (fn (x) (sub 1 (div 1 x))) (unique (factor num))))) 0)))

Calcola la lista dei fattori unici:
(unique (factor num))

Applica la funzione (1 - 1/p) agli elementi della lista dei fattori unici:
(map (fn (x) (sub 1 (div 1 x))) ...

Moltiplica n e tutti gli elementi della lista
(mul num (apply mul ...

(toziente 8)
;-> 4
(toziente 10090)
;-> 4032
(toziente 5e6)
;-> 200000

Non ci resta che verificare quale funzione è la più veloce.

(time (toziente-coprimi 5e6))
;-> 1325.904
(time (toziente-factor 5e6))
;-> 0
(time (toziente-factor-int 5e6))
;-> 0
(time (toziente 5e6))
;-> 0

Le ultime tre funzioni devono essere differenziate ripetendo il calcolo per un certo numero di volte (50000):

(time (toziente-factor 5e6) 50000)
;-> 119.114
(time (toziente-factor-int 5e6) 50000)
;-> 109.032
(time (toziente 5e6) 50000)
;-> 67.039

Il risultato è conforme alle aspettative logiche.


--------------
NUMERI VAMPIRI
--------------

Un numero del vampiro è un numero naturale composto v, con un numero pari di cifre n, che può essere fattorizzato in due interi x e y (chiamati zanne "faing") che non abbiano entrambi degli zeri finali e ognuno dei quali abbia n/2 cifre, dove v contiene precisamente tutte le cifre di x e y, in un ordine qualsiasi, contando la molteplicità.

Per esempio: 1260 è un numero del vampiro, le cui zanne sono 21 e 60 (dato che 21·60 = 1260): infatti, 1260 ha 4 cifre e 12 e 60 hanno entrambi 4/2 = 2 cifre, ed è inoltre formato da tutte le cifre di 21 e 60.

I primi numeri vampiro sono:

1260, 1395, 1435, 1530, 1827, 2187, 6880, 102510, 104260, 105210, 105264, 105750, 108135, 110758, 115672, 116725, 117067, 118440, 120600, 123354, 124483, 125248, 125433, 125460, 125500, ...

Proviamo a risolvere il problema con la forza bruta. Generiamo tutte le permutazioni delle cifre di un numero e poi verifichiamo se il prodotto tra la prima metà delle cifre della permutazione e la seconda metà delle cifre della permutazione è uguale al numero.

(define (list2int lst) (int (join (map string lst))))

(define (int2list n)  (map int (explode (string n))))

Funzione che calcola le permutazioni:

(define (perm lst)
  (local (i indici out)
    (setq indici (dup 0 (length lst)))
    (setq i 0)
    (setq out (list lst))
    (while (< i (length lst))
      (if (< (indici i) i)
          (begin
            (if (zero? (% i 2))
              (swap (lst 0) (lst i))
              (swap (lst (indici i)) (lst i)))
            (push lst out -1)
            (++ (indici i))
            (setq i 0))
          (begin
            (setf (indici i) 0)
            (++ i))))
    out))

Scriviamo la funzione:

(define (vampire n)
  (local (i-lst lun lst a b half)
    (for (i 1111 n)
      (setq i-lst (int2list i))
      (setq lun (length i-lst))
      (setq half (/ lun 2))
      (cond ((even? lun)
             (setq lst (unique (perm i-lst)))
             (dolist (el lst)
               (setq a (list2int (slice el 0 half)))
               (setq b (list2int (slice el half)))
               (if (= (* a b) i)
                 (println a { * } b { = } (* a b)))))))))

(vampire 2000)
;-> 21 * 60 = 1260
;-> 60 * 21 = 1260
;-> 93 * 15 = 1395
;-> 15 * 93 = 1395
;-> 41 * 35 = 1435
;-> 35 * 41 = 1435
;-> 51 * 30 = 1530
;-> 30 * 51 = 1530
;-> 21 * 87 = 1827
;-> 87 * 21 = 1827

(time (vampire 125000))
;-> 68708.184

Questo metodo è molto lento a causa della funzione che calcola le permutazioni.

Cerchiamo di risolvere il problema utilizzando le coppie di fattori.
Ogni numero può essere scomposto in fattori primi. Un fattore è quindi un qualsiasi sottoinsieme dei fattori primi moltiplicati tra loro. La coppia di fattori è il numero originale diviso per il fattore scelto.

Esempio:

Numero = 54
(factor 54)
;-> (2 3 3 3)
Sottoinsieme scelto = (2 3) = 2*3 = 6
Coppia di fattori = (6 (54 / 6)) = (6 9)

Per generare tutti i sottoinsiemi (tutti i fattori) utilizziamo la funzione "powerset-i":

(define (powerset-i lst)
  (define (loop res s)
    (if (empty? s)
      res
      (loop (append (map (lambda (i) (cons (first s) i)) res) res) (rest s))))
  (loop '(()) lst))

(factor 1260)
;-> (2 2 3 3 5 7)

(powerset-i (factor 1260))
;-> ((2 2 3 3 5 7) (2 2 3 3 5) (2 2 3 3 7) (2 2 3 3) (2 2 3 5 7) (2 2 3 5) (2 2 3 7)
;->  (2 2 3) (2 2 3 5 7) (2 2 3 5) (2 2 3 7)
;->  ...
;->  (5 7) (5) (7) ())

Per generare i fattori applichiamo la funzione moltiplicazione "*" a tutti gli elementi do ogni sotto-lista:

(setq r (map (fn(x) (apply * x)) (powerset-i (factor 1260))))
;-> (1260 180 252 36 420 60 84 12 420 60 84 12 140 20 28 4 630 90 126 18 210
;->  30 42 6 210 30 42 6 70 10 14 2 630 90 126 18 210 30 42 6 210 30 42 6 70
;->  10 14 2 315 45 63 9 105 15 21 3 105 15 21 3 35 5 7 1)

Di questa lista a noi interessano solo i numeri che sono lunghi 2 cifre e che dividendo il numero base (1260) generano un numero con due cifre:

(setq r (unique (filter (fn(x) (and (= (length x) 2) (= (length (/ 1260 x)) 2))) r)))
;-> (36 60 84 20 28 90 18 30 42 70 14 45 63 15 21 35)

Da questa lista possiamo creare le coppie di fattori e verificare se le cifre di queste coppie sono le stesse di quelle del numero:

(dolist (el r)
  (setq a el)
  (setq b (/ 1260 el))
    (if (= (sort (append (int2list a) (int2list b))) (sort '(1 2 6 0)))
      (println a { } b { } 1260)))

;-> 60 21 1260
;-> 21 60 1260

Adesso possiamo scrivere la nuova funzione che calcola i numeri vampiri fino a n:

(define (vampire2 n)
  (local (lst lst2 i-lst lun a b h)
    (for (i 1 n)
      ;(setq lun (length i-lst))
      (setq lun (length i))
      (cond ((even? lun)
             (setq i-lst (int2list i))
             (setq h (/ (length i) 2))
             (setq lst (map (fn(x) (apply * x)) (powerset-i (factor i))))
             (setq lst2 (unique (filter (fn(x) (and (= (length x) h) (= (length (/ i x)) h))) lst)))
             (dolist (el lst2)
               (setq a el)
               (setq b (/ i el))
                 (if (= (sort (append (int2list a) (int2list b))) (sort i-lst))
                   (println a { * } b { = } i))
             )
            )
      )
    )
  )
)

(vampire2 2000)
;-> 60 * 21 = 1260
;-> 21 * 60 = 1260
;-> 15 * 93 = 1395
;-> 93 * 15 = 1395
;-> 35 * 41 = 1435
;-> 41 * 35 = 1435
;-> 30 * 51 = 1530
;-> 51 * 30 = 1530
;-> 21 * 87 = 1827
;-> 87 * 21 = 1827

(time (vampire2 125000))
;-> 4734.965

Questo metodo è molto più veloce e la funzione potrebbe essere ottimizzata, oppure si potrebbe utilizzare un importante risultato teorico trovato da Pete Hartley:

  Se x · y è un numero vampiro, allora x · y == x + y (mod 9)

Prova:
Sia mod l'operatore modulo binario e d(x) la somma delle cifre decimali di x.
È noto che d(x) mod 9 = x mod 9, per tutti i valori di x.
Supponiamo che x · y sia un vampiro. Quindi contiene le stesse cifre di xey, in particolare d(x · y) = d(x) + d(y). Questo porta a:
(x · y) mod 9 = d(x · y) mod 9 = (d(x) + d(y)) mod 9 = (d(x) mod 9 + d(y) mod 9) mod 9
              = (x mod 9 + y mod 9) mod 9 = (x + y) mod 9

Le soluzioni alla congruenza sono (x mod 9, y mod 9) in ((0 0) (2 2) (3 6) (5 8) (6 3) (8 5)). Solo questi casi (6 su 81) devono essere testati nella ricerca di vampiri basata sul test di x · y per valori diversi di x e y.

Esempio:

(setq num 1260)

(define (faing? x y)
  (true? (find (list (% x 9) (% y 9))
               '((0 0) (2 2) (3 6) (5 8) (6 3) (8 5)))))

(faing? 12 60)
;-> true

Formula di Roushe e Rogers per generare numeri vampiri:

  1·10^(2n+3) + 524·10^(n+1) + 208 = (25·10^(n) + 1 · (40·10^n + 208)

Questa formula produce numeri vampiri con (2n + 4) cifre.

n = 2  ==>  10524208 = 2501 · 4208
n = 3  ==>  1005240208 = 25001 · 40208

Ma per adesso basta con i numeri vampiri.


----------------
IL GIOCO DEL NIM
----------------

Nim è un gioco in cui due persone alternativamente rimuovono alcuni elementi disposti in una serie di righe partendo da una posizione iniziale. Si inizia con una serie di righe contenenti un certo numero di elementi (il numero delle righe e degli elementi di ogni riga possono essere qualunque numero intero e sono concordati tra i giocatori all'inizio della partita). I giocatori, a turno, tolgono da una qualsiasi riga un numero di elementi a piacere, da uno a tutti. Vince chi toglie l'ultimo elemento presente. Non è possibile passare (saltare la mossa).
Esiste anche una variante chiamata Marienbad in cui chi toglie l'ultimo elemento perde.

Esempio di posizione iniziale:

        |          riga: 0 - elementi: 1
      | | |        riga: 1 - elementi: 3
    | | | | |      riga: 2 - elementi: 5
  | | | | | | |    riga: 3 - elementi: 7

La strategia di gioco è la seguente:

1) se (n1 xor n2 xor ... nk = 0), scegliere una mossa casuale valida (poichè non esiste una mossa vincente)

2) se (n1 xor n2 xor ... nk != 0), scegliere la mossa che rende (n1 xor n2 xor ... nk = 0).

Non svilupperemo un programma completo, ma solo le funzioni per giocare interattivamente.

Rappresentiamo una posizione con una lista: l'indice della lista rappresenta il numero di riga, mentre il relativo valore rappresenta il numero di elementi presenti nella riga.

Utilizzeremo due variabili globali per tenere traccia della posizione iniziale (*start*) e della posizione corrente (*current*): questo rende più semplice l'interazione con la REPL durante una partita

Esempio:
(setq *start* '(1 3 5 7))
(setq *current* '(0 2 3 7))

Funzione che stampa la posizione corrente:

(define (show-position)
  (local (triple)
    (setq big (apply max *start*))
    (setq space (map (fn(x) (+ big 1 (- x))) *start*))
    (setq triple (map list *start* *current* space))
    (dolist (el triple)
      (print (dup " " (el 2)))
      (print (dup ". " (- (el 0) (el 1))))
      (print (dup "| " (el 1)))
      (println)
    )
    '...
  )
)

Funzione per iniziare una nuova partita:

(define (nim start-position current-position)
  (setq *start* start-position)
  (setq *current* current-position)
  (show-position))

(nim '(1 3 5 7) '(1 3 5 7))
;->        |
;->      | | |
;->    | | | | |
;->  | | | | | | |
;-> ...

Funzione che calcola lo xor di una posizione:

(define (calc-xor position) (apply ^ position))

Funzione che verifica se una posizione è vincente per il giocatore di turno:
Se il calcolo dello xor della posizione attuale vale 0, allora non è una posizione vincente.
Se il calcolo dello xor della posizione attuale è diverso da zero, allora è una posizione vincente.
Da una posizione vincente la mossa vincente è quella che rende zero il calcolo dello xor della nuova posizione.

(define (canwin? position) (if (zero? (calc-xor position)) nil true))

Funzione che verifica la fine del gioco:

(define (game-end?)
  (if (zero? (apply + *current*)) true nil))

Funzione che genera e applica una mossa del computer alla posizione corrente:

(define (move-ai)
  (local (found sol)
    ; ricerca una mossa vincente
    (setq found nil)
    (dolist (el *current* found)
      (if (!= el 0)
        (for (i 1 el 1 found)
          (setq test *current*)
          (setq (test $idx) (- el i))
          (if (not (canwin? test))
            (begin
              (setq sol (list $idx i))
              (setq found true)))
        )
      )
    )
    ; se non esiste alcuna mossa vincente,
    ; allora genera una mossa casuale valida.
    ; Toglie un elemento dalla prima riga non vuota...
    (dolist (el *current* found)
      (if (not (zero? el)) (begin
          (setq sol (list $idx 1))
          (setq found true)))
    )
    (if found (begin
        (setf (*current* (first sol)) (- (*current* (first sol)) (last sol)))
        (println "row: " (first sol) { - } "elementi: " (last sol))
        (show-position *start* *current*)
        (if (game-end?) (println "I WIN !!!"))
        )
        (println "Error: search move"))
  )
)

Funzione che applica una mossa dell'utente alla posizione corrente:

(define (move-human mossa)
  (local (ok riga elementi)
    (setq ok nil)
    (until ok
      (setq out mossa)
      (cond ((!= 2 (length out))
             (setq ok true)
             (println "Error: only two value"))
            (true
             (setq riga (first out))
             (setq elementi (last out))
             (cond ((or (not (integer? riga)) (not (integer? elementi)))
                    (setq ok true)
                    (println "Error: only integer value"))
                   ((>= riga (length *current*))
                    (setq ok true)
                    (println "Error: row not found: " riga))
                   ((> elementi (*current* riga))
                    (setq ok true)
                    (println "Error: can't remove " elementi " elements from row " riga))
                   (true ; applica la mossa (validata) alla posizione corrente
                     (setq ok true)
                     (setf (*current* riga) (- (*current* riga) elementi))
                     (println "row: " riga { - } "elementi: " elementi)
                     (show-position *start* *current*)
                     (if (game-end?) (println "YOU WIN !!!"))
                   )
             )
            )
       )
     )
  )
)

Giochiamo una partita:

(nim '(1 3 5 7) '(1 3 5 7))
;->        |
;->      | | |
;->    | | | | |
;->  | | | | | | |
;-> ...

(canwin? '(1 3 5 7))
;-> nil

(move-human '(0 1))
;-> row: 0 - elementi: 1
;->        .
;->      | | |
;->    | | | | |
;->  | | | | | | |

(move-ai)
row: 1 - elementi: 1
;->        .
;->      . | |
;->    | | | | |
;->  | | | | | | |
;-> ...

(move-human '(3 6))
;-> row: 3 - elementi: 6
;->        .
;->      . | |
;->    | | | | |
;->  . . . . . . |
;-> ...

(move-ai)
;-> row: 2 - elementi: 2
;->        .
;->      . | |
;->    . . | | |
;->  . . . . . . |
;-> ...

(move-human '(2 1))
;-> row: 2 - elementi: 1
;->        .
;->      . | |
;->    . . . | |
;->  . . . . . . |
;-> ...

(move-ai)
;-> row: 3 - elementi: 1
;->        .
;->      . | |
;->    . . . | |
;->  . . . . . . .
;-> ...

(move-human '(2 2))
;-> row: 2 - elementi: 2
;->        .
;->      . | |
;->    . . . . .
;->  . . . . . . .
;-> ...

(move-ai)
;->        .
;->      . . .
;->    . . . . .
;->  . . . . . . .
;-> I WIN !!!


------------------------------
FIBONACCI SEQUENZE DI N-NUMERI
------------------------------

Scrivere una funzione per generare le sequenze di Fibonacci in base al valore di n.

 n   Nome         Valori
 2   fibonacci    1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 ...
 3   tribonacci   1 1 2 4 7 13 24 44 81 149 274 504 927 1705 3136 ...
 4   tetranacci   1 1 2 4 8 15 29 56 108 208 401 773 1490 2872 5536 ...
 5   pentanacci   1 1 2 4 8 16 31 61 120 236 464 912 1793 3525 6930 ...
 6   hexanacci    1 1 2 4 8 16 32 63 125 248 492 976 1936 3840 7617 ...
 7   heptanacci   1 1 2 4 8 16 32 64 127 253 504 1004 2000 3984 7936 ...
 8   octonacci    1 1 2 4 8 16 32 64 128 255 509 1016 2028 4048 8080 ...
 9   nonanacci    1 1 2 4 8 16 32 64 128 256 511 1021 2040 4076 8144 ...
10   decanacci    1 1 2 4 8 16 32 64 128 256 512 1023 2045 4088 8172 ...

La funzione "iterate" crea una lista applicando n volte una funzione ad una lista iniziale.
Vediamo il funzionamento in particolare con un esempio:

- la lista iniziale vale (1 2 3)
- la funzione da applicare è "+"
- il numero di iterazioni vale 3

1. applichiamo la funzione alla lista: (apply + '(1 2 3)) = 4
2. aggiungiamo il valore (4) alla lista: (1 2 3 4)
3. applichiamo la funzione alla lista,
   prendendo solo gli ultimi 3 elementi della lista: (apply + '(2 3 4)) = 9
   (perchè la lista iniziale aveva tre elementi)
4. continua come al punto 2 per la prossima iterazione.

La funzione può essere scritta nel seguente modo:

(define (iterate iter func lst)
  (let ((out lst)
        (cur '())
        (len (length lst)))
    (dotimes (x iter)
      (setq cur (slice out (- len)))
      (push (apply func cur) out -1)
    )
    out))

Oppure in modo più conciso:

(define (iterate iter func lst)
  (let ((out lst) (len (length lst)))
    (dotimes (x iter)
      (push (apply func (slice out (- len))) out -1)
    )
    out))

Vediamo il nostro esempio:

(iterate 5 + '(1 2 3))
;-> (1 2 3 6 11 20 37 68)

Invece per calcolare i numeri Pentabonacci:

(iterate 10 + '(0 1 1 2 4))
;-> (0 1 1 2 4 8 16 31 61 120 236 464 912 1793 3525)

(iterate 20 + '(0 1 1 2 4))
;-> (0 1 1 2 4 8 16 31 61 120 236 464 912 1793 3525 6930 13624
;->  26784 52656 103519 203513 400096 786568 1546352 3040048)

Numeri di Fibonacci:

(iterate 10 + '(1 1))
;-> (1 1 2 3 5 8 13 21 34 55 89 144)

Numeri di Tribonacci:

(iterate 10 + '(0 0 1))
;-> (0 0 1 1 2 4 7 13 24 44 81 149 274)

Possiamo usare anche altre funzioni:

(iterate 10 - '(0 1 1 2 4))
;-> (0 1 1 2 4 -8 2 1 3 6 -20 12 0 5 9)

Per utilizzare i numeri big-integer:

(iterate 100 + '(0L 1L 1L 2L 4L))
;-> (0L 1L 1L 2L 4L 8L 16L 31L 61L 120L 236L 464L
;->  ...
;->  930350798981478627292926391581L)

Vediamo le sequenze di Fibonacci:
n = 2
(iterate 10 + '(1 1))
;-> (1 1 2 3 5 8 13 21 34 55 89 144)
n = 3
(iterate 10 + '(1 1 2))
;-> (1 1 2 4 7 13 24 44 81 149 274 504 927)
n = 4
(iterate 10 + '(1 1 2 4))
;-> (1 1 2 4 8 15 29 56 108 208 401 773 1490 2872)
n = 5
(iterate 10 + '(1 1 2 4 8))
;-> (1 1 2 4 8 16 31 61 120 236 464 912 1793 3525 6930)
n = 6
(iterate 10 + '(1 1 2 4 8 16))
;-> (1 1 2 4 8 16 32 63 125 248 492 976 1936 3840 7617 15109)
n = 7
(iterate 10 + '(1 1 2 4 8 16 32))
;-> (1 1 2 4 8 16 32 64 127 253 504 1004 2000 3984 7936 15808 31489)
n = 8
(iterate 10 + '(1 1 2 4 8 16 32 64))
;-> (1 1 2 4 8 16 32 64 128 255 509 1016 2028 4048 8080 16128 32192 64256)
n = 9
(iterate 10 + '(1 1 2 4 8 16 32 64 128))
;-> (1 1 2 4 8 16 32 64 128 256 511 1021 2040 4076 8144 16272 32512 64960 129792)
n = 10
(iterate 10 + '(1 1 2 4 8 16 32 64 128 256))
;-> (1 1 2 4 8 16 32 64 128 256 512 1023 2045 4088 8172 16336 32656 65280 130496 260864)


---------------------------------
IL PROBLEMA DEI MATRIMONI STABILI
---------------------------------

Il problema del matrimoni stabili è un nome semplice che rappresenta un problema molto importante. In economia questo intende ogni problema che richieda di allocare un gruppo di risorse di un insieme A con un gruppo di risorse di un insieme B in maniera tale da formare dei gruppi stabili (nella versione base si parla di coppie, ma è estendibile).

La definizione originale del problema è la seguente:
dato n uomini e n donne, dove ogni persona ha classificato tutti i membri del sesso opposto in ordine di preferenza, si accoppiano uomini e donne insieme in modo tale che non ci siano due persone di sesso opposto che preferirebbero stare tra loro rispetto ai loro attuali partner. Quando non esistono coppie di questo tipo, l'insieme dei matrimoni è considerato stabile.

I matematici americani Dave Gale e Lloyd Shapley pubblicarono un algoritmo di soluzione nel 1962 dimostrando che il problema del matrimonio stabile ammette sempre una soluzione.

L’algoritmo di Gale e Shapley consente di individuare una soluzione stabile. Nel 1971 Mc Vitie e Wilson hanno pubblicato un algoritmo che consente di trovare tutte le soluzioni stabili del problema.

La soluzione proposta è un adattamento del programma in Java presentato all'indirizzo web:

https://www.sanfoundry.com/java-program-gale-shapley-algorithm/

In questo modo possiamo vedere come possono essere tradotte in newLISP alcune espressioni/costrutti del linguaggio Java. Inoltre la nomenclatura è stata lasciata in lingua inglese.

La struttura dei dati di input è la seguente:

Men:   ("M1" "M2" "M3" "M4" "M5")
Women: ("W1" "W2" "W3" "W4" "W5")

Men preferenze:
(("W5" "W2" "W3" "W4" "W1")
 ("W2" "W5" "W1" "W3" "W4")
 ("W4" "W3" "W2" "W1" "W5")
 ("W1" "W2" "W3" "W4" "W5")
 ("W5" "W2" "W3" "W4" "W1"))

Women preferenze:
(("M5" "M3" "M4" "M1" "M2")
 ("M1" "M2" "M3" "M5" "M4")
 ("M4" "M5" "M3" "M2" "M1")
 ("M5" "M2" "M1" "M4" "M3")
 ("M2" "M1" "M4" "M3" "M5"))

Lo pseudocodice dell'algoritmo è il seguente:

Algorithm Gale-Shapley
    Initialize all m of M and w of W to free
    while exist free man m who still has a woman w to propose to
    (
       w = m's highest ranked such woman to whom he has not yet proposed
       if w is free
         (m, w) become engaged
       else some pair (m', w) already exists
         if w prefers m to m'
           (m, w) become engaged
           m' becomes free
         else
           (m', w) remain engaged
    )

Di seguito viene riportato il codice in Java:

"
/** Java Program to Implement Gale Shapley Algorithm **/
/**
 Gale Shapley Algorithm is used to solve the stable marriage problem (SMP). SMP is the problem of finding a stable matching between two sets of elements given a set of preferences for each element.
**/
/** Class GaleShapley **/
public class GaleShapley
{
    private int N, engagedCount;
    private String[][] menPref;
    private String[][] womenPref;
    private String[] men;
    private String[] women;
    private String[] womenPartner;
    private boolean[] menEngaged;

    /** Constructor **/
    public GaleShapley(String[] m, String[] w, String[][] mp, String[][] wp)
    {
        N = mp.length;
        engagedCount = 0;
        men = m;
        women = w;
        menPref = mp;
        womenPref = wp;
        menEngaged = new boolean[N];
        womenPartner = new String[N];
        calcMatches();
    }
    /** function to calculate all matches **/
    private void calcMatches()
    {
        while (engagedCount < N)
        {
            int free;
            for (free = 0; free < N; free++)
                if (!menEngaged[free])
                    break;
            for (int i = 0; i < N && !menEngaged[free]; i++)
            {
                int index = womenIndexOf(menPref[free][i]);
                if (womenPartner[index] == null)
                {
                    womenPartner[index] = men[free];
                    menEngaged[free] = true;
                    engagedCount++;
                }
                else
                {
                    String currentPartner = womenPartner[index];
                    if (morePreference(currentPartner, men[free], index))
                    {
                        womenPartner[index] = men[free];
                        menEngaged[free] = true;
                        menEngaged[menIndexOf(currentPartner)] = false;
                    }
                }
            }
        }
        printCouples();
    }
    /** function to check if women prefers new partner over old assigned partner **/
    private boolean morePreference(String curPartner, String newPartner, int index)
    {
        for (int i = 0; i < N; i++)
        {
            if (womenPref[index][i].equals(newPartner))
                return true;
            if (womenPref[index][i].equals(curPartner))
                return false;
        }
        return false;
    }
    /** get men index **/
    private int menIndexOf(String str)
    {
        for (int i = 0; i < N; i++)
            if (men[i].equals(str))
                return i;
        return -1;
    }
    /** get women index **/
    private int womenIndexOf(String str)
    {
        for (int i = 0; i < N; i++)
            if (women[i].equals(str))
                return i;
        return -1;
    }
    /** print couples **/
    public void printCouples()
    {
        System.out.println("Couples are : ");
        for (int i = 0; i < N; i++)
        {
            System.out.println(womenPartner[i] +" "+ women[i]);
        }
    }
    /** main function **/
    public static void main(String[] args)
    {
        System.out.println("Gale Shapley Marriage Algorithm\n");
        /** list of men **/
        String[] m = {"M1", "M2", "M3", "M4", "M5"};
        /** list of women **/
        String[] w = {"W1", "W2", "W3", "W4", "W5"};
        /** men preference **/
        String[][] mp = {{"W5", "W2", "W3", "W4", "W1"},
                         {"W2", "W5", "W1", "W3", "W4"},
                         {"W4", "W3", "W2", "W1", "W5"},
                         {"W1", "W2", "W3", "W4", "W5"},
                         {"W5", "W2", "W3", "W4", "W1"}};
        /** women preference **/
        String[][] wp = {{"M5", "M3", "M4", "M1", "M2"},
                         {"M1", "M2", "M3", "M5", "M4"},
                         {"M4", "M5", "M3", "M2", "M1"},
                         {"M5", "M2", "M1", "M4", "M3"},
                         {"M2", "M1", "M4", "M3", "M5"}};
        GaleShapley gs = new GaleShapley(m, w, mp, wp);
    }
}
"

Adesso vediamo l'implementazione in newLISP in cui ho cercato di mantenere il codice newLISP il più possibile fedele all'originale:

(define (gs m w mp wp)
  (local (N engagedCount menPref womenPref men women womenPartner menEngaged
          free cont i j km kw ind currentPartner pref res)
    (setq N (length mp))
    (setq engagedCount 0) ;
    (setq men m)   ; array of men (string)
    (setq women w) ; array of women (string)
    (setq menPref mp)   ; array of array of men preferences (string)
    (setq womenPref wp) ; array of array women preferences (string)
    (setq menEngaged (array N '(nil)))   ; boolean array
    (setq womenPartner (array N '(""))) ; string array
    ; function: calcMatches
    (define (calcMatches)
      (while (< engagedCount N)
        ;(println "engaged: " engagedCount)
        (setq free 0)
        (setq cont true)
        (while (and (< free N) cont)
          (if (null? (menEngaged free))
              (setq cont nil)
              (++ free))
        )
        (setq i 0)
        (setq cont true)
        (while (and (< i N) (null? (menEngaged free)))
          ;(println "i: " i " free: " free)
          (setq ind (womenIndexOf (menPref free i)))
          (if (null? (womenPartner ind))
            (begin
             (setf (womenPartner ind) (men free))
             (setf (menEngaged free) true)
             (++ engagedCount))
            ;else
            (begin
             (setq currentPartner (womenPartner ind))
             (if (morePreference currentPartner (men free) ind)
              (begin
               (setf (womenPartner ind) (men free))
               (setf (menEngaged free) true)
               (setf (menEngaged (menIndexOf currentPartner)) nil))
             ))
          )
          (++ i)
        )
      )
    )
    ; function: morePreference
    (define (morePreference curPartner newPartner idx)
      (setq res nil)
      (setq j 0)
      (setq cont true)
      (while (and (< j N) cont)
        (cond ((= (womenPref idx j) newPartner)
               (setq cont nil)
               (setq res true))
              ((= (womenPref idx j) curPartner)
               (setq cont nil)
               (setq res nil))
        )
        (++ j)
      )
      res)
    ; function: menIndexOf
    (define (menIndexOf str)
      (setq km 0)
      (setq cont true)
      (while (and (< km N) cont)
        (if (= (men km) str)
            (setq cont nil)
            (++ km))
      )
      ;(if (= i N) -1 i)
      (if (= km N) nil km)
    )
    ; function: womenIndexOf
    (define (womenIndexOf str)
      (setq kw 0)
      (setq cont true)
      (while (and (< kw N) cont)
        (if (= (women kw) str)
            (setq cont nil)
            (++ kw))
      )
      ;(if (= i N) -1 i)
      (if (= kw N) nil kw)
    )
    ;
    (define (printCouples)
      (dolist (el womenPartner)
        (println el { } (women $idx)))
    )
    ;
    ; Calculate solution
    (calcMatches)
    ; Print solution
    (printCouples)
    'end
  ))

Assegniamo i valori iniziali:

Array of Men:

(setq mm '("M1" "M2" "M3" "M4" "M5"))
(setq m (array 5 mm))

Array of Women:

(setq ww '("W1" "W2" "W3" "W4" "W5"))
(setq w (array 5 ww))

Array of Men preference:

(setq mmp '(("W5" "W2" "W3" "W4" "W1")
           ("W2" "W5" "W1" "W3" "W4")
           ("W4" "W3" "W2" "W1" "W5")
           ("W1" "W2" "W3" "W4" "W5")
           ("W5" "W2" "W3" "W4" "W1")))
(setq mp (array 5 5 (flat mmp)))

Array of Women preference:

(setq wwp '(("M5" "M3" "M4" "M1" "M2")
           ("M1" "M2" "M3" "M5" "M4")
           ("M4" "M5" "M3" "M2" "M1")
           ("M5" "M2" "M1" "M4" "M3")
           ("M2" "M1" "M4" "M3" "M5")))
(setq wp (array 5 5 (flat wwp)))

Proviamo la funzione:

(gs m w mp wp)
;-> M4 W1
;-> M2 W2
;-> M5 W3
;-> M3 W4
;-> M1 W5
;-> end

Attenzione, questo algoritmo permette di trovare una soluzione stabile, non ottima.
Alcune coppie potrebbero essere ottime (banalmente se la prima scelta di un x e un y combaciano), ma non è necessario che lo siano. Anzi, è molto probabile che ciascun elemento ottenga la sua seconda o terza scelta (o, al crescere del numero di persone, anche scelte molto peggiori). Inoltre se un elemento riceve una sola proposta sarà costretto ad accettarla, non importa quanto sia in basso nella sua scala delle preferenze.
È opportuno osservare che l’algoritmo produce sempre la soluzione ottimale per ciascun elemento del gruppo che propone e al tempo stesso produce la soluzione peggiore per ciascun elemento dell'altro gruppo.
Quindi se il gruppo che propone fosse una volta quello degli uomini e una volta quello delle donne otterremmo due risultati diversi, entrambi i risultati però sarebbero completi e costituiti solo da coppie stabili (ottimali per il gruppo proponente).
Di fatto l’algoritmo garantisce che ogni coppia formata non possa "trovare di meglio" e che quindi non abbia motivo per rompersi. E questo è il risultato migliore a cui si può aspirare.

Nota: nei problemi pratici occorre considerare anche i casi generali in cui gli insiemi sono di cardinalità differente e/o le liste di preferenza sono incomplete.

L'algoritmo di Gale-Shapley viene usato in tutto il mondo: in Danimarca per l'assegnazione di bambini agli asili, in Ungheria per l'iscrizione di bambini alle scuole, a New York per la scelta dei rabbini alle sinagoghe, in Cina, Germania e Spagna per gli studenti delle università, nel Regno Unito l'algoritmo è stato il punto di partenza per elaborare un metodo ottimale per associare organi a pazienti bisognosi di trapianti...

Vediamo un altro esempio (Rosetta code):

(setq mm (map string '(abe bob col dan ed fred gav hal ian jon)))
(setq m (array 10 mm))

(setq ww (map string '(abi bea cath dee eve fay gay hope ivy jan)))
(setq w (array 10 ww))

(setq mmp (map string (flat '((abi eve cath ivy jan dee fay bea hope gay)
            (cath hope abi dee eve fay bea jan ivy gay)
            (hope eve abi dee bea fay ivy gay cath jan)
            (ivy fay dee gay hope eve jan bea cath abi)
            (jan dee bea cath fay eve abi ivy hope gay)
            (bea abi dee gay eve ivy cath jan hope fay)
            (gay eve ivy bea cath abi dee hope jan fay)
            (abi eve hope fay ivy cath jan bea gay dee)
            (hope cath dee gay bea abi fay ivy jan eve)
            (abi fay jan gay eve bea dee cath ivy hope)))))
(setq mp (array 10 10 (flat mmp)))

(setq wwp (map string (flat '((bob fred jon gav ian abe dan ed col hal)
            (bob abe col fred gav dan ian ed jon hal)
            (fred bob ed gav hal col ian abe dan jon)
            (fred jon col abe ian hal gav dan bob ed)
            (jon hal fred dan abe gav col ed ian bob)
            (bob abe ed ian jon dan fred gav col hal)
            (jon gav hal fred bob abe col ed dan ian)
            (gav jon bob abe ian dan hal ed col fred)
            (ian col hal gav fred bob abe ed jon dan)
            (ed hal gav abe bob jon col ian fred dan)))))
(setq wp (array 10 10 (flat wwp)))

(gs m w mp wp)
;-> jon abi
;-> fred bea
;-> bob cath
;-> col dee
;-> hal eve
;-> dan fay
;-> gav gay
;-> ian hope
;-> abe ivy
;-> ed jan
;-> end

Cerchiamo adesso di scrivere una funzione che controlla se una data soluzione è stabile o meno. Una soluzione non è stabile se risultano vere entrambe le seguenti condizioni:

1) Esiste un elemento A del primo gruppo (a) che preferisce un elemento B del secondo gruppo (b) all'elemento a cui A è stato abbinato e
2) l'elemento b di B preferisce a di A all'elemento a cui è stato abbinato.

In altre parole, una soluzione è stabile quando non esiste alcuna coppia (a di A e b di B) in cui entrambi si preferiscono l'un l'altro rispetto al loro partner attuale.

Utilizziamo i dati del primo esempio:

(setq mm '("M1" "M2" "M3" "M4" "M5"))
(setq m (array 5 mm))
(setq ww '("W1" "W2" "W3" "W4" "W5"))
(setq w (array 5 ww))
(setq mmp '(("W5" "W2" "W3" "W4" "W1")
           ("W2" "W5" "W1" "W3" "W4")
           ("W4" "W3" "W2" "W1" "W5")
           ("W1" "W2" "W3" "W4" "W5")
           ("W5" "W2" "W3" "W4" "W1")))
(setq mp (array 5 5 (flat mmp)))
(setq wwp '(("M5" "M3" "M4" "M1" "M2")
           ("M1" "M2" "M3" "M5" "M4")
           ("M4" "M5" "M3" "M2" "M1")
           ("M5" "M2" "M1" "M4" "M3")
           ("M2" "M1" "M4" "M3" "M5")))
(setq wp (array 5 5 (flat wwp)))

Calcoliamo la soluzione:

(gs m w mp wp)
;-> M4 W1
;-> M2 W2
;-> M5 W3
;-> M3 W4
;-> M1 W5
;-> end

(setq sol '(("M1" "W5") ("M2" "W2") ("M3" "W4") ("M4" "W1") ("M5" "W3")))

Per seguire meglio il metodo di soluzione modifichiamo e stampiamo i dati:

(define (check-sol sol mmp wwp)
  (local (i j k stable men women theman thewoman pos-woman pos-men idx-m idx-w
          uomini donne prefU prefD link pos ind-uomo ind-donna
          ind-uomo ind-uomo-accoppiato)
    (setq stable true)
    (sort sol)
    (setq men (sort (map (fn(x) (first x)) sol)))
    (setq women (sort (map (fn(x) (last x)) sol)))
    (setq uomini '())
    (setq donne '())
    (setq prefU '())
    (setq prefD '())
    (setq link '())
    ; preferenze degli uomini
    (println "Preferenze M")
    (dolist (el mmp)
      (print "M" $idx ": ")
      (dolist (pref el)
        (print (first (ref pref women)) { })
        (push (first (ref pref women)) prefU -1)
      )
      (println)
    )
    (setq prefU (explode prefU 5))
    ; preferenze delle donne
    (println "Preferenze W")
    (dolist (el wwp)
      (print "W" $idx ": ")
      (dolist (pref el)
        (print (first (ref pref men)) { })
        (push (first (ref pref men)) prefD -1)
      )
      (println)
    )
    (setq prefD (explode prefD 5))
    ; accoppiamenti
    (println "M p  W p")
    (setq i 0)
    (while (< i (length sol))
      (setq theman (first (sol i)))
      (setq thewoman (last (sol i)))
      (setq pos-woman (first (ref thewoman (mmp i))))
      (setq pos-man (first (ref theman (wwp (first (ref thewoman ww))))))
      (setq idx-m i)
      (setq idx-w (first (ref thewoman women)))
      ;(println idx-m { } idx-w { } theman { } thewoman { } pos-woman { } pos-man)
      (println i { } pos-woman {  } idx-w { } pos-man)
      (push idx-m uomini -1)
      (push idx-m donne -1)
      (push (list i pos-woman idx-w pos-man) link -1)
      (++ i)
    )
  )
)

Eseguiamo la funzione:

(check-sol sol mmp wwp)
;-> Preferenze M
;-> M0: 4 1 2 3 0
;-> M1: 1 4 0 2 3
;-> M2: 3 2 1 0 4
;-> M3: 0 1 2 3 4
;-> M4: 4 1 2 3 0
;-> Preferenze W
;-> W0: 4 2 3 0 1
;-> W1: 0 1 2 4 3
;-> W2: 3 4 2 1 0
;-> W3: 4 1 0 3 2
;-> W4: 1 0 3 2 4
;-> M p  W p
;-> 0 0  4 1
;-> 1 0  1 1
;-> 2 0  3 4
;-> 3 0  0 2
;-> 4 2  2 1

Analizziamo la situazione per verificare la stabilità:
tutti gli M che sono accoppiati con valore 0 (colonna p per M) hanno la scelta migliore, quindi non hanno motivo di cambiare. Vediamo l'unico elemento M che non è accoppiato con valore 0, cioè M4.
M4 è accoppiato con W2 (con valore 2), ma preferisce di più W4 e W1.
W4 è accoppiata con M0 con valore 1 e (per W4) M4 vale 4, quindi W4 preferisce restare con M0.
W1 è accoppiata con M1 con valore 1 e (per W1) M4 vale 3, quindi W1 preferisce restare con M1.

Adesso possiamo scrivere la funzione che controlla la stabilità:

(define (check-sol sol mmp wwp)
  (local (i j k stable men women theman thewoman pos-woman pos-men idx-m idx-w
          uomini donne prefU prefD link pos ind-uomo ind-donna
          ind-uomo ind-uomo-accoppiato)
    (setq stable true)
    (sort sol)
    (setq men (sort (map (fn(x) (first x)) sol)))
    (setq women (sort (map (fn(x) (last x)) sol)))
    (setq uomini '())
    (setq donne '())
    (setq prefU '())
    (setq prefD '())
    (setq link '())
    ; preferenze degli uomini
    (println "Preferenze M")
    (dolist (el mmp)
      (print "M" $idx ": ")
      (dolist (pref el)
        (print (first (ref pref women)) { })
        (push (first (ref pref women)) prefU -1)
      )
      (println)
    )
    (setq prefU (explode prefU 5))
    ; preferenze delle donne
    (println "Preferenze W")
    (dolist (el wwp)
      (print "W" $idx ": ")
      (dolist (pref el)
        (print (first (ref pref men)) { })
        (push (first (ref pref men)) prefD -1)
      )
      (println)
    )
    (setq prefD (explode prefD 5))
    ; accoppiamenti
    (println "M p  W p")
    (setq i 0)
    (while (< i (length sol))
      (setq theman (first (sol i)))
      (setq thewoman (last (sol i)))
      (setq pos-woman (first (ref thewoman (mmp i))))
      (setq pos-man (first (ref theman (wwp (first (ref thewoman ww))))))
      (setq idx-m i)
      (setq idx-w (first (ref thewoman women)))
      ;(println idx-m { } idx-w { } theman { } thewoman { } pos-woman { } pos-man)
      (println i { } pos-woman {  } idx-w { } pos-man)
      (push idx-m uomini -1)
      (push idx-m donne -1)
      (push (list i pos-woman idx-w pos-man) link -1)
      (++ i)
    )
    ;(println uomini)
    ;(println donne)
    ;(println prefU)
    ;(println prefD)
    ;(println link)
    ;
    ; check stability
    ;
    (dolist (cur-link link)
      ;(println cur-link { } $idx)
      (setq idx-link $idx)
      ; controllo solo accoppiamenti non ottimali
      (if (> (cur-link 1) 0)
        (begin
         ;(println (cur-link 1) { } $idx)
         (setq pos (- (cur-link 1) 1))
         (while (> pos -1)
           (println "uomo corrente: " idx-link)
           ; indice donna migliore di quella attuale
           (setq ind-donna (prefU idx-link pos))
           (println "indice donna migliore di quella attuale: " ind-donna)
           ; valore uomo corrente per donna migliore
           (setq ind-uomo (first (ref idx-link (prefD ind-donna))))
           (println "valore uomo corrente per donna migliore: " ind-uomo)
           ; valore uomo accoppiato per donna migliore
           (dolist (el link)
             (if (= (el 2) ind-donna) (setq ind-uomo-accoppiato (el 3)))
           )
           (println "valore uomo accoppiato per donna migliore: " ind-uomo-accoppiato)
           ;controllo stabilità
           (if (< ind-uomo ind-uomo-accoppiato)
             (begin
               (setq stable nil)
               (println "coppia instabile")
             )
             ;else
             (println "coppia stabile")
           )
           (-- pos)
         )
        )
      )
    )
    (println "Soluzione stabile: " stable)
  )
)

Proviamo la stabilità:

(check-sol sol mmp wwp)
;-> Preferenze M
;-> M0: 4 1 2 3 0
;-> M1: 1 4 0 2 3
;-> M2: 3 2 1 0 4
;-> M3: 0 1 2 3 4
;-> M4: 4 1 2 3 0
;-> Preferenze W
;-> W0: 4 2 3 0 1
;-> W1: 0 1 2 4 3
;-> W2: 3 4 2 1 0
;-> W3: 4 1 0 3 2
;-> W4: 1 0 3 2 4
;-> M p  W p
;-> 0 0  4 1
;-> 1 0  1 1
;-> 2 0  3 4
;-> 3 0  0 2
;-> 4 2  2 1
;-> uomo corrente: 4
;-> indice donna migliore di quella attuale: 1
;-> valore uomo corrente per donna migliore: 3
;-> valore uomo accoppiato per donna migliore: 1
;-> coppia stabile
;-> uomo corrente: 4
;-> indice donna migliore di quella attuale: 4
;-> valore uomo corrente per donna migliore: 4
;-> valore uomo accoppiato per donna migliore: 1
;-> coppia stabile
;-> Soluzione stabile: true

Proviamo a modificare la soluzione:

(setq sol '(("M1" "W5") ("M2" "W2") ("M3" "W4") ("M4" "W1") ("M5" "W3")))

scambiando di posto W4 in W5:

(setq sol1 '(("M1" "W4") ("M2" "W2") ("M3" "W5") ("M4" "W1") ("M5" "W3")))

(check-sol sol1 mmp wwp)
;-> Preferenze M
;-> M0: 4 1 2 3 0
;-> M1: 1 4 0 2 3
;-> M2: 3 2 1 0 4
;-> M3: 0 1 2 3 4
;-> M4: 4 1 2 3 0
;-> Preferenze W
;-> W0: 4 2 3 0 1
;-> W1: 0 1 2 4 3
;-> W2: 3 4 2 1 0
;-> W3: 4 1 0 3 2
;-> W4: 1 0 3 2 4
;-> M p  W p
;-> 0 3  3 2
;-> 1 0  1 1
;-> 2 4  4 3
;-> 3 0  0 2
;-> 4 2  2 1
;-> uomo corrente: 0
;-> indice donna migliore di quella attuale: 2
;-> valore uomo corrente per donna migliore: 4
;-> valore uomo accoppiato per donna migliore: 1
;-> coppia stabile
;-> uomo corrente: 0
;-> indice donna migliore di quella attuale: 1
;-> valore uomo corrente per donna migliore: 0
;-> valore uomo accoppiato per donna migliore: 1
;-> coppia instabile
;-> uomo corrente: 0
;-> indice donna migliore di quella attuale: 4
;-> valore uomo corrente per donna migliore: 1
;-> valore uomo accoppiato per donna migliore: 3
;-> coppia instabile
;-> uomo corrente: 2
;-> indice donna migliore di quella attuale: 0
;-> valore uomo corrente per donna migliore: 1
;-> valore uomo accoppiato per donna migliore: 2
;-> coppia instabile
;-> uomo corrente: 2
;-> indice donna migliore di quella attuale: 1
;-> valore uomo corrente per donna migliore: 2
;-> valore uomo accoppiato per donna migliore: 1
;-> coppia stabile
;-> uomo corrente: 2
;-> indice donna migliore di quella attuale: 2
;-> valore uomo corrente per donna migliore: 2
;-> valore uomo accoppiato per donna migliore: 1
;-> coppia stabile
;-> uomo corrente: 2
;-> indice donna migliore di quella attuale: 3
;-> valore uomo corrente per donna migliore: 4
;-> valore uomo accoppiato per donna migliore: 2
;-> coppia stabile
;-> uomo corrente: 4
;-> indice donna migliore di quella attuale: 1
;-> valore uomo corrente per donna migliore: 3
;-> valore uomo accoppiato per donna migliore: 1
;-> coppia stabile
;-> uomo corrente: 4
;-> indice donna migliore di quella attuale: 4
;-> valore uomo corrente per donna migliore: 4
;-> valore uomo accoppiato per donna migliore: 3
;-> coppia stabile
;-> Soluzione stabile: nil

La soluzione modificata non è stabile.


-----------------------
TEST PRIMI MILLER-RABIN
-----------------------

Il test di primalità di Miller-Rabin è un algoritmo per determinare se un numero intero è primo.
Il test è probabilistico, nel senso che se il test è negativo, allora il numero è sicuramente composito (non primo), mentre se il test è positivo il numero è "quasi" sicuramente primo.

Per maggiori informazioni: https://it.wikipedia.org/wiki/Test_di_Miller-Rabin

Definiamo alcune funzioni che servono per l'agoritmo.

(random-sample n k) seleziona k numeri distinti da una lista n.
Se il parametro n è un numero, allora la lista vale (1 2 ... n).
Altrimenti n deve essere una lista di elementi distinti.

(define (random-sample n k)
  (cond ((integer? n)
         (slice (randomize (sequence 1 n)) 0 k))
        ((list? n)
         (slice (randomize n) 0 k))
        (true nil)))

(random-sample 100 10)
;-> (73 30 87 32 20 74 91 2 82 36)
(random-sample '(a v f j k o l) 3)
;-> (f j a)

Nota: la funzione "random-sample" manda in crash il sistema con numeri grandi. Probabilmente la primitiva "sequence" richiede troppa memoria per generare la lista di numeri.

Quindi utilizziamo la seguente funzione:

(define (random-sample n k)
  (let (out '())
    (for (i 1 k)
      (push (+ 2 (rand n)) out)
    )
    out))

(random-sample 10 3)
;-> (75 83 90 36 48 59 81 20 57 1)

Nota: questa funzione può generare numeri uguali, ma è molto improbabile con n grande.

(powmod b e m) calcola l'espressione ((b^e) % m) in modo veloce.

(define (powmod b e m)
  (local (r)
    (cond ((= m 1) (setq r 0))
          (true
            ;(setq r 1L)
            (setq r 1)
            (setq b (% b m))
            (while (> e 0)
              (if (= (% e 2) 1) (setq r (% (* r b) m)))
              (setq e (/ e 2))
              (setq b (% (* b b) m))
            )
          )
    )
    r))

(** x p) calcola la potenza di due numeri interi (x^p):

(define (** x p)
  (let (y 1L)
    (dotimes (i p)
      (set 'y (* y x)))))

(powmod 10320320302 2322 5)
;-> 4L
(% (** 10320320302 2322) 5)
;-> 4L

Vediamo i tempi di esecuzione:
(time (% (** 103203203022222 23213) 5))
;-> 2160.79
(time (powmod 103203203022222 23213 5))
;-> 0

Adesso possiamo scrivere la funzione che implementa l'algoritmo di Miller-Rabin:

(define (mil-rab n)
  (local (k s d x out stop)
    (setq out true)
    (setq stop nil)
    (setq k 5)
    (cond ((or (= n 1) (= n 4)) (setq out nil))
          ((or (= n 2) (= n 3) (= n 5)) (setq out true))
          ((zero? (% n 2)) (setq out nil))
          (true
            (setq s 0)
            (setq d (- n 1))
            (while (= (% d 2) 0)
              (++ s)
              (setq d (/ d 2))
            )
            ; ciclo con una lista di numeri casuali (k = 5)
            ;(dolist (a (random-sample (sequence 2 (- n 3)) k) stop)
            ;(dolist (a (random-sample (- n 5) k) stop)
            (dolist (a (random-sample (- n 3) k) stop)
              (setq x (powmod a d n))
              (if (and (!= x 1) (!= n (+ x 1)))
                (begin
                  (setq r 1)
                  (while (< r s)
                    (setq x (powmod x 2 n))
                    (if (= x 1) ; numero composito
                        (setq out nil r s stop true)
                    ;else
                        (if (= x (- n 1)) ; il ciclo non continua
                            (setq a 0 r s)) ; proviamo un'altro "a"
                    )
                    (++ r)
                  )
                  ; numero composito
                  (if (> a 0) (setq out nil stop true))
                )
              )
            )
            ; probabilmente primo se raggiunge la fine del loop
            ; cioè, (out = true)
          )
    )
    out))

Prima di verificare la funzione utilizziamo la funzone "seed" per inizializzare il generatore di numerii casuali di newLISP (altrimenti newLISP inizia sempre con la stessa sequenza di numeri casuali).

(seed (time-of-day))

(mil-rab 11)
;-> true
(mil-rab 1117)
;-> true

Verifichiamo la funzione "mil-rab" utilizzando la funzione "primo?":

(define (primo? n)
   (if (< n 2) nil
       (= 1 (length (factor n)))))

Verifichiamo la correttezza dell'algoritmo per i primi 100000 numeri:

(= (map primo? (sequence 1 100000)) (map mil-rab (sequence 1 100000)))
;-> true

Nota: all'aumentare di k aumenta l'affidabilità della funzione, ma diminuisce la velocità di esecuzione.

Vediamo al differenza di velocità tra le due funzioni:

(time (map primo? (sequence 1 1000000)))
;-> 1123.864

(time (map mil-rab (sequence 1 1000000)))
;-> 6828.682

Purtroppo la funzione "rand" non gestisce i numeri big-integer.


-----------------------
IL PROBLEMA DI GIUSEPPE
-----------------------

Il problema di Giuseppe (Josephus problem) o la permutazione di Giuseppe è un problema collegato ad un episodio raccontato dallo storico Flavio Giuseppe nella sua opera "Guerra giudaica" (composta tra il 93 e il 94 d.C.).
Il problema presenta n persone disposte in circolo in attesa di una esecuzione. Scelta una persona iniziale e un senso di rotazione, si saltano k-1 persone, raggiungendo così la k-esima persona, che viene giustiziata ed eliminata dal cerchio. Poi si saltano k-1 persone e si giustizia la k-esima persona. Le esecuzioni proseguono e il cerchio si restringe sempre più, finché non rimane che una sola persona, la quale viene graziata. Dati n e k, determinare la posizione del sopravvissuto all'interno del cerchio iniziale. In altre parole il problema è scegliere il posto nel cerchio iniziale che assicura la sopravvivenza.

Soluzione ricorsiva
Il problema ha la seguente struttura ricorsiva.

   giuseppe (n, k) = (giuseppe (n - 1, k) + k - 1) % n + 1
   giuseppe (1, k) = 1

Dopo che la prima persona (kth dall'inizio) viene uccisa, rimangono n-1 persone. Quindi chiamiamo giuseppe (n - 1, k) per ottenere la posizione con n-1 persone. Ma la posizione restituita da giuseppe (n - 1, k) considererà la posizione a partire da k%n + 1. Quindi dobbiamo apportare modifiche alla posizione restituita da giuseppe (n - 1, k).

(define (giuseppe n k)
  (if (= n 1) 1
      ; La posizione restituita da (giuseppe (n - 1) k)
      ; viene aggiustata perché la chiamata ricorsiva
      ; (giuseppe (n - 1) k) considera l'originale
      ; posizione (k % n) + 1 come posizione 1
      (+ (% (+ (giuseppe (- n 1) k) k -1) n) 1)))

(giuseppe 14 2)
;-> 13
(giuseppe 5 2)
;-> 3
(giuseppe 7 4)
;-> 2

Soluzione iterativa
Nell'algoritmo, utilizziamo la variabile somma per determinare la persona da rimuovere. La posizione corrente della persona viene calcolata aggiungendo il conteggio della persona K alla posizione precedente, ovvero la somma e il modulo della somma.

(define (giuseppe n k)
  (let (somma 0)
    (for (i 2 n)
      (setq somma (% (+ somma k) i)))
    (+ somma 1)))

(giuseppe 14 2)
;-> 13
(giuseppe 5 2)
;-> 3
(giuseppe 7 4)
;-> 2

Nel caso k sia sempre uguale a 2, allora possiamo utilizzare un altro metodo:

(define (giuseppe n)
  ; trova il valore di 2 ^ (1 + floor (Log n))
  ; che è una potenza di 2 il cui valore
  ; è appena sopra n.
  (let (p 1)
    (while (<= p n)
      (setq p (* p 2)))
    ; restituisce 2n - 2^(1+floor(Log n)) + 1
    (+ (- (* 2 n) p) 1)))

(giuseppe 14)
;-> 13
(giuseppe 5)
;-> 3


------
ROT-13
------

Il ROT-13 (rotate by 13 places) è un cifrario monoalfabetico. Il ROT13 è una variante del cifrario di Cesare, ma con chiave 13: ogni lettera viene sostituita con quella situata 13 posizioni più avanti nell'alfabeto.

Originale:  A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
Criptato:   N O P Q R S T U V W X Y Z A B C D E F G H I J K L M

La scelta della chiave non è casuale, perché è la metà del numero di lettere dell'alfabeto internazionale, 26: in questo modo si può utilizzare lo stesso algoritmo sia per la cifratura che per la decifratura.

Ecco un esempio:

Originale LA SCENA IN CUI IL PERSONAGGIO PRINCIPALE MUORE NON MI PIACE
Criptato  YN FPRAN VA PHV VY CREFBANTTVB CEVAPVCNYR ZHBER ABA ZV CVNPR

Si tratta di un cifrario monoalfabetico molto facile da decifrare e non viene più utilizzato in crittografia. Ad oggi, il ROT-13 viene usato per offuscare un testo che contiene informazioni (es. una soluzione o un suggerimento) che il lettore potrebbe non voler conoscere immediatamente.

Metodo 1:

(define (rot13-1 txt)
  (join
   (map
    (fn(c)
      (cond
       ((<= "A" (upper-case c) "M") (char (+ (char c) 13)))
       ((<= "N" (upper-case c) "Z") (char (- (char c) 13)))
       (true c)))
    (explode txt))))

(rot13-1 "LA SCENA IN CUI IL PERSONAGGIO PRINCIPALE MUORE NON MI PIACE")
;-> "YN FPRAN VA PHV VY CREFBANTTVB CEVAPVCNYR ZHBER ABA ZV CVNPR"
(rot13-1 "YN FPRAN VA PHV VY CREFBANTTVB CEVAPVCNYR ZHBER ABA ZV CVNPR")
;-> "LA SCENA IN CUI IL PERSONAGGIO PRINCIPALE MUORE NON MI PIACE"

Metodo 2:

(define (rot13-2 txt)
 (for (y 0 (- (length txt) 1))
      (setf (txt y) (slurp-2 (nth y txt))))
 txt)

(define (slurp-2 x)
  (if
    (or (and (>= (char x)(char "a")) (<= (char x)(char "m")))
        (and (>= (char x)(char "A")) (<= (char x)(char "M"))))
        (char (+ (char x) 13))
    (or (and (>= (char x)(char "n")) (<= (char x)(char "z")))
        (and (>= (char x)(char "N")) (<= (char x)(char "Z"))))
        (char (- (char x) 13))
  x))

(rot13-2 "LA SCENA IN CUI IL PERSONAGGIO PRINCIPALE MUORE NON MI PIACE")
;-> "YN FPRAN VA PHV VY CREFBANTTVB CEVAPVCNYR ZHBER ABA ZV CVNPR"
(rot13-2 "YN FPRAN VA PHV VY CREFBANTTVB CEVAPVCNYR ZHBER ABA ZV CVNPR")
;-> "LA SCENA IN CUI IL PERSONAGGIO PRINCIPALE MUORE NON MI PIACE"

Metodo 3:

(define (rot13-3 txt)
  (let ((rot13from "NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm")
        (rot13goto "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
        (enc ""))
    (while (> (length txt) 0)
      (if (!= (find (nth 0 txt) rot13from) nil)
        (setq enc(append enc(nth (find (nth 0 txt) rot13from) rot13goto)))
        (setq enc(append enc(nth 0 txt))))
      (setq txt (rest txt))
    )
    enc))

(rot13-3 "LA SCENA IN CUI IL PERSONAGGIO PRINCIPALE MUORE NON MI PIACE")
;-> "YN FPRAN VA PHV VY CREFBANTTVB CEVAPVCNYR ZHBER ABA ZV CVNPR"
(rot13-3 "YN FPRAN VA PHV VY CREFBANTTVB CEVAPVCNYR ZHBER ABA ZV CVNPR")
;-> "LA SCENA IN CUI IL PERSONAGGIO PRINCIPALE MUORE NON MI PIACE"

Metodo 4:

(define (rot13-4 txt)
  (for (y 0 (- (length txt) 1))
    (setf (txt y) (char (slurp-4 (char (nth y txt))))))
txt)

(define (slurp-4 x)
  (if
    (or (and (>= x 97) (<= x 109))
        (and (>= x 65) (<= x 77)))
        (+ x 13)
    (or (and (>= x 110)(<= x 122))
        (and (>= x 78) (<= x 90)))
        (- x 13)
  x))

(rot13-4 "LA SCENA IN CUI IL PERSONAGGIO PRINCIPALE MUORE NON MI PIACE")
;-> "YN FPRAN VA PHV VY CREFBANTTVB CEVAPVCNYR ZHBER ABA ZV CVNPR"
(rot13-4 "YN FPRAN VA PHV VY CREFBANTTVB CEVAPVCNYR ZHBER ABA ZV CVNPR")
;-> "LA SCENA IN CUI IL PERSONAGGIO PRINCIPALE MUORE NON MI PIACE"

Metodo 5:

(define (rot13-5 txt , rotarray)
  (setq rotarray (array 256
  '(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
    25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46
    47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 78 79 80 81
    82 83 84 85 86 87 88 89 90 65 66 67 68 69 70 71 72 73 74 75 76 77
    91 92 93 94 95 96 110 111 112 113 114 115 116 117 118 119 120 121
    122 97 98 99 100 101 102 103 104 105 106 107 108 109 123 124 125
    126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141
    142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157
    158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173
    174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189
    190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205
    206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221
    222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237
    238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253
    254 255)))
  (join (map (fn (x) (char (nth (char x) rotarray))) (explode txt))))

(rot13-5 "LA SCENA IN CUI IL PERSONAGGIO PRINCIPALE MUORE NON MI PIACE")
;-> "YN FPRAN VA PHV VY CREFBANTTVB CEVAPVCNYR ZHBER ABA ZV CVNPR"
(rot13-5 "YN FPRAN VA PHV VY CREFBANTTVB CEVAPVCNYR ZHBER ABA ZV CVNPR")
;-> "LA SCENA IN CUI IL PERSONAGGIO PRINCIPALE MUORE NON MI PIACE"

Metodo 6 (iterativo):

(define (rot13-6 txt , rotarray)
  (setq rotarray (array 256
  '(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
    25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46
    47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 78 79 80 81
    82 83 84 85 86 87 88 89 90 65 66 67 68 69 70 71 72 73 74 75 76 77
    91 92 93 94 95 96 110 111 112 113 114 115 116 117 118 119 120 121
    122 97 98 99 100 101 102 103 104 105 106 107 108 109 123 124 125
    126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141
    142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157
    158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173
    174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189
    190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205
    206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221
    222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237
    238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253
    254 255)))
  (dotimes (i (length txt))
    (setf (txt i) (char (nth (char (nth i txt)) rotarray)))) txt)

(rot13-6 "LA SCENA IN CUI IL PERSONAGGIO PRINCIPALE MUORE NON MI PIACE")
;-> "YN FPRAN VA PHV VY CREFBANTTVB CEVAPVCNYR ZHBER ABA ZV CVNPR"
(rot13-6 "YN FPRAN VA PHV VY CREFBANTTVB CEVAPVCNYR ZHBER ABA ZV CVNPR")
;-> "LA SCENA IN CUI IL PERSONAGGIO PRINCIPALE MUORE NON MI PIACE"

Metodo 7:

(context 'rot13)

(define (rot13:aux ch , i)
  (if (set 'i (find ch "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"))
    ("nopqrstuvwxyzabcdefghijklmNOPQRSTUVWXYZABCDEFGHIJKLM" i)
    ch ))

(define (rot13:rot13-7 txt)
  (join (map rot13:aux (explode txt))))

(context 'MAIN)

(rot13-7 "LA SCENA IN CUI IL PERSONAGGIO PRINCIPALE MUORE NON MI PIACE")
;-> "YN FPRAN VA PHV VY CREFBANTTVB CEVAPVCNYR ZHBER ABA ZV CVNPR"
(rot13-7 "YN FPRAN VA PHV VY CREFBANTTVB CEVAPVCNYR ZHBER ABA ZV CVNPR")
;-> "LA SCENA IN CUI IL PERSONAGGIO PRINCIPALE MUORE NON MI PIACE"

Metodo 8:

(define (rot13-8 str)
  (join
   (map
    (fn(c)
      (cond
       ((<= "A" (upper-case c) "M") (char (+ (char c) 13)))
       ((<= "N" (upper-case c) "Z") (char (- (char c) 13)))
       (true c)))
    (explode str))))

(rot13-8 "LA SCENA IN CUI IL PERSONAGGIO PRINCIPALE MUORE NON MI PIACE")
;-> "YN FPRAN VA PHV VY CREFBANTTVB CEVAPVCNYR ZHBER ABA ZV CVNPR"
(rot13-8 "YN FPRAN VA PHV VY CREFBANTTVB CEVAPVCNYR ZHBER ABA ZV CVNPR")
;-> "LA SCENA IN CUI IL PERSONAGGIO PRINCIPALE MUORE NON MI PIACE"

Vediamo la velocità delle varie funzioni:

(setq testo "LA SCENA IN CUI IL PERSONAGGIO PRINCIPALE MUORE NON MI PIACE")

(time (rot13-1 (rot13-1 testo)) 10000)
;-> 874.66
(time (rot13-2 (rot13-2 testo)) 10000)
;-> 1173.892
(time (rot13-3 (rot13-3 testo)) 10000)
;-> 1042.892
(time (rot13-4 (rot13-4 testo)) 10000)
;-> 958.038
(time (rot13-5 (rot13-5 testo)) 10000)
;-> 474.13
(time (rot13-6 (rot13-6 testo)) 10000)
;-> 827.441
(time (rot13-7 (rot13-7 testo)) 10000)
;-> 470.769
(time (rot13-8 (rot13-8 testo)) 10000)
;-> 854.569


------
SUDOKU
------

Il sudoku è un gioco di logica rappresentato da una matrice di 9×9 celle, ciascuna delle quali può contenere un numero da 1 a 9, oppure essere vuota (zero). La matrice è suddivisa in 9 righe orizzontali, 9 colonne verticali e in 9 "sottomatrici" di 3×3 celle contigue chiamate regioni. Lo scopo del gioco è quello di riempire le caselle vuote con numeri da 1 a 9 in modo tale che in ogni riga, in ogni colonna e in ogni regione siano presenti tutte le cifre da 1 a 9, quindi senza ripetizioni. Una volta riempita correttamente, la matrice appare appare come un quadrato latino.
Il gioco fu inventato dal matematico svizzero Eulero (1707-1783).

Un esempio di puzzle sudoku è il seguente:

  Puzzle sudoku:                 Soluzione:

  3 0 6 | 5 0 8 | 4 0 0          3 1 6 | 5 7 8 | 4 9 2
  5 2 0 | 0 0 0 | 0 0 0          5 2 9 | 1 3 4 | 7 6 8
  0 8 7 | 0 0 0 | 0 3 1          4 8 7 | 6 2 9 | 5 3 1
  ------+-------+------          ------+-------+------
  0 0 3 | 0 1 0 | 0 8 0          2 6 3 | 4 1 5 | 9 8 7
  9 0 0 | 8 6 3 | 0 0 5          9 7 4 | 8 6 3 | 1 2 5
  0 5 0 | 0 9 0 | 6 0 0          8 5 1 | 7 9 2 | 6 4 3
  ------+-------+------          ------+-------+------
  1 3 0 | 0 0 0 | 2 5 0          1 3 8 | 9 4 7 | 2 5 6
  0 0 0 | 0 0 0 | 0 7 4          6 9 2 | 3 5 1 | 8 7 4
  0 0 5 | 2 0 6 | 3 0 0          7 4 5 | 2 8 6 | 3 1 9

In pseudocodice, la nostra strategia usa il backtracking ricorsivo:

Trovare (riga,colonna) di una cella non assegnata
Se non ce n'è nessuna, ritorna vero (puzzle risolto)
Per ogni cifra da 1 a 9
     se non vi è alcun conflitto per la cifra alla (riga,colonna)
     assegnare la cifra a (riga,colonna) e provare ricorsivamente a riempire il resto della matrice
     se la ricorsione ha esito positivo, restituire vero
     in caso di insuccesso, rimuovere la cifra e provarne un'altra
se tutte le cifre sono state provate e nulla ha funzionato, restituire falso per attivare il backtracking

Funzione che verifica se un numero è compatibile con la matrice:

; (con la variabile "safe")
(define (isSafe board row col num)
  (local (safe regionRowStart regionColStart)
    (setq safe true)
    ; numero unico sulla riga (row-clash)
    (for (d 0 (- (length board) 1))
      ; Se il numero che stiamo provando
      ; è presente in quella riga
      ; restituire falso (nil)
      (if (= (board row d) num)
          (setq safe nil)
      )
    )
    (if safe (begin
    ; numero unico sulla colonna (column-clash)
    (for (r 0 (- (length board) 1))
      ; Se il numero che stiamo provando
      ; è presente in quella colonna
      ; restituire falso (nil)
      (if (= (board r col) num)
          (setq safe nil)
      )
    )))
    (if safe (begin
    ; numero unico in ogni regione 3x3 (region-clash)
    (setq regionRowStart (- row (% row 3)))
    (setq regionColStart (- col (% col 3)))
    (for (r regionRowStart (+ regionRowStart 2))
          (for (d regionColStart (+ regionColStart 2))
        (if (= (board r d) num)
            (setq safe nil)
        )
      )
    )))
    ; se non c'è conflitto, allora è sicuro
    safe
  )
)

;(con la funzione "catch")
(define (isSafe board row col num)
(catch
  (local (regionRowStart regionColStart)
    ; numero unico sulla riga (row-clash)
    (for (d 0 (- (length board) 1))
      ; Se il numero che stiamo provando
      ; è presente in quella riga
      ; restituire falso (nil)
      (if (= (board row d) num)
          (throw nil)
      )
    )
    ; numero unico sulla colonna (column-clash)
    (for (r 0 (- (length board) 1))
      ; Se il numero che stiamo provando
      ; è presente in quella colonna
      ; restituire falso (nil)
      (if (= (board r col) num)
          (throw nil)
      )
    )
    ; numero unico in ogni region 3x3 (region-clash)
    (setq regionRowStart (- row (% row 3)))
    (setq regionColStart (- col (% col 3)))
    (for (r regionRowStart (+ regionRowStart 2))
      (for (d regionColStart (+ regionColStart 2))
        (if (= (board r d) num)
            (throw nil)
        )
      )
    )
    ; se non c'è conflitto, allora è sicuro
    true
  )
))

Definiamo la funzione che risolve il sudoku:

(define (solveSudoku board)
(catch
  (local (i j row col isEmpty solved)
    (setq row -1 col -1)
    (setq isEmpty true)
    (setq i 0 j 0)
    (while (and isEmpty (< i (length board)))
      (while (and isEmpty (< j (length board)))
        (if (= (board i j) 0)
            ; Esistono ancora dei valori nulli nel puzzle
            (setq row i col j isEmpty nil)
        )
        (++ j)
      )
      (setq j 0)
      (++ i)
    )
    ; stampa la soluzione
    (if isEmpty (begin (println board) (throw true)))
    ; salva la soluzione su una variabile globale
    ;(if isEmpty (begin (setq *sol* board) (throw true)))
    ;else
    (for (num 1 (length board))
        (cond ((isSafe board row col num)
                 (setf (board row col) num)
                 (if (solveSudoku board) (throw true))
                 (setf (board row col) 0)
              )
        )
    )
    nil
  )
))

Proviamo la funzione:

(setq puzzle
'((3 0 6 5 0 8 4 0 0)
  (5 2 0 0 0 0 0 0 0)
  (0 8 7 0 0 0 0 3 1)
  (0 0 3 0 1 0 0 8 0)
  (9 0 0 8 6 3 0 0 5)
  (0 5 0 0 9 0 6 0 0)
  (1 3 0 0 0 0 2 5 0)
  (0 0 0 0 0 0 0 7 4)
  (0 0 5 2 0 6 3 0 0)))

(solveSudoku puzzle)
;-> ((3 1 6 5 7 8 4 9 2)
;->  (5 2 9 1 3 4 7 6 8)
;->  (4 8 7 6 2 9 5 3 1)
;->  (2 6 3 4 1 5 9 8 7)
;->  (9 7 4 8 6 3 1 2 5)
;->  (8 5 1 7 9 2 6 4 3)
;->  (1 3 8 9 4 7 2 5 6)
;->  (6 9 2 3 5 1 8 7 4)
;->  (7 4 5 2 8 6 3 1 9))
;-> true

I puzzle sudoku più difficili del Dottor Arto Inkala:

Sudoku 1:

8 5 . |. . 2 |4 . .        8 5 9 |6 1 2 |4 3 7
7 2 . |. . . |. . 9        7 2 3 |8 5 4 |1 6 9
. . 4 |. . . |. . .        1 6 4 |3 7 9 |5 2 8
------+------+-----        ------+------+-----
. . . |1 . 7 |. . 2        9 8 6 |1 4 7 |3 5 2
3 . 5 |. . . |9 . .        3 7 5 |2 6 8 |9 1 4
. 4 . |. . . |. . .        2 4 1 |5 9 3 |7 8 6
------+------+-----        ------+------+-----
. . . |. 8 . |. 7 .        4 3 2 |9 8 1 |6 7 5
. 1 7 |. . . |. . .        6 1 7 |4 2 5 |8 9 3
. . . |. 3 6 |. 4 .        5 9 8 |7 3 6 |2 4 1

(setq sudoku1
'((8 5 0 0 0 2 4 0 0)
  (7 2 0 0 0 0 0 0 9)
  (0 0 4 0 0 0 0 0 0)
  (0 0 0 1 0 7 0 0 2)
  (3 0 5 0 0 0 9 0 0)
  (0 4 0 0 0 0 0 0 0)
  (0 0 0 0 8 0 0 7 0)
  (0 1 7 0 0 0 0 0 0)
  (0 0 0 0 3 6 0 4 0)))

(solveSudoku sudoku1)
;-> ((8 5 9 6 1 2 4 3 7)
;->  (7 2 3 8 5 4 1 6 9)
;->  (1 6 4 3 7 9 5 2 8)
;->  (9 8 6 1 4 7 3 5 2)
;->  (3 7 5 2 6 8 9 1 4)
;->  (2 4 1 5 9 3 7 8 6)
;->  (4 3 2 9 8 1 6 7 5)
;->  (6 1 7 4 2 5 8 9 3)
;->  (5 9 8 7 3 6 2 4 1))
;-> true

; (con la variabile "safe")
(time (solveSudoku sudoku1))
;-> 7734.897

; (con la funzione "catch")
(time (solveSudoku sudoku1))
;-> 8969.888

Sudoku 2:

. . 5 |3 . . |. . .        1 4 5 |3 2 7 |6 9 8
8 . . |. . . |. 2 .        8 3 9 |6 5 4 |1 2 7
. 7 . |. 1 . |5 . .        6 7 2 |9 1 8 |5 4 3
------+------+-----        ------+------+-----
4 . . |. . 5 |3 . .        4 9 6 |1 8 5 |3 7 2
. 1 . |. 7 . |. . 6        2 1 8 |4 7 3 |9 5 6
. . 3 |2 . . |. 8 .        7 5 3 |2 9 6 |4 8 1
------+------+-----        ------+------+-----
. 6 . |5 . . |. . 9        3 6 7 |5 4 2 |8 1 9
. . 4 |. . . |. 3 .        9 8 4 |7 6 1 |2 3 5
. . . |. . 9 |7 . .        5 2 1 |8 3 9 |7 6 4

(setq sudoku2
'((0 0 5 3 0 0 0 0 0)
  (8 0 0 0 0 0 0 2 0)
  (0 7 0 0 1 0 5 0 0)
  (4 0 0 0 0 5 3 0 0)
  (0 1 0 0 7 0 0 0 6)
  (0 0 3 2 0 0 0 8 0)
  (0 6 0 5 0 0 0 0 9)
  (0 0 4 0 0 0 0 3 0)
  (0 0 0 0 0 9 7 0 0)))

(solveSudoku sudoku2)
;-> ((1 4 5 3 2 7 6 9 8)
;->  (8 3 9 6 5 4 1 2 7)
;->  (6 7 2 9 1 8 5 4 3)
;->  (4 9 6 1 8 5 3 7 2)
;->  (2 1 8 4 7 3 9 5 6)
;->  (7 5 3 2 9 6 4 8 1)
;->  (3 6 7 5 4 2 8 1 9)
;->  (9 8 4 7 6 1 2 3 5)
;->  (5 2 1 8 3 9 7 6 4))
;-> true

; (con la variabile "safe")
(time (solveSudoku sudoku2))
;-> 234.297

; (con la funzione "catch")
(time (solveSudoku sudoku2))
;-> 265.557


--------
CHESS960
--------

Chess960 è una variante degli scacchi creata dal campione del mondo Bobby Fischer. Questa variante non richiede un materiale diverso, ma si basa su una posizione iniziale casuale, con alcuni vincoli:

A) come nella partita a scacchi standard, tutte e otto i pedoni bianchi devono essere piazzati sulla seconda riga.

B) I pezzi bianchi devono stare nella prima riga come nel gioco standard, in ordine casuale di colonne ma con i due seguenti vincoli:
  1) gli alfieri devono essere posizionati su case di colore opposto (cioè deve esserci un numero pari di spazi tra loro)
  2) il re deve trovarsi tra due torri (con un numero qualsiasi di altri pezzi tra loro)

C) Pedoni e pezzi neri devono essere posizionati rispettivamente sulla settima e sull'ottava riga, rispecchiando i pedoni e i pezzi bianchi, proprio come nel gioco standard. (Cioè, le loro posizioni non sono casuali in modo indipendente.)

Con questi vincoli ci sono 960 possibili posizioni di partenza, quindi il nome della variante.

I pezzi sono definiti nel modo seguente:

ITA        ENG       CHAR
-------    ------    ----
Pedone     Pawn      P
Torre      Rook      R
Cavallo    Knight    N
Alfiere    Bishop    B
Regina     Queen     Q
Re         King      K

Nel file "chess960-lst.lsp" sono memorizzate in una lista tutte le 960 posizioni iniziali.
Il modo più semplice per generare una posizione è quello di prenderne casualmente una da questa lista:

(define (get960)
  (load "chess960-lst.lsp")
  (chess960 (rand 960)))

(get960)
;-> (B Q N B N R K R)

Se invece vogliamo generare una posizione ex-novo possiamo scrivere due funzioni.

Funzione che controlla la correttezza di una posizione casuale:

(define (legal-pos lst)
  (and
    ; re a destra di una torre?
    (> (find 'K lst) (find 'R lst))
    ; re a sinistra dell'altra torre?
    (> (find 'K (reverse (copy lst))) (find 'R (reverse (copy lst))))
    ; alfieri di colore contrario?
    (even? (- (find 'B lst) (find 'B (reverse (copy lst)))))))

Funzione che genera una posizione chess960 corretta:

(define (get960)
  (setq start '(R N B Q K B N R))
  (setq prova (randomize start))
  (while (not (legal-pos prova))
    (setq prova (randomize start))
  )
  prova)

(get960)
;-> (N B R Q K N B R)
(get960)
;-> (R K R B N N B Q)
(get960)
;-> (R B B N N K Q R)

Controlliamo la correttezza della funzione generando n posizioni e controllando che esistano nella lista di tutte le posizioni chess960:

(define (control n)
  (load "chess960-lst.lsp")
  (for (i 1 n)
    (setq a (get960))
    (if (nil? (find a chess960)) (println "error:" a))))

(control 10000)
;-> nil

Sembra tutto corretto.


--------------------
PERCORSO DEL CAVALLO
--------------------

In questo problema un cavallo è posizionato in una qualunque casella sulla scacchiera vuota e, spostandosi secondo le regole degli scacchi (cioè ad L), deve passare per tutte le altre caselle esattamente una sola volta. Un percorso del cavallo si dice "chiuso" se l'ultima casa su cui si posiziona il cavallo è vicina alla casa da cui è partito (ad esempio, se il cavallo inizia in d8 e conclude il suo percorso in f7). In caso contrario il percorso del cavallo è detto "aperto". Questo problema è un esempio del più generale "problema del cammino hamiltoniano" nella teoria dei grafi.

Vediamo la soluzione ricorsiva con backtracking:

(define (knight side x y)
  (local (n board result counter res_counter sx sy)
    (setq n side)
    (setq sx x sy y)
    (setq board (array n n '(0)))
    (setq result (array n n '(0)))
    (setq counter 0)
    (setq res_counter 0)
    (if (knight-tour board sx sy) result nil)
  ))

(define (knight-tour board curr-x curr-y)
(catch
  (local (temp)
  ;(println counter)
  ; n*n mosse --> risolto
  (if (= counter (* n n)) (throw true))
  (cond ((or (> curr-x (- n 1)) (< curr-x 0) (> curr-y (- n 1)) (< curr-y 0) (= (board curr-x curr-y) 1))
         (throw nil))
        (true (++ counter) (++ res-counter))
  )
  (setf (board curr-x curr-y) 1)
  (cond ((knight-tour board (+ curr-x 2) (+ curr-y 1)) ; down_right
         (setf (result curr-x curr-y) res-counter)
         (setq res-counter (- res-counter 1))
         (throw true)
        )
        ((knight-tour board (+ curr-x 1) (+ curr-y 2)) ; right_down
         (setf (result curr-x curr-y) res-counter)
         (setq res-counter (- res-counter 1))
         (throw true)
        )
        ((knight-tour board (+ curr-x -1) (+ curr-y 2)) ; right-up
         (setf (result curr-x curr-y) res-counter)
         (setq res-counter (- res-counter 1))
         (throw true)
        )
        ((knight-tour board (+ curr-x -2) (+ curr-y 1)) ; up-right
         (setf (result curr-x curr-y) res-counter)
         (setq res-counter (- res-counter 1))
         (throw true)
        )
        ((knight-tour board (+ curr-x -2) (+ curr-y -1)) ; up-left
         (setf (result curr-x curr-y) res-counter)
         (setq res-counter (- res-counter 1))
         (throw true)
        )
        ((knight-tour board (+ curr-x -1) (+ curr-y -2)) ; left-up
         (setf (result curr-x curr-y) res-counter)
         (setq res-counter (- res-counter 1))
         (throw true)
        )
        ((knight-tour board (+ curr-x 1) (+ curr-y -2)) ; left-down
         (setf (result curr-x curr-y) res-counter)
         (setq res-counter (- res-counter 1))
         (throw true)
        )
        ((knight-tour board (+ curr-x 2) (+ curr-y -1)) ; down-left
         (setf (result curr-x curr-y) res-counter)
         (setq res-counter (- res-counter 1))
         (throw true)
        )
        (true
          ; nessuna mossa possibile --> backtracking
          (if (or (> curr-x (- n 1)) (< curr-x 0) (> curr-y (- n 1)) (< curr-y 0) (= (board curr-x curr-y) 1))
            (begin
              (setq counter (- counter 1))
              (setq res-counter (- res-counter 1))
              (setf (board curr-x curr-y) 0)
            )
          )
          (throw nil)
        )
  )
  )
))

(knight 6 0 0)
;-> (( 1 16  7 26 11 14)
;->  (34 25 12 15  6 27)
;->  (17  2 33  8 13 10)
;->  (32 35 24 21 28  5)
;->  (23 18  3 30  9 20)
;->  (36 31 22 19  4 29))

(time (knight 6 0 0))
;-> 3437.779

(knight 8 0 0)
;-> (( 1 60 39 34 31 18  9 64)
;->  (38 35 32 61 10 63 30 17)
;->  (59  2 37 40 33 28 19  8)
;->  (36 49 42 27 62 11 16 29)
;->  (43 58  3 50 41 24  7 20)
;->  (48 51 46 55 26 21 12 15)
;->  (57 44 53  4 23 14 25  6)
;->  (52 47 56 45 54  5 22 13))

(time (knight 8 0 0))
;-> 142474.658

(knight 8 7 7)
;-> ((47 34 21 30  5 14 19 64)
;->  (36 31 48 33 20 63  4 13)
;->  (49 46 35 22 29  6 15 18)
;->  (60 37 32 51 62 17 12  3)
;->  (45 50 61 38 23 28  7 16)
;->  (56 59 42 25 52  9  2 11)
;->  (41 44 57 54 39 24 27  8)
;->  (58 55 40 43 26 53 10  1))

(time (knight 8 7 7))
;-> 4232650.162 ; circa 70 minuti

Vediamo lo stesso algoritmo di backtracking codificato in modo più strutturato.

(define (is_valid i j)
  (if (and (>= i 0) (< i n) (>= j 0) (< j n))
      (if (= (board i j) -1)
          true
          nil)))

(define (knight_tour i j step_count)
(catch
  (local (next_i next_j)
    (if (= step_count (* n n)) (throw true))
    (for (k 0 7)
      (setq next_i (+ i (x_move k)))
      (setq next_j (+ j (y_move k)))
      (if (is_valid next_i next_j)
          (begin
            (setf (board next_i next_j) step_count)
            ;(println next_i { } next_j { } step_count)
            (if (knight_tour next_i next_j (+ step_count 1))
                (throw true)
            )
            (setf (board next_i next_j) -1) ; backtracking
          )
      )
    )
    nil
  )
))

(define (start_knight_tour side x y)
  (local (n board x_move y_move step_count sx sy)
    (setq n side)
    (setq sx x sy y)
    (setq step_count 1)
    (setq board (array n n '(-1)))
    (setq x_move '(2 1 -1 -2 -2 -1 1 2))
    (setq y_move '(1 2 2 1 -1 -2 -2 -1))
    (setf (board sx sy) 0) ; cavallo nella cella (x,y)
    (if (knight_tour sx sy step_count) board nil
    )))

(start_knight_tour 6 0 0)
;-> (( 0 15  6 25 10 13)
;->  (33 24 11 14  5 26)
;->  (16  1 32  7 12  9)
;->  (31 34 23 20 27  4)
;->  (22 17  2 29  8 19)
;->  (35 30 21 18  3 28))

(time (start_knight_tour 6 0 0))
;-> 672.085

(start_knight_tour 8 0 0)
;-> (( 0 59 38 33 30 17  8 63)
;->  (37 34 31 60  9 62 29 16)
;->  (58  1 36 39 32 27 18  7)
;->  (35 48 41 26 61 10 15 28)
;->  (42 57  2 49 40 23  6 19)
;->  (47 50 45 54 25 20 11 14)
;->  (56 43 52  3 22 13 24  5)
;->  (51 46 55 44 53  4 21 12))

(time (start_knight_tour 8 0 0))
;-> 23314.636

(start_knight_tour 8 7 7)
;-> ((46 33 20 29  4 13 18 63)
;->  (35 30 47 32 19 62  3 12)
;->  (48 45 34 21 28  5 14 17)
;->  (59 36 31 50 61 16 11  2)
;->  (44 49 60 37 22 27  6 15)
;->  (55 58 41 24 51  8  1 10)
;->  (40 43 56 53 38 23 26  7)
;->  (57 54 39 42 25 52  9  0))

(time (start_knight_tour 8 7 7))
;-> 705835.03 ; circa 11 minuti

Nota: cambiando l'ordine delle mosse di ricerca (x_move e y_move) si ottiene un'altra soluzione (e cambia anche il tempo di calcolo).

Un algoritmo molto più veloce è quello di Warnsdorff (1823) che permette di trovare un percorso chiuso partendo da qualunqe casa della scacchiera.

Regola di Warnsdorff:
1) Partire da qualsiasi posizione iniziale del cavallo sulla scacchiera.
2) Spostarsi sempre in una casella non visitata che possiede grado minimo (numero minimo di caselle adiacenti non visitate).

(define (print-board lst)
  (local (s space)
  (for (i 0 (- n 1))
    (setq s "")
    (for (j 0 (- n 1))
      (if (> (lst (+ (* j n) i)) 9)
          (setq space "  ")
          (setq space "   ")
      )
      (extend s space (string (lst (+ (* j n) i))))
    )
    (println s)
  )
  'end))

; Restricts the knight to remain within
; the 8x8 chessboard
(define (limits x y)
  (and (>= x 0) (>= y 0) (< x n) (< y n)))

; Checks whether a square is valid and empty or not
(define (isempty b x y)
  (and (limits x y) (< (b (+ (* y n) x)) 0)))

; Returns the number of empty squares adjacent to (x, y)
(define (getDegree b x y)
  (let (conta 0)
    (for (i 0 (- n 1))
      (if (isempty b (+ x (cx i)) (+ y (cy i)))
          (++ conta)
      )
    )
    conta))

; Picks next point using Warnsdorff's heuristic.
; Returns false if it is not possible to pick next point.
(define (nextMove)
(catch
  (local (minDegIdx c minDeg nx ny start i)
    (setq minDegIdx -1)
    (setq minDeg (+ n 1))
    ; Try all N adjacent of (*x, *y) starting
    ; from a random adjacent. Find the adjacent
    ; with minimum degree.
    (setq start (rand n))
    (for (conta 0 (- n 1))
      (setq i (% (+ start conta) n))
      (setq nx (+ gx (cx i)))
      (setq ny (+ gy (cy i)))
      (setq c (getDegree board nx ny))
      (if (and (isempty board nx ny) (< c minDeg))
          (setq minDegIdx i minDeg c)
      )
    )
    ; if we could not find a next cell
    (if (= minDegIdx -1) (throw nil))
    ; Store coordinates of next point
    (setq nx (+ gx (cx minDegIdx)))
    (setq ny (+ gy (cy minDegIdx)))
    ; Mark next move
    (setf (board (+ (* ny n) nx)) (+ (board (+ (* gy n) gx)) 1))
    ; Update next point
    (setq gx nx)
    (setq gy ny)
    true
  )
))

; checks its neighbouring squares
; If the knight ends on a square that is one
; knight's move from the beginning square,
; then tour is closed
(define (neighbour x y xx yy)
  (let (found nil)
    (for (i 0 (- n 1) 1 found)
      (if (and (= (+ x (cx i)) xx) (= (+ y (cy i)) yy))
          (setq found true)
      )
    )
    found))

; Generates the legal moves using warnsdorff's heuristics.
; Returns false if not possible
(define (findClosedTour)
(catch
  (local (temp)
  ; fill board
  (setq board (array (* n n) '(-1)))
  ; Current points are same as initial points
  (setq gx sx gy sy)
  ; Mark first move
  (setf (board (+ (* gy n) gx)) 1)
  ; Keep picking next points using Warnsdorff's heuristic
  (for (i 0 (- (* n n) 2))
    (if (nil? (nextMove)) (throw nil))
  )
  ; Check if tour is closed
  (if (not (neighbour gx gy sx sy)) (throw nil))
  (print-board board)
  true
  )
))

(define (warnsdorff x y)
    (setq n 8)
    ; start position
    (setq sx x sy y)
    ; current position
    (setq gx sx gy sy)
    ; Move pattern on basis of the change of
    ; x coordinates and y coordinates respectively
    (setq cx '(1 1 2 2 -1 -1 -2 -2))
    (setq cy '(2 -2 1 -1 2 -2 1 -1))
    ; define board
    (setq board (array (* n n) '(-1)))
    ; While we don't get a solution
    (while (not (findClosedTour)))
    'stop
)

(warnsdorff 0 0)
;->    1   4  61  20  51   6  53  22
;->   34  19   2   5  62  21  50   7
;->    3  64  35  60  37  52  23  54
;->   18  33  38  63  56  59   8  49
;->   39  14  57  36  43  48  55  24
;->   32  17  42  47  58  27  44   9
;->   13  40  15  30  11  46  25  28
;->   16  31  12  41  26  29  10  45
;-> stop

(warnsdorff 1 1)
;->   53  50  15  20  63  24  13  22
;->   16   1  54  51  14  21  58  25
;->   49  52  19  64  59  62  23  12
;->    2  17  60  55  46  33  26  57
;->   43  48  45  18  61  56  11  32
;->    6   3  42  47  34  29  38  27
;->   41  44   5   8  39  36  31  10
;->    4   7  40  35  30   9  28  37
;-> stop

(warnsdorff 7 7)
;->    7  10  25  40  59  12  27  30
;->   24  39   8  11  26  29  62  13
;->    9   6  41  60  47  58  31  28
;->   38  23  46  43  50  61  14  63
;->    5  42  55  48  57  44  51  32
;->   22  37  20  45  54  49  64  15
;->   19   4  35  56  17   2  33  52
;->   36  21  18   3  34  53  16   1

(time (warnsdorff 7 7))
;-> 12.965
(time (warnsdorff 7 7))
;-> 53.121
(time (warnsdorff 7 7))
;-> 477.722
(time (warnsdorff 7 7))
;-> 69.916
(time (warnsdorff 7 7))
;-> 541.521


------------------------
TEOREMA CINESE DEI RESTI
------------------------

Siano (n1, n2,..., nk) k interi a due a due coprimi (divisori) e siano (b1, b2,..., bk) k interi relativi (resti).
Allora il sistema di congruenze:

x ≡ b1 (mod n1)   --> x mod n1 = b1
x ≡ b2 (mod n2)   --> x mod n2 = b2
...
x ≡ bk (mod nk)   --> x mod nk = bk

Ammette soluzioni. Inoltre se x0 è una soluzione del sistema, tutte le soluzioni di tale sistema saranno date da:

x = x0 + h*N  dove h appartiene all'insieme dei numeri interi relativi (Z) e N = n1*n2*...*nk.

Nota: la condizione che (n1, n2,..., nk) siano coprimi a coppie, è solo una condizione sufficiente per la risolubilità del sistema. Può capitare che i moduli non siano a due a due coprimi, ma il sistema abbia comunque soluzione.

Vediamo come si calcola la soluzione di un sistema di congruenze con un esempio:

x ≡ 2 (mod 5)
x ≡ 0 (mod 4)
x ≡ 4 (mod 7)

Poiché mcd(5,4) = mcd(5,7) = mcd(4,7) = 1 per il Teorema Cinese dei resti, il sistema ammette soluzione.

Siano:

b1=2, b2=0, b3=4

n1=5, n2=4, n3=7

N = n1*n2*n3 = 140

N1 = n2*n3 = 28

N2 = n1*n3 = 35

N3 = n1*n2 = 20

Iniziamo col determinare una soluzione particolare y1 della congruenza:

N1*y2 ≡ 1 (mod n1)   ==>   28*y1 ≡ 1 (mod 5)   ==>   y1 = 2

Determiniamo una soluzione particolare y2 della congruenza:

N2*y2 ≡ 1 (mod n2)   ==>   35*y2 ≡ 1 (mod 4)   ==>   y2 = 3

Determiniamo una soluzione particolare y3 della congruenza:

N3*y3 ≡ 1 (mod n3)   ==>   20*y2 ≡ 1 (mod 7)   ==>   y2 = 6

La soluzione particolare x0 del sistema è data da:

x0 = b1*N1*y1 + b2*N2*y2 + b3*N3*y3 = 112 + 0 + 480 = 592 = 32 (mod N) = 32 (mod 140)

Quindi le soluzioni del sistema sono date da: x = 32 + 140*h.

Algoritmo del teorema cinese dei resti
--------------------------------------
L'algoritmo seguente è applicabile solo se l'insieme dei numeri n è coprimo a coppie (coprimo pairwise).

Dato il sistema di congruenze:

x ≡ ai (mod ni) dove i=1,...k

Definiamo il prodotto N = n1*n2*...*nk

Per ogni i, gli interi ni e N/ni sono coprimi.

Usando l'algoritmo di Euclide Esteso possiamo trovare gli interi ri e si tali che: ri*ni + si*N/ni = 1.

La soluzione vale: x = Sum[1,k](ai*si*N/ni)

E la soluzione minima vale: x (mod N)

; ritorna il valore di x, dove (a * x) % b == 1
(define (mul-inv a b)
  (local (b0 t q x0 x1)
    (setq b0 b x0 0 x1 1)
    (cond ((= b 1) 1)
          (true
            (while (> a 1)
              (setq q (/ a b))
              (setq t b b (% a b) a t)
              (setq t x0 x0 (- x1 (* q x0)) x1 t)
            )
            (if (< x1 0) (setq x1 (+ x1 b0)))
            x1
          ))))

(mul-inv 3 2)
;-> 1
(mul-inv 5 3)
;-> 2
(mul-inv 7 2)
;-> 1

Funzione che calcola la soluzione con il Teorema Cinese dei Resti:

(define (chinese divisori resti)
  (local (p prod sum)
    (setq prod 1 sum 0)
    (for (i 0 (- (length divisori) 1))
      (setq prod (* prod (divisori i)))
    )
    (for (i 0 (- (length divisori) 1))
      (setq p (/ prod (divisori i)))
      (setq sum (+ sum (* (resti i) (mul-inv p (divisori i)) p)))
    )
    (list (% sum prod) prod)
  )
)

Funzione per il calcolo del minimo comune multiplo:

(define (lcm_ a b) (/ (* a b) (gcd a b)))
(define-macro (lcm) (apply lcm_ (args) 2))

(lcm 3 5 7)
;-> 105
(apply lcm '(3 5 7))
;-> 105

Funzione finale per il Teorema Cinese dei Resti:

(define (trc divisori resti)
    ;se tutte le coppie di numeri sono coprimi tra loro
    ;(minimo comune multiplo(numeri) = prodotto(numeri))
    (if (= (apply * divisori) (apply lcm divisori))
        ;allora cerchiamo la soluzione
        (chinese divisori resti)
        ; altrimenti nessuna soluzione
        nil))

(trc '(3 5 7) '(2 3 2))
;-> (23 105)

La soluzione vale (23 + k*105) dove k=...,-2,-1,0,1,2,...

(trc '(3 5 10) '(2 3 2))
;-> nil

Esempio di applicazione del teorema:

Un generale deve contare i suoi soldati. Invece di contarli uno ad uno, li fa disporre in diversi modi:
1) se messi in fila per 5, allora l'ultima fila ha 1 soldato
2) se messi in fila per 8, allora l'ultima fila ha 7 soldati
3) se messi in fila per 7, allora l'ultima fila ha 6 soldati

A questo punto il generale applica il Teorema Cinese dei Resti e calcola il numero dei soldati:

(chinese '(5 8 7) '(1 7 6))
;-> (111 280)

Infatti risulta:
(% 111 5)
;-> 1
(% 111 8)
;-> 7
(% 111 7)
;-> 6

Applicazioni del teorema cinese dei resti
-----------------------------------------
La maggior parte delle implementazioni di RSA utilizza il teorema cinese del resto durante la firma dei certificati HTTPS e durante la decrittografia.
Il teorema cinese del resto può essere utilizzato anche nella condivisione segreta, che consiste nel distribuire un insieme di dati tra un gruppo di persone che, tutti insieme (ma nessuno da solo), possono recuperare un certo valore dall'insieme dei dati. Ciascuna delle parti è rappresentata da una congruenza e la soluzione del sistema di congruenze utilizzando il teorema cinese dei resti è il numero segreto da recuperare. La condivisione segreta che utilizza il teorema cinese del resto utilizza anche speciali sequenze di interi che garantiscono l'impossibilità di recuperare il numero da un insieme di dati con meno di una certa cardinalità.

Il teorema cinese dei resti è stato utilizzato per costruire una numerazione di Gödel per le sequenze, che è coinvolta nella dimostrazione dei teoremi di incompletezza di Gödel.


----------------
NUMERI ATTRAENTI
----------------

Un numero viene detto attraente se il numero dei suoi fattori primi (distinti o meno) è primo. Per esempio, il numero 20, la cui scomposizione prima è 2 × 2 × 5, è un numero attraente perché anche il numero dei suoi fattori primi (3) è primo.

(define (prime? n) (= (length (factor n)) 1))
(define (attractive? n) (prime? (length (factor n))))
(filter attractive? (sequence 2 120))

Output:
;-> (4 6 8 9 10 12 14 15 18 20 21 22 25 26 27 28 30 32 33 34 35 38
;->  39 42 44 45 46 48 49 50 51 52 55 57 58 62 63 65 66 68 69 70 72
;->  74 75 76 77 78 80 82 85 86 87 91 92 93 94 95 98 99 102 105 106
;->  108 110 111 112 114 115 116 117 118 119 120)


----
IBAN
----

Scrivere una funzione che controlla se un codice dato rappresenta un numero IBAN (International Bank Account Number).

(setq *iban-code-length* '((15  ("NO"))
                             (16  ("BE"))
                             (18  ("DK" "FO" "FI" "GL" "NL"))
                             (19  ("MK" "SI"))
                             (20  ("AT" "BA" "EE" "KZ" "LT" "LU"))
                             (21  ("CR" "HR" "LV" "LI" "CH"))
                             (22  ("BH" "BG" "GE" "DE" "IE" "ME" "RS" "GB"))
                             (23  ("GI" "IL" "AE"))
                             (24  ("AD" "CZ" "MD" "PK" "RO" "SA" "SK" "ES" "SE" "TN" "VG"))
                             (25  ("PT"))
                             (26  ("IS" "TR"))
                             (27  ("FR" "GR" "IT" "MR" "MC" "SM"))
                             (28  ("AL" "AZ" "CY" "DO" "GT" "HU" "LB" "PL"))
                             (29  ("BR" "PS"))
                             (30  ("KW" "MU"))
                             (31  ("MT"))))

;; Remove spaces and set upper case.
(define (sanitize-iban iban)
   (upper-case (replace " " iban ""))
)

;; Check that only A-Z and 0-9 are used.
(define (valid-chars? iban)
  (setq rx (string "[A-Z0-9]{" (length iban) "}" ))
  (regex rx iban 1)
)

;; Check that the length is correct for the country.
(define (valid-length? iban)
  (setq countries-found (lookup (int (length iban)) *iban-code-length*))
  (if (not (nil? countries-found))
    (member (0 2 iban) countries-found)
  )
)

;; Convert the IBAN to integer following the rules from Wikipedia.
(define (iban-to-integer iban)
    (setq country-code (0 2 iban))
    (setq checksum (2 2 iban))
    (setq iban (string (4 iban) country-code))
    (setq iban (join (map (lambda (x) (if (regex "[0-9]" x) x (string (- (char x) 55)))) (explode iban))))
    (bigint (string iban checksum))
)

;; Test if IBAN is correct (true) or not (nil):
;; (valid-iban? "GB82 WEST 1234 5698 7654 32") ==> true
;; (valid-iban? "GB82 TEST 1234 5698 7654 32") ==> nil
(define (valid-iban? iban)
    (setq iban (sanitize-iban iban))
    (and
        (valid-chars? iban)
        (valid-length? iban)
        (= 1L (% (iban-to-integer iban) 97))
    )
)

(valid-iban? "GB82 WEST 1234 5698 7654 32")
;-> true

(valid-iban? "GB82 TEST 1234 5698 7654 32")
;-> nil


-----------------------
ESTENDERE IL LINGUAGGIO
-----------------------

Introdurre un nuovo meccanismo di controllo del flusso. Un esempio pratico e utile è un ramo a quattro vie (four-way branch): alle volte, è necessario scrivere codice che dipende da due condizioni, risultando in un massimo di quattro rami (a seconda che entrambe, solo la prima, solo la seconda o nessuna delle condizioni siano "vere"). In un linguaggio simile al C questo potrebbe essere il seguente:

  if (condition1isTrue) {
     if (condition2isTrue)
        bothConditionsAreTrue();
     else
        firstConditionIsTrue();
  }
  else if (condition2isTrue)
     secondConditionIsTrue();
  else
     noConditionIsTrue();

Oltre ad essere piuttosto ingombrante, le espressioni per 'condition2isTrue' devono essere scritte due volte. Se 'condition2isTrue' fosse un'espressione lunga e complessa, sarebbe abbastanza illeggibile e il codice generato dal compilatore potrebbe essere inutilmente grande.

Questo può essere migliorato introducendo una nuova parola chiave if2. È simile a if, ma accetta due istruzioni condizionali invece di una e fino a tre istruzioni "else". Una proposta (in sintassi pseudo-C) potrebbe essere:

  if2 (condition1isTrue) (condition2isTrue)
     bothConditionsAreTrue();
  else1
     firstConditionIsTrue();
  else2
     secondConditionIsTrue();
  else
     noConditionIsTrue();

Scegli la sintassi che si adatta al tuo linguaggio. Le parole chiave "else1" e "else2" sono solo esempi. La nuova espressione condizionale dovrebbe apparire, annidarsi e comportarsi in modo analogo all'istruzione "if" incorporata nel linguaggio.

(context 'if2)

(define-macro (if2:if2 cond1 cond2 both-true first-true second-true neither)
  (cond
    ((eval cond1)
      (if (eval cond2)
            (eval both-true)
            (eval first-true)))
    ((eval cond2)
      (eval second-true))
    (true
      (eval neither))))

(context MAIN)

(if2 true true 'bothTrue 'firstTrue 'secondTrue 'else)
;-> bothTrue
(if2 true false 'bothTrue 'firstTrue 'secondTrue 'else)
;-> firstTrue
(if2 false true 'bothTrue 'firstTrue 'secondTrue 'else)
;-> secondTrue
(if2 false false 'bothTrue 'firstTrue 'secondTrue 'else)
;-> else


------------------------
COMPOSIZIONE DI FUNZIONI
------------------------

Creare una funzione "compose" i cui due argomenti f e g sono entrambi funzioni con un argomento.
Il risultato di compose deve essere una funzione di un argomento, (chiamiamo l'argomento x), che applica la funzione f al risultato dell'applicazione della funzione g a x: compose(f, g) (x) = f(g(x)).

(define (compose f g) (expand (lambda (x) (f (g x))) 'f 'g))

((compose sin asin) 0.5)
;-> 0.5
((compose sqrt pow) 3)
;-> 3


--------------------
CALCOLO DI UNA SERIE
--------------------

Calcolare l'ennesimo termine di una serie, cioè la somma degli n primi termini della sequenza corrispondente.
Questo valore, o il suo limite quando n tende all'infinito, è anche chiamato la somma della serie.

Definiamo una funzione che accetta tre parametri:
1) la funzione da calcolare
2) il valore iniziale dell'indice
3) il valore finale dell'indice

(define (sum-series func from to)
  (let (s 0)
    (for (i from to)
      (inc s (func i))
    )
    s))

Adesso per calcolare la serie di una funzione occorre prima definire la funzione matematica e poi usare "sum-series". Ad esempio:

Sum[x 1 n] (1/x^2) = π²/6
(define (f x) (div 1 (* x x)))
(sum-series f 1 1000)
;-> 1.643934566681562

Sum[x 0 n] (1/2^x) = 2
(define (g x) (div (pow 2 x)))
(sum-series g 0 1000)
;-> 2

Serie con segni alternati
Sum[x 1 n] (-1)^(n-1)/n = ln(2)
(define (h x) (div (pow -1 (- x 1)) x))
(sum-series h 1 1000)
;-> 0.6931471805599453
(log 2)
;-> 0.6931471805599453

Sum[x 0 n] 1/x! = e
(define (fact n)
  (if (zero? n)
      1
      (apply * (map bigint (sequence 1 n)))))
(define (o x) (div (fact x)))
(sum-series o 0 100)
;-> 2.718281828459046


-------------
NUMERI GAPFUL
-------------

I numeri (interi positivi espressi in base dieci) che sono (esattamente) divisibili per il numero formato dalla prima e dall'ultima cifra sono noti come numeri gapful. Esattamente divisibile significa divisibile senza resto.
Tutti i numeri a una e due cifre hanno questa proprietà e sono banalmente esclusi. Solo i numeri ≥ 100 saranno considerati.
Esempio
187 è un numero gapful perché è esattamente divisibile per il numero 17 che è formato dalla prima e dall'ultima cifra decimale di 187.
Circa il 7,46% degli interi positivi è gapful.

;; Create an integer out of the first and last digits of a given integer
(define (first-and-last-digits number)
 (local (digits first-digit last-digit)
  (set 'digits (format "%d" number))
  (set 'first-digit (first digits))
  (set 'last-digit (last digits))
  (int (append first-digit last-digit))))

;; Divisibility test
(define (divisible-by? num1 num2)
 (zero? (% num1 num2)))

;; Gapfulness test
(define (gapful? number)
 (divisible-by? number (first-and-last-digits number)))

;; Increment until a gapful number is found
(define (next-gapful-after number)
 (do-until (gapful? number)
  (++ number)))

;; Return a list of gapful numbers beyond some (excluded) lower limit.
(define (gapful-numbers quantity lower-limit)
 (let ((gapfuls '()) (number lower-limit))
  (dotimes (counter quantity)
   (set 'number (next-gapful-after number))
   (push number gapfuls))
  (reverse gapfuls)))

;; Format a list of numbers together into decimal notation.
(define (format-many numbers)
 (map (curry format "%d") numbers))

;; Format a list of integers on one line with commas
(define (format-one-line numbers)
 (join (format-many numbers) ", "))

;; Display a quantity of gapful numbers beyond some (excluded) lower limit.
(define (show-gapfuls quantity lower-limit)
 (println "The first " quantity " gapful numbers beyond " lower-limit " are:")
 (println (format-one-line (gapful-numbers quantity lower-limit))))

; Example: calculate gapful numbers
(show-gapfuls 30 99)
;-> The first 30 gapful numbers beyond 99 are:
;-> 100, 105, 108, 110, 120, 121, 130, 132, 135, 140, 143, 150, 154, 160, 165,
;-> 170, 176, 180, 187, 190, 192, 195, 198, 200, 220, 225, 231, 240, 242, 253
(show-gapfuls 15 999999)
;-> The first 15 gapful numbers beyond 999999 are:
;-> 1000000, 1000005, 1000008, 1000010, 1000016, 1000020, 1000021, 1000030,
;-> 1000032, 1000034, 1000035, 1000040, 1000050, 1000060, 1000065
(show-gapfuls 10 999999999)
;-> The first 10 gapful numbers beyond 999999999 are:
;-> 1000000000, 1000000001, 1000000005, 1000000008, 1000000010,
;-> 1000000016, 1000000020, 1000000027, 1000000030, 1000000032


----------------------------------
VALUTAZIONE DI UNA ESPRESSIONE RPN
----------------------------------

Valutare il valore di un'espressione aritmetica nella notazione polacca inversa (Reverse Polish Notation). Gli operatori validi sono:

"+" "-" "*" "/" "%"
"add" "sub" "mul" "div" "mod" "pow"
"abs" "sqrt" "exp"
"sin" "cos" "tan"
"asin" "acos" "atan" "atan2"

Ogni operando può essere un numero o un'altra espressione. Per esempio:

Questo problema può essere risolto utilizzando una pila (stack). Valutiamo ogni elemento dell'espressione (lista):
- quando è un numero, lo mettiamo nella pila (push).
- quando è un operatore, prendiamo (pop) i numeri che servono dalla pila, eseguiamo il calcolo e mettiamo (push) il risultato nella pila (per decidere quanti sono "i numeri che servono dalla pila" basta vedere quanti numeri servono all'operatore corrente).

Per capire come funziona, scriviamo una versione che accetta solo le quattro operazioni "+" "-" "*" "/":

(define (eval-rpn lst)
  (local (stack a b)
    (setq stack '())
    (dolist (el lst)
      (if (number? el) ; se è un numero...
          (push el stack) ; lo metto nella pila
          (begin ; altrimenti è un operatore
            ; prendo due numeri dalla pila
            (setq a (pop stack))
            (setq b (pop stack))
            ; applico l'operatore e
            ; inserisco il risultato nella pila
            (cond ((= el '+) (push (+ a b) stack))
                  ((= el '-) (push (- b a) stack))
                  ((= el '*) (push (* a b) stack))
                  ((= el '/) (push (/ b a) stack))
                  (true (println "error"))
            )
          )
      )
    )
    ;restituisco il valore in cima alla pila
    (pop stack)
  )
)

Adesso scriviamo la funzione che accetta tutti gli operatori:

(define (eval-rpn lst)
  (local (stack a b op op1 op2)
    (setq stack '())
    ; lista operatori con un argomento
    (setq op1 '(abs sqrt exp sin cos tan asin acos atan))
    ; lista operatori con due argomenti
    (setq op2 '(+ - * / % add sub mul div mod pow atan2))
    ; Per ogni simbolo della lista...
    (dolist (el lst)
      (cond ((number? el)     ; se è un numero...
             (push el stack)) ; lo metto nella pila
            (true ; altrimenti è un operatore
             (cond ((find el op1) ; se è un operatore unario...
                    (setq a (pop stack))    ; prendo numero dalla pila
                    (setq op (eval el))     ; calcolo operazione
                    (push (op a) stack))    ; inserisco risultato nella pila
                   ((find el op2) ; se è un operatore binario...
                    (setq a (pop stack))    ; prendo primo numero dalla pila
                    (setq b (pop stack))    ; prendo secondo numero dalla pila
                    (setq op (eval el))     ; calcolo operazione e
                    (push (op b a) stack))  ; inserisco risultato nella pila
                   (true (println "operator error:" el))
             ))
      )
    )
    ;restituisco il valore in cima alla pila
    (pop stack)
  )
)

(eval-rpn '(3 2 + 7 * 4 / ))
;-> 8
(eval-rpn '(3 2 + 7 * 4 / 2.5 add))
;-> 10.5
(eval-rpn '(4 13 5 / +))
;-> 6
(eval-rpn '(3 2 pow))
;-> 9
(eval-rpn '(3 4 - abs))
;-> 1
(eval-rpn '(10 4 %))
;-> 2
(eval-rpn '(3 4 2 * 1 5 - 2 3 pow pow / +))
;-> 3

Proviamo a scrivere un'altra funzione che accetta anche le variabili globali. Per fare questo valutiamo gli elementi dell'espressione rpn e sostituiamo i valori, per esempio:

(setq q 3 t 5)
(setq expr '(q t 2 * 1 5 - 2 3 pow pow / +))
(map eval expr)
;-> (3 5 2 *@414964 1 5 -@414951 2 3 pow@40D998 pow@40D998 /@414977 +@41493E)

Questo non va bene perchè valutiamo anche gli operatori (i numeri vengono valutati su se stessi), allora usiamo una funzione specifica:

(map (fn (x) (if (not (protected? x)) (eval x) x)) expr)
;-> (3 5 2 * 1 5 - 2 3 pow pow / +)

Come si vede le variabili "q" e "t" sono state sostituite dai loro valori. Se abbiamo una variabile non inizializzata questa non viene valutata:

(setq expr '(z q t 2 * 1 5 - 2 3 pow pow / +))
(map (fn (x) (if (not (protected? x)) (eval x) x)) expr)
;-> (z 3 5 2 * 1 5 - 2 3 pow pow / +)

e genererà un errore nella funzione "eval-rpn".

Adesso possiamo scrivere la funzione che utilizza le variabili globali:

(define (eval-rpn lst)
  (local (_stack _a _b _op _op1 _op2)
    (setq _stack '())
    ; lista operatori con un argomento
    (setq _op1 '(abs sqrt exp sin cos tan asin acos atan))
    ; lista operatori con due argomenti
    (setq _op2 '(+ - * / % add sub mul div mod pow atan2))
    ; Valuto gli elementi della lista (espressione rpn) e
    ; assegno il valore alle variabili
    (setq lst (map (fn (x) (if (not (protected? x)) (eval x) x)) lst))
    ; Per ogni simbolo della lista...
    (dolist (el lst)
      (cond ((number? el)      ; se è un numero...
             (push el _stack)) ; lo metto nella pila
            (true ; altrimenti è un operatore
             (cond ((find el _op1) ;operatore unario
                    (setq _a (pop _stack))    ; prendo numeri dalla pila
                    (setq _op (eval el))     ; calcolo operazione
                    (push (_op _a) _stack))    ; inserisco risultato nella pila
                   ((find el _op2) ;operatore binario
                    (setq _a (pop _stack))    ; prendo numeri dalla pila
                    (setq _b (pop _stack))    ; prendo numeri dalla pila
                    (setq _op (eval el))     ; calcolo operazione
                    (push (_op _b _a) _stack))  ; inserisco risultato nella pila
                   (true (println "operator error:" el))
             ))
      )
    )
    ;restituisco il valore in cima alla pila
    (pop _stack)
  )
)

(eval-rpn '(3 4 2 * 1 5 - 2 3 pow pow / +))
;-> 3
(setq a 10 b 20)
(setq c (eval-rpn '(a b +)))
;-> 30

(eval-rpn '(a b + 5 - sqrt))
;-> 5


---------------
IL GIOCO DEL 24
---------------

Dati quattro numeri distinti da 1 a 9, costruire un'espressione con questi numeri e le quattro operazioni (+, -, *, /) che valuti a 24. Per esempio, con i numeri 2, 4, 5, e 6 possiamo scrivere: (((6 - 2) * 5) + 4) = 24
Occorre utilizzare tutti i numeri della lista, ma non è necessario utilizzare tutte e quattro le operazioni nell'espressione finale.

Risolviamo il problema creando e valutando tutte le possibili espressioni. La valutazione delle espressioni viene fatta in modo rpn.

(define (eval-rpn lst)
  (local (stack a b op op1 op2)
    (setq stack '())
    (setq op1 '(abs sqrt exp sin cos tan asin acos atan))
    (setq op2 '(+ - * / % add sub mul div mod pow atan2))
    (dolist (el lst)
      (cond ((number? el)
             (push el stack))
            (true
             (cond ((find el op1)
                    (setq a (pop stack))
                    (setq op (eval el))
                    (push (op a) stack))
                   ((find el op2)
                    (setq a (pop stack))
                    (setq b (pop stack))
                    (setq op (eval el))
                    (push (op b a) stack))
                   (true (println "operator error:" el))))))
    (pop stack)))

(eval-rpn '(3 2 + 7 * 4 / ))
;-> 8

Per creare le espressioni da valutare occorrono due funzioni di calcolo combinatorio: le permutazioni senza ripetizioni e le permutazioni con ripetizione.

Permutazioni senza ripetizione (n!):

(define (perm lst)
  (local (i indici out)
    (setq indici (dup 0 (length lst)))
    (setq i 0)
    (setq out (list lst))
    (while (< i (length lst))
      (if (< (indici i) i)
          (begin
            (if (zero? (% i 2))
              (swap (lst 0) (lst i))
              (swap (lst (indici i)) (lst i))
            )
            (push lst out -1)
            (++ (indici i))
            (setq i 0)
          )
          (begin
            (setf (indici i) 0)
            (++ i)
          )
       )
    ) out))

(perm '(a b c))
;-> ((a b c) (b a c) (c a b) (a c b) (b c a) (c b a))

(perm '(a b b))
;-> ((a b b) (b a b) (b a b) (a b b) (b b a) (b b a))

Permutazioni con ripetizione (n^k):

(define (perm-rep k lst)
  (if (zero? k) '(())
      (flat (map (lambda (p) (map (lambda (e) (cons e p)) lst))
                         (perm-rep (- k 1) lst)) 1)))

(perm-rep 2 '(a b c))
;-> ((a a) (b a) (c a) (a b) (b b) (c b) (a c) (b c) (c c))

(perm-rep 2 '(a b b))
;-> ((a a) (b a) (b a) (a b) (b b) (b b) (a b) (b b) (b b))

Lista delle operazioni:
(setq op '(add sub mul div))

Lista delle operazioni possibili (n^k) = 4^3 = 64:
(setq operats (perm-rep 3 op))
;-> ((add add add) (sub add add) (mul add add) (div add add)
;->  (add sub add) (sub sub add) (mul sub add) (div sub add)
;->  ...
;->  (add div div) (sub div div) (mul div div) (div div div))

(length operats);-> 64
(pow 4 3);-> 64

Lista dei numeri singoli:
(setq num '(3 7 1 8))

Lista dei numeri possibili (n! = 4! = 24):
(setq digits (perm num))
;-> ((3 7 1 8) (7 3 1 8) (1 3 7 8) (3 1 7 8) (7 1 3 8) (1 7 3 8) (8 7 3 1)
;->  (7 8 3 1) (3 8 7 1) (8 3 7 1) (7 3 8 1) (3 7 8 1) (3 1 8 7) (1 3 8 7)
;->  (8 3 1 7) (3 8 1 7) (1 8 3 7) (8 1 3 7) (8 1 7 3) (1 8 7 3) (7 8 1 3)
;->  (8 7 1 3) (1 7 8 3) (7 1 8 3))

(length digits)
;-> 24

Adesso possiamo unire le due liste per creare una espressione da valutare.

Creazione dell'espressione da valutare:
(setq expr (append (digits 0) (operats 0)))
;-> (3 7 1 8 add add add)

Valutazione dell'espressione:
(eval-rpn expr)
;-> 19

Adesso scriviamo la funzione finale:

(define (game24 lst)
(local (op operats num digits out)
  (setq out '())
  (setq op '(add sub mul div))
  (setq operats (perm-rep 3 op))
  (setq digits (perm lst))
  (dolist (digit digits)
    (dolist (oper operats)
      (setq expr (append digit oper))
      (if (= 24 (eval-rpn expr))
          (begin
          ;(println expr)
          (replace 'add expr '+)
          (replace 'sub expr '-)
          (replace 'mul expr '*)
          (replace 'div expr '/)
          (println expr)
          (push expr out -1)
          )
      )
    )
  )
  out))

(game24 '(2 4 5 6))
;-> (4 5 2 6 - * -)
;-> (6 2 4 5 + * +)
;-> (6 2 4 5 * - -)
;-> (6 2 5 4 + * +)
;-> (6 2 5 4 * - -)
;-> (4 5 6 2 - * +)
;-> ((4 5 2 6 - * -) (6 2 4 5 + * +) (6 2 4 5 * - -)
;->  (6 2 5 4 + * +) (6 2 5 4 * - -) (4 5 6 2 - * +))

Proviamo a generalizzare il gioco  utilizzando fino a 9 numeri iniziali (1..9) e un numero qualunque da raggiungere (goal). Inoltre convertiamo l'espressione rpn in espressione infissa per la stampa.

Routine che converte l'espressione rpn nella corrispondente espressione infissa:

(define (infix lst)
  (local (s c)
    (setq s "")
    (setq c (/ (length lst) 2))
    (setq lst (map string lst))
    (dotimes (i c)
      (push "(" s -1)
      (push (lst i) s -1)
      (push " " s -1)
      (push (lst (- (length lst) 1 i)) s -1)
      (push " " s -1)
    )
    (push (lst c) s -1)
    (push (dup ")" c) s -1)
    s))

(infix '(2 1 4 3 5 6 7 8 9 * * - + + * - +))
;-> "(2 + (1 - (4 * (3 + (5 + (6 - (7 * (8 * 9))))))))"

Routine che converte l'espressione rpn nella corrispondente espressione prefissa:

(define (pre-fix lst)
  (local (s c)
    (setq s "")
    (setq c (/ (length lst) 2))
    (setq lst (map string lst))
    (dotimes (i c)
      (push "(" s -1)
      (push (lst (- (length lst) 1 i)) s -1)
      (push " " s -1)
      (push (lst i) s -1)
      (push " " s -1)
    )
    (push (lst c) s -1)
    (push (dup ")" c) s -1)
    s))

(pre-fix '(2 1 4 3 5 6 7 8 9 * * - + + * - +))
;-> "(+ 2 (- 1 (* 4 (+ 3 (+ 5 (- 6 (* 7 (* 8 9))))))))"

(eval-string (pre-fix '(2 1 4 3 5 6 7 8 9 * * - + + * - +)))
;-> 1963

Funzione finale:

(define (game-number lst goal)
(local (op operats digits out)
  (setq out '())
  (setq op '(add sub mul div))
  (setq operats (perm-rep (- (length lst) 1) op))
  (setq digits (perm lst))
  (dolist (digit digits)
    (dolist (oper operats)
      (setq expr (append digit oper))
      (if (= goal (eval-rpn expr))
          (begin
          ;(println expr)
          (replace 'add expr '+)
          (replace 'sub expr '-)
          (replace 'mul expr '*)
          (replace 'div expr '/)
          (println (infix expr))
          (push (list expr (infix expr)) out -1)
          )
      )
    )
  )
  out))

Proviamo con il gioco del 24:

(game-number '(2 4 5 6) 24)
;-> (4 - (5 * (2 - 6)))
;-> (6 + (2 * (4 + 5)))
;-> (6 - (2 - (4 * 5)))
;-> (6 + (2 * (5 + 4)))
;-> (6 - (2 - (5 * 4)))
;-> (4 + (5 * (6 - 2)))
;-> ((4 5 2 6 - * -) (6 2 4 5 + * +) (6 2 4 5 * - -)
;->  (6 2 5 4 + * +) (6 2 5 4 * - -) (4 5 6 2 - * +))

Proviamo un insieme di numeri che non hanno soluzione:

(game-number '(5 7 5 1) 24)
;-> ()

Proviamo con altri numeri:

(game-number '(1 3 7 10 25 50) 831)
;-> ()

(game-number '(1 3 7 10 25 50) 765)
(25 + (10 * (50 + (3 * (1 + 7)))))
(50 / (10 / (3 - (25 * (1 - 7)))))
(50 / (10 / (3 + (25 * (7 - 1)))))
(25 + (10 * (50 + (3 * (7 + 1)))))
;-> (((25 10 50 3 1 7 + * + * +) "(25 + (10 * (50 + (3 * (1 + 7)))))")
;->  ((50 10 3 25 1 7 - * - / /) "(50 / (10 / (3 - (25 * (1 - 7)))))")
;->  ((50 10 3 25 7 1 - * + / /) "(50 / (10 / (3 + (25 * (7 - 1)))))")
;->  ((25 10 50 3 7 1 + * + * +) "(25 + (10 * (50 + (3 * (7 + 1)))))"))

(game-number '(1 2 3 4 5 6 7 8 9) 1963)
(2 + (1 - (4 * (3 + (5 + (6 - (7 * (8 * 9))))))))
(1 + (2 - (4 * (3 + (5 + (6 - (7 * (8 * 9))))))))
(3 - (4 * (1 + (2 + (5 + (6 - (7 * (8 * 9))))))))
(3 - (4 * (2 + (1 + (5 + (6 - (7 * (8 * 9))))))))
(3 + (5 * (4 - (1 * (2 + (6 * (7 - (8 * 9))))))))
......

Per verifica prendiamo il primo risultato:
(eval-rpn '(2 1 4 3 5 6 7 8 9 * * - + + * - +))
;-> 1963
(2 + (1 - (4 * (3 + (5 + (6 - (7 * (8 * 9))))))))
(2 + (1 - (4 * (3 + (5 + (6 - (7 * (72))))))))
(2 + (1 - (4 * (3 + (5 + (6 - (504)))))))
(2 + (1 - (4 * (3 + (5 + (-498))))))
(2 + (1 - (4 * (3 + (-493)))))
(2 + (1 - (4 * (-490))))
(2 + (1 - (-1960)))
(2 + 1961)
1963

(game-number '(1 2 3 4 5 6 7 8 9) 2020)
;-> (4 / (3 * (2 / (1 + (5 + (6 * (7 * (8 * 9))))))))
;-> (4 / (3 * (2 / (1 + (5 + (6 * (7 * (8 * 9))))))))
;-> ......

(game-number '(1 2 3 4 5 6 7 8 9) 666)
;-> (3 * (1 * (2 - (4 * (5 + (6 * (7 - (8 + 9))))))))
;-> (3 / (1 / (2 - (4 * (5 + (6 * (7 - (8 + 9))))))))
;-> (1 * (3 * (2 - (4 * (5 + (6 * (7 - (8 + 9))))))))
;-> (3 * (2 - (1 * (4 * (5 + (6 * (7 - (8 + 9))))))))
;-> (2 + (4 * (1 - (3 * (5 + (6 * (7 - (8 + 9))))))))
;-> (2 * (1 + (4 * (3 + (5 * (6 - (7 - (8 + 9))))))))
;-> ......

Nota:
Con 9 cifre (da 1 a 9) abbiamo n! = 9! = 362880 modi di disporre le cifre nell'espressione
Con 9 cifre abbiamo 8 operazioni con 4 operatori n^k = 4^8 = 65536 modi di disporre gli operatori nell'espressione.
(* 362880 65536)
;-> 23781703680 ; (23 miliardi 781 milioni 703 mila 680) espressioni


-------------
SEQUENZA FUSC
-------------

La sequenza "fusc" (chiamata anche sequenza di Stern) è definita nel modo seguente:

  fusc(0) = 0
  fusc(1) = 1
  per n > 1, fusc(n) vale:
  se n è pari:     fusc(n) = fusc(n/2)
  se n è dispari:  fusc(n) = fusc((n-1)/2) + fusc((n+1)/2)

Questa è la sequenza OEIS A002487.

Vediamo prima di tutto la versione ricorsiva:

(define (fusc n)
  (cond ((or (zero? n) (= 1 n)) n)
        ((even? n) (fusc (/ n 2)))
        (true (+ (fusc (/ (- n 1) 2)) (fusc(/ (+ n 1) 2))))))

(fusc 10)
;-> 3

(map fusc (sequence 0 100))
;-> (0 1 1 2 1 3 2 3 1 4 3 5 2 5 3 4 1 5 4 7 3 8 5 7 2 7 5 8 3
;->  7 4 5 1 6 5 9 4 11 7 10 3 11 8 13 5 12 7 9 2 9 7 12 5 13
;->  8 11 3 10 7 11 4 9 5 6 1 7 6 11 5 14 9 13 4 15 11 18 7 17
;->  10 13 3 14 11 19 8 21 13 18 5 17 12 19 7 16 9 11 2 11 9 16 7)

Adesso vediamo la versione iterativa.
Possiamo evitare completamente la ricorsione poiché possiamo sempre esprimere fusc(n) nella forma a*fusc(m) + b*fusc(m + 1) riducendo il valore di m a 0. Abbiamo il seguente schema:

se m è dispari:
a*fusc(m) + b*fusc(m+1) = a*fusc((m-1)/2) + (b+a)*fusc((m+1)/2)

se m è pari:
a*fusc(m) + b*fusc(m+1) = (a+b)*fusc(m/2) + b*fusc((m/2)+1)

Pertanto è possibile utilizzare un ciclo per risolvere il problema in tempo O(log n):

(define (fusc-i n)
  (local (a b)
    (setq a 1 b 0)
    (cond ((zero? n) 0)
          (true (while (> n 0)
                  (if (odd? n)
                      (setq b (+ b a) n (/ (- n 1) 2))
                      (setq a (+ a b) n (/ n 2)))
                )
          )
    )
    b))

(fusc-i 10)
;-> 3

(map fusc-i (sequence 0 100))
;-> (0 1 1 2 1 3 2 3 1 4 3 5 2 5 3 4 1 5 4 7 3 8 5 7 2 7 5 8 3
;->  7 4 5 1 6 5 9 4 11 7 10 3 11 8 13 5 12 7 9 2 9 7 12 5 13
;->  8 11 3 10 7 11 4 9 5 6 1 7 6 11 5 14 9 13 4 15 11 18 7 17
;->  10 13 3 14 11 19 8 21 13 18 5 17 12 19 7 16 9 11 2 11 9 16 7)

Adesso risolviamo il problema con la programmazione dinamica.
Memorizziamo i due casi base di fs(0) = 0, fs(1) = 1, e poi attraversiamo il vettore dall'indice 2 a n calcolando fs(i) come da definizione. Infine restituiamo il valore di fs(n).

(define (fusc-dp n)
  (let (fs (array (+ n 2) '(0)))
    (setf (fs 0) 0)
    (setf (fs 1) 1)
    (if (> n 1)
      (for (i 2 n)
        (if (even? i)
            (setf (fs i) (fs (/ i 2)))
            (setf (fs i) (+ (fs (/ (- i 1) 2)) (fs (/ (+ i 1) 2))))
        )
      )
    )
    (fs n)))

(fusc-dp 10)
;-> 10

(map fusc-dp (sequence 0 100)))
;-> (0 1 1 2 1 3 2 3 1 4 3 5 2 5 3 4 1 5 4 7 3 8 5 7 2 7 5 8 3
;->  7 4 5 1 6 5 9 4 11 7 10 3 11 8 13 5 12 7 9 2 9 7 12 5 13
;->  8 11 3 10 7 11 4 9 5 6 1 7 6 11 5 14 9 13 4 15 11 18 7 17
;->  10 13 3 14 11 19 8 21 13 18 5 17 12 19 7 16 9 11 2 11 9 16 7)

Vediamo se le tre funzioni producono risultati uguali:

(= (map fusc (sequence 0 100))
   (map fusc-i (sequence 0 100))
   (map fusc-dp (sequence 0 100)))
;-> true

Vediamo i tempi di esecuzione delle funzioni:

(time (map fusc (sequence 0 10000)))
;-> 622.346

(time (map fusc-i (sequence 0 10000)))
;-> 17.959

(time (map fusc-dp (sequence 0 10000)))
;-> 8244.964

La versione iterativa è quella più veloce, ma la versione con la programmazione dinamica calcola tutti i valori della funzione da 0 a n. Quindi il confronto dovrebbe essere fatto nel modo seguente.
Riscriviamo fusc-dp in modo che restituisca una lista con tutti i valori:

(define (fusc-n n)
  (let (fs (array (+ n 2) '(0)))
    (setf (fs 0) 0)
    (setf (fs 1) 1)
    (if (> n 1)
      (for (i 2 n)
        (if (even? i)
            (setf (fs i) (fs (/ i 2)))
            (setf (fs i) (+ (fs (/ (- i 1) 2)) (fs (/ (+ i 1) 2))))
        )
      )
    )
    (slice fs 0 (+ n 1))))

Vediamo se le funzioni producono risultati uguali:

(= (map fusc-i (sequence 0 100000)) (array-list (fusc-n 100000)))
;-> true

Adesso facciamo il confronto:

(time (map fusc-i (sequence 0 100000)))
;-> 217.446
(time (fusc-n 100000))
;-> 18.937

In questo caso (cioè quando vogliamo tutti i valori della funzione fusc da 0 a n) la funzione fusc-n è molto più veloce.


--------------
ALGORITMO DAMM
--------------

Nel rilevamento degli errori, l'algoritmo di Damm è un algoritmo di cifre di controllo che rileva tutti gli errori di una cifra e tutti gli errori di trasposizione adiacenti. È stato presentato da H. Michael Damm nel 2004.
L'algoritmo di Damm rileva tutte le occorrenze dei due tipi di errori di trascrizione più frequenti, vale a dire l'alterazione di una singola cifra e la trasposizione di due cifre adiacenti (inclusa la trasposizione della cifra di controllo finale e della cifra precedente).

(define (damm-encode number)
  (local (dm out)
    (setq dm
      '((0 3 1 7 5 9 8 6 4 2)
        (7 0 9 2 1 5 4 8 6 3)
        (4 2 0 6 8 7 1 3 5 9)
        (1 7 5 0 9 8 3 4 2 6)
        (6 1 2 3 0 4 5 9 7 8)
        (3 6 7 4 2 0 9 5 8 1)
        (5 8 6 9 7 2 0 1 3 4)
        (8 9 4 5 3 6 2 0 1 7)
        (9 4 3 8 6 1 7 2 0 5)
        (2 5 8 1 4 3 6 7 9 0)))
    (setq out 0)
    (dostring (el (string number))
      (setq out (dm out (int (char el))))
    )
    out))

(define (check-damm-encode number)
  (zero? (damm-encode number)))

(damm-encode 572)
;-> 4

(check-damm-encode 5724)
;-> true

(damm-encode 43881234567)
;-> 9

(check-damm-encode 438812345679)
;-> true


----------------------------------
DISTANZA TRA DUE PUNTI DELLA TERRA
----------------------------------

Utilizziamo la formula "haversine" per calcolare la distanza minima tra due punti di una sfera (tale distanza viene chiamata "ortodromia"). Si tratta quindi della distanza più breve tra due punti della superficie terrestre (in linea d'aria e ignorando l'orografia).
Le coordinate per la latitudine e la longitudine sono espresse in gradi decimali.

(define (deg-rad deg) (div (mul deg 3.1415926535897931) 180))

(define (dist-earth lat1 lon1 lat2 lon2)
  (local (r dLat dLon a c d)
  (setq r 6371) ; raggio medio della terra in km
  (setq dLat (deg-rad (sub lat2 lat1))) ; delta lat (in radianti)
  (setq dLon (deg-rad (sub lon2 lon1))) ; delta lon (in radianti)
  (setq a (add (mul (sin (div dLat 2)) (sin (div dLat 2)))
               (mul (cos (deg-rad lat1)) (cos (deg-rad lat2))
                    (sin (div dLon 2)) (sin (div dLon 2)))))
  (setq c (mul 2 (atan2 (sqrt a) (sqrt (sub 1 a)))))
  (setq d (mul r c)))) ; distanza in km

(dist-earth 42.123456 13.123456 54.654321 8.654321)
;-> 1431.173709679866
(dist-earth 42.123456 -10.123456 54.654321 -2.654321)
;-> 1496.522788559527

La formula di haversine produce un errore massimo dello 0.5% (poichè la terra è un elissoide e non una sfera).


-----------------
ALGORITMO SOUNDEX
-----------------

Soundex è un algoritmo fonetico per l'indicizzazione dei nomi in base al suono (come pronunciati in inglese). L'obiettivo è che gli omofoni (parole che hanno la stessa pronuncia, ma differiscono nella grafia) siano codificati nella stessa rappresentazione in modo che possano essere riconosciuti come simili nonostante piccole differenze di ortografia. L'algoritmo codifica principalmente le consonanti, una vocale non viene codificata a meno che non sia la prima lettera. Soundex è il più conosciuto di tutti gli algoritmi fonetici ed è la base di molti algoritmi fonetici moderni.

I passi dell'algoritmo ufficiale sono i seguenti:

1) Conserva la prima lettera del nome e elimina tutte le altre occorrenze di a, e, i, o, u, y, h, w.
2) Sostituisci le consonanti con le cifre come segue (dopo la prima lettera):
   b, f, p, v → 1
   c, g, j, k, q, s, x, z → 2
   d, t → 3
   l → 4
   m, n → 5
   r → 6
3) Se due o più lettere con lo stesso numero sono adiacenti nel nome originale (prima del passaggio 1), conservare solo la prima lettera. Anche due lettere con lo stesso numero separate da "h" o "w" sono codificate come un numero unico, mentre tali lettere separate da una vocale sono codificate due volte. Questa regola si applica anche alla prima lettera.
4) Se hai poche lettere nel nome e non puoi assegnare tre numeri, aggiungi degli zeri fino a quando non ci sono tre numeri. Se hai quattro o più numeri, conserva solo i primi tre.

Funzione che formatta una stringa in una determinata lunghezza con un carattere predefinito:

(define (pad-string str ch len)
  (local (out len-str)
    (setq out "")
    (setq len-str (length str))
    (cond ((zero? len-str) (setq out (dup ch len)))
          ((= len-str len) (setq out str))
          ((> len-str len) (setq out (slice str 0 len)))
          ((< len-str len) (setq out (push (dup ch (- len len-str)) str -1))))))

(pad-string "" "0" 2)
;-> 00
(pad-string "ABC" "0" 5)
;-> "ABC00"
(pad-string "ABC" "0" 3)
;-> "ABC"
(pad-str "ABC" "0" 2)
;-> "AB"
(pad-str "ABC" "0" 0)
;-> ""

Funzione di decodifica dei caratteri:

(define (getcode ch)
  (letn ((lst '(("B" "1") ("F" "1") ("P" "1") ("V" "1")
                ("C" "2") ("G" "2") ("J" "2") ("K" "2")
                ("Q" "2") ("S" "2") ("X" "2") ("Z" "2")
                ("D" "3") ("T" "3")
                ("L" "4")
                ("M" "5") ("N" "5")
                ("R" "6")
                ("H" "-") ("W" "-")))
        (out (lookup ch lst)))
        (if (nil? out) (setq out ""))
        out))

(getcode "B")
;-> "1"
(getcode "A")
;-> ""
(getcode "H")
;-> "-"

Adesso possiamo scrive la funzione finale "soundex":

(define (soundex str)
  (local (out prev curr)
    (setq str (upper-case str))
    (setq out (str 0))
    (setq prev (getcode (out 0)))
    (dostring (el str)
      (setq curr (getcode (char el)))
      (if (and (!= curr "") (!= curr "-") (!= curr prev))
        (push curr out -1)
      )
      (if (!= curr "-") (setq prev curr))
    )
    (pad-string out "0" 4)))

(soundex "Ashcroft")
;-> A261

(setq lista '("Ashcraft" "Ashcroft" "Gauss" "Ghosh" "Hilbert" "Heilbronn" "Lee" "Lloyd"
              "Moses" "Pfister" "Robert" "Rupert" "Rubin" "Tymczak" "Soundex" "Example"))

(map soundex lista)
;-> ("A261" "A261" "G200" "G200" "H416" "H416" "L000" "L300"
;->  "M220" "P236" "R163" "R163" "R150" "T522" "S532" "E251")

Nota: la maggior parte dei database SQL usa un algoritmo leggermente diverso.

Vediamo cosa accade con dei nomi italiani:

(setq lista '("Mario" "Marco" "Sara" "Lara" "Luca" "Luisa" "Lisa"
              "Massimo" "Massimiliano" "Maria" "Marta"))

(map soundex lista)
;-> ("M600" "M620" "S600" "L600" "L200" "L200" "L200"
;->  "M250" "M254" "M600" "M630")


-------------------------------------
TRASFORMATA DISCRETA DI FOURIER (DFT)
-------------------------------------

Calcola la trasformata discreta di Fourier (DFT) della lista/vettore di numeri complessi in ingresso.

La lista/vettore ha la seguente struttura:

((real1 img1) (real2 img2) ... (realN imgN))

(setq PI 3.1415926535897931)

(define (dft input)
  (local (len sum-real sum-img angle)
    (setq len (length input))
    (setq output (array len '(0)))
    (for (k 0 (- len 1))
      (setq sum-real 0 sum-img 0)
      (for (t 0 (- len 1))
        (setq angle (div (mul 2 PI t k) len))
        (setq sum-real (add sum-real (add (mul (first (input t)) (cos angle))
                                          (mul (last (input t)) (sin angle)))))
        (setq sum-img  (add sum-img  (sub (mul (last (input t)) (cos angle))
                                          (mul (first (input t)) (sin angle)))))
      )
      ;(println sum-real { } sum-img)
      (setf (output k) (list sum-real sum-img))
    )
    output))

Vediamo alcuni esempi:

(setq in '((1 0) (4 0) (3 0) (2 0)))
(dft in)
;-> ((10 0) (-2 -2) (-2 -4.898425415289509e-016) (-2 1.999999999999999))

(setq in '((8 0) (4 0) (8 0) (0 0)))
(dft in)
;-> ((20 0) (0 -4.000000000000001)
;->  (12 1.469527624586853e-015)
;->  (-8.881784197001252e-016 3.999999999999997))

(setq in '(
  (0.4967  0) (-0.1383 0) ( 0.6477 0) ( 1.523  0) (-0.2342 0) (-0.2341 0) ( 1.5792 0)
  ( 0.7674 0) (-0.4695 0) ( 0.5426 0) (-0.4634 0) (-0.4657 0) ( 0.242  0) (-1.9133 0)
  (-1.7249 0) (-0.5623 0) (-1.0128 0) ( 0.3142 0) (-0.908  0) (-1.4123 0) ( 1.4656 0)
  (-0.2258 0) ( 0.0675 0) (-1.4247 0) (-0.5444 0) ( 0.1109 0) (-1.151  0) ( 0.3757 0)
  (-0.6006 0) (-0.2917 0) (-0.6017 0) ( 1.8523 0)))

(setq out (dft in))

Formattiamo meglio il risultato:

(setq outf
  (map list (map (fn(x) (format "%5.4f" (first x))) out)
            (map (fn(x) (format "%5.4f" (last x))) out)))

(dolist (el outf) (println (first el) { } (last el) "i"))
;-> -4.3939 0.0000i
;-> 9.0217 -3.7036i
;-> -0.5874 -6.2268i
;-> 2.5184 3.7749i
;-> 0.5008 -0.8433i
;-> 1.2904 -0.4024i
;-> 4.3391 0.8079i
;-> -6.2614 2.1596i
;-> 1.8974 2.4889i
;-> 0.1042 7.6169i
;-> 0.3606 5.1620i
;-> 4.7965 0.0755i
;-> -5.3064 -3.2329i
;-> 4.6237 1.5287i
;-> -2.1211 4.4873i
;-> -4.0175 -0.3712i
;-> -2.0297 -0.0000i
;-> -4.0175 0.3712i
;-> -2.1211 -4.4873i
;-> 4.6237 -1.5287i
;-> -5.3064 3.2329i
;-> 4.7965 -0.0755i
;-> 0.3606 -5.1620i
;-> 0.1042 -7.6169i
;-> 1.8974 -2.4889i
;-> -6.2614 -2.1596i
;-> 4.3391 -0.8079i
;-> 1.2904 0.4024i
;-> 0.5008 0.8433i
;-> 2.5184 -3.7749i
;-> -0.5874 6.2268i
;-> 9.0217 3.7036i

L'esempio di wikipedia produce risultati differenti:

(setq in '((1 0) (2 -1) (0 -1) (1 2)))

(setq out (dft in))
(setq outf
  (map list (map (fn(x) (format "%5.4f" (first x))) out)
            (map (fn(x) (format "%5.4f" (last x))) out)))
(dolist (el outf) (println (first el) { } (last el) "i"))
;-> 4.0000  0.0000i
;-> -2.0000 -0.0000i
;-> -2.0000 -2.0000i
;-> 4.0000  2.0000i


-----------------
NUMERI DI HARSHAD
-----------------

Un numero di Harshad in una data base è un numero intero positivo divisibile per la somma delle proprie cifre.
La definizione è stata data dal matematico indiano Dattatreya Ramachandra Kaprekar. Il termine Harshad deriva dal sanscrito "harṣa" che significa "grande gioia". A volte ci si riferisce a questi numeri anche come numeri di Niven, in onore del matematico Ivan Morton Niven.

(define (digit-sum num)
  (let (out 0)
    (while (!= num 0)
      (setq out (+ out (% num 10)))
      (setq num (/ num 10)))
    out))

(define (harshad? num)
  (zero? (% num (digit-sum num))))

(setq hd (map harshad? (sequence 1 50)))
(filter true? (map (fn(x) (if x (+ $idx 1))) hd))
;-> (1 2 3 4 5 6 7 8 9 10 12 18 20 21 24 27 30 36 40 42 45 48 50)

Vediamo la velocità:

(time (map harshad? (sequence 1 100000)))
;-> 85.214
(time (map harshad? (sequence 1 1000000)))
;-> 992.429
(time (map harshad? (sequence 1 10000000)))
;-> 10963.707


-------------
NUMERI HUMBLE
-------------

I numeri humble (umili) sono numeri interi positivi che non hanno fattori primi > 7.
Un altro modo per esprimere i numeri Humble è il seguente:

  humble = 2^i × 3^j × 5^k × 7^m
         dove i, j, k, m ≥ 0

1) Trovare i primi 50 numeri Humble.
2) Trovare il numero di numeri Humble che hanno x cifre con 1<= x <= 9

Prima scriviamo una funzione per verificare se un dato numero > 1 è un numero Humble.
Usiamo le primitive di newLISP "factor" e "difference":

(setq ok '(2 3 5 7))
(setq lst1 '(2 3 4 5 7))
(setq lst2 '(2 3 5 5 7))
(setq lst3 '(2))

(difference lst1 ok)
;-> (4)
(difference lst2 ok)
;-> ()
(difference lst3 ok)
;-> ()

Ecco la funzione:

(define (humble? num)
  (null? (difference (factor num) '(2 3 5 7))))

Adesso scriviamo due funzioni che calcolano i numeri di Humble fino a un dato numero:

Prima funzione (iterativa):

(define (humble1-to num)
  (let (out '(0 1))
    (for (i 2 num)
      (if (humble? i)
          (push i out -1)))
    out))

(humble1-to 50)
;-> (0 1 2 3 4 5 6 7 8 9 10 12 14 15 16 18 20 21
;->  24 25 27 28 30 32 35 36 40 42 45 48 49 50)

Seconda funzione (funzionale):

(define (humble2-to num)
  (let (out '(0 1))
    (extend out (map humble? (sequence 2 num)))
    (filter true? (map (fn(x) (if x $idx)) out))))

(humble2-to 50)
;-> (0 1 2 3 4 5 6 7 8 9 10 12 14 15 16 18 20 21
;->  24 25 27 28 30 32 35 36 40 42 45 48 49 50)

Vediamo la velocità delle due funzioni:

(time (humble1-to 1e5))
;-> 166.582
(time (humble1-to 1e6))
;-> 2039.789
(time (humble1-to 1e7))
;-> 27098.987

(time (humble2-to 1e5))
;-> 180.546
(time (humble2-to 1e6))
;-> 2142.921
(time (humble2-to 1e7))
;-> 28169.361

Ma quanti sono i numeri di Humble fino ad un milione (1e6)?

(length (humble1-to 1e6))
;-> 1274

(last (humble1-to 1e6))
;-> 1000000

Cerchiamo di risolvere il secondo problema:

(define (humble-digits num)
  (let (out (array 10 '(0)))
    (setq (out 1) 1)
    (for (i 2 num)
      (if (humble? i)
          (++ (out (length i)))))
    out))

(humble-digits 1e5)
;-> (0 9 36 95 197 356 1 0 0 0)
(humble-digits 1e6)
;-> (0 9 36 95 197 356 579 1 0 0)
(humble-digits 1e7)
;-> (0 9 36 95 197 356 579 882 1 0)
(time (humble-digits 1e7))
;-> 26933.739

Con questa velocità la funzione non riesce a calcolare la soluzione in tempo ragionevole.

Usiamo un'altro metodo per verificare se un numero è Humble:

(define (humble? num)
  (while (zero? (% num 2)) (setq num (/ num 2)))
  (while (zero? (% num 3)) (setq num (/ num 3)))
  (while (zero? (% num 5)) (setq num (/ num 5)))
  (while (zero? (% num 7)) (setq num (/ num 7)))
  (= num 1))

Vediamo la velocità:

(time (humble1-to 1e7))
;-> 4596.102

(time (print (humble-digits 1e7)))
;-> (0 9 36 95 197 356 579 882 1 0)
;-> 4614.613

(time (print (humble-digits (- 1e9 1))))
(0 9 36 95 197 356 579 882 1272 1768)
;-> 463139.021 Quasi 8 minuti.

Quindi fino a 1 miliardo (1e9) abbiamo:

    9 numeri Humble hanno 1 cifra
   36 numeri Humble hanno 2 cifre
   95 numeri Humble hanno 3 cifre
  197 numeri Humble hanno 4 cifre
  356 numeri Humble hanno 5 cifre
  579 numeri Humble hanno 6 cifre
  882 numeri Humble hanno 7 cifre
 1272 numeri Humble hanno 8 cifre
 1768 numeri Humble hanno 9 cifre

Vediamo un approccio migliore.
Invece di controllare ogni singolo numero possiamo costruire numeri partendo dal primo. I numeri che vogliamo sono fondamentalmente 2^w 3^x 5^y 7^z, per tutti i valori interi di w, x, y, z. L'iterazione non è immediata (come facciamo a sapere quale iterazione viene dopo?). Ma un modo diverso di ragionare è pensare che è ogni numero Humble è 2 volte o 3 volte o 5 volte o 7 volte il numero umile precedente. In questo modo l'iterazione è più semplice.

(define (humble-to num)
  (local (hn w x y z)
    (setq hn (array num '(0)))
    (setf (hn 1) 1)
    (setq w 1 x 1 y 1 z 1)
    (for (i 2 (- num 1))
      (setf (hn i) (min (* 2 (hn w)) (* 3 (hn x)) (* 5 (hn y)) (* 7 (hn z))))
      (if (= (hn i) (* 2 (hn w))) (++ w))
      (if (= (hn i) (* 3 (hn x))) (++ x))
      (if (= (hn i) (* 5 (hn y))) (++ y))
      (if (= (hn i) (* 7 (hn z))) (++ z))
    )
    hn))

(array-list (humble-to 47))
;-> (0 1 2 3 4 5 6 7 8 9 10 12 14 15 16 18 20 21 24 25 27 28 30 32 35 36 40 42 45 48
;->  49 50 54 56 60 63 64 70 72 75 80 81 84 90 96 98 100 105 108 112 120 125 126 128
;->  135 140 144 147 150 160 162 168 175 180 189 192 196 200 210 216 224 225 240 243
;->  245 250 252 256 270 280 288 294 300 315 320 324 336 343 350 360 375 378 384 392
;->  400 405 420 432 441 448)

Questa funzione "humble-to" calcola "num" numeri di Humble, mentre le funzioni "humble1-to" e "humble2-to" calcolano tutti i numeri di Humble minori o uguali a "num".

Verifichiamo che producono lo stesso risultato:

(= (array-list (humble-to 47)) (humble1-to 100))
;-> true

Adesso riscriviamo la funzione per risolvere la seconda questione:

(define (humble-digits num-digits)
  (local (hn i w x y z continua cifre)
    (setq hn (array 100000 '(0)))
    (setq cifre (array (+ num-digits 1) '(0)))
    (setq (cifre 1) 1)
    (setf (hn 1) 1)
    (setq w 1 x 1 y 1 z 1)
    (setq continua true)
    (setq i 2)
    (while continua
      (setf (hn i) (min (* 2 (hn w)) (* 3 (hn x)) (* 5 (hn y)) (* 7 (hn z))))
      (if (= (hn i) (* 2 (hn w))) (++ w))
      (if (= (hn i) (* 3 (hn x))) (++ x))
      (if (= (hn i) (* 5 (hn y))) (++ y))
      (if (= (hn i) (* 7 (hn z))) (++ z))
      ; aggiornamento vettore delle cifre
      (cond ((<= (length (hn i)) num-digits)
             (++ (cifre (length (hn i)))))
            (true (setq continua nil))
      )
      (++ i)
    )
    cifre))

Proviamo:

(humble-digits 16)
;-> (0 9 36 95 197 356 579 882 1272 1768 2380 3113 3984 5002 6187 7545 9081)

(time (humble-digits 16))
;-> 44.35

La soluzione è immediata.


------------------------
PERSISTENZA DI UN NUMERO
------------------------

La persistenza di un numero descrive il numero di operazioni che si devono applicare ad un intero per raggiungere un punto fisso, ad esempio fino a quando successive operazioni non cambieranno più il numero.
Generalmente, questo termine viene riferito alla persistenza additiva o moltiplicativa di un intero, che indica quante volte bisogna sostituire un numero con la somma o con la moltiplicazione delle sue cifre fino a quando si raggiunge un numero con una sola cifra. La cifra finale che si ottiene viene chiamata Multiplicative Digital Root o Additive Digital Root del numero intero iniziale.

Esempio: persistenza moltiplicativa

679 -> (6*7*9)=378 -> (3*7*8)=168 -> (1*6*8)=48 -> (4*2)=32 -> (3*2)=6.
679 -> 378 -> 168 -> 48 -> 32 -> 6.

Cioè, la persistenza di 679 è 6. La persistenza di un numero a una cifra è 0. Esistono numeri con persistenza di 11. Non è noto se ci siano numeri con la persistenza di 12 ma è noto (perchè è stato verificato con un computer nel 2019) che non esistono numeri con persistenza uguale a 12 che hanno meno di 20000 cifre.

Nota: la persistenza additiva o moltiplicativa dipende dalla base di numerazione in cui si sta operando.

Per la persistenza moltiplicativa:

Funzione cha calcola il prodotto delle cifre di un numero:

(define (digit-mul num)
  (let (out 1)
    (while (!= num 0)
      (setq out (* out (% num 10)))
      (setq num (/ num 10))
    )
    out))

(digit-mul 100)
;-> 0

Funzione che calcola la persistenza moltiplicativa:

(define (pers-mul n)
  (let (out 0)
    (while (> n 9)
      (setq n (digit-mul n))
      (++ out)
    )
    out))

(pers-mul 28)
;-> (2)

(map pers-mul (sequence 1 30))
;-> (0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 1)

I numeri più piccoli con persistenza moltiplicativa di 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,... sono 10, 25, 39, 77, 679, 6788, 68889, 2677889, 26888999, 3778888999, 277777788888899, ...

Verifichiamo:

(map pers-mul '(10 25 39 77 679 6788 68889 2677889 26888999 3778888999 277777788888899))
;-> (1 2 3 4 5 6 7 8 9 10 11)

Per la persistenza additiva:

Funzione cha calcola la somma delle cifre di un numero:

(define (digit-add num)
  (let (out 0)
    (while (!= num 0)
      (setq out (+ out (% num 10)))
      (setq num (/ num 10))
    )
    out))

Funzione che calcola la persistenza additiva:

(define (pers-add n)
  (let (out 0)
    (while (> n 9)
      (setq n (digit-add n))
      (++ out)
    )
    out))

(pers-add 28)
;-> 2

(map pers-add (sequence 0 30))
;-> (0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 2 2 1)

I numeri più piccoli con persistenza additiva di 1, 2, 3, 4, ... sono 10, 19, 199, 19999999999999999999999, ...

Verifichiamo:

(map pers-add '(10 19 199 19999999999999999999999))
;-> (1 2 3 4)


--------------
NUMERI TAXICAB
--------------

I numeri Taxicab sono numeri che sono la somma di due cubi in due o più modi, i primi dei quali sono 1729, 4104, 13832, 20683, 32832, 39312, 40033, 46683, 64232, ... (OEIS A001235).

Il nome di questi numeri prende origine da un aneddoto, secondo il quale il matematico inglese Godfrey Harold Hardy, recatosi in ospedale in visita al matematico indiano Srinivasa Ramanujan, fece una battuta circa il fatto che il numero del taxi che aveva preso (1729) appariva essere privo di particolare interesse matematico. Ma Ramanujan rispose immediatamente: "No Hardy, è un numero estremamente interessante: è il minimo intero che si può esprimere come somma di due cubi in due modi diversi!"

1729 = 1 ^ 3 + 12 ^ 3 = 9 ^ 3 + 10 ^ 3

Taxicab:
1729, 4104, 13832, 20683, 32832, 39312, 40033, 46683, 64232, 65728,
110656, 110808, 134379, 149389, 165464, 171288, 195841, 216027, 216125,
262656, 314496, 320264, 327763, 373464, 402597, 439101, 443889, 513000,
513856, 515375, 525824, 558441, 593047, 684019, 704977, ...

Funzione che calcola tutti i numeri taxicab fino ad un numero dato:

(define (taxicab-to num)
  (local (i c out)
  (setq out '())
    (setq i 1)
    (while (< i num)
      (setq c 0)
      ; Verifica per tutte le coppie (j k) se risulta:
      ; i = j^3 + k^3
      (for (j 1 (int (pow i (div 1 3))))
        (for (k (+ j 1) (int (pow i (div 1 3))))
          (if (= (+ (* j j j) (* k k k)) i)
            (++ c)
          )
         )
      )
      (if (>= c 2) (push i out -1))
      (++ i)
    )
    out))

(taxicab-to 100000)
;-> (1729 4104 13832 20683 32832 39312 40033 46683 64232 65728)

Funzione che calcola i primi "quanti" numeri taxicab:

(define (taxicab-count quanti)
  (local (i conta c out)
  (setq out '())
    (setq i 1 conta 0)
    (while (< conta quanti)
      (setq c 0)
      (for (j 1 (int (pow i (div 1 3))))
        (for (k (+ j 1) (int (pow i (div 1 3))))
          (if (= (+ (* j j j) (* k k k)) i)
            (++ c)
          )
         )
      )
      (if (>= c 2)
          (begin (push i out -1) (++ conta))
      )
      (++ i)
    )
    out))

(taxicab-count 6)
;-> (1729 4104 13832 20683 32832 39312)

Entrambe le funzioni hanno una complessità temporale O(n^3) e non permettono di calcolare numeri taxicab troppo grandi.
Vediamo quanto tempo impiega per calcolare tutti i numeri taxicab fino ad un milione:

(time (println (taxicab-to 1e6)))
;-> (1729 4104 13832 20683 32832 39312 40033 46683 64232 65728 110656 110808 134379 149389
;->  165464 171288 195841 216027 216125 262656 314496 320264 327763 373464 402597 439101
;->  443889 513000 513856 515375 525824 558441 593047 684019 704977 805688 842751 885248
;->  886464 920673 955016 984067 994688)
;-> 321249.471 ; 5 minuti e 21 secondi


-----------
CODICE GRAY
-----------

Dato un numero N, generare stringhe di bit da 0 a 2^N-1 in modo tale che le stringhe successive differiscano di un bit.

La soluzione a questo problema è il codice Gray.

Per esempio:

Input: N = 2
Output: 00 01 11 10

Input: N = 3
Output: 000 001 011 010 110 111 101 100

Algoritmo

I codici Gray a n bit possono essere generati dall'elenco dei codici Gray a (n-1) bit utilizzando i seguenti passaggi.

  Poniamo che la lista dei codici Gray a (N-1) bit sia L1.
  Creare un'altra lista L2 che è il contrario di L1.
  Modificare la lista L1 anteponendo "0" in tutti i codici di L1.
  Modificare la lista L2 anteponendo "1" in tutti i codici di L2.
  Concatenare L1 e L2.
  L'elenco concatenato è la lista dei codici Gray a N bit.

Ad esempio, vediamo i passaggi per generare l'elenco dei codici Gray a 3 bit dall'elenco dei codici Gray a 2 bit:

  L1 = (00 01 11 10) (elenco di codici gray a 2 bit)
  L2 = (10 11 01 00) (inverso di L1)
  Anteporre "0" a tutti codici di L1, L1 diventa (000 001 011 010)
  Anteporre "1" a tutti codici di L2, L2 diventa (110 111 101 100)
  Concatenare L1 e L2: otteniamo (000 001 011 010 110 111 101 100)

Per generare il codice Gray a N bit, partiamo dalla lista dei codici Gray a 1 bit (0 1) e costruiamo tutte le liste successive fino a N.

(define (gray num)
  (local (lst1 lst2)
    (cond ((< num 1) '())
          ((= num 1) '("0" "1"))
          (true
          (setq lst1 '("0" "1"))
          (for (i 2 num)
            (setq lst2 (map reverse lst1))
            (setq lst1 (map (fn(x) (string "0" x)) lst1))
            (setq lst2 (map (fn(x) (string "1" x)) lst2))
            (setq lst1(extend lst1 lst2))
          )))))

(gray 3)
;-> ("000" "001" "010" "011" "100" "110" "101" "111")

Il numero di elementi della sequenza Gray(n) vale 2^n e cresce rapidamente con N:

(for (i 1 20) (print (length (gray i)) { }))
;-> 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192
;-> 16384 32768 65536 131072 262144 524288 1048576

(for (i 1 20) (print (pow 2 i) { }))
;-> 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192
;-> 16384 32768 65536 131072 262144 524288 1048576

Il codice Gray viene chiamato anche "reflected binary code" (RBC) oppure "reflected binary" (RB). I primi sedici numeri sono codificati nella tabella seguente:

   Decimale  Binario  Gray  Decimale Gray
       0      0000    0000      0
       1      0001    0001      1
       2      0010    0011      3
       3      0011    0010      2
       4      0100    0110      6
       5      0101    0111      7
       6      0110    0101      5
       7      0111    0100      4
       8      1000    1100     12
       9      1001    1101     13
      10      1010    1111     15
      11      1011    1110     14
      12      1100    1010     10
      13      1101    1011     11
      14      1110    1001      9
      15      1111    1000      8

Per convertire un numero decimale in decimale Gray (OEIS A003188) possiamo usare la seguente funzione:

(define (graycode1 num) (^ num (>> num 1)))

(graycode1 7)
;-> 4
(graycode1 10)
;-> 15

Oppure in maniera equivalente:

(define (graycode2 num) (^ num (floor (/ num 2))))

(graycode2 7)
;-> 4
(graycode2 10)
;-> 15

(= (map graycode1 (sequence 1 10000)) (map graycode2 (sequence 1 10000)))
;-> true


------------
GAME OF LIFE
------------

Il Gioco della Vita (The Game of Life), noto anche semplicemente come Life, è un automa cellulare ideato dal matematico britannico John Horton Conway nel 1970. È un gioco la cui evoluzione è determinata dal suo stato iniziale e non richiede ulteriori input. Si interagisce con il gioco della vita creando una configurazione iniziale e osservando come si evolve passo dopo passo. Il gioco è Turing completo e può simulare qualsiasi macchina di Turing.

Regole del gioco
----------------
L'universo del Gioco della Vita è una griglia ortogonale bidimensionale infinita di celle quadrate, ognuna delle quali si trova in uno dei due possibili stati, vivo o morto (o popolato e non popolato, rispettivamente). Ogni cella interagisce con i suoi otto vicini, che sono le celle adiacenti orizzontalmente, verticalmente o diagonalmente. Ad ogni passaggio nel tempo, si verificano le seguenti transizioni:

  - Qualsiasi cellula viva con meno di due vicini vivi muore, come per sottopopolazione.
  - Qualsiasi cellula viva con due o tre vicini vivi sopravvive alla generazione successiva.
  - Qualsiasi cellula viva con più di tre vicini vivi muore, come per sovrappopolazione.
  - Qualsiasi cellula morta con esattamente tre vicini vivi diventa una cellula viva, come per riproduzione.

Queste regole, che confrontano il comportamento dell'automa con la vita reale, possono essere condensate come segue:

  - Qualsiasi cellula viva con due o tre vicini vivi sopravvive.
  - Qualsiasi cellula morta con tre vicini vivi diventa una cellula viva.
  - Tutte le altre cellule vive muoiono nella generazione successiva. Allo stesso modo, tutte le altre cellule morte rimangono morte.

Il modello iniziale costituisce il seme del sistema. La prima generazione viene creata applicando le regole di cui sopra simultaneamente a ogni cellula del seme: nascite e morti avvengono simultaneamente e il momento discreto in cui ciò accade è talvolta chiamato passo (tick o step). Ogni generazione è una funzione pura della precedente. Le regole continuano ad essere applicate ripetutamente per creare nuove generazioni.

Implementazione
---------------
Il nostro universo è finito e viene rappresentato con una matrice quadrata NxN.

La stato "vivo" vale 1.
Lo stato "morto" vale 0.

In questo modo possiamo sommare i valori dei vicini per applicare le regole:

Per le celle vive (1):
- (somma < 2) o (somma > 3) ==> la cella muore
- (somma = 2) o (somma = 3) ==> la cella continua a vivere

Per le celle morte (0):
- (somma == 3) ==> la cella nasce (vive)

Invece di iterare su una matrice usiamo un vettore, per esempio la seguente matrice 4x4:

0 1 0 1
0 1 0 0
0 0 0 0
1 1 0 1

viene rappresentata con il vettore di 16 elementi:

0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 1

dove gli indici della matrice sono determinati da:

riga    = i % 4
colonna = i / 4

Questo ci permette di calcolare più facilmente i vicini di una cella. Per esempio, nel nostro caso N = 4 e i vicini della cella i-esima sono i seguenti:

sinistra: (i - 1)
destra:   (i + 1)
sopra:    (i - N) = (i - 4)
sotto:    (i + N) = (i + 4)
alto-sx:  (i - (N + 1)) = (i - 5)
alto-dx:  (i - (N - 1)) = (i - 3)
basso-sx: (i + (N - 1)) = (i + 3)
basso-dx: (i + (N + 1)) = (i + 5)

Per evitare il controllo degli indici quando visitiamo/sommiamo le celle vicine contorniamo la matrice con valori 0 che la delimitano (in questo modo la somma non viene modificata dai valori di contorno che valgono 0).

Supponiamo di avere una matrice 10x10 di celle. Poichè la matrice viene contornata la matrice finale ha dimensioni 12x12.

Definiamo il vettore:

(setq dim 12)
(setq board (array (* dim dim) '(0)))

Scriviamo una funzione che stampa il gioco:

(define (print-board board size)
  (for (i 0 (- (length board) 1))
    (cond ((= i 0) (print"╔"))
          ((< i (- size 1)) (print "══"))
          ((= i (- size 1)) (print"╗"))
          ((= i (* size (- size 1))) (print "╚"))
          ((= i (- (length board) 1)) (print"╝"))
          ((or (zero? (% i size)) (zero? (% (+ i 1) size))) (print "║"))
          ((and (> i (* size (- size 1))) (< i (- (* size size) 1))) (print "══"))
          ((zero? (board i)) (print "  "))
          ((= 1 (board i)) (print "██"))
    )
    (if (zero? (% (+ i 1) size))
        (println))
  ))

(print-board board dim)

Scriviamo una funzione che data una generazione calcola la successiva:

(define (next board size)
  (local (temp-board somma)
    ; crea matrice temporanea
    (setq temp-board board)
    ; per ogni cella della matrice di life
    (for (i (+ size 1) (- (length board) (+ size 2)))
      ; se l'indice è fuori dalla matrice (nel contorno)
      (if (or (zero? (% i size)) (zero? (% (+ i 1) size)))
          nil
          (begin
            ; calcolo del numero dei vicini della cella
            (setq somma (+ (board (- i 1))
                           (board (+ i 1))
                           (board (- i size))
                           (board (+ i size))
                           (board (- i (+ size 1)))
                           (board (- i (- size 1)))
                           (board (+ i (+ size 1)))
                           (board (+ i (- size 1)))))
                  ; (> 3) la cella muore
            (cond ((> somma 3) (setf (temp-board i) 0))
                  ; (= 3) la cella vive o nasce
                  ((= somma 3) (setf (temp-board i) 1))
                  ; (= 2 e viva) la cella vive
                  ((and (= somma 2) (= (temp-board i) 1)) (setf (temp-board i) 1))
                  ; altrimenti la cella muore
                  (true (setf (temp-board i) 0))
            )
          )
       )
    )
  temp-board))

Adesso definiamo un "glider" nella matrice iniziale. Un "glider" è una configurazione che si muove indefinitamente nella matrice (a meno che non incroci altre celle vive).

(setf (board 15) 1)
(setf (board 27) 1)
(setf (board 39) 1)
(setf (board 38) 1)
(setf (board 25) 1)

Stampiamo la matrice:

(print-board board dim)
 ╔════════════════════╗
 ║    ██              ║
 ║██  ██              ║
 ║  ████              ║
 ║                    ║
 ║                    ║
 ║                    ║
 ║                    ║
 ║                    ║
 ║                    ║
 ║                    ║
 ╚════════════════════╝

Adesso calcoliamo le generazioni successive con un ciclo:

(while true
  (setq board (next board dim))
  (print-board board dim)
  (print "Premi Invio per la prossima generazione:")
  (read-line))

╔════════════════════╗ ╔════════════════════╗ ╔════════════════════╗
║  ██                ║ ║    ██              ║ ║                    ║
║    ████            ║ ║      ██            ║ ║  ██  ██            ║
║  ████              ║ ║  ██████            ║ ║    ████            ║
║                    ║ ║                    ║ ║    ██              ║
║                    ║ ║                    ║ ║                    ║
║                    ║ ║                    ║ ║                    ║
║                    ║ ║                    ║ ║                    ║
║                    ║ ║                    ║ ║                    ║
║                    ║ ║                    ║ ║                    ║
║                    ║ ║                    ║ ║                    ║
╚════════════════════╝ ╚════════════════════╝ ╚════════════════════╝
╔════════════════════╗ ╔════════════════════╗
║    ██              ║ ║                    ║
║      ██            ║ ║      ██            ║
║  ██████            ║ ║  ██  ██            ║
║                    ║ ║    ████            ║
║                    ║ ║                    ║
║                    ║ ║                    ║
║                    ║ ║                    ║
║                    ║ ║                    ║
║                    ║ ║                    ║
║                    ║ ║                    ║
╚════════════════════╝ ╚════════════════════╝

L'ultima generazione è uguale alla prima tranne il fatto che il "glider" si è spostato in basso a sinistra della matrice.

Esistono tante configurazioni particolari nel gioco della vita.

Adesso scriviamo una funzione che prende una matrice in ingresso (configurazione iniziale) e calcola le generazioni successive.

La matrice ha la seguente struttura:

(setq gen0 '((0 1 0 0 1 0 0)
             (1 1 1 0 1 0 1)
             (1 0 1 0 1 1 0)
             (0 1 0 0 0 0 1)
             (1 1 1 1 1 0 1)
             (0 1 0 1 0 1 1)
             (1 1 0 1 0 1 1)))

Prima dobbiamo scrivere una funzione che contorna la matrice di 0:

(define (pad matrix)
  (local (row col out)
    (setq out '())
    (if (array? matrix) (setq matrix (array-list matrix)))
    (setq row (+ 2 (length matrix)))
    (setq col (+ 2 (length (matrix 0))))
    ; aggiunge una riga iniziale ad out
    (push (dup 0 col true) out -1)
    ; aggiunge le righe centrali ad out
    (dolist (el matrix)
      (setq cur (append '(0) el '(0)))
      (push cur out -1)
    )
    ; aggiunge una riga finale ad out
    (push (dup 0 col true) out -1)
    (array (* col row) (flat out))))

(setq matrice '((0 0 1 0 0)
                (1 0 1 0 1)
                (0 0 1 1 1)
                (0 0 0 0 1)
                (0 1 1 1 1)))

(print-board (pad matrice) 7)
╔══════════╗
║    ██    ║
║██  ██  ██║
║    ██████║
║        ██║
║  ████████║
╚══════════╝

Adesso scriviamo la funzione finale:

(define (life start)
  (local (board dim)
    (setq board (pad start))
    (setq dim (sqrt (length board)))
    (while true
      (setq board (next board dim))
      (print-board board dim)
      (println "Premi Invio per la prossima generazione")
      (println "       Premi Ctrl-C per uscire")
      (read-line))))

Generiamo una generazione iniziale casuale con una matrice 32x32:

(setq gen0 (explode (rand 2 1024) 32))

Facciamo partire la simulazione:

(life gen0)
╔════════════════════════════════════════════════════════════════╗
║  ██████      ██████  ██████████    ██████    ████  ██        ██║
║██          ██        ██          ██                            ║
║██                    ██              ██                        ║
║██  ██      ██                                    ██          ██║
║██        ████████                ██  ██      ████        ██████║
║  ████    ██                      ██  ██  ██                ████║
║██        ████                    ████        ████          ██  ║
║██      ████                    ██                            ██║
║██          ██            ██                                  ██║
║      ████                ██                                    ║
║████                    ████    ██                ██  ██    ██  ║
║      ██                    ██                    ██  ████      ║
║      ██  ██  ██  ████████████  ████      ████    ██  ██  ██  ██║
║██        ██  ████                    ██████      ██  ██  ██  ██║
║██              ██████    ██                      ██  ██      ██║
║  ████    ██    ████                ██  ██            ████████  ║
║      ██  ██                ██  ██    ████  ██        ████    ██║
║  ████      ██    ██        ██                            ██  ██║
║██          ██        ██        ██    ████            ████      ║
║██                              ██                          ████║
║██                                                      ██  ██  ║
║██      ██                          ██          ██      ██  ██  ║
║██    ████  ██        ██            ██  ██          ██    ██    ║
║          ██                            ██  ██  ██        ██    ║
║████        ████      ██          ████  ██  ██  ██  ██        ██║
║██            ██                            ████                ║
║██        ██    ████      ██      ████        ██                ║
║        ████████      ████  ██        ██                        ║
║  ████  ████████        ████  ██                ██          ████║
║      ████    ██████████████                          ██        ║
║      ██        ██        ██                                    ║
║                    ██████    ██  ████      ████  ██  ██  ██    ║
╚════════════════════════════════════════════════════════════════╝
Premi Invio per la prossima generazione
       Premi Ctrl-C per uscire

---------------------

Adesso vediamo un altro metodo per simulare il gioco della vita. Questa volta utilizziamo una matrice n x m anche nel programma (e non un vettore come prima). Comunque i bordi della matrice (prima e ultima riga con prima e ultima colonna) hanno tutti valore 0 perchè rappresentano il limite/contorno della matrice (come nel caso precedente).

Funzione che stampa la matrice:

(define (print-griglia griglia m n)
  (for (i 0 (- m 1))
    (for (j 0 (- n 1))
      (if (zero? (griglia i j))
          (print "·")
          (print "×")
      )
    )
    (println "")
  ))

Funzione che calcola la generazione successiva:

(define (next-gen griglia m n)
  (local (vivi gen)
    (setq gen (array m n '(0)))
    ; per ogni cella della matrice
    (for (r 1 (- m 2))
      (for (c 1 (- n 2))
        (setq vivi 0)
        ; calcola i vicini che sono vivi
        (for (i -1 1)
          (for (j -1 1)
            (setq vivi (+ vivi (griglia (+ r i) (+ c j))))
          )
        )
        ; sottrae il valore della cella corrente
        ; (che non deve rientrare nei vicini)
        (setq vivi (- vivi (griglia r c)))
        ; Applica le regole del gioco della vita:
              ; solitudine: la cella muore
        (cond ((and (= (griglia r c) 1) (< vivi 2))
              (setf (gen r c) 0))
              ; sovrappopolazione: cella muore
              ((and (= (griglia r c) 1) (> vivi 3))
              (setf (gen r c) 0))
              ; nascita: cella nasce/vive
              ((and (= (griglia r c) 0) (= vivi 3))
              (setf (gen r c) 1))
              ; nessun cambiamento: la cella rimane nel suo stato
              (true (setf (gen r c) (griglia r c)))
        )))
     gen))

Funzione finale:

(define (vita griglia m n)
  (local (tempgrid)
    (setq tempgrid griglia)
    (print-griglia tempgrid m n)
    (println "Generazione iniziale")
    (println "Premere Invio per la prossima generazione")
    (println "oppure Ctrl-C per uscire")
    (while true
      (setq tempgrid (next-gen tempgrid m n))
      (print-griglia tempgrid m n)
      (println "Premere Invio per la prossima generazione")
      (println "oppure Ctrl-C per uscire")
      (read-line))))

Proviamo con una matrice 10 x 14:

(setq board '((0 0 0 0 0 0 0 0 0 0 0 0 0 0)
              (0 0 0 1 0 0 0 0 0 0 1 0 0 0)
              (0 1 0 1 0 0 0 0 0 0 1 0 0 0)
              (0 0 1 1 0 0 0 0 0 0 1 0 0 0)
              (0 0 0 0 0 0 0 0 0 0 0 0 0 0)
              (0 0 0 0 0 0 0 0 0 0 0 0 0 0)
              (0 0 0 0 0 0 0 0 0 0 0 0 0 0)
              (0 1 1 0 0 0 0 0 0 0 0 0 0 0)
              (0 1 1 0 0 0 0 0 0 0 0 0 0 0)
              (0 0 0 0 0 0 0 0 0 0 0 0 0 0)))

Lanciamo la simulazione:

(vita board 10 14)

··············  ··············  ··············  ··············
···x······x···  ··x···········  ···x······x···  ··············
·x·x······x···  ···xx····xxx··  ····x·····x···  ··x·x····xxx··
··xx······x···  ··xx··········  ··xxx·····x···  ···xx·········
··············  ··············  ··············  ···x··········
··············  ··············  ··············  ··············
··············  ··············  ··············  ··············
·xx···········  ·xx···········  ·xx···········  ·xx···········
·xx···········  ·xx···········  ·xx···········  ·xx···········
··············  ··············  ··············  ··············
Generazione 0   Generazione 1   Generazione 2   Generazione 3

··············
··········x···
····x·····x···
··x·x·····x···
···xx·········
··············
··············
·xx···········
·xx···········
··············
Generazione 4

Nota: il miglior programma (open-source e multi-piattaforma) per "giocare" con Life e altri automi cellulari è "golly" (http://golly.sourceforge.net/).


---------
ACKERMANN
---------

Nella teoria della computabilità la funzione di Ackermann (da Wilhelm Ackermann) è uno degli esempi più semplici e scoperti per primi di una funzione totalmente calcolabile che non è ricorsiva in modo primitivo. Tutte le funzioni ricorsive primitive sono totali e calcolabili, ma la funzione di Ackermann illustra che non tutte le funzioni computabili totali sono ricorsive primitive.
Una versione comune, la funzione Ackermann – Péter a due argomenti, è definita per gli interi non negativi m e n nel modo seguente:

A(0, n) = n + 1
A(m, 0) = A(m-1, 1)
A(m, n) = A(m-1, A(m n-1))

Il suo valore cresce rapidamente, anche per valori piccoli di input.

Versione ricorsiva:

(define (ackermann m n)
  (cond ((zero? m) (+ n 1))
        ((zero? n) (ackermann (- m 1) 1))
        (true (ackermann (- m 1) (ackermann m (- n 1))))))

(for (m 0 3)
  (for (n 0 3)
    (println (format "Ack(%d,%d): %d" m n (ackermann m n)))))
;-> Ack(0,0): 1
;-> Ack(0,1): 2
;-> Ack(0,2): 3
;-> Ack(0,3): 4
;-> Ack(1,0): 2
;-> Ack(1,1): 3
;-> Ack(1,2): 4
;-> Ack(1,3): 5
;-> Ack(2,0): 3
;-> Ack(2,1): 5
;-> Ack(2,2): 7
;-> Ack(2,3): 9
;-> Ack(3,0): 5
;-> Ack(3,1): 13
;-> Ack(3,2): 29
;-> Ack(3,3): 61

Versione migliorata:

(define (pow-i num power)
  (local (pot out)
    (if (zero? power)
        (setq out 1L)
        (begin
          (setq pot (pow-i num (/ power 2)))
          (if (odd? power)
              (setq out (* num pot pot))
              (setq out (* pot pot)))))
    out))

(define (ack m n)
  (case m
    (0 (+ n 1))
    (1 (+ n 2))
    (2 (+ n n 3))
    (3 (- (pow-i 2L (+ 3L n)) 3))
    (true (ack (- m 1) (if (zero? n) 1 (ack m (- n 1)))))))

(for (m 0 3)
  (for (n 0 3)
    (println (format "Ack(%d,%d): %d" m n (ack m n)))))
;-> Ack(0,0): 1
;-> Ack(0,1): 2
;-> Ack(0,2): 3
;-> Ack(0,3): 4
;-> Ack(1,0): 2
;-> Ack(1,1): 3
;-> Ack(1,2): 4
;-> Ack(1,3): 5
;-> Ack(2,0): 3
;-> Ack(2,1): 5
;-> Ack(2,2): 7
;-> Ack(2,3): 9
;-> Ack(3,0): 5
;-> Ack(3,1): 13
;-> Ack(3,2): 29
;-> Ack(3,3): 61

Possiamo anche calcolare:

(ack 4L 1L)
;-> 65533

Il seguente output ha 20221 cifre:

(ack 4L 2L)
;-> 200352993040684646497907235156025575044782547556...
;-> ...337539755822087777506072339445587895905719156733L

Non provate a calcolare:

(ack 4L 3L)

ci vuole troppo tempo.

Il fatto che la funzione di Ackermann sia ricorsiva in modo non primitivo, comporta l'impossibilità di calcolarla utilizzando solo dei cicli (loop). Comunque può essere calcolata anche in modo iterativo, simulando la ricorsione con una pila (stack), inserendo (push) ed estraendo (pop) i valori di input e di output per ogni chiamata di funzione (che è quello che fa il linguaggio nel runtime):

(define (ack2 m n)
  (local (stack lst out q)
    (setq stack (list (list m n 0)))
    (setq out -1)
    (while (> (length stack) 0)
      (setq lst (pop stack))
      (setq m (lst 0))
      (setq n (lst 1))
      (setq q (lst 2))
      (cond ((zero? q)
             (cond ((zero? m) (setq out (+ n 1)))
                   ((zero? n) (push (list (- m 1) 1 0) stack))
                   (true (push (list m n 1) stack)
                         (push (list m (- n 1) 0) stack)))
            )
            ((= q 1) (push (list (- m 1) out 0) stack))
            (true (println "nil"))
      )
    )
    out))

(for (m 0 3)
  (for (n 0 3)
    (println (format "Ack(%d,%d): %d" m n (ack2 m n)))))
;-> Ack(0,0): 1
;-> Ack(0,1): 2
;-> Ack(0,2): 3
;-> Ack(0,3): 4
;-> Ack(1,0): 2
;-> Ack(1,1): 3
;-> Ack(1,2): 4
;-> Ack(1,3): 5
;-> Ack(2,0): 3
;-> Ack(2,1): 5
;-> Ack(2,2): 7
;-> Ack(2,3): 9
;-> Ack(3,0): 5
;-> Ack(3,1): 13
;-> Ack(3,2): 29
;-> Ack(3,3): 61

Nota: (ack2 4 1) non è calcolabile.

La prossima funzione differisce da quella precedente in quanto inserisce nello stack solo il valore di m e non una tripla di valori:

(define (ack3 m n)
  (local (stack lst out q)
    (setq stack (list m))
    (while (> (length stack) 0)
      (setq m (pop stack))
      (cond ((zero? m) (setq n (+ n m 1)))
            ((zero? n)
             (setq n (+ n 1))
             (setq m (- m 1))
             (push m stack))
            (true
             (setq m (- m 1))
             (push m stack)
             (setq m (+ m 1))
             (push m stack)
             (setq n (- n 1)))
      )
    )
    n))

(for (m 0 3)
  (for (n 0 3)
    (println (format "Ack(%d,%d): %d" m n (ack3 m n)))))
;-> Ack(0,0): 1
;-> Ack(0,1): 2
;-> Ack(0,2): 3
;-> Ack(0,3): 4
;-> Ack(1,0): 2
;-> Ack(1,1): 3
;-> Ack(1,2): 4
;-> Ack(1,3): 5
;-> Ack(2,0): 3
;-> Ack(2,1): 5
;-> Ack(2,2): 7
;-> Ack(2,3): 9
;-> Ack(3,0): 5
;-> Ack(3,1): 13
;-> Ack(3,2): 29
;-> Ack(3,3): 61

Nota: (ack3 4 1) non è calcolabile.

Le ultime due funzioni "ack2" e "ack3" sono molto lente perchè la simulazione della ricorsione viene fatta con una coda/lista.


------------------------
SEQUENZA Q DI HOFSTADTER
------------------------

La sequenza di Hofstadter Q è definita come:

Q(1) = Q(2) = 1
Q(n) = Q(n-Q(n-1)) + Q(n-Q(n-2)) per n > 2.

È simile alla sequenza di Fibonacci, ma mentre il termine successivo nella sequenza di Fibonacci è la somma dei due termini precedenti, nella sequenza Q i due termini precedenti dicono di quanto tornare indietro nella sequenza Q per trovare i due numeri da sommare per calcolare il termine successivo della sequenza.

Nella OEIS questa sequenza è la A005185:

(setq A005185 '(1 1 2 3 3 4 5 5 6 6 6 8 8 8 10 9 10 11 11
                12 12 12 12 16 14 14 16 16 16 16 20 17 17 20
                21 19 20 22 21 22 23 23 24 24 24 24 24 32 24
                25 30 28 26 30 30 28 32 30 32 32 32 32 40 33
                31 38 35 33 39 40 37 38 40 39))

Definiamo direttamente la funzione utilizzando la ricorsione:

(define (qh num)
  (cond ((= num 1) 1)
        ((= num 2) 1)
        (true (+ (qh (- num (qh (- num 1)))) (qh (- num (qh (- num 2))))))))

(map qh (sequence 1 10))
;-> (1 1 2 3 3 4 5 5 6 6)

(qh 30)
;-> 16
(qh 34)
;-> 20
(qh 40)
;-> 22

La funzione è molto lenta:

(time (qh 34))
;-> 7950.982
(time (qh 40))
;-> 142933.365

Possiamo provare ad utilizzare la tecnica memoization:

(define-macro (memoize mem-func func)
  (set (sym mem-func mem-func)
    (letex (f func c mem-func)
      (lambda ()
        (or (context c (string (args)))
        (context c (string (args)) (apply f (args))))))))

(memoize qh-m
  (lambda (num)
  (cond ((= num 1) 1)
        ((= num 2) 1)
        (true (+ (qh-m (- num (qh-m (- num 1)))) (qh-m (- num (qh-m (- num 2)))))))))

(map qh-m (sequence 1 10))
;-> (1 1 2 3 3 4 5 5 6 6)

(qh-m 30)
;-> 16
(qh-m 34)
;-> 20
(qh-m 40)
;-> 22
(qh-m 100)
;-> 56

In questo caso la funzione è molto più veloce:

(time (qh-m 40))
;-> 0

ma abbiamo il problema con i numeri più grandi perchè la ricorsione è molto profonda e provoca l'errore di stack overflow:

(qh-m 1000)
;-> ERR: call or result stack overflow : cond

Allora utilizziamo un vettore per memorizzare tutti i valori della sequenza mentre li calcoliamo. In questo modo calcoliamo tutti i valori q(i) con i = 1,..,n:

(define (hof num)
  (let (qq (array (+ num 1) '(0)))
    (setf (qq 1) 1)
    (setf (qq 2) 1)
    (for (i 3 num)
      (setf (qq i) (+ (qq (- i (qq (- i 1)))) (qq (- i (qq (- i 2))))))
    )
    qq))

(hof 10)
;-> (0 1 1 2 3 3 4 5 5 6 6)

(last (hof 1000))
;-> 502

(length (hof 1000))
;-> 1001

Confrontiamo il risultato con la sequenza OEIS:

(length A005185)
;-> 74

(= A005185 (slice (array-list (hof 74)) 1 74))
;-> true

Vediamo quanto è veloce quest'ultima funzione:

(time (println (last (hof 1e6))))
;-> 5124632
;-> 248.364

Vediamo quanto tempo occorre per calcolare la sequenza dei primi 100 milioni di numeri:

(time (println (last (hof 100000000))))
;-> 50166508
;-> 33357.835
    34 secondi

La funzione è molto veloce, ma il vettore che definiamo utilizza tanta memoria.


------------------------------------
SEQUENZA FIGURA-FIGURA DI HOFSTADTER
------------------------------------

La sequenza Figura-Figura (R e S) di Hofstadter sono una coppia di sequenze intere complementari definite come segue:

R(1) = 1
S(1) = 2
R(n) = R(n-1) + S(n-1), per n>1

con la sequenza S(n) definita come una serie strettamente crescente di interi positivi non presenti in R(n). I primi termini di queste sequenze sono:

R: 1, 3, 7, 12, 18, 26, 35, 45, 56, 69, 83, 98, 114, 131, 150, 170, 191, 213, 236, 260, ... (A005228 OEIS)
S: 2, 4, 5, 6, 8, 9, 10, 11, 13, 14, 15, 16, 17, 19, 20, 21, 22, 23, 24, 25, ... (A030124 OEIS)

(define (ffh num)
  (local (r s)
    (setq r '(0 1))
    (setq s '(0 2))
    (for (i 2 num)
      ;(println i)
      (ffr i)
      (ffs i)
    )
    (list r s)))

(define (ffr n)
  (push (+ (r (- n 1)) (s (- n 1))) r -1))

(define (ffs n)
  (local (idx stop)
    (setq stop nil)
    (setq idx (+ (s (- n 1)) 1))
    (do-until stop
      (cond ((ref idx r)
             (++ idx))
            (true
             (push idx s -1)
             (setq stop true))
      ))))

(ffh 20)
;-> ((0 1 3 7 12 18 26 35 45 56 69 83 98 114 131 150 170 191 213 236 260)
;->  (0 2 4 5 6 8 9 10 11 13 14 15 16 17 19 20 21 22 23 24 25))

Vediamo i tempi di esecuzione:

(time (ffh 10000))
;-> 1481.927
(time (ffh 100000))
;-> 211800.307

Proviamo ad utilizzare una hash-map per inserire e controllare i valori di r (invece di controllarli sulla lista dei valori di r):

(define (ffh num)
  (local (r s)
    (new Tree 'rhash)
    (setq r '(0 1))
    (setq s '(0 2))
    (rhash "1" 1)
    (for (i 2 num)
      ;(println i)
      (ffr i)
      (ffs i)
    )
    (delete 'rhash)
    (list r s)))

(define (ffr n)
  (local (val)
    (setq val (+ (r (- n 1)) (s (- n 1))))
    (push val r -1)
    (rhash (string val) val)))

(define (ffs n)
  (local (idx stop)
    (setq stop nil)
    (setq idx (+ (s (- n 1)) 1))
    (do-until stop
      (cond ((nil? (rhash idx))
             (push idx s -1)
             (setq stop true))
            (true
             (++ idx))
      ))))

(ffh 20)
;-> ((0 1 3 7 12 18 26 35 45 56 69 83 98 114 131 150 170 191 213 236 260)
;->  (0 2 4 5 6 8 9 10 11 13 14 15 16 17 19 20 21 22 23 24 25))

(time (ffh 10000))
;-> 1211.927
(time (ffh 100000))
;-> 199469.585

Abbiamo ottenuto solo un piccolo miglioramento di velocità.


------------------------
SEQUENZA G DI HOFSTADTER
------------------------

La sequenza G di Hofstadter è definita come segue:

G(0) = 0
G(n) = n - G(G(n-1)), per n>0

I primi termini di questa sequenza sono:

0, 1, 1, 2, 3, 3, 4, 4, 5, 6, 6, 7, 8, 8, 9, 9, 10, 11, 11, 12, 12, ... (A005206 OEIS)

Per calcolare i valori utilizziamo un vettore che viene riempito sequenzialmente (non usiamo la ricorsione perchè è più lenta:

(define (gh num)
  (let (g (array (+ num 1) '(0)))
    (setf (g 0) 0)
    (setf (g 1) 1)
    (for (i 2 num)
      (setq (g i) (- i (g (g (- i 1)))))
    )
    g))

(gh 20)
;-> (0 1 1 2 3 3 4 4 5 6 6 7 8 8 9 9 10 11 11 12 12)

Vediamo quanto tempo occorre per calcolare i primi 100 milioni di termini:

(time (println (last (gh 100000000))))
;-> 61803399
;-> 12495.63
    12.5 secondi

Nota: per una rappresentazione visiva di questa sequenza vedi "A combinatorial interpretation of hofstadter’s G-sequence" di Mustazee Rahman.

----------------------------------------------
SEQUENZA FEMMINA (F) MASCHIO (M) DI HOFSTADTER
----------------------------------------------

Le sequenze Hofstadter Female (F) e Male (M) sono definite come segue:

F(0) = 1
M(0) = 0
F(n) = n - M(F(n-1)), per n>0
M(n) = n - F(M(n-1)), per n>0

I primi termini di questa sequenze sono:

F: 1, 1, 2, 2, 3, 3, 4, 5, 5, 6, 6, 7, 8, 8, 9, 9, 10, 11, 11, 12, 13, ... (A005378 OEIS)
M: 0, 0, 1, 2, 2, 3, 4, 4, 5, 6, 6, 7, 7, 8, 9, 9, 10, 11, 11, 12, 12, ... (A005379 OEIS)

(define (fmh num)
  (local (f m)
    (setq f (array (+ num 1) '(0)))
    (setq m (array (+ num 1) '(0)))
    (setf (f 0) 1)
    (setf (m 0) 0)
    (for (i 1 num)
      (setq (f i) (- i (m (f (- i 1)))))
      (setq (m i) (- i (f (m (- i 1)))))
    )
    (list f m)))

(fmh 20)
;-> ((1 1 2 2 3 3 4 5 5 6 6 7 8 8 9 9 10 11 11 12 13)
;->  (0 0 1 2 2 3 4 4 5 6 6 7 7 8 9 9 10 11 11 12 12))

Vediamo quanto tempo occorre per calcolare i primi 100 milioni di termini:

(time (fmh 100000000))
;-> 26554.548
    26.5 secondi


-----------
CONVEX HULL
-----------

Dato un insieme di N punti, il convex-hull è definito come il poligono convesso più piccolo che racchiude tutti i punti dell'insieme. Questo poligono è anche il poligono con il più piccolo perimetro contenente tutti i punti.

      |
    6 |                       O
      |
    5 |       O                       O
      |
    4 |       O       O
      |
    3 |   O                   O
      |
    2 |           O
      |
    1 |   O                   O
      |
    0 ---------------------------------------
      0   1   2   3   4   5   6   7   8   9

    Punti = ((1 3) (4 4) (1 1) (2 5) (6 3) (8 5) (6 1) (6 6) (3 2) (2 4)

Ecco una lista di algoritmi che risolvono il problema del convex-hull:

Algoritmo                  Tempo          Autore
----------------------------------------------------------------------
Brute Force                O(n^4)         [Anon, the dark ages]
Gift Wrapping              O(n*h)         [Chand & Kapur, 1970]
Graham Scan                O(n*log(n))    [Graham, 1972]
Jarvis March               O(n*h)         [Jarvis, 1973]
QuickHull                  O(n*h)         [Eddy, 1977], [Bykat, 1978]
Divide-and-Conquer         O(n*log(n))    [Preparata & Hong, 1977]
Monotone Chain             O(n*log(n))    [Andrew, 1979]
Incremental                O(n*log(n))    [Kallay, 1984]
Marriage-before-Conquest   O(n*log(h))    [Kirkpatrick & Seidel, 1986]

Per risolvere questo problema useremo l'algoritmo di Andrew (monotone chain algorithm, 1979) che ha complessità temporale O(n*log(n)) in generale e O(n) se i punti sono già ordinati lungo l'asse x.
Questo algoritmo si basa sul test di orientamento tra 3 punti (vedi sotto) e può evitare errori di arrotondamento.
I punti superiori del convex-hull sono elaborati da sinistra a destra, nell'ordine delle loro coordinate x. La lista "alto" contiene il convex-hull dei punti già processati. Quando si elabora un punto p la prima cosa è aggiungerlo a "alto". Quindi, fintanto che il penultimo punto di "alto" rende la sequenza non convessa, viene rimosso dall'elenco.
Allo stesso modo si ottiene la parte inferiore del convex-hull. Il risultato è ottenuto concatenando le due liste e invertendo la lista "alto" per ottenere i punti dello scafo convesso nell'ordine "normale" (cioè quella antiorario).
Si noti che il primo e l'ultimo elemento delle liste sono uguali e quindi vanno rimossi.

Test di orientamento
--------------------
Dati tre punti p1, p2 e p3, vogliamo sapere se sono allineati, oppure, muovendosi da p1 -> p2 -> p3, se sono in senso orario (destra) o in senso anti-orario (sinistra).

Dobbiamo controllare il segno della componente z del prodotto vettoriale:
  ____   ____
  p1p2 × p2p3

Se è positivo, allora sono in senso antiorario (sinistra),
Se è negativo, allora sono in senso orario (destra),
Se è zero, allora i punti sono allineati.

(define (antiorario? p1 p2 p3)
  (> (sub (mul (sub (p1 0) (p3 0)) (sub (p2 1) (p3 1)))
          (mul (sub (p1 1) (p3 1)) (sub (p2 0) (p3 0)))) 0))

Quando i punti hanno coordinate non intere bisogna eseguire i calcoli che prevedono l'uguaglianza con una piccola tolleranza (esempio 10^-7), invece di utilizzare zero, per proteggersi da eventuali errori di arrotondamento.

(define (convex-hull lst)
  (local (alto basso)
    (sort lst)
    (setq alto '())
    (setq basso '())
    (dolist (p lst)
      ;(if (>= (length alto) 2)
      ;  (begin
      ;  (println p { } (alto -1) { } (alto -2) (antiorario? p (alto -1) (alto -2)))
      ;  (read-line)
      ;))
      (while (and (>= (length alto) 2) (not (antiorario? p (alto -1) (alto -2))))
        (setq alto (chop alto))
      )
      (push p alto -1)
      (while (and (>= (length basso) 2) (not (antiorario? (basso -2) (basso -1) p)))
        (setq basso (chop basso))
      )
      (push p basso -1)
    )
    (append (chop basso) (chop (reverse alto)))))

(setq lst '((1 3) (4 4) (1 1) (2 5) (6 3) (8 5) (6 1) (6 6) (3 2) (2 4)))

(convex-hull lst)
;-> ((1 1) (6 1) (8 5) (6 6) (2 5) (1 3))

Nel diagramma seguente i punti del convex-hull sono contrassegnsti con X.

      |
    6 |                       X
      |
    5 |       X                       X
      |
    4 |       O       O
      |
    3 |   X                   O
      |
    2 |           O
      |
    1 |   X                   X
      |
    0 ---------------------------------------
      0   1   2   3   4   5   6   7   8   9

Proviamo con l'esempio riportato su Rosetta Code:

(setq rc '((16 3) (12 17) (0 6) (-4 -6) (16 6) (16 -7) (16 -3)
           (17 -4) (5 19) (19 -8) (3 16) (12 13) (3 -4) (17 5)
           (-3 15) (-3 -9) (0 11) (-9 -3) (-4 -2) (12 10)))

(convex-hull rc)
;-> ((-9 -3) (-3 -9) (19 -8) (17 5) (12 17) (5 19) (-3 15))

Un esempio più complesso di convex-hull calcolato con questa funzione è visibile nell'immagine "convex-hull.png" contenuta nella cartella "data".


-------------------
SEQUENZA THUE-MORSE
-------------------

La sequenza Thue-Morse, o Prouhet-Thue-Morse, è la sequenza binaria (una sequenza infinita di 0 e 1) ottenuta partendo da 0 e aggiungendo successivamente il complemento booleano della sequenza ottenuta fino a quel momento. I primi passi di questa procedura producono le stringhe 0 poi 01, 0110, 01101001, 0110100110010110 e così via. La sequenza completa inizia così: 01101001100101101001011001101001.... (OEIS A010060).

(define (complemento str)
  (let (compl "")
    (for (i 0 (- (length str) 1))
      ; se carattere = "0", aggiunge 1
      (if (= (str i) "0")
          (extend compl "1")
          ; else
          ; se carattere = "1", aggiunge 0
          (extend compl "0")
      )
    )
    compl))

(define (thue-morse num)
  (let (seq "0")
    (for (i 1 (- num 1))
      (extend seq (complemento seq))
    )
    seq))

(thue-morse 6)
;-> "01101001100101101001011001101001"


--------------
NUMERI DI BELL
--------------

I numeri Bell o esponenziali rappresentano il numero di modi diversi per partizionare un insieme che ha esattamente n elementi. Ogni elemento della sequenza B(n) è il numero di partizioni di un insieme di dimensione n dove l'ordine degli elementi e l'ordine delle partizioni non sono significativi. Per esempio, (a b) è lo stesso di (b a) e (a) (b) è lo stesso di (b) (a).

I primi numeri di Bell hanno i seguenti valori (OEIS A000110):

B(0) = 1 C'è solo un modo per partizionare un insieme con zero elementi ()
B(1) = 1 C'è solo un modo per partizionare un insieme con un elemento (a)
B(2) = 2 Due elementi possono essere partizionati in due modi (a) (b), (a b)
B(3) = 5 Tre elementi possono essere partizionati in cinque modi (a) (b) (c), (a b) (c), (a) (b c), (a c) (b), (a b c)
ecc.

1, 1, 2, 5, 15, 52, 203, 877, 4140, 21147, 115975, 678570, 4213597, 27644437, 190899322, 1382958545, 10480142147, 82864869804, 682076806159, 5832742205057, 51724158235372, 474869816156751, 4506715738447323, 44152005855084346, 445958869294805289, 4638590332229999353, 49631246523618756274

I numeri di Bell possono essere calcolati creando il cosiddetto triangolo di Bell, chiamato anche matrice di Aitken o triangolo di Peirce:

1. Iniziare con il numero uno. Mettere questo numero in una riga da solo x(0,1) = 1.
2 .Iniziare una nuova riga con l'elemento più a destra della riga precedente come numero più a sinistra x(i,1)) = x(i-1,r) dove r è l'ultimo elemento della (i-1)-esima riga.
3. Determinare i numeri che non si trovano nella colonna di sinistra prendendo la somma del numero a sinistra e il numero sopra il numero a sinistra, cioè il numero diagonalmente in alto a sinistra rispetto al numero che stiamo calcolando x(i,j) =  x(i,j-1) + x(i-1,j-1).
4. Ripetere il ​​passaggio 3 finché non c'è una nuova riga con un numero in più rispetto alla riga precedente (Eseguire il passaggio 3 fino a j = r + 1).
5. Il numero sul lato sinistro di una data riga è il numero di Bell per quella riga B(i) = x(i,1).

L'implementazione che segue si basa su questo algoritmo, ma produce solo i numeri di Bell:

(define (bell limite)
  (local (arr num idx out)
    (setq arr (array limite '(0L)))
    (setq num 0L)
    (setf (arr 0) 1L)
    (push (arr 0) out -1)
    (while (< num limite)
      (setf (arr num) (arr 0))
      (setq idx num)
      (while (>= idx 1)
        (setf (arr (- idx 1)) (+ (arr (- idx 1)) (arr idx)))
        (-- idx)
      )
      (++ num)
      ;(println arr)
      ;(read-line)
      (push (arr 0) out -1)
    )
    out))

(bell 25)
;-> (1L 1L 2L 5L 15L 52L 203L 877L 4140L 21147L 115975L 678570L
;->  4213597L 27644437L 190899322L 1382958545L 10480142147L
;->  82864869804L 682076806159L 5832742205057L 51724158235372L
;->  474869816156751L 4506715738447323L 44152005855084346L
;->  445958869294805289L 4638590332229999353L)

Vediamo il 50-esimo numero di Bell:

((bell 50) 49)
;-> 10726137154573358400342215518590002633917247281L

Vediamo i tempi di esecuzione:

(time (bell 100))
;-> 3.996
(time (bell 1000))
;-> 496.267
(time (bell 2000))
;-> 2708.044
(time (bell 4000))
;-> 17817.96
(time (bell 8000))
;-> 131118.729


-----------------------
NUMERI AUTO-DESCRITTIVI
-----------------------

Un numero intero si dice "auto-descrittivo" se ha la proprietà che, quando le posizioni delle cifre sono etichettate da 0 a N-1, la cifra in ciascuna posizione è uguale al numero di volte in cui quella cifra appare nel numero.

Ad esempio, 2020 è un numero autodescrittivo a quattro cifre:

   la posizione 0 ha valore 2 e ci sono due 0 nel numero;
   la posizione 1 ha valore 0 e non ci sono 1 nel numero;
   la posizione 2 ha valore 2 e ci sono due 2;
   la posizione 3 ha valore 0 e ci sono zero 3.

I numeri auto-descrittivi fino a 100 milioni sono: 1210, 2020, 21200, 3211000, 42101000.

(define (int-lst num)
  (let (out '())
    (while (!= num 0)
      (push (% num 10) out)
      (setq num (/ num 10))) out))

(define (autodesc? num)
(catch
  (local (digit num-lst)
    (setq num-lst (int-lst num))
    ; conta le cifre di num-lst
    (setq digit (count '(0 1 2 3 4 5 6 7 8 9) num-lst))
    ; applica la regola ad ogni cifra della lista:
    ; la cifra in ciascuna posizione è uguale al numero di volte
    ; in cui quella cifra appare nel numero?
    (dolist (el num-lst)
      (if (!= (digit $idx) el) (throw nil))
    )
    true)))

(autodesc? 2020)
;-> true

(autodesc? 1210)
;-> true

Definiamo una funzione che calcola i numeri descrittivi fino ad un dato numero:

(define (autodesc num)
  (for (i 1 num)
    (if (autodesc? i) (print i {, }))))

Vediamo i tempi di calcolo:

(time (autodesc 1e8))
;-> 1210, 2020, 21200, 3211000, 42101000,
;-> 378928.914 ;6 minuti e 20 secondi (circa)


---------
JORT SORT
---------

Nota: JortSort è considerato un'opera di satira. Raggiunge il suo risultato in modo intenzionalmente indiretto. La soluzione deve essere nello spirito del jortsort originale piuttosto che cercare di scrivere la versione più efficiente.

"JortSort è un uno strumento di ordinamento che lascia all'utente l'onere di svolgere il lavoro e garantisce efficienza perché non è necessario ordinare mai più." Jenn "Moneydollars" Schiffer al JSConf.

JortSort è una funzione che accetta come argomento una singola lista di oggetti comparabili.
Quindi ordina la lista in ordine crescente e confronta la lista ordinato con la lista originariamente fornita.
Se le liste corrispondono (ovvero la lista originale era già ordinata), la funzione restituisce true.
Se le liste non corrispondono (ovvero la lista originale non è stato ordinata), la funzione restituisce false (nil).

(define (jort-sort lst)
  (if (= lst (sort (copy lst)))
      true
      nil))

(jort-sort '(1 2 3 5 2))
;-> nil
(jort-sort '(1 2 3 5 11))
;-> true


-----------------------------
FUNZIONI MUTUAMENTE RICORSIVE
-----------------------------

Scrivere due funzioni mutuamente (reciprocamente) ricorsive che calcolano gli elementi delle sequenze di Hofstadter "Female" e "Male" definite come:

F(0) = 1
M(0) = 0
F(n) = n - M(F(n-1)), per n>0
M(n) = n - F(M(n-1)), per n>0

I primi termini di questa sequenze sono:

F: 1, 1, 2, 2, 3, 3, 4, 5, 5, 6, 6, 7, 8, 8, 9, 9, 10, 11, 11, 12, 13, ... (A005378 OEIS)
M: 0, 0, 1, 2, 2, 3, 4, 4, 5, 6, 6, 7, 7, 8, 9, 9, 10, 11, 11, 12, 12, ... (A005379 OEIS)

(define (female num)
  (if (= num 0) 1
      (- num (male (female (- num 1))))))

(define (male num)
  (if (= num 0) 0
      (- num (female (male (- num 1))))))

(for (i 0 20) (print (female i) { }))
;-> 1 1 2 2 3 3 4 5 5 6 6 7 8 8 9 9 10 11 11 12 13
(for (i 0 20) (print (male i) { }))
;-> 0 0 1 2 2 3 4 4 5 6 6 7 7 8 9 9 10 11 11 12 12

Un altro esempio di coppia di funzioni mutuamente ricorsive è il seguente:

(define (pari? num)
  (cond ((zero? num) true)
        (true (dispari? (- (abs num) 1))))))

(define (dispari? num)
  (cond ((zero? num) nil)
        (true (pari? (- (abs num) 1)))))

(pari? 237)
;-> nil
(pari? 200)
;-> true
(pari? -100)
;-> true
(pari? -77)
;-> nil

(dispari? 237)
;-> true
(dispari? 200)
;-> nil
(dispari? -100)
;-> nil
(dispari? -77)
;-> true


-----------------------
NUMERI IN BASE NEGATIVA
-----------------------

I numeri in base negativa sono un modo alternativo per codificare i numeri senza la necessità del segno meno "-". È possibile utilizzare varie basi negative, tra cui nega-decimale (base -10), nega-binaria (-2) e nega-ternaria (-3).

Una base negativa può essere utilizzata per costruire un sistema numerico posizionale non standard. Come altri sistemi a valore posizionale, ogni posizione contiene multipli della potenza appropriata della base del sistema, solo che in questo caso la base è negativa, cioè la base b è uguale a −r per qualche numero naturale r (r ≥ 2).

I sistemi a base negativa possono contenere tutti gli stessi numeri dei sistemi di valori di posizione standard, ma sia i numeri positivi che quelli negativi sono rappresentati senza l'uso di un segno meno (o, nella rappresentazione del computer, senza il bit di segno). Questo vantaggio è controbilanciato da una maggiore complessità delle operazioni aritmetiche. La necessità di memorizzare le informazioni normalmente contenute da un segno negativo si traduce spesso in un numero in base negativa più lungo di una cifra rispetto al suo equivalente in base positiva.

Esempio
Rappresentazione del numero 12243 nel sistema negadecimale (b = −10):

Multipli
  (−10)^4 = 10000  (−10)^3 = −1000  (−10)^2 = 100  (−10)^1 = −10  (−10)^0 = 1
          1                2                2              4              3

Poiché 10000 + (−2000) + 200 + (−40) + 3 = 8163, la rappresentazione 12243(−10) in notazione negadecimale è equivalente a 8163(10) in notazione decimale, mentre −8163(10) in decimale sarebbe scritto 9977(−10) in negadecimale.

Scriviamo due funzioni che codificano/decodificano un numero in base negativa:

Funzione che converte un numero in base 10 nel numero (stringa) corrispondente in una certa base negativa:

(define (to-neg-base num bn)
  (local (digits nn val out)
    (setq digits "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
    (cond ((or (< bn -62) (> bn -1)) nil)
          ((zero? num) "0")
          (true
           (setq out "")
           (setq nn (bigint num))
           (until (zero? nn 0)
             (setq val (% nn bn))
             (setq nn (/ nn bn))
             (if (< val 0)
                 (setq nn (+ nn 1) val (- val bn))
             )
             (push (digits val) out)
           ))
     )
     out))

Facciamo alcune prove:

(to-neg-base 8163 -10)
;-> "12243"
(to-neg-base -8163 -10)
;-> "9977"

(define (from-neg-base ns b)
  (local (digits nn val out)
    (setq digits "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
    (cond ((or (< b -62) (> b -1)) nil)
          ((zero? ns) "0")
          (true
           (setq out 0)
           (setq bb 1L)
           (for (i (- (length ns) 1) 0 -1)
             (setq out (+ out (* bb (find (ns i) digits))))
             (setq bb (* bb b))
           ))
    )
    out))

Facciamo alcune prove:

(from-neg-base "12243" -10)
;-> 8163
(from-neg-base "9977" -10)
;-> -8163
(from-neg-base "11110" -2)
;-> 10

(from-neg-base (to-neg-base 1234567890 -10) -10)
;-> 1234567890
(to-neg-base (from-neg-base "1234567890" -10) -10)
;-> "1234567890"

(from-neg-base "newLISP" -62)
;-> 2747418320417
(to-neg-base 2747418320417 -62)
;-> "newLISP"

(from-neg-base "cameyo" -62)
(to-neg-base -34292389174 -62)
;-> "cameyo"


-----------
QUATERNIONI
-----------

I quaternioni sono entità matematiche introdotte da William Hamilton nel 1843 come estensioni dei numeri complessi. Un quaternione è un oggetto formale del tipo:

  a + bi + cj + dk

dove a,b,c,d sono numeri reali e i,j,k sono dei simboli che si comportano in modo simile all'unità immaginaria dei numeri complessi.

Somma e prodotto di due quaternioni sono definiti tenendo conto delle relazioni:

  i∙i = j∙j = k∙k = i∙j∙k = -1 oppure ii = jj = kk = ijk = -1.

che implicano:

  i*j = k
  j*k = i
  k*i = j
  j*i = -k
  k*j = -i
  i*k = -j

La tabella seguente riassume i risultati delle moltiplicazioni fra due elementi:

  +---+---+---+---+---+
  | * | 1 | i | j | k |
  +---+---+---+---+---+
  | 1 | 1 | i | j | k |
  +---+---+---+---+---+
  | i | i |-1 | k |-j |
  +---+---+---+---+---+
  | j | j |-k |-1 | i |
  +---+---+---+---+---+
  | k | k | j |-i |-1 |
  +---+---+---+---+---+

L'ordine di moltiplicazione è importante, infatti ,in generale, per due quaternioni q1 e q2:

  q1q2 ≠ q2q1.

Scrivere le funzioni per le seguenti operazioni di base con i quaternioni:

  q = a + bi + cj + dk

Norma di un quaternione q

  (norma q) = sqrt(a^2 + b^2 + c^2 + d^2)

Negativo di un quaternione q

  (negativo q) = (-a, -b, -c, -d)

Coniugato di un quaternione q

  (coniugato q) = (a, -b, -c, -d)

Addizione numero reale r e quaternione q

  r + q = q + r = (a + r, b, c, d)

Addizione di due quaternioni q1 e q2

  q1 + q2 = (a1+a2, b1+b2, c1+c2, d1+d2)

Moltiplicazione numero reale r e quaternione q

  q*r = r*q = (ar, br, cr, dr)

Moltiplicazione di due quaternioni q1 e q2

  (a1a2 − b1b2 − c1c2 − d1d2,
  a1b2 + b1a2 + c1d2 − d1c2,
  a1c2 − b1d2 + c1a2 + d1b2,
  a1d2 + b1c2 − c1b2 + d1a2)

Utilizziamo una lista per rappresentare un quaternione:

  q = (a + bi + cj + dk)  ==> (a b c d)

(setq q  '(1 2 3 4))
(setq q1 '(2 3 4 5))
(setq q2 '(3 4 5 6))
(setq r 7)

; norma di un quaternione
(define (norm-quat q)
  (let (out 0)
    (for (i 0 3)
      (setq out (add out (mul (q i) (q i)))))
    (sqrt out)))

(setq q '(1 2 3 4))
(norm-quat q)
;-> 5.477225575051661

; Negativo di un quaternione
(define (neg-quat q)
  (for (i 0 3)
    (setf (q i) (mul -1 (q i))))
  q)

(neg-quat q)
;-> (-1 -2 -3 -4)

; Coniugato di un quaternione
(define (coniug-quat q)
  (for (i 1 3)
    (setf (q i) (mul -1 (q i))))
  q)

(coniug-quat q)
;-> (1 -2 -3 -4)

; Addizione/sottrazione numero reale e quaternione
(define (add-real-quat r q)
  (setf (q 0) (add (q 0) r))
  q)

(add-real-quat r q)
;-> (8 2 3 4)

; Addizione/sottrazione tra due quaternioni
(define (add-quat q1 q2)
  (for (i 0 3)
    (setf (q1 i) (add (q1 i) (q2 i))))
  q1)

(add-quat q1 q2)
;-> (5 7 9 11)

; Moltiplicazione numero reale e quaternione
(define (mul-real-quat r q)
  (for (i 0 3)
    (setf (q i) (mul r (q i))))
  q)

(mul-real-quat r q)
;-> (7 14 21 28)

; Moltiplicazione tra due quaternioni
(define (mul-quat q1 q2)
  (let (out '(0 0 0 0))
    (setf (out 0) (sub (mul (q1 0) (q2 0))    (mul (q1 1) (q2 1))     (mul (q1 2) (q2 2))     (mul (q1 3) (q2 3))))
    (setf (out 1) (add (mul (q1 0) (q2 1))    (mul (q1 1) (q2 0))     (mul (q1 2) (q2 3))  (- (mul (q1 3) (q2 2)))))
    (setf (out 2) (add (mul (q1 0) (q2 2)) (- (mul (q1 1) (q2 3)))    (mul (q1 2) (q2 0))     (mul (q1 3) (q2 1))))
    (setf (out 3) (add (mul (q1 0) (q2 3))    (mul (q1 1) (q2 2))  (- (mul (q1 2) (q2 1)))    (mul (q1 3) (q2 0))))
    out))

(mul-quat q1 q2)
;-> (-56 16 24 26)
(mul-quat q2 q1)
;-> (-56 18 20 28)

Potete trovare una libreria sui quaternioni scritta da Heiko Schroeter al seguente indirizzo web:

  http://www.newlisp.org/modules/various/quatlib.lsp.html

Nota: i quaternioni vengono utilizzati nella modellizzazione delle rotazioni dello spazio: per questo motivo vengono impiegati nella fisica teorica (teoria della relatività e meccanica quantistica) e in settori applicativi, come la computer grafica 3D e la robotica.

Nota: l'uso dei quaternioni per ruotare un oggetto 3D lungo i tre assi x,y,z elimina il problema del "Gimbal lock", che può verificarsi se si utilizzano gli angoli di Eulero per la rotazione dell'oggetto.

Il "Gimbal lock" (blocco del giunto cardanico) è il fenomeno di due assi di rotazione di un oggetto che puntano nella stessa direzione. In poche parole, significa che il tuo oggetto non ruoterà come pensi che dovrebbe ruotare. Questo è un problema frustrante che ogni artista di computer grafica dovrà affrontare durante la sua carriera (e accade sempre nel momento peggiore possibile). Il Gimbal lock si verifica quando si ruota un oggetto con una matrice di rotazione con angoli di Eulero. È una limitazione generale di questo tipo di matrice di rotazione.

Qualsiasi sistema che utilizza gli angoli di Eulero (Maya, Max, Lightwave, Softimage) ha problemi di Gimbal lock. La ragione di ciò è che gli angoli di Eularo valutano ogni asse indipendentemente e in un ordine prestabilito. Ad esempio, l'ordine è generalmente X, Y, Z (ma vale anche per altri ordini), il che significa che prima l'oggetto viaggia lungo l'asse X. Quando l'operazione è completa, si sposta lungo l'asse Y e infine l'asse Z. Il problema del Gimbal lock si verifica quando si ruota l'oggetto lungo l'asse Y, diciamo di 90 gradi. Poiché la componente X è già stata valutata, non viene considerata con gli altri due assi. QUello che accade è che gli assi X e Z punto lungo lo stesso asse.

Il programma ZBrush (Pixologic) utilizza internamente sia gli angoli di Eulero che i quaternioni, ma il linguaggio di scripting mette a disposizione solo gli angoli di Eulero. Questa è la risposta di Pixolator (alias Ofer Alon, creatore del programma Zbrush) ad una mia richiesta di spiegazioni nel lontano luglio 2003:

"Hi Cameyo:
As you have already figured out, rotation system is a bit complicated. Internally, ZBrush is utilizing rotation matrices, Euler angles as well as quaternions.The rotation values in the TRNASFORM palette (and the TransformGet commands) are values that have been translated from ZBrush's internal representation into a more readable x,y,z angles format. The effective range for Y and Z rotations is ± 180 degrees. Values that are outside this range are automatically readjusted to fit within this range. The effective range for the X axis is only ±90 (this is why your ZScript is problematic when the X axis angle crosses the 90 degrees range). If you use values outside this range, the X will be readjusted and may require the Y axis to be reflected (+180 degrees). As mentioned above, "Gimbal lock" is also an issue when rotating an object by 90 degrees increments.

These factors must be taken into consideration when ZScripting rotation commands. One of ZBrush's standard ZScripts is the "PointFromTo" ZScript. This ZScript present a solution to a different, but yet related, rotation problem. I am including the source code of the "PointFromTo" ZScript here, you may find it helpful to your rotation explorations

-Pixolator"

Le rotazioni dei quaternioni sono molto più potenti e robuste poichè valutano tutti e tre gli assi contemporaneamente per trovare una direzione in cui muoversi e un quarto valore (la componente w o il vettore up) per indicare alla matrice quanto deve muoversi. Il vantaggio di utilizzare questo metodo è che non dobbiamo mai preoccuparci del Gimbal Lock poichè non può accadere in quanto tutti e tre gli assi vengono aggiornati contemporaneamente. Il lato negativo dell'utilizzo dei quaternioni è che sono molto più complicati da concettualizzare e implementare rispetto agli angoli di Eulero.


--------
BIORITMI
--------

Un bioritmo è un tentativo di identificare vari aspetti della vita di una persona attraverso una semplice modellazione matematica. La maggior parte degli scienziati crede che quest'idea non abbia un'efficacia maggiore del caso e considerano il concetto come un esempio di pseudoscienza.

Secondo la teoria dei bioritmi, la vita di una persona è caratterizzata da cicli biologici ritmici che influenzano le attività e le abilità personali in vari aspetti: fisico, emotivo e mentale (intellettuale). Questi cicli iniziano alla nascita ed oscillano in modo costante (onde sinusoidali) nel corso della vita.

La maggior parte dei modelli di bioritmo usa tre cicli: uno fisico di 23 giorni, uno emotivo di 28 ed uno mentale di 33. Sebbene il ciclo di 28 giorni sia della stessa lunghezza del ciclo mestruale medio delle donne, e sia stato in origine definito come ciclo “femminile” (vedi in seguito), i due non sono necessariamente sincronizzati. Ognuno di questi cicli varia tra estremi alti e bassi, in modo sinusoidale, con giorni in cui il ciclo incrocia la linea dello zero, descritti come "giorni critici" a maggior rischio di incertezza. In aggiunta a questi tre cicli, sono stati proposti vari altri cicli, basati sulla combinazione lineare dei tre, o su cicli più lunghi o più corti.

Le equazioni che regolano i tre cicli di base sono:

  Fisico: sin(2*pi*x/23)
  Emotivo: sin(2*pi*x/28)
  Mentale: sin(2*pi*x/33)

dove x indica il numero di giorni dalla nascita.

Si può osservare che la combinazione dei due cicli di 23 e 28 giorni si ripete (periodo) ogni 644 giorni (un anno e 3/4), mentre la tripla combinazione dei cicli di 23, 28 e 33 giorni si ripete ogni 21.252 giorni (circa 58 anni).

Converte una data gregoriana in numero del giorno giuliano (valido solo dal 15 ottobre 1582 d.C.):

(define (gdate-julian gdate)
  (local (a y m)
    (setq a (/ (- 14 (gdate 1)) 12))
    (setq y (+ (gdate 0) 4800 (- a)))
    (setq m (+ (gdate 1) (* 12 a) (- 3)))
    (+ (gdate 2) (/ (+ (* 153 m) 2) 5) (* y 365) (/ y 4) (- (/ y 100)) (/ y 400) (- 32045))))

Calcola la differenza tra due date gregoriane:

(define (gdate-diff gdate1 gdate2)
  (- (gdate-julian gdate1) (gdate-julian gdate2)))

(gdate-diff '(2021 5 6) '(1983 3 21))
;-> 13926

(setq PI 3.1415926535897931)

Funzioni per i tre cicli:

(define (fisico x)
  (sin (div (mul 2 3.141592653589793 x) 23)))
(define (emotivo x)
  (sin (div (mul 2 3.141592653589793 x) 28)))
(define (mentale x)
  (sin (div (mul 2 3.141592653589793 x) 33)))

(fisico 0)
;-> 0
(fisico 644)
;-> -6.857795581405313e-015

Vediamo come visualizzare i valori dei tre cicli nell'intervallo (-100, 100):

(define (cicli)
  (println " Emotivo       Fisico        Mentale")
  (println " gg    val     gg    val     gg    val")
  (for (i 0 33 1)
    (print (format "%3d  %+5d    " i (round (mul 100 (fisico i)))))
    (print (format "%3d  %+5d    " i (round (mul 100 (emotivo i)))))
    (print (format "%3d  %+5d    " i (round (mul 100 (mentale i)))))
    (println {})))

(cicli)
;-> Emotivo       Fisico        Mentale
;-> gg    val     gg    val     gg    val
;->  0     +0      0     +0      0     +0
;->  1    +27      1    +22      1    +19
;->  2    +52      2    +43      2    +37
;->  3    +73      3    +62      3    +54
;->  4    +89      4    +78      4    +69
;->  5    +98      5    +90      5    +81
;->  6   +100      6    +97      6    +91
;->  7    +94      7   +100      7    +97
;->  8    +82      8    +97      8   +100
;->  9    +63      9    +90      9    +99
;-> 10    +40     10    +78     10    +95
;-> 11    +14     11    +62     11    +87
;-> 12    -14     12    +43     12    +76
;-> 13    -40     13    +22     13    +62
;-> 14    -63     14     +0     14    +46
;-> 15    -82     15    -22     15    +28
;-> 16    -94     16    -43     16    +10
;-> 17   -100     17    -62     17    -10
;-> 18    -98     18    -78     18    -28
;-> 19    -89     19    -90     19    -46
;-> 20    -73     20    -97     20    -62
;-> 21    -52     21   -100     21    -76
;-> 22    -27     22    -97     22    -87
;-> 23     +0     23    -90     23    -95
;-> 24    +27     24    -78     24    -99
;-> 25    +52     25    -62     25   -100
;-> 26    +73     26    -43     26    -97
;-> 27    +89     27    -22     27    -91
;-> 28    +98     28     +0     28    -81
;-> 29   +100     29    +22     29    -69
;-> 30    +94     30    +43     30    -54
;-> 31    +82     31    +62     31    -37
;-> 32    +63     32    +78     32    -19
;-> 33    +40     33    +90     33     +0

Scriviamo una funzione che visualizza i valori dei bioritmi per 11 giorni (5 giorni prima, giorno scelto, 5 giorni dopo) in modo da identificare anche l'andamento delle curve e non solo i valori del giorno scelto:

(define (bioritmi data-oggi data-nascita)
  (println "Emotivo   Fisico   Mentale")
  (setq giorni (gdate-diff data-oggi data-nascita))
  (setq pre (- giorni 5))
  (setq post (+ giorni 5))
  (for (i pre post)
    (if (= i giorni) (println (format "%s" (dup "-" 31))))
    (print (format "%+6d   %+6d   %+6d"
            (round (mul 100 (fisico i))) (round (mul 100 (emotivo i))) (round (mul 100 (mentale i)))))
    (if (= i giorni) (print (format "\n%s" (dup "-" 31))))
    (println {})
  ))

Bioritmo del giorno 6 maggio 2021 per una persona nata il 21 marzo 1983:

(bioritmi '(2021 5 6) '(1983 3 21))
;-> Emotivo   Fisico   Mentale
;->   +100      +90      -81
;->    +94      +97      -69
;->    +82     +100      -54
;->    +63      +97      -37
;->    +40      +90      -19
;-> -------------------------------
;->    +14      +78       +0
;-> -------------------------------
;->    -14      +62      +19
;->    -40      +43      +37
;->    -63      +22      +54
;->    -82       +0      +69
;->    -94      -22      +81


-----------
RUNGE-KUTTA
-----------

Data l'equazione differenziale:

  y'(t) = t * sqrt[y(t)]

con le condizioni inziali:

  t0 = 0
  y0 = y(t0) = y(0) = 1

Questa equazione a la seguente soluzione esatta:

          (t² + 4)²
  y(t) = -----------
            16

Utilizzare il metodo Runge-Kutta del quarto ordine per risolvere l'equazione differenziale nell'intervallo t = 0 ... 10 con un valore di incremento di dt = 0.1 (101 punti totali, dato il primo). Stampare i valori calcolati di y ad ogni valore intero di t (0, 1.0, 2.0, ... 10.0) insieme all'errore rispetto alla soluzione esatta.

Metodo Runge-Kutta
------------------
Partendo da un dato yn e tn calcolare:

  dy1 = dt * y'(tn,yn)
  dy2 = dt * y'(tn + dt/2, yn + dy1/2)
  dy3 = dt * y'(tn + dt/2, yn + dy2/2)
  dy4 = dt * y'(tn + dt, yn + dy3)

poi calcolare:

  y(n+1) = yn + (dy1 +2*dy2 + 2*dy3 + dy4)/6
  t(n+1) = tn + dt

Implementazione:

(define (equation t y) (mul t (sqrt y)))
(define (solution t) (div (pow (add (mul t t) 4) 2) 16))

(define (rk4)
  (local (t end-t dt n y s dy1 dy2 dy3 dy4 i error t-rounded)
    (setq t 0.0)
    (setq end-t 10.0)
    (setq dt 0.1)
    (setq n (+ (int (div (sub end-t t) dt)) 1))
    (setq y (array n '(0)))
    (setq s (array n '(0)))
    (setq i 0)
    (setq (s i) 0.0)
    (setq (y i) 1.0)
    (println " t    y(t)     errore")
    (println (format "%4.1f %8.3f  %e" 0.00 1.00 0.00))
    (while (< i (- (length y) 1))
      (setq dy1 (mul dt (equation (s i) (y i))))
      (setq dy2 (mul dt (equation (add (s i) (div dt 2)) (add (y i) (div dy1 2)))))
      (setq dy3 (mul dt (equation (add (s i) (div dt 2)) (add (y i) (div dy2 2)))))
      (setq dy4 (mul dt (equation (add (s i) dt) (add (y i) dy3))))
      (setf (s (+ i 1)) (add (s i) dt))
      (setf (y (+ i 1)) (add (y i) (div (add dy1 (mul 2 dy2) (mul 2 dy3) dy4) 6)))
      (setq error (abs (sub (y (+ i 1)) (solution (s (+ i 1))))))
      (setq t-rounded (round (add t dt) -2))
      (if (zero? (mod t-rounded 1))
          (println (format "%4.1f %8.3f  %e" t-rounded (y (+ i 1)) error))
      )
      (++ i)
      (setq t (add t dt))
    )
    '----------------------------))

(rk4)
;->  t    y(t)     errore
;->  0.0    1.000  0.000000e+000
;->  1.0    1.562  1.457219e-007
;->  2.0    4.000  9.194792e-007
;->  3.0   10.562  2.909562e-006
;->  4.0   25.000  6.234909e-006
;->  5.0   52.562  1.081970e-005
;->  6.0  100.000  1.659460e-005
;->  7.0  175.562  2.351773e-005
;->  8.0  289.000  3.156520e-005
;->  9.0  451.562  4.072316e-005
;-> 10.0  676.000  5.098329e-005
;-> ----------------------------


------
ISBN13
------

Il codice ISBN ("International Standard Book Number" cioè il numero di riferimento internazionale di un libro) è una sequenza numerica di 13 cifre usata per la classificazione dei libri.
L'attuale codice ISBN è formato da una stringa di 13 cifre, suddivise in 5 settori. Generalmente, ma non sempre, i vari settori del codice ISBN sono separati l'uno dall'altro da un trattino (è il metodo consigliato) o da uno spazio.

1) Prefisso EAN – sono le prime tre cifre del codice ISBN, introdotte a partire dal 2007. Indicano che si è in presenza di un libro.

2) Gruppo linguistico – è l'identificativo del paese o dell'area linguistica dell'editore. Può utilizzare da 1 a 5 cifre.

3) Editore – è l'identificativo della casa editrice o del marchio editoriale. Può utilizzare da 2 a 7 cifre.

4) Titolo – è l'identificativo del libro. Può utilizzare da 1 a 6 cifre.

5) Carattere di controllo – è l'ultima cifra del codice ISBN (nei "vecchi" codici ISBN-10, oltre ai numeri da 0 a 9, si utilizzava anche il 10 romano, cioè la "X") e serve a verificare che il codice non sia stato letto o trascritto erroneamente.

Solo il primo e l'ultimo settore hanno un numero fisso di cifre (rispettivamente 3 e 1), mentre per gli altri tre settori centrali il numero di cifre varia in modo complementare fra loro. I tre settori centrali, nel loro insieme, hanno dunque a disposizione le nove cifre restanti. Questo significa che, meno cifre sono utilizzate dal gruppo linguistico e dall'editore, più cifre sono disponibili per la sua produzione editoriale (il settore titolo). In altre parole, le lingue e gli editori che hanno meno cifre nel codice ISBN dovrebbero essere anche quelli che pubblicano una maggior quantità di libri.

Verificare se un numero ISBN13 è valido.

Algoritmo di validazione ISBN13
-------------------------------
ISBN      9    7    8    1    8    6    1    9    7    8    7    6    9
Peso      1    3    1    3    1    3    1    3    1    3    1    3    1
Prodotto  9 + 21 +  8 +  3 +  8 + 18 +  1 + 27  + 7 + 24 +  7 + 18 +  9 = 160

160 diviso 10 = 16 resto 0
Se il resto vale 0, allora ISBN13 è valido.

Esempi:

  978-1734314502 valido
  978-1734314509 errato
  978-1788399081 valido
  978-1788399083 errato

Possiamo scrivere la seguente funzione per la verifica:

(define (check-ISBN13 str)
  (local (mult)
    (setq str (replace "-" str ""))
    (setq mult '(1 3 1 3 1 3 1 3 1 3 1 3 1))
    (setq val (map int (explode str)))
    (setq m (apply + (map * val mult)))
    (zero? (% m 10))))

(check-ISBN13 "978-1734314502")
;-> true
(check-ISBN13 "978-1734314509")
;-> nil
(check-ISBN13 "978-1788399081")
;-> true
(check-ISBN13 "978-1788399083")
;-> nil


-----------------
INSIEME DI CANTOR
-----------------

L'insieme di Cantor (dal matematico tedesco Georg Cantor), è un sottoinsieme dell'intervallo [0, 1] dei numeri reali.
L'insieme di Cantor è definibile in modo ricorsivo, partendo dall'intervallo [0, 1] e rimuovendo ad ogni passo un segmento aperto centrale da ogni intervallo.
Al primo passo rimuoviamo da [0, 1] il sotto-intervallo (1/3, 2/3), e rimaniamo quindi con due intervalli [0, 1/3] U [2/3, 1].
Al secondo passo rimuoviamo un segmento aperto centrale in entrambi questi intervalli (che ha lunghezza pari a un terzo della lunghezza del segmento, come al primo passo), e otteniamo quattro intervalli ancora più piccoli. E si continua così in modo analogo.
L'insieme di Cantor consiste di tutti i punti dell'intervallo di partenza [0, 1] che non vengono mai rimossi da questo procedimento ricorsivo: in altre parole, l'insieme che rimane dopo aver iterato questo procedimento infinite volte. È chiamato in termini suggestivi come "polvere di Cantor".

I primi quattro passi di questo processo sono illustrati qui sotto:

  ■■■■■■■■■■■■■■■■■■■■■■■■■■■
  ■■■■■■■■■         ■■■■■■■■■
  ■■■   ■■■         ■■■   ■■■
  ■ ■   ■ ■         ■ ■   ■ ■

Scriviamo una funzione che stampa 5 passi del processo:

(define (cantor start len idx)
 (local (seg)
  (setq seg (/ len 3))
  (cond ((zero? seg) nil)
        (true
         (for (i idx (- height 1))
           (for (j (+ start seg) (+ start (* seg 2) (- 1)))
             (setf (lines i j) " ")
           )
         )
         (cantor start seg (+ idx 1))
         (cantor (+ start (* seg 2)) seg (+ idx 1)))
  )))

(define (cantor-set)
  (local (width height lines)
    (setq width 81)
    (setq height 5)
    (setq lines (array height width '("■")))
    (cantor 0 width 1)
    (for (i 0 (- height 1))
      (for (j 0 (- width 1))
        (print (lines i j))
      )
      (println {})
    )))

(cantor-set)
;-> ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
;-> ■■■■■■■■■■■■■■■■■■■■■■■■■■■                           ■■■■■■■■■■■■■■■■■■■■■■■■■■■
;-> ■■■■■■■■■         ■■■■■■■■■                           ■■■■■■■■■         ■■■■■■■■■
;-> ■■■   ■■■         ■■■   ■■■                           ■■■   ■■■         ■■■   ■■■
;-> ■ ■   ■ ■         ■ ■   ■ ■                           ■ ■   ■ ■         ■ ■   ■ ■


---------------------------------------------
INCREMENTO-DECREMENTO DI UNA STRINGA NUMERICA
---------------------------------------------

Scrivere due funzioni per incrementare e decrementare una stringa numerica.

Incrementa una stringa numerica:

(define (inc-str str)
  (string (++ (int str 0 10))))

(inc-str "-1")
;-> 0
(inc-str "08")
;-> "9"
(inc-str "")
;-> "1"

Decrementa una stringa numerica:

(define (dec-str str)
  (string (-- (int str 0 10))))

(dec-str "-1")
;-> "-2"
(dec-str "12abc")
;-> "11"
(dec-str "abc12")
;-> "-1"


------------------------
FUNZIONI DI PRIMA CLASSE
------------------------

Un linguaggio ha funzioni di prima classe ("first-class funciton") se può eseguire ciascuna delle seguenti operazioni senza invocare ricorsivamente un compilatore o un interprete o la metaprogrammazione:

1) Creare nuove funzioni da funzioni preesistenti in fase di esecuzione
2) Memorizzare le funzioni in oggetti iterabili (es. liste,vettori)
3) Usare le funzioni come argomenti per altre funzioni
4) Usare le funzioni come valori di ritorno di altre funzioni

Il seguente codice effettua tutte le operazioni richieste:

(define (compose f g) (expand (lambda (x) (f (g x))) 'f 'g))
(define (cube x) (pow x 3))
(define (cube-root x) (pow x (div 1 3)))

(setq function (list sin cos cube))
(setq inverse (list asin acos cube-root))
(setq x 0.5)

(define (go f g)
  (if (not (or (null? f) (null? g)))
      (begin (println ((compose (first f) (first g)) x))
             (go (rest f) (rest g)))))

(go function inverse)
;-> 0.5
;-> 0.4999999999999999
;-> 0.5000000000000001

Prima-classe (first-class) e Ordine-superiore (high-class)
----------------------------------------------------------
Funzione di prima classe:
un linguaggio di programmazione ha funzioni di prima classe se le funzioni in quel linguaggio vengono trattate come altre variabili. Quindi le funzioni possono essere assegnate a qualsiasi altra variabile o passate come argomento o possono essere restituite da un'altra funzione.

Funzione di ordine superiore:
una funzione che riceve un'altra funzione come argomento o che restituisce una nuova funzione o entrambe è chiamata funzione di ordine superiore. Le funzioni di ordine superiore sono possibili solo grazie alla funzione di prima classe.


----------------
INVERSIONE FRASE
----------------

Data una stringa di parole separate da spazi scrivere tre funzioni per:

1) Invertire i caratteri della stringa.
2) Invertire i caratteri di ogni singola parola nella stringa, mantenendo l'ordine originale delle parole all'interno della stringa.
3) Invertire l'ordine di ogni parola della stringa, mantenendo l'ordine dei caratteri in ogni parola.

(setq str "Frase da invertire")

1)
(define (invert-chars str)
  (reverse str))
(invert-chars str)
;-> "eritrevni ad esarF"

2)
(define (invert-words-chars str)
  (map reverse (parse str " " )))
(invert-words-chars str)
;-> ("esarF" "ad" "eritrevni")

3)
(define (invert-words str)
  (reverse (parse str " " )))
(invert-words str)
;-> ("invertire" "da" "Frase")


---------------------
CONTEGGIO POPOLAZIONE
---------------------

Il conteggio della popolazione (population count) è il numero di 1 (uno) nella rappresentazione binaria di un numero intero non negativo. Quseto valore è conosciuto anche con i seguenti nomi:

 - pop count
 - popcount
 - sideways sum
 - bit summation
 - Hamming weight

Ad esempio, 5 (che è 101 in binario) ha un conteggio della popolazione pari a 2.

I numeri malvagi (Evil numbers) sono numeri interi non negativi che hanno un conteggio della popolazione pari (OEIS A001969).

I numeri odiosi (Odious numbers) sono numeri interi positivi che hanno un conteggio della popolazione dispari (OEIS A000069).

Scrivere una funzione che genera i numeri malvagi e i numeri odiosi fino ad un dato numero.

(define (count-pop num)
  (first (count '("1") (explode (bits num)))))
(count-pop 100)
;-> 3

(define (evil-odious num)
  (let ((evil '()) (odious '()) (val 0))
    (for (i 0 num)
      (setq val (count-pop i))
      (if (even? val)
          (push i evil -1)
          (push i odious -1)
      )
    )
    (list evil odious)))

(evil-odious 30)
;-> ((0 3 5 6 9 10 12 15 17 18 20 23 24 27 29 30)
;->  (1 2 4 7 8 11 13 14 16 19 21 22 25 26 28))


------------------------------
SELEZIONE CASUALE DA UNA LISTA
------------------------------

Scrivere una funzione che seleziona un elemento casuale da una lista.

(define (pick-rand lst)
  (lst (rand (length lst))))

(setq lst '(6 21 31 12 58 63 77 36 42))

(pick-rand lst)
;-> 6
(pick-rand lst)
;-> 63
(pick-rand lst)
;-> 21
(pick-rand lst)
;-> 63

Se vogliamo ogni volta un elemento diverso (fino all'esaurimento dei numeri della lista) possiamo scrivere:

(setq lst '(6 21 77 42))

(define (pick-unique-rand)
  (cond ((null? lst) nil)
        (true
        (let (val (lst (rand (length lst))))
        (pop lst (find val lst))
        val))))

(pick-unique-rand lst)
;-> 21
(pick-unique-rand lst)
;-> 77
(pick-unique-rand lst)
;-> 6
(pick-unique-rand lst)
;-> 42
;-> (pick-unique-rand lst)
nil

Oppure possiamo generare tutta la lista di numeri casuali con la funzione "randomize":

(define (get-unique-rand lst)
  (randomize lst))

(setq lst (sequence 1 90))

(get-unique-rand lst)
;-> (41 75 43 66 77 11 23 15 82 40 72 87 20 74 32 10 37 63 56 21 61 50
;->  90 71 1 76 78 53 64 6 47 2 83 27 3 28 33 42 59 58 4 85 81 31 70 52
;->  7 34 79 12 44 54 19 14 89 65 67 16 24 73 39 38 60 25 5 30 86 46 55
;->  80 57 29 26 62 13 68 9 49 36 48 8 69 84 45 51 17 22 35 88 18)


------------------------------
RAPPRESENTAZIONE DI ZECKENDORF
------------------------------

Proprio come i numeri possono essere rappresentati in una notazione posizionale come somme di multipli delle potenze di dieci (decimali) o di due (binarie), tutti gli interi positivi possono essere rappresentati come la somma di una o zero volte i membri distinti della serie di Fibonacci.

Ricorda che i primi sei numeri di Fibonacci distinti sono: 1, 2, 3, 5, 8, 13.

Il numero decimale 11 (undici) può essere scritto come 0*13 + 1*8 + 0*5 + 1*3 + 0*2 + 0*1 o 010100 in notazione posizionale dove le colonne rappresentano la moltiplicazione per un particolare membro della sequenza. Gli zeri iniziali vengono eliminati in modo che 11 decimale diventi 10100.

Tuttavia, 10100 non è l'unico modo per ricavare 11 dai numeri di Fibonacci: anche 0*13 + 1*8 + 0*5 + 0*3 + 1*2 + 1*1 o 010011 rappresenta anche il decimale 11. Comunque per un vero numero Zeckendorf c'è la restrizione aggiuntiva che non possono essere usati due numeri di Fibonacci consecutivi, quindi l'ultima rappresentazione di 11 non è un numero di Zeckendorf.

Scrivere una funzione che converte un generico numero intero nel corrispondente numero di Zeckendorf.

(define (fib num)
  (if (< num 2)
      num
      (add (fib (- num 1)) (fib (- num 2)))))

(define (zeckendorf num)
  (local (fibNums fibPos curFibNum temp out)
    (setq out "")
    (setq fibNums '())
    (setq fibPos 2)
    (setq curFibNum (fib fibPos))
    (do-while (<= curFibNum num)
      (push curFibNum fibNums)
      (++ fibPos)
      (setq curFibNum (fib fibPos))
    )
    (setq temp num)
    (dolist (el fibNums)
      (if (<= el temp)
        (begin
          (push "1" out -1)
          (setq temp (- temp el))
        )
        (push "0" out -1)
      )
    )
    out))

(zeckendorf 10)
;-> "10010"

(for (i 1 10)
  (println i {: } (zeckendorf i))
)
;-> 1: 1
;-> 2: 10
;-> 3: 100
;-> 4: 101
;-> 5: 1000
;-> 6: 1001
;-> 7: 1010
;-> 8: 10000
;-> 9: 10001
;-> 10: 10010

Scriviamo anche una funzione che effettua l'operazione inversa, cioè converte una stringa che rappresenta un numero di Zuckendorf nel corrispondente numero decimale:

(define (zeck-decimal zeck)
  (local (num)
    (setq num 0)
    (dolist (b (explode (reverse zeck)))
      (if (= b "1")
          (setq num (+ (fib (+ $idx 2)) num))))
    num))

(zeckendorf 10)
;-> "10010"
(zeck-decimal "10010")
;-> 10
(zeckendorf 100)
;-> "1000010100"
(zeck-decimal "1000010100")
;-> 100

(zeckendorf (zeck-decimal "10101010"))
;-> "10101010"
(zeck-decimal (zeckendorf 54))
;-> 54


-----------------------------
VECCHIE UNITÀ DI MISURA RUSSE
-----------------------------

Scrivere un programma per convertire le vecchie misure di lunghezza russe nel sistema metrico (e viceversa).


(setq unit-name '("kilometer" "meter" "centimeter"
                  "tochka" "liniya" "diuym" "vershok" "piad"
                  "fut" "arshin" "sazhen" "versta" "milia"))

(setq unit-value '(1000.0 1.0 0.01
                   0.000254 0.00254 0.0254 0.04445 0.1778
                   0.3048 0.7112 2.1336 1066.8 7467.6))

(define (russian-unit val unit)
  (local (idx scala)
    (setq idx (find unit unit-name))
    (setq scala (mul val (unit-value idx)))
    (println val " " unit " is:")
    (dolist (el unit-name)
      (cond ((!= el unit)
            (println (format "%.6f %s" (div scala (unit-value $idx)) el)))
      )
    )))

(russian-unit 1 "meter")
;-> 1 meter is:
;-> 0.001000 kilometer
;-> 100.000000 centimeter
;-> 3937.007874 tochka
;-> 393.700787 liniya
;-> 39.370079 diuym
;-> 22.497188 vershok
;-> 5.624297 piad
;-> 3.280840 fut
;-> 1.406074 arshin
;-> 0.468691 sazhen
;-> 0.000937 versta
;-> 0.000134 milia

(russian-unit 20 "piad")
;-> 20 piad is:
;-> 0.003556 kilometer
;-> 3.556000 meter
;-> 355.600000 centimeter
;-> 14000.000000 tochka
;-> 1400.000000 liniya
;-> 140.000000 diuym
;-> 80.000000 vershok
;-> 11.666667 fut
;-> 5.000000 arshin
;-> 1.666667 sazhen
;-> 0.003333 versta
;-> 0.000476 milia

=============================================================================

================

 PROJECT EULERO

================

                                Intel i5     Intel i7     Intel i7
  Problema    Soluzione         Tempo (msec) Tempo (msec) Tempo (msec)
                                Algorithm 1  Algorithm 1  Algorithm 2
|    1     |  233168            |         0  |         0  |         0  |
|    2     |  4613732           |         0  |         0  |         0  |
|    3     |  6857              |         0  |         0  |         0  |
|    4     |  906609            |       297  |       203  |         0  |
|    5     |  232792560         |         0  |         0  |         0  |
|    6     |  25164150          |         0  |         0  |         0  |
|    7     |  104743            |        78  |        31  |        16  |
|    8     |  23514624000       |       110  |        62  |         0  |
|    9     |  31875000          |        62  |        31  |         0  |
|    10    |  142913828922      |      1563  |      1078  |       546  |
|    11    |  70600674          |         0  |         0  |         3  |
|    12    |  76576500          |      5445  |      4022  |         0  |
|    13    |  5537376230        |         0  |         0  |         -  |
|    14    |  837799            |     22487  |     15408  |      7563  |
|    15    |  137846528820      |         0  |         0  |         0  |
|    16    |  1366              |         0  |         0  |        32  |
|    17    |  21124             |         0  |         0  |         -  |
|    18    |  1074              |        32  |         7  |         0  |
|    19    |  171               |         3  |         1  |         1  |
|    20    |  648               |         0  |         0  |         -  |
|    21    |  31626             |       220  |       134  |        87  |
|    22    |  871198282         |        20  |        10  |         -  |
|    23    |  4179871           |     40900  |     27534  |         -  |
|    24    |  2783915460        |     25309  |     12282  |         -  |
|    25    |  4782              |      4926  |      3469  |         -  |
|    26    |  983               |       488  |       266  |         -  |
|    27    |  -59231            |      2000  |      1532  |         -  |
|    28    |  669171001         |         0  |         0  |         -  |
|    29    |  9183              |       141  |        94  |         -  |
|    30    |  443839            |       516  |       344  |         -  |
|    31    |  73682             |         1  |         0  |         -  |
|    32    |  45228             |      1625  |      1079  |         -  |
|    33    |  100               |         0  |         0  |         -  |
|    34    |  40730             |      3797  |      2625  |         -  |
|    35    |  55                |      1267  |       902  |         -  |
|    36    |  872187            |      1443  |       945  |         -  |
|    37    |  748317            |       778  |       651  |         -  |
|    38    |  932718654         |        94  |        48  |         -  |
|    39    |  840               |     13486  |      9561  |         -  |
|    40    |  210               |       141  |       433  |         -  |
|    41    |  7652413           |       125  |        64  |         -  |
|    42    |  162               |        31  |         4  |         -  |
|    43    |  16695334890       |      1749  |      1321  |         -  |
|    44    |  5482660           |      5589  |      4182  |         -  |
|    45    |  1533776805        |       115  |        63  |         -  |
|    46    |  5777              |        31  |         5  |         -  |
|    47    |  134043            |         0  |         0  |         -  |
|    48    |  9110846700        |       266  |       186  |         -  |
|    49    |  296962999629      |        19  |         5  |         -  |
|    50    |  997651            |     27113  |     18871  |         -  |
|    51    |  121313            |       269  |       180  |         -  |
|    52    |  142857            |       313  |       204  |         -  |
|    53    |  4075              |        25  |         5  |         -  |
|    54    |  376               |       154  |        91  |         -  |
|    55    |  249               |       116  |        69  |         -  |
|    56    |  972               |       186  |       119  |         -  |
|    57    |  153               |        10  |         1  |         -  |
|    58    |  26241             |       630  |       432  |         -  |
|    59    |  129448 / 107359   |        15  |         1  |         -  |
|    60    |  26033             |     55055  |     38926  |         -  |
|    61    |  28684             |         -  |        85  |         -  |
|    62    |  127035954683      |         -  |      6348  |        83  |
|    63    |  49                |         -  |         0  |         0  |
|    64    |  1322              |         -  |        81  |         -  |
|    65    |  272               |         -  |         0  |         -  |
|    66    |  661               |         -  |         0  |         -  |
|    67    |  7273              |         -  |         1  |         -  |
|    68    |  6531031914842725  |         -  |        21  |         -  |
|    69    |  510510            |         -  |       642  |         -  |
|    70    |  8319823           |         -  |      9621  |         7  |
|    71    |  428570            |         -  |       191  |         -  |
|    72    |  303963552391      |         -  |      2060  |         -  |
|    73    |  7295372           |         -  |      1809  |      2345  |
|    74    |  402               |         -  |    286059  |         -  |
|    75    |  161667            |         -  |       822  |         -  |
|    76    |  190569291         |         -  |         0  |         -  |
|    77    |  71                |         -  |         4  |         -  |
|    78    |  55374             |         -  |      7918  |         -  |
|    79    |  73162890          |         -  |         0  |         -  |
|    80    |  40886             |         -  |        29  |         -  |
|    81    |  427337            |         -  |         3  |         -  |
|    82    |  260324            |         -  |         5  |         -  |
|    83    |  425185            |         -  |      6503  |         -  |
|    84    |  101524            |         -  |        66  |         -  |
|    85    |  2772              |         -  |         2  |         -  |
|    86    |  1818              |         -  |    233564  |       528  |
|    87    |  1097343           |         -  |      1153  |         -  |
|    88    |  7587457           |         -  |     24771  |       377  |
|    89    |  743               |         -  |         0  |         -  |
|    90    |  1217              |         -  |        31  |         -  |
|    91    |  14234             |         -  |      7259  |         1  |
|    92    |  8581146           |         -  |     51582  |        16  |
|    93    |  1258              |         -  |       389  |         -  |
|    94    |  518408346         |         -  |     28946  |         0  |
|    95    |  14316             |         -  |      1846  |         -  |
|    96    |  24702             |         -  |     27084  |         -  |
|    97    |  8739992577        |         -  |       497  |         -  |
|    98    |  18769             |         -  |       136  |         -  |
|    99    |  709               |         -  |         0  |         -  |
|   100    |  756872327473      |         -  |         0  |         -  |
|   101    |  37076114526       |         -  |        70  |         -  |
|   102    |  228               |         -  |         2  |         0  |

Sito web: https://projecteuler.net/archives

Cos'è Project Euler?
Project Euler è una serie di stimolanti problemi di programmazione matematica/informatica che richiedono molto più di semplici approfondimenti matematici per essere risolti. Sebbene la matematica aiuti ad arrivare a metodi eleganti ed efficienti, per risolvere la maggior parte dei problemi sarà necessario l'uso di un computer e competenze di programmazione.

La motivazione per l'avvio di Project Euler, e la sua continuazione, è di fornire una piattaforma per la mente indagatrice per addentrarsi in aree non familiari e apprendere nuovi concetti in un contesto divertente e ricreativo.

A chi sono rivolti i problemi?
Il pubblico previsto comprende studenti per i quali il curriculum di base non alimenta la loro fame per imparare, adulti il ​​cui background non era principalmente la matematica ma aveva un interesse per le cose matematiche, e professionisti che vogliono mantenere le loro capacità di solving e la matematica all'avanguardia.

Chiunque può risolvere i problemi?
I problemi sono di diversa difficoltà e per molti l'esperienza è l'apprendimento a catena induttivo. Cioè, risolvendo un problema ti esporrà ad un nuovo concetto che ti permette di intraprendere un problema precedentemente inaccessibile. Quindi il partecipante determinato lentamente ma sicuramente farà il suo lavoro attraverso ogni problema.

Cosa fare in seguito?
Per tenere traccia dei tuoi progressi è necessario impostare un account e abilitare i cookie. Se hai già un account puoi accedere senza problemi, altrimenti devi registrati - è completamente gratuito!

Tuttavia, poiché alcuni problemi sono difficili, potresti voler visualizzare i problemi prima di registrarti.

"Il progetto Eulero esiste per incoraggiare, sfidare e sviluppare le capacità e il divertimento di chiunque abbia un interesse per l'affascinante mondo della matematica."

Nota: i problemi devono essere risolti con la "regola del minuto", cioè i programmi devono trovare la soluzione entro un minuto.

In questo paragrafo affronteremo e risolveremo alcuni di questi problemi. Comunque prima di vedere la soluzione dovresti provare a risolverli per conto proprio in modo da migliorare le tue capacità di problem-solver e di programmatore.

Nota: La maggior parte delle soluzioni contiene una spiegazione dell'algoritmo utilizzato e alcuni problemi sono risolti con due algoritmi diversi. In genere il secondo algoritmo ha un approccio più matematico ed è più veloce.

Nota: La soluzione della maggior parte dei problemi comporta (almeno per me) la ricerca di informazioni su internet di argomenti diversi (matematica, algoritmi, problem solving, ecc.).

Vengono prima presentate alcune funzioni che servono per la soluzione di diversi problemi.

;=============================================
; (isprime? n)
; Controlla se n è un numero primo
; Non funziona con i big integer
; numero massimo (int64): 9223372036854775807
;=============================================
(define (isprime? n)
   (if (< n 2) nil
       (= 1 (length (factor n)))))
;=============================================

;=============================================
; (factor-group n)
; fattorizza il numero x raggruppando i termini uguali
; Non funziona con i big integer
; numero massimo (int64): 9223372036854775807
;=============================================
(define (factor-group x)
  (if (= x 1) '(1 1)
    (letn (fattori (factor x)
          unici (unique fattori))
      (transpose (list unici (count unici fattori)))
    )
  )
)

(factor-group 1)
;-> (1 1)

(factor-group 2000)
;-> ((2 4) (5 3))

(factor-group 232792560)
;-> ((2 4) (3 2) (5 1) (7 1) (11 1) (13 1) (17 1) (19 1))

E la funzione inversa a factor-group che genera il numero partendo dalla fattorizzazione:

(define (inv-factor-group lst)
      (apply * (map (lambda (x) (pow (first x) (last x))) lst))
)

(inv-factor-group (factor-group 232792560))
;-> 232792560
----------------------------------------------------------------------------

==========
Problema 1
==========

Multipli di 3 e di 5

Se elenchiamo i numeri sotto a 10 che sono multipli di 3 o di 5, otteniamo 3, 5, 6 e 9.
La loro somma vale 23.

Trova la somma di tutti i multipli di 3 o di 5 sotto a 1000.
============================================================================

La funzione "sequence" genera una lista di numeri:

(sequence 1 10)
;-> (1 2 3 4 5 6 7 8 9 10)

(sequence 1 10 2)
;-> (1 3 5 7 9)

Possiamo anche scrivere una funzione che si comporta come "sequence":

(define (seq start end (step 1))
  (cond ((= start end) (list end))
        ((> start end) '())
        (true (cons start (seq (+ start step) end step)))
  )
)

(seq 1 10)
;-> (1 2 3 4 5 6 7 8 9 10)

(seq 1 10 2)
;-> (1 3 5 7 9)

Un numero n è divisibile esattamente per m se risulta (n mod m == 0),
cioè il resto della divisione tra n e m vale zero.
In newLISP "%" è la funzione mod per i numeri interi.

(zero? (% 10 2))
;-> true
(zero? (% 130 11))
;-> nil

La funzione "filter" seleziona tutti i valori che soddisfano un predicato:
(filter (fn(x) (> x 5)) '(6 4 5 2 6 7 3 4 8 9))
;-> (6 6 7 8 9)

La funzione "apply" applica una funzione utilizzando tutti gli argomenti:
(apply + '(1 3 5))
;-> 9

Adesso possiamo scrivere la funzione:

(define (e001)
  (apply + (filter (fn(x) (or (zero? (% x 3)) (zero? (% x 5)))) (sequence 1 999)))
)

(e001)
;-> 233168

(time (e001))
;-> 0

(time (e001) 10000)
;-> 2453.466

Soluzione alternativa:

generiamo due sequenze (una con i multipli di 3 e l'altra con i multipli di 5)
(setq a (sequence 3 20 3))
;-> (3 6 9 12 15 18)
(setq b (sequence 5 20 5))
;-> (5 10 15 20)

uniamo le sequenze (la funzione union mantiene solo valori unici)
(setq c (union a b))
;-> (3 6 9 12 15 18 5 10 20)

infine sommiamo tutti i numeri:
(apply + c)
;-> 18

Ed ecco la funzione:

(define (e001)
    (apply + (union (sequence 3 999 3) (sequence 5 999 5)))
)

(e001)
;-> 233168

(time (e001))
;-> 0

(time (e001) 10000)
;-> 796.682

Dal punto di vista matematico possiamo notare che:

Sum[1..n] (i) = (1/2)*n*(n + 1) (Formula di Gauss)

Se vogliamo sapere quanti numeri sono divisibili per 3 possiamo scrivere:

D(n 3) = 3 * Sum[1 (floor n/3)] (i) = 3*(1/2)*(floor n/3)*((floor n/3) + 1)

Perchè contiamo fino a (floor n/3)? Applichiamo la formula:

(3) * (1 + 2 + 3 + ... 999) ==> (3 6 9 12 ... 2997)

Quanti sono i divisori di 3 fino a 999:

(for (i 1 999) (if (zero? (% i 3)) (++ d))) d
;-> 333

Quindi:

(floor (div 999 3))
;-> 333

E per un generico valore k (invece di 3):

D(n k) = k*Sum[1 (floor n/k)] (i) = k*(1/2)*(floor n/k)*((floor n/k) + 1)

Adesso sommiamo i divisori di 3 e i divisori di 5 e sottraiamo i divisori 15 (perchè (lcm 5 3 = 15)):

sol = D(999 3) + D(999 5) - D(999 15)

(define (e001-2 n)
  (local (a b c)
    (setq a (floor (div n 3)))
    (setq b (floor (div n 5)))
    (setq c (floor (div n 15)))
    (div (- (+ (* 3 a (+ a 1)) (* 5 b (+ b 1))) (* 15 c (+ c 1))) 2)))

(e001-2 999)
;-> 233168

(time (e001-2 999))
;-> 0

(time (e001-2 999) 10000)
;-> 15.586

Il tempo di questa funzione non dipende da n (diversamente dalle prime due funzioni).

(time (e001-2 10000) 10000)
;-> 15.587
----------------------------------------------------------------------------


==========
Problema 2
==========

I numeri di Fibonacci pari

Ciascun nuovo termine della sequenza di Fibonacci viene generato addizionando i due termini precedenti.
Partendo da 1 e 2, i primi 10 termini valgono:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

Considerando i termini della sequenza di Fibonacci i cui valori non superano quattro milioni, trovare la somma dei termini pari.
============================================================================

Questa è la funzione per il calcolo dei numeri di fibonacci:

(define (fibonacci n)
  (let (L '(0 1))
    (dotimes (i n)
      (setq L (list (L 1) (apply + L)))
    )
    ;(L 1)
    (last L)
  )
)

Il numero 32 è quello che genera l'ultimo valore utile (minore di 4.000.000):

(fibonacci 32)
;-> 3524578

(fibonacci 33)
;-> 5702887

Modifichiamo l'espressione "dotimes" con "while" per controllare il valore ottenuto.
Inoltre aggiorniamo il valore del risultato (res) quando il numero calcolato è dispari.

(define (e002)
  (let (L '(0 1) res 0)
    ;(dotimes (i n)
    (while (< (last L) 4000000)
      (setq L (list (L 1) (apply add L)))
      (if (even? (last L)) (inc res (last L)))
    )
    ;(last L)
    res
  )
)

(e002)
;-> 4613732

(time (e002))
;-> 0

(time (e002) 100000)
;-> 671.918

Soluzione alternativa:

(define (e002)
  (let (a 2 b 1 ans 0)
    (until (> b 4000000)
      (if (even? a)
        (inc ans a))
      (inc b a)
      (swap a b))
     ans))

(e002)
;-> 4613732

(time (e002))
;-> 0

(time (e002) 100000)
;-> 343.627

Dal punto di vista matematico:

Formula di Binet (relazione tra i numeri di fibonacci e il rapporto aureo):

Fib(n) = (phi^n - psi^n)/sqrt(5)

dove: phi = (1 + sqrt(5))/2 e psi = (1 - sqrt(5))/2

Invertendo la formula troviamo l'indice n per il numero di fibonacci Fib(n) dato:

n = floor (log[phi](F*sqrt(5) + (1/2)))

Inoltre utilizziamo la seguente identità (la somma dei primi n numeri di fibonacci vale (F(n+2) - 1):

Sum[0 n] F(i) = F(n+2) - 1

Usiamo queste formule per scrivere la funzione:

(define (setval)
  (setq sr (sqrt 5))
  (setq phi (div (add 1 sr) 2))
  (setq psi (div (sub 1 sr) 2)))

(define (f n) (div (sub (pow phi n) (pow psi n)) sr))
(define (idx fib) (floor (div (log (add (mul fib sr) 0.5)) (log phi))))
(define (sumfib n) (sub (f (+ n 2)) 1))

(define (e002-2 n)
    (setval)
    (round (div (sumfib (idx n)) 2)))

(e002-2 3999999)
;-> 4613732

(time (e002-2 3999999))
;-> 0

(time (e002-2 3999999) 100000)
;-> 78.098

Il tempo di questa funzione non dipende da n (diversamente dalle prime due funzioni).

(time (e002-2 9999999) 100000)
;-> 78.096
----------------------------------------------------------------------------


==========
Problema 3
==========

Il più grande fattore primo

I fattori primi di 13195 sono 5, 7, 13 e 29.

Qual'è il fattore primo più grande del numero 600851475143 ?
============================================================================

La funzione "factor" di newLISP restituisce tutti i fattori di un numero:

(factor 600851475143)
;-> (71 839 1471 6857)

Non resta che trovare il valore massimo:

(apply max (factor 600851475143))
;-> 6857

Definiamo la funzione:

(define (e003)
  (apply max (factor 600851475143))
)

(e003)
;-> 6857

(time (e003))
;-> 0

(time (e003) 100000)
;-> 496.8

Se vogliamo implementare la fattorizzazione, possiamo scrivere:

(define (e003-2 n)
  (let (i 2)
    (while (<= (* i i) n)
      (while (= (% n i) 0)
        (setq n (/ n i))
      )
      (++ i)
    )
    n))

(e003-2 600851475143)
;-> 6857

(time (e003-2 600851475143))
;-> 0

(time (e003-2 600851475143) 100000)
;-> 18174.285
----------------------------------------------------------------------------


==========
Problema 4
==========

Il più grande prodotto palindromo

Un numero palindromo ha lo stesso valore leggendo da sinistra a destra o da destra a sinistra.
Il più grande numero palindromo ottenuto dal prodotto di due numeri da due cifre vale 9009 = 91 * 99.

Trova il più grande numero palindromo ottenuto dal prodotto di due numeri da tre cifre.
============================================================================

(define (e004)
    (let (out 0  val 0)
        (for (i 100 999)
          (for (j i 999)
            (setq val (string (* i j)))
            (when (= val (reverse (copy val)))
                (setq out (max out (int val)))
            )
          )
        )
 out)
)

(e004)
;-> 906609

(time (e004))
;-> 204.069

(time (e004) 100)
;-> 19220.569

Dal punto di vista matematico:

La prima osservazione è che il numero deve essere compreso tra 100^2 e 999^2 o nell'intervallo (10000, 998001). 1]. Poiché la maggior parte dei numeri ha 6 cifre e stiamo cercando il più grande, ignoriamo i numeri a 5 cifre. Sulla base di questo, possiamo costruire un numero palindromo come:

'abccba' = 100000a + 10000b + 1000c + 100c + 10b + a
         = 100001a + 10010b + 1100c
         11*(9091a + 910b + 100c)

Pertanto, stiamo cercando i due numeri più grandi p, q:

p*q = 11*(9091a + 910b + 100c) ≤ 999^2

Questa equazione ci mostra che p o q, ma non entrambi, devono avere un fattore 11. Per massimizzare le due incognite, iniziamo la ricerca con p = 9 e per ogni p decrescente cerchiamo un massimo q per costruire un palindromo. Possiamo fare un'ottimizzazione basata sull'osservazione precedente: se p non è divisibile per 11, q lo deve essere, e come tale possiamo iniziare la ricerca con 990 come maggior multiplo di 11 e cercare solo multipli di 11. Un'altra ottimizzazione è, che non abbiamo bisogno di lasciare che q vadaal di sotto di p poiché possiamo scambiare i numeri. Vediamo un'implementazione:

(define (palindromo? num)
  (let (str (string num))
    (= str (reverse (copy str)))))

(define (e004-2)
  (local (r s t q p found)
    (setq r 0)
    (setq p 999)
    (while (>= p 100)
      (if (zero? (% p 11))
          (setq q 999 s 1)
          (setq q 990 s 11)
      )
      (setq found nil)
      (while (and (> q 99) (not found))
        (setq t (* p q))
        (if (and (< r t) (palindromo? t))
            (setq r t found true)
            ;(begin (println p { } q { } t) (setq r t found true))
        )
        (setq q (- q s))
      )
      (-- p)
    )
    r))

(e004-2)
;-> 906609

993 * 913 = 906609

(time (e004-2))
31.237

(time (e004-2) 100)
;-> 2187.681

Questa funzione è circe 10 volte più veloce della prima funzione.

Possiamo migliorare la funzione invertendo di nuovo p e q. In questo modo possiamo usare un ciclo con p da 990 attraverso i multipli di 11 e usare q per trovare un palindromo.

(define (e004-2)
  (local (r t q p found)
    (setq r 0)
    (for (p 990 100 -11)
      (setq found nil)
      (for (q 999 100 -1 found)
        (setq t (* p q))
        (if (and (< r t) (palindromo? t))
            (setq r t found true)
            (if (< t r) (setq found true))
        )
      )
    )
    r))

(e004-2)
;-> 906609

(time (e004-2))
;-> 0

(time (e004-2) 100)
;-> 109.373

Quest'ultima funzione è 20 volte più veloce della precedente (seconda) funzione.
(div 2187.681 109.373)
;-> 20.002

Quest'ultima funzione è 175 volte più veloce della prima funzione.
(div 19220.569 109.373)
;-> 175.734
----------------------------------------------------------------------------


==========
Problema 5
==========

Il multiplo minore

2520 è il più piccolo numero che può essere diviso esattamente (senza resto) da tutti i numeri da 1 a 10.

Qual'è il più piccolo numero positivo che è divisibile esattamente per tutti i numeri da 1 a 20 ?
============================================================================

La soluzione non vale 1*2*3*4*5*6*7*8*9*10*11*12*13*14*15*16*17*18*19*20 perchè, per esempio, quando il numero cercato è divisibile per 3 e per 5 è anche divisibile per 15.

La soluzione consiste nel trovare tutti i numeri che sono fattori unici con gli esponenti massimi e moltiplicarli tra loro.

Proviamo con il numero 10:

Troviamo tutte scomposizioni in fattori:

2  -> (2)
3  -> (3)
4  -> (2 2)
5  -> (5)
6  -> (2 3)
7  -> (7)
8  -> (2 2 2)
9  -> (3 3)
10 -> (2 5)

I fattori unici sono: 2, 3, 5, e 7.

Questi hanno esponenete massimo rispettivamente: 3 2 1 1.

Quindi i numeri da moltiplicare sono: 2^3, 3^2, 5^1 e 7^1.

Otteniamo: 8 * 9 * 5 * 7 = 2520.

; lista con le fattorizzazioni dei numeri da 2 a 10
(setq a (map factor (sequence 2 10)))
;-> ((2) (3) (2 2) (5) (2 3) (7) (2 2 2) (3 3) (2 5))

; lista con tutti i numeri dei fattori
(setq b (flat (map factor (sequence 2 10))))
;-> (2 3 2 2 5 2 3 7 2 2 2 3 3 2 5)

; lista con tutti i numeri dei fattori presi una sola volta
(setq c (unique (flat (map factor (sequence 2 10)))))
;-> (2 3 5 7)

Adesso dobbiamo trovare gli esponenti massimi di 2,3,5 e 7 nella lista con le fattorizzazioni dei numeri da 2 a 10.

Vediamo prima come funziona funzione "count":

(setq a '((1 2) (5 5) (2 3)))
(setq c '(2 3 5))

Vogliamo trovare quante volte gli elementi di c compaiono in a:

(map (curry count c) a)
;-> ((1 0 0) (0 0 2) (1 1 0)

cosa significa il risultato?

(1 0 0) -> conto il 2 una  volta su (1 2)
        -> conto il 3 zero volte su (1 2)
        -> conto il 5 zero volte su (1 2)

(0 0 2) -> conto il 2 zero volte su (5 5)
        -> conto il 3 zero volte su (5 5)
        -> conto il 5 due  volte su (5 5)

(1 1 0) -> conto il 2 una  volta su (2 3)
        -> conto il 3 una  volta su (2 3)
        -> conto il 5 zero volte su (2 3)

Se trasponiamo la lista:

(transpose(map (curry count c) a))
;-> ((1 0 1) (0 0 1) (0 2 0))

Che significa:

(1 0 1) -> conto il 2 una  volta su (1 2)
        -> conto il 2 zero volte su (5 5)
        -> conto il 2 una  volta su (2 3)
(0 0 1) -> conto il 3 zero volte su (1 2)
        -> conto il 3 zero volte su (5 5)
        -> conto il 3 una  volta su (2 3)
(0 2 0) -> conto il 5 zero volte su (1 2)
        -> conto il 5 due  volte su (5 5)
        -> conto il 5 zero volte su (2 3)

Nel nostro caso:

; lista con le fattorizzazioni dei numeri da 2 a 10
(setq a (map factor (sequence 2 10)))
;-> ((2) (3) (2 2) (5) (2 3) (7) (2 2 2) (3 3) (2 5))

; lista con tutti i numeri dei fattori
(setq b (flat (map factor (sequence 2 10))))
;-> (2 3 2 2 5 2 3 7 2 2 2 3 3 2 5)

; lista con tutti i numeri dei fattori presi una sola volta
(setq c (unique (flat (map factor (sequence 2 10)))))
;-> (2 3 5 7)

Adesso troviamo quante volte gli elementi di c compaiono in a:

(setq d (transpose(map (curry count c) a)))
;-> ((1 0 2 0 1 0 3 0 1) (0 1 0 0 1 0 0 2 0) (0 0 0 1 0 0 0 0 1) (0 0 0 0 0 1 0 0 0))

Adesso dobbiamo trovare il valore massimo di ogni sottolista (che sono gli esponenti massimi rispettivamente di 2,3,5 e 7).

(setq e (map (curry apply max)
            (transpose(map (curry count c) a))))
;-> (3 2 1 1)

Per capire meglio come funziona l'ultima espressione vediamo un esempio.

Se vogliamo applicare la funzione "sin" ad una lista di valori possiamo usare la funzione "map":

(map sin '(10 20 30))
;-> (-0.5440211108893698 0.9129452507276277 -0.9880316240928618)

Ma se i valori sono in sottoliste questo non funziona:

(map sin '((10) (20) (30)))
;-> ERR: value expected in function sin : '(10)

La soluzione si ottiene utilizzando la funzione "curry" e "apply":

(map (curry apply sin) '((10) (20) (30)))
;-> (-0.5440211108893698 0.9129452507276277 -0.9880316240928618)

Oppure in modo equivalente:

(map (lambda (x) (apply sin x)) '((10) (20) (30)))

"curry" transforma una funzione f(x, y) che prende due argomenti in una funzione fx(y) che prende un singolo argomento.
In questo modo "curry" dice ad "apply" di applicare la funzione "sin" solo alla sottolista.

Tornando al problema abbiamo:

; lista con tutti i numeri dei fattori presi una sola volta
(setq c (unique (flat (map factor (sequence 2 10)))))
;-> (2 3 5 7)

; lista con gli esponenti massimi rispettivamente di 2,3,5 e 7).
(setq e (map (curry apply max)
            (transpose(map (curry count c) a))))
;-> (3 2 1 1)

Adesso calcoliamo i numeri con la funzione "pow" e li moltiplichiamo tra loro:

(apply * (map pow c e))
;-> 2520

Scriviamo la funzione finale:

(define (e005)
  (setq a (map factor (sequence 2 20)))
  (setq b (flat a))
  (setq c (unique b))
  (setq e (map (curry apply max)
               (transpose(map (curry count c) a))))
  (apply * (map pow c e))
)

(e005)
;-> 232792560

(time (e005))
;-> 0

Dal punto di vista matematico, dopo tutti questi ragionamenti per trovare la soluzione notiamo che il problema richiedeva semplicemente di trovare il minimo comune multiplo dei primi venti numeri interi...

Quindi utilizzando la seguente funzione che calcola il Minimo Comune Multiplo di una serie di numeri:

(define-macro (mcm)
  (apply (fn (x y) (/ (* x y) (gcd x y))) (args) 2))

Potevamo calcolare la soluzione con:

(mcm 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20)
;-> 232792560

(define (e005-2) (apply mcm (sequence 2 20)))

(e005-2)
;-> 232792560

(time (e005-2))
;-> 0
----------------------------------------------------------------------------


==========
Problema 6
==========

Somma quadrati differenza

La somma dei quadrati dei primi dieci numeri naturali vale,

1^2 + 2^2 + ... + 10^2 = 385

Il quadrato della somma dei primi dieci numeri naturali vale,

(1 + 2 + ... + 10)^2 = 55^2 = 3025

Quindi la differenza tra la somma dei quadrati e il quadrato della somma dei primi dieci numeri naturali vale 3025 − 385 = 2640.

Trovare la differenza tra la somma dei quadrati e il quadrato della somma dei primi cento numeri naturali.
============================================================================

I primi dieci numeri li otteniamo da:

(setq num (sequence 1 10))
;-> (1 2 3 4 5 6 7 8 9 10)

La loro somma vale:

(setq sum (apply add num))
;-> 55

Il quadrato della somma vale:

(setq qs (* sum sum))
;-> 3025

La somma dei quadrati vale:

(setq sq (apply add (map * num num)))

Nota che:

(setq lst (sequence 1 10))
(map * lst lst)
;-> (1 4 9 16 25 36 49 64 81 100)
(map * lst lst lst)
;-> (1 8 27 64 125 216 343 512 729 1000)

La loro differenza vale:

(sub qs sq)
;-> 2640

Scriviamo la funzione:

(define (e006)
  (setq num (sequence 1 100))
  (setq sum (apply add num))
  (setq qs (* sum sum))
  (setq sq (apply add (map * num num)))
  (sub qs sq)
)

(e006)
;-> 25164150

(time (e006))
;-> 0

(time (e006) 100000)
;-> 640.678

Soluzione alternativa:

(define (e006)
    (let (lst (sequence 1 100))
        (- (pow (apply + lst)) (apply + (map * lst lst))) )
)

(e006)
;-> 25164150

(time (e006))
;-> 0

(time (e006) 100000)
;-> 640.467

Dal punto di vista matematico abbiamo:

Somma dei Quadrati

f(n) = Sum[1..n] i^2 = (1/6)*n*(n - 1)*(2*n - 1)

Quadrato della Somma

g(n) = (Sum[1..n] i)^2 = (1/4)*n^2*(n + 1)^2

La loro differenza:

g(n) - f(n) = (1/12)*n*(n + 1)*(3*n^2 - n - 2)

Possiamo scrivere la funzione:

(define (e006-2 n)
  (/ (* n (+ n 1) (sub (* 3 (pow n)) n 2)) 12))

(e006-2 100)
;-> 25164150

(time (e006-2 100))
;-> 0

(time (e006-2 100) 100000)
;-> 31.237

Il tempo di questa funzione non dipende da n (diversamente dalle prime due funzioni).

(time (e006-2 10000) 100000)
;-> 31.235
----------------------------------------------------------------------------


==========
Problema 7
==========

Il 10001-esimo numero primo

Elencando i primi sei numeri primi: 2, 3, 5, 7, 11, e 13, si nota che il sesto primo è 13.

Qual'è il 10001-esimo numero primo?
============================================================================

La soluzione con la forza bruta è semplice, cerchiamo progressivamente tutti i numeri primi partendo dal primo fino ad arrivare al 10001 numero primo:

(define (e007)
  (setq cnt 1 n 3) ; partiamo da 3 (il numero 2 è primo)
  (while (!= 10001 cnt)
      (if (isprime? n) (setq cnt (+ cnt 1))) ; se è un numero primo incrementiamo il conto
      (setq n (+ n 2)) ; non consideriamo i numeri pari
  )
  (- n 2)
)

(e007)
;-> 104743

(time (e007))
;-> 31.235

(time (e007) 100)
;-> 2625.219

Dal punto di vista matematico possiamo sfruttare il fatto che tutti i numeri primi (tranne il 2 e il 3) sono nella forma (6*k ± 1):

(define (e007-2 n)
  (local (conta i)
    (setq conta 2 i 0)
    (while (< conta n)
      (++ i 6)
      (if (isprime? (+ i 1)) (++ conta))
      (if (isprime? (- i 1)) (++ conta))
    )
    ; l'aggiungo l'ultimo primo che è nella forma 6*k + 1
    (+ i 1)))

(e007-2 10001)
;-> 104743

(time (e007-2 10001))
;-> 15.587

(time (e007-2 10001) 100)
;-> 1875.206
----------------------------------------------------------------------------


==========
Problema 8
==========

Il maggior prodotto in una serie

Le quattro cifre adiacenti che hanno il più grande prodotto nel numero da 1000 cifre riportato di seguito sono 9 × 9 × 8 × 9 = 5832.

73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450

Trovare, nel numero da 1000 cifre, le tredici cifre adiacenti che hanno il prodotto più grande. Qual'è il valore di questo numero ?
============================================================================

Assegniamo il numero ad una variabile di tipo stringa:

(setq x
"7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450")

(length x)
;-> 1000

Possiamo anche assegnare la variabile in un altro modo:

; elimina gli spazi (line-feeds)
(setq x (replace "\\s+" [text]
73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450
[/text] "" 0))

(length x)
;-> 1000

Dividiamo la stringa in blocchi da 13 caratteri (con passo 1 da 0 a 987):

(slice (explode x) 0 5) ; 5 al posto di 13
;-> ("7" "3" "1" "6" "7")

(setq a (map (fn (i) (slice (explode x) i 5))
             (sequence 0 4))) ; 4 al posto di 987

;-> (("7" "3" "1" "6" "7")
;->  ("3" "1" "6" "7" "1")
;->  ("1" "6" "7" "1" "7")
;->  ("6" "7" "1" "7" "6")
;->  ("7" "1" "7" "6" "5"))

(setq b (map join a))
;-> ("73167" "31671" "16717" "67176" "71765")

Mettiamo tutto insieme:

(setq c (map join (map (fn (i) (slice (explode x) i 5))
                       (sequence 0 4))))

;-> ("73167" "31671" "16717" "67176" "71765")

Convertiamo ogni carattere del blocco in integer:

(map explode c)
;-> (("7" "3" "1" "6" "7")
;->  ("3" "1" "6" "7" "1")
;->  ("1" "6" "7" "1" "7")
;->  ("6" "7" "1" "7" "6")
;->  ("7" "1" "7" "6" "5"))

(setq d (map (fn (i) (map int i)) (map explode c)))
;-> ((7 3 1 6 7) (3 1 6 7 1) (1 6 7 1 7) (6 7 1 7 6) (7 1 7 6 5))

Adesso moltiplichiamo tra loro i numeri in ogni sottolista:

(setq e (map (fn (i) (apply * i)) d))
;-> (882 126 294 1764 1470)

Infine troviamo il valore massimo delle moltiplicazioni:

(apply max e)
;-> 1764

Possiamo scrivere la funzione:

(setq x
"7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450")

(define (e008)
  ;(setq a (map join (map (fn (i) (slice (explode x) i 4)) ; for test: 5832
  ;                       (sequence 0 996))))
  (setq a (map join (map (fn (i) (slice (explode x) i 13)); for final result
                         (sequence 0 987))))
  (setq b (map (fn (i) (map int i)) (map explode a)))
  (setq c (map (fn (i) (apply * i)) b))
  (setq _res (apply max c))
  ;(println (nth (ref _res c) b)) ;-> (5 5 7 6 6 8 9 6 6 4 8 9 5)
  ;(println (last b)) ;-> (0 4 2 0 7 5 2 9 6 3 4 5 0)
  _res
)

(e008) ; con il valore 4 di test
;-> 5832

(e008) ; con il valore 13
;-> (5 5 7 6 6 8 9 6 6 4 8 9 5)
;-> 23514624000

(* 5 5 7 6 6 8 9 6 6 4 8 9 5)
;-> 23514624000

(time (e008))
;-> 62.476

(time (e008) 500)
;-> 27315.46

Possiamo scrivere la funzione utilizzando la tecnica "window sliding". La finestra di 13 caratteri simuove lungo la stringa il nuovo valore della moltiplicazione dei 13 caratteri è data dal valore precedente moltiplicato per l'ultimo carattere della nuova finestra e diviso per il primo carattere della finestra precedente. L'unico problema è quando tgroviamo il valore 0 come prima cifra della finestra precedente (non è possibile dividere per zero): questo caso deve essere trattato a parte.

(define (e008-2 str n)
  (local (vet prod maxp pre cur)
    ; trasformo la stringa in un vettore
    (setq vet (array (length str) (map int (explode str))))
    ; il primo prodotto è il prodotto dei primi n numeri
    (setq prod (apply * (slice vet 0 n)))
    (setq maxp prod)
    (for (i n (- (length vet) 1))
      (setq pre (vet (- i n)))
      (setq cur (vet i))
      (if (= pre 0)
          ; se la prima cifra 0, allora calcolo il prodotto esteso
          (setq prod (apply * (slice vet (+ i 1 (- n)) n)))
          ; altrimenti moltiplico e divido
          (setq prod (/ (* prod cur) pre))
      )
      (setq maxp (max prod maxp))
    )
    maxp))

(setq x
"7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450")

(e008-2 x 13)
;-> 23514624000

(time (e008-2 x 13))
;-> 0

(time (e008-2 x 13) 500)
;-> 218.696

Quest'ultima funzione è 125 volte più veloce della prima:

(div 27315.46 218.696)
;-> 124.9015071148992
----------------------------------------------------------------------------


==========
Problema 9
==========

Triple Pitagoriche speciali

Una tripla pitagorica è un insieme di tre numeri naturali, a < b < c, per cui risulta,

a^2 + b^2 = c^2

Per esempio, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.

Esiste solo una tripla pitagorica per cui risulta: a + b + c = 1000.

Trovare il prodotto a*b*c.
============================================================================

(define (e009)
    (catch
      (for (a 1 1000)
        (for (b a 1000)
            (let (c (sqrt (+ (pow a) (pow b))))
                (when (and
                      (= (add a b c) 1000)
                      (< a b c)) ; a < b < c
                    ;(println a { } b { } c)
                    (throw (* a b c))
                 )
             )
         )
      )
    )
)

(e009)
;-> 200 375 425
;-> 31875000

(time (e009))
;-> 31.208

(time (e009) 1000)
;-> 30908.208

Dal punto di vista matematico, poniamo c = n - a - b.

Poichè (a < b < c) e (a + b + c = n), possiamo concludere che:

valore massimo per a: a < (n/3) - 1
valore massimo per b: b < (n/2) - 1

Adesso partendo da (a + b) = (n - c) e (a^2 + b^2 = c^2):

      a^2 + b^2 = c^2
a^2 + b^2 + 2ab = c^2 + 2ab
      (a + b)^2 = c^2 + 2ab
      (n - c)^2 = c^2 + 2ab  ==>  2ab = (n - c)^2 - c^2

Sottraiamo 2ab dalla prima equazione (a^2 + b^2 = c^2):

      a^2 + b^2 = c^2
a^2 + b^2 - 2ab = c^2 - 2ab
(a - b)^2 = c^2 - (n - c)^2 + c^2
(a - b)^2 = c^2 - n^2 - c^2 + 2nc + c^2
(a - b)^2 = c^2 - n^2 + 2nc

Poichè (c^2 - n^2 + 2nc) deve essere un quadrato perfetto, possiamo ignorare a e b e verificare solo se è un quadrato perfetto.

Una possibile implementazione è la seguente:

(define (e009-2 n)
  (local (a b ab sq-ab res found)
    (setq found nil)
    (setq res nil)
    (for (c (floor (+ (/ n 3) 1)) (- (/ n 2) 1) 1 found)
      (setq sq-ab (- (+ (* c c) (* 2 n c)) (* n n)))
      (setq ab (floor (sqrt sq-ab)))
      (if (= (* ab ab) sq-ab)
          (setq b (/ (- n (+ c ab)) 2)
                a (- n b c)
                found true
                res (list (sort (list a b c)) (+ a b c) (* a b c)))
      )
    )
    res))

(e009-2 1000)
;-> ((200 375 425) 1000 31875000)

(time (e009-2 1000))
;-> 0

(time (e009-2 1000) 1000)
;-> 31.208

Quest'ultima funzione è 990 volte più veloce della prima:

(div 30908.208 31.208)
;-> 990.3937451935401
----------------------------------------------------------------------------


===========
Problema 10
===========

Sommatoria dei numeri primi

La somma dei numeri primi minori di 10 vale 2 + 3 + 5 + 7 = 17.

Trovare la somma di tutti i primi minori di 2 milioni.
============================================================================

(sequence 2 10)
;-> (2 3 4 5 6 7 8 9 10)

(isprime? 2)
;-> true

(filter isprime? (sequence 2 10))
;-> (2 3 5 7)

(filter isprime? (sequence 2 1000))
;-> (2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107
;->  109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223
;->  227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337
;->  347 349 353 359 367 373 379 383 389 397 401 409 419 421 431 433 439 443 449 457
;->  461 463 467 479 487 491 499 503 509 521 523 541 547 557 563 569 571 577 587 593
;->  599 601 607 613 617 619 631 641 643 647 653 659 661 673 677 683 691 701 709 719
;->  727 733 739 743 751 757 761 769 773 787 797 809 811 821 823 827 829 839 853 857
;->  859 863 877 881 883 887 907 911 919 929 937 941 947 953 967 971 977 983 991 997)

(apply add (filter isprime? (sequence 2 10)))
;-> 17

(apply add (filter isprime? (sequence 2 10000)))
;-> 5736396

(apply add (filter isprime? (sequence 2 2000000)))
;-> 142913828922

(time (apply add (filter isprime? (sequence 2 2000000))))
;-> 2265.831

(+ 2 (apply + (filter isprime? (sequence 3 2000000 2 ))))
;-> 142913828922

(time (+ 2 (apply + (filter isprime? (sequence 3 2000000 2 )))))
;-> 1893.077

Proviamo con una funzione iterativa:

(define (e010)
    (let (somma 2)
        (for (i 3 1999999 2)
            (if (= 1 (length (factor i)))
                (setq somma (+ somma i)))
        )
        somma
    )
)

(e010)
;-> 142913828922

(time (e010))
;-> 1077.866

Dal punto di vista matematico possiamo implementare una versione del crivello di eratostene ottimizzata per questo problema, inoltre calcoliamo la somma dei numeri primi fino a n come la differenza tra la somma di tutti i numeri primi fino a n e la somma di tutti i numeri composti (non-primi) fino a n:

Sum[1..n]primi(i) = Sum[1..n](i) - Sum[1..n]composti(i)

dove: Sum[1..n](i) = n*(n + 1)/2

(define (e010-2 n)
  (local (sum bound data start step)
    (setq sum 0)
    (setq bound (floor (sqrt n)))
    (setq data (array (+ n 1) '(0)))
    (setf (data 1) 1)
    (setf (data 0) 1)
    (for (i 2 bound)
      (if (zero? (data i))
          (for (j (+ i i) n i)
            (if (zero? (data j))
              (begin
              (setf (data j) 1)
              (++ sum j))
            )
          )
       )
    )
    (- (/ (* n (+ n 1)) 2) sum 1)))

(e010-2 1999999)
;-> 142913828922

(time (e010-2 1999999))
;-> 546.907
----------------------------------------------------------------------------


===========
Problema 11
===========

Il più grande prodotto in una griglia

Nella griglia 20 × 20 seguente, quattro numeri lungo una linea diagonale sono stati racchiusi con i caratteri > < (es. >26<).

08  02  22  97  38  15  00  40  00  75  04  05  07  78  52  12  50  77  91  08
49  49  99  40  17  81  18  57  60  87  17  40  98  43  69  48  04  56  62  00
81  49  31  73  55  79  14  29  93  71  40  67  53  88  30  03  49  13  36  65
52  70  95  23  04  60  11  42  69  24  68  56  01  32  56  71  37  02  36  91
22  31  16  71  51  67  63  89  41  92  36  54  22  40  40  28  66  33  13  80
24  47  32  60  99  03  45  02  44  75  33  53  78  36  84  20  35  17  12  50
32  98  81  28  64  23  67  10 >26< 38  40  67  59  54  70  66  18  38  64  70
67  26  20  68  02  62  12  20  95 >63< 94  39  63  08  40  91  66  49  94  21
24  55  58  05  66  73  99  26  97  17 >78< 78  96  83  14  88  34  89  63  72
21  36  23  09  75  00  76  44  20  45  35 >14< 00  61  33  97  34  31  33  95
78  17  53  28  22  75  31  67  15  94  03  80  04  62  16  14  09  53  56  92
16  39  05  42  96  35  31  47  55  58  88  24  00  17  54  24  36  29  85  57
86  56  00  48  35  71  89  07  05  44  44  37  44  60  21  58  51  54  17  58
19  80  81  68  05  94  47  69  28  73  92  13  86  52  17  77  04  89  55  40
04  52  08  83  97  35  99  16  07  97  57  32  16  26  26  79  33  27  98  66
88  36  68  87  57  62  20  72  03  46  33  67  46  55  12  32  63  93  53  69
04  42  16  73  38  25  39  11  24  94  72  18  08  46  29  32  40  62  76  36
20  69  36  41  72  30  23  88  34  62  99  69  82  67  59  85  74  04  36  16
20  73  35  29  78  31  90  01  74  31  49  71  48  86  81  16  23  57  05  54
01  70  54  71  83  51  54  69  16  92  33  48  61  43  52  01  89  19  67  48

Il prodotto di questi numeri vale 26 × 63 × 78 × 14 = 1788696.

Qual'è il valore più grande del prodotto di quattro numeri adiacenti nella stessa direzione (su, giù, sinistra, destra o diagonalmente) nella griglia 20 × 20?
============================================================================

(setq grid
'( 8  2 22 97 38 15  0 40  0 75  4  5  7 78 52 12 50 77 91  8
  49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48  4 56 62  0
  81 49 31 73 55 79 14 29 93 71 40 67 53 88 30  3 49 13 36 65
  52 70 95 23  4 60 11 42 69 24 68 56  1 32 56 71 37  2 36 91
  22 31 16 71 51 67 63 89 41 92 36 54 22 4  40 28 66 33 13 80
  24 47 32 60 99  3 45  2 44 75 33 53 78 36 84 20 35 17 12 50
  32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70
  67 26 20 68  2 62 12 20 95 63 94 39 63  8 40 91 66 49 94 21
  24 55 58  5 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72
  21 36 23  9 75  0 76 44 20 45 35 14  0 61 33 97 34 31 33 95
  78 17 53 28 22 75 31 67 15 94  3 80  4 62 16 14  9 53 56 92
  16 39  5 42 96 35 31 47 55 58 88 24  0 17 54 24 36 29 85 57
  86 56  0 48 35 71 89  7  5 44 44 37 44 60 21 58 51 54 17 58
  19 80 81 68  5 94 47 69 28 73 92 13 86 52 17 77  4 89 55 40
   4 52  8 83 97 35 99 16  7 97 57 32 16 26 26 79 33 27 98 66
  88 36 68 87 57 62 20 72  3 46 33 67 46 55 12 32 63 93 53 69
   4 42 16 73 38 25 39 11 24 94 72 18  8 46 29 32 40 62 76 36
  20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74  4 36 16
  20 73 35 29 78 31 90  1 74 31 49 71 48 86 81 16 23 57  5 54
   1 70 54 71 83 51 54 69 16 92 33 48 61 43 52  1 89 19 67 48))

(length grid)
;-> 400

(define (right i)
  (setq r (slice grid i 4))
  (apply * r))

(define (down i)
  (setq d (select grid i (+ i 20) (+ i 40) (+ i 60)))
  (apply * d))

(define (diag-down-right i)
  (setq dr (select grid i (+ i 21) (+ i 42) (+ i 63)))
  (apply * dr))

(define (diag-down-left i)
  (setq dl (select grid i (+ i 19) (+ i 38) (+ i 57)))
  (apply * dl))

(define (e011)
  (setq down-max (apply max (map (fn (x) (down x)) (sequence 0 339))))
  (setq diag-down-left-max (apply max (map (fn (x) (diag-down-left x)) (sequence 3 339))))
  (setq diag-down-right-max (apply max (map (fn (x) (diag-down-right x)) (sequence 0 333))))
  (max down-max diag-down-left-max diag-down-left-max)
)

(e011)
;-> 70600674

(time (e011))
;-> 0

(time (e011) 1000)
;-> 501.021

Per migliorare la velocità proviamo ad utilizzare un vettore al posto di una lista, cicli "for" al posto di "map" e moltiplicazioni dirette al posto di "apply":

(setq arr (array 20 20 grid))
;-> ((8 2 22 97 38 15 0 40 0 75 4 5 7 78 52 12 50 77 91 8)
;->  (49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 4 56 62 0)
;->  (81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 3 49 13 36 65)
;->  (52 70 95 23 4 60 11 42 69 24 68 56 1 32 56 71 37 2 36 91)
;->  (22 31 16 71 51 67 63 89 41 92 36 54 22 4 40 28 66 33 13 80)
;->  (24 47 32 60 99 3 45 2 44 75 33 53 78 36 84 20 35 17 12 50)
;->  (32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70)
;->  (67 26 20 68 2 62 12 20 95 63 94 39 63 8 40 91 66 49 94 21)
;->  (24 55 58 5 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72)
;->  (21 36 23 9 75 0 76 44 20 45 35 14 0 61 33 97 34 31 33 95)
;->  (78 17 53 28 22 75 31 67 15 94 3 80 4 62 16 14 9 53 56 92)
;->  (16 39 5 42 96 35 31 47 55 58 88 24 0 17 54 24 36 29 85 57)
;->  (86 56 0 48 35 71 89 7 5 44 44 37 44 60 21 58 51 54 17 58)
;->  (19 80 81 68 5 94 47 69 28 73 92 13 86 52 17 77 4 89 55 40)
;->  (4 52 8 83 97 35 99 16 7 97 57 32 16 26 26 79 33 27 98 66)
;->  (88 36 68 87 57 62 20 72 3 46 33 67 46 55 12 32 63 93 53 69)
;->  (4 42 16 73 38 25 39 11 24 94 72 18 8 46 29 32 40 62 76 36)
;->  (20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 4 36 16)
;->  (20 73 35 29 78 31 90 1 74 31 49 71 48 86 81 16 23 57 5 54)
;->  (1 70 54 71 83 51 54 69 16 92 33 48 61 43 52 1 89 19 67 48))

(define (get-el y x)
  (if (and (>= y 0) (< y 20) (>= x 0) (< x 20))
      (arr y x)
      0))

(get-el 2 2)
;-> 31

(define (e011-2)
  (local (dx dy val max-val)
    (setq max-val 0)
    (setq dx '(1 0 1 -1))
    (setq dy '(0 1 1  1))
    (for (y 0 19)
      (for (x 0 19)
        (for (d 0 3)
          (setq val 1)
          (for (i 0 3)
            (setq val (* val (get-el (+ y (* i (dy d))) (+ x (* i (dx d))))))
          )
          (setq max-val (max val max-val))
        )
      )
    )
    max-val))

(e011-2)
;-> 70600674

(time (e011-2))
;-> 2.992

(time (e011-2) 1000)
;-> 2496.241

Questa volta la velocità è peggiorata (probabilmente la funzione "get-el" è la responsabile).
----------------------------------------------------------------------------


===========
Problema 12
===========

Numero triangolare altamente divisibile

La sequenza di numeri triangolari viene generata aggiungendo i numeri naturali. Quindi il settimo numero di triangolo sarebbe 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. I primi dieci termini sarebbero:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Cerchiamo di elencare i fattori dei primi sette numeri triangolare:

  1: 1
  3: 1,3
  6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28

Possiamo vedere che 28 è il primo numero triangolare ad avere più di cinque divisori.

Qual'è il valore del primo numero triangolare che ha oltre cinquecento divisori?
============================================================================

Funzione che calcola l'n-esimo numero triangolare:

(define (numtri n) (/ (+ (* n n) n) 2))
;-> (numtri 1)
;-> 1
;-> (numtri 2)
;-> 3
;-> (numtri 3)
;-> 6
;-> (numtri 4)
;-> 10

Funzione cha calcola il numero di divisori di un numero n:

(define (numdivisors n)
  (local (ndiv)
    (setq ndiv 0)
    (for (i 1 (+ n 1))
      (if (zero? (% n i)) (++ ndiv))
    )
    ndiv
  )
)

(numdivisors 10) ;(1 2 5 10)
;-> 4

(numdivisors 64) ;(1 2 4 8 16 32 64)
;-> 7

(numdivisors 76576500)
;-> 576

(define (e012)
  (let (look true)
    (for (i 1 99999 2 (not look))
      (if (> (* (numdivisors i) (numdivisors (div (numtri i) i))) 500)
        (begin
          (println "i = " i {; }
                   "tri = " (numtri i) {; }
                   "divisori = " (* (numdivisors i) (numdivisors (div (numtri i) i))))
          (setq look false)
        )
      )
    )
  )
)

(e012)
;-> i = 12375; tri = 76576500; divisori = 576
;-> true

(time (e012))
;-> 5444.521

Dal punto di vista matematico, il numero di divisori di un numero naturale n è dato da tau(n) o τ(n) o talvolta  delta(n) o δ(n). Ogni numero naturale può essere espresso come il prodotto dei loro fattori primi k in questo modo:

n = Prod[1..k] p(i)^e(i)
​
Quindi il numero di divisori è dato da:

tau(n) = Prod[1..k] e(i) + 1

Quindi abbiamo bisogno della scomposizione in fattori primi e del prodotto dei suoi esponenti.

Prima scriviamo la funzione che calcola tau(n):

(define (tau num)
  (local (n i p c)
    (setq n num i 2 p 1)
    (cond ((= num 1) (setq p 1))
          (true
            (while (<= (* i i) n)
              (setq c 1)
              (while (zero? (% n i))
                (setq n (/ n i))
                (++ c)
              )
              (++ i)
              (setq p (* p c))
            )
            (if (or (= n num) (> n 1)) (setq p (* p 2)))
          )
     )
     p))

(tau 20)
;-> 6

Vediamo se la funzione "tau" e "numdivisors" danno gli stessi risultati:
(for (i 1 10000)
  (if (!= (numdivisors i) (tau i)) (println i { } (numdivisors i) { } (tau i))))
  ;-> nil

Inoltre occorre la seguente funzione che calcola i numeri triangolari fino ad un certo valore num:

(define (tri num)
  (setq n 1)
  (setq d 1)
  (println d)
  (while (< d num)
    (++ n)
    (++ d n)
    (println d)
  )
  d)

(tri 21)
;-> 1
;-> 3
;-> 6
;-> 10
;-> 15
;-> 21

La funzione finale è la seguente:

(define (e012-2 x)
  (let ((n 1) (d 1))
    (while (<= (tau d) x)
      (++ n)
      (++ d n)
    )
    d))

(e012-2 500)
;-> 76576500

(time (e012-2))
;-> 0
----------------------------------------------------------------------------


===========
Problema 13
===========

Grande somma

Calcolare le prime dieci cifre della somma dei seguenti cento numeri di 50 cifre ognuno.
============================================================================

Suddividiamo la lista da 100 numeri in due liste da 50 numeri per evitare il limite dei 2048 caratteri che newLISP pone alla lunghezza di una espressione.

(setq numeriA '(
 37107287533902102798797998220837590246510135740250L
 46376937677490009712648124896970078050417018260538L
 74324986199524741059474233309513058123726617309629L
 91942213363574161572522430563301811072406154908250L
 23067588207539346171171980310421047513778063246676L
 89261670696623633820136378418383684178734361726757L
 28112879812849979408065481931592621691275889832738L
 44274228917432520321923589422876796487670272189318L
 47451445736001306439091167216856844588711603153276L
 70386486105843025439939619828917593665686757934951L
 62176457141856560629502157223196586755079324193331L
 64906352462741904929101432445813822663347944758178L
 92575867718337217661963751590579239728245598838407L
 58203565325359399008402633568948830189458628227828L
 80181199384826282014278194139940567587151170094390L
 35398664372827112653829987240784473053190104293586L
 86515506006295864861532075273371959191420517255829L
 71693888707715466499115593487603532921714970056938L
 54370070576826684624621495650076471787294438377604L
 53282654108756828443191190634694037855217779295145L
 36123272525000296071075082563815656710885258350721L
 45876576172410976447339110607218265236877223636045L
 17423706905851860660448207621209813287860733969412L
 81142660418086830619328460811191061556940512689692L
 51934325451728388641918047049293215058642563049483L
 62467221648435076201727918039944693004732956340691L
 15732444386908125794514089057706229429197107928209L
 55037687525678773091862540744969844508330393682126L
 18336384825330154686196124348767681297534375946515L
 80386287592878490201521685554828717201219257766954L
 78182833757993103614740356856449095527097864797581L
 16726320100436897842553539920931837441497806860984L
 48403098129077791799088218795327364475675590848030L
 87086987551392711854517078544161852424320693150332L
 59959406895756536782107074926966537676326235447210L
 69793950679652694742597709739166693763042633987085L
 41052684708299085211399427365734116182760315001271L
 65378607361501080857009149939512557028198746004375L
 35829035317434717326932123578154982629742552737307L
 94953759765105305946966067683156574377167401875275L
 88902802571733229619176668713819931811048770190271L
 25267680276078003013678680992525463401061632866526L
 36270218540497705585629946580636237993140746255962L
 24074486908231174977792365466257246923322810917141L
 91430288197103288597806669760892938638285025333403L
 34413065578016127815921815005561868836468420090470L
 23053081172816430487623791969842487255036638784583L
 11487696932154902810424020138335124462181441773470L
 63783299490636259666498587618221225225512486764533L
 67720186971698544312419572409913959008952310058822L ))

(setq numeriB '(
 95548255300263520781532296796249481641953868218774L
 76085327132285723110424803456124867697064507995236L
 37774242535411291684276865538926205024910326572967L
 23701913275725675285653248258265463092207058596522L
 29798860272258331913126375147341994889534765745501L
 18495701454879288984856827726077713721403798879715L
 38298203783031473527721580348144513491373226651381L
 34829543829199918180278916522431027392251122869539L
 40957953066405232632538044100059654939159879593635L
 29746152185502371307642255121183693803580388584903L
 41698116222072977186158236678424689157993532961922L
 62467957194401269043877107275048102390895523597457L
 23189706772547915061505504953922979530901129967519L
 86188088225875314529584099251203829009407770775672L
 11306739708304724483816533873502340845647058077308L
 82959174767140363198008187129011875491310547126581L
 97623331044818386269515456334926366572897563400500L
 42846280183517070527831839425882145521227251250327L
 55121603546981200581762165212827652751691296897789L
 32238195734329339946437501907836945765883352399886L
 75506164965184775180738168837861091527357929701337L
 62177842752192623401942399639168044983993173312731L
 32924185707147349566916674687634660915035914677504L
 99518671430235219628894890102423325116913619626622L
 73267460800591547471830798392868535206946944540724L
 76841822524674417161514036427982273348055556214818L
 97142617910342598647204516893989422179826088076852L
 87783646182799346313767754307809363333018982642090L
 10848802521674670883215120185883543223812876952786L
 71329612474782464538636993009049310363619763878039L
 62184073572399794223406235393808339651327408011116L
 66627891981488087797941876876144230030984490851411L
 60661826293682836764744779239180335110989069790714L
 85786944089552990653640447425576083659976645795096L
 66024396409905389607120198219976047599490197230297L
 64913982680032973156037120041377903785566085089252L
 16730939319872750275468906903707539413042652315011L
 94809377245048795150954100921645863754710598436791L
 78639167021187492431995700641917969777599028300699L
 15368713711936614952811305876380278410754449733078L
 40789923115535562561142322423255033685442488917353L
 44889911501440648020369068063960672322193204149535L
 41503128880339536053299340368006977710650566631954L
 81234880673210146739058568557934581403627822703280L
 82616570773948327592232845941706525094512325230608L
 22918802058777319719839450180888072429661980811197L
 77158542502016545090413245809786882778948721859617L
 72107838435069186155435662884062257473692284509516L
 20849603980134001723930671666823555245252804609722L
 53503534226472524250874054075591789781264330331690L ))

(length numeriA)
;-> 50
(length numeriB)
;-> 50

(apply + numeriA)
;-> 2739840008414248713350123647779193919724097856798098L

(apply + numeriB)
;-> 2797536221976627923951925099053792052049561975094574L

(+ (apply + numeriA) (apply + numeriB))

(define (e013)
  (slice (string (+ (apply + numeriA) (apply + numeriB))) 0 10))

(e013)
;-> "5537376230"

Il numero  completo vale:
5537376230390876637302048746832985971773659831892672L

(time (e013))
;-> 0
----------------------------------------------------------------------------


===========
Problema 14
===========

La sequenza di Collatz più lunga

La seguente sequenza iterativa è definita per l'insieme di numeri interi positivi:

n = 1 -> stop
n -> n / 2 (n è pari)
n -> 3 * n + 1 (n è dispari)

Usando la regola sopra e iniziando con 13, generiamo la seguente sequenza:
13 40 20 10 5 16 8 4 2 1
Si può vedere che questa sequenza (che inizia a 13 e finisce a 1) contiene 10 termini.
Anche se non è stato ancora dimostrato (Collatz Problem), si ritiene che tutti i numeri iniziali conducano al numero 1.

Quale numero iniziale, inferiore a un milione, produce la catena più lunga?

NOTA: una volta avviata la sequenza, i termini possono superare il milione.
============================================================================

Scriviamo una funzione che costruisce la sequenza di Collatz per un numero n:

(define (collatz n)
  (if (= n 1) '(1)
    (cons n (collatz (if (even? n) (/ n 2) (+ 1 (* 3 n)))))))

Poi scriviamo una funzione che calcola la lunghezza della sequenza di Collatz di un numero n:

(define (collatz-lenght n)
  (length (collatz n))
)

(collatz 24)
;-> (24 12 6 3 10 5 16 8 4 2 1)

(collatz-lenght 24)
;-> 11

Utilizzando le due funzioni direttamente (senza alcun tipo di ottimizzazione) possiamo scrivere la seguente soluzione:

(define (e014)
  (local (maxlun out num)
    (setq maxlun 0)
    (setq out '())
    (setq num 0)
    (for (i 1 1000000)
      (if (> (length (collatz i)) maxlun)
          (begin
            (setq maxlun (length (collatz i)))
            (setq num i)
          )
      )
    )
    (list num maxlun)
  )
)

Questa funzione è molto lenta...

(e014)
;-> (837799 525)

(time (e014))
;-> 107039.434 ; 107 secondi

Proviamo a scrivere una funzione unica che calcola la lunghezza di collatz senza costruire la lista:

(define (e014)
  (local (maxlun lun num c)
    (setq maxlun 0)
    (setq num 0)
    (for (i 1 1000000)
      (setq c i)
      (setq lun 1)
      ; calcolo della lunghezza della sequenza
      (while (!= c 1)
         (if (even? c) (setq c (/ c 2))
                       (setq c (+ 1 (* 3 c)))
         )
         (++ lun)
      )
      (if (> lun maxlun) ; se la sequenza è più lunga di quella massima,
          (begin         ; allora aggiorno il valore massimo e il relativo numero di collatz
            (setq maxlun lun)
            (setq num i)
          )
      )
    )
    (list num maxlun)
  )
)

(e014)
;-> (837799 525)

(time (e014))
;-> 15376.695 ; 15.4 secondi

Possiamo riscrivere la funzione in modo diverso:

(define (len-collatz n)
  (let (c 1)
    (while (> n 1)
      (if (even? n)
          (setq n (/ n 2))
          (setq n (+ (* 3 n) 1))
      )
      (++ c)
    )
    c))

(len-collatz 24)
;-> 11

(define (e014 n)
  (local (max-len max-num)
    (setq max-len 0 max-num 0)
    (for (i 1 n)
      (setq c (len-collatz i))
      (if (> c max-len)
          (setq max-len c max-num i)
      )
    )
    (list max-num max-len)))

(e014 999999)
;-> (837799 525)

(time (e014 999999))
;-> 15157.284

Non abbiamo migliorato la velocità...

Allora proviamo ad utilizzare una hash-map per contenere i valori delle lunghezze di Collatz di ogni numero:

; crea hash
(new Tree 'hash)

; assegna hash (hash chiave valore)
(hash 4 2)
;-> 2

; recupero valore con chiave
(hash 4)
;-> 2

; valore nil se non esiste la chiave
(hash 3)
;-> nil

; elimina hash
(delete 'hash)

Scriviamo la funzione:

(define (e014-2 n)
  (local (maxlun lun num c found)
    ;(delete 'hash)
    (new Tree 'hash)
    (setq maxlun 0)
    (setq num 0)
    (for (i 1 n)
      (if (= (length (hash)) n) (println i { } n))
      (setq c i)
      (setq lun 1)
      ; calcolo della lunghezza della sequenza
      (setq found nil)
      (while (and (!= c 1) (not found))
        ; se non trovo il valore della lunghezza nella hashmap
        (if (nil? (hash (string c)))
            ; calcolo la lunghezza normalmente
            (begin
            (if (even? c)
                (setq c (/ c 2))

                (setq c (+ 1 (* 3 c)))
            )
            (++ lun))
            ;else
            ; altrimenti la recupero dalla hashmap
            (begin
            (setq found true)
            (setq lun (+ lun (hash (string c)) (- 1))))
        )
      )
      ; inserisco nella hashmap il valore della lunghezza trovata
      (hash i lun)
      (if (> lun maxlun) ; se la sequenza è più lunga di quella massima,
          (begin         ; allora aggiorno il valore massimo e il relativo numero di collatz
            (setq maxlun lun)
            (setq num i)
          )
      )
    )
    (list num maxlun (length (hash)))
  )
)

(e014-2 999999)
;-> (837799 525)

Per calcolare la velocità della funzione occorre eliminare l'hashmap perchè contiene tutti i valori delle lunghezze fino al numero 999999:

(delete 'hash)

(time (e014-2 999999))
;-> 7563.103

Se non eliminiamo l'hashmap:

(time (e014-2 999999))
;-> 2015.606
----------------------------------------------------------------------------


===========
Problema 15
===========

Percorsi in una griglia

Partendo dall'angolo in alto a sinistra di una griglia 2 × 2, e potendo solo spostarsi verso destra e verso il basso, ci sono esattamente 6 percorsi diversi per raggiungere l'angolo in basso a destra.

Quanti percorsi ci sono attraverso una griglia 20 × 20?
==============

Quello che ci interessa è la distanza tra le coordinate di inizio e fine, cioè la dimensione della griglia: 20.

Possiamo scrivere una funzione ricorsiva che utilizza questo valore di distanza per calcolare il numero totale dei percorsi (minimi) tra i due punti.
Poichè ogni volta ci dobbiamo muovere a destra o verso il basso possiamo richiamare la stesse funzioni con uno dei parametri (destra o basso) diminuito di 1. Queste funzioni vengono richiamate tante volte quanto vale la distanza tra le coordinate. Facendo la somma dei risultati di queste funzioni otteniamo il numero di percorsi (minimi) tra le coordinate di inizio e fine della griglia.

La funzione ricorsiva per il calcolo dei percorsi è la seguente:

(define (numPercorsi basso destra);
    (if (or (= basso 0) (= destra 0)) 1
        (+ (numPercorsi (- basso 1) destra)
           (numPercorsi basso (- destra 1)))
    )
)

(numPercorsi 2 2)
;-> 6

(numPercorsi 10 10)
;-> 184756

(time (numPercorsi 20 20))

Purtroppo questa funzione è molto lenta (O(2^n)) quindi dobbiamo utilizzare un'altro metodo. Dal punto di vista matematico, il numero di percorsi in una griglia dal punto (0,0) al punto (n,m) è uguale al coefficiente binomiale:

(n + m)      (n + m)!
        = -------------
(  n  )      n! * m!
                          (2*n)    (2*n)!    (40)      40!
Nel nostro caso diventa:        = -------- =      = ---------
                          ( n )    (n!)^2    (20)    (20!)^2

Definiamo la funzione fattoriale:

(define (fact n) (apply * (map bigint (sequence 1 n))))

Calcoliamo il numero di percorsi:

(define (e015 n)
  (/ (fact (+ n n)) (* (fact n) (fact n)))
)

(e015 20)
;-> 137846528820L

(time (e015 20))
;-> 0

(time (e015 20) 10000)
;-> 180.548

Dal punto di vista non-matematico, notiamo che:

(for (i 1 10) (print (e015 i) { }))
;-> 2L 6L 20L 70L 252L 924L 3432L 12870L 48620L 184756L

Guardando su oesis.org si trova che questa sequenza è la A000984 (Central binomial coefficients).
Questa sequenza può essere calcolata nel modo seguente:

(define (e015-2 n)
  (let (c 1)
    (for (i 1 n)
      (setq c (/ (* c (+ n i)) i)))))

(e015-2 20)
;-> 137846528820

(time (e015-2 20))
;-> 0

(time (e015-2 20) 10000)
;-> 18.95

Questa funzione è 10 volte più veloce della precedente.
----------------------------------------------------------------------------


===========
Problema 16
===========

Somma cifre di una potenza

2^15 = 32768 e la somma delle sue cifre vale 3 + 2 + 7 + 6 + 8 = 26.

Quanto vale la somma delle cifre del numero 2^1000?
============================================================================

(Definiamo una funzione che calcola la potenza di un numero intero (big integer):

(define (potenza n m)
  (setq pot 1L)
  (dotimes (x m)
    (setq pot (* pot n))
  )
)

(potenza 3 50)
;-> 717897987691852588770249L

(define (e016)
  (setq num (potenza 2 1000))
  (setq n$ (string num))
  (setq n$ (slice n$ 0 (- (length n$) 1)))
  (apply + (map int (explode n$)))
)

(e016)
;-> 1366

(time (e016))
;-> 0

Dal punto di vista matematico possiamo utilizzare la formula per la lunghezza di un numero intero n:

L(n) = floor(1 + log10(n))

Quindi il numero 2^1000 è lungo:

d = 1 + floor(log10(2^1000)) = 1 + floor(1000*log10(2))

(add 1 (floor (mul 1000 (log 2 10))))
;-> 302

Quindi possiamo moltiplicare il numero 2 per 1000 volte utilizzando il normale algoritmo per la moltiplicazione e memorizzare il risultato in un vettore di 320 elementi. Potremmo usare una lista per memorizzare il risultato, ma un vettore è più veloce.

(define (e016-2 esp)
  (local (product carry order digits number)
    (setq order 0)
    (setq digits (add 1 (floor (mul 1000 (log 2 10)))))
    (setq number (array digits '(1)))
    (setf (number 0) 1)
    (for (i 0 (- esp 1))
      (setq carry 0)
      (for (j 0 order)
        (setq product (+ (* 2 (number j)) carry))
        (setf (number j) (% product 10))
        (setq carry (/ product 10))
        (if (and (= j order) (> carry 0))
          (++ order)
        )
      )
    )
    (apply + (array-list number))))

(e016-2 1000)
;-> 1366

(time (e016-2 1000))
;-> 31.947
----------------------------------------------------------------------------


===========
Problema 17
===========

Contare il numero di lettere

Se i numeri da 1 a 5 sono scritti con le parole inglesi:
one, two, three, four, five allora sono state usate
 3  +  3  +  5  +  4  +  4 = 19 lettere in totale.

Se tutti i numeri da 1 a 1000 (one thousand) incluso fossero scritti con le parole inglesi, quante lettere occorrerebbe usare?

NOTA: non contare spazi o trattini. Ad esempio, 342 (three hundred and forty-two) contiene 23 lettere e 115 (one hundred and fifteen) contiene 20 lettere. L'uso di "and" quando si scrivono numeri è conforme all'uso britannico.
============================================================================

La soluzione è tediosa.

(setq n1-19 '("" "one" "two" "three" "four" "five" "six" "seven" "eight" "nine" "ten" "eleven" "twelve" "thirteen" "fourteen" "fifteen" "sixteen" "seventeen" "eighteen" "nineteen"))

(setq n20-90 '("" "" "twenty" "thirty" "forty" "fifty" "sixty" "seventy" "eighty" "ninety"))

(setq n100 "hundred")

; gli spazi non contano
(setq n100and "hundredand")

(setq n1000 "onethousand")

(define (e017)
  (local (n1-9 n10-19 n20-99 n100-999)
    (setq n1-9 (apply + (map length (1 9 n1-19))))
    (setq n10-19 (apply + (map length (10 19 n1-19))))
    (setq n20-99 (+ (* 10 (apply + (map length (2 9 n20-90))))
                    (* 8 n1-9)))
    (setq n100-999 (+ (* 100 (+ n1-9))
                      (* 9 (+ n1-9 n10-19 n20-99))
                            (* 9 (length n100))
                            (* 9 99 (length n100and))))
    (+ n1-9 n10-19 n20-99 n100-999 (length n1000))
  )
)

(e017)
;-> 21124

(time (e017))
;-> 0
----------------------------------------------------------------------------


===========
Problema 18
===========

Percorso con somma massima

Iniziando dalla parte superiore del triangolo in basso e passando ai numeri adiacenti sulla riga sottostante, il totale massimo dall'alto verso il basso è 23.

   3
  7 4
 2 4 6
8 5 9 3

Cioè, 3 + 7 + 4 + 9 = 23.

Trova il totale massimo dall'alto al basso del triangolo sottostante:

                            75
                          95 64
                        17 47 82
                      18 35 87 10
                    20 04 82 47 65
                  19 01 23 75 03 34
                88 02 77 73 07 63 67
              99 65 04 28 06 16 70 92
            41 41 26 56 83 40 80 70 33
          41 48 72 33 47 32 37 16 94 29
        53 71 44 65 25 43 91 52 97 51 14
      70 11 33 28 77 73 17 78 39 68 17 57
    91 71 52 38 17 14 91 43 58 50 27 29 48
  63 66 04 68 89 53 67 30 73 16 69 87 40 31
04 62 98 27 23 09 70 98 73 93 38 53 60 04 23

NOTA: poiché ci sono solo 16384 percorsi, è possibile risolvere questo problema provando ogni percorso.
============================================================================

La seguente soluzione è veramente "brutale".

(define (e018)
  (local (a aa b bb c cc d dd e ee f ff g gg h hh i ii j jj k kk l ll m mm n nn o oo somma sommaMax)
    (setq triangle '((75) (95 64) (17 47 82) (18 35 87 10) (20 4 82 47 65) (19 1 23 75 3 34) (88 2 77 73 7 63 67) (99 65 4 28 6 16 70 92) (41 41 26 56 83 40 80 70 33) (41 48 72 33 47 32 37 16 94 29) (53 71 44 65 25 43 91 52 97 51 14) (70 11 33 28 77 73 17 78 39 68 17 57) (91 71 52 38 17 14 91 43 58 50 27 29 48) (63 66 4 68 89 53 67 30 73 16 69 87 40 31) (4 62 98 27 23 9 70 98 73 93 38 53 60 4 23)))
    (setq a (triangle 0))
    (setq b (triangle 1))
    (setq c (triangle 2))
    (setq d (triangle 3))
    (setq e (triangle 4))
    (setq f (triangle 5))
    (setq g (triangle 6))
    (setq h (triangle 7))
    (setq i (triangle 8))
    (setq j (triangle 9))
    (setq k (triangle 10))
    (setq l (triangle 11))
    (setq m (triangle 12))
    (setq n (triangle 13))
    (setq o (triangle 14))
    (setq sommaMax 0)
    (setq somma 0)
    (for (bb 0 (- (length b) 1))
     (for (cc bb (+ bb 1))
       (for (dd cc (+ cc 1))
        (for (ee dd (+ dd 1))
         (for (ff ee (+ ee 1))
          (for (gg ff (+ ff 1))
           (for (hh gg (+ gg 1))
            (for (ii hh (+ hh 1))
             (for (jj ii (+ ii 1))
              (for (kk jj (+ jj 1))
               (for (ll kk (+ kk 1))
                (for (mm ll (+ ll 1))
                 (for (nn mm (+ mm 1))
                  (for (oo nn (+ nn 1))
                   (setq somma (+ (a 0) (b bb) (c cc) (d dd) (e ee) (f ff) (g gg) (h hh)
                                  (i ii) (j jj) (k kk) (l ll) (m mm) (n nn) (o oo)))
                   (if (> somma sommaMax) (swap somma sommaMax))
    ))))))))))))))
    sommaMax
  );local
)

(e018)
;-> 1074

(time (e018))
;-> 31.248

Una soluzione generica può essere ottenuta con la programmazione dinamica. In pratica per trovare la soluzione, ogni riga deve essere aggiunta a qualsiasi riga successiva, dal basso verso l'alto. Poiché ogni cella ha due predecessori, prendiamo il valore massimo delle due. Con questo metodo, la soluzione si trova nella cella superiore del triangolo:

var triangle = [
  [75],
  [95, 64],
  [17, 47, 82],
  [18, 35, 87, 10],
  [20, 04, 82, 47, 65],
  [19, 01, 23, 75, 03, 34],
  [88, 02, 77, 73, 07, 63, 67],
  [99, 65, 04, 28, 06, 16, 70, 92],
  [41, 41, 26, 56, 83, 40, 80, 70, 33],
  [41, 48, 72, 33, 47, 32, 37, 16, 94, 29],
  [53, 71, 44, 65, 25, 43, 91, 52, 97, 51, 14],
  [70, 11, 33, 28, 77, 73, 17, 78, 39, 68, 17, 57],
  [91, 71, 52, 38, 17, 14, 91, 43, 58, 50, 27, 29, 48],
  [63, 66, 04, 68, 89, 53, 67, 30, 73, 16, 69, 87, 40, 31],
  [04, 62, 98, 27, 23, 09, 70, 98, 73, 93, 38, 53, 60, 04, 23],
];

(define (e018-2)
  (let (tri '(
             (75)
             (95 64)
             (17 47 82)
             (18 35 87 10)
             (20 4 82 47 65)
             (19 1 23 75 3 34)
             (88 2 77 73 7 63 67)
             (99 65 4 28 6 16 70 92)
             (41 41 26 56 83 40 80 70 33)
             (41 48 72 33 47 32 37 16 94 29)
             (53 71 44 65 25 43 91 52 97 51 14)
             (70 11 33 28 77 73 17 78 39 68 17 57)
             (91 71 52 38 17 14 91 43 58 50 27 29 48)
             (63 66 4 68 89 53 67 30 73 16 69 87 40 31)
             (4 62 98 27 23 9 70 98 73 93 38 53 60 4 23)))
  (for (i (- (length tri) 2) 0 -1)
    (for (j 0 i)
      (setf (tri i j) (+ (tri i j) (max (tri (+ i 1) j) (tri (+ i 1) (+ j 1)))))
    )
  )
  (tri 0 0)))

(e018-2)
;-> 1074

(time (e018) 100)
;-> 655.032

(time (e018-2) 100)
;-> 3.021

La seconda funzione è 200 volte più veloce.
----------------------------------------------------------------------------


===========
Problema 19
===========

Conteggio delle domeniche

Ti vengono fornite le seguenti informazioni, ma potresti ricercare altre informazioni per te stesso.

- Il 1 gennaio 1900 era un lunedì.
- Trenta dì conta Novembre
  con April, Giugno e Settembre.
  Di ventotto ce n'è uno,
  Tutti gli altri ne han trentuno.

Un anno bisestile si verifica quando è divisibile per 4, ma non per un secolo (00) a meno che non sia divisibile per 400.

Quante domeniche caddero il primo del mese durante il ventesimo secolo (dal 1° gennaio 1901 al 31 dicembre 2000)?
============================================================================

Usiamo l'algoritmo di Gauss per determinare il giorno della settimana:

(define (day-of-week year month day) ; 0..6 --> Sun..Sat
    (letn ( d day
            m (+ (% (- month 3) 12) 1)
            Y (if (> m 10) (- year 1) year)
            y (% Y 100)
            c (/ (- Y y) 100)
            w (add d (floor (sub (mul 2.6 m) 0.2)) y (floor (div y 4)) (floor (div c 4)) (- (mul c 2)))
            w (% w 7)
          )
       (if (< w 0) (inc w 7) w))
)

Adesso la soluzione è abbastanza semplice:

(define (e019)
  (local (somma)
    (setq somma 0)
    (for (anno 1901 1999)
      (for (mese 1 12)
        (if (zero? (day-of-week anno mese 1)) (++ somma))
      )
    )
    somma
  )
)

(e019)
;-> 171

(time (e019))
;-> 2.997

Adesso utilizziamo l'algoritmo di Zeller per calcolare il giorno della settimana di una certa data:

(define (dayZ year month day)
  (local (adjust mm yy d)
    (setq adjust (/ (- 14 month) 12))
    (setq mm (+ month (* 12 adjust) (- 2)))
    (setq yy (- year adjust))
    (setq d (% (+ day (/ (- (* 13 mm) 1) 5) yy (/ yy 4) (- (/ yy 100)) (/ yy 400)) 7))
  )
)

(define (e019-2)
  (local (somma)
    (setq somma 0)
    (for (anno 1901 2000)
      (for (mese 1 12)
        (if (zero? (dayZ anno mese 1)) (++ somma))
      )
    )
    somma
  )
)

(e019-2)
;-> 171

(time (e019-2))
;-> 1.021

(time (e019) 1000)
;-> 854.296

(time (e019-2) 1000)
;-> 816.062
----------------------------------------------------------------------------


===========
Problema 20
===========

Somma di cifre fattoriali

n! significa n × (n - 1) × ... × 3 × 2 × 1

Ad esempio, 10! = 10 × 9 × ... × 3 × 2 × 1 = 3628800,
e la somma delle cifre nel numero 10! vale 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.

Trova la somma delle cifre nel numero 100!
============================================================================

Funzione fattoriale

(define (fact n) (apply * (map bigint (sequence 1 n))))

(explode (string (fact 10)))
;-> ("3" "6" "2" "8" "8" "0" "0" "L")

(map int (explode (string (fact 10))))
;-> (3 6 2 8 8 0 0 nil)

(define (e020)
  (apply + (map (fn (x) (int x 0)) (explode (string (fact 100)))))
)

(e020)
;-> 648

(time (e020))
;-> 0

Il creatore di newLISP (Lutz Mueller) ha scritto la seguente funzione che moltiplica due numeri interi passati come stringhe (è valida anche per numeri big-integer).

(define (big* x y) ; a and b are strings of decimal digits
    (letn ( nx (length x)
            ny (length y)
            np (+ nx ny)
            X (array nx (reverse (map int (explode x))))
            Y (array ny (reverse (map int (explode y))))
            Q (array (+ nx 1) (dup 0 (+ nx 1)))
            P (array np (dup 0 np))
            carry 0
            digit 0 )
        (dotimes (i ny) ; for each digit of the multiplier
            (dotimes (j nx) ; for each digit of the multiplicant
                (setq digit (+ (* (Y i) (X j)) carry) )
                (setq carry (/ digit 10))
                (setf (Q j) (% digit 10)) )
            (setf (Q nx ) carry)
            ; add Q to P shifted by i
            (setq carry 0)
            (dotimes (j (+ nx 1))
                (setq digit (+ (P (+ j i)) (Q j) carry))
                (setq carry (/ digit 10))
                (setf (P (+ j i)) (% digit 10)) )
        )
    ; translate P to string and return
    (setq P (reverse (array-list P)))
    (if (zero? (P 0)) (pop P))
    (join (map string P))
    )
)

Con la seguente soluzione al problema:

(define (e020-Lutz)
    (let (result "1")
        (for (i 2 100)
            (setq result (big* result (string i))))
        (apply + (map int (explode result))))
)

(e020-Lutz)
;-> 648

(time (e020-Lutz))
;-> 32.948
----------------------------------------------------------------------------


===========
Problema 21
===========

Numeri Amicabili

Definiamo d(n) come la somma dei divisori propri di n (tutti i numeri minori di n che dividono esattamente n).

Se d(a) = b e d(b) = a, dove a ≠ b,, allora a e b sono una coppia amicabile e a e b sono chiamati singolarmente numeri amicabili.

Per esempio, i divisori propri di 220 sono 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 e 110: quindi d(n) = 284. I divisori propri di 284 sono 1, 2, 4, 71 e 142: così d(284) = 220.

Calcolare la somma di tutti i numeri amicabili inferiori a 10000.
============================================================================

Definiamo la funzione che calcola la somma dei divisori di un numero:

(define (sum-divisors n)
  (setq res 0)
  (setq m (sqrt n))
  (setq i 2)
  (while (<= i m)
      (if (zero? (% n i))   ; se 'i' è divisore di 'n'
          (if (= i (/ n i))              ; se entrambi i divisori sono uguali...
            (setq res (+ res i))         ; allora aggiungilo una volta,
            (setq res (+ res i (/ n i))) ; altrimenti aggiungili entrambi.
          )
      )
      (setq i (+ i 1))
  )
  res
)

(sum-divisors 10)
;-> 7

Adesso dobbiamo definire la funzione che calcola i divisori propri:

(define (sum-proper-divisors n)
  (+ 1 (sum-divisors n))
)

(sum-proper-divisors 10)
;-> 8
(sum-proper-divisors 3)
;-> 1

(sum-proper-divisors 18)
;-> 21

(sum-proper-divisors 220)
;-> 284
(sum-proper-divisors 284)
;-> 220

Adesso scriviamo la funzione che calcola i numeri amicabili:

(define (e021)
  (setq _res 0)
  (for (j 1 9999)
      (setq spd (sum-proper-divisors j))
      (setq spd2 (sum-proper-divisors spd))
      (if (and (= j spd2) (!= spd spd2))
            (begin
              (setq _res (+ _res spd spd2))
              ;(println j { } spd { } spd2)
            )
      )
  )
  (/ _res 2)
)

(e021)
;-> 220 284 220
;-> 284 220 284
;-> 1184 1210 1184
;-> 1210 1184 1210
;-> 2620 2924 2620
;-> 2924 2620 2924
;-> 5020 5564 5020
;-> 5564 5020 5564
;-> 6232 6368 6232
;-> 6368 6232 6368
;-> 31626

(time (e021))
;-> 220.022

Una soluzione più efficiente si ottiene usando la seguente formula:
Siano p1, p2, ..., pk i fattori primi del numero n.
Siano a1, a2, ..., ak le potenze massime rispettivamente di p1, p2, ..., pk che dividono n (es. n = (p1^a1)*(p2^a2)*...*(pk^ak)).

Somma dei divisori = (1 + p1 + p1^2 ... p1^a1) *
                     (1 + p2 + p2^2 ... p2^a2) *
                     ......................... *
                     (1 + pk + pk^2 ... pk^ak)

Notiamo che i termini individuali di questa formula sono progressioni geometriche.
Possiamo riscrivere la formula come:

Somma dei divisori = (p1^(a1+1) - 1)/(p1 - 1) *
                     (p2^(a2+1) - 1)/(p2 - 1) *
                     ........................ *
                     (pk^(ak+1) - 1)/(pk - 1)

Vediamo un'applicazione della formula:

Consideriamo il numero 18.

(factor 18)
;-> (2 3 3)

Somma dei divisori = 1 + 2 + 3 + 6 + 9 + 18
(+ 1 2 3 6 9 18)
;-> 39

Scrivendo i divisori come potenze dei fattori primi otteniamo:

Somma di divisori = (2^0)(3^0) + (2^1)(3^0) + (2^0)(3^1) +
                    (2^1)(3^1) + (2^0)(3^2) + (2^1)(3^2)
                  = (2^0)(3^0) + (2^0)(3^1) + (2^0)(3^2) +
                    (2^1)(3^0) + (2^1)(3^1) + (2^1)(3^2)
                  = (2^0)(3^0 + 3^1 + 3^2) +
                    (2^1)(3^0 + 3^1 + 3^2)
                  = (2^0 + 2^1)(3^0 + 3^1 + 3^2)

Guardando attentamente, possiamo notare che l'ultima espressione è del tipo:

(1 + p1) * (1 + p2 + p2^2)

dove p1 = 2, p2 = 3.

Quindi: (1 + 2) * (1 + 3 + 9) = 3*13 = 39

Per trovare la somma dei divisori di un numero è sufficiente conoscere la sua scomposizione in fattori primi e applicare la seguente formula:

Somma dei divisori = Prod [(1 + f(i)^1 + ... + f(i)^k(i)]

dove [f(i), k(i)] è il fattore i-esimo con f = valore del fattore e k = potenza del fattore
e l'indice i varia da 1 al numero dei fattori.

Per trovare la somma dei divisori propria di un numero, basta sottrarre il numero stesso alla somma dei divisori ottenuta con la formula.

Esempio:

(fattorizza 18)
;-> ((2 1) (3 2))

somma dei divisori = (1 + p1 + p1^2 ... p1^a1) * (1 + p2 + p2^2 ... p2^a2) =
= (1 + 2) * (1 + 3 + 3^2) = 3 * 13 = 39

somma dei divisori propri = somma dei divisori - n = 39 - 18 = 21

Esempio:

(fattorizza 220)
;-> ((2 2) (5 1) (11 1))

p1 = 2  a1 = 2
p2 = 5  a2 = 1
p3 = 11 a3 = 1

(p1^(a1+1) - 1)/(p1 - 1) = (2^3 - 1)/(2 - 1) = 7
(p2^(a2+1) - 1)/(p2 - 1) = (5^2 - 1)/(5 - 1) = 6
(p3^(a3+1) - 1)/(p3 - 1) = (11^2 - 1)/(11 - 1) = 12

(* 6 7 12)
;-> 504

(- 504 220)
;-> 284 ; somma dei divisori propri di 220

Adesso possiamo scrivere la funzione che calcola i numeri amicabili:

(define (factor-group x)
  (if (= x 1) '(1 1)
    (letn (fattori (factor x)
          unici (unique fattori))
      (transpose (list unici (count unici fattori)))
    )
  )
)

(factor-group 220)
;-> ((2 2) (5 1) (11 1))

(factor-group 1)
;-> (1 1)

(define (somma-divisori-propri-fast n)
  (if (= n 1) '0
    (begin (setq res 1)
     (setq lst (factor-group n))
     (dolist (el lst)
       (setq somma-el 0)
       (for (i 0 (last el))
         (setq somma-el (+ somma-el (pow (first el) i)))
       )
       (setq res (* res somma-el))
     )
     (- res n)) ;somma divisori propri (tutti tranne se stesso)
  )
)

(somma-divisori-propri-fast 220)
;-> 284

(somma-divisori-propri-fast 284)
;-> 220

(somma-divisori-propri-fast 1)
;-> 0

Scriviamo la funzione richiesta dal problema:

(define (e021-2)
  (setq _res 0)
  (for (j 2 9999)
      (setq spd (somma-divisori-propri-fast j))
      (setq spd2 (somma-divisori-propri-fast spd))
      (if (and (= j spd2) (!= spd spd2))
            (begin
              (setq _res (+ _res spd spd2))
              ;(println j { } spd { } spd2)
            )
      )
  )
  (/ _res 2)
)

(e021-2)
;-> 31626

(time (e021-2))
;-> 122.883

la funzione "e021-fast" è tre volte più veloce della funzione "e021".
----------------------------------------------------------------------------


===========
Problema 22
===========

Punteggio dei nomi

Usando "names.txt", un file di testo 46K contenente oltre cinquemila nomi, inizia crando una lista dei nomi in ordine alfabetico. Quindi, calcolando il valore alfabetico per ciascun nome, moltiplica questo valore per la sua posizione alfabetica nella lista per ottenere un punteggio del nome.

Ad esempio, quando la lista è ordinata in ordine alfabetico, COLIN, che vale 3 + 15 + 12 + 9 + 14 = 53, è il 938-esimo nome nell'elenco. Quindi, COLIN otterrebbe un punteggio di 938 × 53 = 49714.

Qual è il totale di tutti i punteggi dei nomi contenuti nel file?
============================================================================

Il file ha questa struttura:
"MARY","PATRICIA","LINDA",...

Rimuoviamo tutti i caratteri doppio-apice "":

(define (remove-char c from-file to-file)
    (set 'in-file (open from-file "read"))
    (set 'out-file (open to-file "write"))
    (while (set 'chr (read-char in-file))
        (if (!= chr c)
          (write-char out-file chr)))
    (close in-file)
    (close out-file)
    "fatto")

(char {"})
;-> 34

(char 34)
;-> "\""

(remove-char 34 "p022_nomi.txt" "nomi22.txt")

Il file adesso ha questa struttura:

MARY,PATRICIA,LINDA,...

Importiamo il file in una lista di stringhe:

(silent (setq nomi (parse (read-file "nomi22.txt") ",")))

Vediamo i primi cinque nomi:

(slice nomi 0 5)
;-> ("MARY" "PATRICIA" "LINDA" "BARBARA" "ELIZABETH")

Ordiniamo la lista:

(silent (sort nomi))

Vediamo i primi cinque nomi:

(slice nomi 0 5)
;-> ("AARON" "ABBEY" "ABBIE" "ABBY" "ABDUL")

Vediamo dove si trova "COLIN":

(ref "COLIN" nomi )
;-> 937

Quindi dobbiamo aggiungere 1 all'indice della lista (+ $idx 1).
Adesso creiamo una lista associativa (association list) tra i caratteri e il numero del relativo ordine.

(setq alfa  '(("A" 1) ("B" 2) ("C" 3) ("D" 4) ("E" 5) ("F" 6) ("G" 7) ("H" 8) ("I" 9) ("J" 10) ("K" 11) ("L" 12) ("M" 13) ("N" 14) ("O" 15) ("P" 16) ("Q" 17) ("R" 18) ("S" 19) ("T" 20) ("U" 21) ("V" 22) ("W" 23) ("X" 24) ("Y" 25) ("Z" 26)))

(lookup '"A" alfa)
;-> 1

(define (e022)
  (local (somma nomesomma nome$)
    (setq somma 0)
    (dolist (el nomi)
      (setq nome$ (explode el))
      (setq nomesomma 0)
      (dolist (c nome$)
        (setq nomesomma (add nomesomma (lookup c alfa)))
      )
      (setq nomesomma (mul nomesomma (+ $idx 1)))
      (setq somma (add somma nomesomma))
    )
  )
)

(e022)
;-> 871198282

(time (e022))
;-> 20.016
----------------------------------------------------------------------------


===========
Problema 23
===========

Somma numeri non abbondanti

Un numero perfetto è un numero per il quale la somma dei relativi divisori è esattamente uguale al numero. Ad esempio, la somma dei divisori propri di 28 sarebbe 1 + 2 + 4 + 7 + 14 = 28, il che in dica che 28 è un numero perfetto.

Un numero n è chiamato carente se la somma dei suoi divisori è inferiore a n e viene chiamato abbondante se questa somma supera n.

Dato che 12 è il numero abbondante più piccolo, 1 + 2 + 3 + 4 + 6 = 12, il numero più piccolo che può essere scritto come somma di due numeri abbondanti è 24. Con l'analisi matematica, si può dimostrare che tutti gli interi superiori a 28123 possono essere scritti come somma di due numeri abbondanti. Tuttavia, questo limite superiore non può essere ulteriormente ridotto dall'analisi anche se è noto che il più grande numero che non può essere espresso come somma di due numeri abbondanti è inferiore a questo limite.

Trovare la somma di tutti i numeri interi positivi che non possono essere scritti come la somma di due numeri abbondanti.
============================================================================

Funzione che calcola la somma di tutti i divisori propri (tutti i divisori tranne se stesso) di un numero :
(vedi problema 21)

(define (factor-group x)
  (if (= x 1) '(1 1)
    (letn (fattori (factor x)
          unici (unique fattori))
      (transpose (list unici (count unici fattori)))
    )
  )
)

(define (somma-divisori-propri-fast n)
  (if (= n 1) '0
    (begin (setq res 1)
     (setq lst (factor-group n))
     (dolist (el lst)
       (setq somma-el 0)
       (for (i 0 (last el))
         (setq somma-el (+ somma-el (pow (first el) i)))
       )
       (setq res (* res somma-el))
     )
     (- res n)) ;somma divisori propri (tutti tranne se stesso)
  )
)

(somma-divisori-propri-fast 284235235345)
;-> 59865475031

Funzione che cerca una coppia di numeri in un vettore che sommano a num.
Questa funzione ha complessità temporale O(nlog(n)).

(define (trovaCoppia vec num)
  (local (low high a b out)
    ; ordina il vettore in ordine crescente
    (sort vec)
    ; indici che puntano all'inizio e alla fine dell'array
    (setq low 0)
    (setq high (- (length vec) 1))
    (while (and (< low high) (= out nil))
      (setq a (vec low))
      (setq b (vec high))
      ; vale anche la coppia formata dallo stesso numero ripetuto
      ; altrimenti il risultato vale: 4179935
      (if (or (= num (add a b)) (= num (add a a)) (= num (add b b)))
          ; coppia trovata
          (setq out true)
      )
      (if (< (add (vec low) (vec high)) num)
          ; incrementa l'indice basso se il totale è minore della somma
          (++ low)
          ; decrementa indice alto se è totale è maggiore della somma
          (-- high)
      )
    )
    out
  );local
)

(setq lst '( 123 73 64 7 8 6 5 4 3 4 5 6 7 ))
(setq v (array (length lst) lst))
(array? v)
;-> true

(trovaCoppia v 130)
;-> true

(trovaCoppia v 230)
;-> nil

(trovaCoppia v 246)
;-> true

Funzione che crea la lista dei numeri abbondanti fino al numero 28123.

(define (creaAbbondanti)
  (local (out)
    (setq out '())
    (for (i 1 28123)
      (if (< i (somma-divisori-propri-fast i))
        (push i out)
      )
    )
    out
  )
)

(silent (setq abbo (creaAbbondanti)))
(time (setq abbo (creaAbbondanti)))

(length abbo)
;-> 6965
(sort abbo)

(slice abbo 0 30)
;-> (12 18 20 24 30 36 40 42 48 54 56 60 66 70 72 78 80 84 88 90 96 100 102 104 108 112 114 120 126 132)

Adesso possiamo scrivere la funzione che trova i numeri richiesti dal problema:

(define (e023)
  (local (abbo-lst abbo somma out)
    (setq out '())
    (setq somma 0)
    (setq abbo-lst (creaAbbondanti))
    (setq abbo (array (length abbo-lst) abbo-lst))
    (for (i 1 28123)
      (if (not (trovaCoppia abbo i))
        (begin
          (setq somma (add somma i))
          (push i out -1)
        )
      )
    )
    (println somma)
    out
  )
)

(silent (setq res (e023)))
;-> 4179871

(slice res 0 100)
;-> (1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 25 26 27 28 29 31 33
;->  34 35 37 39 41 43 45 46 47 49 51 53 55 57 59 61 63 65 67 69 71 73 75 77 79 81 83
;->  85 87 89 91 93 95 97 99 101 103 105 107 109 111 113 115 117 119 121 123 125 127
;->  129 131 133 135 137 139 141 143 145 147 149 151 153 155 157 159 161 163 165 167
;->  169)

Sopra a 50 i numeri della somma sono tutti dispari, quindi dividiamo il ciclo for in due parti:

(define (e023)
  (local (abbo-lst abbo somma)
    (setq somma 0)
    (setq abbo-lst (creaAbbondanti))
    (setq abbo (array (length abbo-lst) abbo-lst))
    (for (i 1 50)
      (if (not (trovaCoppia abbo i))
          (setq somma (add somma i))
      )
    )
    (for (i 51 28123 2)
      (if (not (trovaCoppia abbo i))
          (setq somma (add somma i))
      )
    )
    somma
  )
)

(e023)
;-> 4179871

(time (e023))
;-> 40900.186 ; circa 41 secondi
----------------------------------------------------------------------------


===========
Problema 24
===========

Permutazioni lessicografiche

Una permutazione è una disposizione ordinata di oggetti. Ad esempio, 3124 è una possibile permutazione delle cifre 1, 2, 3 e 4. Se tutte le permutazioni sono ordinate numericamente o alfabeticamente, vengono chiamate in ordine lessicografico. Le permutazioni lessicografiche di 0, 1 e 2 sono:

012 021 102 120 201 210

Qual è la milionesima permutazione lessicografica delle cifre 0, 1, 2, 3, 4, 5, 6, 7, 8 e 9?
============================================================================

Definiamo la funzione che genera le permutazioni:

(define (seq start end)
  (if (= start end)
      (list end)
      (cons start (seq (+ start 1) end))))

(define (insert l n e)
  (if (= 0 n)
      (cons e l)
      (cons (first l)
            (insert (rest l) (- n 1) e))))

(define (permute l)
  (if (null? l) '(())
      (apply append (map (lambda (p)
                           (map (lambda (n) (insert p n (first l))) (seq 0 (length p))))
                         (permute (rest l))))))

Scriviamo la funzione finale:

(define (e024)
  (setq p (sort (permute '(0 1 2 3 4 5 6 7 8 9))))
  (int (join (map string (p 999999))))
)

Abbiamo ordinato le permutazioni poichè non vengono create in ordine lessicografico.

(e024)
;-> 2783915460

(time (e024))
;-> 25309.091  ;circa 25 secondi
----------------------------------------------------------------------------


===========
Problema 25
===========

Numero di Fibonacci a 1000 cifre

La sequenza di Fibonacci è definita dalla relazione di ricorrenza:

Fn = Fn-1 + Fn-2, dove F1 = 1 e F2 = 1.
Quindi i primi 12 termini saranno:

F1 = 1
F2 = 1
F3 = 2
F4 = 3
F5 = 5
F6 = 8
F7 = 13
F8 = 21
F9 = 34
F10 = 55
F11 = 89
F12 = 144

Il dodicesimo termine, F12, è il primo termine a contenere tre cifre.

Qual è l'indice del primo termine nella sequenza di Fibonacci che contiene 1000 cifre?
============================================================================

Funzione per calcolare i numeri di Fibonacci:

(define (fibo-i n)
  (local (a b c)
    (setq a 0L b 1L c 0L)
    (for (i 0 (- n 1))
      (setq c (+ a b))
      (setq a b)
      (setq b c)
    )
    a
  )
)

(fibo-i 12)
;-> 144L
(length (fibo-i 12))
;-> 3

(define (e025)
  (local (trovato num)
    (setq num 1)
    (while (not trovato)
      (if (> (length (fibo-i num)) 999)
        (setq trovato true)
      )
      (++ num)
    )
    (-- num)
  )
)

(e025)
;-> 4782

(time (e025))
;-> 4925.875
----------------------------------------------------------------------------


===========
Problema 26
===========

Periodo dei numeri reciproci

Una frazione unitaria contiene 1 nel numeratore. La rappresentazione decimale delle frazioni unitarie con i denominatori da 2 a 10 è data:

1/2 =  0.5
1/3 =  0.(3)
1/4 =  0.25
1/5 =  0.2
1/6 =  0.1(6)
1/7 =  0.(142857)
1/8 =  0.125
1/9 =  0.(1)
1/10 = 0.1

Dove 0.1 (6) significa 0.166666 ... e ha un ciclo ricorrente di 1 cifra. Si può vedere che 1/7 ha un ciclo ricorrente di 6 cifre.

Trova il valore di d <1000 per cui 1 / d contiene il ciclo ricorrente più lungo nella sua parte della frazione decimale.
============================================================================

Calcoliamo i resti della divisione, quando troviamo lo stesso resto per la seconda volta, allora abbiamo trovato un ciclo (se il rsto è diverso da zero.
La lunghezza del ciclo è uguale alla distanza in cui si trovano i due valori uguali di resto.

Esempio: 1/14

(% 1 14)
;-> 1
(% 10 14)
;-> 10
(% 100 14)
;-> 2
(% 1000 14)
;-> 6
(% 10000 14)
;-> 4
(% 100000 14)
;-> 12
(% 1000000 14)
;-> 8
(% 10000000 14)
;-> 10 ; il numero 10 è stato già trovato ==> stop

La lista vale: (1 10 2 6 4 12 8 10)

La distanza tra i due numeri 10 è la differenza tra gli indici: 7 - 1 = 6.
Se i due numeri uguali del resto valgono 0, allora il reciproco non ha cicli.

Adesso possiamo scrivere la funzione che calcola la lunghezza del ciclo del reciproco di un numero:

(define (ciclo n)
  (local (trovato lst resto len-ciclo idx)
    (setq lst '())
    (setq pot 1)
    (while (not trovato)
      (setq resto (% pot n))
      (if (= (find resto lst) nil ) (push resto lst -1)
          (begin
            (setq trovato true)
            (push resto lst -1)
            (setq idx (ref-all resto lst))
            (setq len-ciclo (- (first (last idx)) (first (first idx))))
          )
      )
      (setq pot (* 10L pot))
      ;(println pot)
    )
    ;se i numeri uguali del resto valgono 0, allora il ciclo vale 0.
    (if (= resto 0) (setq len-ciclo 0))
    ;(list len-ciclo lst (div 1 n))
    (list len-ciclo (div 1 n))
  )
)

(ciclo 14)
;-> (6 (1 10 2 6 4 12 8 10) 0.07142857142857143)

(ciclo 7)
;-> (6 (1 3 2 6 4 5 1) 0.1428571428571429)

(ciclo 2)
;-> (0 0.5)

(ciclo 3)
;-> (1 0.3333333333333333)

(ciclo 983)
;-> (982 0.001017293997965412)

(define (e026)
  (local (num maxciclo)
    (setq maxciclo 0)
    (for (i 1 1000)
      (setq c (ciclo i))
      (if (> c maxciclo)
        (setq maxciclo c num i)
      )
    )
    (list num maxciclo)
  )
)

(e026)
;-> (983 (982 0.001017293997965412))

(time (e026))
;-> 488.049
----------------------------------------------------------------------------


===========
Problema 27
===========

Eulero scoprì la notevole formula quadratica:  n^2 + n + 41

La formula produce 40 numeri primi per i valori interi consecutivi 0≤n≤39. Tuttavia, quando n = 40, 40^2 + 40 + 41 = 40 (40 + 1) + 41 è divisibile per 41, e certamente quando n = 41, 41^2 + 41 + 41 è chiaramente divisibile per 41.

È stata scoperta l'incredibile formula n^2 - 79n + 1601, che produce 80 numeri primi per i valori consecutivi 0≤n≤79. Il prodotto dei coefficienti, -79 e 1601, è -126479.

Considerando forme quadratiche del tipo:

n^2 + a*n + b, dove |a| < 1000 e |b| ≤ 1000

dove |n| è il valore assoluto di n

Per esempio: |11| = 11 e |-4| = 4

Trova il prodotto dei coefficienti, a e b, per l'espressione quadratica che produce il numero massimo di numeri primi per valori consecutivi di n, iniziando con n = 0.
============================================================================

(define (primo? n)
        (if (< n 2) nil
            (= 1 (length (factor n)))))

(define (e027)
  (local (aa bb num min_a max_a min_b max_b max_len primo lst)
    (setq min_a -999)
    (setq max_a 999)
    (setq min_b -1000)
    (setq max_b 1000)
    (for (a min_a max_a)
      (for (b min_b max_b)
        (setq primo true)
        (setq lst '())
        (setq num 1)
        (while primo
          (if (primo? (add (mul num num) (mul a num) b))
            (begin
              (push num lst)
              (if (> (length lst) max_len)
                (begin
                  (setq max_len (length lst))
                  (setq aa a)
                  (setq bb b)
                )
              )
              (++ num)
            )
          ;else
            (setq primo nil)
          );if
        );while
      );for
    );for
    (list (* aa bb) aa bb max_len)
  );local
)

(e027)
;-> (-59231 -61 971 71)

(time (e027))
;-> 2000.151

Proviamo a ricercare in un intervallo più grande (-10000 10000):

(define (test27 min_a max_a min_b max_b)
  (local (aa bb num max_len primo lst)
    (for (a min_a max_a)
      (for (b min_b max_b)
        (setq primo true)
        (setq lst '())
        (setq num 0)
        (while primo
          (if (primo? (add (mul num num) (mul a num) b))
            (begin
              (push num lst)
              (if (> (length lst) max_len)
                (begin
                  (setq max_len (length lst))
                  (setq aa a)
                  (setq bb b)
                )
              )
              (++ num)
            )
          ;else
            (setq primo nil)
          );if
        );while
      );for
    );for
    (list aa bb max_len)
  );local
)

(test27 -10000 10000 -10000 10000)
;-> (-79 1601 80)

Abbiamo trovato l'equazione presentata come esempio nel problema.

Facciamo un controllo:

(define (f n)
  (primo? (+ (* n n) (* (- 79) n) 1601)))

(f 2)

(count '(true) (map f (sequence 0 79)))
;-> (80)

(define (f1 n)
  (list (primo? (+ (* n n) (* (- 79) n) 1601)) (+ (* n n) (* (- 79) n) 1601)))

Proviamo ad eliminare la lista dei numeri primi ed usare solo un contatore per cercare di migliorare la velocità di esecuzione, inoltre :

(define (e027-2)
  (local (aa bb num min_a max_a min_b max_b max_len primo lst_len)
    (setq min_a -999)
    (setq max_a 999)
    (setq min_b -1000)
    (setq max_b 1000)
    (for (a min_a max_a)
      (for (b min_b max_b)
        (setq primo true)
        (setq lst_len 0)
        (setq num 0)
        (while primo
          (if (primo? (add (mul num num) (mul a num) b))
            (begin
              (++ lst_len)
              (if (> lst_len max_len)
                (begin
                  (setq max_len lst_len)
                  (setq aa a)
                  (setq bb b)
                )
              )
              (++ num)
            )
          ;else
            (setq primo nil)
          );if
        );while
      );for
    );for
    (list (* aa bb) aa bb max_len)
  );local
)

(e027-2)
;-> (-59231 -61 971 71)

(time (e027-2))
;-> 2015.211

Non abbiamo migliorato, sembra che il tempo dipenda quasi esclusivamente dai due cicli for :-)
----------------------------------------------------------------------------


===========
Problema 28
===========

Diagonale di numeri a spirale

Partendo dal numero 1 e spostandosi verso destra in senso orario, si forma una spirale 5 per 5 come segue:

21 22 23 24 25
20  7  8  9 10
19  6  1  2 11
18  5  4  3 12
17 16 15 14 13

Si può verificare che la somma dei numeri sulle diagonali sia 101:
(21 + 7 + 1 + 3 + 13 + 25 + 9 + 5 + 17) = 101 (l'elemento centrale (1) viene contato solo una volta).

Qual è la somma dei numeri sulle diagonali in una spirale 1001 per 1001 formata nello stesso modo?
============================================================================

Disegniamo una matrice più grande per poter individuare una funzione che possa generarer i valori dei numeri sulla diagonale in funzione della grandezza della matrice:

 73                      81
    43                49
       21 22 23 24 25
       20  7  8  9 10
       19  6  1  2 11
       18  5  4  3 12
       17 16 15 14 13
    37                31
 65                      57

(define (e028)
  (local (m somma a_d b_d b_s a_s alto_dx basso_dx basso_sx alto_sx)
    (setq m 1001)
    (setq somma 0)
    (setq a_d '())
    (setq b_d '())
    (setq a_s '())
    (setq b_s '())
    (for (i 1 (/ (- m 1) 2))
      (setq alto_dx (* (+ (* i 2) 1) (+ (* i 2) 1)))
      (setq basso_dx (- alto_dx (* 6 i)))
      (setq basso_sx (- alto_dx (* 4 i)))
      (setq alto_sx (- alto_dx (* 2 i)))
      ;(println alto_dx { } alto_sx { } basso_sx { } basso_dx)
      (push alto_dx a_d)
      (push basso_dx b_d)
      (push basso_sx b_s)
      (push alto_sx a_s)
    )
    (setq somma (+ (apply + a_d) (apply + a_s) (apply + b_d) (apply + b_s) 1))
  )
)

Con m = 5 e con l'espressione print attiva, otteniamo:

;-> 9 7 5 3
;-> 25 21 17 13
;-> 101

(e028)
;-> 669171001

(time (e028))
;-> 0
----------------------------------------------------------------------------


===========
Problema 29
===========

Potenze distinte

Considerare tutte le combinazioni intere di ab per 2 ≤ a ≤ 5 e 2 ≤ b ≤ 5:

2^2 = 4,  2^3 = 8,   2^4 = 16,  2^5 = 32
3^2 = 9,  3^3 = 27,  3^4 = 81,  3^5 = 243
4^2 = 16, 4^3 = 64,  4^4 = 256, 4^5 = 1024
5^2 = 25, 5^3 = 125, 5^4 = 625, 5^5 = 3125

Se vengono quindi posizionati in ordine numerico, con le eventuali ripetizioni rimosse, otteniamo la seguente sequenza di 15 termini distinti:

4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

Quanti termini distinti sono nella sequenza generata da a^b per 2 ≤ a ≤ 100 e 2 ≤ b ≤ 100?
============================================================================

(define (potenza n m)
  (setq pot 1L)
  (dotimes (x m)
    (setq pot (* pot n))
  )
)

(define (e029)
  ;(local (a b lst)
  (local (a b)
    (setq lst '())
    (for (a 2 100)
      (for (b 2 100)
        (push (potenza a b) lst)
      )
    )
    (setq lst (unique lst))
    (length lst)
  )
)

(e029)
;-> 9183

(time (e029))
;-> 140.608
----------------------------------------------------------------------------


===========
Problema 30
===========

Quinta potenza delle cifre

Sorprendentemente ci sono solo tre numeri che possono essere scritti come la somma delle quarte potenze delle loro cifre:

1634 = 1^4 + 6^4 + 3^4 + 4^4
8208 = 8^4 + 2^4 + 0^4 + 8^4
9474 = 9^4 + 4^4 + 7^4 + 4^4

La somma di questi numeri è 1634 + 8208 + 9474 = 19316.

Il numero 1 = 1^4 non viene incluso perchè non è una somma.

Trova la somma di tutti i numeri che possono essere scritti come somma delle quinte potenze delle loro cifre.
============================================================================

Funzione che estrae le cifre di un numero da sinistra verso destra:

(define (estraiCifre n)
  (local (cifra)
    (while (!= n 0)
      (setq cifra (% n 10))
      (setq n (/ n 10))
      (print cifra { })
    )
  )
)

(estraiCifre 1234)
;-> 4 3 2 1 " "

Precalcoliamo la quinta potenza di ogni cifra:

(setq pot5 (map (fn (x) (pow x 5)) '(0 1 2 3 4 5 6 7 8 9)))
;-> (0 1 32 243 1024 3125 7776 16807 32768 59049)

Funzione che calcola la somma delle quinte potenze di tutte le cifre di un numero:

(define (pot5Cifre n)
  (local (cifra somma)
    (setq somma 0)
    (while (!= n 0)
      (setq cifra (% n 10))
      (setq somma (+ somma (pot5 cifra)))
      (setq n (/ n 10))
    )
    somma
  )
)

(pot5Cifre 1634)
;-> 9044

Limite superiore:
max numero con 1 cifra = 9^5 = 56049
max numero con 2 cifre = 9^5 + 9^5 = 118098
max numero con 3 cifre = 9^5 + 9^5 + 9^5 = 177147
max numero con 4 cifre = 9^5 + 9^5 + 9^5 + 9^5 = 236196
max numero con 5 cifre = 9^5 + 9^5 + 9^5 + 9^5 + 9^5 = 295245
max numero con 6 cifre = 9^5 + 9^5 + 9^5 + 9^5 + 9^5 + 9^5 = 354294
max numero con 7 cifre = 9^5 + 9^5 + 9^5 + 9^5 + 9^5 + 9^5 + 9^5 = 413343

Quindi per essere sicuri di considerare tutti i numeri di cinque cifre formati dalla somma delle quinte potenze di ogni cifra occorre prendere il numero 295245 (perchè questo numero ha 6 cifre).

(* 5 (pow 9 5))
;-> 295245

(define (e030)
  (local (maxVal tot)
    (setq maxVal 295245)
    (setq tot 0)
    (for (i 2 maxVal)
      (setq x (pot5Cifre i))
      (if (= x i) (setq tot (+ tot x)))
    )
    tot
  )
)

(e030)
;-> 443839

(time (e030))
;-> 515.564
----------------------------------------------------------------------------


===========
Problema 31
===========

Somme di monete

In Inghilterra la moneta è composta da sterline "£" e pence "p" e ci sono in circolazione otto tipi di monete:

1p, 2p, 5p, 10p, 20p, 50p, £ 1 (100p) e £ 2 (200p)

È possibile arrivare a £ 2 nel modo seguente:

1 × £ 1 + 1 × 50p + 2 × 20p + 1 × 5p + 1 × 2p + 3 × 1p

In quanti modi diversi si può arrivare a £ 2 usando un numero qualsiasi di monete?
============================================================================

Soluzione forza-bruta:

(define (e031)
  (local (A B C D E F G q tot)
    (setq A (sequence 0 200))
    (setq B (sequence 0 200 2))
    (setq C (sequence 0 200 5))
    (setq D (sequence 0 200 10))
    (setq E (sequence 0 200 20))
    (setq F (sequence 0 200 50))
    (setq G (sequence 0 200 100))
    (setq q 1)
    (setq tot 200)
    (dolist (a A)
      (dolist (b B (> (+ a b) tot))
        (dolist (c C (> (+ a b c) tot))
          (dolist (d D (> (+ a b c d) tot))
            (dolist (e E (> (+ a b c d e) tot))
              (dolist (f F (> (+ a b c d e f) tot))
                (dolist (g G)
                  (if (= (+ a b c d e f g) tot) (++ q))
    )))))))
    q
  );local
)

(e031)
;-> 73682

(time (e031))
;-> 3009.901

Soluzione programmazione dinamica:

(define (e031)
  (local (totale monete modi)
    ; valore obiettivo
    (setq totale 200)
    ; lista dei tagli di monete disponibili
    (setq monete '(1 2 5 10 20 50 100 200))
    ; crea un vettore di totale elementi con tutti valori 0 tranne il primo (modi[0]) che vale 1
    (setq modi (array (+ totale 1) (extend '(1) (dup 0 totale))))
    (dolist (el monete)
      (for (i el totale)
        (setq (modi i) (+ (modi i) (modi (- i el))))
      )
    )
    (modi totale)
  )
)

(e031)
;-> 73682

(time (e031))
;-> 0.971
----------------------------------------------------------------------------


===========
Problema 32
===========

Prodotti Pandigitali

Diciamo che un numero con n cifre è pandigitale se fa uso di tutte le cifre da 1 a n esattamente una volta. Ad esempio, il numero a 5 cifre, 15234, è pandigitale da 1 a 5.

Il prodotto 7254 è inusuale, poiché l'identità 39 × 186 = 7254, contenente moltiplicando, moltiplicatore e prodotto è pandigitale da 1 a 9.

Trovare la somma di tutti i prodotti la cui identità in moltiplicando/moltiplicatore/prodotto è pandigitale da 1 a 9.

SUGGERIMENTO: alcuni prodotti possono essere ottenuti in più di un modo, quindi assicurati di includerlo solo una volta nella somma.
============================================================================

La seguente funzione verifica se un numero è pandigitale (1-9):

(define (pan? n)
  (cond ((or (< n 123456789) (> n 987654321) (!= 0 (% n 9))) nil)
        (true
          (let (lst '(0 -1 -1 -1 -1 -1 -1 -1 -1 -1))
            (while (!= n 0)
              (setf (lst (% n 10)) 1)
              (setq n (/ n 10))
            )
            ;(println lst)
            (if (ref '-1 lst) nil true)
          )
        )
  )
)

(pan? 391867254)
;-> true

(pan? 391877254)
;-> nil

Calcoliamo i limiti dei numeri coinvolti:

(* 999 99)
;-> 98901

(* 9999 9)
;-> 89991

999 * 99 = 98901 => 10 cifre (moltiplicando/moltiplicatore/prodotto)
9999 * 9 = 89991 => 10 cifre (moltiplicando/moltiplicatore/prodotto)

Quindi, il massimo valore del primo indice vale 99 e il massimo valore del secondo indice 9999. Si tratta di una stima grossolana che potrebbe essere migliorata.

Possiamo scrivere la soluzione:

(define (e032)
  (local (somma sol p)
    (setq sol '())
    (for (i 1 99)
      (for (j (+ i 1) 9999)
        (setq p (int (string i j (* i j))))
        (if (pan? p) (push (* i j) sol))
        ;(if (pan? p) (begin (push (* i j) sol) (println i { * } j { = } (* i j))))
      )
    )
    (setq sol (unique sol))
    (apply + sol)
  )
)

(e032)
;-> 45228

(time (e032))
;-> 1625.291

Ecco tutti i prodotti pandigitali:

 4 * 1738 = 6952
 4 * 1963 = 7852
12 *  483 = 5796 (a)
18 *  297 = 5346 (b)
27 *  198 = 5346 (b)
28 *  157 = 4396
39 *  186 = 7254
42 *  138 = 5796 (a)
48 *  159 = 7632

(+ 6952 7852 5796 5346 4396 7254 7632)
;-> 45228
----------------------------------------------------------------------------


===========
Problema 33
===========

Cancellazione di cifre nelle frazioni

La frazione 49/98 è una frazione curiosa, poiché un matematico inesperto nel tentativo di semplificarlo potrebbe erroneamente credere che 49/98 = 4/8, che è corretto, si ottiene cancellando le due cifre 9.

Considereremo frazioni come, 30/50 = 3/5, come esempi banali.

Esistono esattamente quattro esempi non banali di questo tipo di frazione, che hanno valore minore di 1, e contenenti due cifre nel numeratore e nel denominatore.

Se il prodotto di queste quattro frazioni viene ridotto ai minimi termini (semplificato), trovare il valore del denominatore.
============================================================================

Funzione che converte un numero intero in una lista:

(define (int2list n)
  (let (out '())
    (while (!= n 0)
      (push (% n 10) out)
      (setq n (/ n 10))
    )
    out
  )
)

La soluzione con la forza bruta è abbastanza semplice (e anche veloce):

(define (e033)
  (local (fraction frazione N D num numL den denL d d1 d2 n n1 n2 val)
    (setq fraction '())
    (for (num 11 100)
      (for (den (+ num 1) 100)
        (setq val (div num den))
        (setq frazione 0)
        (setq denL (int2list den))
        (setq d1 (int (denL 0)))
        (setq d2 (int (denL 1)))
        (setq numL (int2list num))
        (setq n1 (int (numL 0)))
        (setq n2 (int (numL 1)))
        (cond ((and (= n1 d2) (!= d1 0))
               (setq frazione (div n2 d1))
               (setq n n2)
               (setq d d1)
              )
              ((and (= n2 d1) (!= d2 0))
               (setq frazione (div n1 d2))
              )
              ((and (= n1 d1) (!= d2 0))
               (setq frazione (div n2 d2))
              )
              ((and (= n2 d2) (!= n2 0) (!= d1 0))
               (setq frazione (div n1 d1))
              )
        )
        (if (= frazione val) (push (list num den) fraction))
      )
    )
    (println fraction)
    (setq N (apply * (map first f)))
    (setq D (apply * (map last f)))
    (div D (gcd N D))
  );local
)

(e033)
;-> ((49 98) (26 65) (19 95) (16 64))
;-> 100

(time (e033))
;-> 31.235

Le quattro frazioni sono: 16/64 (1/4), 26/65 (2/5), 19/95 (1/5) e 49/98 (4/8).

Anche in questo problema possiamo utilizzare la matematica per trovare un algoritmo migliore.
Si può dimostrare che ogni frazione della soluzione deve essere della forma:

10*n + i    n
-------- = ---
10*i + d    d

dove numeratore "n" e denominatore "d" soddisfano la relazione: 1 <= n < d <= 9
e la variabile da eliminare "i" soddisfa la relazione: 1 <= i <= 9

Per evitare di utilizzare divisoni, troveremo le soluzioni verificando se vale l'uguaglianza:

d*(10*n + i) = n*(10*i + d)

(define (e033)
  (local (den num numtot dentot)
    (setq numtot 1 dentot 1)
    (for (i 1 9)
      (setq den 1)
      (while (< den i)
        (setq num 1)
        (while (< num den)
          (if (= (* den (+ (* num 10) i)) (* num (+ (* 10 i) den)))
            (begin
              (setq dentot (* dentot den))
              (setq numtot (* numtot num))
              ;(println num i {/} i den)
            )
          )
          (++ num)
        )
        (++ den)
      )
    )
    (/ dentot (gcd numtot dentot))
  )
)

(e033)
;-> 100

(time (e033))
;-> 0
----------------------------------------------------------------------------


===========
Problema 34
===========

Cifre fattoriali

145 è un numero curioso, poichè 1! + 4! + 5! = 1 + 24 + 120 = 145.

Trovare la somma di tutti i numeri che sono uguali alla somma del fattoriale delle loro cifre.

Nota: poichè 1! = 1 e 2! = 2 non sono somme, allora non vengono inclusi.
============================================================================

Precalcoliamo il fattoriale delle cifre 0..9:

(define (fact n) (if (= n 0) 1 (apply * (sequence 1 n))))

(setq fact-lst (map (fn(n) (fact n)) (sequence 0 9)))
;-> (1 1 2 6 24 120 720 5040 40320 362880)

Limiti dei numeri
Il numero 3 potrebbe andar bene, ma poiché il fattoriale di un numero di una cifra - eccetto 3 - ha sempre più di una cifra, allora possiamo iniziare con 10.
Il calcolo del limite superiore è un pò più complicato.
Se prendiamo un numero n con "d" cifre, possiamo scrivere:

 10^(d-1) <= n < 10^d

Per formare il numero massimo di "d" cifre dobbiamo utilizzare tutti 9, e la somma delle sue cifre fattoriali sarebbe d*9!, quindi:

 10^(d-1) <= d*9! < 10^d

Provando alcuni valori di "d" notiamo che 9!*7 = 2540160. Non esiste un valore più alto, poiché sia 9!*8 che 9!*9 generano ugualmente numeri di 7 cifre (9!*8 = 2903040, 9!* = 93265920). Quindi il numero 9999999 genera 7*9! = 2540160.

(define (e034)
  (local (fact-lst somma sol n)
    (setq fact-lst '(1 1 2 6 24 120 720 5040 40320 362880))
    (setq sol '())
    (for (i 10 2540160)
      (setq somma 0)
      (setq n i)
      (while (!= n 0)
        (setq somma (+ somma (fact-lst (% n 10))))
        (setq n (/ n 10))
      )
      (if (= somma i) (push i sol))
    )
    (list (apply + sol) sol)
  )
)

(e034)
;-> (40730 (40585 145))

(time (e034))
;-> 3797.395
----------------------------------------------------------------------------


===========
Problema 35
===========

Numeri primi circolari

Il numero, 197, è chiamato primo circolare perché tutte le rotazioni delle cifre: 197, 971 e 719, sono esse stesse prime.

Ci sono tredici tali numeri primi sotto 100: 2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79 e 97.

Quanti numeri primi circolari ci sono sotto un milione?
============================================================================

Abbiamo bisogno delle seguenti funzioni ausiliarie:

Verifica se un numero è primo:

(define (primo? n)
        (if (< n 2) nil
            (= 1 (length (factor n)))))

Converte un numero intero in una lista:

(define (int2list n)
  (let (out '())
    (while (!= n 0)
      (push (% n 10) out)
      (setq n (/ n 10))
    )
    out
  )
)

Converte una lista in un numero intero:

(define (list2int lst)
  (let (n 0)
    (for (i 0 (- (length lst) 1))
      (setq n (+ n (* (lst i) (pow 10 (- (length lst) i 1)))))
    )
  )
)

Crea una lista con tutte le rotazioni della lista passata:

(define (creaRotate lst)
  (let (out '())
    ;(for (i 1 (- (length lst) 1))
    (for (i 1 (length lst))
      (push (rotate lst) out)
    )
    out
  )
)

(apply + '(1 2 3 1 2 3) 3)
;-> 15
(creaRotate '(2))
;-> ((2))

(creaRotate '(1 2 3))
;-> ((1 2 3) (2 3 1) (3 1 2))

Adesso definiamo la funzione che risolve il problema:

(define (e035)
  (local (primicirco candidate stop k)
    (setq primicirco '(2)) ;lista risultato
    (setq candidate '())   ;lista rotazioni
    (for (i 3 999999 2)    ;solo numeri pari
      (if (primo? i)
        (begin
          ; creiamo la lista di tutti numeri ruotati del numero i
          (setq candidate (creaRotate (int2list i)))
          (setq stop nil)
          (setq k 0)
          (while (and (< k (length candidate)) (= stop nil))
            (if (!= k 0) ;il primo numero è sempre primo
              ;stop quando un numero della lista candidati non è primo
              (if (not (primo? (list2int (candidate k)))) (setq stop true))
            )
            (++ k)
          )
          ; se tutti i numeri nella lista candidati sono primi
          ; aggiungiamo la lista al risultato
          (if (= stop nil) (push (list2int (candidate (- k 1))) primicirco))
        )
      );if
    );for
    (list (length primicirco) primicirco)
  );local
)

(e035)
;-> (55 (199933 999331 193939 393919 993319 391939 939391 939193 933199 331999 319993
;->      919393 19937 19391 99371 39119 37199 93911 93719 71993 11939 91193 7937 1931 7793
;->      3779 9377 9311 1193 3119 199 197 991 373 971 337 733 131 919 719 113 311 79 97
;->      37 17 73 13 71 31 11 7 5 3 2))

(time (e035))
;-> 1266.715
----------------------------------------------------------------------------


===========
Problema 36
===========

Palindromi a doppia base

Il numero decimale, 585 = 10010010012 (binario), è palindromo in entrambe le basi.

Trova la somma di tutti i numeri, sotto al milione, che sono palindromi in base 10 e in base 2.

(Si noti che il numero palindromo, in entrambe le basi, non include gli zeri iniziali.)
============================================================================

Funzioni ausiliarie

Questa funzione controlla se un numero è palindromo:

(define (paliN n)
  (= (string n) (reverse (string n))))

(paliN 113311)
;-> true

(paliN 1123311)
;-> nil

Questa funzione controlla se una stringa è palindroma:

(define (paliS s)
  (= s (reverse (copy s))))

(paliS "1234321")
;-> true

(paliS "51234321")
;-> nil

Nota: I numeri pari non sono mai palindromi in base 2, perchè il bit a destra vale sempre 0 e il bit a sinistra vale sempre 1.

Nota: per controllare se un numero in base 2 è palindromo occorre utilizzare una stringa per rappresentarlo, perchè altrimenti il numero dovrebbe essere un big integer (con L alla fine).

La funzione finale è la seguente:

(define (e036)
  (let (somma 0)
    (for (i 1 999999 2) ;nessun numero pari palindromo in base 2
      (if (and (paliN i) (paliS (bits i)))
        (begin
          (setq somma (+ somma i))
          ;(println i { - } (bits i))
        )
      )
    )
    somma
  )
)

(e036)
;-> 872187

(time (e036))
;-> 1442.523

I numeri palindromi in entrambe le basi sono:

1 - 1
3 - 11
5 - 101
7 - 111
9 - 1001
33 - 100001
99 - 1100011
313 - 100111001
585 - 1001001001
717 - 1011001101
7447 - 1110100010111
9009 - 10001100110001
15351 - 11101111110111
32223 - 111110111011111
39993 - 1001110000111001
53235 - 1100111111110011
53835 - 1101001001001011
73737 - 10010000000001001
585585 - 10001110111101110001
----------------------------------------------------------------------------


===========
Problema 37
===========

Numeri primi troncabili

Il numero 3797 ha una proprietà interessante. Essendo primo se stesso, è possibile rimuovere continuamente i numeri da sinistra a destra, e rimanere primo in ogni fase: 3797, 797, 97 e 7. Allo stesso modo possiamo lavorare da destra a sinistra: 3797, 379, 37 e 3.

Trova la somma degli unici undici numeri primi che sono entrambi troncabili da sinistra a destra e da destra a sinistra.

NOTA: 2, 3, 5 e 7 non sono considerati numeri primi troncabili.
============================================================================

(define (creaTruncate lst)
  (let (out '())
    ; da destra
    (for (i 1 (- (length lst) 1))
      (push (slice lst 0 i) out)
    )
    ; da sinistra
    (for (i 1 (- (length lst) 1))
      (push (slice lst i) out)
    )
    out
  )
)

(setq lst '(3 7 9 7))

(creaTruncate lst)
;-> ((7) (9 7) (7 9 7) (3 7 9) (3 7) (3))

(define (int2list n)
  (let (out '())
    (while (!= n 0)
      (push (% n 10) out)
      (setq n (/ n 10))
    )
    out
  )
)

(define (list2int lst)
  (let (n 0)
    (for (i 0 (- (length lst) 1))
      (setq n (+ n (* (lst i) (pow 10 (- (length lst) i 1)))))
    )
  )
)

(define (primo? n)
  (if (= n 2) true
      (if (even? n) nil
          (if (< n 2) nil
              (= 1 (length (factor n)))))))

(define (e037)
  (local (primitrunca candidate trovati stop k i)
    (setq primitrunca '()) ;lista risultato
    (setq candidate '())   ;lista troncati
    (setq trovati 0)
    (setq i 11)
    (while (< trovati 11)
      (if (primo? i)
        (begin
          (setq candidate (creaTruncate (int2list i)))
          (setq stop nil)
          (setq k 0)
          (while (and (< k (length candidate)) (= stop nil))
            (if (not (primo? (list2int (candidate k)))) (setq stop true))
            (++ k)
          )
          (if (= stop nil)
            (begin
              ;(push (list2int (candidate (- k 1))) primitrunca)
              (push i primitrunca)
              (++ trovati)
            )
          )
        )
      );if
      (setq i (+ i 2))
      (if (= 0 (% i 10000)) (println i))
    );while
    (list (apply + primitrunca) primitrunca)
  );local
)

(e037)
;-> (748317 (739397 3797 3137 797 373 317 313 73 53 37 23))

(time (e037))
;-> 939.055

Proviamo a velocizzare l'algoritmo della funzione.
Considerazioni:
- non abbiamo bisogno di una lista per il risultato: basta usare una variabile (somma).
- non abbiamo bisogno di una lista per i numeri troncati: possiamo testarli appena generati.

Definiamo una funzione che controlla se un numero è truncabile a sinistra:

(define (truncaSX n)
  (local (i stop)
    (setq i 10)
    (while (and (<= i n) (= stop nil))
      (if (not (primo? (% n i))) (setq stop true))
      (setq i (* i 10))
    )
    (not stop)
  )
)

(truncaSX 3797)
;-> true

Definiamo una funzione che controlla se un numero è truncabile a destra:

(define (truncaDX n)
  (local (i stop)
    (setq i n)
    (while (and (!= 0 i) (= stop nil))
      (if (not (primo? i)) (setq stop true))
      (setq i (/ i 10))
    )
    (not stop)
  )
)

(truncaDX 3797)
;-> true

(define (e037)
  (local (trovati somma i)
    (setq somma 0)
    (setq i 11)
    (while (< trovati 11)
      (if (and (truncaDX i) (truncaSX i))
        (begin
          (setq somma (+ somma i))
          (++ trovati)
        )
      )
      (setq i (+ i 2))
    )
    somma
  )
)

(e037)
;-> 748317

(time (e037))
;-> 778.216
----------------------------------------------------------------------------


===========
Problema 38
===========

Multiplicazioni pandigitali

Prendi il numero 192 e moltiplicalo per i numeri 1, 2 e 3:

192 × 1 = 192
192 × 2 = 384
192 × 3 = 576

Concatenando ogni prodotto otteniamo il numero pandigitale da 1 a 9, 192384576. Chiameremo 192384576 il prodotto concatenato di 192 e (1,2,3)

Lo stesso può essere ottenuto iniziando con 9 e moltiplicando per 1, 2, 3, 4 e 5, che genera il pandigitale, 918273645, che è il prodotto concatenato di 9 e (1,2,3,4,5).

Qual è il più grande numero pandigitale da 1 a 9 (9 cifre) che può essere formato come prodotto concatenato di un numero intero con (1,2, ..., n) dove n > 1?
============================================================================

(define (pan? n)
  (cond ((or (< n 123456789) (> n 987654321) (!= 0 (% n 9))) nil)
        (true
          (let (lst '(0 -1 -1 -1 -1 -1 -1 -1 -1 -1))
            (while (!= n 0)
              (setf (lst (% n 10)) 1)
              (setq n (/ n 10))
            )
            ;(println lst)
            (if (ref '-1 lst) nil true)
          )
        )
  )
)

Per calcolare il limite superiore del ciclo basta considerare che con 10000 arriviamo a considerare numeri con 10 cifre (dobbiamo concatenare le stringhe delle moltiplicazioni), quindi questo valore è sufficiente.

(define (lim n)
  (length (append (string (* n 1)) (string (* n 2))))
)

(lim 9999)
;-> 9

(lim 10000)
;-> 10

(define (e038)
  (local (maxpandi theK theI pandisomma)
    (setq maxpandi 0)
    (setq theK 0)
    (setq theI 0)
    (for (k 1 10000)
      (setq pandisomma "")
      (for (i 1 9)
        (extend pandisomma (string (* k i)))
        (if (and (= (length pandisomma) 9) (> (int pandisomma) maxpandi) (pan? (int pandisomma)))
          (begin
            (setq maxpandi (int pandisomma))
            (setq theK k)
            (setq theI i)
          )
        )
      )
    )
    (list maxpandi theK theI)
  );local
)

(e038)
;-> (932718654 9327 2)

str(9327*1) + str(9327*2) = "932718654"

(time (e038))
;-> 93.757
----------------------------------------------------------------------------


===========
Problema 39
===========

Triangoli rettangoli interi

Se p è il perimetro di un triangolo rettangolo con lati di lunghezza intera, {a, b, c}, ci sono esattamente tre soluzioni per p = 120.

{20,48,52}, {24,45,51}, {30,40,50}

Per quale valore di p ≤ 1000, il numero di soluzioni è massimizzato?
============================================================================

(define (e039)
  (local (qmax lst a b p q)
    (setq qmax 0)
    (setq lst '())
    (for (p 12 1000 2)
      (setq q 0)
      (setq a 1)
      (while (< a (/ p 3))
        (setq b (+ a 1))
        (setq stop nil)
        (while (and (= stop nil) (< b (- p a)))
          (if (= (pow (- p a b) 2) (+ (* a a) (* b b)))
            (begin
              (++ q)
              (setq stop true)
            )
          )
          (++ b)
        )
        (++ a)
      )
      (if (> q qmax)
        (begin
          (setq lst (list p q))
          (setq qmax q)
        )
      )
    )
    lst
  );local
)

(e039)
;-> (840 8)

(time (e039))
;-> 13485.51
----------------------------------------------------------------------------


===========
Problema 40
===========

La costante di Champernowne

Una frazione decimale irrazionale viene creata concatenando gli interi positivi:

0.12345678910(1)112131415161718192021 ...

Si può vedere che la dodicesima cifra della parte frazionaria è (1).

Se d(n) rappresenta l'ennesima cifra della parte frazionaria, trovare il valore della seguente espressione:

d(1) × d(10) × d(100) × d(1000) × d(10000) × d(100000) × d(1000000)
============================================================================

La lunghezza della costante di Champernowne supera (di poco) il milione quando si arriva a concatenare il numero 186000:

(length (join (map string (sequence 0 186000))))
;-> 1004896

Quindi usiamo questo valore come limite per la creazione delle cifre del risultato:

(define (e040)
  (local (num cifre val x stop sol)
    (setq lst '())
    (setq stop nil)
    (setq num 1)
    (while (and (< num 186000) (= stop nil))
      (setq cifre (length (string num)))
      (setq val num)
      (for (i cifre 1 -1)
        (setq x (/ val (pow 10 (- i 1))))
        (setq val (- val (* x (pow 10 (- i 1)))))
        (push x lst -1)
      )
      ;(if (> (length lst) 1000000) (setq stop true))
      (++ num)
      ;(if (= (% num 10000) 0) (println num { } (length lst)))
    )
    (* (lst 0) (lst 9) (lst 99) (lst 999) (lst 9999) (lst 99999) (lst 999999))
  )
)

(e040)
;-> 210

(time (e040))
;-> 640.584

Proviamo un altro metodo, creiamo una stringa che contiene almeno 1000000 di cifre e poi calcoliamo il risultato della moltiplicazione:

(define (e040)
  (let (a$ (join (map string (sequence 1 186000))))
    (* (int (a$ 0)) (int (a$ 9)) (int (a$ 99)) (int (a$ 999)) (int (a$ 9999)) (int (a$ 99999)) (int (a$ 999999)))
  )
)

(e040)
;-> 210

(time (e040))
;-> 140.625
----------------------------------------------------------------------------


===========
Problema 41
===========

Primo Pandigitale

Diremo che un numero a una cifra è pandigitale se fa uso di tutte le cifre da 1 a n esattamente una volta. Ad esempio, 2143 è un pandigitale a 4 cifre ed è anche primo.

Qual è il più grande numero primo pandigitale ad n-cifre esistente?
============================================================================

I numeri pandigitali (0..9), quelli (1..9) e quelli (1..8) non sono primi perchè sono tutti divisibili per 9 (in quanto la somma delle loro cifre vale 9).
Quindi consideriamo solo i numeri pandigitali fino a 7 cifre.

Possiamo iniziare a creare tutte le permutazioni di 7 cifre e cercare il numero primo massimo (se esiste).
Poi potremmo passare ai numeri con 6 cifre, e via di questo passo.

Funzione per le permutazioni:

(define (rimuovi x lst)
  (cond
    ((null? lst) '())
    ((= x (first lst)) (rimuovi x (rest lst)))
    (true (cons (first lst) (rimuovi x (rest lst))))))

(define (permutazioni lst)
  (cond
    ((= (length lst) 1)(list lst))
    (true (apply append(map(lambda (i) (map (lambda (j)(cons i j))
                                            (permutazioni (rimuovi i lst)))) lst)))))

Funzione test numero primo:

(define (primo? n)
   (if (< n 2) nil
       (= 1 (length (factor n)))))

Scriviamo la funzione finale:

(define (e041)
  (local (perm num primi)
    ;crea le permutazioni
    (setq perm (permutazioni '("1" "2" "3" "4" "5" "6" "7")))
    ; crea la lista dei numeri
    (setq num (map (fn (x) (int (join x))) perm))
    ;filtra i numeri primi e poi cerca il valore massimo
    (apply max (filter primo? num))
  )
)

(e041)
;-> 7652413

(time (e041))
;-> 125.004
----------------------------------------------------------------------------


===========
Problema 42
===========

Numeri triangolari codificati

L'ennesimo termine della sequenza di numeri triangolari è dato da, t(n) = ½*n*(n + 1), quindi i primi dieci numeri di triangolari sono:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Convertendo ogni lettera di una parola in un numero corrispondente alla sua posizione alfabetica e aggiungendo questi valori formiamo un valore della parola. Ad esempio, il valore della parola per SKY è 19 + 11 + 25 = 55 = t10. Se il valore della parola è un numero triangolare, chiameremo la parola triangolo.

Usando il file "words.txt", un file di testo 16K contenente quasi duemila parole inglesi comuni, quante sono le parole triangolari?
============================================================================

Il file ha questa struttura:
"A","ABILITY","ABLE","ABOUT","ABOVE","ABSENCE","ABSOLUTELY",...

Rimuoviamo tutti i caratteri doppio-apice "":

(define (remove-char c from-file to-file)
    (set 'in-file (open from-file "read"))
    (set 'out-file (open to-file "write"))
    (while (set 'chr (read-char in-file))
        (if (!= chr c)
          (write-char out-file chr)))
    (close in-file)
    (close out-file)
    "fatto")

(char {"})
;-> 34

(char 34)
;-> "\""

(remove-char 34 "p042_words.txt" "words42.txt")

Il file adesso ha questa struttura:
A,ABILITY,ABLE,ABOUT,ABOVE,ABSENCE,ABSOLUTELY,

MARY,PATRICIA,LINDA,...

Importiamo il file in una lista di stringhe:

(silent (setq parole (parse (read-file "words42.txt") ",")))

Vediamo i primi cinque nomi:

(slice parole 0 5)
;-> ("A" "ABILITY" "ABLE" "ABOUT" "ABOVE")

Calcoliamo la lunghezza della parola più lunga:

(apply max (map length parole))
;-> 14

Il valore massimo di una parola vale 14 volte "Z";
(* 14 26)
;-> 364

Adesso creiamo una lista associativa (association list) tra i caratteri e il numero del relativo ordine:

(setq alfa  '(("A" 1) ("B" 2) ("C" 3) ("D" 4) ("E" 5) ("F" 6) ("G" 7) ("H" 8) ("I" 9) ("J" 10) ("K" 11) ("L" 12) ("M" 13) ("N" 14) ("O" 15) ("P" 16) ("Q" 17) ("R" 18) ("S" 19) ("T" 20) ("U" 21) ("V" 22) ("W" 23) ("X" 24) ("Y" 25) ("Z" 26)))

(lookup '"A" alfa)
;-> 1

Creiamo una lista di numeri triangolari (almeno fino a 364):

(setq tri (map (fn (n) (/ (* n (+ n 1)) 2)) (sequence 1 27)))
;-> (1 3 6 10 15 21 28 36 45 55 66 78 91 105 120 136 153 171 190 210 231 253 276 300 325 351 378)

Calcoliamo il valore della parola "ABILITY";

(setq valore 0)
(dolist (el (explode "ABILITY"))
  (setq valore (+ valore (lookup el alfa)))
)

;-> 78
A =  1
B =  2
I =  9
L = 12
I =  9
T = 20
Y = 25
   ----
    78

Vediamo se è un numero triangolare:

(ref 78 tri)
;-> (11)

Si tratta dell'undicesimo numero triangolare (se non fosse triangolare avremmo ottenuto nil dalla funzione "ref")

Possiamo scrivere la funzione finale:

(define (e042)
  (local (alfa tri valore out)
    (setq out 0)
    (setq alfa  '(("A" 1) ("B" 2) ("C" 3) ("D" 4) ("E" 5) ("F" 6) ("G" 7) ("H" 8) ("I" 9) ("J" 10) ("K" 11) ("L" 12) ("M" 13) ("N" 14) ("O" 15) ("P" 16) ("Q" 17) ("R" 18) ("S" 19) ("T" 20) ("U" 21) ("V" 22) ("W" 23) ("X" 24) ("Y" 25) ("Z" 26)))
    (setq tri (map (fn (n) (/ (* n (+ n 1)) 2)) (sequence 1 27)))
    (setq parole (parse (read-file "words42.txt") ","))
    (dolist (parola parole)
      (setq valore 0)
      (dolist (el (explode parola))
        (setq valore (+ valore (lookup el alfa)))
      )
      (if (ref valore tri) (++ out))
    )
    out
  )
)

(e042)
;-> 162

(time (e042))
;-> 31.244
----------------------------------------------------------------------------


===========
Problema 43
===========

Divisibilità sotto-stringhe

Il numero, 1406357289, è un numero da 0 a 9 pandigitale perché è composto da ciascuna delle cifre da 0 a 9 in un certo ordine, ma ha anche una proprietà di divisibilità della sotto-stringhe piuttosto interessante.

Sia d(1) la prima cifra, d(2) la seconda cifra e così via. In questo modo, notiamo quanto segue:

d(2)d(3)d(4) = 406 è divisibile per 2
d(3)d(4)d(5) = 063 è divisibile per 3
d(4)d(5)d(6) = 635 è divisibile per 5
d(5)d(6)d(7) = 357 è divisibile per 7
d(6)d(7)d(8) = 572 è divisibile per 11
d(7)d(8)d(9) = 728 è divisibile per 13
d(8)d(9)d(10) = 289 è divisibile per 17

Trovare la somma di tutti i numeri pandigital da 0 a 9 con questa proprietà.
============================================================================

Se d(4)d(5)d(6) è divisibile per 5, allora d(6) deve valere 5 (d(5) se zero-based).

(define (list2int lst)
  (let (n 0)
    (for (i 0 (- (length lst) 1))
      (setq n (+ n (* (lst i) (pow 10 (- (length lst) i 1)))))
    )
  )
)

(define (insert l n e)
  (if (= 0 n)
      (cons e l)
      (cons (first l)
            (insert (rest l) (- n 1) e))))

(define (seq start end)
  (if (= start end)
      (list end)
      (cons start (seq (+ start 1) end))))

(define (permute l)
  (if (null? l) '(())
      (apply append (map (lambda (p)
                           (map (lambda (n) (insert p n (first l))) (seq 0 (length p))))
                         (permute (rest l))))))

(define (e043)
  (local (numeri p10 a)
    (setq numeri '())
    (setq p10 (permute '(0 1 2 3 4 6 7 8 9)))
    (dolist (p p10)
      (if (!= (p 0) 0) ;scartare le permutazioni che iniziano con 0
        (begin
          (push 5 p 5) ; p(5) deve valere 5
          (setq n1 (+ (* (p 1) 100) (* (p 2) 10) (p 3)))
          (setq n2 (+ (* (p 2) 100) (* (p 3) 10) (p 4)))
          (setq n3 (+ (* (p 3) 100) (* (p 4) 10) (p 5)))
          (setq n4 (+ (* (p 4) 100) (* (p 5) 10) (p 6)))
          (setq n5 (+ (* (p 5) 100) (* (p 6) 10) (p 7)))
          (setq n6 (+ (* (p 6) 100) (* (p 7) 10) (p 8)))
          (setq n7 (+ (* (p 7) 100) (* (p 8) 10) (p 9)))
          (if (and (= (% n1 2) 0) (= (% n2 3) 0) (= (% n3 5) 0) (= (% n4 7) 0)
                   (= (% n5 11) 0) (= (% n6 13) 0) (= (% n7 17) 0))
              (push (list2int p) numeri)
          )
        )
      )
    )
    (list (apply + numeri) numeri)
  )
)

(e043)
;-> (16695334890 (4130952867 1430952867 4160357289 4106357289 1460357289 1406357289))

(time (e043))
;-> 1748.593
----------------------------------------------------------------------------


===========
Problema 44
===========

Numeri pentagonali

I numeri pentagonali sono generati dalla formula, P(n) = n*(3n-1)/2. I primi dieci numeri pentagonali sono:

1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

Si può vedere che P4 + P7 = 22 + 70 = 92 = P8. Tuttavia, la loro differenza, 70 - 22 = 48, non è pentagonale.

Trovare la coppia di numeri pentagonali, P(j) e P(k), per cui la loro somma e differenza sono pentagonali e D = |P(k) - P(j)| è ridotto al minimo: qual è il valore di D?
============================================================================

P(n) n-esimo numero pentagonale
N = numero dato

Affinchè un numero N sia pentagonale deve risultare:

P(n) = N  ==>  (3*n*n - n - 2*N) = 0  ==>  n = (1 + sqrt(24*N + 1))/6

Prima versione:

(define (penta? n)
  (let (i (div (add (sqrt (add 1 (mul 24 n))) 1) 6))
    (if (= 0 (sub i (int i))) true nil)
  )
)

Seconda versione (più veloce):

(define (penta? n)
; molto più veloce che cercare nella lista dei numeri pentagonali
  (if (= (mod (div (add (sqrt (+ 1 (mul 24 n))) 1) 6) 1) 0) true nil)
)

(penta? 176)
;-> true

(define (e044)
  (local (n penta stop i j out)
    (setq out nil)
    (setq penta (map (fn (n) (/ (* n (- (* 3 n) 1)) 2)) (sequence 1 10000)))
    (setq stop nil)
    (dolist (i penta (= stop true))
      (dolist (j penta (= stop true))
        (if (and (penta? (+ i j)) (penta? (abs (- i j))))
          (begin
            (setq stop true)
            (setq out (list i j (- j i)))
          )
        )
      )
    )
    out
  )
)

(e044)
;-> (1560090 7042750 5482660)

(time (e044))
;-> 5588.505
----------------------------------------------------------------------------


===========
Problema 45
===========

Triangolari, pentagonali ed esagonali

I numeri triangolari, pentagonali ed esagonali sono generati dalle seguenti formule:

Triangolari T(n) = n*(n + 1)/2 ==> 1, 3, 6, 10, 15, ...
Pentagonala P(n) = n*(3*n-1)/2 ==> 1, 5, 12, 22, 35, ...
Esagonale   H(n) = n*(2*n-1)   ==> 1, 6, 15, 28, 45, ...

Si può verificare che T(285) = P(165) = H(143) = (40755)

Trovare il prossimo numero triangolare che è anche pentagonale ed esagonale.
============================================================================

(define (tri n) (/ (* n (+ n 1)) 2))
(define (pen n) (/ (* n (- (* 3 n) 1)) 2))
(define (esa n) (* n (- (* 2 n) 1)))

(tri 285)
;-> 40755
(pen 165)
;-> 40755
(esa 143)
;-> 40755

Deve risultare:

t*(t + 1)/2 == p*(3*p-1)/2 == x*(2*x-1)

dove t -> indice triangolari
dove p -> indice pentagonali
dove x -> indice esagonali

La soluzione dell'uguaglianza:

t*(t + 1)/2 == x*(2*x-1)

vale: x = (t + 1)/2, t = 2*x - 1

Per t = 285 otteniamo x = (285 + 1)/2 = 143

Definiamo una funzione che genera l'indice del numero esagonale utilizzando l'indice del numero triangolare:

(define (xidx t) (/ (+ t 1) 2))

(xidx 285)
;-> 143

Vediamo come funziona:

(for (i 285 301 2)
  (println (tri i) { } (esa (xidx i))))
;-> 40755 40755
;-> 41328 41328
;-> 41905 41905
;-> 42486 42486
;-> 43071 43071
;-> 43660 43660
;-> 44253 44253
;-> 44850 44850
;-> 45451 45451

Adesso generiamo le tre sequenze di numeri:

(silent (setq trian (map tri (sequence 0 100000))))
(silent (setq penta (map pen (sequence 0 100000))))
(silent (setq esago (map esa (sequence 0 100000))))

Possiamo scrivere la soluzione controllando per ogni valore dell'indice del numero triangolare se esiste quel valore del numero triangolare nella lista dei numeri pentagonali:

(define (e045)
  (local (stop i)
    (setq i 287)
    (setq stop nil)
    (while (= stop nil)
      (setq x (xidx i))
      ;(if (ref (esa x) penta) (begin (println i { } x { } (ref (esa x) penta) { } (esa x)) (setq stop true)))
      (if (ref (tri i) penta) (begin (println i { } x { } (ref (esa x) penta) { } (esa x)) (setq stop true)))
      (if (zero? (% i 1000))  (println i))
      (setq i (+ i 2))
    )
  )
)

(e045)
;-> 55385 27693 (31977) 1533776805

(time (e045))
;-> 19343.289

Possiamo usare la funzione "intersect" di newLISP per trovare il risultato:

(define (e045)
  (local (trian penta esago)
    (setq trian (map tri (sequence 1 100000)))
    (setq penta (map pen (sequence 1 100000)))
    (setq esago (map esa (sequence 1 100000)))
    (intersect (intersect trian penta) esago)
  )
)

(e045)
;-> (1 40755 1533776805)

(time (e045))
;-> 114.465

Questa soluzione è molto più veloce.
----------------------------------------------------------------------------


===========
Problema 46
===========

L'altra congettura di Goldbach

È stato proposto da Christian Goldbach che ogni numero composito dispari può essere scritto come la somma di un numero primo e due volte un quadrato.

9 = 7 + 2 × 1^2
15 = 7 + 2 × 2^2
21 = 3 + 2 × 3^2
25 = 7 + 2 × 3^2
27 = 19 + 2 × 2^2
33 = 31 + 2 × 1^2

Si scopre che la congettura era falsa.

Qual'è il più piccolo numero composito dispari che non può essere scritto come somma di un numero primo e due volte quadrato?
============================================================================

Per ogni numero dispari x:
- se x è un numero composito (cioè è un numero non primo) ==> non trovato
- per i che va da 1 a (* i i 2) se (x - i * i * 2) è primo ==> non trovato
  altrimenti ==> trovato

Funzione per i numeri primi:

(define (primo? n)
   (if (< n 2) nil
       (= 1 (length (factor n)))))

Funzione che controlla se un numero soddisfa la congettura (se il numero è primo non soddisfa la congettura):

(define (check x)
  (local (out i stop limite)
    (cond ((primo? x) (setq out true))
          (true
            (setq i 1)
            (setq stop nil)
            (setq limite (* i i 2))
            (while (and (<= limite x) (= stop nil))
              (if (primo? (- x (* i i 2))) (begin (setq stop true) (setq out true)))
              (++ i)
              (setq limite (* i i 2))
            )
          )
    )
    out
  )
)

Scriviamo la funzione finale:

(define (e046)
  (local (num trovato)
    (setq num 11)
    (setq trovato false)
    (while (= trovato nil)
      (if (= (check num) nil) (setq trovato true))
      (setq num (+ num 2))
    )
    (- num 2)
  )
)


(e046)
;-> 5777

(time (e046))
;-> 31.247
----------------------------------------------------------------------------


===========
Problema 47
===========

Fattori primi distinti

I primi due numeri consecutivi con due fattori primi distinti sono:

14 = 2 × 7
15 = 3 × 5

I primi tre numeri consecutivi con tre fattori primi distinti sono:

644 = 2² × 7 × 23
645 = 3 × 5 × 43
646 = 2 × 17 × 19.

Trova i primi quattro numeri interi consecutivi con quattro fattori primi distinti ciascuno. Qual è il primo di questi numeri?
============================================================================

Funzione che calcola il numero di fattori primi distitni di un numero:

(define (numFattDist n) (length (unique (factor n))))

(numFattDist 12345)
;-> 3

Possiamo scrivere la funzione finale:

(define (e047)
  (local (stop i)
    (setq i 134043)
    (while (= stop nil)
      (if (and (= (numFattDist i) 4)
               (= (numFattDist (+ i 1)) 4)
               (= (numFattDist (+ i 2)) 4)
               (= (numFattDist (+ i 3)) 4))
          (setq stop true)
      )
      (++ i)
      (if (= (% i 1000000) 0) (println i))
    )
    (-- i)
  )
)

(e047)
;-> 134043

(time (e047))
;-> 0
----------------------------------------------------------------------------


===========
Problema 48
===========

Auto potenze

La serie, 1^1 + 2^2 + 3^3 + ... + 10^10 = 10405071317.

Trova le ultime dieci cifre della serie, 1^1 + 2^2 + 3^3 + ... + 1000^1000.
============================================================================

Funzione che calcola la potenza di numeri interi (anche per numeri big integer):

(define (potenza n m)
  (setq pot 1L)
  (dotimes (x m)
    (setq pot (* pot n))
  )
  pot
)

Creiamo una lista con tutti i numeri da 1 a 1000 elevati a se stessi:
(setq a (map (fn (x) (potenza x x)) (sequence 1L 1000L)))

Sommiano tutti i valori della lista:
(setq b (apply + a))

Trasformiano il numero somma in stringa ed estraiamo le ultime 10 cifre (senza la L finale):
(setq c (pop (string b) -11 10))
;-> "9110846700"

Scriviamo la funzione:

(define (e048)
  (pop (string (apply + (map (fn (x) (potenza x x)) (sequence 1L 1000L)))) -11 10)
)

(e048)
;-> "9110846700"

(time (e048))
;-> 265.614
----------------------------------------------------------------------------


===========
Problema 49
===========

Permutazioni prime

La sequenza aritmetica, 1487, 4817, 8147, in cui ciascun termine aumenta di 3330, è inusuale in due modi: (i) ciascuno dei tre termini è primo, e (ii) ciascuno dei numeri a 4 cifre è una permutazione degli altri.

Non ci sono sequenze aritmetiche composte da tre numeri primi di 1, 2 o 3 cifre, che esibiscono questa proprietà, ma esiste un'altra sequenza crescente di 4 cifre.

Quale numero di 12 cifre si forma concatenando i tre termini in questa sequenza?
============================================================================

Funzione per i numeri primi:

(define (primo? n)
   (if (< n 2) nil
       (= 1 (length (factor n)))))

Funzione che converte un numero in una lista:

(define (int2list n)
  (let (out '())
    (while (!= n 0)
      (push (% n 10) out)
      (setq n (/ n 10))
    )
    out
  )
)

Limiti da considerare nella ricerca della soluzione: da 1001 a 9999

Filtro i numeri primi:

(setq a (filter primo? (sequence 1001 9999)))
(length a)
;-> 1061

Funzione che controlla se due numeri hanno le stesse cifre:

(define (cifreUguali x y)
  (if (= (sort (int2list x)) (sort (int2list y))))
)

(cifreUguali 1234 4231)
;-> true

Controllo tutti gli elementi della lista dei numeri primi per vedere se soddisfano le condizioni del problema:

(dolist (el a)
  (setq a1 el)
  (setq a2 (+ a1 3330))
  (setq a3 (+ a2 3330))
  (if (and (primo? a2) (primo? a3) (cifreUguali a1 a2) (cifreUguali a2 a3))
    (println a1 { } a2 { } a3)
  )
)
;-> 1487 4817 8147
;-> 2969 6299 9629

Possiamo scrivere la funzione finale:

(define (e049)
  (local (primi a1 a2 a3 out)
    (setq primi (filter primo? (sequence 1001 9999)))
    (dolist (el primi)
      (setq a1 el)
      (setq a2 (+ a1 3330))
      (setq a3 (+ a2 3330))
      (if (and (primo? a2) (primo? a3) (cifreUguali a1 a2) (cifreUguali a2 a3))
        (setq out (string a1 a2 a3))
        ;(println a1 { } a2 { } a3)
      )
    )
    out
  )
)

(e049)
;-> "296962999629"

(time (e049))
;-> 9.01
----------------------------------------------------------------------------


===========
Problema 50
===========

Somma di primi consecutivi

Il primo 41 può essere scritto come la somma di sei numeri primi consecutivi:

41 = 2 + 3 + 5 + 7 + 11 + 13

Questa è la somma più lunga di numeri primi consecutivi che si aggiunge a un numero primo inferiore a cento.

La somma più lunga di numeri primi consecutivi al di sotto di un migliaio che aggiunge un numero primo, contiene 21 termini ed è uguale a 953.

Quale primo, inferiore a un milione, può essere scritto come la somma dei numeri primi più consecutivi?
============================================================================

Funzione per i numeri primi:

(define (primo? n)
   (if (< n 2) nil
       (= 1 (length (factor n)))))

Limiti da considerare nella ricerca della soluzione: da 2 a 1000000

Filtro i numeri primi:

(silent (setq primi (filter primo? (sequence 2 1000000))))
(length primi)
;-> 78490

(slice primi 0 10)

(define (e050)
  (local (primi lenprimi somma sommaMax limite i j stop)
    (setq somma 0)
    (setq limite -1)
    (setq primi (filter primo? (sequence 2 1000000)))
    (setq lenprimi (length primi))
    (setq i 2)
    (while (< i lenprimi)
      (setq somma 0)
      (setq stop nil)
      (setq j i)
      (while (and (< j lenprimi) (= stop nil))
        (setq somma (+ somma (primi j)))
        (if (> somma 1000000) (setq stop true)
        ;else
        (if (and (> (- j i) limite) (> somma sommaMax) (primo? somma))
          (begin
            (setq sommaMax somma)
            (setq limite (- j i))
          )
        ))
        (++ j)
      )
      (++ i)
      ;(if (= (% i 10000)) (println i))
    )
    sommaMax
  )
)

(e050)
;-> 997651

(time (e050))
;-> 27113

I numeri coinvolti nella soluzione sono i seguenti:

(997651 543 (7 11 13 17 19 23 29 31 37 41 43 47 53
59 61 67 71 73 79 83 89 97 101 103 107 109 113 127
131 137 139 149 151 157 163 167 173 179 181 191 193
197 199 211 223 227 229 233 239 241 251 257 263 269
271 277 281 283 293 307 311 313 317 331 337 347 349
353 359 367 373 379 383 389 397 401 409 419 421 431
433 439 443 449 457 461 463 467 479 487 491 499 503
509 521 523 541 547 557 563 569 571 577 587 593 599
601 607 613 617 619 631 641 643 647 653 659 661 673
677 683 691 701 709 719 727 733 739 743 751 757 761
769 773 787 797 809 811 821 823 827 829 839 853 857
859 863 877 881 883 887 907 911 919 929 937 941 947
953 967 971 977 983 991 997 1009 1013 1019 1021 1031
1033 1039 1049 1051 1061 1063 1069 1087 1091 1093 1097
1103 1109 1117 1123 1129 1151 1153 1163 1171 1181 1187
1193 1201 1213 1217 1223 1229 1231 1237 1249 1259 1277
1279 1283 1289 1291 1297 1301 1303 1307 1319 1321 1327
1361 1367 1373 1381 1399 1409 1423 1427 1429 1433 1439
1447 1451 1453 1459 1471 1481 1483 1487 1489 1493 1499
1511 1523 1531 1543 1549 1553 1559 1567 1571 1579 1583
1597 1601 1607 1609 1613 1619 1621 1627 1637 1657 1663
1667 1669 1693 1697 1699 1709 1721 1723 1733 1741 1747
1753 1759 1777 1783 1787 1789 1801 1811 1823 1831 1847
1861 1867 1871 1873 1877 1879 1889 1901 1907 1913 1931
1933 1949 1951 1973 1979 1987 1993 1997 1999 2003 2011
2017 2027 2029 2039 2053 2063 2069 2081 2083 2087 2089
2099 2111 2113 2129 2131 2137 2141 2143 2153 2161 2179
2203 2207 2213 2221 2237 2239 2243 2251 2267 2269 2273
2281 2287 2293 2297 2309 2311 2333 2339 2341 2347 2351
2357 2371 2377 2381 2383 2389 2393 2399 2411 2417 2423
2437 2441 2447 2459 2467 2473 2477 2503 2521 2531 2539
2543 2549 2551 2557 2579 2591 2593 2609 2617 2621 2633
2647 2657 2659 2663 2671 2677 2683 2687 2689 2693 2699
2707 2711 2713 2719 2729 2731 2741 2749 2753 2767 2777
2789 2791 2797 2801 2803 2819 2833 2837 2843 2851 2857
2861 2879 2887 2897 2903 2909 2917 2927 2939 2953 2957
2963 2969 2971 2999 3001 3011 3019 3023 3037 3041 3049
3061 3067 3079 3083 3089 3109 3119 3121 3137 3163 3167
3169 3181 3187 3191 3203 3209 3217 3221 3229 3251 3253
3257 3259 3271 3299 3301 3307 3313 3319 3323 3329 3331
3343 3347 3359 3361 3371 3373 3389 3391 3407 3413 3433
3449 3457 3461 3463 3467 3469 3491 3499 3511 3517 3527
3529 3533 3539 3541 3547 3557 3559 3571 3581 3583 3593
3607 3613 3617 3623 3631 3637 3643 3659 3671 3673 3677
3691 3697 3701 3709 3719 3727 3733 3739 3761 3767 3769
3779 3793 3797 3803 3821 3823 3833 3847 3851 3853 3863
3877 3881 3889 3907 3911 3917 3919 3923 3929 3931))
----------------------------------------------------------------------------


===========
Problema 51
===========

Sostituzioni di cifre nei numeri primi

Sostituendo la prima cifra del numero a 2 cifre *3, si scopre che sei dei nove valori possibili: 13, 23, 43, 53, 73 e 83, sono tutti primi.

Sostituendo la terza e la quarta cifra di 56**3 con la stessa cifra, questo numero di 5 cifre è il primo esempio con sette numeri primi tra i dieci numeri generati, dando la famiglia: 56003, 56113, 56333, 56443, 56663, 56773 e 56993. Di conseguenza 56003, essendo il primo membro di questa famiglia, è il primo più piccolo con questa proprietà.

Trova il primo più piccolo che, sostituendo parte del numero (non necessariamente cifre adiacenti) con la stessa cifra, fa parte di una famiglia di otto valori primi.
============================================================================

Prima di scrivere la soluzione abbiamo bisogno di alcune funzioni ausiliarie.

Funzione che genera tutti i numeri primi da m a n:

(define (sieve-from-to m n)
  (local (arr lst out)
    (setq out '())
    (setq arr (array (+ n 1)) lst '(2))
    (for (x 3 n 2)
        (when (not (arr x))
          (push x lst -1)
          (for (y (* x x) n (* 2 x) (> y n))
              (setf (arr y) true))))
    (if (<= m 2)
        lst
        (dolist (el lst) (if (>= el m) (push el out -1)))
    )
  )
)

Funzione che conta le occorrenze di un carattere in una stringa:

(define (conta-char stringa carattere)
  (let (out 0)
    (dolist (el (explode stringa))
      (if (= carattere el) (++ out))) out))

(conta-char "451234555" "5")
;-> 4

Funzione che sostituisce caratteri (char-old -> char-new) in una stringa:

(define (cambia-char stringa char-old char-new)
  (let (out "")
    (dolist (el (explode stringa))
      (if (= char-old el)
        (write out char-new)
        (write out el)))
    out))

(cambia-char "12345543215" "5" "0")
;-> "12340043210"

Funzione che verifica la primalità di un numero:

(define (primo? n)
  (if (< n 2) nil
    (if (= 1 (length (factor n))))))

Infine la funzione soluzione (brute-force):

(define (e051 n)
  (local (cycleMaxL primi numS ciclo cycleL uguali newnum found)
    (setq found nil)
    (setq primi (sieve-from-to 100000 n))
    (dolist (num primi found)
      (setq numS (string num))
      (dolist (cifra (explode "1234567890") found)
        (setq ciclo 0)
        (setq cycleL '())
        (setq uguali (conta-char numS cifra))
        (if (= uguali 3)
          ;(dolist (nuovo (explode "1234567890"))
          (dolist (nuovo (explode "1234567890") found)
            (setq newnum (cambia-char numS cifra nuovo))
            (if (= (length newnum) (length numS))
              (if (primo? (int newnum))
                (begin (++ ciclo)
                       (push (int newnum) cycleL -1))
              )
            )
          )
        )
        (if (> (length cycleL) (length cycleMaxL))
          (begin (setq cycleMaxL cycleL)
                 (if (>= (length cycleMaxL) 8)
                   (begin (setq found true)
                    (println "Sol: " numS { } (slice cycleMaxL 0 8)))
                    ;(println "Sol: " numS { } cycleMaxL)))
                 ))
        )
      )
    )
    'end
  )
)

(e051 999999)
;-> Sol: 121313 (121313 222323 323333 424343 525353 626363 828383 929393)
;-> end

(time (e051 999999))
;-> Sol: 121313 (121313 222323 323333 424343 525353 626363 828383 929393)
;-> 269.946
----------------------------------------------------------------------------


===========
Problema 52
===========

Permutazione di multipli

Si può vedere che il numero 125874 e il suo doppio 251748 contengono esattamente le stesse cifre, ma in un ordine diverso.

Trova il numero intero positivo più piccolo x, tale che 2x, 3x, 4x, 5x e 6x contengano le stesse cifre.
============================================================================

Funzione che verifica se due numeri hanno le stesse cifre:

(define (same-digit m n)
  (if (!= (length m) (length n))
      nil
      (= (sort (explode (string m))) (sort (explode (string n))))))

(same-digit 1234 4321)
;-> true

(same-digit 12341 4321)
;-> nil

(define (e052)
  (let ((i 10)
        (continua true))
    (while continua
      (if (and (same-digit i (* 2 i))
               (same-digit i (* 3 i))
               (same-digit i (* 4 i))
               (same-digit i (* 5 i))
               (same-digit i (* 6 i)))
          (setq continua nil))
      (++ i)
    )
    (- i 1)))

(e052)
;-> 142857

(time (e052))
;-> 313.15
----------------------------------------------------------------------------


===========
Problema 53
===========

Selezione di combinazioni

Esistono esattamente dieci modi per selezionare tre cifre tra cinque cifre 1, 2, 3, 4 e 5): 123, 124, 125, 134, 135, 145, 234, 235, 245 e 345
                                      (5)
In combinatoria, si usa la notazione, ( ) = 10.
                                      (3)

In generale,

(n)         n!
( ) = --------------- , dove r <= n
(r)    r! * (n - r)!

e n! = 1 * 2 * 3 * ... * (n - 1) * n

Il numero n = 23 ha il primo valore che supera il milione:

(23)
(  ) = 1144066
(10)
                                                (n)
Quanti valori, non necessariamente distinti, di (r) per 1<=n<=100, sono maggiori di un milione?
============================================================================

Formula che calcola il binomiale (big-integer):

(define (binom n k)
  (local (M q)
    (setq M (array (+ n 1) (+ k 1) '(0L)))
    (for (i 0 n)
      (setq q (min i k))
      (for (j 0 q)
        (if (or (= j 0) (= j i))
          (setq (M i j) 1L)
          (setq (M i j) (+ (M (- i 1) (- j 1)) (M (- i 1) j)))
        )
      )
    )
    (M n k)
  );local
)

(binom 23 10)
;-> 1144066L

Funzione soluzione:

(define (e053 n)
  (let (quanti 0)
    (for (i 1 n)
      (for (j 1 i)
        (if (> (binom i j) 1e6) (++ quanti))))
    quanti))

(e053 100)
;-> 4075

(time (e053 100))
;-> 6231.481

Per velocizzare la soluzione, proviamo a non usare i big integer nella funzione che calcola il binomiale.

(define (binom n k)
  (local (M q)
    (setq M (array (+ n 1) (+ k 1) '(0)))
    (for (i 0 n)
      (setq q (min i k))
      (for (j 0 q)
        (if (or (= j 0) (= j i))
          (setq (M i j) 1)
          (setq (M i j) (+ (M (- i 1) (- j 1)) (M (- i 1) j)))
        )
      )
    )
    (M n k)
  );local
)

(binom 23 10)
;-> 1144066

I numeri binomiali che superano il valore massimo per gli int64 diventano negativi, quindi usiamo la funzione "abs" per considerarli maggiori di 10 milioni.

(define (e053 n)
  (let (quanti 0)
    (for (i 1 n)
      (for (j 1 i)
        (if (> (abs (binom i j)) 1e6) (++ quanti))))
    quanti))

(e053 100)
;-> 4075

(time (e053 100))
;-> 3522.499

Abbiamo quasi raddoppiato la velocità, ma il problema è la lentezza della funzione che calcola il binomiale. Proviamo un altro metodo: poichè il numero n arriva solo fino a 100, possiamo precalcolare il fattoriale dei primi 100 numeri e usarli per calcolare il binomiale con la formula originale.

Funzione fattoriale (big-integer):

(define (fact n) (apply * (map bigint (sequence 1 n))))

Funzione binomiale (big-integer):

(define (bino n r) (/ (f n) (* (f r) (f (- n r)))))

Adesso riscriviamo la funzione soluzione:

(define (e053)
  (local (quanti f)
    (setq quanti 0)
    ;precalcolo dei fattoriali da 0 a 100
    (setq f (map fact (sequence 0 100)))
    (for (i 1 100)
      (for (j 1 i)
        ; la differenza tra gli indici deve essere
        ; maggiore di 0 affinchè (bino i j) possa
        ; essere maggiore di un milione.
        ; Infatti (bino x x) = 1
        (if (> (- i j) 0)
          (if (> (bino i j) 1e6) (++ quanti)))))
    quanti))

(e053)
;-> 4075

(time (e053))
;-> 25.013

Questa volta la risposta di newLISP è immediata.
----------------------------------------------------------------------------


===========
Problema 54
===========

Mani di poker

Nel gioco del poker, una mano è composta da cinque carte e sono classificate, dalla più bassa alla più alta, nel modo seguente:

Carta alta: carta di valore più alto.
Una coppia: due carte dello stesso valore.
Due coppie: due coppie diverse.
Tris: tre carte dello stesso valore.
Scala: tutte le carte hanno valori consecutivi.
Colore: tutte le carte sono dello stesso seme.
Full: un tris e una coppia.
Poker: quattro carte dello stesso valore.
Scala reale: tutte le carte sono valori consecutivi dello stesso seme.
Scala reale massima: dieci, Jack, Queen, King, Asso dello stesso seme.
Le carte sono valutate nell'ordine:
2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, King, Asso

Se due giocatori hanno mani dello stesso valore, allora vince quello che ha il valore composto più alto(per esempio, una coppia di otto batte una coppia di cinque, vedi esempio 1 sotto). Ma se abbiamo un pareggio tra ranghi uguali, ad esempio entrambi i giocatori hanno una coppia di regine, vengono confrontate le carte più alte in ogni mano (vedi esempio 4 di seguito). Se le carte più alte sono uguali, allora vengono confrontate le carte più alte successive e così via.

Considera le seguenti cinque mani distribuite a due giocatori:

Hand   Player 1             Player 2               Winner
1      5H 5C 6S 7S KD       2C 3S 8S 8D TD         Player 2
       Pair of Fives        Pair of Eights

2      5D 8C 9S JS AC       2C 5C 7D 8S QH         Player 1
       Highest card Ace     Highest card Queen

3      2D 9C AS AH AC       3D 6D 7D TD QD         Player 2
       Flush with Diamonds  Three Aces

4      4D 6S 9H QH QC       3D 6D 7H QD QS         Player 1
       Pair of Queens       Pair of Queens
       Highest card Nine    Highest card Seven

5      2H 2D 4C 4D 4S       3C 3D 3S 9S 9D         Player 1
       Full House           Full House
       With Three Fours     with Three Threes

Il file "poker.txt" contiene mille mani casuali distribuite a due giocatori. Ogni riga del file contiene dieci carte (separate da un singolo spazio): le prime cinque sono le carte del giocatore 1 e le ultime cinque sono le carte del giocatore 2. Puoi presumere che tutte le mani siano valide (nessun carattere non valido o carte ripetute), la mano di ogni giocatore non è in un ordine specifico e in ogni mano c'è un chiaro vincitore.

Quante mani vince il giocatore 1?
============================================================================

Vediamo come vengono rappresentati i semi:

H = Hearts (Cuori)
D = Diamonds (Quadri)
C = Clubs (Fiori)
S = Spades (Picche)

Vediamo i passi della soluzione con il file "poker.txt" (che ha solo 10 mani):

(setq raw (read-file "poker.txt"))
"8C TS KC 9H 4S 7D 2S 5D 3S AC\r\n
 5C AD 5D AC 9C 7C 5H 8D TD KS\r\n
 3H 7H 6S KC JS QH TD JC 2D 8S\r\n
 TH 8H 5C QS TC 9H 4D JC KS JS\r\n
 7C 5H KC QH JD AS KH 4C AD 4S\r\n
 5H KS 9C 7D 9H 8D 3S 5D 5C AH\r\n
 6H 4H 5C 3H 2H 3S QH 5S 6S AS\r\n
 TD 8C 4H 7C TC KC 4C 3H 7S KS\r\n
 7C 9C 6D KD 3H 4C QS QC AC KH\r\n
 JC 6S 5H 2H 2D KD 9D 7C AS JS"

Usiamo la funzione "parse" per ottenere solo una stringa che rappresenta una mano:

(setq data (parse raw "\r\n"))
;-> ("8C TS KC 9H 4S 7D 2S 5D 3S AC"
;->  "5C AD 5D AC 9C 7C 5H 8D TD KS"
;->  "3H 7H 6S KC JS QH TD JC 2D 8S"
;->  "TH 8H 5C QS TC 9H 4D JC KS JS"
;->  "7C 5H KC QH JD AS KH 4C AD 4S"
;->  "5H KS 9C 7D 9H 8D 3S 5D 5C AH"
;->  "6H 4H 5C 3H 2H 3S QH 5S 6S AS"
;->  "TD 8C 4H 7C TC KC 4C 3H 7S KS"
;->  "7C 9C 6D KD 3H 4C QS QC AC KH"
;->  "JC 6S 5H 2H 2D KD 9D 7C AS JS")

Adesso se vogliamo ottenere una lista per ogni riga, basta mappare la funzione "list" sugli elementi della lista data:

(setq data (map list data))
;-> (("8C TS KC 9H 4S 7D 2S 5D 3S AC")
;->  ("5C AD 5D AC 9C 7C 5H 8D TD KS")
;->  ("3H 7H 6S KC JS QH TD JC 2D 8S")
;->  ("TH 8H 5C QS TC 9H 4D JC KS JS")
;->  ("7C 5H KC QH JD AS KH 4C AD 4S")
;->  ("5H KS 9C 7D 9H 8D 3S 5D 5C AH")
;->  ("6H 4H 5C 3H 2H 3S QH 5S 6S AS")
;->  ("TD 8C 4H 7C TC KC 4C 3H 7S KS")
;->  ("7C 9C 6D KD 3H 4C QS QC AC KH")
;->  ("JC 6S 5H 2H 2D KD 9D 7C AS JS"))

Dobbiamo cambiare i valori dei caratteri:
('A','14')
('K','13')
('Q','12')
('J','11')
('T','10')

e creiamo la seguente struttura per i dati per ogni mano:

((valori-p1) (semi-p1) (valori-p2) (semi-p2))

(setq mani '())
(dolist (el data)
  (setq row (first el))
  ;(println row)
  (setq val-p1 (explode (select row '(0 3 6 9 12))))
  (replace "A" val-p1 "14")
  (replace "K" val-p1 "13")
  (replace "Q" val-p1 "12")
  (replace "J" val-p1 "11")
  (replace "T" val-p1 "10")
  (setq val-p1 (sort (map int val-p1)))
  (setq val-p2 (explode (select row '(15 18 21 24 27))))
  (replace "A" val-p2 "14")
  (replace "K" val-p2 "13")
  (replace "Q" val-p2 "12")
  (replace "J" val-p2 "11")
  (replace "T" val-p2 "10")
  (setq val-p2 (sort (map int val-p2)))
  ; i semi non vengono ordinati perchè ci servono
  ; solo per calcolare "colore"
  (setq sem-p1 (select row '(1 4 7 10 13)))
  (setq sem-p2 (select row '(16 19 22 25 28)))
  (push (list val-p1 sem-p1 val-p2 sem-p2) mani -1)
  mani
)

;-> (((4 8 9 10 13) "CSCHS" (2 3 5 7 14) "DSDSC")
;->  ((5 5 9 14 14) "CDDCC" (5 7 8 10 13)  "CHDDS")
;->  ((3 6 7 11 13) "HHSCS" (2 8 10 11 12) "HDCDS")
;->  ((5 8 10 10 12) "HHCSC" (4 9 11 11 13) "HDCSS")
;->  ((5 7 11 12 13) "CHCHD" (4 4 13 14 14) "SHCDS")
;->  ((5 7 9 9 13) "HSCDH" (3 5 5 8 14) "DSDCH")
;->  ((2 3 4 5 6) "HHCHH" (3 5 6 12 14) "SHSSS")
;->  ((4 7 8 10 10) "DCHCC" (3 4 7 13 13) "CCHSS")
;->  ((3 6 7 9 13) "CCDDH" (4 12 12 13 14) "CSCCH")
;->  ((2 2 5 6 11) "CSHHD" (7 9 11 13 14) "DDCSS"))

(first mani)
;-> ((4 8 9 10 13) "CSCHS" (2 3 5 7 14) "DSDSC")
(first (first mani))
;-> (4 8 9 10 13)

Adesso scriviamo la funzione che calcola il punteggio di una singola mano con i parametri "numeri" e "semi": (4 8 9 10 13) "CSCHS". Da notare che gli indici dei semi non corrispondono agli indici dei numeri. Questo perchè i semi servono solo per stabilire se sono tutti uguali (es. "CCCCC").

Esempi di utilizzo della funzione "calcola":

Input
  numeri = (2 3 4 8 10) ; numeri è ordinato
  semi = "CHCCC"
Output
  ((1 10 8 4 3 2) "High Card")
  dove 1 è il valore della mano
  e 10,8,4,3,2 sono i valori delle ordinati carte

Input
  numeri = (2 2 2 8 8) ; numeri è ordinato
  semi = "CHCCC"
Output
  ((7 2 8) "Full House")
  dove 7 è il valore della mano
  2 è il valore del tris e
  8 è il valore della coppia

(define (calcola numeri semi)
  (local (valore nome a b c)
    (setq valore '())
    (setq nome "")
    ;
    ; Flush, Straight Flush, Royal Flush
    ; Colore, Scala Reale, Scala Reale Massima
    (if (or (= semi "CCCCC") (= semi "DDDDD") (= semi "HHHHH") (= semi "SSSSS"))
        (begin
         (setq valore '(6)
               nome "Flush") ; Colore
         (if (= 4 (- (numeri 4) (numeri 0)))
             (begin
             (setq valore (list 9 (numeri 4))
                   nome "Straight Flush") ; Scala Reale
             (if (= 14 (numeri 4))
                 (setq valore (list 10 14)
                       nome "Royal Flush") ; Scala Reale Massima
             ))
         )
        )
    )
    ;
    ; Four of a Kind
    ; Poker
    (if (= valore '()) ; non abbiamo ancora catalogato la mano
        (for (i 2 14)
          (if (= (count (list i) numeri) '(4))
              (setq valore (list 8 i)
                    nome "Four of a Kind") ; Poker
          )
        )
    )
    ;
    ; Full House
    ; Full
    (if (= valore '()) ; non abbiamo ancora catalogato la mano
        (for (i 2 14)
          (if (= (count (list i) numeri) '(3))
              (for (j 2 14)
                (if (= (count (list j) numeri) '(2))
                    (setq valore (list 7 i j)
                          nome "Full House") ; Full
                )
              )
          )
        )
    )
    ;
    ; Three of a Kind
    ; Tris
    (if (= valore '()) ; non abbiamo ancora catalogato la mano
        (for (i 2 14)
          (if (= (count (list i) numeri) '(3))
              (begin
                (setq a i)
                (setq valore (list 4 i)
                      nome "Three of a Kind") ; Tris
                (for (k 4 0 -1)
                  (if (!= a (numeri k))
                      (push (numeri k) valore -1)
                  )
                )
              )
          )
        )
    )
    ;
    ; Two Pairs
    ; Doppia Coppia
    (if (= valore '()) ; non abbiamo ancora catalogato la mano
        (for (i 2 14)
          (if (= (count (list i) numeri) '(2))
              (for (j 2 14)
                (if (and (= (count (list j) numeri) '(2)) (!= i j))
                    (begin
                    (setq a (max i j))
                    (setq b (min i j))
                    (for (k 4 0 -1)
                       (if (and (!= a (numeri k)) (!= b (numeri k)))
                           (setq c (numeri k))
                       )
                    )
                    (setq valore (list 3 a b c)
                          nome "Two Pairs") ; Doppia Coppia
                ))
              )
          )
        )
    )
    ;
    ; Straight
    ; Scala
    (if (= valore '()) ; non abbiamo ancora catalogato la mano
        (if (and (= 1 (- (numeri 4) (numeri 3)))
                 (= 1 (- (numeri 3) (numeri 2)))
                 (= 1 (- (numeri 2) (numeri 1)))
                 (= 1 (- (numeri 1) (numeri 0))))
            (setq valore (list 5 (numeri 4))
                  nome "Straight") ; Scala
        )
    )
    ;
    ; One Pair
    ; Coppia
    (if (= valore '()) ; non abbiamo ancora catalogato la mano
        (for (i 2 14)
          (if (= (count (list i) numeri) '(2))
              (begin
              (setq valore (list 2 i)
                    nome "One Pair") ; Coppia
              (for (k 4 0 -1)
                (if (!= i (numeri k))
                    (push (numeri k) valore -1)
                )
              ))
          )
        )
    )
    ;
    ; High Card
    ; Carta maggiore
    (if (= valore '()) ; non abbiamo ancora catalogato la mano
        (setq valore (list 1 (numeri 4) (numeri 3) (numeri 2)
                             (numeri 1) (numeri 0))
              nome "High Card") ; Carta maggiore
    )
    ;
    ; Error: mano unclassified
    ; Errore: mano non catalogata
    (if (= valore '()) ; non abbiamo ancora catalogato la mano
        (println "error")
    )
    (list valore nome)
  )
)

Proviamo la funzione "calcola":

(calcola '(2 3 4 6 8) "CHCCC")
;-> ((1 6 8 4 3 2) "High Card")
(calcola '(2 2 2 10 10) "CHCCC")
;-> ((7 2 10) "Full House")
(calcola '(2 3 4 8 10) "CHCCC")
;-> ((1 8 3 4 2 10) "High Card")
(calcola '(10 2 3 3 8) "CHCCC")
;-> ((2 3 8 2 10) "One Pair")
(calcola '(3 3 3 5 6) "CHCCC")
;-> ((4 3 6 5) "Three of a Kind")
(calcola '(4 8 9 10 13) "CSCHS")
;-> ((1 13 10 9 8 4) "High Card")
(calcola '(2 3 5 4 6) "DDDDD")
;-> ((9 6) "Straight Flush")
(calcola '(10 11 12 13 14) "DDDDD")
;-> ((10 14) "Royal Flush")

Vediamo se funziona correttamente:

(dolist (el mani)
  (setq p1 (calcola (el 0) (el 1)))
  (setq p2 (calcola (el 2) (el 3)))
  (println (el 0) { - } p1)
  (println (el 2) { - } p2)
)

;-> (4 8 9 10 13) - ((1 13 10 9 8 4) "High Card")
;-> (2 3 5 7 14) - ((1 14 7 5 3 2) "High Card")
;-> (5 5 9 14 14) - ((3 14 5 9) "Two Pairs")
;-> (5 7 8 10 13) - ((1 13 10 8 7 5) "High Card")
;-> (3 6 7 11 13) - ((1 13 11 7 6 3) "High Card")
;-> (2 8 10 11 12) - ((1 12 11 10 8 2) "High Card")
;-> (5 8 10 10 12) - ((2 10 12 8 5) "One Pair")
;-> (4 9 11 11 13) - ((2 11 13 9 4) "One Pair")
;-> (5 7 11 12 13) - ((1 13 12 11 7 5) "High Card")
;-> (4 4 13 14 14) - ((3 14 4 13) "Two Pairs")
;-> (5 7 9 9 13) - ((2 9 13 7 5) "One Pair")
;-> (3 5 5 8 14) - ((2 5 14 8 3) "One Pair")
;-> (2 3 4 5 6) - ((5 6) "Straight")
;-> (3 5 6 12 14) - ((1 14 12 6 5 3) "High Card")
;-> (4 7 8 10 10) - ((2 10 8 7 4) "One Pair")
;-> (3 4 7 13 13) - ((2 13 7 4 3) "One Pair")
;-> (3 6 7 9 13) - ((1 13 9 7 6 3) "High Card")
;-> (4 12 12 13 14) - ((2 12 14 13 4) "One Pair")
;-> (2 2 5 6 11) - ((2 2 11 6 5) "One Pair")
;-> (7 9 11 13 14) - ((1 14 13 11 9 7) "High Card")
;-> ((1 14 13 11 9 7) "High Card")

Adesso dobbiamo scrivere una funzione che confronta gli elementi di due liste per trovare quale delle due è maggiore:

Esempi:
(3 4 9) maggiore di (2 3 12)
(3 4 9) maggiore di (3 3 12)
(3 4 9) minore di (5 3 8)
(4 5 2 7) maggiore di (4 5 2 6)

(define (maggiore lst1 lst2)
  (cond ((or (null? lst1) (null? lst2))
         ; se lst1 ha più elementi di lst2
         (if (not (null? lst1))
             true  ;se lst1 ha più elementi di lst2
             nil)) ; altrimenti lst1 = lst2
        ((> (first lst1) (first lst2)) true)
        ((< (first lst1) (first lst2)) nil)
        ((= (first lst1) (first lst2))
         (maggiore (rest lst1) (rest lst2)))))

(maggiore '(3 4 9) '(3 4 9))
;-> nil
(= '(3 4 9) '(3 4 9))
;-> true
(maggiore '(13 10 9 8 7 6) '(13 10 9 8 7 5))
;-> true
(maggiore '(13 10 9 8 7) '(13 10 9 8 7 2))
;-> nil
(maggiore '(13 10 9 8 7 2) '(13 10 9 8 7))
;-> true
(maggiore '(13 10 9 8 7) '(12 10 9 8 7 2))
;-> true
(maggiore '(12 9 9 8 7) '(12 10 9 8 7 2))
;-> nil
(maggiore '(14 4) '(14 3 6 7 8 9))
;-> true
(maggiore '(14 4) '(14 5 6 7 8 9))
;-> nil

Adesso possiamo scrivere la funzione finale:

(define (e054)
  (setq raw (read-file "054_poker.txt"))
  (setq data (parse raw "\r\n"))
  (setq data (map list data))
  (setq mani '())
  (dolist (el data)
    (setq row (first el))
    ;(println row)
    (setq val-p1 (explode (select row '(0 3 6 9 12))))
    (replace "A" val-p1 "14")
    (replace "K" val-p1 "13")
    (replace "Q" val-p1 "12")
    (replace "J" val-p1 "11")
    (replace "T" val-p1 "10")
    (setq val-p1 (sort (map int val-p1)))
    (setq val-p2 (explode (select row '(15 18 21 24 27))))
    (replace "A" val-p2 "14")
    (replace "K" val-p2 "13")
    (replace "Q" val-p2 "12")
    (replace "J" val-p2 "11")
    (replace "T" val-p2 "10")
    (setq val-p2 (sort (map int val-p2)))
    ; i semi non vengono ordinati perchè ci servono
    ; solo per calcolare "colore"
    (setq sem-p1 (select row '(1 4 7 10 13)))
    (setq sem-p2 (select row '(16 19 22 25 28)))
    (push (list val-p1 sem-p1 val-p2 sem-p2) mani -1)
    mani
  )
  ;(println (length mani))
  (setq val-p1 0)
  (setq val-p2 0)
  (dolist (el mani)
    (setq p1 (first (calcola (el 0) (el 1))))
    (setq p2 (first (calcola (el 2) (el 3))))
    (if (maggiore p1 p2)
        (begin
          ;(println (el 0) { } (el 1))
          ;(println (el 2) { } (el 3))
          ;(println p1 { } p2)
          (++ val-p1)
          ;(read-line)
        )
    )
  )
  val-p1
)

Calcoliamo la soluzione:

(e054)
;-> 376

(time (e054))
;-> 154.756
----------------------------------------------------------------------------


===========
Problema 55
===========

Numeri di Lychrel

Se prendiamo 47, lo invertiamo e lo aggiungiamo, otteniamo 47 + 74 = 121, che è palindromo.

Non tutti i numeri producono palindromi così rapidamente. Per esempio,

349 + 943 = 1292,
1292 + 2921 = 4213
4213 + 3124 = 7337

Cioè, 349 impiega tre iterazioni per arrivare a un palindromo.

Sebbene nessuno lo abbia ancora dimostrato, si ritiene che alcuni numeri, come 196, non producano mai un palindromo. Un numero che non forma mai un palindromo attraverso il processo di inversione e aggiunta si chiama numero Lychrel. A causa della natura teorica di questi numeri e ai fini di questo problema, supponiamo che un numero sia Lychrel fino a prova contraria. Inoltre, ti viene dato che per ogni numero inferiore a diecimila, o (i) diventerà un palindromo in meno di cinquanta iterazioni, o (ii) nessuno, con tutta la potenza di calcolo esistente, è riuscito finora a mapparlo su un palindromo. Infatti, 10677 è il primo numero in cui è stato dimostrato di richiedere oltre cinquanta iterazioni prima di produrre un palindromo: 4668731596684224866951378664 (53 iterazioni, 28 cifre).

Sorprendentemente, ci sono numeri palindromi che sono essi stessi numeri Lychrel (il primo esempio è 4994).

Quanti numeri Lychrel ci sono sotto diecimila?

NOTA: il testo è stato leggermente modificato il 24 aprile 2007 per enfatizzare la natura teorica dei numeri di Lychrel.
============================================================================

Funzione che inverte le cifre un numero:

(define (inverti n)
  (int (reverse (string n)) 0 10))

Da notare che la funzione "int" considera in base ottale il suo argomento se tale numero inizia con uno "0".

(int "055")
;-> 45

Per specificare una conversione decimale occorre specificarlo:

(int "055" 0 10)
;-> 55

(inverti 12345)
;-> 54321

Funzione che controlla se un numero è palindromo:

(define (pali? n) (= n (inverti n)))

(pali? 12344321)
;-> true
(pali? 123454321)
;-> true
(pali? 123211)
;-> nil

Funzione che controlla se un numero è di Lychrel:

(define (lychrel? num)
  (local (a b found lyc zzz)
    (setq zzz num)
    (setq found nil)
    (setq lyc true)
    (for (i 1 50 1 found)
      (setq a num)
      (setq b (inverti a))
      ;(println "num: " zzz { } "i: " i { } "a: " a { } "b: " b { } "a+b: " (+ a b))
      (if (pali? (+ a b))
        (begin
          (setq lyc nil)
          (setq found true)
          ;(println "NUM: " zzz { } "i: " i { } "a: " a { } "b: " b { } "a+b: " (+ a b))
        )
      )
      (setq num (+ a b))
    )
    lyc
  )
)

(lychrel? 47)
;-> nil

Funzione finale (versione 1):

(define (e053 prove)
  (let (out 0)
    (for (i 1 prove)
      (if (lychrel? i) (++ out))
    )
    out))

(e053 10000)
;-> 249
(time (e053 10000))
;-> 116.877

Funzione finale (versione 2):

(define (e053 n)
  (count '(true) (map lychrel? (sequence 1 n))))

(e053 10000)
;-> (249)
(time (e053 10000))
;-> 125.839
----------------------------------------------------------------------------


===========
Problema 56
===========

Somma di cifre di potenza

Un googol (10^100) è un numero enorme: uno seguito da cento zeri. 100^100 è quasi inimmaginabilmente grande: uno seguito da duecento zeri. Nonostante le loro dimensioni, la somma delle cifre in ciascun numero è solo 1.

Considerando i numeri naturali della forma a^b, dove a, b < 100, qual'è la somma massima delle cifre?
============================================================================

Funzione che calcola la somma delle cifre di un numero:

(define (digit-sum n)
  (let (out 0)
    (while (!= n 0)
      (setq out (+ out (% n 10)))
      (setq n (/ n 10))
    )
    out))

(digit-sum 123456789L)
;-> 45

Funzione che calcola la potenza intera di due numeri interi:

(define (** x p)
    (let (y 1L)
        (dotimes (i p)
            (setq y (* y x)))))

(** 35 21)
;-> 266335422555582049846649169921875L

(digit-sum 266335422555582049846649169921875L)
;-> 161

(+ 2 6 6 3 3 5 4 2 2 5 5 5 5 8 2 0 4 9 8 4 6 6 4 9 1 6 9 9 2 1 8 7 5)
;-> 161

Funzione soluzione:

(define (e056)
  (local (somma somma-max)
    (setq somma-max 0)
    (for (a 75 100)
      (for (b 75 100)
        (setq somma (digit-sum (** a b)))
        (if (> somma somma-max) (setq somma-max somma))
      )
    )
    somma-max))

(e056)
;-> 972

(time (e056))
;-> 199.794

Possiamo scrivere la funzione anche in stile funzionale.

Questa funzione calcola tutte le potenza di ogni elemento della prima lista elevato ad ogni elemento della seconda lista (prodotto cartesiano):

(define (cp lst1 lst2)
  (let (out '())
    (if (or (null? lst1) (null? lst2))
        nil
        (dolist (el1 lst1)
          (dolist (el2 lst2)
            (push (** el1 el2) out -1))))))

Funzione soluzione:

(define (e056)
  (apply max (map digit-sum (cp (map bigint (sequence 75 100))
                                (map bigint (sequence 75 100))))))

(e056)
;-> 972

(time (e056))
;-> 186.794
----------------------------------------------------------------------------


===========
Problema 57
===========

È possibile dimostrare che la radice quadrata di due può essere espressa come una frazione continua infinita.

sqrt(2) = 1 + 1 / (2 + 1 / (2 + 1 / (2 +...))) = 1.414213...

Espandendo questo per le prime quattro iterazioni, otteniamo:

1 + 1/2 = 3/2 = 1.5
1 + 1 / (2 + 1/2) = 7/5 = 1.4
1 + 1 / (2 + 1 / (2 + 1/2)) = 17/12 = 1.41666...
1 + 1 / (2 + 1 / (2 + 1 / (2 + 1/2))) = 41/29 = 1.41379...

Le tre espansioni successive sono 99/70, 239/169 e 577/408, ma l'ottava espansione, 1393/985, è il primo esempio in cui il numero di cifre nel numeratore supera il numero di cifre nel denominatore.

Nelle prime mille espansioni, quante frazioni contengono un numeratore con più cifre del denominatore?
============================================================================

La sequenza a(k) inizia con a(0) = 1 + 1/2 e a(1) = (1 + (1 / (2 + 1/2))), sostituendo a(0) in a(1) otteniamo a(1) = 1 + (1 / (1 + a(0))). Quindi possiamo scrivere:

                                        1
a(k+1) = 1 + (1 / (1 + a(k))) = 1 + ----------
                                     1 + a(k)

Invece di utilizzare la libreria delle frazioni per calcolare il numeratore e il denominatore di ogni iterazione, possiamo espandere a(k+1):

a(k+1) = 1 + (1 / (1 + a(k))) = 1 + (1 / (1 + nk/dk)) =
       = 1 + (1 / (1 + nk/dk)) = 1 + (1 / (1 + (dk + nk)/dk) =
       = 1 + dk/(dk + nk) = (dk + nk + dk)/(dk + nk) =
       = (2*dk + nk)/(dk + nk)

Usiamo questa formula per calcolare il numeratore e il denominatore per ogni iterazione, poi confrontiamo le loro lunghezze e incrementiamo il contatore:

(define (e057 num)
  (local (n d tn td out)
    (setq out 0)
    (setq n 1L)
    (setq d 1L)
    (for (i 0 num)
      (setq tn n)
      (setq td d)
      (setq n (+ (* 2L td) tn))
      (setq d (+ td tn))
      ;(println n { } d)
      (if (> (length n) (length d)) (++ out))
    )
    out
  )
)

(e057 1000)
;-> 153

(time (e057 1000))
;-> 10.036
----------------------------------------------------------------------------


===========
Problema 58
===========
Numeri primi a spirale

A partire da 1 e creando una spirale in senso antiorario, si forma una spirale quadrata con lato di lunghezza 7:

37 36 35 34 33 32 31
38 17 16 15 14 13 30
39 18  5  4  3 12 29
40 19  6  1  2 11 28
41 20  7  8  9 10 27
42 21 22 23 24 25 26
43 44 45 46 47 48 49

È interessante notare che i quadrati dispari si trovano lungo la diagonale in basso a destra, ma ciò che è più interessante è che 8 dei 13 numeri che giacciono lungo entrambe le diagonali sono primi (43 7 3 13 31) e (37 17 5). Cioè, un rapporto dell'8/13 ≈ 62%.

Se un nuovo strato completo viene avvolto attorno alla spirale sopra, verrà formata una spirale quadrata con lunghezza laterale 9. Se questo processo continua, qual è la lunghezza laterale della spirale quadrata per la quale il rapporto dei numeri primi lungo entrambe le diagonali scende prima sotto il 10%?
============================================================================

La spirale di lato 9 è la seguente:

 65 64 63 62 61 60 59 58 57
 66 37 36 35 34 33 32 31 56
 67 38 17 16 15 14 13 30 55
 68 39 18  5  4  3 12 29 54
 69 40 19  6  1  2 11 28 53
 70 41 20  7  8  9 10 27 52
 71 42 21 22 23 24 25 26 51
 72 43 44 45 46 47 48 49 50
 73 74 75 76 77 78 79 80 81

Occorre notare che partendo da k=1 i valori che cerchiamo sono:

lato = 2*k + 1
basso-dx = (2*k + 1)^2
alto-dx  = (basso-dx - 6*k)
alto-sx  = (basso-dx - 4*k)
basso-sx = (basso-dx - 2*k)

Quindi ad ogni iterazione/spirale dobbiamo solo controllare se questi quattro numeri sono primi ed eventualmente aggiornare il conteggio dei numeri primi totali.

Iterazione 1:
5  4  3
6  1  2
7  8  9

Iterazione 2:
17 16 15 14 13
18  5  4  3 12
19  6  1  2 11
20  7  8  9 10
21 22 23 24 25

Iterazione 3:
37 36 35 34 33 32 31
38 17 16 15 14 13 30
39 18  5  4  3 12 29
40 19  6  1  2 11 28
41 20  7  8  9 10 27
42 21 22 23 24 25 26

...e così via.

Possiamo scrivere la funzione di soluzione:

(define (primo? n)
   (if (< n 2) nil
       (= 1 (length (factor n)))))

(define (e058 n)
  (local (numeriDiag numeriPrimi perc lato found
          alto-dx alto-sx basso-dx basso-sx)
    (setq found nil)
    (setq numeriDiag 1)
    (setq numeriPrimi 0)
    (setq perc 0)
    (for (side 1 n 1 found)
      (setq lato (+ (* 2 side) 1))
      ;(setq basso-dx (* (+ (* 2 side) 1) (+ (* 2 side) 1)))
      (setq basso-dx (* lato lato))
      (setq alto-dx (- basso-dx (* 6 side)))
      (setq alto-sx (- basso-dx (* 4 side)))
      (setq basso-sx (- basso-dx (* 2 side)))
      ;(println alto-dx { } alto-sx { } basso-sx { } basso-dx)
      (setq numeriDiag (+ (* 2 lato) 1))
      ;(if (primo? basso-dx) (++ numeriPrimi))
      (if (primo? alto-dx) (++ numeriPrimi))
      (if (primo? basso-sx) (++ numeriPrimi))
      (if (primo? alto-sx) (++ numeriPrimi))
      (setq perc (div numeriPrimi numeriDiag))
      ;(println side { } lato { } numeriPrimi { } numeriDiag { } perc)
      (if (< perc 0.1) (setq found true))
    )
    (list lato perc numeriPrimi numeriDiag)
  )
)

(e058 50000)
;-> (26241 0.09999428386334623 5248 52483)

(time (e058 50000))
;-> 630.190
----------------------------------------------------------------------------


===========
Problema 59
===========

Decodifica XOR

A ciascun carattere di un computer viene assegnato un codice univoco e lo standard preferito è ASCII (American Standard Code for Information Interchange). Ad esempio, A maiuscola = 65, asterisco (*) = 42 e k minuscola = 107.

Un moderno metodo di crittografia è quello di prendere un file di testo, convertire i byte in ASCII, quindi fare lo XOR ad ogni byte con un dato valore, preso da una chiave segreta. Il vantaggio con la funzione XOR è che l'uso della stessa chiave di crittografia sul testo cifrato ripristina il testo normale, ad esempio, 65 XOR 42 = 107, quindi 107 XOR 42 = 65.

Per avere una criptazione inviolabile, la chiave deve avere la stessa lunghezza del messaggio di testo normale e la chiave deve essere composta da byte casuali. Se l'utente tiene il messaggio crittografato e la chiave di crittografia in posti diversi allora è impossibile decrittografare il messaggio senza entrambe le 'metà' (messaggio crittografato e chiave).

Sfortunatamente, questo metodo non è pratico per la maggior parte degli utenti, quindi il metodo modificato è usare una password come chiave. Se la password è più corta del messaggio, il che è probabile, la chiave viene ripetuta ciclicamente in tutto il messaggio. Il giusto bilanciamento è quello di usare una chiave (password) sufficientemente lunga per la sicurezza, ma abbastanza corta per essere ricordata.

Il tuo compito è stata semplificato, poiché la chiave di crittografia è composta da tre caratteri minuscoli. Utilizzando il file "p059_cipher.txt" che contiene i codici ASCII crittografati e sapendo che il testo normale (decifrato) contiene parole inglesi comuni, decodificare il messaggio e trovare la somma dei valori ASCII dei caratteri contenuti nel testo originale.
============================================================================

Assegniamo i valori contenuti nel file "p059_cipher.txt" ad una lista:

(setq tc '(79 59 12 2 79 35 8 28 20 2 3 68 8 9 68 45 0 12 9 67
68 4 7 5 23 27 1 21 79 85 78 79 85 71 38 10 71 27 12 2
79 6 2 8 13 9 1 13 9 8 68 19 7 1 71 56 11 21 11 68
6 3 22 2 14 0 30 79 1 31 6 23 19 10 0 73 79 44 2 79
19 6 28 68 16 6 16 15 79 35 8 11 72 71 14 10 3 79 12 2
79 19 6 28 68 32 0 0 73 79 86 71 39 1 71 24 5 20 79 13
9 79 16 15 10 68 5 10 3 14 1 10 14 1 3 71 24 13 19 7
68 32 0 0 73 79 87 71 39 1 71 12 22 2 14 16 2 11 68 2
25 1 21 22 16 15 6 10 0 79 16 15 10 22 2 79 13 20 65 68
41 0 16 15 6 10 0 79 1 31 6 23 19 28 68 19 7 5 19 79
12 2 79 0 14 11 10 64 27 68 10 14 15 2 65 68 83 79 40 14
9 1 71 6 16 20 10 8 1 79 19 6 28 68 14 1 68 15 6 9
75 79 5 9 11 68 19 7 13 20 79 8 14 9 1 71 8 13 17 10
23 71 3 13 0 7 16 71 27 11 71 10 18 2 29 29 8 1 1 73
79 81 71 59 12 2 79 8 14 8 12 19 79 23 15 6 10 2 28 68
19 7 22 8 26 3 15 79 16 15 10 68 3 14 22 12 1 1 20 28
72 71 14 10 3 79 16 15 10 68 3 14 22 12 1 1 20 28 68 4
14 10 71 1 1 17 10 22 71 10 28 19 6 10 0 26 13 20 7 68
14 27 74 71 89 68 32 0 0 71 28 1 9 27 68 45 0 12 9 79
16 15 10 68 37 14 20 19 6 23 19 79 83 71 27 11 71 27 1 11
3 68 2 25 1 21 22 11 9 10 68 6 13 11 18 27 68 19 7 1
71 3 13 0 7 16 71 28 11 71 27 12 6 27 68 2 25 1 21 22
11 9 10 68 10 6 3 15 27 68 5 10 8 14 10 18 2 79 6 2
12 5 18 28 1 71 0 2 71 7 13 20 79 16 2 28 16 14 2 11
9 22 74 71 87 68 45 0 12 9 79 12 14 2 23 2 3 2 71 24
5 20 79 10 8 27 68 19 7 1 71 3 13 0 7 16 92 79 12 2
79 19 6 28 68 8 1 8 30 79 5 71 24 13 19 1 1 20 28 68
19 0 68 19 7 1 71 3 13 0 7 16 73 79 93 71 59 12 2 79
11 9 10 68 16 7 11 71 6 23 71 27 12 2 79 16 21 26 1 71
3 13 0 7 16 75 79 19 15 0 68 0 6 18 2 28 68 11 6 3
15 27 68 19 0 68 2 25 1 21 22 11 9 10 72 71 24 5 20 79
3 8 6 10 0 79 16 8 79 7 8 2 1 71 6 10 19 0 68 19
7 1 71 24 11 21 3 0 73 79 85 87 79 38 18 27 68 6 3 16
15 0 17 0 7 68 19 7 1 71 24 11 21 3 0 71 24 5 20 79
9 6 11 1 71 27 12 21 0 17 0 7 68 15 6 9 75 79 16 15
10 68 16 0 22 11 11 68 3 6 0 9 72 16 71 29 1 4 0 3
9 6 30 2 79 12 14 2 68 16 7 1 9 79 12 2 79 7 6 2
1 73 79 85 86 79 33 17 10 10 71 6 10 71 7 13 20 79 11 16
1 68 11 14 10 3 79 5 9 11 68 6 2 11 9 8 68 15 6 23
71 0 19 9 79 20 2 0 20 11 10 72 71 7 1 71 24 5 20 79
10 8 27 68 6 12 7 2 31 16 2 11 74 71 94 86 71 45 17 19
79 16 8 79 5 11 3 68 16 7 11 71 13 1 11 6 1 17 10 0
71 7 13 10 79 5 9 11 68 6 12 7 2 31 16 2 11 68 15 6
9 75 79 12 2 79 3 6 25 1 71 27 12 2 79 22 14 8 12 19
79 16 8 79 6 2 12 11 10 10 68 4 7 13 11 11 22 2 1 68
8 9 68 32 0 0 73 79 85 84 79 48 15 10 29 71 14 22 2 79
22 2 13 11 21 1 69 71 59 12 14 28 68 14 28 68 9 0 16 71
14 68 23 7 29 20 6 7 6 3 68 5 6 22 19 7 68 21 10 23
18 3 16 14 1 3 71 9 22 8 2 68 15 26 9 6 1 68 23 14
23 20 6 11 9 79 11 21 79 20 11 14 10 75 79 16 15 6 23 71
29 1 5 6 22 19 7 68 4 0 9 2 28 68 1 29 11 10 79 35
8 11 74 86 91 68 52 0 68 19 7 1 71 56 11 21 11 68 5 10
7 6 2 1 71 7 17 10 14 10 71 14 10 3 79 8 14 25 1 3
79 12 2 29 1 71 0 10 71 10 5 21 27 12 71 14 9 8 1 3
71 26 23 73 79 44 2 79 19 6 28 68 1 26 8 11 79 11 1 79
17 9 9 5 14 3 13 9 8 68 11 0 18 2 79 5 9 11 68 1
14 13 19 7 2 18 3 10 2 28 23 73 79 37 9 11 68 16 10 68
15 14 18 2 79 23 2 10 10 71 7 13 20 79 3 11 0 22 30 67
68 19 7 1 71 8 8 8 29 29 71 0 2 71 27 12 2 79 11 9
3 29 71 60 11 9 79 11 1 79 16 15 10 68 33 14 16 15 10 22 73))

Vediamo come criptare/decriptare un carattere con la funzione XOR:

(char "a")
;-> 97

(char "k")
;-> 107

Cripta il valore (ASCII) del carattere "a" con il valore della chiave "k":
(^ 97 107)
;-> 10

Decripta il valore criptato (10) con il valore della chiave "k":
(^ 10 107)
;-> 97

Funzione di criptazione:

(define (crypt ch key)
  (char (^ (char ch) (char key))))

(crypt "a" "k")
;-> "\n"

Funzione di decriptazione:

(define (decrypt ch key)
  (char (^ (char ch) (char key))))

(decrypt (crypt "a" "k") "k")
;-> "a"

Nota: le funzione di criptazione e decriptazione sono identiche.

Adesso scriviamo una funzione che cripta una stringa con una data password.

(define (crypt ch key)
  (char (^ (char ch) (char key))))

(crypt "a" "k")
;-> "\n"

(define (decrypt ch key)
  (char (^ (char ch) (char key))))

(decrypt (crypt "a" "k") "k")
;-> "a"

Adesso scriviamo una funzione che cripta una stringa con una data password.

(define (crypt-text text pwd)
  (local (k lst len out)
    (setq out '())
    (setq numchar (- (length pwd) 1))
    ;(setq lst (explode text)) ; non UTF-8
    (setq lst (unpack (dup "s" (length text)) text)) ; UTF-8
    (setq k 0)
    (dolist (el lst)
      (push (crypt el (pwd k)) out -1)
      (++ k)
      (if (= k numchar) (setq k 0))
    )
    (join out)))

(crypt-text "Massimo" "pwd")
;-> "=\022\003\004\025\026\031"

(crypt-text "=\022\003\004\025\026\031" "pwd")
;-> Massimo

(crypt-text (crypt-text "cryptomessage" "password") "password")
;-> cryptomessage

Per il nostro scopo è più conveniente avere in input una lista di codici ASCII (la nostra lista tc):

(define (crypt-text text pwd)
  ; text: testo in una lista di numeri ASCII
  (local (k lst len out)
    (setq out '())
    (setq numchar (length pwd))
    (setq k 0)
    (dolist (el text)
      (push (^ el (char (pwd k))) out -1)
      (++ k)
      (if (= k numchar) (setq k 0))
    )
    out
  )
)

(crypt-text (map char (explode "Massimo Eva")) "pwd")
;-> (61 22 23 3 30 9 31 87 33 6 22)

(join (map char (crypt-text '(61 22 23 3 30 9 31 87 33 6 22) "pwd")))
;-> "Massimo Eva"

Adesso dobbiamo trovare la chiave (password) del testo cifrato. Sappiamo che è formata da tre lettere minuscole. Facciamo l'analisi delle frequenze al testo cifrato.

Frequenza dei caratteri nella lingua inglese:
http://www.data-compression.com/english.html

|=========|=========|=========|=========|=========|=========|=========|
|    a    |    b    |    c    |    d    |    e    |    f    |    g    |
|=========|=========|=========|=========|=========|=========|=========|
 0.0651738 0.0124248 0.0217339 0.0349835 0.1041442 0.0197881 0.0158610

|=========|=========|=========|=========|=========|=========|=========|
|    h    |    i    |    j    |    k    |    l    |    m    |    n    |
|=========|=========|=========|=========|=========|=========|=========|
 0.0492888 0.0558094 0.0009033 0.0050529 0.0331490 0.0202124 0.0564513

|=========|=========|=========|=========|=========|=========|=========|
|    o    |    p    |    q    |    r    |    s    |    t    |    u    |
|=========|=========|=========|=========|=========|=========|=========|
 0.0596302 0.0137645 0.0008606 0.0497563 0.0515760 0.0729357 0.0225134

|=========|=========|=========|=========|=========|=========|
|    v    |    w    |    x    |    y    |    z    |  SPACE  |
|=========|=========|=========|=========|=========|=========|
 0.0082903 0.0171272 0.0013692 0.0145984 0.0007836 0.1918182

(setq af '(
 (0.0651738 "a") (0.0124248 "b") (0.0217339 "c") (0.0349835 "d")
 (0.1041442 "e") (0.0197881 "f") (0.0158610 "g") (0.0492888 "h")
 (0.0558094 "i") (0.0009033 "j") (0.0050529 "k") (0.0331490 "l")
 (0.0202124 "m") (0.0564513 "n") (0.0596302 "o") (0.0137645 "p")
 (0.0008606 "q") (0.0497563 "r") (0.0515760 "s") (0.0729357 "t")
 (0.0225134 "u") (0.0082903 "v") (0.0171272 "w") (0.0013692 "x")
 (0.0145984 "y") (0.0007836 "z") (0.1918182 " ")))

(sort af >)
;-> ((0.1918182 " ") (0.1041442 "e") (0.0729357 "t") (0.0651738 "a")
;->  (0.0596302 "o") (0.0564513 "n") (0.0558094 "i") (0.051576 "s")
;->  (0.0497563 "r") (0.0492888 "h") (0.0349835 "d") (0.033149 "l")
;->  (0.0225134 "u") (0.0217339 "c") (0.0202124 "m") (0.0197881 "f")
;->  (0.0171272 "w") (0.015861 "g")  (0.0145984 "y") (0.0137645 "p")
;->  (0.0124248 "b") (0.0082903 "v") (0.0050529 "k") (0.0013692 "x")
;->  (0.0009033 "j") (0.0008606 "q") (0.0007836 "z"))

Quindi il carattere spazio " " è quello di gran lunga più frequente (quasi il 20%). Per il nostro algoritmo sarà sufficiente utilizzare questo carattere.

Vediamo quali sono i valori più frequenti nel testo cifrato:

(apply max tc)
;-> 94
(setq freq (array 95 '(0)))

(dolist (el tc) (setf (freq el) (+ (freq el) 1)))
freq
;-> (49 63 60 37 5 21 49 41 34 41 60 54 31 24 38 26 38 9 10 35
;->  22 15 22 17 9 6 6 21 21 11 4 4 4 2 0 3 0 2 2 2 1 1 0 0 2
;->  4 0 0 1 0 0 0 1 0 0 0 2 0 0 4 1 0 0 0 1 2 0 2 77 1 0 70 5
;->  11 4 5 0 0 1 86 0 1 0 2 1 5 4 3 0 1 0 1 1 1 1)

Converto il vettore in lista:

(setq f (array-list freq))
f

Lista di frequenze ordinata:

(sort (copy f) >)
;-> (86 77 70 63 60 60 54 49 49 41 41 38 38 37 35 34 31 26 24 22 22 21 21 21 17 15 11
;->  11 10 9 9 6 6 5 5 5 5 4 4 4 4 4 4 4 3 3 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1
;->  1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)

Il valore più frequente del testo cifrato è 86.

Posizione (valore ASCII criptato):

(ref 86 f)
;-> (79)

Associo il valore 79 al carattere " " (che è il più frequente in lingua inglese). Quindi trovo il carattere della chiave che restituisce uno spazio " ":

(dolist (el (explode "abcdefghijlklmnopqrstuvwxyz "))
  (if (= " " (char (^ 79 (char el))))
    (println el)))
;-> o

Un carattere della chiave è "o".

Lo stesso ragionamento può essere fatto con il secondo valore più frequente del testo cifrato, cioè 77.
Infatti, poichè ogni carattere della chiave codifica (quasi) lo stesso numero di caratteri

Posizione (valore ASCII criptato):

(ref 77 f)
;-> (68)

(dolist (el (explode "abcdefghijlklmnopqrstuvwxyz "))
  (if (= " " (char (^ 68 (char el))))
    (println el)))
;-> d

Un altro carattere della chiave è "d".

Lo stesso ragionamento può essere fatto con il terzo valore più frequente del testo cifrato, cioè 70.

Posizione (valore ASCII criptato):

(ref 70 f)
;-> (71)

(dolist (el (explode "abcdefghijlklmnopqrstuvwxyz "))
  (if (= " " (char (^ 71 (char el))))
    (println el)))
;-> g

Il terzo carattere della chiave è "g".

La chiave è composta dai caratteri "o", "d" e "g". Proviamo con "dog":

(setq testo (join (map char (crypt-text tc "dog"))))

In questo caso otteniamo un testo illeggibile.

Proviamo con "god":

(setq testo (join (map char (crypt-text tc "god"))))
;-> "(The Gospel of John, chapter 1) 1 In the beginning the Word already existed. He was with God, and he was God. 2 He was in the beginning with God. 3 He created everything there is. Nothing exists that he didn't make. 4 Life itself was in him, and this life gives light to everyone. 5 The light shines through the darkness, and the darkness can never extinguish it. 6 God sent John the Baptist 7 to tell everyone about the light so that everyone might believe because of his testimony. 8 John himself was not the light; he was only a witness to the light. 9 The one who is the true light, who gives light to everyone, was going to come into the world. 10 But although the world was made through him, the world didn't recognize him when he came. 11 Even in his own land and among his own people, he was not accepted. 12 But to all who believed him and accepted him, he gave the right to become children of God. 13 They are reborn! This is not a physical birth resulting from human passion or plan, this rebirth comes from God.14 So the Word became human and lived here on earth among us. He was full of unfailing love and faithfulness. And we have seen his glory, the glory of the only Son of the Father."

Testo decifrato correttamente. Vediamo la somma dei valori ASCII del testo decifrato:

(setq sol (apply + (map char (explode testo))))
;-> 107359

(define (e059)
  (setq testo (join (map char (crypt-text tc "god"))))
  (setq sol (apply + (map char (explode testo)))))

(e059)
;-> 107359

(time (e059))
;-> 15.625

Il tempo registrato non è quello che include tutti i calcoli, ma credo che una funzione completa che utilizza questo metodo non dovrebbe impiegare più di 2/3 secondi per trovare la soluzione.

Sembra che il sito di Project Euler abbia cambiato il contenuto del file "p059_cipher.txt".
Proviamo il nostro metodo con questo nuovo file.

Assegniamo i valori contenuti nel file ad una lista:

(setq tc1 '(
 36 22 80 0 0 4 23 25 19 17 88 4 4 19 21 11 88 22 23 23 29 69
 12 24 0 88 25 11 12 2 10 28 5 6 12 25 10 22 80 10 30 80 10 22
 21 69 23 22 69 61 5 9 29 2 66 11 80 8 23 3 17 88 19 0 20 21
 7 10 17 17 29 20 69 8 17 21 29 2 22 84 80 71 60 21 69 11 5 8
 21 25 22 88 3 0 10 25 0 10 5 8 88 2 0 27 25 21 10 31 6 25
 2 16 21 82 69 35 63 11 88 4 13 29 80 22 13 29 22 88 31 3 88 3
 0 10 25 0 11 80 10 30 80 23 29 19 12 8 2 10 27 17 9 11 45 95
 88 57 69 16 17 19 29 80 23 29 19 0 22 4 9 1 80 3 23 5 11 28
 92 69 9 5 12 12 21 69 13 30 0 0 0 0 27 4 0 28 28 28 84 80
 4 22 80 0 20 21 2 25 30 17 88 21 29 8 2 0 11 3 12 23 30 69
 30 31 23 88 4 13 29 80 0 22 4 12 10 21 69 11 5 8 88 31 3 88
 4 13 17 3 69 11 21 23 17 21 22 88 65 69 83 80 84 87 68 69 83 80
 84 87 73 69 83 80 84 87 65 83 88 91 69 29 4 6 86 92 69 15 24 12
 27 24 69 28 21 21 29 30 1 11 80 10 22 80 17 16 21 69 9 5 4 28
 2 4 12 5 23 29 80 10 30 80 17 16 21 69 27 25 23 27 28 0 84 80
 22 23 80 17 16 17 17 88 25 3 88 4 13 29 80 17 10 5 0 88 3 16
 21 80 10 30 80 17 16 25 22 88 3 0 10 25 0 11 80 12 11 80 10 26
 4 4 17 30 0 28 92 69 30 2 10 21 80 12 12 80 4 12 80 10 22 19
 0 88 4 13 29 80 20 13 17 1 10 17 17 13 2 0 88 31 3 88 4 13
 29 80 6 17 2 6 20 21 69 30 31 9 20 31 18 11 94 69 54 17 8 29
 28 28 84 80 44 88 24 4 14 21 69 30 31 16 22 20 69 12 24 4 12 80
 17 16 21 69 11 5 8 88 31 3 88 4 13 17 3 69 11 21 23 17 21 22
 88 25 22 88 17 69 11 25 29 12 24 69 8 17 23 12 80 10 30 80 17 16
 21 69 11 1 16 25 2 0 88 31 3 88 4 13 29 80 21 29 2 12 21 21
 17 29 2 69 23 22 69 12 24 0 88 19 12 10 19 9 29 80 18 16 31 22
 29 80 1 17 17 8 29 4 0 10 80 12 11 80 84 67 80 10 10 80 7 1
 80 21 13 4 17 17 30 2 88 4 13 29 80 22 13 29 69 23 22 69 12 24
 12 11 80 22 29 2 12 29 3 69 29 1 16 25 28 69 12 31 69 11 92 69
 17 4 69 16 17 22 88 4 13 29 80 23 25 4 12 23 80 22 9 2 17 80
 70 76 88 29 16 20 4 12 8 28 12 29 20 69 26 9 69 11 80 17 23 80
 84 88 31 3 88 4 13 29 80 21 29 2 12 21 21 17 29 2 69 12 31 69
 12 24 0 88 20 12 25 29 0 12 21 23 86 80 44 88 7 12 20 28 69 11
 31 10 22 80 22 16 31 18 88 4 13 25 4 69 12 24 0 88 3 16 21 80
 10 30 80 17 16 25 22 88 3 0 10 25 0 11 80 17 23 80 7 29 80 4
 8 0 23 23 8 12 21 17 17 29 28 28 88 65 75 78 68 81 65 67 81 72
 70 83 64 68 87 74 70 81 75 70 81 67 80 4 22 20 69 30 2 10 21 80
 8 13 28 17 17 0 9 1 25 11 31 80 17 16 25 22 88 30 16 21 18 0
 10 80 7 1 80 22 17 8 73 88 17 11 28 80 17 16 21 11 88 4 4 19
 25 11 31 80 17 16 21 69 11 1 16 25 2 0 88 2 10 23 4 73 88 4
 13 29 80 11 13 29 7 29 2 69 75 94 84 76 65 80 65 66 83 77 67 80
 64 73 82 65 67 87 75 72 69 17 3 69 17 30 1 29 21 1 88 0 23 23
 20 16 27 21 1 84 80 18 16 25 6 16 80 0 0 0 23 29 3 22 29 3
 69 12 24 0 88 0 0 10 25 8 29 4 0 10 80 10 30 80 4 88 19 12
 10 19 9 29 80 18 16 31 22 29 80 1 17 17 8 29 4 0 10 80 12 11
 80 84 86 80 35 23 28 9 23 7 12 22 23 69 25 23 4 17 30 69 12 24
 0 88 3 4 21 21 69 11 4 0 8 3 69 26 9 69 15 24 12 27 24 69
 49 80 13 25 20 69 25 2 23 17 6 0 28 80 4 12 80 17 16 25 22 88
 3 16 21 92 69 49 80 13 25 6 0 88 20 12 11 19 10 14 21 23 29 20
 69 12 24 4 12 80 17 16 21 69 11 5 8 88 31 3 88 4 13 29 80 22
 29 2 12 29 3 69 73 80 78 88 65 74 73 70 69 83 80 84 87 72 84 88
 91 69 73 95 87 77 70 69 83 80 84 87 70 87 77 80 78 88 21 17 27 94
 69 25 28 22 23 80 1 29 0 0 22 20 22 88 31 11 88 4 13 29 80 20
 13 17 1 10 17 17 13 2 0 88 31 3 88 4 13 29 80 6 17 2 6 20
 21 75 88 62 4 21 21 9 1 92 69 12 24 0 88 3 16 21 80 10 30 80
 17 16 25 22 88 29 16 20 4 12 8 28 12 29 20 69 26 9 69 65 64 69
 31 25 19 29 3 69 12 24 0 88 18 12 9 5 4 28 2 4 12 21 69 80
 22 10 13 2 17 16 80 21 23 7 0 10 89 69 23 22 69 12 24 0 88 19
 12 10 19 16 21 22 0 10 21 11 27 21 69 23 22 69 12 24 0 88 0 0
 10 25 8 29 4 0 10 80 10 30 80 4 88 19 12 10 19 9 29 80 18 16
 31 22 29 80 1 17 17 8 29 4 0 10 80 12 11 80 84 86 80 36 22 20
 69 26 9 69 11 25 8 17 28 4 10 80 23 29 17 22 23 30 12 22 23 69
 49 80 13 25 6 0 88 28 12 19 21 18 17 3 0 88 18 0 29 30 69 25
 18 9 29 80 17 23 80 1 29 4 0 10 29 12 22 21 69 12 24 0 88 3
 16 21 3 69 23 22 69 12 24 0 88 3 16 26 3 0 9 5 0 22 4 69
 11 21 23 17 21 22 88 25 11 88 7 13 17 19 13 88 4 13 29 80 0 0
 0 10 22 21 11 12 3 69 25 2 0 88 21 19 29 30 69 22 5 8 26 21 23 11 94))

(apply max tc1)
;-> 95
(setq freq1 (array 96 '(0)))

(dolist (el tc1) (setf (freq1 el) (+ (freq1 el) 1)))
freq1
;-> (75 19 31 36 61 15 11 9 25 20 52 43 65 33 2 2 38 73 11 21 22 65
;->  56 46 21 42 7 10 25 70 26 24 0 0 0 2 2 0 0 0 0 0 0 0 2 1 0 0 0
;->  3 0 0 0 0 1 0 0 1 0 0 1 1 1 1 3 9 2 5 3 86 7 1 3 7 2 5 2 3 3 0
;->  107 4 2 8 16 0 4 9 77 1 0 2 6 0 4 2)

Converto il vettore in lista:

(setq f1 (array-list freq1))
f1

Lista di frequenze ordinata:

(sort (copy f1) >)
;-> (107 86 77 75 73 70 65 65 61 56 52 46 43 42 38 36 33 31 26 25 25 24
;->  22 21 21 20 19 16 15 11 11 10 9 9 9 8 7 7 7 6 5 5 4 4 4 3 3 3 3 3
;->  3 2 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0
;->  0 0 0 0 0 0 0 0 0 0 0 0 0)

Il valore più frequente del testo cifrato è 107.

Posizione (valore ASCII criptato):

(ref 107 f1)
;-> (80)

Associo il valore 80 al carattere " " (che è il più frequente in lingua inglese). Quindi trovo il carattere della chiave che restituisce uno spazio " ":

(dolist (el (explode "abcdefghijlklmnopqrstuvwxyz "))
  (if (= " " (char (^ 80 (char el))))
    (println el)))
;-> p

Un carattere della chiave è "p".

Lo stesso ragionamento può essere fatto con il secondo valore più frequente del testo cifrato, cioè 86.

Posizione (valore ASCII criptato):

(ref 86 f1)
;-> (69)

(dolist (el (explode "abcdefghijlklmnopqrstuvwxyz "))
  (if (= " " (char (^ 69 (char el))))
    (println el)))
;-> e

Un altro carattere della chiave è "e".

Lo stesso ragionamento può essere fatto con il terzo valore più frequente del testo cifrato, cioè 77.

Posizione (valore ASCII criptato):

(ref 77 f1)
;-> (88)

(dolist (el (explode "abcdefghijlklmnopqrstuvwxyz "))
  (if (= " " (char (^ 88 (char el))))
    (println el)))
;-> x

Il terzo carattere della chiave è "x".

La chiave è composta dai caratteri "p", "e" e "x".

Facciamo alcuni tentativi:

(setq testo (join (map char (crypt-text tc1 "xpe"))))
In questo caso otteniamo un testo illeggibile.

(setq testo (join (map char (crypt-text tc1 "pex"))))
In questo caso otteniamo un testo illeggibile.

(setq testo (join (map char (crypt-text tc1 "pxe"))))
In questo caso otteniamo un testo illeggibile.

(setq testo (join (map char (crypt-text tc1 "xep"))))
In questo caso otteniamo un testo illeggibile.

(setq testo (join (map char (crypt-text tc1 "exp"))))
;-> "An extract taken from the introduction of one of Euler's most celebrated papers, \"De summis serierum reciprocarum\" [On the sums of series of reciprocals]: I have recently found, quite unexpectedly, an elegant expression for the entire sum of this series 1 + 1/4 + 1/9 + 1/16 + etc., which depends on the quadrature of the circle, so that if the true sum of this series is obtained, from it at once the quadrature of the circle follows. Namely, I have found that the sum of this series is a sixth part of the square of the perimeter of the circle whose diameter is 1; or by putting the sum of this series equal to s, it has the ratio sqrt(6) multiplied by s to 1 of the perimeter to the diameter. I will soon show that the sum of this series to be approximately 1.644934066842264364; and from multiplying this number by six, and then taking the square root, the number 3.141592653589793238 is indeed produced, which expresses the perimeter of a circle whose diameter is 1. Following again the same steps by which I had arrived at this sum, I have discovered that the sum of the series 1 + 1/16 + 1/81 + 1/256 + 1/625 + etc. also depends on the quadrature of the circle. Namely, the sum of this multiplied by 90 gives the biquadrate (fourth power) of the circumference of the perimeter of a circle whose diameter is 1. And by similar reasoning I have likewise been able to determine the sums of the subsequent series in which the exponents are even numbers."

Testo decifrato correttamente.
La chiave vale "exp".

Vediamo la somma dei valori ASCII del testo decifrato:

(setq sol (apply + (map char (explode testo))))
;-> 129448
----------------------------------------------------------------------------


===========
Problema 60
===========

Insiemi di coppie di numeri primi

I numeri primi 3, 7, 109 e 673 sono piuttosto notevoli. Prendendo due numeri primi e concatenandoli in qualsiasi ordine, il risultato sarà sempre un numero primo. Ad esempio, prendendo 7 e 109, sia 7109 che 1097 sono primi. La somma di questi quattro numeri primi, 792, rappresenta la somma più bassa per un insieme di quattro numeri primi con questa proprietà.

Trova la somma più bassa per un set di cinque numeri primi per i quali qualunque coppia di numeri primi si concatenano per produrre un altro numero primo.
============================================================================

L'algoritmo di soluzione è del tipo brute-force:

Generare N numeri primi.
Il primo numero della lista dei numeri primi è "a", il secondo numero della lista è "b" (b > a).
Controllare se "ab" e "ba" sono numeri primi,
se sono numeri primi, allora prendere il terzo numero dalla lista "c" (c > b).
   controllare se "ac", "ca", "bc", "ca" sono tutti numeri primi,
   se sono numeri primi, allora prendere un quarto numero dalla lista "d" (d > c).
      controllare se "ad", "da", "bd", "db", "cd", "dc" sono tutti numeri primi,
      se sono tutti numeri primi, prendi il quinto numero dalla lista "e" (e > d)
         controllare se "ae", "ea", "be", "eb", "ce", "ec", "de", "ed" sono tutti numeri primi,
         se sono tutti numeri primi, allora stampa a + b + c + d + e.

Adesso resta il problema di definire il numero N, cioè fino a quale numero primo dobbiamo considerare?
Non possiamo fermarci quando abbiamo trovato una soluzione, perchè non sappiamo se ne esistono altre con un valore di somma minore.
Andremo per tentativi... fino a 5000, fino a 6000, fino a 7000 ecc.

Funzione per verificare se un numero n è primo:

(define (prime? n)
   (if (< n 2) nil
       (= 1 (length (factor n)))))

Funzione per generare tutti i numeri primi fino a n:

(define (sieve n)
   (setq arr (array (+ n 1)) lst '(2))
   (for (x 3 n 2)
      (when (not (arr x))
         (push x lst -1)
         (for (y (* x x) n (* 2 x) (> y n))
            (setf (arr y) true)))) lst)

(sieve 50)
;-> (2 3 5 7 11 13 17 19 23 29 31 37 41 43 47)

Funzione che controlla se la combinazione (come stringa) dei numeri ab e ba sono entrambi primi:

(define (check a b)
  (and (prime? (int (string a b))) (prime? (int (string b a)))))

Questa è più veloce.

(define (check a b)
  (local (len-a len-b)
    (setq len-a (+ (int (log a 10)) 1))
    (setq len-b (+ (int (log b 10)) 1))
    ;(setq len-a (length a))
    ;(setq len-b (length b))
    (and (prime? (int (+ (* a (pow 10 len-b)) b)))
         (prime? (int (+ (* b (pow 10 len-a)) a))))
    ;(and (prime? (int (+ (* a (pow 10 (+ (int (log b 10)) 1))) b)))
    ;     (prime? (int (+ (* b (pow 10 (+ (int (log a 10)) 1))) a))))
  )
)

(check 109 673)
;-> true
(check 3 23)
;-> nil

(define (e060 n)
  (local (primi-lst primi)
    ; (setq primi (sieve n))
    ; Il 2 e il 5 non possono essere nella soluzione perchè
    ; un numero con 2 o 5 come ultima cifra non è primo.
    (pop (setq primi (sieve n)) '(0 2))
    ;(setq primi (array (length primi-lst) primi-lst))
    ; a è il primo numero
    (dolist (a primi)
      ; b è il secondo numero
      (dolist (b primi)
        (cond ((>= a b) nil)
              (true
               (if (check a b)
                   ; c è il terzo numero
                   (dolist (c primi)
                     (cond ((>= b c) nil)
                           (true
                            ; check se (a,c) e (b,c) soddisfano la condizione
                            (if (and (check a c) (check b c))
                                ; d è il quarto numero
                                (dolist (d primi)
                                  (cond ((>= c d) nil)
                                         (true
                                          # check se (a,d), (b,d) e (c,d) soddisfano la condizione
                                          (if (and (check a d) (check b d) (check c d))
                                              ; e è il quinto numero
                                              (dolist (e primi)
                                                (cond ((>= d e) nil)
                                                       (true
                                                        ; check se (a,e), (b,e), (c,e) e (d,e) soddisfano la condizione
                                                        (if (and (check a e) (check b e) (check c e) (check d e))
                                                            (println (+ a b c d e) { } a { } b { } c { } d { } e)
                                                        )))))))))))))))))))


(e060 5000)
;-> nil
(e060 6000)
;-> nil
(e060 7000)
;-> nil
(e060 8000)
;-> nil
(e060 9000)
;-> 26033 13 5197 5701 6733 8389

(time (e060 9000))
;-> 26033 13 5197 5701 6733 8389
;-> 56943.359

La funzione impiega circa 57 secondi per trovare la soluzione (siamo sotto al minuto).

Proviamo ad usare un vettore per i numeri primi. In questo modo possiamo evitare di controllare se un numero primo selezionato è superiore al precedente, ma dobbiamo usare l'indicizzazione per trovare il valore di un numero nel vettore.

(define (e060 n)
  (local (primi primi-lst up)
    ; (setq primi (sieve n))
    ; Il 2 e il 5 non possono essere nella soluzione perchè
    ; un numero con 2 o 5 come ultima cifra non è primo.
    (pop (setq primi-lst (sieve n)) '(0 2))
    (setq primi (array (length primi-lst) primi-lst))
    (setq up (- (length primi) 1))
    ; a è il primo numero
    (for (i 0 (- up 1))
      ; b è il secondo numero
      (for (j (+ i 1) (- up 2))
        ; check se (a,b) soddisfano la condizione
        (if (check (primi i) (primi j))
            ; c è il terzo numero
            (for (k (+ j 1) (- up 3))
              ; check se (a,c) e (b,c) soddisfano la condizione
              (if (and (check (primi i) (primi k))
                       (check (primi j) (primi k)))
                  ; d è il quarto numero
                  (for (x (+ k 1) (- up 4))
                    # check se (a,d), (b,d) e (c,d) soddisfano la condizione
                    (if (and (check (primi i) (primi x))
                             (check (primi j) (primi x))
                             (check (primi k) (primi x)))
                        ; e è il quinto numero
                        (for (y (+ x 1) (- up 5))
                          ; check se (a,e), (b,e), (c,e) e (d,e) soddisfano la condizione
                          (if (and (check (primi i) (primi y))
                                   (check (primi j) (primi y))
                                   (check (primi k) (primi y))
                                   (check (primi x) (primi y)))
                              (println (+ (primi i) (primi j) (primi k) (primi x) (primi y)) { }
                                       (primi i) { } (primi j) { } (primi k) { } (primi x) { } (primi y))
                          )))))))))))

(time (e060 9000))
;-> 26033 13 5197 5701 6733 8389
;-> 55055.913

I tempi di calcolo delle due funzioni sono quasi uguali.
----------------------------------------------------------------------------


===========
Problema 61
===========

I numeri triangolari, quadrati, pentagonali, esagonali, ettagonali e ottagonali sono tutti numeri figurati (poligonali) e sono generati dalle seguenti formule:

Triangolo   P3,n = n(n + 1)/2     1, 3,  6, 10, 15, ...
Quadrato    P4,n = n^2            1, 4,  9, 16, 25, ...
Pentagonale P5,n = n(3n − 1)/2    1, 5, 12, 22, 35, ...
Esagonale   P6,n = n(2n − 1)      1, 6, 15, 28, 45, ...
Eptagonale  P7,n = n(5n − 3)/2    1, 7, 18, 34, 55, ...
Ottagonale  P8,n = n(3n − 2)      1, 8, 21, 40, 65, ...

L'insieme ordinato di tre numeri a 4 cifre: 8128, 2882, 8281, ha tre proprietà interessanti.

1) Il set è ciclico, in quanto le ultime due cifre di ogni numero sono le prime due cifre del numero successivo (compreso l'ultimo numero con il primo).
2) Ogni tipo poligonale: triangolo (P3,127 = 8128), quadrato (P4,91 = 8281) e pentagonale (P5,44 = 2882), è rappresentato da un numero diverso nell'insieme.
3) Questo è l'unico set di numeri a 4 cifre con questa proprietà.

Trova la somma dell'unico insieme ordinato di sei numeri ciclici a 4 cifre per i quali ogni tipo poligonale: triangolo, quadrato, pentagonale, esagonale, ettagonale e ottagonale, è rappresentato da un numero diverso nell'insieme.
============================================================================

L'algoritmo è abbastanza semplice, ma tedioso:

Creiamo le liste per ogni numero pentagonale (non possiamo avere un numero con lo 0 nella terza cifra ==> no ciclo).
Creiamo una lista totale con elementi univoci e ordinata.
Costruiamo una catena ciclica (valida) di numeri (percorrendo tutta la lista).
Se la catena contiene numeri da tutte le liste di numeri poligonali, allora abbiamo trovato la soluzione.

(define (do-tri)
  (let ((val 0) out '())
    (for (i 45 141)
      (setq val (/ (* i (+ i 1)) 2))
      (if (!= ((string val) 2) "0") (push val out -1)))
    out))

(define (do-square)
  (let ((val 0) out '())
    (for (i 32 99)
      (setq val (* i i))
      (if (!= ((string val) 2) "0") (push val out -1)))
    out))

(define (do-penta)
  (let ((val 0) out '())
    (for (i 26 81)
      (setq val (/ (* i (- (* 3 i) 1)) 2))
      (if (!= ((string val) 2) "0") (push val out -1)))
    out))

(define (do-hexa)
  (let ((val 0) out '())
    (for (i 23 71)
      (setq val (* i (- (* 2 i) 1)))
      (if (!= ((string val) 2) "0") (push val out -1)))
    out))

(define (do-hepta)
  (let ((val 0) out '())
    (for (i 21 63)
      (setq val (/ (* i (- (* 5 i) 3)) 2))
      (if (!= ((string val) 2) "0") (push val out -1)))
    out))

(define (do-octa)
  (let ((val 0) out '())
    (for (i 19 58)
      (setq val (* i (- (* 3 i) 2)))
      (if (!= ((string val) 2) "0") (push val out -1)))
    out))

(define (e061)
(catch
  (local (numeri chain all tri square penta hexa hepta octa
          ax1 ax2 ax3 ax4 ax5 ax6 bx1 bx2 bx3 bx4 bx5 bx6)
    (setq numeri (list 3 4 5 6 7 8))
    (setq chain '() all '())
    (setq tri (do-tri))
    (setq square (do-square))
    (setq penta (do-penta))
    (setq hexa (do-hexa))
    (setq hepta (do-hepta))
    (setq octa (do-octa))
    (setq all (apply extend (list tri square penta hexa hepta octa)))
    (setq all (sort (unique all)))
    ; costruisce la catena di numeri
    (dolist (x1 all)
      (setq ax1 (/ x1 100))
      (setq bx1 (% x1 100))
      (dolist (x2 all)
        (cond ((!= x1 x2)
               (setq ax2 (/ x2 100))
               (setq bx2 (% x2 100))
               (cond ((> ax2 bx1) nil)
                     ((= bx1 ax2)
                      (dolist (x3 all)
                        (cond ((!= x1 x2 x3)
                               (setq ax3 (/ x3 100))
                               (setq bx3 (% x3 100))
                               (cond ((> ax3 bx2) nil)
                                     ((= bx2 ax3)
                                      (dolist (x4 all)
                                        (cond ((!= x1 x2 x3 x4)
                                               (setq ax4 (/ x4 100))
                                               (setq bx4 (% x4 100))
                                               (cond ((> ax4 bx3) nil)
                                                     ((= bx3 ax4)
                                                      (dolist (x5 all)
                                                        (cond ((!= x1 x2 x3 x4 x5 x)
                                                               (setq ax5 (/ x5 100))
                                                               (setq bx5 (% x5 100))
                                                               (cond ((> ax5 bx4) nil)
                                                                     ((= bx4 ax5)
                                                                      (dolist (x6 all)
                                                                        (cond ((!= x1 x2 x3 x4 x5 x6)
                                                                               (setq ax6 (/ x6 100))
                                                                               (setq bx6 (% x6 100))
                                                                               (cond ((> ax6 bx5) nil)
                                                                                     ((and (= bx5 ax6) (= bx6 ax1))
                                                                                      ; creazione e controllo catena corrente
                                                                                      (setq chain (list x1 x2 x3 x4 x5 x6))
                                                                                      (setq lista '())
                                                                                      (dolist (x chain)
                                                                                        (cond ((find x octa) (push 8 lista))
                                                                                              ((find x hepta) (push 7 lista))
                                                                                              ((find x hexa) (push 6 lista))
                                                                                              ((find x penta) (push 5 lista))
                                                                                              ((find x square) (push 4 lista))
                                                                                              ((find x tri) (push 3 lista))
                                                                                        )
                                                                                        (setq lista (sort (unique lista)))
                                                                                        ; catena trovata
                                                                                        (if (= lista numeri) (throw (apply + chain)))
                                                                                      ))))))))))))))))))))))))))))))

(e061)
;-> 28684

(time (e061))
;-> 85.8
----------------------------------------------------------------------------


===========
Problema 62
===========

Permutazioni cubiche

Il cubo, 41063625 (3453), può essere permutato per produrre altri due cubi: 56623104 (3843) e 66430125 (4053). In effetti, 41063625 è il cubo più piccolo che ha esattamente tre permutazioni delle sue cifre che sono anche cubi.

Trova il cubo più piccolo per il quale esattamente cinque permutazioni delle sue cifre sono cubi.

Concetto di base:
Due liste con gli stessi elementi, ma in ordine diverso, producono le stesse permutazioni.

Esempio:
(setq lst1 '(1 2 3))
(setq lst2 '(2 3 1))

(sort (perm lst1))
;-> ((1 2 3) (1 3 2) (2 1 3) (2 3 1) (3 1 2) (3 2 1))

(sort (perm lst2))
;-> ((1 2 3) (1 3 2) (2 1 3) (2 3 1) (3 1 2) (3 2 1))

I numeri che possono essere permutati per produrre uno o più cubi hanno tutti le stesse cifre. Ordinando in modo decrescente le cifre di questi numeri notiamo che il risultato è lo stesso per i tutti i valori che, elevati al cubo, li generano. Vediamo un esempio:

valore   cubo                  ordinamento/codifica    risultato
3453 --> 3453^3 = 41063625 --> (digit-sort 41063625) = 66543210
3843 --> 3453^3 = 56623104 --> (digit-sort 56623104) = 66543210
4053 --> 4053^3 = 56623104 --> (digit-sort 66430125) = 66543210

In altre parole, i numeri 3453, 3843 e 4053 (che generano tutti un cubo con le stesse cifre) hanno la stessa codifica.  Per risolvere il problema occorre cercare una codifica che si ripete per 5 volte.
Quindi uno pseudo-algoritmo è il seguente:

1. valore = 0
2. codifica il valore.
3. inserisci la codifica in una lista.
4. se la codifica è presente 5 volte nella lista,
   allora il risultato vale (primo indice della codifica)^3. Stop.
   altrimenti aumenta di 1 il valore e vai al passo 3.

La prima codifica che utilizziamo è la seguente:

(setq i 27)
(setq cubo (explode (string (* i i i))))
;-> ("1" "9" "6" "8" "3")
(setq cubo (sort (explode (string (* i i i)))))
;-> ("1" "3" "6" "8" "9")

Quindi la lista contiene elementi del tipo: ("1" "3" "6" "8" "9")

Scriviamo la funzione:

(define (e062)
  (local (cubo lst num found out)
    (setq num 0 found nil)
    (until found
      ; calcoliamo la codifica
      (setq cubo (sort (explode (string (* num num num)))))
      ; inseriamo la codifica nella lista
      (push cubo lst -1)
      ; se la codifica corrente è presente 5 volte nella lista...
      (if (= (count (list cubo) lst) '(5))
          ; allora abbiamo trovato la soluzione
          (setq out (pow (first (ref cubo lst)) 3) found true)
      )
      (++ num)
    )
    out))

(e062)
;-> 127035954683

(time (e062))
;-> 23831.307

Proviamo a semplificare l'elemento della lista utilizzando un'altra codifica:

(setq i 27)
(setq cubo (explode (string (* i i i))))
;-> ("1" "9" "6" "8" "3")
(setq cubo (sort (explode (string (* i i i))) >))
;-> ("9" "8" "6" "3" "1")
(setq num 0)
(dolist (el cubo) (setq num (+ (int el) (* num 10))))
;-> 98631

Quindi la lista contiene elementi del tipo: 98631

Funzione che ordina in modo decrescente (per preservare lo zero) le cifre di un numero:

(define (digit-sort num)
  (let (out 0)
    (dolist (el (sort (explode (string num)) >))
      (setq out (+ (int el) (* out 10))))))

Scriviamo la funzione:

(define (e062)
  (local (cubo lst num found out)
    (setq num 0 found nil)
    (until found
      (setq cubo (digit-sort (* num num num)))
      (push cubo lst -1)
      (if (= (count (list cubo) lst) '(5))
          (setq out (pow (first (ref cubo lst)) 3) found true)
      )
      (++ num)
    )
    out))

(e062)
;-> 127035954683

(time (e062))
;-> 6348.037

Proviamo con un altra funzione "digit-sort" che ordina in modo decrescente (per preservare lo zero) le cifre di un numero:

(define (digit-sort num)
  (local (lst out)
    (setq lst (dup 0 10))
    (setq out 0)
    (while (> num 0)
      (++ (lst (% num 10)))
      (setq num (/ num 10))
    )
    (for (i 9 0 -1)
      (setq out (/ (- (* (pow 10 (lst i)) (+ i (* 9 out))) i) 9))
    )
    out))

(digit-sort 12340)
;-> 43210

(digit-sort 130987345354322)
;-> 987554433332210

Eseguiamo di nuovo la funzione:

(e062)
;-> 127035954683

(time (e062))
;-> 6305.131

I tempi di esecuzione delle due funzioni sono uguali.

Il secondo algoritmo utilizza una hash-map con la seguente struttura:

 chiave                       valore
((digit-sort (* num num num)) (num ripetizioni))

In questo modo la soluzione si trova quando le ripetizioni di una chiave vale 5. Maggiori spiegazioni nei commenti della funzione.

(define (e062-2)
  (local (cubo lst num found out)
    (new Tree 'myHash)
    (setq num 0 found nil)
    (until found
      ; calcola il valore della chiave
      ; es. num=5 -> num*num*num = 125 -> cubo = 521
      (setq cubo (digit-sort (* num num num)))
      ; se la chiave non esiste nella hashmap...
      (if (null? (myHash cubo))
          ; allora inserisce il cubo (chiave) con la lista (num 1) (valore)
          ; nella lista (num 1), 1 rappresenta il numero di ripetizioni del cubo
          ; mentre num rappresenta il numero da elevare a potenza
          (myHash cubo (list num 1))
          ; altrimenti aggiunge 1 al numero di ripetizioni nella lista (valore)
          (begin
            ; occorre ricostruire tutta la lista associata alla valore di cubo (chiave)
            (myHash cubo (list (first $it) (+ (last $it) 1)))
            ; se il numero di ripetizioni vale 5
            (if (= 5 (last (myHash cubo)))
                ; allora abbiamo trovato la soluzione
                (setq out (pow (first (myHash cubo)) 3) found true)
            )
          )
      )
      (++ num)
    )
    ; elimina la hash-map
    (delete 'myHash)
    out))

Vediamo come si comporta questa funzione:

(e062-2)
;-> 127035954683

(time (e062-2))
;-> 83.742

L'utilizzo di una hash-map fornisce la soluzione immediatamente.
----------------------------------------------------------------------------


===========
Problema 63
===========

Conteggio di cifre di potenze

Il numero di 5 cifre, 16807 = 7^5, è anche una quinta potenza. Allo stesso modo, il numero di 9 cifre, 134217728 = 8^9, è una nona potenza.

Quanti numeri interi positivi di n cifre esistono che sono anche un'ennesima potenza?
============================================================================

Cerchiamo un numero n tale che la lunghezza di n elevato a k sia k:  L(n^k) = k

Calcoliamo il limite superiore di n:

k = L(n^k)
k = floor(1 + log10(k^k))
k - 1 <= k*log10(n) < k
log10(n) < 1
n < 10

Quindi il valore massimo per n è 9.

Calcoliamo il limite superiore di k:

L(n^k) > k
floor(1 + k*log10(n^k)) > k
1 + k*log10(n) > k
log10(n) > (k - 1)/k = 1 - 1/k
1/k > 1 - log10(n)
k > 1/(1 - log10(n))

Con n=9 il valore massimo per k è 21:

(div (sub 1 (log 9 10)))
;-> 21.85434532678283

(define (e063)
  (let (c  0)
    (for (n 1 9)
      (for (k 1 21)
        (if (= (floor (add 1 (mul k (log n 10)))) k)
          (++ c)
        )
      )
    )
    c))

(e063)
;-> 49

(time (e063))
;-> 0

Dal punto di vista matematico possiamo notare che dalla definizione della lunghezza di  un numero L risulta:

10^(k-1) <= n^k < 10^k

Poichè n < 10, risulta che 10^(k-1) cresce più velocemente di n^k e ad un certo punto lo sorpasserà. Quindi troviamo il punto in cui queste quantità sono uguali:

10^(k-1) = n^k
(1/10)*10^k = n^k
k*log(10) - log(10) = k*log(n)
k = log(10)/(log(10 - log(n)))

Questa volta k rappresenta il numero di volte in cui le quantità considerate sono uguali (prendiamo floor(k)). La funzione è la seguente:

(define (e063-2)
  (let (res 0)
    (for (i 1 9)
      (setq res (add res (floor (div (log 10) (log (div 10 i))))))
    )
    res))

(e063-2)
;-> 49

(time (e063-2))
;-> 0

Questa seconda soluzione è molto più veloce:

(time (e063) 10000)
;-> 392.976

(time (e063-2) 10000)
;-> 20.965
----------------------------------------------------------------------------


===========
Problema 64
===========

Ogni radice quadrata può essere rappresentata con una frazione continua.

La frazione continua di sqrt(23) vale [4, (1,3,1,8)].
La notazione indica che la frazione continua inizia con 4 e il blocco (1,3,1,8) si ripete indefinitamente.

Le prime dieci rappresentazioni di frazione continua di radici quadrate (irrazionali) sono:

sqrt( 2) = (1, (2)],         periodo = 1
sqrt( 3) = (1, (1,2)],       periodo = 2
sqrt( 4) = (2, (4)],         periodo = 1
sqrt( 6) = (2, (2,4)],       periodo = 2
sqrt( 7) = (2, (1,1,1,1)],   periodo = 4
sqrt( 8) = (2, (1,4)],       periodo = 2
sqrt(10) = (3, (6)],         periodo = 1
sqrt(11) = (3, (3,6)],       periodo = 2
sqrt(12) = (3, (2,6)],       periodo = 2
sqrt(13) = (3, (1,1,1,1,6)], periodo = 5

Esattamente quattro frazioni continue hanno un periodo dispari.

Quante frazioni continue per N <= 10000 hanno un periodo dispari?
============================================================================

L'algoritmo presentato dall'articolo "Methods of computing square roots" di wikipedia è il seguente:

Start:
 m[0] = 0
 d[0] = 1
 a[0] = floor(sqrt(n))
 k = a[0]
Loop:
 m[i] = a[i-1]*d[i-1] - m[i-1]
 d[i] = (n-m[i]*m[i])/d[i-1]
 a[i] = floor((k + m[i])/d[i])
Stop: quando la i-esima tripla è stata generata precedentemente.

Note: m[i],d[i],a[i] sono sempre interi.

L'articolo di Alexandra Ioana Gliga "On continued fractions of the square root of prime numbers" dimostra che per ogni numero intero positivo che non è un quadrato perfetto risulta:

  sqrt(n) = [a1, (a2 a3 ... an 2*a1)]

Questo ci permette di fermare il ciclo quando l'i-esimo valore vale 2*a1.

Scriviamo la funzione:

(define (e064)
  (local (max-val out limite)
    (setq max-val 10000)
    (setq out 0)
    (for (n 2 max-val)
      (setq limite (int (sqrt n)))
      ; l'algortimo non funziona quando abbiamo un quadrato perfetto
      ; quindi saltiamo questi casi che non influenzano il risultato finale
      (if (!= (* limite limite ) n)
          (let ((periodo 0) (d 1) (m 0) (a limite))
            (do-while (!= a (* 2 limite))
              (setq m (- (* d a) m))
              (setq d (/ (- n (* m m)) d))
              (setq a (/ (+ limite m) d))
              (++ periodo)
            )
            (if (odd? periodo) (++ out))
          )
      )
    )
    out))

(e064)
;-> 1322

(time (e064))
;-> 81.294
----------------------------------------------------------------------------


===========
Problema 65
===========

Convergenti di e

La radice quadrata di 2 può essere scritta come una frazione continua infinita.
                       1
sqrt(2) = 1 + --------------------
                         1
              2 + ----------------
                           1
                  2 + ------------
                             1
                      2 + --------
                          2 + ...

La frazione continua infinita può essere scritta come sqrt(2) = [1, (2)] indica che 2 si ripete all'infinito. In un modo simile, sqrt(23) = [4, (1,3,1,8)].

Risulta che la sequenza dei valori parziali delle frazioni continue per le radici quadrate fornisce le migliori approssimazioni razionali. Consideriamo i convergenti per sqrt(2):

1 + 1/2 = 3/2
1 + 1/(2 + 1/2) = 7/5
1 + 1/(2 + 1/(2 + 1/2)) = 17/12
1 + 1/(2 + 1/(2 + 1/(2 + 1/2))) = 41/29

Quindi la sequenza dei primi dieci convergenti per sqrt(2) sono:

1, 3/2, 7/5, 17/12, 41/29, 99/70 239/169, 577/408, 1393/985, 3363/2378, ...

La cosa più sorprendente è che per l'importante costante matematica "e" risulta:

e = [2,1,2,1,1,4,1,1,6,1...1,2k,1...]

I primi dieci termini nella sequenza di convergenti per e sono:

2, 3, 8/3, 11/4, 19/7, 87/32, 106/39, 193/71, 1264/465, 1457/536, ...

La somma delle cifre al numeratore del decimo convergente è 1 + 4 + 5 + 7 = 17.

Trova la somma delle cifre del numeratore del centesimo convergente della frazione continua per "e".
============================================================================

Calcoliamo i primi n termini della frazione continua del numero tenendo conto che il pattern ...1,2n,1... si ripete all'infinito: cf(e) = [2, 1,2,1, 1,4,1, 1,6,1, 1,8,1, 1,10,1, ...]

(define (cf_e n)
  (let (cfe '(2))
    (for (i 1 (- n 1))
      (extend cfe (list 1 (* 2 i) 1)))
    (slice cfe 0 n)))

(cf_e 20)
;-> (2 1 2 1 1 4 1 1 6 1 1 8 1 1 10 1 1 12 1 1)

Poi scriviamo una funzione che calcola i convergenti partendo da una frazione continua e restituisce l'ultima delle frazioni convergenti Pn/Qn (dobbiamo usare i big-integer perchè il numeratore e il denominatore delle frazioni convergenti crescono velocemente):

(define (cf2conv cf)
  (local (p0 q0 p1 q1 p2 q2)
    (cond ((= (length cf) 1) (setq p2 (first cf) q2 1))
          (true
           (setq p0 1L q0 0L)
           (setq p1 (bigint (cf 0)) q1 1L)
           (for (k 1 (- (length cf) 1))
             (setq p2 (+ (* p1 (cf k)) p0))
             (setq q2 (+ (* q1 (cf k)) q0))
             ; k-esima frazione convergente
             ;(println (list p2 q2 (div p2 q2)))
             (setq p0 p1 q0 q1 p1 p2 q1 q2)
           ))
    )
    (list p2 q2)))

(cf2conv (cf_e 20))
;-> (28245729L 10391023L)

Poi ci serve una funzione che converte un numero in una lista:

(define (int2lst num)
  (let (out '())
    (while (!= num 0)
      (push (% num 10) out)
      (setq num (/ num 10))) out))

Adesso possiamo scrivere la funzione finale:

(define (e065)
  (local (numer)
    (setq numer (first (cf2conv (cf_e 100))))
    (apply + (int2lst numer))))

(e065)
;-> 272L

(time (e065))
;-> 0
----------------------------------------------------------------------------


===========
Problema 66
===========

# Equazione di Pell
# x^2 - D*y^2 = 1
#
# Espandere sqrt(D) in frazione continua
# sqrt(D) = [q0,q1,q2,...,qn,2*q0]
# Periodo della frazione continua = n
# Calcolare l'n-esimo convergente della frazione continua (Pn/Qn).
# Se n è dispari allora Pn e Qn sono la soluzione.
# Se n è pari occorre:
#    Espandere sqrt(D) in frazione continua fino al termine (2n+1)
#    Calcolare i convergenti fino al termine (2n+1).
#    P(2*n+1) e Q(2*n+1) sono le soluzioni.

(define (Pell n)
  (local (z r x y e1 e2 f1 f2 A B t1 t2)
    (setq x (bigint (int (sqrt n))))
    (setq y x)
    (setq z 1L)
    (setq r (* x 2))
    (setq e1 1L e2 0L)
    (setq f1 0L f2 1L)
    (catch
      (while true
        (setq y (bigint (- (* r z) y)))
        (setq z (bigint (/ (- n (* y y)) z)))
        (setq r (bigint (/ (+ x y) z)))
        (setq t1 e1) (setq t2 e2)
        (setq e1 t2)
        (setq e2 (bigint (+ (* t2 r) t1)))
        (setq t1 f1) (setq t2 f2)
        (setq f1 t2)
        (setq f2 (bigint (+ (* t2 r) t1)))
        (setq A f2)
        (setq B e2)
        (setq t1 A) (setq t2 B)
        (setq B t1)
        (setq A (bigint (+ (* t1 x) t2)))
        (if (= (- (* A A) (* B B n)) 1) (throw (list A B)))
        ;(println (format "z = %s\nr = %s\nx = %s\ny = %s" (string z) (string r) (string x) (string y)))
        ;(println (format "e1 = %s\ne2 = %s\nf1 = %s\nf2 = %s" (string e1) (string e2) (string f1) (string f2)))
        ;(println (format "A = %s\nB = %s" (string A) (string B)))
        ;(read-line)
      );while
    );catch
  );local
)

(Pell 61)
;-> (1766319049L 226153980L)

(Pell 109)
;-> (158070671986249L 15140424455100L)

(Pell 181)
;-> (2469645423824185801L 183567298683461940L)

(Pell 277)
;-> (159150073798980475849L 9562401173878027020L)

Se passiamo un numero quadrato, otteniamo un errore:

(Pell 4)
;-> ERR: division by zero
;-> called from user function (Pell 4)

Scriviamo la funzione finale per risolvere il problema:

(define (e066)
  (let ((maxval -1) (out 0))
    (for (i 1 1000)
      (if (!= (sqrt i) (int (sqrt i)))
          (if (> (first (Pell i)) maxval)
              (setq maxval (first (Pell i)) out i))))
    out))

(e066)
;-> 661

(time e066)
;-> 0
----------------------------------------------------------------------------


===========
Problema 67
===========

Percorso con somma massima II

Iniziando dalla parte superiore del triangolo in basso e passando ai numeri adiacenti sulla riga sottostante, il totale massimo dall'alto verso il basso è 23.

   3
  7 4
 2 4 6
8 5 9 3

Cioè, 3 + 7 + 4 + 9 = 23.

Trovare il totale massimo dall'alto verso il basso utilizzando "triangle.txt", un file di testo di 15K contenente un triangolo con cento righe.

NOTA: questa è una versione molto più difficile del problema 18. Non è possibile provare tutti i percorsi per risolvere questo problema, poiché ce ne sono 2^99 in tutto! Potendo controllare un trilione (10^12) di percorsi ogni secondo, ci vorrebbero oltre venti miliardi di anni per controllarli tutti. C'è un algoritmo efficiente per risolverlo.
============================================================================

Il file "triangle.txt" è stato trasformato in "e067.lsp" che ha il seguente formato:

(setq tri (dup 0 100))
(setf (tri 0) '(59))
(setf (tri 1) '(73 41))
(setf (tri 2) '(52 40 9))
(setf (tri 3) '(26 53 6 34))
...

Per caricare il file:

(load "e067.lsp")

Una soluzione generica può essere ottenuta con la programmazione dinamica. In pratica per trovare la soluzione, ogni riga deve essere aggiunta a qualsiasi riga successiva, dal basso verso l'alto. Poiché ogni cella ha due predecessori, prendiamo il valore massimo delle due. Con questo metodo, la soluzione si trova nella cella superiore del triangolo:

(load "e067.lsp")

(define (e067)
    (for (i (- (length tri) 2) 0 -1)
      (for (j 0 i)
        (setf (tri i j) (+ (tri i j) (max (tri (+ i 1) j) (tri (+ i 1) (+ j 1)))))
      )
    )
    (tri 0 0))

(e067)
;-> 7273

(time (e067))
;-> 1.995
----------------------------------------------------------------------------


===========
Problema 68
===========

Considera il seguente anello "magico" 3-gon, riempito con i numeri da 1 a 6 e ogni riga somma a nove.

       4
        \
         3
        / \
       1---2---6
      /
     5

Lavorando in senso orario, e partendo dal gruppo di tre con il nodo esterno numericamente più basso (4,3,2 in questo esempio), ogni soluzione può essere descritta in modo univoco. Ad esempio, la soluzione di cui sopra può essere descritta dall'insieme: 4,3,2 - 6,2,1 - 5,1,3.

È possibile completare l'anello con quattro diversi totali: 9, 10, 11 e 12. Ci sono otto soluzioni in totale.

Totale   Soluzioni
   9     4,2,3 - 5,3,1 - 6,1,2
   9     4,3,2 - 6,2,1 - 5,1,3
  10     2,3,5 - 4,5,1 - 6,1,3
  10     2,5,3 - 6,3,1 - 4,1,5
  11     1,4,6 - 3,6,2 - 5,2,4
  11     1,6,4 - 5,4,2 - 3,2,6
  12     1,5,6 - 2,6,4 - 3,4,5
  12     1,6,5 - 3,5,4 - 2,4,6

Concatenando ogni gruppo è possibile formare stringhe di 9 cifre: la stringa massima per un anello 3-gon è 432621513.

Utilizzando i numeri da 1 a 10, a seconda degli arrangiamenti, è possibile formare stringhe di 16 e 17 cifre. Qual è il numero massimo di 16 cifre per un anello "magico" 5-gon?
============================================================================

Funzione che calcola le permutazioni:

(define (perm lst)
  (local (i indici out)
    (setq indici (dup 0 (length lst)))
    (setq i 0)
    ; aggiungiamo la lista iniziale alla soluzione
    (setq out (list lst))
    (while (< i (length lst))
      (if (< (indici i) i)
          (begin
            (if (zero? (% i 2))
              (swap (lst 0) (lst i))
              (swap (lst (indici i)) (lst i))
            )
            ;(println lst);
            (push lst out -1)
            (++ (indici i))
            (setq i 0)
          )
          (begin
            (setf (indici i) 0)
            (++ i)
          )
       )
    )
    out))

(define (gon lst)
  (local (is-gon gonL pL6 pL7 pL8 pL9 pL10 p6 p7 p8 p9 p10)
    (setq is-gon nil)
    (setq gonL '() pL6 '() pL7 '() pL8 '() pL9 '() pL10 '())
    (setq p6  (+ (lst 6)  (lst 1) (lst 2)))
    (setq p7  (+ (lst 7)  (lst 2) (lst 3)))
    (setq p8  (+ (lst 8)  (lst 3) (lst 4)))
    (setq p9  (+ (lst 9)  (lst 4) (lst 5)))
    (setq p10 (+ (lst 10) (lst 5) (lst 1)))
    ; Controllo se le somme sono uguali
    (cond ((and (= p6 p7) (= p7 p8) (= p8 p10) (= p9 p10))
           (setq is-gon true)
           ; Cerco l'indice del valore minimo esterno
           ; cioè cerco il numero 6, perchè all'esterno ci devono
           ; stare i numeri 6,7,8,9,10.
           (setq indice (find 6 lst))
           ; Costruisco la lista soluzione
           (setq pL6  (list (lst 6)  (lst 1) (lst 2)))
           (setq pL7  (list (lst 7)  (lst 2) (lst 3)))
           (setq pL8  (list (lst 8)  (lst 3) (lst 4)))
           (setq pL9  (list (lst 9)  (lst 4) (lst 5)))
           (setq pL10 (list (lst 10) (lst 5) (lst 1)))
           (cond ((= indice 6)  (setq gonL (apply extend (list pL6  pL7  pL8  pL9  pL10))))
                 ((= indice 7)  (setq gonL (apply extend (list pL7  pL8  pL9  pL10 pL6))))
                 ((= indice 8)  (setq gonL (apply extend (list pL8  pL9  pL10 pL6  pL7))))
                 ((= indice 9)  (setq gonL (apply extend (list pL9  pL10 pL6  pL7  pL8))))
                 ((= indice 10) (setq gonL (apply extend (list pL10 pL6  pL7  pL8  pL9))))
           ))
    )
    (if is-gon
        (list gonL p6)
        (list '() 0))))

(define (e068)
  (local (vmax pa pb val go x y)
    (setq vmax 0)
    (setq pa (perm '(1 2 3 4 5)))
    (setq pb (perm '(6 7 8 9 10)))
    (dolist (a pa)
      (setq val '())
      (dolist (b pb)
        (setq val (apply extend (list '(0) a b)))
        (setq go (gon val))
        (setq x (first go))
        (setq y (last go))
        (if (!= y 0)
          (begin
           ;(println x { } y)
           (if (> (int (join (map string x))) vmax)
               (setq vmax (int (join (map string x))))
           ))
        )
      )
    )
    vmax))

(e068)
;-> 6531031914842725

(time (e068))
;-> 21.97
----------------------------------------------------------------------------


===========
Problema 69
===========

La funzione toziente di Eulero, φ(n) (a volte chiamata funzione phi), è usata per determinare il numero di numeri positivi minori o uguali a n che sono primi relativamente a n. Ad esempio, poiché 1, 2, 4, 5, 7 e 8 sono tutti inferiori a nove e primi relativamente a nove, φ(9) = 6.
Il numero 1 è considerato relativamente primo rispetto a ogni numero positivo, quindi φ(1)= 1.

 n | Relatively Prime | φ(n) | n/φ(n)    |
 -----------------------------------------
 2 | 1                | 1    | 2         |
 3 | 1,2              | 2    | 1.5       |
 4 | 1,3              | 2    | 2         |
 5 | 1,2,3,4          | 4    | 1.25      |
 6 | 1,5              | 2    | 3         |
 7 | 1,2,3,4,5,6      | 6    | 1.1666... |
 8 | 1,3,5,7          | 4    | 2         |
 9 | 1,2,4,5,7,8      | 6    | 1.5       |
10 | 1,3,7,9          | 4    | 2.5       |

Si può vedere che n = 6 produce un massimo n/φ(n) per n ≤ 10.

Trova il valore di n ≤ 1000000 per cui il rapporto n/φ(n) è massimo.
============================================================================

Utilizziamo un approccio con la forza bruta.

Funzione che calcola il toziente da 0 fino a n numeri:

(define (totients-to num)
  (let (phi (array (+ num 1) '(0)))
    (setf (phi 0) 0)
    (setf (phi 1) 1)
    (for (i 2 num)
      (setf (phi i) i))
    (for (i 2 num)
      (if (= (phi i) i)
          (for (j i num i)
            (setf (phi j) (- (phi j) (/ (phi j) i))))))
     phi))

(totients-to 10)
;-> (0 1 1 2 2 4 2 6 4 6 4)

Scriviamo la funzione finale:

(define (e069)
  (local (t idx cur-val max-val)
    (setq t (totients-to 1000000))
    (setq max-val -1)
    (setq idx-val nil)
    ; cerca il valore massimo
    (for (i 0 1000000)
      (setq cur-val (t i))
      (if (> (div i cur-val) max-val)
          (setq idx-val i max-val (div i cur-val))
      )
    )
    idx-val))

(e069)
;-> 510510

(time (e069))
;-> 642.279
----------------------------------------------------------------------------


===========
Problema 70
===========

Pemutazione toziente

La funzione toziente di Eulero, φ(n) (a volte chiamata funzione phi), è usata per determinare il numero di numeri positivi minori o uguali a n che sono primi relativamente a n. Ad esempio, poiché 1, 2, 4, 5, 7 e 8 sono tutti inferiori a nove e primi relativamente a nove, φ(9) = 6.
Il numero 1 è considerato relativamente primo rispetto a ogni numero positivo, quindi φ(1)= 1.

È interessante notare che φ(87109) = 79180, e si può vedere che 87109 è una permutazione di 79180.

Trova il valore di n, 1 < n < 10^7, per cui φ(n) è una permutazione di ne il rapporto n/φ(n) produce un minimo.
============================================================================

Utilizziamo un approccio con la forza bruta.

Funzione che verifica se due numeri hanno le stesse cifre:

(define (perm? n1 n2)
  (if (!= (length n1) (length n2))
      nil
      (let (ar (array 10 '(0)))
        (while (!= n1 0)
            (++ (ar (% n1 10)))
            (setq n1 (/ n1 10))
        )
        ;(println ar)
        (while (!= n2 0)
            (-- (ar (% n2 10)))
            (setq n2 (/ n2 10))
        )
        ;(println ar)
        (= (count '(0) (array-list ar)) '(10)))))

(perm? 123123 112233)
;-> true

Funzione che calcola il toziente da 0 fino a n numeri:

(define (totients-to num)
  (let (phi (array (+ num 1) '(0)))
    (setf (phi 0) 0)
    (setf (phi 1) 1)
    (for (i 2 num)
      (setf (phi i) i))
    (for (i 2 num)
      (if (= (phi i) i)
          (for (j i num i)
            (setf (phi j) (- (phi j) (/ (phi j) i))))))
     phi))

(totients-to 10)
;-> (0 1 1 2 2 4 2 6 4 6 4)

Scriviamo la funzione finale:

(define (e070)
  (local (t idx cur-val min-val)
    (setq t (totients-to 9999999))
    (setq min-val 999999)
    (setq idx-val nil)
    ; cerca il valore minimo
    (for (i 2 9999999)
      (setq cur-val (t i))
      (if (< (div i cur-val) min-val)
          (if (perm? cur-val i)
                  (setq idx-val i min-val (div i cur-val))
              )
          )
    )
    idx-val))

(e070)
;-> 8319823

(time (e070))
;-> 9621.575

Dal punto di vistta matematico possimo notare che:

1) Rendere minimo n/φ(n) equivale a massimizzare φ(n)/n, che si verifica quando n ha il minor numero di fattori primi possibile.
2) φ(n) = n - 1 dove n è primo, poiché tutti i numeri sotto sono coprimi per definizione
3) φ(n) = φ(p*q) = (p - 1) (q - 1) dove n è semiprimo e p e q sono i suoi fattori e p <> q.
4) φ(n) = φ(p2) = (p - 1) p dove n è semiprime ep è il suo unico fattore distinto.
5) n - 1 non può essere una permutazione di n, quindi il nostro n non può essere un primo, ma è probabilmente il prodotto di due numeri primi (semiprimi).

Funzone che calcola tutti i numeri primi da 1 fino a un dato numero:

(define (primes-to num)
  (cond ((= num 1) '())
        ((= num 2) '(2))
        (true
         (let (lst '(2))
          (setq arr (array (+ num 1)))
          (for (x 3 num 2)
                (when (not (arr x))
                  (push x lst -1)
                  (for (y (* x x) num (* 2 x) (> y num))
                      (setf (arr y) true)))) lst))))

Le considerazioni precedenti portano (dopo molti tentativi) alla seguente funzione:

(define (e070)
(catch
  (local (num primi min-q min-n q n totient)
  (setq num 10000000)
  (setq primi (primes-to (int (mul 1.25 (sqrt num)))))
  (setq primi (slice primi (int (mul 0.5 (length primi)))))
  (setq min-q 2 min-n 0 i 0)
  (dolist (p1 primi)
    (dolist (p2 (slice primi i))
      (cond ((!= (% (+ p1 p2) 9) 1) nil)
            (true
             (setq n (* p1 p2))
             (if (> n num) (throw min-n)) ; soluzione trovata
             (setq totient (* (- p1 1) (- p2 1)))
             (setq q (div n totient))
             (if (and (> min-q q) (perm? totient n))
                 (setq min-q q min-n n))))))
  'not-found)))

(e070)
;-> 8319823

(time (e070))
;-> 7.012
----------------------------------------------------------------------------


===========
Problema 71
===========

Frazioni ordinate

Considera la frazione, n/d, dove n e d sono numeri interi positivi. Se n < d e HCF(n,d) = 1, si parla di frazione propria ridotta.

Se elenchiamo l'insieme delle frazioni proprie ridotte per d ≤ 8 in ordine crescente di dimensione, otteniamo:

1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8

Si può vedere che 2/5 è la frazione immediatamente a sinistra di 3/7.

Elencando l'insieme delle frazioni proprie ridotte per d ≤ 1.000.000 in ordine crescente di dimensione, trova il numeratore della frazione immediatamente a sinistra di 3/7.
============================================================================

Nota: HCF = High Common Factor (fattore comune maggiore)

(define (find-upper n base)
  (let ((a 1) (cont true))
    (while (and (< a n) cont)
      (if (> (div a n) base)
          (setq cont nil)
          (++ a)))
    a))

(find-upper 8 (div 3 7))
;-> 4
(find-upper 1000000 (div 3 7))
;-> 428572

(define (e071)
  (local (n num den minimo base limite a b)
    (setq n 1000000)
    (++ n)
    (setq num 1 den 1)
    (setq minimo 0)
    (setq base (div 3 7))
    (setq limite (find-upper n base))
    (setq a (- limite 2))
    (while (< a limite)
      (setq b (+ a 1))
      (while (< b n)
        (setq v (div a b))
        (if (and (< v base) ( > v minimo))
            (setq num a den b minimo (div num den))
        )
        (++ b)
      )
      (++ a)
    )
    ;(list num den (div num den))
    num))

(e071 1000000)
;-> 428570

(time (e071))
;-> 191.169
----------------------------------------------------------------------------


===========
Problema 72
===========

Conteggio delle frazioni

Considera la frazione, n/d, dove n e d sono numeri interi positivi. Se n <de HCF (n, d) = 1, si parla di frazione propria ridotta.

Se elenchiamo l'insieme delle frazioni proprie ridotte per d ≤ 8 in ordine crescente di dimensione, otteniamo:

1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8

Si può vedere che ci sono 21 elementi in questo set.

Quanti elementi sarebbero contenuti nell'insieme delle frazioni proprie ridotte per d ≤ 1.000.000?
============================================================================

Ordinando le frazioni in una matrice si ottiene il seguente risultato (n=10):

  1/2   1/3   1/4   1/5   1/6   1/7   1/8   1/9  1/10
    0   2/3   1/2   2/5   1/3   2/7   1/4   2/9   1/5
    0     0   3/4   3/5   1/2   3/7   3/8   1/3  3/10
    0     0     0   4/5   2/3   4/7   1/2   4/9   2/5
    0     0     0     0   5/6   5/7   5/8   5/9   1/2
    0     0     0     0     0   6/7   3/4   2/3   3/5
    0     0     0     0     0     0   7/8   7/9  7/10
    0     0     0     0     0     0     0   8/9   4/5
    0     0     0     0     0     0     0     0  9/10
    0     0     0     0     0     0     0     0     0

(1/2, 1/3, 1/4, 1/5, 1/6, 1/7, 1/8, 1/9, 1/10, 2/3, 2/5, 2/7, 2/9,
3/4, 3/5, 3/7, 3/8, 3/10, 4/5, 4/7, 4/9, 5/6, 5/7, 5/8, 5/9, 6/7,
7/8, 7/9, 7/10, 8/9, 9/10)

Notiamo che:
a) le colonne con denominatore numero primo hanno (denominatore - 1) termini.
b) le colonne con denominatore non primo hanno toziente(denominatore) termini.
(dove toziente(n) è il numero di interi minori di n che sono primi rispetto a n)

Funzione che verifica se un numero è primo:

(define (prime? num)
   (if (< num 2) nil
       (= 1 (length (factor num)))))

Funzione che calcola il toziente di un numero:

(define (toziente num)
  (if (= num 1) 1
    (let (res num)
      (dolist (f (unique (factor num)))
        (setq res (- res (/ res f))))
      res)))

Scriviamo la funzione finale:

(define (e072)
  (let ((num 1000000) (somma 0))
    (for (i 2 num)
      (if (prime? i)
          (setq somma (+ somma (- i 1)))
          (setq somma (+ somma (toziente i)))
      )
    )
    somma))

(e072)
;-> 303963552391

(time (e072))
;-> 2060.973
----------------------------------------------------------------------------


===========
Problema 73
===========

Conteggio delle frazioni in un intervallo

Considera la frazione, n/d, dove n e d sono numeri interi positivi. Se n < d e HCF(n,d) = 1, si parla di frazione propria ridotta.

Se elenchiamo l'insieme delle frazioni proprie ridotte per d ≤ 8 in ordine crescente di dimensione, otteniamo:

1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8

Si può vedere che ci sono tre frazioni tra 1/3 e 1/2

Quante frazioni si trovano tra 1/3 e 1/2 nell'insieme ordinato di frazioni proprie ridotte per d ≤ 12.000?.
============================================================================

Nota: HCF = High Common Factor (fattore comune maggiore)

Soluzione brute-force:

(define (find-upper n x)
(catch
  (let (a 1)
    (while (< a n)
      (if (> (div a n) x) (throw a))
      (++ a))
    a)))

(define (e073 n)
(catch
  (local (nmin nmax limite a b v continua out)
    (++ n)
    (setq out '())
    (setq nmin (div 1 3))
    (setq nmax (div 1 2))
    (setq limite (find-upper n 0.5))
    (setq a 1)
    (while (< a limite)
      (setq b (+ a 1))
      (setq continua true)
      (while (and (< b n) continua)
        (setq v (div a b))
        ;(println a { } b { } v)
        (cond ((and (< v nmax) (> v nmin))
               (push v out -1)
               (++ somma))
              ; da qui fino al prossimo valore di 'a' tutte le frazioni sono minori...
              ((< v nmin)
               (setq continua nil))
              ; da qui in poi tutte le frazioni sono maggiori...
              ((and (> v nmax) (= b (- n 1)))
               (throw (length (unique out))))
        )
        (if continua (++ b))
      )
      (++ a)
    )
    (length (unique out)))))

(e073 12000)
;-> 7295372

(time (e073 12000))
;-> 16306.157

Invece di trovare il limite superiore, possiamo iterare su tutti i possibili denominatori e verificare che i numeratori soddisfino le condizioni.

La funzione diventa la seguente:

(define (e073)
  (local (a b num den limite somma)
    (setq a 3 b 2)
    (setq somma 0 limite 12000)
    (for (den 5 limite)
      (setq num (int (+ (div den a) 1)))
      (for (n num (int (div (- den 1) b)))
        (if (= (gcd n den) 1) (++ somma))
      )
    )
    somma))

(e073)
;-> 7295372

(time (e073))
;-> 1809.163

Dal punto di vista matematico possiamo utilizzare la sequenza di Farey.
Nel libro "Il libro dei numeri" di Conway e Guy viene spiegato come calcolare la sequenza successiva  di Farey a partire da uno degli n termini:
inserire la frazione mediante (a + b)/(c + d) tra i termini a/c e b/d quando c + d <= n. Dato 0 <= a/b < c/d <= 1 con b*c-a*d = 1, sia h/k la mediante di a/b e c/d. Allora a/b < h/k < c/d, e queste frazioni soddisfano le relazioni unimodulari

  b*h - a*k = 1

  c*k - d*h = 1

Questo metodo viene implementato nella seguente funzione:

(define (e073)
  (local (ar idx c d mediant somma continua)
    (setq ar (array 12000 '(0)))
    (setq idx 0)
    (setq c 3 d 2)
    (setq somma 0)
    (setq continua true)
    (while continua
      (setq mediant (+ c d))
      (cond ((<= mediant 12000)
             (++ somma)
             (setf (ar idx) d)
             (++ idx)
             (setq d mediant))
            (true
             (if (zero? idx) (setq continua nil))
             (setq c d)
             (-- idx)
             (setq d (ar idx)))
      )
    )
    somma))

(e073)
;-> 7295372

(time (e073))
;-> 2345.727
----------------------------------------------------------------------------


===========
Problema 74
===========

Il numero 145 è ben noto per la proprietà che la somma del fattoriale delle sue cifre è pari a 145:

1! + 4! + 5! = 1 + 24 + 120 = 145

Forse meno noto è 169, in quanto produce la catena di numeri più lunga che ricollega a 169: si scopre che esistono solo tre di tali loop:

169 → 363601 → 1454 → 169
871 → 45361 → 871
872 → 45362 → 872

Non è difficile dimostrare che OGNI numero di partenza alla fine rimarrà bloccato in un ciclo. Per esempio,

69 → 363600 → 1454 → 169 → 363601 (→ 1454)
78 → 45360 → 871 → 45361 (→ 871)
540 → 145 (→ 145)

Iniziare con 69 produce una catena di cinque termini non ripetitivi, ma la catena non ripetitiva più lunga con un numero iniziale inferiore a un milione è sessanta termini.

Quante catene, con un numero iniziale inferiore a un milione, contengono esattamente sessanta termini non ripetitivi?
============================================================================

Scriviamo la funzione che calcola la somma dei fattoriali delle cifre di un numero:

(define (sumfatt num)
       ; precodifica dei fattoriali da 0 a 9
  (let ((fact '(1 1 2 6 24 120 720 5040 40320 362880))
        (temp num) (out 0))
    (while (> temp 0)
      (setq out (+ out (fact (% temp 10))))
      (setq temp (/ temp 10))
    )
    out))

(sumfatt 145)
;-> 145
(sumfatt 169)
;-> 363601
(sumfatt 363601)
;-> 1454

Utilizziamo la forza bruta: costruiamo la catena per ogni numero (in una lista) e controlliamo se è lunga 60, in tal caso aumentiamo di 1 il conteggio.

(define (e074)
  (local (limite num chain out)
    (setq out 0 limite 1000000)
    (for (i 1 limite)
      (setq num i)
      (setq chain '())
      (until (find num chain)
        (push num chain -1)
        (setq num (sumfatt num))
      )
      (if (= (length chain) 60) (++ out))
    )
    out))

(e074)
;-> 402

(time (e074))
;-> 32332.048

Proviamo ad utilizzare una hash-map al posto della lista:

(define (e074)
  ;(local (limite num chain out)
  (local (limite num out)
    (setq out 0 limite 1000000)
    (for (i 1 limite)
      (setq num i)
      ;(setq chain '())
      (new Tree 'chain)
      ;(until (find num chain)
      (until (chain num)
        ;(push num chain -1)
        (chain num num)
        (setq num (sumfatt num))
      )
      ;(if (= (length chain) 60) (++ out))
      (if (= (length (chain)) 60) (++ out))
      ; l'eliminaziona di una hash-map è lenta
      (delete 'chain)
      ; per vedere come sono distribuite le catene da 1 a 1000000
      ;(if (zero? (% i 50000)) (println i { } out))
    )
    out))

(e074)
;-> 402

(time (e074))
;-> 76084.168

Credo che il peggioramento del tempo di esecuzione sia dovuto all'operazione di eliminazione della hash-map "delete" che è lenta. Proviamo allora ad utilizzare ogni volta una hash-map diversa utilizzando la funzione "gensym":

(define (gensym)
  (sym (string "g-" (uuid)))) ; 'g-*** è un simbolo legale

(define (e074)
  ;(local (limite num chain out)
  (local (limite num out)
    (setq out 0 limite 1000000)
    (for (i 1 limite)
      (setq num i)
      ;(setq chain '())
      ;(new Tree 'chain)
      (setq chain (new Tree (gensym) true))
      ;(until (find num chain)
      (until (chain num)
        ;(push num chain -1)
        (chain num num)
        (setq num (sumfatt num))
      )
      ;(if (= (length chain) 60) (++ out))
      (if (= (length (chain)) 60) (++ out))
      ;(delete 'chain)
      ; per vedere come sono distribuite le catene da 1 a 1000000
      ;(if (zero? (% i 50000)) (println i { } out))
    )
    out))

(e074)
;-> 402

(time (print (e074)))
;-> 51001.943

Il tempo di esecuzione è migliore della precedente funzione, ma utilizzare una lista è più veloce in questo caso.

Proviamo con un altro algoritmo.
Consideriamo i numeri di una catena: hanno tutti la stessa lunghezza della catena a cui appartengono.
Se nella costruzione della catena di un numero raggiungiamo il numero 169 o 871 o 872 sappiamo come termina la catena stessa.
Utilizzando anche gli altri numeri 363601, 1454, 45361 e 45362 possiamo modificare il criterio di arresto del calcolo diretto della catena: ci fermiamo quando incontriamo uno di questi sette numeri oppure quando un numero termina la catena su se stesso.

Scriviamo funzione finale:

(define (e074)
  (local (limite num ultimo somma out)
    (setq stop '(169 871 872 1454 45361 45362 363601))
    (setq out 0 limite 1000000)
    (for (i 1 1000000)
      (setq num i)
      (setq somma 0 ultimo 0)
      (while (and (!= num ultimo) (not (find num stop)))
        (setq ultimo num)
        (setq num (sumfatt num))
        (++ somma)
      )
      (if (and (= somma 57) (or (= num 169) (= num 1454) (= num 363601)))
          (++ out))
    )
    out))


(e074)
;-> 402

(time (e074))
;-> 28605.673

Questa è la più veloce anche se il tempo non è entusiasmante.
----------------------------------------------------------------------------


===========
Problema 75
===========

Risulta che 12 cm è la più piccola lunghezza di filo che può essere piegata per formare un triangolo ad angolo retto con un lato intero esattamente in un modo, ma ci sono molti altri esempi.

12 cm: (3,4,5)
24 cm: (6,8,10)
30 cm: (5,12,13)
36 cm: (9,12,15)
40 cm: (8,15,17)
48 cm: (12,16,20)

Al contrario, alcune lunghezze di filo, come 20 cm, non possono essere piegate per formare un triangolo ad angolo retto con un lato intero, e altre lunghezze consentono di trovare più di una soluzione. Ad esempio, utilizzando 120 cm è possibile formare esattamente tre triangoli ad angolo retto con lati interi diversi.

120 cm: (30,40,50), (20,48,52), (24,45,51)

Dato che L è la lunghezza del filo, per quanti valori di L ≤ 1.500.000 si può formare esattamente un triangolo ad angolo retto con un lato intero?
============================================================================

L'idea centrale è quella di iterare sulle lunghezze dei cateti: se le lunghezze dei lati non sono numeri coprimi, allora abbiamo già contato quella tripla pitagorica. Potete trovare maggiori spiegazioni nell'articolo "Tree of primitive Pythagorean triples" su wikipedia.

(define (e075)
  (local (limite ar perimetro)
    (setq limite 1500000)
    (setq ar (array limite '(0)))
    (for (i 1 (- (sqrt limite) 1) 2)
      (for (j 2 (- (sqrt limite) i 1) 2)
        (if (= (gcd i j) 1)
            (begin
            (setq perimetro (+ (abs (- (* j j) (* i i))) (* 2 i j) (* i i) (* j j)))
            (setq x perimetro)
            (while (< x limite)
              (++ (ar x))
              (setq x (+ x perimetro))
            ))
        )
      )
    )
    (first (count '(1) (array-list ar)))))

(e075)
;-> 161667

(time (e075))
;-> 822.828
----------------------------------------------------------------------------


===========
Problema 76
===========

Conteggio delle somme

È possibile scrivere cinque come somma in esattamente sei modi diversi:

4 + 1
3 + 2
3 + 1 + 1
2 + 2 + 1
2 + 1 + 1 + 1
1 + 1 + 1 + 1 + 1

In quanti modi diversi si può scrivere cento come somma di almeno due numeri interi positivi?
============================================================================

La soluzione è simile a quella del problema 31. Le uniche differenze sono:
1) il totale vale 100 (invece di 200)
2) le monete (gli interi in questo caso) vanno da 1 a 99 (invece che (1 2 5 10 20 50 100 200))

(define (e076)
  (local (totale monete modi)
    ; valore obiettivo
    (setq totale 100)
    ; lista dei tagli di monete disponibili
    (setq monete (sequence 1 99))
    ; crea un vettore di totale elementi con tutti valori 0 tranne il primo (modi[0]) che vale 1
    (setq modi (array (+ totale 1) (extend '(1) (dup 0 totale))))
    (dolist (el monete)
      (for (i el totale)
        (setq (modi i) (+ (modi i) (modi (- i el))))
      )
    )
    (modi totale)))

(e076)
;-> 190569291

(time (e076))
;-> 0
----------------------------------------------------------------------------


===========
Problema 77
===========

Somme di primi

È possibile scrivere dieci come somma dei numeri primi esattamente in cinque modi diversi:

7 + 3
5 + 5
5 + 3 + 2
3 + 3 + 2 + 2
2 + 2 + 2 + 2 + 2

Qual è il primo valore che può essere scritto come somma di numeri primi in oltre cinquemila modi diversi?
============================================================================

L'algoritmo di soluzione è simile a quella del problema precedente. Al posto del totale=100 iniziamo da 2 fino a che non troviamo tutte le soluzioni. Inoltre, invece di utilizzare i numeri da 1 a 99, usiamo i numeri primi (preventivamente calcolati).

(define (e077)
  (local (primi limite iter modi i continua)
    (setq primi '(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79))
    (setq limite 5000)
    (setq iter 2)
    (setq continua true)
    (while continua
      ;(println iter)
      (setq modi (array (+ iter 1) (extend '(1) (dup 0 iter))))
      ;(println modi)
      ;(read-line)
      (dolist (p primi)
        (setq i p)
        (while (<= i iter)
          (setf (modi i) (+ (modi i) (modi (- i p))))
          (++ i)
        )
      )
      (if (> (modi iter) 5000)
          (setq continua nil)
          (++ iter)
      )
    )
    iter))

(e077)
;-> 71

(time (e077))
;-> 4.015
----------------------------------------------------------------------------


===========
Problema 78
===========

Partizioni di monete

Sia p(n) il numero dei diversi modi in cui n monete possono essere separate in pile. Ad esempio, cinque monete possono essere separate in pile in esattamente sette modi diversi, quindi p(5) = 7.

OOOOO
OOOO   O
OOO   OO
OOO   O   O
OO   OO   O
OO   O   O   O
O   O   O   O   O

Trova il valore minimo di n per cui p(n) è divisibile per un milione.
============================================================================

Su wikipedia si trova che la funzione generatrice per p(n) vale:

p(n) = p(n - 1) + p(k - 2) - p(k - 5) - p(k - 7) + p(k - 12) + p(k - 15) - p(k - 22) ...

dove p(0) = 1 e p(n) = 0 per n < 0.

La sequenza dei numeri k da utilizzare è data dalla formula dei numeri pentagonali generalizzati:

f(k) = k*(3k-1)/2 che vale sia per k negativo che per k positivo.

Questa formula può essere generata nel modo seguente:

    | (m/2 + 1)    se (k mod 2) = 0,
k = |
    | (-m/2 - 1)   altrimenti

I segni della funzione seguono lo schema +, +, -, -, +, +, -, -,...

Quindi partendo dal primo valore della sequenza possiamo calcolare quella successiva e cosi via.

(define (penta k) (/ (* k (- (* 3 k) 1)) 2))

(define (e078)
  (local (n p-vec segno penta continua i j val)
    (setq p-vec (array 100000 '(0)))
    (setq n 1)
    (setf (p-vec 0) 1)
    (setq continua true)
    (while continua
      (setq i 0)
      (setq penta 1)
      (while (<= penta n)
        (if (> (% i 4) 1)
            (setq segno -1)
            (setq segno 1))
        (setf (p-vec n) (+ (p-vec n) (* segno (p-vec (- n penta)))))
        (setf (p-vec n) (% (p-vec n) 1000000))
        (++ i)
        (if (zero? (% i 2))
            (setq j (+ (/ i 2) 1))
            (setq j (- (+ (/ i 2) 1))))
        (setq penta (/ (* j (- (* 3 j) 1)) 2))
      )
      (if (zero? (p-vec n))
          (setq continua nil)
          (++ n))
      ;(if (zero? (% n 10000)) (println n))
    )
    n))

(e078)
;-> 55374

(time (e078))
;-> 7918.736

Il tempo di esecuzione non è entusiasmante, ma non è che abbia capito molto bene come funziona tutta la matematica dietro il partizionamento degli interi. Mi accontento che il risultato sia corretto.
----------------------------------------------------------------------------


===========
Problema 79
===========

Derivazione del passcode

Un metodo di sicurezza comune utilizzato per l'online banking consiste nel chiedere all'utente tre caratteri casuali da un passcode. Ad esempio, se il codice di accesso era 531278, potrebbero richiedere il 2°, il 3° e il 5° carattere:  la risposta attesa sarebbe 317.

Il file di testo, keylog.txt, contiene cinquanta tentativi di accesso riusciti.

Dato che i tre caratteri vengono sempre richiesti in ordine, analizzare il file in modo da determinare il codice segreto più breve possibile di lunghezza sconosciuta.
============================================================================

Il file "keylog.txt" è stato trasformato nella lista seguente:

(setq pwd '("319" "680" "180" "690" "129" "620" "762" "689" "318" "368" "710"
            "720" "629" "168" "160" "716" "731" "736" "729" "316" "769" "290"
            "719" "389" "162" "289" "718" "790" "890" "362" "760" "380" "728"))

(length pwd)
;-> 50

Eliminiamo i valori doppi:

(setq pwd (unique pwd))
;-> ("319" "680" "180" "690" "129" "620" "762" "689" "318" "368" "710"
;->  "720" "629" "168" "160" "716" "731" "736" "729" "316" "769" "290"
;->  "719" "389" "162" "289" "718" "790" "890" "362" "760" "380" "728")

(length pwd)
;-> 33

Definiamo tre liste che conterranno le prime, le seconde e le terze cifre di ogni numero di login (ripetute solo una volta):

(setq prima '())
(setq seconda '())
(setq terza '())
(dolist (login pwd)
  (push (login 0) prima -1)
  (push (login 1) seconda -1)
  (push (login 2) terza -1)
)
(setq prima (unique prima))
;-> ("3" "6" "1" "7" "2" "8")
(setq seconda (unique seconda))
;-> ("1" "8" "9" "2" "6" "3")
(setq terza (unique terza))
;-> ("9" "0" "2" "8" "6" "1")

Uniamo tutte le cifre:

(setq uniche prima)
(setq uniche (unique (extend uniche seconda terza)))
;-> ("3" "6" "1" "7" "2" "8" "9" "0")
(length uniche)
;-> 8

Quindi possiamo trarre le seguenti conclusioni:

1) la password minima è lunga quanto la lista "uniche": 8
2) nella password non ci sono le cifre "4" e "5"
3) La prima cifra della della password è "7", perchè è l'unica cifra che compare solo nella lista "prima".
4) L'ultima cifra della password è "0", perchè è l'unica cifra che compare solo nella lista "terza".

Per adesso, la password vale "7xxxxxx0", dove xxxxxx sono occupate, in qualche ordine, da "1" "2" "3" "6" "8" "9".

Dalla lista "pwd" possiamo calcolare, per ogni cifra, tutte le cifre che appaiono prima e tutte le cifre che appaiono dopo:

(define (cifre-dove x lst)
  (setq prima-di-x '())
  (setq dopo-di-x '())
  (dolist (login pwd)
    (setq pos-x (find x login))
    (cond ((= 0 pos-x)
           (push (login 1) dopo-di-x -1)
           (push (login 2) dopo-di-x -1))
          ((= 1 pos-x)
           (push (login 0) prima-di-x -1)
           (push (login 2) dopo-di-x -1))
          ((= 2 pos-x)
           (push (login 0) prima-di-x -1)
           (push (login 1) prima-di-x -1))
    )
  )
  (setq prima-di-x (unique prima-di-x))
  (setq dopo-di-x (unique dopo-di-x))
  (println "Prima di " x " : " prima-di-x)
  (println "Dopo di " x " : " dopo-di-x))

(cifre-dove "0")
;-> Prima di 0 : ("6" "8" "1" "9" "2" "7" "3")
;-> Dopo di 0 : ()
(cifre-dove "1")
;-> Prima di 1 : ("3" "7")
;-> Dopo di 1 : ("9" "8" "0" "2" "6")
(cifre-dove "2")
;-> Prima di 2 : ("1" "6" "7" "3")
;-> Dopo di 2 : ("9" "0" "8")
(cifre-dove "3")
;-> Prima di 3 : ("7")
;-> Dopo di 3 : ("1" "9" "8" "6" "2" "0")
(cifre-dove "6")
;-> Prima di 6 : ("7" "3" "1")
;-> Dopo di 6 : ("8" "0" "9" "2")
(cifre-dove "7")
;-> Prima di 7 : ()
;-> Dopo di 7 : ("6" "2" "1" "0" "3" "9" "8")
(cifre-dove "8")
;-> Prima di 8 : ("6" "1" "3" "2" "7")
;-> Dopo di 8 : ("0" "9")
(cifre-dove "9")
;-> Prima di 9 : ("3" "1" "6" "2" "8" "7")
;-> Dopo di 9 : ("0")

Da una semplice analisi troviamo che:
prima di 3 c'è solo 7                           ==> 73xxxxx0
prima di 1 ci sono solo 3 e 7                   ==> 731xxxx0
prima di 6 ci sono solo 3 e 7 e 1               ==> 7316xxx0
prima di 2 ci sono solo 3 e 7 e 1 e 6           ==> 73162xx0
prima di 8 ci sono solo 3 e 7 e 1 e 6 e 2       ==> 731628x0
prima di 9 ci sono solo 3 e 7 e 1 e 6 e 2 e 8   ==> 73162890

Quindi la soluzione vale: 73162890

L'ultima funzione è sufficiente per definire una procedura che calcola la soluzione.

Nel 2009 avevo scritto la seguente soluzione in python:

log = [319,680,180,690,129,620,762,689,762,318,368,710,720,710,629,168,160,689,716,
731,736,729,316,729,729,710,769,290,719,680,318,389,162,289,162,718,729,319,790,680,
890,362,319,760,316,729,380,319,728,716]

def eulero079(L):
   a = []
   for i in range(0,len(L)):
       iL = int2list(L[i])
       a.append((iL[0],iL[1]))
       a.append((iL[1],iL[2]))
   a.sort()
   # calcolo, per ogni numero, la lista dei numeri che stanno prima
   pri = []
   for x in [0,1,2,3,6,7,8,9]:
       base = []
       for i in range(0,len(a)):
           if a[i][1] == x:
               base.append(a[i][0])
       newbase = list(set(base))
       newbase.sort()
       pri.append((x,newbase))
   # aggiorno le liste con i numeri che stanno davanti
   for k in range(0,10):
       primaD = {}
       for i in range(0,len(pri)):
           primaD[pri[i][0]] = pri[i][1]
       pri = []
       for i in primaD.keys():
           tp = []
           for val in primaD[i]:
               tp = tp + primaD[val]
           tpp = list(set(tp+primaD[i]))
           tpp.sort
           pri.append((i,tpp))
   ma = [(len(pri[i][1]),pri[i][0]) for i in range(0,len(pri))]
   ma.sort()
   # "ma" è una lista ordinata per posizione che contiene tuple del tipo:
   # (posizione,cifra)
   # Costruzione della soluzione
   pwd = ''
   for i in range(len(ma)):
       pwd = pwd + str(ma[i][1])
   return(pwd)

eulero079(log)
;-> 73162890
----------------------------------------------------------------------------


===========
Problema 80
===========

Espansione digitale della radice quadrata

È noto che se la radice quadrata di un numero naturale non è un intero, allora è irrazionale. L'espansione decimale di tali radici quadrate è infinita senza alcun motivo ripetitivo.

La radice quadrata di due è 1,41421356237309504880 ... e la somma digitale delle prime cento cifre decimali è 475.

Per i primi cento numeri naturali, trova il totale delle somme digitali delle prime cento cifre decimali per tutte le radici quadrate irrazionali.
============================================================================

(sqrt 2)
;-> 1.414213562373095

Funzione per calcolare una potenza intera (big-integer):

(define (** num power)
    (let (out 1L)
        (dotimes (i power)
            (setq out (* out num)))))

Funzione per calcolare la somma delle cifre di un numero:

(define (digit-sum num)
  (let (out 0)
    (while (!= num 0)
      (setq out (+ out (% num 10)))
      (setq num (/ num 10))
    )
    out))

Per calcolare la radice quadrata di un numero (specificando il numero di cifre dopo la virgola) utilizziamo l'algoritmo riportato nell'articolo "Square roots by subtraction" di Frazer Jarvis.

(setq limite (** 10 (+ 14 1)))
(define (sqrt-prec num cifre)
  (local (a b limite)
    (setq limite (** 10 (+ cifre 1)))
    (setq a (* 5L num))
    (setq b 5L)
    (while (< b limite)
      (cond ((>= a b)
             (setq a (- a b))
             (setq b (+ b 10))
            )
            (true
             (setq a (* a 100))
             (setq b (+ (* (/ b 10) 100) 5))
            )
      )
    )
    (/ b 100)))

(digit-sum (sqrt-prec 2 100))
;-> 475

(define (e080)
  (let ((q 1) (out 0))
    (for (i 1 100)
      (cond ((= (* q q) i)
             (++ q)
            )
            (true
              (setq out (+ out (digit-sum (sqrt-prec i 100))))
            )
      )
    )
    out))

(e080)
;-> 40886

(time (e080))
;-> 29.95
----------------------------------------------------------------------------


===========
Problema 81
===========

Somma del percorso: due modi

Nella matrice 5 per 5 di seguito, la somma minima del percorso da in alto a sinistra a in basso a destra, spostandosi solo a destra e in basso, è sottolineata ed è uguale a 2427.

    131 673 234 103  18
    ---
    201  96 342 965 150
    --- --- ---
    630 803 746 422 111
            ---
    537 699 497 121 956
                ---
    805 732 524  37 331
                ---

Trova la somma minima del percorso da in alto a sinistra a in basso a destra spostandoti a destra e in basso in "matrix.txt", un file di testo 31K contenente una matrice 80 per 80.
============================================================================

Il file "matrix.txt" è stato trasformato nel file "e081.lsp", una lista di nome "matrix" che rappresenta la matrice.

La somma del percorso minimo dall'angolo in alto a sinistra a una data cella è il valore della cella più il minimo della somma del percorso per la cella sopra di essa e la somma del percorso per la cella a sinistra di essa. Questo ci permette di risolvere il problema con la tecnica della programmazione dinamica.

(load "e081.lsp")

(matrix 0 0)
;-> 4445
(matrix 79 79)
;-> 7981

numero righe:
(length matrix)
;-> 80
numero colonne:
(length (matrix 0))
;-> 80

(define (e081)
  (load "e081.lsp")
  (let (len (- (length matrix) 1))
    ; calcolo dp della prima riga della matrice
    (for (i 1 len)
      (setf (matrix 0 i) (+ (matrix 0 i) (matrix 0 (- i 1))))
    )
    ; calcolo dp della prima colonna della matrice
    (for (i 1 len)
      (setf (matrix i 0) (+ (matrix i 0) (matrix (- i 1) 0)))
    )
    ; calcolo dp del resto della matrice
    (for (i 1 len)
      (for (j 1 len)
        (setf (matrix i j) (+ (matrix i j) (min (matrix (- i 1) j) (matrix i (- j 1)))))
      )
    )
    (matrix len len)))

(e081)
;-> 427337

(time (e081))
;-> 3
----------------------------------------------------------------------------


===========
Problema 82
===========

Somma del percorso: tre modi

La somma del percorso minimo nella matrice 5 per 5 di seguito, iniziando in qualsiasi cella nella colonna di sinistra e finendo in qualsiasi cella nella colonna di destra, e spostandosi solo su, giù e destra, è sottolineata: la somma è pari a 994.

    131 673 234 103  18
            --- --- ---
    201  96 342 965 150
    --- --- ---
    630 803 746 422 111

    537 699 497 121 956

    805 732 524  37 331

Trova la somma minima del percorso dalla colonna di sinistra alla colonna di destra in "matrix.txt", un file di testo 31K contenente una matrice 80 per 80.
============================================================================

Il file "matrix.txt" è stato trasformato nel file "e082.lsp", una lista di nome "matrix" che rappresenta la matrice.

(load "e082.lsp")

(matrix 0 0)
;-> 4445
(matrix 79 79)
;-> 7981

L'algoritmo è simile a quello del problema 81, ma abbiamo bisogno di un vettore ausiliario per tenere traccia delle soluzioni parziali.

(define (e082)
(load "e082.lsp")
  (letn ((len (- (length matrix) 1)) (sp (array (+ len 1) '(0))))
    ; Soluzione iniziale
    (for (i 0 len)
      (setf (sp i) (matrix i len))
    )
    ; calcolo dp della prima colonna della matrice
    (for (i (- len 1) 0)
      ; analizza in basso
      (setf (sp 0) (+ (sp 0) (matrix  0 i)))
      ; calcolo soluzione minima parziale
      (for (j 1 len)
        (setf (sp j) (min (+ (sp (- j 1)) (matrix j i)) (+ (sp j) (matrix j i))))
      )
      ; analizza in alto
      (for (j (- len 1) 0)
        (setf (sp j) (min (sp j) (+ (sp (+ j 1)) (matrix j i))))
      )
    )
    ; soluzione minima assoluta
    (apply min sp)))

(e082)
;-> 260324

(time (e082))
;-> 4
----------------------------------------------------------------------------


===========
Problema 83
===========

Somma del percorso: quattro modi

NOTA: questo problema è una versione notevolmente più impegnativa del problema 81.

Nella matrice 5 per 5 di seguito, la somma del percorso minimo dall'alto a sinistra verso il basso a destra, spostandosi a sinistra, a destra, in alto e in basso, è sottolineata ed è uguale a 2297.

    131 673 234 103  18
    ---     --- --- ---
    201  96 342 965 150
    --- --- ---     ---
    630 803 746 422 111
                --- ---
    537 699 497 121 956
                ---
    805 732 524  37 331
                --- ---

Trova la somma minima del percorso da in alto a sinistra a in basso a destra spostandoti a sinistra, destra, su e giù in "matrix.txt", un file di testo di 31K contenente 80 da 80 matrice.
============================================================================

Il file "matrix.txt" è stato trasformato nel file "e082.lsp", una lista di nome "matrix" che rappresenta la matrice.

(load "e083.lsp")
(matrix 0 0)
;-> 4445
(matrix 79 79)
;-> 7981

Algoritmo di soluzione preso da un articolo del sito https://www.programmersought.com/

Considerando la matrice come un grafo diretto in cui ogni numero rappresenta il peso di ogni arco possiamo utilizzare l'algoritmo di Dijkstra. Questo algoritmo trova la distanza più breve da un vertice ad altri vertici in un grafo diretto o non orientato (i pesi del grafo devono avere tutti un valore maggiore di 0). Sul sito https://www.programmersought.com/ ho trovato

Per risolvere il problema utilizziamo un vettore dist[][2], dist[a][0] rappresenta la lunghezza del percorso più breve da 0 ad "a" che abbiamo trovato (non necessariamente la più breve), dist[a][1] = 1 significa che questo è il più breve, dist[a][1] = 0 significa che non siamo ancora sicuri che questa sia la lunghezza più breve.

Inizializziamo i valori, dist[0][0] = 0, dist[0][1] = 1, dist[i][0](i ≠ 0) = infinito, a[i][1] = 0.

Quindi esaminando i diversi punti adiacenti ad a0, come a1 e a3, possiamo lasciare dist[1][0] = dist[0][0] + P (il peso da a0 a a1) e fare la stessa cosa per dist[3][0].

A questo punto, troviamo il valore minimo di dist[][1] = 0 in dist[][0], ad esempio, dist[3][1], quindi possiamo confermare che questo deve essere il percorso più breve da a0 a a3. Perché se c'è un percorso più breve, deve iniziare da a0 e a3 è il valore minimo in dist, il che costituisce una contraddizione. Quindi il percorso più breve da a0 ad a3 è confermato.

Adesso esaminiamo i vertici adiacenti ad a3 e ripetiamo l'operazione sopra. Dopo un numero limitato di operazioni, è possibile ottenere la lunghezza del percorso più breve da a0 a tutti i vertici e, se il percorso non viene trovato, dist[i][0] ha valore infinito.

(define (e083)
  ;(load "e083.lsp")
  (local (dist iter idxm)
    ; vettore delle distanze
    (setq dist (array 6400 2 '(10000000 0)))
    (setq iter 0)
    (setq idxm 0)
    ; inizializzazione vettore delle distanze
    (setf (dist 0 0) 0)
    (setf (dist 0 1) 1)
    (setf (dist 1 0) (matrix 0 1))
    (setf (dist 80 0) (matrix 1 0))
    ; 80x80 = 6400
    (while (< iter 6400)
      (setq idxm (foundmin dist))
      ;(println idxm)
      ;(read-line)
      ; flag: percorso minimo
      (setf (dist idxm 1) 1)
      ; aggiorna le distanze con i punti adiacenti
      (if (!= (% idxm 80) 0)
          (setf (dist (- idxm 1) 0) (min (dist (- idxm 1) 0) (+ (dist idxm 0) (matrix (/ idxm 80) (- (% idxm 80) 1))))))
      (if (!= (% idxm 80) 79)
          (setf (dist (+ idxm 1) 0) (min (dist (+ idxm 1) 0) (+ (dist idxm 0) (matrix (/ idxm 80) (+ (% idxm 80) 1))))))
      (if (!= (/ idxm 80) 0)
          (setf (dist (- idxm 80) 0) (min (dist (- idxm 80) 0) (+ (dist idxm 0) (matrix (- (/ idxm 80) 1) (% idxm 80))))))
      (if (!= (/ idxm 80) 79)
          (setf (dist (+ idxm 80) 0) (min (dist (+ idxm 80) 0) (+ (dist idxm 0) (matrix (+ (/ idxm 80) 1) (% idxm 80))))))
      ;(println (dist (- idxm 1) 0) { } (dist (+ idxm 1) 0) { } (dist (- idxm 80) 0) { } (dist (+ idxm 80) 0))
      ;(read-line)
      (++ iter)
    )
    (+ (dist 6399 0) (matrix 0 0))))

(e083)
;-> 425185

(time (e083))
;-> 6503.784
----------------------------------------------------------------------------


===========
Problema 84
===========

In the game, Monopoly, the standard board is set up in the following way:

   GO  A1  CC1 A2  T1  R1  B1  CH1 B2  B3  JAIL
   H2                                      C1
   T2                                      U1
   H1                                      C2
   CH3                                     C3
   R4                                      R2
   G3                                      D1
   CC3                                     CC2
   G2                                      D2
   G1                                      D3
   G2J F3  U2  F2  F1  R3  E3  E2  CH2 E1  FP

A player starts on the GO square and adds the scores on two 6-sided dice to determine the number of squares they advance in a clockwise direction. Without any further rules we would expect to visit each square with equal probability: 2.5%. However, landing on G2J (Go To Jail), CC (community chest), and CH (chance) changes this distribution.

In addition to G2J, and one card from each of CC and CH, that orders the player to go directly to jail, if a player rolls three consecutive doubles, they do not advance the result of their 3rd roll. Instead they proceed directly to jail.

At the beginning of the game, the CC and CH cards are shuffled. When a player lands on CC or CH they take a card from the top of the respective pile and, after following the instructions, it is returned to the bottom of the pile. There are sixteen cards in each pile, but for the purpose of this problem we are only concerned with cards that order a movement. Any instruction not concerned with movement will be ignored and the player will remain on the CC/CH square.

Community Chest (2/16 cards):
  1. Advance to GO
  2. Go to JAIL
Chance (10/16 cards):
  1. Advance to GO
  2. Go to JAIL
  3. Go to C1
  4. Go to E3
  5. Go to H2
  6. Go to R1
  7. Go to next R (railway company)
  8. Go to next R
  9. Go to next U (utility company)
 10. Go back 3 squares.

The heart of this problem concerns the likelihood of visiting a particular square. That is, the probability of finishing at that square after a roll. For this reason it should be clear that, with the exception of G2J for which the probability of finishing on it is zero, the CH squares will have the lowest probabilities, as 5/8 request a movement to another square, and it is the final square that the player finishes at on each roll that we are interested in. We shall make no distinction between "Just Visiting" and being sent to JAIL, and we shall also ignore the rule about requiring a double to "get out of jail", assuming that they pay to get out on their next turn.

By starting at GO and numbering the squares sequentially from 00 to 39 we can concatenate these two-digit numbers to produce strings that correspond with sets of squares.

Statistically it can be shown that the three most popular squares, in order, are JAIL (6.24%) = Square 10, E3 (3.18%) = Square 24, and GO (3.09%) = Square 00. So these three most popular squares can be listed with the six-digit modal string: 102400.

If, instead of using two 6-sided dice, two 4-sided dice are used, find the six-digit modal string.
============================================================================

La soluzione consiste nel simulare il gioco seguendo tutte le regole, lanciare i dadi per tante volte e contare quante volte si passa per ogni casella.

(define (e084)
(local (freq max-lanci num-lanci pos num d1 d2 d3 d4 perc)
  (setq freq (array 40 '(0)))
  (setq max-lanci 100000 num-lanci 0 pos 0 num 0)
  (while (< num-lanci max-lanci)
    (setq d1 (+ (rand 4) 1))
    (setq d2 (+ (rand 4) 1))
    (setq pos (+ pos d1 d2))
    (if (> pos 39 (setq pos (- pos 40))))
    (if (= d1 d2) (++ num) (setq num 0))
    (if (or (= pos 2) (= pos 17) (= pos 33))
        (begin (setq d3 (+ (rand 16) 1))
              (if (= d3 1) (setq pos 0))
              (if (= d3 2) (setq pos 10))))
    (if (or (= pos 7) (= pos 22) (= pos 33))
        (begin (setq d4 (+ (rand 15) 1))
              (if (= d4 1) (setq pos 0))
              (if (= d4 2) (setq pos 10))
              (if (= d4 3) (setq pos 11))
              (if (= d4 4) (setq pos 24))
              (if (= d4 5) (setq pos 39))
              (if (= d4 6) (setq pos 5))
              (if (or (= d4 7) (= d4 8))
                  (begin (if (= pos 7) (setq pos 12))
                          (if (= pos 22) (setq pos 25))
                          (if (= pos 36) (setq pos 5))))
              (if (= d4 9)
                  (begin (if (= pos 7) (setq pos 12))
                          (if (= pos 22) (setq pos 28))
                          (if (= pos 36) (setq pos 12))))
              (if (= d4 10) (setq pos (- pos 3)))))
    (if (or (= pos 30) (= num 3)) (setq pos 10))
    (++ (freq pos))
    (++ num-lanci)
    (if (= num 3) (setq num 0))
  )
  (setq perc '())
  (for (i 0 39)
    (push (list (mul (div (freq i) max-lanci) 100) i) perc)
  )
  (sort perc >)
  (int (string (perc 0 1) (perc 1 1) (perc 2 1)))))

(e084)
;-> 101524

(time (e084))
;-> 66.849
----------------------------------------------------------------------------


===========
Problema 85
===========

Contare i rettangoli

Contando attentamente si può vedere che una griglia rettangolare di 3 x 2 contiene diciotto rettangoli:

                        1 da 3x2               2 da 2x2         3 da 1x2
 ╔════╦════╦════╗       ╔══════════════╗       ╔════════╗       ╔════╗
 ║    ║    ║    ║       ║              ║       ║        ║       ║    ║
 ╠════╬════╬════╣  ==>  ║      1       ║   +   ║   2    ║   +   ║ 3  ║   +
 ║    ║    ║    ║       ║              ║       ║        ║       ║    ║
 ╚════╩════╩════╝       ╚══════════════╝       ╚════════╝       ╚════╝

                        2 da 3x1               4 da 2x2         6 da 1x1
                        ╔══════════════╗       ╔════════╗       ╔════╗
                     +  ║      2       ║   +   ║   4    ║   +   ║ 6  ║   =  18
                        ╚══════════════╝       ╚════════╝       ╚════╝

Sebbene non esista una griglia rettangolare che contenga esattamente due milioni di rettangoli, trova l'area della griglia con la soluzione più vicina.
============================================================================

Una griglia N * M può essere rappresentata come (N + 1) linee orizzontali e (M + 1) linee verticali.
In un rettangolo, abbiamo bisogno di due distinte linee orizzontali e due distinte linee verticali.
Quindi possiamo scegliere 2 linee verticali e 2 linee orizzontali per formare un rettangolo. Ci sono (N+1) scelte per la larghezza e (M+1) scelte per l'altezza, quindi il numero totale di rettangoli possibili nella griglia vale:

 binom(N+1,2) * binom(M+1,2) = (N*(N+1)*M*(M+1))/4

(define (e085)
  (local (diff area numrett adiff erow ecol)
    (setq diff 2000000 area -1 erow -1 ecol -1)
    (for (r 1 100)
      (for (c 1 100)
        (setq numrett (/ (* r (+ r 1) c (+ c 1)) 4))
        (setq adiff (abs (- numrett 2000000)))
        (if (< adiff diff)
             (setq area (* r c) diff adiff erow r ecol c))))
    area))

(e085)
;-> 2772

(time (e085))
;-> 2
----------------------------------------------------------------------------


===========
Problema 86
===========
Un ragno, S, si trova in un angolo di una stanza cuboide (parallelepipedo) che misura 6 per 5 per 3, e una mosca, F, si trova nell'angolo opposto. Percorrendo le superfici della stanza la distanza "retta" più breve da S a F è 10 e il percorso è mostrato nel diagramma "e086p.png".

Tuttavia, ci sono fino a tre candidati di percorso "più breve" per ogni dato cuboide e il percorso più breve non ha sempre una lunghezza intera.

Si può dimostrare che ci sono esattamente 2060 cuboidi distinti, ignorando le rotazioni, con dimensioni intere, fino a una dimensione massima di M per M per M, per cui la rotta più breve ha lunghezza intera quando M = 100. Questo è il valore minimo di M per cui il numero di soluzioni supera il valore duemila. Il numero di soluzioni quando M = 99 è 1975.

Trova il valore minimo di M tale che il numero di soluzioni superi prima un milione.
============================================================================

Vedi la figura "e086s.png" per capire quale sia il percorso minimo in un cubo aperto.

Presumendo che a <= b <= c esistono tre percorsi più brevi:

percorso1 = (a + b)^2 + c^2
percorso2 = (a + c)^2 + b^2
percorso3 = (c + b)^2 + a^2

Espandendo le espressioni si trova che il percorso1 ha il valore minimo. Calcoliamo tutti questi percorsi e contiamo quelli che hanno valore intero.

(define (e086)
(catch
  (local (limite conta m a b c percorso sqr)
    (setq limite 1000000 conta 0 m 1)
    (for (m 1 10000)
      (for (a 1 m)
        (for (b a m)
          (setq c m)
          (setq percorso (+ (* (+ a b) (+ a b)) (* c c)))
          (setq sqr (sqrt percorso))
          (if (= (* sqr sqr) percorso) (++ conta))
        )
      )
      (if (> conta limite) (throw m))
    )
    m)))

(e086)
;-> 1818

(time (println (e086)))
;-> 233564.084

Calcolando tutti i percorsi occorre molto tempo per calcolare la soluzione.

Un altro metodo è quello di pensare (a + b) come un unico valore "ab", che varia da 2 a 2*M. In questo modo si fissa il valore "c" al suo valore massimo. Adesso dobbiamo trovare il numero di cubi, corrispondenti al valore "c", che soddisfano la condizione.

(define (e086)
  (local (limit conta ab c sqr)
    (setq limit 1000000 conta 0 c 1)
    (while (< conta limit)
      (++ c)
      (for (ab 2 (* 2 c))
        (setq path (+ (* ab ab) (* c c)))
        (setq sqr (sqrt path))
        (if (= (* sqr sqr) path)
            (if (>= ab c)
                (setq conta (+ conta 1 (- c (/ (+ ab 1) 2))))
                (setq conta (+ conta (/ ab 2)))))))
    c))

(e086)
;-> 1818

(time (e086))
;-> 528.583
----------------------------------------------------------------------------


===========
Problema 87
===========

Triple potenze di primi

Il numero più piccolo esprimibile come la somma di un quadrato primo, un cubo primo e una quarta potenza primo è 28. In effetti, ci sono esattamente quattro numeri inferiori a cinquanta che possono essere espressi in questo modo:

28 = 2^2 + 2^3 + 2^4
33 = 3^2 + 2^3 + 2^4
49 = 5^2 + 2^3 + 2^4
47 = 2^2 + 3^3 + 2^4

Quanti numeri inferiori a cinquanta milioni possono essere espressi come la somma di un quadrato primo, un cubo primo e una quarta potenza primo?
============================================================================

Funzione per calcolare i numeri primi fino a n:

(define (primes-to num)
  (cond ((= num 1) '())
        ((= num 2) '(2))
        (true
         (let (lst '(2))
          (setq arr (array (+ num 1)))
          (for (x 3 num 2)
                (when (not (arr x))
                  (push x lst -1)
                  (for (y (* x x) num (* 2 x) (> y num))
                      (setf (arr y) true)))) lst))))

L'algoritmo è abbastanza semplice e può essere estrapolato dai commenti della funzione:

(define (e087)
  (local (val primi primi2 primi3 primi4 limite out)
    (setq out '())
    (setq limite 50000000)
    # calcola i primi fino a sqrt(limite)
    (setq primi (primes-to (int (sqrt limite))))
    ; calcola i quadrati di questi primi (< limite)
    (setq primi2 (filter (fn(x) (< x limite)) (map (fn(x) (* x x)) primi)))
    ; calcola i cubi di questi primi (< limite)
    (setq primi3 (filter (fn(x) (< x limite)) (map (fn(x) (* x x x)) primi)))
    ; calcola le quarte potenze di questi primi (< limite)
    (setq primi4 (filter (fn(x) (< x limite)) (map (fn(x) (* x x x x)) primi)))
    ;(println "p= " primi {-} "p2= " primi2 {-} "p3= " primi3 {-} "p4= " primi4)
    ; crea una lista con le somme di tutti i numeri delle tre liste
    (dolist (a primi2)
      (dolist (b primi3)
        (dolist (c primi4)
          (setq val (+ a b c))
          (if (< val limite)
              (push val out -1)
          ))))
    ; elimina i numeri multipli dalla lista
    (length (unique out))))

(e087)
;-> 1097343

(time (e087))
;-> 1153.946

Per ottimizzare la funzione potremmo:
1) Generare primi2, primi3 e primi4 fino ai numeri i cui quadrati, cubi e quarte potenze sono inferiori al limite
2) fermare il ciclo b quando (a + b) > limite
3) fermare il ciclo c quando (a + b + c) > limite
4) inserire i valori in una hash-map

Comunque il tempo di esecuzione è soddisfacente.
----------------------------------------------------------------------------


===========
Problema 88
===========

Somma e prodotti di numeri

Un numero naturale, N, che può essere scritto come la somma e il prodotto di un dato insieme di almeno due numeri naturali, {a1, a2, ..., ak} è chiamato numero di somma-prodotto: N = a1 + a2 + ... + ak = a1 × a2 × ... × ak.

Ad esempio, 6 = 1 + 2 + 3 = 1 × 2 × 3.

Per un dato insieme di dimensioni, k, chiameremo il più piccolo N con questa proprietà un numero minimo di somma-prodotto. I numeri minimi della somma-prodotto per gli insiemi di dimensione, k = 2, 3, 4, 5 e 6 sono i seguenti.

k = 2:  4 = 2 × 2 = 2 + 2
k = 3:  6 = 1 × 2 × 3 = 1 + 2 + 3
k = 4:  8 = 1 × 1 × 2 × 4 = 1 + 1 + 2 + 4
k = 5:  8 = 1 × 1 × 2 × 2 × 2 = 1 + 1 + 2 + 2 + 2
k = 6: 12 = 1 × 1 × 1 × 1 × 2 × 6 = 1 + 1 + 1 + 1 + 2 + 6

Quindi per 2≤k≤6, la somma di tutti i numeri minimi di somma-prodotto è 4 + 6 + 8 + 12 = 30. Si noti che 8 viene conteggiato una sola volta nella somma.

Infatti, poiché l'insieme completo dei numeri minimi di somma del prodotto per 2≤k≤12 è {4, 6, 8, 12, 15, 16}, la somma è 61.

Qual'è la somma di tutti i numeri minimi di somma-prodotto per 2≤k≤12000?
============================================================================

Per ottenere la somma-prodotto uguale di un numero n occorre utilizzare la fattorizzazione del numero per ottenere il prodotto e aggiungere tanti 1 alla somma per eguagliare il valore del prodotto, poi aggiungiamo lo stesso numero di 1 come moltiplicandi (che non cambiano il valore del prodotto). Per esempio:

(setq n 12)
(factor n)
;-> (2 2 3)

prodotto = 2 * 2 * 3 = 12
   somma = 2 + 2 + 3 + 1 + 1 + 1 + 1 + 1 = 12
prodotto = 2 * 2 * 3 * 1 * 1 * 1 * 1 = 12

Possiamo anche ricavare una formula per il valore della somma-prodotto di una qualunque lista di fattori:

k = numero-di-fattori + prodotto-dei-fattori - somma-dei-fattori

Per esempio per la lista di fattori (2 2 3) abbiamo:

k = 3 + 12 - 7 = 8

Inoltre la somma-prodotto minima per k è maggiore o uguale a k poiché la somma-prodotto minima consiste di k unità che sommano a k. Il limite superiore per la somma-prodotto minima per k è 2k. Il motivo è che possiamo sempre usare i fattori (2, k) questo ci dà il prodotto 2*k e la somma 2+k. Aggiungendo k-2 unità otteniamo una somma di prodotto valida per k che è uguale a 2k.
In altre parole, il prodotto-somma minimo (spm) per k è compreso tra k e 2*k (k ≤ spm(k) ≤ 2*k).

(define (get-k f-lst) (+ (length f-lst) (apply * f-lst) (- (apply + f-lst))))

(get-k (factor 6))
;-> 3

(get-k (factor 8))
;-> 5

Quindi basta fattorizzare tutti i numeri compresi tra 2 e 24000 per verificare se queste fattorizzazioni sono una somma-prodotto minima di qualche k.
Purtroppo bisogna considerare tutte le combinazioni di fattorizzazione per ogni numero perchè la somma-prodotto minima di qualche k non viene prodotta dalla scomposizione primitiva. Per esempio prendiamo il numero 8:

Scomposizione primitiva:
(factor 8)
;-> (2 2 2)
(get-k (factor 8))
;-> 5

L'altra scomposizione di 8 vale: (2 4)
(get-k '(2 4))
;-> 4

Il valore somma-prodotto minimo vale 4 per il numero 8.

Possiamo scrivere una funzione che genera tutte le fattorizzazioni di ogni numero fino a 2*k, ma è molto lenta:

(define (get-factorizations n)
  (let (afc '())
    (all-fact n '() n)))

(define (all-fact num parfac parval)
  (let ((newval parval) (i (- num 1)))
    (while (>= i 2)
      (cond ((zero? (% num i))
              (if (> newval 1) (setq newval i))
              (if (and (<= (/ num i) parval) (<= i parval) (>= (/ num i) i))
                  (begin
                    (push (append parfac (list i (/ num i))) afc -1)
                    (setq newval (/ num i))
                  )
              )
              (if (<= i parval)
                  (all-fact (/ num i) (append parfac (list i)) newval)
              )
            )
      )
      (-- i)
    )
    (sort (unique (map sort afc)))))

(get-factorizations 8)
;-> ((2 2 2) (2 4))
(get-factorizations 12)
;-> ((2 2 3) (2 6) (3 4))
(get-factorizations 24)
;-> ((2 2 2 3) (2 2 6) (2 3 4) (2 12) (3 8) (4 6))
(get-factorizations 280)
;-> ((2 2 2 5 7) (2 2 2 35) (2 2 5 14) (2 2 7 10) (2 2 70)
;->  (2 4 5 7) (2 4 35) (2 5 28) (2 7 20) (2 10 14) (2 140)
;->  (4 5 14) (4 7 10) (4 70) (5 7 8) (5 56) (7 40) (8 35)
;->  (10 28) (14 20))
(get-factorizations 11)
;-> ()
(get-factorizations 577)
;-> ()

Ma questa funzione è inutilizzabile per valori superiori a 10000:

(time (println (get-factorizations 12000)))
;->  ....
;->  (75 160)
;->  (80 150)
;->  (96 125)
;->  (100 120))
;-> 275880.184

Allora calcoliamo dinamicamente ogni fattorizzazione per ogni numero fino a 24.000 aggiungendo ogni fattore a ciascuna fattorizzazione di numeri più piccoli.

(define (fattorizza n resto fattore-max termine somma)
  (cond ((= resto 1)
         (setq termine (+ termine (- n somma)))
         (if (and (<= termine limite) (< n (spm termine)))
             (setf (spm termine) n))
        )
        (true
        (for (i 2 fattore-max)
          (cond ((zero? (% resto i))
                 (setq fattore i)
                 (fattorizza n (/ resto fattore) (min fattore fattore-max) (+ termine 1) (+ somma fattore))))))))

(define (e088)
  (local (limite spm n resto fattore-max fattore somma termine)
    (setq limite 12000)
    (setq spm (array (+ limite 1) '(999999999)))
    (for (i 2 (* limite 2))
      ;(if (zero? (% i 4000)) (print i { }))
      (fattorizza i i i 0 0)
    )
    (setq out (sort (unique (array-list spm))))
    (apply + (slice out 1 (- (length out) 2)))))

(e088)
;-> 7587457

(time (println (e088)))
;-> 24771.751

Il seguente algoritmo calcola il valore minimo di somma-prodotto ricorsivamente:

(define (cerca prodotto somma i)
  (catch
  (local (valprod valsomma)
    (setf (out (- prodotto somma)) (min (out (- prodotto somma)) prodotto))
    (while (<= i (+ n 2))
      (setq valprod (* prodotto i))
      (setq valsomma (+ somma i (- 1)))
      (if (> (- valprod valsomma) n) (throw 'end))
      (cerca valprod valsomma i)
      (++ i)))))

(define (e088)
  (local (limite extra)
    (setq limite 12000)
    (setq extra (+ limite 10))
    (setq out (array extra '(999999999)))
    (cerca 1 0 2)
    (apply + (unique (array-list (slice out 2 11999))))))

(e088)
;-> 7587457

(time (e088))
;-> 377.014
----------------------------------------------------------------------------


===========
Problema 89
===========

Numeri romani

Affinché un numero scritto in numeri romani sia considerato valido, ci sono regole di base che devono essere seguite. Anche se le regole consentono di esprimere alcuni numeri in più di un modo, esiste sempre un modo "migliore" per scrivere un numero particolare.

Ad esempio, sembrerebbe che ci siano almeno sei modi per scrivere il numero sedici:

IIIIIIIIIIIIIIII
VIIIIIIIIIII
VVIIIIII
XIIIIII
VVVI
XVI

Tuttavia, secondo le regole sono validi solo XIIIIII e XVI, e l'ultimo esempio è considerato il più efficiente, poiché utilizza il minor numero di numeri.

Il file di testo 11K, roman.txt, contiene mille numeri scritti in numeri romani validi, ma non necessariamente minimi. V`edi Informazioni sui Numeri romani per le regole definitive di questo problema (.

Trova il numero di caratteri salvati scrivendo ciascuno di questi nella loro forma minima.

Nota: si può presumere che tutti i numeri romani nel file non contengano più di quattro unità identiche consecutive.
============================================================================

Funzione di conversione da numero intero a numero romano:

(define (integer2roman num)
  (local (table roman k)
    (setq table '(("M" 1000) ("CM" 900) ("D" 500) ("CD" 400)
          ("C" 100)("XC" 90)("L" 50)("XL" 40) ("X" 10) ("IX" 9) ("V" 5)
          ("IV" 4) ("I" 1)))
    (setq roman "")
    (dolist (el table)
      (setq k (/ num (last el)))
      (setq num (% num (last el)))
      (extend roman (dup (first el) k))
    )
    roman))

(integer2roman 4444)
;-> "MMMMCDXLIV"

(integer2roman 16)
;-> "XVI"

Funzione di conversione da numero romano a numero intero:

(define (roman2integer roman)
  (local (table curr prev num)
    (setq table '(("I" 1) ("V" 5) ("X" 10) ("L" 50) ("C" 100) ("D" 500) ("M" 1000)))
    (setq prev 0 num 0)
    ; iterate through all characters
    (dostring (ch roman)
      ; converts the current character into an integer
      (setq curr (lookup (char ch) table))
      ; pick the right case to add or subtract
      (if (>= prev curr)
          (setq num (+ num prev))
          (setq num (- num prev))
      )
      (setq prev curr)
    )
    ; add the last value
    (setq num (+ num curr))))

(roman2integer "MMMMCDXLIV")
;-> 4444

(roman2integer "XIIIIII")
;-> 16

Il file "roman.txt" è stato trasformato nel file "e089.lsp" che ha la seguente struttura:

(setq roma '("MMMMDCLXXII" "MMDCCCLXXXIII" "MMMDLXVIIII" ...)

Scriviamo la funzione finale:

(define (e089)
  (local (somma len1 len2)
    (setq somma 0)
    (dolist (el roma)
      (setq len1 (length el))
      (setq len2 (length (integer2roman (roman2integer el))))
      (setq somma (+ somma (- len1 len2)))
      ;(println (list el (length el)) { }
      ;         (list (integer2roman (roman2integer el)) (length (integer2roman (roman2integer el)))))
      ;(read-line)
    )
    somma))

Carichiamo il file ed eseguiamo la funzione:

(load "roma.lsp")
(length roma)
;-> 1000

(e089)
;-> 743

(time e089)
;-> 0
----------------------------------------------------------------------------


===========
Problema 90
===========

Coppie di cubi con cifre

Ciascuna delle sei facce di un cubo ha una cifra diversa (da 0 a 9) scritta su di essa. Lo stesso viene fatto per un secondo cubo. Mettendo i due cubi fianco a fianco in posizioni diverse possiamo formare una varietà di numeri a 2 cifre.

Ad esempio, il numero quadrato 64 potrebbe essere formato con 6 e 4.

Infatti, scegliendo attentamente le cifre su entrambi i cubi è possibile visualizzare tutti i numeri quadrati inferiori al cento: 01, 04, 09, 16, 25, 36, 49, 64 e 81.

Ad esempio, un modo per ottenere questo risultato è posizionare {0, 5, 6, 7, 8, 9} su un cubo e {1, 2, 3, 4, 8, 9} sull'altro cubo.

Tuttavia, per questo problema, permetteremo che il 6 o il 9 siano capovolti in modo che una disposizione come {0, 5, 6, 7, 8, 9} e {1, 2, 3, 4, 6, 7} permette la visualizzazione di tutti i nove numeri quadrati, altrimenti sarebbe impossibile ottenere 09.

Nel determinare una disposizione distinta siamo interessati alle cifre su ogni cubo, non all'ordine.

{1, 2, 3, 4, 5, 6} è equivalente a {3, 6, 4, 1, 2, 5}
{1, 2, 3, 4, 5, 6} è distinto da {1, 2, 3, 4, 5, 9}

Ma poiché stiamo consentendo l'inversione di 6 e 9, i due insiemi distinti nell'ultimo esempio rappresentano entrambi l'insieme esteso {1, 2, 3, 4, 5, 6, 9} allo scopo di formare numeri a 2 cifre.

Quante disposizioni distinte dei due cubi consentono di visualizzare tutti i numeri quadrati?
============================================================================

Risolviamo il problema con il metodo brute-force. Le spiegazioni dell'algoritmo si trovano nei commenti alla funzione.

Funzione che calcola il numero di combinazioni:

(define (comb k lst)
  (cond ((zero? k)   '(()))
        ((null? lst) '())
        (true
          (append (map (lambda (k-1) (cons (first lst) k-1))
                       (comb (- k 1) (rest lst)))
                  (comb k (rest lst))))))

(define (e090)
  (local (quadrati cifre dado out idx1)
    ; lista delle cifre dove al posto del 9 mettiamo 6
    ; per evitare di dover capovolgere le due cifre nel controllo
    (setq cifre '(0 1 2 3 4 5 6 7 8 6))
    ; lista di tutti i quadrati da creare
    ; nota: (0 6) invece di (0 9) e (4 6) invece di (4 9)
    (setq quadrati '((0 1) (0 4) (0 6) (1 6) (2 5) (3 6) (4 6) (8 1)))
    ; lista di tutte le combinazioni di 6 cifre
    (setq dado (comb 6 cifre))
    ; risultato
    (setq out 0)
    ; per ogni elemento/combinazione (es. (2 3 4 6 7 6)) in dado
    (dolist (d1 dado)
      (setq idx1 $idx)
      ; per ogni elemento/combinazione (es. (2 3 4 6 7 6)) in dado
      ; (diverso da se stesso, infatti prendiamo una parte
      ; della lista "dado" con (slice dado idx1))
      (dolist (d2 (slice dado idx1))
        ; controlla se i due elementi/combinazioni verificano i requisiti
        ; cioè creano tutti i quadrati
        (if (controlla d1 d2) (++ out))
      )
    )
    out))

(define (controlla c1 c2)
  (let ((stop nil) (out true))
    ; Per ogni elemento della lista quadrati
    (dolist (quad quadrati stop)
      ; prima cifra del quadrato
      (setq x (first quad))
      ; seconda cifra del quadrato
      (setq y (last quad))
      ; verifichiamo che può essere creato dalla coppia c1 e c2
      ; se un solo quadrato non può essere creato restituisce nil
      ; altrimenti restituisce true, cioè tutti i quadrati
      ; possono essere creati dalla coppia c1 e c2.
      ; la verifica consiste nel controllare se x e y
      ; compaiono in c1 e c2 o viceversa.
      (if (not (or (and (find x c1) (find y c2)) (and (find x c2) (find y c1))))
          (setq out nil stop true)
      )
    )
    out))

(e090)
;-> 1217

(time (e090))
;-> 31.942
----------------------------------------------------------------------------


===========
Problema 91
===========

Triangoli rettangoli con coordinate intere

I punti P (x1,y1) e Q (x2,y2) sono tracciati in coordinate intere e sono uniti all'origine, O (0,0), per formare ΔOPQ.

Ci sono esattamente quattordici triangoli contenenti un angolo retto che può essere formato quando ciascuna coordinata è compresa tra 0 e 2 inclusi, cioè
0 ≤ x1, y1, x2, y2 ≤ 2.

Dato che 0 ≤ x1, y1, x2, y2 ≤ 50, quanti triangoli rettangoli possono essere formati?
============================================================================

Possiamo risolvere il problema con la forza bruta analizzando tutti i possibili triangoli con coordinate x1,y1 e x2,y2 e la terza coordinata da calcolare/verificare.

(define (qdist x1 y1 x2 y2)
  (let ((d1 (mul (- x1 x2) (- x1 x2)))
        (d2 (mul (- y1 y2) (- y1 y2))))
  (add d1 d2)))

(define (e091)
  (local (limite x1 y1 x2 y2 d1 d2 d3 out)
    (setq limite 50)
    (setq out 0)
    (for (x1 0 limite)
      (for (y1 0 limite)
        (cond ((and (= x1 0) (= y1 0)) nil)
              (true
                (for (x2 0 limite)
                  (for (y2 0 limite)
                    (cond ((or (and (= x2 0) (= y2 0)) (and (= x1 x2) (= y1 y2))) nil)
                          (true
                            (setq d1 (qdist 0 0 x1 y1))
                            (setq d2 (qdist 0 0 x2 y2))
                            (setq d3 (qdist x1 y1 x2 y2))
                            (if (or (= (add d1 d2) d3) (= (add d2 d3) d1) (= (add d1 d3) d2))
                                (++ out))))))))))
    (/ out 2)))

(e091)
;-> 14234

(time (e091))
;-> 7259.789

Altro algoritmo:
se entrambe le coordinate si trovano ai lati della griglia, possiamo creare un triangolo rettangolo. Questo triangolo rettangolo può anche essere trasformato in altri due triangoli rettangoli. Poiché ci sono 50 * 50 = 2500 modi per scegliere queste due coordinate, sappiamo già che ci sono almeno 2500 * 3 = 7500 triangoli rettangoli.
Per trovare il resto dei triangoli facciamo questo ragionamento: se vogliamo trovare un triangolo rettangolo con la coordinata P = (1,2) possiamo tracciare una linea che parte dall'origine O fino a P, la linea avrà una pendenza di 2. Quindi se tracciamo una linea con una pendenza -1/2, il reciproco negativo di 2, sarà perpendicolare a OP. Poiché l'altra coordinata Q deve contenere numeri interi, troveremo Q spostando P 2 blocchi a destra e 1 blocco in basso (usando pendenza = -1/2). Questo triangolo rettangolo sopra può anche essere riflesso lungo la linea y = x per formare un altro triangolo rettangolo.
triangolo rettangolo con coordinate (2, 1) e (1, 3), a y = x riflesso dell'immagine sopra.
Inoltre, possiamo estendere PQ di altri 2 blocchi a destra e 1 blocco in basso e creare un triangolo rettangolo diverso con coordinate (1, 2) e (5, 0).
Avvertenza: le pendenze (frazioni) vanno semplificate altrimenti possiamo perdere alcuni triangoli rettangoli.

(define (e091)
  (local (limite p val out)
    (setq limite 50)
    ; Numero di rettangoli per i punti su entrambi i lati.
    ; (che hanno 3 possibili trasformazioni)
    (setq out (* (pow limite 2) 3))
    ; Calcolo rettangoli rimanenti
    (for (x 1 50)
      (for (y 1 50)
        (setq p (gcd x y))
        (setq dx (/ x p))
        (setq dy (/ y p))
        (setq val (mul 2 (min (/ (- limite x) dy) (/ y dx))))
        (setq out (+ out val))
      )
    )
    out))

(e091)
;-> 14234

(time (e091))
;-> 1
----------------------------------------------------------------------------


===========
Problema 92
===========

Catena del quadrato delle cifre

Una catena di numeri viene creata aggiungendo continuamente il quadrato delle cifre in un numero per formare un nuovo numero fino a quando non è stato visto prima.

Per esempio,

44 → 32 → 13 → 10 → 1 → 1
85 → 89 → 145 → 42 → 20 → 4 → 16 → 37 → 58 → 89

Pertanto qualsiasi catena che arriva a 1 o 89 rimarrà bloccata in un ciclo infinito. La cosa più sorprendente è che OGNI numero di partenza alla fine arriverà a 1 o 89.

Quanti numeri di partenza sotto i dieci milioni arriveranno a 89?
============================================================================

Prima di definire la funzione cha calcola la catena, dobbiamo scrivere la funzione cha calcola la somma dei quadrati delle cifre di un numero:

Prima versione "sum-sq-digit":

(define (int-lst num)
  (let (out '())
    (while (!= num 0)
      (push (% num 10) out)
      (setq num (/ num 10))) out))

(define (sum-sq-digit num)
  (apply + (map (fn(x) (* x x)) (int-lst num))))

(sum-sq-digit 32)
;-> 13
(sum-sq-digit 456)
;-> 77
(time (sum-sq-digit 12345678901234567890) 100000)
;-> 1554.87

Seconda versione "sum-sq-digit":

(define (sum-sq-digit num)
  (let ((cifra 0) (tot 0))
  (while (> num 0)
    (setq cifra (% num 10))
    (setq num (/ (- num cifra) 10))
    (setq tot (+ tot (* cifra cifra)))
  )
  tot))

(sum-sq-digit 32)
;-> 13
(sum-sq-digit 456)
;-> 77
(time (sum-sq-digit 12345678901234567890) 100000)
;-> 1263.057
;-> 140.624

Terza versione "sum-sq-digit":

(define (sum-sq-digit num)
  (let ((cifra 0) (tot 0))
  (while (> num 0)
    (setq cifra (% num 10))
    (setq tot (+ tot (* cifra cifra)))
    (setq num (/ num 10))
  )
  tot))

(sum-sq-digit 32)
;-> 13
(sum-sq-digit 456)
;-> 77
(time (sum-sq-digit 12345678901234567890) 100000)
;-> 1112.057

Quarta versione "sum-sq-digit":

(define (sum-sq-digit num)
  (let ((cifra 0) (tot 0))
  (while (> num 0)
    (setq cifra (% num 10))
    (if cifra
      (setq tot (+ tot (* cifra cifra))))
    (setq num (/ num 10))
  )
  tot))

(sum-sq-digit 32)
;-> 13
(sum-sq-digit 456)
;-> 77
(time (sum-sq-digit 12345678901234567890) 100000)
;-> 1106.45

Adesso scriviamo la funzione che calcola la catena di un numero:

(define (chain num)
  (local (chain-lst num-lst val found out)
    (setq val num found nil)
    (until found
      (setq num (sum-sq-digit num))
      (push num chain-lst -1)
      (if (or (= num 1) (= num 89))
          (setq out (list val num (length chain-lst) chain-lst) found true)
      )
    )
    out))

Vediamo alcuni esempi di catene:

(chain 100)
;-> (100 1 1 (1))
(chain 1)
;-> (1 1 1 (1))
(chain 89)
;-> (89 89 8 (145 42 20 4 16 37 58 89))
(chain 44)
;-> (44 1 4 (32 13 10 1))
(chain 85)
;-> (85 89 1 (89))

(for (i 1 20) (println (chain i)))
;-> (1 1 1 (1))
;-> (2 89 5 (4 16 37 58 89))
;-> (3 89 7 (9 81 65 61 37 58 89))
;-> (4 89 4 (16 37 58 89))
;-> (5 89 4 (25 29 85 89))
;-> (6 89 9 (36 45 41 17 50 25 29 85 89))
;-> (7 1 5 (49 97 130 10 1))
;-> (8 89 5 (64 52 29 85 89))
;-> (9 89 6 (81 65 61 37 58 89))
;-> (10 1 1 (1))
;-> (11 89 6 (2 4 16 37 58 89))
;-> (12 89 5 (5 25 29 85 89))
;-> (13 1 2 (10 1))
;-> (14 89 6 (17 50 25 29 85 89))
;-> (15 89 6 (26 40 16 37 58 89))
;-> (16 89 3 (37 58 89))
;-> (17 89 5 (50 25 29 85 89))
;-> (18 89 5 (65 61 37 58 89))
;-> (19 1 4 (82 68 100 1))
;-> (20 89 5 (4 16 37 58 89))

Scriviamo la funzione che calcola la soluzione con la forza bruta:

(define (e092)
  (local (num n89 found)
    (setq num 9999999 n89 0)
    (for (i 1 num)
      (setq found nil)
      (setq k i)
      (until found
        ;(setq k (apply + (map (fn(x) (* x x)) (int-lst k))))
        (setq k (sum-sq-digit k))
        (if (= k 89) (setq n89 (+ n89 1) found true))
        (if (= k 1)  (setq found true))
      )
    )
    n89))

(e092)
;-> 8581146

(time (e092))
;-> 51582.689

Il tempo di esecuzione non è molto soddisfacente.

Per trovare un algoritmo migliore dobbiamo fare alcune considerazioni.

Notiamo che due numeri che hanno le stesse cifre hanno la stessa catena perchè calcoliamo la somma dei quadrati delle cifre. Per esempio i numeri 4666777 e 6767674 hanno la stessa catena:

(chain 4666777)
;-> (4666777 89 9 (271 54 41 17 50 25 29 85 89))

(chain 6767674)
;-> (6767674 89 9 (271 54 41 17 50 25 29 85 89))

Quindi tutti i numeri che hanno le stesse cifre (non considerando lo 0 perchè facciamo il quadrato di ogni cifra) hanno la stessa catena.

Inoltre, la più grande somma possibile di quadrati è creata dal numero 9999999, che vale 7^9 = 567.
Possiamo usare questo numero come dimensione di una lista che contiene tutti i valori generati dal calcolo della somma dei quadrati delle cifre per i numeri inferiori 10 milioni (questo perchè tutti gli altri numeri inferiori a 10 milioni sono solo permutazioni con una somma minore).

Prima scriviamo una funzione che restituisce true se la catena di un dato numero termina con 89, altrimenti restituisce nil:

(define (end89? n)
  (local (sum x)
    (while (and (!= n 1) (!= n 89))
      (setq sum 0)
      (while (> n 0)
        (setq x (% n 10))
        (setq sum (+ sum (* x x)))
        (setq n (/ n 10))
      )
      (setq n sum)
    )
    (= n 89)))

(end89? 1)
;-> nil
(end89? 89)
;-> true
(end89? 4666777)
;-> true
(end89? 6767674)
;-> true

Poi possiamo creare la lista che contiene le somme:

(setq lst-sum '(0))
(for (i 1 567) (push (end89? i) lst-sum -1))

I valori delle somme non coprono tutti i numeri da 1 a 567:

(count '(true) lst-sum)
;-> 486

Adesso dobbiamo sapere quante volte un dato insieme di cifre può verificarsi sotto i 10 milioni. Questo è semplicemente il fattoriale del numero totale di elementi (cioè quante cifre, 7) diviso per il prodotto dei fattoriali dei conteggi degli elementi unici (quante volte compare ogni cifra):

(numero-elementi-gruppo = 7! / (c1! * c2! * ... * c9!))

Per esempio, per il numero 4666777 otteniamo che il numero di elementi vale (coefficiente multinomiale):

numero-elementi-gruppo(4666777) = 7! / (1! * 3! * 3!) = 140

Vediamo quante combinazioni di cifre univoche ci sono da 1 a 9999999 (combinazioni con ripetizione):

(define (comb-rep k lst)
  (cond ((zero? k 0) '(()))
        ((null? lst) '())
        (true
         (append (map (lambda (x) (cons (first lst) x))
                      (comb-rep (- k 1) lst))
                 (comb-rep k (rest lst))))))

(setq numeri (comb-rep 7 '(1 2 3 4 5 6 7 8 9 0)))
(length numeri)
;-> 11440

Esistono solo 11.440 combinazioni di cifre univoche comprese tra 1 e 9999999.

Quindi dobbiamo trovare un modo per calcolare la catena solo di questi numeri.
Potremmo utilizzare 9 cicli "for" per generare numeri del tipo "abcdefg" e quando le cifre soddisfano a≤b≤c≤d≤e≤f≤g, allora controllare la somma nella lista delle somme (lst-sum). Se la catena termina con 89, dobbiamo aggiungere tutte le possibili combinazioni (calcolate con il coefficiente multinomiale) al risultato.

Per velocizzare i calcoli utilizziamo una lista precalcolata per i fattoriali da 0 a 7:

fact = (1 1 2 6 24 120 720 5040)

Oppure possiamo utilizzare direttamente i numeri della lista "numeri", verificare se la sua catena di ogni termina con 89 ed eventualmente aggiungere al totale il numero degli elementi del suo gruppo (cioè tutti i numeri che conducono a 89) calcolando il relativo coefficiente multinomiale.

Proviamo a scrivere una funzione con quest'ultimo algoritmo.

Funzione che converte una lista in un intero:

(define (lst-int lst)
  (let (num 0)
    (dolist (el lst) (setq num (+ el (* num 10))))))

Funzione finale:

(define (e092)
  (local (fact numeri num out)
    (setq out 0)
    (setq fact '(1 1 2 6 24 120 720 5040))
    ; creazione dei 11440 numeri univoci
    (setq numeri (comb-rep 7 '(1 2 3 4 5 6 7 8 9 0)))
    ;(setq numeri (map lst-int (comb-rep 7 '(1 2 3 4 5 6 7 8 9 0))))
    (dolist (el numeri)
      ;(println $idx { } el)
      (setq num (lst-int el))
      ; se la catena del numero corrente finisce con 89
      (if (and (> num 0) (end89? num))
          ; allora aggiorniamo la somma totale
          ; sommando il coefficiente multinomiale
                 ; contiamo la molteplicità delle cifre del numero
          (letn ((conta (count '(1 2 3 4 5 6 7 8 9 0) el))
                 ; e poi calcoliamo il coefficiente multinomiale
                 (coeff (/ (fact 7) (apply * (map (fn(x) (fact x)) conta)))))
                 ; aggiorniamo il totale
                 (setq out (+ out coeff))
          )
      )
    )
    out))

(e092)
;-> 8581146

(time (e092))
;-> 116.715

La prima soluzione processa 9999999 di numeri, mentre la seconda soluzione processa 11440 numeri. Il rapporto vale: (/ 9999999 11440) = 874.
Per i tempi di esecuzione abbiamo il seguente rapporto: (/ 51582 116) = 444, cioè la seconda funzione è circa 450 volte più veloce.
----------------------------------------------------------------------------


===========
Problema 93
===========

Espressioni aritmetiche

Utilizzando ciascuna delle cifre dell'insieme, {1, 2, 3, 4}, esattamente una volta, e facendo uso delle quattro operazioni aritmetiche (+, -, *, /) e parentesi, è possibile formare diversi target interi positivi.

Per esempio,

8 = (4 * (1 + 3)) / 2
14 = 4 * (3 + 1/2)
19 = 4 * (2 + 3) - 1
36 = 3 * 4 * (2 + 1)

Si noti che le concatenazioni delle cifre, come 12 + 34, non sono consentite.

Utilizzando l'insieme, {1, 2, 3, 4}, è possibile ottenere trentuno numeri target diversi di cui 36 è il massimo, e ciascuno dei numeri da 1 a 28 può essere ottenuto prima di incontrare il primo numero non esprimibile.

Trova l'insieme di quattro cifre distinte, a < b < c < d, per il quale è possibile ottenere l'insieme più lungo di interi positivi consecutivi, da 1 a n, dando la tua risposta come una stringa: abcd.
============================================================================

Funzione che valuta le espressioni (rpn):

(define (eval-rpn lst)
  (local (stack a b op operator)
    (setq stack '())
    (setq operator '(+ - * / add sub mul div))
    (dolist (el lst)
      (cond ((number? el)
             (push el stack))
            (true
             (cond ((find el operator)
                    (setq a (pop stack))
                    (setq b (pop stack))
                    (setq op (eval el))
                    ; ritorna 0 se si divide per zero
                    (if (and (zero? a) (or (= op div) (= op /)))
                        (push 0 stack )
                        (push (op b a) stack)))
                   (true (println "operator error:" el))))))
    (pop stack)))

Funzione che calcola le combinazioni:

(define (comb k lst)
  (cond ((zero? k)   '(()))
        ((null? lst) '())
        (true
          (append (map (lambda (k-1) (cons (first lst) k-1))
                       (comb (- k 1) (rest lst)))
                  (comb k (rest lst))))))

(setq cifre '(1 2 3 4 5 6 7 8 9))

(setq digit4 (comb 4 cifre))

(length digit4)
;-> 126

(sort digit4)
;-> ((1 2 3 4) (1 2 3 5) (1 2 3 6) (1 2 3 7) (1 2 3 8) (1 2 3 9)
;->  (1 2 4 5) (1 2 4 6) (1 2 4 7) (1 2 4 8) (1 2 4 9) (1 2 5 6)
;->  ...
;->  (4 7 8 9) (5 6 7 8) (5 6 7 9) (5 6 8 9) (5 7 8 9) (6 7 8 9))

Adesso occorre calcolare le permutazioni di ogni elemento di digit4:

(define (perm lst)
  (local (i indici out)
    (setq indici (dup 0 (length lst)))
    (setq i 0)
    ; aggiungiamo la lista iniziale alla soluzione
    (setq out (list lst))
    (while (< i (length lst))
      (if (< (indici i) i)
          (begin
            (if (zero? (% i 2))
              (swap (lst 0) (lst i))
              (swap (lst (indici i)) (lst i))
            )
            ;(println lst);
            (push lst out -1)
            (++ (indici i))
            (setq i 0)
          )
          (begin
            (setf (indici i) 0)
            (++ i)
          )
       )
    )
    out))

(setq p1234 (perm '(1 2 3 4)))
;-> ((1 2 3 4) (2 1 3 4) (3 1 2 4) (1 3 2 4) (2 3 1 4) (3 2 1 4)
;->  (4 2 1 3) (2 4 1 3) (1 4 2 3) (4 1 2 3) (2 1 4 3) (1 2 4 3)
;->  (1 3 4 2) (3 1 4 2) (4 1 3 2) (1 4 3 2) (3 4 1 2) (4 3 1 2)
;->  (4 3 2 1) (3 4 2 1) (2 4 3 1) (4 2 3 1) (3 2 4 1) (2 3 4 1))

(length (perm '(1 2 3 4)))
;-> 24

(* 24 126)
;-> 3024 liste di numeri da calcolare

Vediamo la lista delle operazioni:

Permutazioni con ripetizione (n^k):

(define (perm-rep k lst)
  (if (zero? k) '(())
      (flat (map (lambda (p) (map (lambda (e) (cons e p)) lst))
                         (perm-rep (- k 1) lst)) 1)))

(setq op '(add sub mul div))

Lista delle operazioni possibili (n^k) = 4^3 = 64:

(setq operats (perm-rep 3 op))
;-> ((add add add) (sub add add) (mul add add) (div add add)
;->  (add sub add) (sub sub add) (mul sub add) (div sub add)
;->  ...
;->  (add div div) (sub div div) (mul div div) (div div div))

(length operats)
;-> 64
(pow 4 3)
;-> 64

(* 3024 64)
;-> 193536 espressioni da valutare

Calcoliamo le sequenze:

Funzione che calcola la sequenza massima (1,n) di una lista:

(define (maxseq lst)
  (let (out 0)
    (setq (lst 0 0) 0)
    (dolist (el lst)
      (if (= el $idx) (setq out $idx)))
    out))

(setq valmaxseq 0)
(setq valmaxseq-numbers '())
(setq res4 '())
(setq res '())
(setq alld4 '())
(dolist (d4 digit4)
  (setq alld4 (perm d4))
  (setq res4 '())
  ;(println d4)
  ;(read-line)
  (dolist (numeri alld4)
    (dolist (el operats)
      ; crea e valuta espressione (es. (1 3 2 4 add mul mul))
      (setq val (abs (eval-rpn (append numeri el))))
      ;(println val { } numeri)
      ;(read-line)
      (if (= val (int val))
        (push val res4)
      )
    )
  )
  (setq res4 (unique (sort res4)))
  ;(println res4)
  ;(read-line)
  (setq seqval (maxseq res4))
  ;(println seqval { } d4)
  ;(read-line)
  (if (> seqval valmaxseq)
      (setq valmaxseq seqval valmaxseq-numbers d4)
  )
)
(println (list valmaxseq valmaxseq-numbers))
;-> (51 (1 2 5 8))

Adesso possiamo scrivere la funzione finale:

(define (e093)
  (local (cifre digit4 op)
    (setq cifre '(1 2 3 4 5 6 7 8 9))
    (setq digit4 (comb 4 cifre))
    (sort digit4)
    (setq op '(add sub mul div))
    (setq operats (perm-rep 3 op))
    (setq valmaxseq 0)
    (setq valmaxseq-numbers '())
    (setq res4 '())
    (setq res '())
    (setq alld4 '())
    (dolist (d4 digit4)
      (setq alld4 (perm d4))
      (setq res4 '())
      ;(println d4)
      ;(read-line)
      (dolist (numeri alld4)
        (dolist (el operats)
          ; crea e valuta espressione (es. (1 3 2 4 add mul mul))
          (setq val (abs (eval-rpn (append numeri el))))
          ;(println val { } numeri)
          ;(read-line)
          (if (= val (int val))
            (push val res4)
          )
        )
      )
      (setq res4 (unique (sort res4)))
      ;(println res4)
      ;(read-line)
      (setq seqval (maxseq res4))
      ;(println seqval { } d4)
      ;(read-line)
      (if (> seqval valmaxseq)
          (setq valmaxseq seqval valmaxseq-numbers d4)
      )
    )
  (list valmaxseq valmaxseq-numbers)
  (join (map string valmaxseq-numbers))))

(e093)
;-> "1258"

(time (e093))
;-> 389.985
----------------------------------------------------------------------------


===========
Problema 94
===========

Triangoli quasi equilateri

È facilmente dimostrato che non esiste alcun triangolo equilatero con lati di lunghezza intera e area intera. Tuttavia, il triangolo quasi equilatero 5-5-6 ha un'area di 12 unità quadrate.

Definiremo un triangolo quasi equilatero come un triangolo per cui due lati sono uguali e il terzo differisce di non più di un'unità.

Trova la somma dei perimetri di tutti i triangoli quasi equilateri con lunghezze laterali e area integrali e i cui perimetri non superano un miliardo (1.000.000.000).
============================================================================

Possiamo risolvere il problema utilizzando le triple pitagoriche primitive o l'equazione di Pell.

(define (e094)
  (local (a b c m n limite out)
  ; a = m^2 - n^2
  ; b = 2*m*n
  ; c = m^2 + n^2
  ; a + b + c = 2*m^2 + 2*m*n = 2*m*(m + n)
  ; quindi m < sqrt((a+b+c)/2)
  (setq limite (int (sqrt (div 1e9 2))))
  ;(setq limite 12000)
  (setq out 0)
  (for (n 1 limite)
    (for (m (+ n 1) limite)
      ; test tripla primitiva
      (if (and (= (gcd m n) 1) (!= (% (- m n) 2) 0))
          (begin
            ; genera una tripla pitagorica (metodo di euclide)
            (setq a (- (* m m) (* n n)))
            (setq b (* 2 m n))
            (setq c (+ (* m m) (* n n)))
            ;(println "--> " a { } b { } c)
            ;(read-line)
            ; controllo triangolo quasi equilatero
            (cond ((<= (+ a b c) 1e9)
                   (if (= (abs (- (* 2 a) c)) 1)
                       (setq out (+ out (+ (* 2 c) (* 2 a)))))
                   (if (= (abs (- (* 2 b) c)) 1)
                       (setq out (+ out (+ (* 2 c) (* 2 b))))))
            )
          )
      )
    )
  )
  out))

(e094)
;-> 518408346

(time (e094))
;-> 93751.845

Ponendo il limite uguale a 12000 otteniamo il seguente risultato:

(e094)
;-> 518408346

(time (e094))
;-> 28946.177

Con un altro algoritmo (intelligent brute-force):

(define-macro (psetq)
  (let ((_var '()) (_ex '()))
    (for (i 0 (- (length (args 1)) 1))
      (setq _ex (expand (args 1 i) (args 0 0)))
      (for (j 1 (- (length (args 0)) 1))
        (setq _ex (expand _ex (args 0 j))))
      (push _ex _var -1))
    (dolist (el _var)
      (set (args 0 $idx) (eval el)))))

(define (e094)
  (local (lato1 lato2 perim k out)
    (setq lato1 1 lato2 1 perim 0 k 1 out 0)
    (while (< perim 1e9)
      (psetq (lato1 lato2 k) (lato2 (+ (* 4 lato2) (* 2 k) (- lato1)) (- k)))
      (setq out (+ out perim))
      (setq perim (- (* 3 lato2) k))
    )
    out))

(e094)
;-> 518408346

(time (e094))
;-> 0
----------------------------------------------------------------------------


===========
Problema 95
===========

Catene amichevoli

I divisori propri di un numero sono tutti i divisori escluso il numero stesso. Ad esempio, i divisori propri di 28 sono 1, 2, 4, 7 e 14. Poiché la somma di questi divisori è uguale a 28, lo chiamiamo numero perfetto.

È interessante notare che la somma dei divisori propri di 220 è 284 e la somma dei divisori propri di 284 è 220, formando una catena di due numeri. Per questo motivo, 220 e 284 sono chiamati una coppia amichevole.

Forse meno conosciute sono le catene più lunghe. Ad esempio, iniziando con 12496, formiamo una catena di cinque numeri:

        12496 → 14288 → 15472 → 14536 → 14264 (→ 12496 → ...)

Poiché questa catena ritorna al punto di partenza, viene chiamata catena amichevole.

Trova il membro più piccolo della catena amichevole più lunga con nessun elemento superiore a un milione.
============================================================================

(define (e095)
  (local (limite dp lcmax catena num tmp idx out)
    (setq limite 1000000)
    (setq dp (array limite '(1)))
    (for (i 2 (- (/ limite 2) 1))
      (for (j (* 2 i) (- limite 1) i)
        (setf (dp j) (+ (dp j) i))))
    (setq lcmax 0)
    (for (i 2 (- limite 1))
      (setq num i)
      (setq catena '())
      (while (< (dp num) limite)
        (setq tmp (dp num))
        (setf (dp num) (+ limite 1))
        (setq num tmp)
        (cond ((if (find num catena))
               (setq idx (find num catena))
               (if (> (length (slice catena idx)) lcmax)
                   (setq lcmax (length (slice catena idx))
                        out (apply min (slice catena idx)))))
              (true
               (push num catena -1))
        )
      )
    )
    out))

(e095)
;-> 14316

(time (e095))
;-> 1824.12
----------------------------------------------------------------------------


===========
Problema 96
===========

Su Doku

Su Doku (giapponese che significa luogo del numero) è il nome di un concetto di puzzle popolare. La sua origine non è chiara, ma il merito viene attribuito a Leonhard Euler che ha inventato un puzzle simile e molto più difficile, chiamato Quadrati Latini. L'obiettivo dei puzzle di Su Doku è quello di sostituire gli spazi vuoti (o zeri) in una griglia 9 per 9 in modo tale che ogni riga, colonna e regione 3x3 contenga ciascuna delle cifre da 1 a 9. Di seguito è riportato un esempio di una tipica griglia di puzzle iniziale e della sua griglia di soluzione.

  0 0 3 | 0 2 0 | 6 0 0          4 8 3 | 9 2 1 | 6 5 7
  9 0 0 | 3 0 5 | 0 0 1          9 0 0 | 3 4 5 | 8 2 1
  0 0 1 | 8 0 6 | 4 0 0          2 5 1 | 8 7 6 | 4 9 3
  ------+-------+------          ------+-------+------
  0 0 8 | 1 0 2 | 9 0 0          5 4 8 | 1 3 2 | 9 7 6
  7 0 0 | 0 0 0 | 0 0 8          7 2 9 | 5 6 4 | 1 3 8
  0 0 6 | 7 0 8 | 2 0 0          1 3 6 | 7 9 8 | 2 4 5
  ------+-------+------          ------+-------+------
  0 0 2 | 6 0 9 | 5 0 0          3 7 2 | 6 8 9 | 5 1 4
  8 0 0 | 2 0 3 | 0 0 9          8 1 4 | 2 5 3 | 7 6 9
  0 0 5 | 0 1 0 | 3 0 0          6 9 5 | 4 1 7 | 3 8 2

Un puzzle di Su Doku ben costruito ha una soluzione unica e può essere risolto dalla logica, anche se potrebbe essere necessario impiegare metodi di "indovinare e testare" per eliminare le opzioni (questo è un'opinione molto contestata). La complessità della ricerca determina la difficoltà del puzzle. L'esempio sopra è considerato facile perché può essere risolto con una semplice deduzione diretta.

Il file di testo 6K, sudoku.txt (e096.lsp), contiene cinquanta diversi puzzle di Su Doku che variano in difficoltà, ma tutti con soluzioni uniche (il primo puzzle nel file è l'esempio sopra).

Risolvendo tutti e cinquanta i puzzle, trova la somma di tutti i numeri a 3 cifre che si trovano nell'angolo in alto a sinistra di ogni griglia della soluzione. Ad esempio, 483 è il numero di 3 cifre che si trova nell'angolo in alto a sinistra della griglia della soluzione sopra.
============================================================================

(define (isSafe board row col num)
  (local (safe regionRowStart regionColStart)
    (setq safe true)
    ; numero unico sulla riga (row-clash)
    (for (d 0 (- (length board) 1))
      ; Se il numero che stiamo provando
      ; è presente in quella riga
      ; restituire falso (nil)
      (if (= (board row d) num)
          (setq safe nil)
      )
    )
    (if safe (begin
    ; numero unico sulla colonna (column-clash)
    (for (r 0 (- (length board) 1))
      ; Se il numero che stiamo provando
      ; è presente in quella colonna
      ; restituire falso (nil)
      (if (= (board r col) num)
          (setq safe nil)
      )
    )))
    (if safe (begin
    ; numero unico in ogni regione 3x3 (region-clash)
    (setq regionRowStart (- row (% row 3)))
    (setq regionColStart (- col (% col 3)))
    (for (r regionRowStart (+ regionRowStart 2))
          (for (d regionColStart (+ regionColStart 2))
        (if (= (board r d) num)
            (setq safe nil)
        )
      )
    )))
    ; se non c'è conflitto, allora è sicuro
    safe
  )
)

(define (solveSudoku board)
(catch
  (local (i j row col isEmpty solved)
    (setq row -1 col -1)
    (setq isEmpty true)
    (setq i 0 j 0)
    (while (and isEmpty (< i (length board)))
      (while (and isEmpty (< j (length board)))
        (if (= (board i j) 0)
            ; Esistono ancora dei valori nulli nel puzzle
            (setq row i col j isEmpty nil)
        )
        (++ j)
      )
      (setq j 0)
      (++ i)
    )
    ; stampa la soluzione
    ;(if isEmpty (begin (println board) (throw true)))
    ; salva la soluzione su una variabile globale
    (if isEmpty (begin (setq *sol* board) (throw true)))
    ;else
    (for (num 1 (length board))
        (cond ((isSafe board row col num)
                 (setf (board row col) num)
                 (if (solveSudoku board) (throw true))
                 (setf (board row col) 0)
              )
        )
    )
    nil
  )
))

(define (e096)
  (local (out)
    (setq out 0)
    (load "e096.lsp")
    (setq base "(solveSudoku gridX)")
    (for (i 1 50)
      (setq expr (replace "X" (copy base) (string i)))
      (setq out (+ out (* 100 (*sol* 0 0)) (* 10 (*sol* 0 1)) (*sol* 0 2)))
      ;(println expr)
      (eval-string expr)
      ;(println i { } out)
    )
    out
  )
)

(e096)
;-> 24702

(time (e096))
;-> 27084.701
----------------------------------------------------------------------------


===========
Problema 97
===========

Il più grande primo non-Mersenne

Il primo numero primo noto che supera il milione di cifre è stato scoperto nel 1999 ed è un numero primo di Mersenne della forma 2 ^ 6972593-1. Contiene esattamente 2.098.960 cifre. Successivamente sono stati trovati altri numeri primi di Mersenne, della forma (2^p − 1), che contengono più cifre.

Tuttavia, nel 2004 è stato trovato un enorme numero primo non Mersenne che contiene 2.357.207 cifre: 28433 × 2^7830457 + 1.

Trova le ultime dieci cifre di questo numero primo.
============================================================================

Le ultime 10 cifre di un numero n si ottengono applicando l'operatore modulo: (n % 10000000000).
Il problema è come calcolare velocemente 2^7830457. Cercando di risolvere direttamente l'espressione,  newLISP impiega un tempo lunghissimo. Infatti:

Funzione per calcolare la potenza (intera) di un numero intero:

(define (** num power)
    (let (out 1L)
        (dotimes (i power)
            (setq out (* out num)))))

Scriviamo la funzione:

(define (e097) (% (+ (* (** 2L 7830456L) 28433) 1) 10000000000L))

Attenzione, la seguente funzione impiega moltissimo tempo:

(e097)

Abbiamo visto che per estrapolare le ultime 10 cifre occorre calcolare (n mod 10000000000). Poichè per  l'operazione modulo (mod) vale la proprietà distributiva:

a*b mod n = ((a mod n)*(b mod n)) mod n

possiamo calcolare 2^7830457 utilizzando la moltiplicazione in un ciclo e utilizzando il modulo dopo ogni moltiplicazione. In questo modo non abbiamo neanche bisogno di utilizzare i big-integer:

(define (e097)
  (let (val 2L)
    (for (i 1 7830456)
      (setq val (% (* 2L val) 10000000000L))
    )
    (setq val (* val 28433L))
    (setq val (+ val 1L))
    (setq val (% val 10000000000L))))

(e097)
;-> 8739992577L

(define (e097)
  (let (val 2)
    (for (i 1 7830456)
      (setq val (% (* 2 val) 10000000000))
    )
    (setq val (* val 28433))
    (setq val (+ val 1))
    (setq val (% val 10000000000))))

(e097)
;-> 8739992577

Inoltre il tempo di esecuzione è accettabile:

(time (e097))
;-> 497.573
----------------------------------------------------------------------------


===========
Problema 98
===========

Anagrammi quadrati

Sostituendo ciascuna delle lettere della parola CARE con 1, 2, 9 e 6 rispettivamente, formiamo un numero quadrato: 1296 = 36^2. Ciò che è notevole è che, utilizzando le stesse sostituzioni digitali, anche l'anagramma RACE forma un numero quadrato: 9216 = 96^2. Chiameremo CARE (e RACE) una coppia di parole anagrammate quadrate e specificheremo inoltre che gli zeri iniziali non sono consentiti, né una lettera diversa può avere lo stesso valore digitale di un'altra lettera.

Utilizzando "words.txt", un file di testo da 16 KB contenente quasi duemila parole inglesi comuni, trova tutte le coppie di parole anagrammi quadrate (una parola palindromica NON è considerata anagramma di se stesso).

Qual'è il numero quadrato più grande formato da un membro di una tale coppia?

NOTA: Tutti gli anagrammi formati devono essere contenuti nel file di testo specificato.
============================================================================

(load "e098.lsp")
(length words)
;-> 1786

(words 7)
;-> academic

Definiamo una funzione che ordina le word:

(define (sortword str)
  (list (length str) (join (sort (explode str))) str))

(sortword (words 7))
;-> (8 "AACCDEIM" "ACADEMIC")

(setq ord-words (sort (map sortword words)))
;-> ((1 "A" "A") (1 "I" "I")
;->  (2 "AN" "AN") (2 "AS" "AS")
;->  ...
;->  (13 "AEGIIINNOSTTV" "INVESTIGATION")
;->  (14 "AACCCEHIIRRSTT" "CHARACTERISTIC")
;->  (14 "AADIIIMNNORSTT" "ADMINISTRATION")
;->  (14 "AEEEEINPRRSTTV" "REPRESENTATIVE")
;->  (14 "AEEEINNOPRRSTT" "REPRESENTATION")
;->  (14 "AEEIINNOPRRTTT" "INTERPRETATION")
;->  (14 "BEIIILNOPRSSTY" "RESPONSIBILITY"))

(length ord-words)
;-> 1786

Struttura elemento della lista ord-words:

(lunghezza-word sorted-word word)

Due parole sono anagramma una dell'altra se hanno la stessa sorted-word (quindi anche la lunghezza è la stessa.

Poichè le word palindrome non devono essere considerate possiamo eliminare tutte le parole con lunghezza minore di 3.

(setq ord-words (filter (fn(x) (> (first x) 2)) ord-words))
;-> ((3 "ABD" "BAD") (3 "ABG" "BAG") (3 "ABR" "BAR") (3 "ACN" "CAN")
;->  (3 "ACR" "CAR") (3 "ACT" "ACT") (3 "ACT" "CAT") (3 "ADD" "ADD")
;->  ...
;->  (14 "AEEIINNOPRRTTT" "INTERPRETATION")
;->  (14 "BEIIILNOPRSSTY" "RESPONSIBILITY"))

(length ord-words)
;-> 1761

Cerca le word che sono anagramma:

(setq ana-words '())
(setq len-w 0)
(setq ord-w "")
(setq w-w   "")
(dolist (el ord-words)
  (if (and (= (el 0) len-w) (= (el 1) ord-w))
      (push (list w-w (el 2)) ana-words -1)
  )
  (setq len-w (el 0))
  (setq ord-w (el 1))
  (setq w-w   (el 2))
)

ana-words
;-> (("ACT" "CAT") ("EAT" "TEA") ("DOG" "GOD") ("HOW" "WHO") ("ITS" "SIT")
;->  ("NOW" "OWN") ("CARE" "RACE") ("DEAL" "LEAD") ("HATE" "HEAT")
;->  ("MALE" "MEAL") ("MEAN" "NAME") ("EARN" "NEAR") ("RATE" "TEAR")
;->  ("EAST" "SEAT") ("FILE" "LIFE") ("ITEM" "TIME") ("NOTE" "TONE")
;->  ("SURE" "USER") ("FORM" "FROM") ("SIGN" "SING") ("SHUT" "THUS")
;->  ("POST" "SPOT") ("SPOT" "STOP") ("BOARD" "BROAD") ("PHASE" "SHAPE")
;->  ("EARTH" "HEART") ("ARISE" "RAISE") ("LEAST" "STEAL") ("SHEET" "THESE")
;->  ("QUIET" "QUITE") ("NIGHT" "THING") ("THROW" "WORTH") ("SHOUT" "SOUTH")
;->  ("DANGER" "GARDEN") ("CREDIT" "DIRECT") ("CENTRE" "RECENT")
;->  ("EXCEPT" "EXPECT") ("COURSE" "SOURCE") ("FORMER" "REFORM")
;->  ("IGNORE" "REGION") ("CREATION" "REACTION") ("INTRODUCE" "REDUCTION"))

(length ana-words)
;-> 42

Vediamo se ci sono anagrammi palindromi:

(dolist (el ana-words) (if (= (el 0) (reverse (el 1))) (println el)))
;-> ("DOG" "GOD")

Lasciamolo stare...se non è la soluzione finale.

Adesso dovremmo provare tutte le combinazioni delle cifre (1..9) per ogni coppia di word. Questo è un calcolo molto oneroso e dobbiamo evitarlo.

Se proviamo tutte le sostituzioni lettera per cifra, allora stiamo cercando coppie di quadrati con queste proprietà:

1) hanno la stessa lunghezza

2) hanno le stesse cifre con il numero di occorrenze della stringa di input.

Quindi è più veloce trovare tutte queste coppie di quadrati.

(setq squares (map (fn(x) (* x x)) (sequence 1 50)))
;-> (1 4 9 16 25 36 49 64 81 100 121 144 169 196 225 256 289 324 361 400 441 484 529
;->  576 625 676 729 784 841 900 961 1024 1089 1156 1225 1296 1369 1444 1521 1600 1681
;->  1764 1849 1936 2025 2116 2209 2304 2401 2500)

(define (number-stamp num)
  (let ((ar (array 10 '(0))) (out 0))
    ; fill array with the count of digits
    (while (> num 0)
      (++ (ar (% num 10)))
      (setq num (/ num 10))
    )
    ; create output number from array
    (for (i 9 0)
      (setq out (+ (ar i) (* out 10)))
    )
    out))

(setq squares-stamp (sort (map (fn(x) (list (number-stamp x) x)) squares)))
;-> ((10 1) (12 100) (120 121) (10000 4) (10002 400) (10111 1024)
;->  (10111 2401) (11100 324) (11101 2304) (20010 144) (20010 441)
;->  (30010 1444) (100100 25) (100102 2500) (100120 1521) (100200 225)
;->  (100201 2025) (100210 1225) (1000010 16) (1000012 1600) (1000120 2116)
;->  (1001000 36) (1001010 361) (1010000 64) (1100020 1156) (1100100 256)
;->  (1100100 625) (11010010 1764) (11100000 576) (12000000 676)
;->  (100000010 81) (100010010 841) (100020000 484) (101000020 1681)
;->  (110010000 784) (1000000000 9) (1000000002 900) (1000000201 2209)
;->  (1000010000 49) (1000100100 529) (1001000010 169) (1001000010 196)
;->  (1001000010 961) (1001000110 1296) (1001001010 1369) (1001001010 1936)
;->  (1010000100 729) (1100000011 1089) (1100000100 289) (1100010010 1849))

Cerchiamo le coppie che hanno lo stesso "stampo":

(setq squares-pair '())
(setq stamp-sq 0)
(setq num-sq 0)
(dolist (el squares-stamp)
  (if (= (el 0) stamp-sq)
      (push (list (el 0) num-sq (el 1)) squares-pair -1)
  )
  (setq stamp-sq (el 0))
  (setq num-sq (el 1))
)

squares-pair
;-> ((10111 1024 2401) (20010 144 441) (1100100 256 625)
;->  (1001000010 169 196) (1001000010 196 961) (1001001010 1369 1936))

Adesso dobbiamo eliminare quelle che hanno cifre doppie (es. la cifra 4 nella coppia 144 e 441), cioè quelle che hanno una (o più) cifra con valore maggiore di 1 nello "stamp" (es. la cifra 2 nell'elemento (20010 144 441).

(define (doppie stamp)
  (if (find "2|3|4|5|6|7|8|9" (string stamp) 0) true nil))

(setq sq-pair '())
(dolist (el squares-pair)
  (if (not (doppie (el 0)))
      (push el sq-pair -1)))

sq-pair
;-> ((10111 1024 2401) (1100100 256 625) (1001000010 169 196)
;->  (1001000010 196 961) (1001001010 1369 1936))

Ma fino a quanto dobbiamo calcolare i quadrati?

La word più lunga ha 9 caratteri ("INTRODUCE" "REDUCTION"), quindi il quadrato più grande non può essere maggiore di 987654321.

(sqrt 987654321)
;-> 31426.96805293187

Quindi dobbiamo calcolare il quadrato dei primi 31476 numeri.

Ripetiamo il calcolo:

(setq max-sq 31426)
(setq squares (map (fn(x) (* x x)) (sequence 1 31426)))
(setq squares-stamp (sort (map (fn(x) (list (number-stamp x) x)) squares)))
(setq squares-pair '())
(setq stamp-sq 0)
(setq num-sq 0)
(dolist (el squares-stamp)
  (if (= (el 0) stamp-sq)
      (push (list (el 0) num-sq (el 1)) squares-pair -1)
  )
  (setq stamp-sq (el 0))
  (setq num-sq (el 1))
)
(setq sq-pair '())
(dolist (el squares-pair)
  (if (not (doppie (el 0)))
      (push (list (el 1) (el 2)) sq-pair -1)))

(length sq-pair)
;-> 300

(sort sq-pair)
;-> ((169 196) (196 961) (256 625)
;->  (1024 2401) (1089 9801) (1296 2916)
;->  (1369 1936) (1764 4761) (2916 9216)
;->  (4096 9604) (12769 96721)
;->  (16384 31684) (17689 18769) (18769 78961)
;->  (20736 30276) (21904 41209) (23104 32041)
;->  (23409 39204) (23716 32761) (29584 54289)
;->  (31684 36481) (32761 72361) (34596 45369)
;->  ...
;->  (798401536 803495716)
;->  (825470361 853107264)
;->  (842973156 847159236)
;->  (847159236 923187456))

(sqrt 847159236)
;-> 29106
(sqrt 923187456)
;-> 30384

Quindi dobbiamo confrontare queste 300 coppie di quadrati della lista "sq-pair" con le 42 coppie di word della lista ana-words.
Il confronto completo va effettuato solo con le coppie di word che hanno la stessa lunghezza delle coppie dei quadrati.

Definiamo una funzione che effettua il check:

(define (square? n)
  (let (v (+ (sqrt n 0.5)))
    (= n (* v v))))

(define (int-lst num)
  (let (out '())
    (while (!= num 0)
      (push (% num 10) out)
      (setq num (/ num 10))) out))

(define (lst-int lst)
  (let (num 0)
    (dolist (el lst) (setq num (+ el (* num 10))))))

(setq ww '("CARE" "RACE"))
(setq qq '(1296 9216))

(setq mappa (map list (explode (ww 0)) (int-lst (qq 0))))
;-> (("C" 1) ("A" 2) ("R" 9) ("E" 6))

(setq new-num (lst-int (map (fn(x) (lookup x mappa)) (explode (ww 1)))))
;-> 9216

(define (check w-pair q-pair)
  (setq out nil)
  (cond ((!= (length (w-pair 0)) (length (q-pair 0)))
         (setq out nil))
        (true
          (setq mappa (map list (explode (w-pair 0)) (int-lst (qq 0))))
          (setq new-num (lst-int (map (fn(x) (lookup x mappa)) (explode (w-pair 1)))))
          (if (= new-num (q-pair 1)) 
              (setq out true)
          )
        )
  )
  out)

(check ww qq)
;-> true

Adesso possiamo confrontare la liste degli anagrammi con la lista dei quadrati:

(setq valmax 0)
(dolist (ww ana-words)
  (dolist (qq sq-pair)
    (cond ((check ww qq)
           (if (> (qq 0) valmax) 
             (begin
               (setq valmax (qq 0))
               (println ww { } qq { } valmax)
             ))
           (if (> (qq 1) valmax) 
               (begin
                 (setq valmax (qq 1))
                 (println ww { } qq { } valmax)
               )))
    )
  )
)
;-> ("EAT" "TEA") (256 625) 256
;-> ("EAT" "TEA") (256 625) 625
;-> ("NOW" "OWN") (196 961) 961
;-> ("CARE" "RACE") (1296 2916) 1296
;-> ("CARE" "RACE") (1296 2916) 2916
;-> ("DEAL" "LEAD") (1764 4761) 4761
;-> ("RATE" "TEAR") (4096 9604) 9604
;-> ("BOARD" "BROAD") (17689 18769) 17689
;-> ("BOARD" "BROAD") (17689 18769) 18769

valmax
;-> 18769

Nota: questo metodo trova la soluzione esatta, ma non trova l'esempio citato dal problema (CARE RACE 1296 9216) perchè quando abbiamo cercato le coppie che hanno lo stesso "stampo" non abbiamo considerato l'ipotesi che possano esistere delle triple con lo stesso stampo, in questo caso la tripla: (1296 = 36^2, 2916 = 54, 9216 = 96^2).

Scriviamo la funzione completa:

(load "e098.lsp")

(define (sortword str)
  (list (length str) (join (sort (explode str))) str))

(define (number-stamp num)
  (let ((ar (array 10 '(0))) (out 0))
    ; fill array with the count of digits
    (while (> num 0)
      (++ (ar (% num 10)))
      (setq num (/ num 10))
    )
    ; create output number from array
    (for (i 9 0)
      (setq out (+ (ar i) (* out 10)))
    )
    out))

(define (doppie stamp)
  (if (find "2|3|4|5|6|7|8|9" (string stamp) 0) true nil))
  
(define (square? n)
  (let (v (+ (sqrt n 0.5)))
    (= n (* v v))))

(define (int-lst num)
  (let (out '())
    (while (!= num 0)
      (push (% num 10) out)
      (setq num (/ num 10))) out))

(define (lst-int lst)
  (let (num 0)
    (dolist (el lst) (setq num (+ el (* num 10))))))

(define (check w-pair q-pair)
  (setq out nil)
  (cond ((!= (length (w-pair 0)) (length (q-pair 0)))
         (setq out nil))
        (true
          (setq mappa (map list (explode (w-pair 0)) (int-lst (qq 0))))
          (setq new-num (lst-int (map (fn(x) (lookup x mappa)) (explode (w-pair 1)))))
          (if (= new-num (q-pair 1)) 
              (setq out true)
          )
        )
  )
  out)

(define (e098)
  (local (ord-words ana-words len-w ord-w w-w 
          max-sq squares squares-stamp squares-pair
          stamp-sq num-sq sq-pair valmax)
    (setq ord-words (sort (map sortword words)))
    (setq ord-words (filter (fn(x) (> (first x) 2)) ord-words))
    (setq ana-words '())
    (setq len-w 0)
    (setq ord-w "")
    (setq w-w   "")
    (dolist (el ord-words)
      (if (and (= (el 0) len-w) (= (el 1) ord-w))
          (push (list w-w (el 2)) ana-words -1)
      )
      (setq len-w (el 0))
      (setq ord-w (el 1))
      (setq w-w   (el 2))
    )
    (setq max-sq 31426)
    (setq squares (map (fn(x) (* x x)) (sequence 1 max-sq)))
    (setq squares-stamp (sort (map (fn(x) (list (number-stamp x) x)) squares)))
    (setq squares-pair '())
    (setq stamp-sq 0)
    (setq num-sq 0)
    (dolist (el squares-stamp)
      (if (= (el 0) stamp-sq)
          (push (list (el 0) num-sq (el 1)) squares-pair -1)
      )
      (setq stamp-sq (el 0))
      (setq num-sq (el 1))
    )
    (setq sq-pair '())
    (dolist (el squares-pair)
      (if (not (doppie (el 0)))
          (push (list (el 1) (el 2)) sq-pair -1)))
    (sort sq-pair)
    (setq valmax 0)
    (dolist (ww ana-words)
      (dolist (qq sq-pair)
        (cond ((check ww qq)
              (if (> (qq 0) valmax) 
                (begin
                  (setq valmax (qq 0))
                  ;(println ww { } qq { } valmax)
                ))
              (if (> (qq 1) valmax) 
                  (begin
                    (setq valmax (qq 1))
                    ;(println ww { } qq { } valmax)
                  )))
        )
      )
    )
    valmax))

(e098)
;-> 18769

(time (e098))
;-> 130.677
----------------------------------------------------------------------------


===========
Problema 99
===========

Massimo esponenziale

Confrontare due numeri scritti in forma di indice come 2^11 e 3^7 non è difficile, poiché qualsiasi calcolatrice confermerebbe che 2^11 = 2048 < 3^7 = 2187.

Tuttavia, confermare che 632382^518061 > 519432^525806 sarebbe molto più difficile, poiché entrambi i numeri contengono oltre tre milioni di cifre.

Utilizzando "base_exp.txt", un file di testo da 22 KB contenente mille righe con una coppia base / esponente su ciascuna riga, determinare quale numero di riga ha il valore numerico maggiore.

NOTA: le prime due righe nel file rappresentano i numeri nell'esempio fornito sopra.
============================================================================

Il file "base_exp.txt" è stato trasformato nel file "e099.lsp".

Non è necessario calcolare le potenze direttamente. Possiamo usare i logaritmi utilizzando le seguenti proprietà:

1) log(x) < (log(y) implica che x < y e viceversa (perchè log(x) è una funzione crescente).
2) log(x^y) = y*log(x)

In questo modo dobbiamo trovare il massimo dei valori: y*(log(x).

Carichiamo il file che contiene la lista "lst" con tutte le coppie di numeri (x y):

(load "e099.lsp")

(define (e099)
  (let ((max-val 0) (riga 0))
    (dolist (el lst)
      (if (> (mul (last el) (log (first el))) max-val)
          (setq riga (+ 1 $idx) max-val (mul (last el) (log (first el))))))
    riga))

(e099)
;-> 709

(time (e099))
;-> 0
----------------------------------------------------------------------------


============
Problema 100
============

Probabilità stabilite

Se una scatola contiene ventuno dischi colorati, composti da quindici dischi blu e sei dischi rossi, e due dischi sono stati presi a caso, si può vedere che la probabilità di prendere due dischi blu, P (BB) = (15/21) × (14/20) = 1/2.

La successiva disposizione di questo tipo, per la quale c'è esattamente il 50% di possibilità di prendere due dischi blu a caso, è una scatola contenente ottantacinque dischi blu e trentacinque dischi rossi.

Trova la prima disposizione che contenga più di 10^12 = 1.000.000.000.000 dischi in totale, determinare il numero di dischi blu che la confezione deve contenere.
============================================================================

                                 b     (b - 1)
Bisogna risolvere l'equazione:  --- * --------- = 1/2.
                                 n     (n - 1)

Sviluppando si ottiene: 2b^2 - 2b - n^2 + n = 0 che è una equazione quadratica diofantina. Risolvendo per b otteniamo le due soluzioni: b = (2 + sqrt (4 + 8n^2 - 8n)) / 4 = (1 + sqrt (1 + 2n^2 - 2n))/2. Quindi, è sufficiente trovare valori di n tali che 2n^2 - 2n + 1 = c^2 per qualche intero c. Risolvendo per n, otteniamo n = (2 + sqrt (8c^2 - 4))/4 = (1 + sqrt(2c^2 - 1))/2. Quindi, è sufficiente trovare valori di c tali che d^2 - 2c^2 = -1 per qualche intero d. Se (d, c) è una soluzione, (3*d + 4*c, 2*d + 3*c) è la prossima soluzione. Pertanto, le soluzioni intere per c possono essere generate ricorsivamente e ciascuna può essere tradotta in una soluzione distinta per il valore di b. Questo ragionamento porta alla coppia di equazioni ricorsive:

b(k+1) = 3*b(k) + 2*n(k) - 2
n(k+1) = 4*b(k) + 3*n(k) - 3

Adesso possiamo scrivere la funzione:

(define (e100)
  (let ((n 21) (b 15) (b1 0) (n1 0))
    (while (< n 1000000000000)
      (setq b1 (+ (* 3 b) (* 2 n) (- 2)))
      (setq n1 (+ (* 4 b) (* 3 n) (- 3)))
      (setq b b1 n n1)
    )
    b))

(e100)
;-> 756872327473

(time (e100))
;-> 0
----------------------------------------------------------------------------


============
Problema 101
============

Polinomio ottimale

Se ci vengono presentati i primi k termini di una sequenza, è impossibile dire con certezza il valore del termine successivo, poiché ci sono infinite funzioni polinomiali che possono modellare la sequenza.

Ad esempio, consideriamo la sequenza dei numeri dei cubi. Questo è definito dalla funzione generatrice,
u^n = n^3: 1, 8, 27, 64, 125, 216, ...

Supponiamo che ci siano stati dati solo i primi due termini di questa sequenza. Lavorando sul principio che "semplice è il migliore" dovremmo assumere una relazione lineare e prevedere che il termine successivo sia 15 (differenza comune 7). Anche se ci venissero presentati i primi tre termini, secondo lo stesso principio di semplicità, si dovrebbe assumere una relazione quadratica.

Definiremo OP(k, n) come l'ennesimo termine della funzione generatrice polinomiale ottima per i primi k termini di una sequenza. Dovrebbe essere chiaro che OP(k, n) genererà accuratamente i termini della sequenza per n ≤ k, e potenzialmente il primo termine errato (FIT - First Incorrect Term) sarà OP(k, k + 1): in tal caso lo chiameremo un cattivo OP (BOP - Bad OP).

Come base, se ci fosse dato solo il primo termine di sequenza, sarebbe più sensato assumerlo costante, cioè, per n ≥ 2, OP(1, n) = u1.

Quindi otteniamo i seguenti OP per la sequenza cubica:

OP (1, n) = 1                   1, 1, 1, 1, ...
                                   -
OP (2, n) = 7n − 6              1, 8, 15, ...
                                      --
OP (3, n) = 6n^2 − 11n + 6      1, 8, 27, 58, ...
                                          --
OP (4, n) = n3                  1, 8, 27, 64, 125, ...

Chiaramente non esistono BOP per k ≥ 4.

Considerando la somma dei FIT generati dai BOP (sottolineati sopra), otteniamo 1 + 15 + 58 = 74.

Considera la seguente funzione di generazione del polinomio di decimo grado:

un = 1 - n + n ^ 2 - n ^ 3 + n ^ 4 - n ^ 5 + n ^ 6 - n ^ 7 + n ^ 8 - n ^ 9 + n ^ 10

Trova la somma dei FIT per i BOP.
============================================================================

Si tratta di un problema prettamente matematico e questa volta ho utilizzato SAGE/python per trovare la soluzione.

def ug(n):
   y = 1 - n + n^2 - n^3 + n^4 - n^5 + n^6 -n^7 + n^8 - n^9 +  n^10
   return(y)

def ugLista(n):
   ugL = []
   for i in range(1,n+1):
       ugL.append(ug(i))
   return(ugL)

ugLista(12)

[1, 683, 44287, 838861, 8138021, 51828151, 247165843, 954437177,
3138105961, 9090909091, 23775972551, 57154490053]

def eulero101(plotta = False):
   import numpy as np
   bop = [1]

   grado = 1
   x = np.array(range(0,grado+1), dtype=float)
   y = np.array([1,683], dtype=float)
   coeff = np.polyfit(x,y,grado)
   poli = np.poly1d(np.polyfit(x,y,grado))
   coeffL = []
   for i in range(len(coeff)):
       coeffL.append(int(round(coeff[i])))
   print coeffL,
   html('<pre>' + str(poli)  + '</pre>')
   for i in range(0,grado+2):
       print poli(i),
   bop.append(poli(i))
   if plotta:
       P0 = list_plot(zip(x,y), rgbcolor='red')
       P1 = list_plot([(i,poli(i)) for i in np.linspace(int(0),int(10),100)],plotjoined=True)
       show(P0 + P1)

   grado = 2
   x = np.array(range(0,grado+1), dtype=float)
   y = np.array([1,683,44287], dtype=float)
   coeff = np.polyfit(x,y,grado)
   poli = np.poly1d(np.polyfit(x,y,grado))
   coeffL = []
   for i in range(len(coeff)):
       coeffL.append(int(round(coeff[i])))
   print coeffL,
   html('<pre>' + str(poli)  + '</pre>')
   for i in range(0,grado+2):
       print poli(i),
   bop.append(poli(i))
   if plotta:
       P0 = list_plot(zip(x,y), rgbcolor='red')
       P1 = list_plot([(i,poli(i)) for i in np.linspace(int(0),int(10),100)],plotjoined=True)
       show(P0 + P1)

   grado = 3
   x = np.array(range(0,grado+1), dtype=float)
   y = np.array([1,683,44287,838861], dtype=float)
   coeff = np.polyfit(x,y,grado)
   poli = np.poly1d(np.polyfit(x,y,grado))
   coeffL = []
   for i in range(len(coeff)):
       coeffL.append(int(round(coeff[i])))
   print coeffL,
   html('<pre>' + str(poli)  + '</pre>')
   for i in range(0,grado+2):
       print poli(i),
   bop.append(poli(i))
   if plotta:
       P0 = list_plot(zip(x,y), rgbcolor='red')
       P1 = list_plot([(i,poli(i)) for i in np.linspace(int(0),int(10),100)],plotjoined=True)
       show(P0 + P1)

   grado = 4
   x = np.array(range(0,grado+1), dtype=float)
   y = np.array([1,683,44287,838861,8138021], dtype=float)
   coeff = np.polyfit(x,y,grado)
   poli = np.poly1d(np.polyfit(x,y,grado))
   coeffL = []
   for i in range(len(coeff)):
       coeffL.append(int(round(coeff[i])))
   print coeffL,
   html('<pre>' + str(poli)  + '</pre>')
   for i in range(0,grado+2):
       print poli(i),
   bop.append(poli(i))
   if plotta:
       P0 = list_plot(zip(x,y), rgbcolor='red')
       P1 = list_plot([(i,poli(i)) for i in np.linspace(int(0),int(10),100)],plotjoined=True)
       show(P0 + P1)

   grado = 5
   x = np.array(range(0,grado+1), dtype=float)
   y = np.array([1, 683, 44287, 838861, 8138021, 51828151], dtype=float)
   coeff = np.polyfit(x,y,grado)
   poli = np.poly1d(np.polyfit(x,y,grado))
   coeffL = []
   for i in range(len(coeff)):
       coeffL.append(int(round(coeff[i])))
   print coeffL,
   html('<pre>' + str(poli)  + '</pre>')
   for i in range(0,grado+2):
       print poli(i),
   bop.append(poli(i))
   if plotta:
       P0 = list_plot(zip(x,y), rgbcolor='red')
       P1 = list_plot([(i,poli(i)) for i in np.linspace(int(0),int(10),100)],plotjoined=True)
       show(P0 + P1)

   grado = 6
   x = np.array(range(0,grado+1), dtype=float)
   y = np.array([1, 683, 44287, 838861, 8138021, 51828151, 247165843], dtype=float)
   coeff = np.polyfit(x,y,grado)
   poli = np.poly1d(np.polyfit(x,y,grado))
   coeffL = []
   for i in range(len(coeff)):
       coeffL.append(int(round(coeff[i])))
   print coeffL,
   html('<pre>' + str(poli)  + '</pre>')
   for i in range(0,grado+2):
       print poli(i),
   bop.append(poli(i))
   if plotta:
       P0 = list_plot(zip(x,y), rgbcolor='red')
       P1 = list_plot([(i,poli(i)) for i in np.linspace(int(0),int(10),100)],plotjoined=True)
       show(P0 + P1)

   grado = 7
   x = np.array(range(0,grado+1), dtype=float)
   y = np.array([1, 683, 44287, 838861, 8138021, 51828151, 247165843, 954437177], dtype=float)
   coeff = np.polyfit(x,y,grado)
   poli = np.poly1d(np.polyfit(x,y,grado))
   coeffL = []
   for i in range(len(coeff)):
       coeffL.append(int(round(coeff[i])))
   print coeffL,
   html('<pre>' + str(poli)  + '</pre>')
   for i in range(0,grado+2):
       print poli(i),
   bop.append(poli(i))
   if plotta:
       P0 = list_plot(zip(x,y), rgbcolor='red')
       P1 = list_plot([(i,poli(i)) for i in np.linspace(int(0),int(10),100)],plotjoined=True)
       show(P0 + P1)

   grado = 8
   x = np.array(range(0,grado+1), dtype=float)
   y = np.array([1, 683, 44287, 838861, 8138021, 51828151, 247165843, 954437177, 3138105961], dtype=float)
   coeff = np.polyfit(x,y,grado)
   poli = np.poly1d(np.polyfit(x,y,grado))
   coeffL = []
   for i in range(len(coeff)):
       coeffL.append(int(round(coeff[i])))
   print coeffL,
   html('<pre>' + str(poli)  + '</pre>')
   for i in range(0,grado+2):
       print poli(i),
   bop.append(poli(i))
   if plotta:
       P0 = list_plot(zip(x,y), rgbcolor='red')
       P1 = list_plot([(i,poli(i)) for i in np.linspace(int(0),int(10),100)],plotjoined=True)
       show(P0 + P1)

   grado = 9
   x = np.array(range(0,grado+1), dtype=float)
   y = np.array([1, 683, 44287, 838861, 8138021, 51828151, 247165843, 954437177, 3138105961, 9090909091], dtype=float)
   coeff = np.polyfit(x,y,grado)
   poli = np.poly1d(np.polyfit(x,y,grado))
   coeffL = []
   for i in range(len(coeff)):
       coeffL.append(int(round(coeff[i])))
   print coeffL,
   html('<pre>' + str(poli)  + '</pre>')
   for i in range(0,grado+2):
       print poli(i),
   bop.append(poli(i))
   if plotta:
       P0 = list_plot(zip(x,y), rgbcolor='red')
       P1 = list_plot([(i,poli(i)) for i in np.linspace(int(0),int(10),100)],plotjoined=True)
       show(P0 + P1)

   grado = 10
   x = np.array(range(0,grado+1), dtype=float)
   y = np.array([1, 683, 44287, 838861, 8138021, 51828151, 247165843, 954437177, 3138105961, 9090909091, 23775972551], dtype=float)
   coeff = np.polyfit(x,y,grado)
   poli = np.poly1d(np.polyfit(x,y,grado))
   coeffL = []
   for i in range(len(coeff)):
       coeffL.append(int(round(coeff[i])))
   print coeffL,
   html('<pre>' + str(poli)  + '</pre>')
   for i in range(0,grado+2):
       print poli(i),
   if plotta:
       P0 = list_plot(zip(x,y), rgbcolor='red')
       P1 = list_plot([(i,poli(i)) for i in np.linspace(int(0),int(10),100)],plotjoined=True)
       show(P0 + P1)

   print bop
   #print int(round(sum(bop)))
   return(int(round(sum(bop))))

time eulero101(plotta=False)

[682, 1]

682 x + 1

1.0 683.0 1365.0 
[21461, -20779, 1]
           2
2.146e+04 x - 2.078e+04 x + 1

0.999999999993 683.0 44287.0 130813.0 
[118008, -332563, 215237, 1]
          3             2
1.18e+05 x - 3.326e+05 x + 2.152e+05 x + 1

1.0 683.0 44287.0 838861.0 3092453.0 
[210232, -1143384, 1979989, -1046155, 1]
           4             3            2
2.102e+05 x - 1.143e+06 x + 1.98e+06 x - 1.046e+06 x + 1

1.0000000149 683.00000001 44287.0 838861.0 8138021.0 32740951.0
[159060, -1380368, 4423716, -5973011, 2771285, 1]
           5            4             3             2
1.591e+05 x - 1.38e+06 x + 4.424e+06 x - 5.973e+06 x + 2.771e+06 x + 1

0.999999880791 683.000000086 44286.9999999 838861.0 8138021.0 51828151.0 205015603.0 
[58542, -719070, 3595702, -8748234, 10067497, -4253755, 1]
           6             5             4             3             2
5.854e+04 x - 7.191e+05 x + 3.596e+06 x - 8.748e+06 x + 1.007e+07 x - 4.254e+06 x + 1

1.0 682.999999477 44287.0000006 838861.0 8138021.0 51828151.0 247165843.0 898165577.0 
[11165, -175923, 1234805, -4610573, 9383726, -9627563, 3785045, 1]
           7             6             5             4             3              2
1.117e+04 x - 1.759e+05 x + 1.235e+06 x - 4.611e+06 x + 9.384e+06 x - 9.628e+06 x + 3.785e+06 x + 1

1.0 683.000003743 44287.0000004 838861.000003 8138021.0 51828151.0 247165843.0 954437177.0 3093310441.0 
[1111, -19943, 181819, -942755, 2909786, -5205926, 4890985, -1814395, 1]
      8             7             6             5            4             3             2 
1111 x - 1.994e+04 x + 1.818e+05 x - 9.428e+05 x + 2.91e+06 x - 5.206e+06 x + 4.891e+06 x - 1.814e+06 x + 1 

1.00000762939 683.000007528 44286.9999997 838861.000002 8138021.00001 51828151.0 247165843.0 954437177.0 3138105961.0 9071313571.0 
[54, -833, 9541, -63125, 269491, -723550, 1172770, -1026551, 362885, 1]
    9       8        7             6             5             4             3             2
54 x - 833 x + 9541 x - 6.312e+04 x + 2.695e+05 x - 7.235e+05 x + 1.173e+06 x - 1.027e+06 x + 3.629e+05 x + 1

0.999998092651 682.99998807 44286.9999814 838860.999984 8138020.99998 51828151.0 247165843.0 954437177.0 3138105961.0 9090909091.0 23772343751.0 
[1, 9, 37, 91, 148, 166, 130, 70, 25, 5, 1]
   10     9      8      7       6       5       4      3      2
1 x  + 9 x + 37 x + 91 x + 148 x + 166 x + 130 x + 70 x + 25 x + 5 x + 1

0.999999046326 682.999999004 44286.9999978 838860.999998 8138021.0 51828151.0 247165843.0 954437177.0 3138105961.0 9090909091.0 23775972551.0 57154490053.0 
[1, 1365.0, 130812.99999999997, 3092452.9999999986, 32740951.000000015, 205015603.00000089, 898165576.99999714, 3093310441.0001335, 9071313571.000391, 23772343750.999367]
37076114526L
Time: CPU 0.07 s, Wall: 0.22 s

Soluzione: 37076114526
Tempo: 0.07 sec = 70 msec
----------------------------------------------------------------------------


============
Problema 102
============

Contenimento del triangolo

Tre punti distinti vengono tracciati a caso su un piano cartesiano, per il quale -1000 ≤ x, y ≤ 1000, in modo tale che si formi un triangolo.

Considera i seguenti due triangoli:

A (-340,495), B (-153, -910), C (835, -947)

X (-175,41), Y (-421, -714), Z (574, -645)

Si può verificare che il triangolo ABC contiene l'origine, mentre il triangolo XYZ no.

Utilizzando "triangles.txt", un file di testo di 27K contenente le coordinate di mille triangoli "casuali", trova il numero di triangoli di cui l'interno contiene l'origine.

NOTA: i primi due esempi nel file rappresentano i triangoli nell'esempio fornito sopra.
============================================================================

Il file "triangle.txt" è stato trasformato nel file "e102.lsp" che contiene la lista "triangle".

(load "e102.lsp")

(triangle 0)
;-> (-340 495 -153 -910 835 -947)
(triangle 1)
;-> (-175 41 -421 -714 574 -645)

Possiamo usare il teorema di Jordan (che vale anche per qualunque poligono):

1) Calcolare delle intersezioni tra la semiretta x = 0 per y < 0 che passa per 0,0 e i segmenti del triangolo.

2) Se le intersezioni sono pari, allora il punto è esterno.

3) Se le intersezioni sono dispari, allora il punto è interno.

(define (retta x1 y1 x2 y2)
  ; y = a*x + b
  (local (a b)
    ; rette parallele ?
    (if (zero? (sub x2 x1)) (setq x (add x 0.01)))
    (setq a (div (sub y2 y1) (sub x2 x1)))
    (setq b (sub y1 (mul a x1)))
    (list a b)))

(define (e102)
  (local (x0 y0 xmax xmin ymax ymin r1 a1 b1 r2 a2 b2 r3 a3 b3 conta dentro fuori)
    (setq x0 0 y0 0 dentro 0 fuori 0)
    (dolist (el triangle)
      (setq xmax (max (el 0) (el 2) (el 4)))
      (setq xmin (min (el 0) (el 2) (el 4)))
      (setq ymax (max (el 1) (el 3) (el 5)))
      (setq ymin (min (el 1) (el 3) (el 5)))
      ; Controllo se 0,0 è esterno al rettangolo di contenimento del triangolo
      (cond ((or (> x0 xmax) (< x0 xmin) (> y0 ymax) (< y0 ymin))
             (++ fuori))
            ; Calcolo dei parametri delle rette dei lati del triangolo
            (true
             (setq r1 (retta (el 0) (el 1) (el 2) (el 3)))
             (setq a1 (first r1)) (setq b1 (last r1))
             (setq r2 (retta (el 2) (el 3) (el 4) (el 5)))
             (setq a2 (first r2)) (setq b2 (last r2))
             (setq r3 (retta (el 4) (el 5) (el 0) (el 1)))
             (setq a3 (first r3)) (setq b3 (last r3))
             (setq conta 0)
             ; b1, b2, b3 sono le soluzioni delle intersezioni
             ; la soluzione deve essere compresa tra y1 e y2 del lato e deve essere minore di 0
             (if (and (>= b1 (min (el 1) (el 3))) (<= b1 (max (el 1) (el 3))) (< b1 0))
                 (++ conta))
             (if (and (>= b2 (min (el 3) (el 5))) (<= b2 (max (el 3) (el 5))) (< b2 0))
                 (++ conta))
             (if (and (>= b3 (min (el 5) (el 1))) (<= b3 (max (el 5) (el 1))) (< b3 0))
                 (++ conta))
             (if (odd? conta) 
                 (++ dentro)
                 (++ fuori))
            )
      )
    )
    dentro))

(e102)
;-> 228

(time (e102))
;-> 2.022

Un altro algoritmo semplice e veloce, chiamato metodo baricentrico, consiste nel controllare su quale lato del semipiano creato dai lati si trova il punto.

(define (e102)
  (local (x1 y1 x2 y2 x3 y3 a b c out)
    (setq out 0)
    (dolist (el triangle)
      (setq x1 (el 0)) (setq y1 (el 1))
      (setq x2 (el 2)) (setq y2 (el 3))
      (setq x3 (el 4)) (setq y3 (el 5))
      (setq a (> (- (* x1 y2) (* y1 x2)) 0))
      (setq b (> (- (* x2 y3) (* y2 x3)) 0))
      (setq c (> (- (* x3 y1) (* y3 x1)) 0))
      (if (= a b c) (++ out))
    )
    out))

(e102)
;-> 228

(time 102)
;-> 0
----------------------------------------------------------------------------

=============================================================================

===============

 PROBLEMI VARI

===============

Ci sono (1 + 2 + 3) numeri primi minori di (4 + 5 + 6) e il 7-imo primo è uguale a (8 + 9).

----------
BubbleSort
----------

Il Bubble sort (ordinamento a bolla) è un semplice algoritmo stabile di ordinamento di una lista o di un vettore di dati. Ogni coppia di elementi adiacenti viene comparata e invertita di posizione se sono nell'ordine sbagliato. L'algoritmo continua continuamente ad eseguire questi passaggi per tutta la lista finché non vengono più eseguiti scambi, situazione che indica che la lista è ordinata.

Complessità temporale media O(n^2).

Nota: Un metodo di ordinamento si dice stabile se preserva l'ordine relativo dei dati cha hanno chiavi uguali all'interno della struttura dati da ordinare.

Possiamo rappresentare l'algoritmo con questo pseudocodice:

procedure BubbleSort(A:lista di elementi da ordinare)
  ultimoScambiato ← n
  n ← length(A) - 1
  while (ultimoScambiato > 0) do
    ultimoScambiato ← 0
    for i ← 0 to n do
      if (A[i] > A[i + 1]) then  //sostituire '>' con '<' per ottenere un ordinamento decrescente
        swap ( A[i], A[i+1] )
        ultimoScambiato ← i
    ; ad ogni passaggio si accorcia il ciclo di for
    ; fermandosi in corrispondenza dell'ultimo scambio effettuato
    n ← ultimoScambiato

Versione ricorsiva:

(define (bubble-up lst)
    (if (null? (rest lst))
        lst
        (if (< (first lst) (first (rest lst)))
            (cons (first lst) (bubble-up (rest lst)))
            (cons (first (rest lst)) (bubble-up (cons (first lst) (rest (rest lst))))))))

(define (bubble-sort-aux n lst)
    (cond ((= n 1) (bubble-up lst))
          (true (bubble-sort-aux (- n 1) (bubble-up lst)))))

(define (bubbleSort lst)
    (bubble-sort-aux (length lst) lst))

(bubbleSort '(5 10 9 8 7 8 6 7 5 4 3 4 5))
;-> (3 4 4 5 5 5 6 7 7 8 8 9 10)

Versione iterativa:

(define (bubbleSort lst)
  (local (i j continua)
    (setq continua 1)
    (setq j (length lst))
    (while (= continua 1)
      (setq continua 0)
      (for (i 1 (- j 1))
        (cond ((< (lst i) (lst (- i 1)))
               (swap (lst i) (lst (- i 1)))
               (setq continua 1))
        )
      )
      (-- j)
    )
  )
  lst
)

(bubbleSort '(5 10 9 8 7 8 6 7 5 4 3 4 5))
;-> (3 4 4 5 5 5 6 7 7 8 8 9 10)


---------
QuickSort
---------

Il Quicksort è un algoritmo di ordinamento ricorsivo. Appartiene alla classe degli algoritmi divide et impera, dal momento che scompone ricorsivamente i dati da processare in sottoprocessi. Tale procedura ricorsiva viene comunemente detta partizionamento: preso un elemento chiamato "pivot" da una struttura dati (es. lista o vettore) si pongono gli elementi minori a sinistra rispetto al pivot e gli elementi maggiori a destra. L'operazione viene quindi reiterata sui due insiemi risultanti fino al completo ordinamento della struttura.

Il Quicksort (ordinamento rapido), è l'algoritmo di ordinamento che ha, nel caso medio, prestazioni migliori tra quelli basati su confronto. È stato ideato da Richard Hoare nel 1961.

Complessità temporale media O(nlogn).

Lo pseudocodice per il Quicksort è:

Procedure Quicksort(A)
Input A, vettore a1, a2, a3 .. an
  begin
    if n ≤ 1 then return A
    else
      begin
        scegli un elemento pivot ak
        calcola il vettore A1 dagli elementi ai di A tali che i ≠ K e ai ≤ ak
        calcola il vettore A2 dagli elementi aj di A tali che j ≠ K e aj > ak
        A1 ← Quicksort(A1)
        A2 ← Quicksort(A2)
        return A1 U (ak) U A2;
      end

In newLISP possiamo scriverla in questo modo utilizzando la funzione "filter":

(define (quicksort lst)
  (cond ((or (null? lst)         ; la lista è vuota (ordinata)
             (null? (rest lst))) ; la lista ha un solo elemento (ordinata)
         lst)
        (true
          (let ((pivot (first lst)) ; Seleziona il primo elemento come pivot
                (resto (rest lst))) ; Prendi la lista rimanente (resto)
               (append (quicksort   ; Ricorsivamente ordina la lista dei valori più piccoli
                          (filter (lambda (x) (< x pivot)) resto)) ; Seleziona i valori più piccoli
                       (list pivot) ; Aggiungi il pivot al centro
                       (quicksort   ; Ricorsivamente ordina la lista dei valori più grandi
                          (filter (lambda (x) (>= x pivot)) resto)))  ; Seleziona i valori maggiori e uguali
          )
        )
  )
)

(quicksort '(89 3 4 5 3 2 2 4 6 7 8 9 7 8 9 3 2 4 89))
;-> (2 2 2 3 3 3 4 4 4 5 6 7 7 8 8 9 9 89 89)

Questo è l'algoritmo più veloce (in media) per ordinare una lista:

(silent (setq lst (rand 10000 100000)))

(time (quicksort lst))
;-> 989.971

Ma non è paragonabile alla funzione predefinita di newLISP "sort":

(time (sort lst))
;-> 55.94


-----------------------------------
Simulare una matrice con un vettore
-----------------------------------

Data la seguente matrice:

          | 1  2  3  4 |
Matrice = | 5  6  7  8 |
          | 9 10 11 12 |

Simuliamo l'indicizzazione della matrice con il vettore:

Vettore = (1 2 3 4 5 6 7 8 9 10 11 12)

In generale se la matrice ha N righe e M colonne, allora il vettore deve avere N*M elementi: matrice(NxM) ==> vettore(N*M)

La formula di conversione degli indici è la seguente:

Matrice(i,j) = Vettore(i*m + j) = vettore(k)

Definiamo una funzione che converte gli indici della matrice (i,j) nell'indice k del vettore:

(define (i-j->k i j n m) (+ (* i m) j))

(setq vec '(1 2 3 4 5 6 7 8 9 10 11 12))
(setq n 3)
(setq m 4)

(i-j->k 0 0 n m)
;-> 0
(vec (i-j->k 0 0 n m))
;-> 1

Stampiamo gli indici del vettore:

(for (i 0 (- n 1))
  (for (j 0 (- m 1))
    (print (i-j->k i j n m) { })
  )
)
;-> 0 1 2 3 4 5 6 7 8 9 10 11 " "

Stampiamo i valori del vettore:

(for (i 0 (- n 1))
  (for (j 0 (- m 1))
    (print (vec (i-j->k i j n m)) { })
  )
)
;-> 1 2 3 4 5 6 7 8 9 10 11 12 " "

Adesso definiamo la funzione inversa che mappa l'indice k del vettore negli indici (i,j) della matrice:

(define (k->i-j k n m)
  (local (i j)
    (setq i (/ k m))
    (setq j (- k (* m i)))
    (list i j)
  )
)

(k->i-j 0 n m)
;-> (0 0)
(k->i-j 11 n m)
;-> (2 3)

Stampiamo gli indici della matrice:

(for (k 0 (- (* n m) 1))
    (print (k->i-j k n m) { })
)
;-> (0 0) (0 1) (0 2) (0 3) (1 0) (1 1) (1 2) (1 3) (2 0) (2 1) (2 2) (2 3) " "


--------------------------------------------
Implementare una pila (stack) con un vettore
--------------------------------------------

La pila (Stack) è una struttura dati lineare che segue un ordine particolare in cui vengono eseguite le operazioni. L'ordine può essere LIFO (Last In First Out) o FILO (First In Last Out).
Principalmente le seguenti quattro operazioni di base sono eseguite nello stack:

Push: aggiunge un elemento nello stack. Se lo stack è pieno, si dice che sia una condizione di Overflow.
Pop: rimuove un oggetto dalla pila. Gli articoli vengono visualizzati nell'ordine invertito in cui vengono inseriti. Se lo stack è vuoto, si dice che sia una condizione di Underflow.
Look o Peek o Top: restituisce l'elemento superiore dello stack.
isEmpty: restituisce true se lo stack è vuoto, altrimenti false.
pila

Come capire praticamente una pila?
Ci sono molti esempi di vita reale di una pila. Considera il semplice esempio di piatti impilati uno sull'altro in una mensa. Il piatto che è nella parte superiore è il primo ad essere rimosso, in altre parole il piatto che è stato posto nella posizione più bassa rimane nella pila per il periodo di tempo più lungo. Quindi, può essere semplicemente visto seguire l'ordine LIFO / FILO.

Complessità di tempo delle operazioni sullo stack:

Le funzioni push (), pop (), isEmpty () e look () richiedono tutte un tempo O(1). Non eseguiamo alcun ciclo in queste operazioni.

          ---------------------   <-- push
          | 1 | 2 | 3 | 4 | 5 |
          ---------------------   pop -->
  Indice    0   1   2   3   4

Crea le variabili per la gestione della pila:
(define (Screate n)
  (setq Ssize n) ; max size
  (setq Sidx 0)
  (setq Stack (array Ssize '(0)))
)

La pila è vuota?
(define (SisEmpty?) (= Sidx 0))

La pila è piena?
(define (SisFull?) (= Sidx Ssize))

Lunghezza della pila
(define (SgetLen) (Sidx)

Inserisce un elemento nella pila (in cima):
(define (Spush el)
  (if (SisFull?) (list nil "Overflow")
    (begin (setf (Stack Sidx) el) (++ Sidx))
  )
)

Estrae un elemento dalla pila (in cima):
(define (Spop)
  (if (SisEmpty?) (list nil "Underflow")
    (begin (-- Sidx) (Stack Sidx))
  )
)

Guarda un elemento dalla lista (in cima):
(define (Slook)
  (if (SisEmpty?) nil
      (Stack (- Sidx 1))
  )
)

Stampa elementi della pila:

(define (Sshow)
  (if (SisEmpty?) nil ; coda vuota ?
      (for (i 0 (- Sidx 1))
            (print (Stack i) { })
      )
  )
)

(Screate 3)
;-> (0 0 0)
(Spush 1)
;-> 1
(Spush 2)
;-> 2
(SisFull?)
;-> nil
(Spush 3)
;-> 3
(SisFull?)
;-> true
(Slook)
;-> 3
(Sshow)
;-> 1 2 3
(Spop)
;-> 3
(Spop)
;-> 2
(Spop)
;-> 1
(Spop)
;-> (nil "Overflow)
(Spush 1)
(Spush 2)
(Spush 3)
(Spush 4)
;-> (nil "Overflow")


--------------------------------------------
Implementare una coda (queue) con un vettore
--------------------------------------------

In una coda (queue), l'inserimento e l'eliminazione degli elementi avvengono agli estremi opposti, quindi l'implementazione non è semplice come quella della pila (stack). Le operazioni su una coda sono basate sul principio FIFO (First In First Out).
Per implementare una coda usando un vettore, creare un vettore "vec" arr di dimensione n e utilizzare due variabili front e rear che verranno inizializzate a 0, il che significa che la coda è attualmente vuota. La variabile "rear" è l'indice in cui gli elementi sono memorizzati nel vettore e "front" è l'indice del primo elemento del vettore. Alcune delle operazioni sulle code sono le seguenti:

Enqueue: aggiunge di un elemento alla coda. L'aggiunta di un elemento verrà eseguita dopo aver controllato se la coda è piena o meno. Se (front < n) che indica che l'array non è pieno, allora memorizza l'elemento in vec[front] e incrementa rear di 1, ma se rear == n allora si ottiene una condizione di Overflow (il vettore è pieno).

Dequeue: rimuove un elemento dalla coda. Un elemento può essere cancellato solo quando è presente almeno un elemento da eliminare, ad esempio (rear > 0). Ora, l'elemento at vec[front] può essere cancellato, ma tutti gli elementi rimanenti devono essere spostati a sinistra di una posizione in modo che le successive operazioni sulla coda trovino il primo elemento della coda sulla prima cella (indice 0) del vettore.

Look: Ottiene l'elemento iniziale (front) dalla coda, ad esempio vec[front] se la coda non è vuota.

Show: Se la coda non è vuota, attraversa e stampa tutti gli elementi dall'indice anteriore a quello posteriore.

               -------------------------
  dequeue <--  | 1 | 2 | 3 | 4 | 5 |   |  <-- enqueue
               -------------------------
       Indice    0   1   2   3   4  ...

Crea le variabili per la gestione della coda:

(define (Qcreate n)
  (setq Qsize n) ; max size
  (setq Qfront 0)
  (setq Qrear 0)
  (setq Queue (array Qsize '(0)))
)

Inserisce un elemento nella coda (in fondo alla coda):

(define (Qenqueue el)
  ;controlla se la coda è piena
  (if (= Qsize Qrear)
      (list nil "overflow")
      ;else
      (begin
        (setf (Queue Qrear) el)
        (++ Qrear)
        el
      )
  )
)

Estrae un elemento dalla coda (all'inizio della coda):

(define (Qdequeue)
  (local (el)
    ;controlla se la coda è vuota
    (if (= Qfront Qrear)
        (list nil "overflow")
        ;else
        (begin
          (setq el (Queue Qfront)) ; estrae primo elemento della coda
          ; sposta tutti gli elementi a sinistra di un posto
          ; partendo dal secondo indice fino all'indice Qrear
          (for (i 0 (- Qrear 2)) (setf (Queue i) (Queue (+ i 1))))
          ; decrementa Qrear
          (-- Qrear)
          el
        )
    )
  );local
)

Stampa elementi della coda:

(define (Qshow)
  (if (= Qfront Qrear) nil ; coda vuota ?
      (for (i Qfront (- Qrear 1))
            (print (Queue i) { })
      )
  )
)

Guarda il primo elemento della coda:

(define (Qlook)
  (if (= Qfront Qrear) ; coda vuota ?
      nil
      (Queue Qfront)
  )
)

La coda è vuota?

(define (QisEmpty?) (= Qfront Qrear))

La coda è piena?

(define (QisFull?) (= Qrear Qsize))

Lunghezza della coda:

(define (QgetLen) (- Qfront Qrear))

(Qcreate 4)
;-> (0 0 0 0)
(Qenqueue 1)
;-> 1
(Qenqueue 2)
;-> 2
(Qenqueue 3)
;-> 3
(Qshow)
;-> 1 2 3
(QisEmpty?)
;-> nil
(QisFull?)
;-> nil
(Qenqueue 4)
;-> 4
(QisFull?)
;-> true
(Qenqueue 5)
;-> (nil "overflow")
(Qshow)
;-> (1 2 3 4)
(Qdequeue)
;-> (1)
(Qshow)
;-> (2 3 4)
(Qdequeue)
;-> 2
(Qdequeue)
;-> 3
(Qdequeue)
;-> 4
(Qdequeue)
;-> (nil "overflow")
(Qenqueue 4)
(Qshow)
;-> 4
(Qlook)
;-> 4
(Qshow)
;-> 4

Complessità temporale enqueue O(1)
Complessità temporale dequeue O(n)

È possibile ottenere una complessità temporale O(1) per la funzione dequeue se utilizziamo una lista circolare.

Con newLISP possiamo definire una coda (illimitata) utilizzando una lista in maniera "quick and dirty".
Dichiariamo una lista con lo stesso nome del contesto (funtore):

(setq k:k '())

Funzione che aggiunge (alla fine) un elemento alla coda:

(define (enqQ queue el) (push el queue -1))

Funzione che prende l'elemento iniziale della coda:

(define (deqQ queue) (if (not (emptyQ? queue)) (pop queue) nil))

Funzione che "guarda" il valore del primo elemento della coda:

(define (lookQ queue) (queue 0))

Funzione che restituisce true se la coda è vuota:

(define (emptyQ? queue) (= 0 (length queue)))

Funzione che restituisce il numero di elementi della coda:

(define (lenQ queue) (length queue))

Funzione che mostra tutti gli di elementi della coda:

(define (showQ queue) (println queue))

(enqQ k 1)
;-> (1)
(enqQ k 2)
;-> (2)
(enqQ k 3)
;-> (3)
k:k
;-> (1 2 3)
(deqQ k)
;-> 1
(println k:k)
;-> (2 3)
(emptyQ? k)
;-> nil
(lenQ k)
;-> 2
(k:k 1)
;-> 3
(showQ k:k)
;-> (2 3)
(lookQ k)
;-> 2

Con lo stesso metodo possiamo implementare anche una pila illimitata.


----------------------------
Coda circolare (Ring Buffer)
----------------------------

La Coda circolare (Circular Queue) è una struttura di dati lineare in cui le operazioni vengono eseguite in base al principio FIFO (First In First Out) e l'ultima posizione viene connessa alla prima posizione per creare un cerchio. Viene anche chiamato 'Ring Buffer'.

            front
 8      10   0       1  <--- indice
   -----------------
   |   |   | 2 | 1 |  <--- valore
   -----------------
 7 |   |       | 4 | 2
   -----------------
   |   | 7 | 8 | 5 |
   -----------------
 6       5   4       3
        rear

Crea le variabili per la gestione della coda circolare:

(define (CQcreate n)
  (setq CQsize n) ; max size
  (setq CQfront -1)
  (setq CQrear -1)
  (setq CQqueue (array CQsize '(0)))
)

(define (CQenqueue el)
  (cond ((or (and (= CQfront 0) (= CQrear (- CQsize 1)))
             (= CQrear (% (- CQfront 1) (- CQsize 1))))
          (list nil "Overflow") ; la coda è piena
        )
        ((= CQfront -1) ; primo inserimento
          (setq CQfront 0)
          (setq CQrear 0)
          (setq (CQqueue CQrear) el)
        )
        ((and (= CQrear (- CQsize 1)) (!= CQfront 0))
          (setq CQrear 0)
          (setq (CQqueue CQrear) el)
        )
        (true
          (++ CQrear)
          (setq (CQqueue CQrear) el)
        )
  )
)

(define (CQdequeue)
  (local (el)
    (cond ((= CQfront -1) (list nil "Underflow")) ; la coda è vuota
          (true
            (setq el (CQqueue CQfront))
            (setq (CQqueue CQfront) -1)
            (cond ((= CQfront CQrear) (setq CQfront -1 CQrear -1))
                  ((= CQfront (- CQsize 1)) (setq CQfront 0))
                  (true (++ CQfront))
            )
            el
          )
    )
  )
)

(define (CQshow)
  (cond ((= -1 CQfront) (list nil "Empty"))
        ((>= CQrear CQfront) (for (i CQfront CQrear) (print (CQqueue i) { })))
        (true (for (i CQfront (- CQsize 1) (print (CQqueue i) { })))
              (for (i 0 CQrear) (print (CQqueue i) { }))
        )
  )
)

(CQcreate 4)
;-> (0 0 0 0)
(CQenqueue 2)
;-> 2
(CQenqueue 1)
;-> 1
(CQshow)
;-> 2 1
(CQdequeue)
;-> 2
(CQdequeue)
;-> 1
(CQdequeue)
;-> (nil "Underflow")
(CQshow)
;-> (nil "Empty")

(CQenqueue 1)
(CQenqueue 2)
(CQenqueue 3)
(CQenqueue 5)
(CQenqueue 8)
;-> (nil "Overflow")
(CQshow)
;-> (1 2 3 5)

Complessità temporale:  O(1) per CQenqueue e CQdequeue poiché non vi è alcun ciclo in nessuna delle operazioni.

Applicazioni che utilizzano le code:
Gestione della memoria: le posizioni di memoria inutilizzate nel caso di code ordinarie possono essere utilizzate in code circolari.
Sistema di traffico: nel sistema di traffico controllato da computer, le code circolari vengono utilizzate per accendere ripetutamente i semafori secondo il tempo impostato.
Pianificazione della CPU: i sistemi operativi spesso mantengono una coda di processi pronti per l'esecuzione o che sono in attesa di un particolare evento.


----------
Fattoriale
----------

In matematica, si definisce fattoriale di un numero naturale n, indicato con n!, il prodotto dei numeri interi positivi minori o uguali a tale numero. In formula:

n! = Prod[i], con (1 <= i <= n)

per la convenzione del prodotto vuoto risulta inoltre: 0! = 1. Questo può essere dimostrato nel modo seguente:

(n-1)! = n!/n

sostituiamo i valori partendo da n = 4:

3! = 4!/4 = 2*3*4/4 = 2*3 = 6
2! = 3!/3 = 2*3/3 = 2 = 2
1! = 2!/2 = 2/2 = 1
0! = 1!/1 = 1/1 = 0

Nota: 1 = 1! = 1 * (1-1)! = 1 * 0! = 0!

Metodo ricorsivo:

(define (fact n)
  (if (< n 2)
      1
      (* n (fact (- n 1)))
  )
)

(fact 6L)
;-> 720L

Metodo iterativo:

(define (fact1 n)
  (let (fatt 1L)
    (for (x 1L n)
      (setq fatt (* fatt x))
    )
  )
)

(fact1 6)
;-> 720L

Metodo newLISP:

(define (fact2 n) (if (= n 0) 1 (apply * (map bigint (sequence 1 n)))))

(fact2 6)
;-> 720L

(fact2 100)
;-> 93326215443944152681699238856266700490715968264381621
;-> 46859296389521759999322991560894146397615651828625369
;-> 7920827223758251185210916864000000000000000000000000L

(time (fact1 113) 10000)
;-> 180.544

(time (fact2 113) 10000)
;-> 258.308

I fattoriali sono importanti nel calcolo combinatorio.
Per esempio, vi sono n! diverse sequenze formate da n oggetti distinti, cioè ci sono n! permutazioni di n oggetti.



----------------------
Coefficiente binomiale
----------------------

Il coefficiente binomiale, cioè il numero di scelte di k elementi tra quelli di un insieme di n elementi (numero di combinazioni semplici), ha la seguente formula:

(n)        n!
   = ---------------
(k)   k! * (n - k)!

in altre parole, il coefficiente binomiale C(n, k) fornisce anche il numero di modi, trascurando l'ordine, che k oggetti possono essere scelti tra n oggetti.

Soluzione ricorsiva

(define (binomiale n k)
  (if (or (= k 0) (= k n))
      1
      (add (binomiale (- n 1) (- k 1)) (binomiale (- n 1) k))
  )
)

(binomiale 5 2)
;-> 10

Soluzione iterativa

Per calcolare il coefficiente binomiale, usiamo una matrice M[][] che memorizza i valori precedenti (si tratta di una tecnica della Programmazione Dinamica)

(define (binomiale n k)
  (local (M q)
    (setq M (array (+ n 1) (+ k 1) '(0L)))
    (for (i 0 n)
      (setq q (min i k))
      (for (j 0 q)
        (if (or (= j 0) (= j i))
          (setq (M i j) 1L)
          (setq (M i j) (+ (M (- i 1) (- j 1)) (M (- i 1) j)))
        )
      )
    )
    (M n k)
  );local
)

(binomiale 5 2)
;-> 10L

(binomiale 100 5)
;-> 75287520L

Complessità temporale: O(n*k)
Complessità spaziale: O(n*k)

La seguente funzione è stata scritta da TedWalther e si basa su un algoritmo trovato in "Lilavati", un trattato di aritmetica scritto nel 1150 in India.

(define (binomial-coefficient n k)
  (if (> k n)
    0
    (let (r 1L)
      (for (d 1 k)
        (setq r (/ (* r n) d)) (-- n))
      r)))

(time (binomial-coefficient 12345 4) 10000)
;-> 16.981
(time (binomiale 12345 4) 100)
;-> 2620.148

Test di correttezza:

(for (i 100 2000)
  (for (j 2 10)
    (if (!= (binomial-coefficient i j) (binomiale i j)) (println " error: " i { } j))))
;-> nil

--------------
Lancio di dadi
--------------

Definire una funzione che permetta di ottenere il risultato del lancio di n dadi con m facce.
Utilizziamo la funzione "rand".

*****************
>>>funzione RAND
*****************
sintassi: (rand int-range [int-N])

Valuta l'espressione in int-range e genera un numero casuale compreso tra 0 (zero) e (int-range - 1). Quando viene passato 0 (zero), il generatore casuale interno viene inizializzato utilizzando il valore corrente restituito dalla funzione C time (). Facoltativamente, è possibile specificare un secondo parametro per restituire un elenco di lunghezza int-N di numeri casuali.

(dotimes (x 100) (print (rand 2))) =>
11100000110100111100111101 ... 10111101011101111101001100001000

(rand 3 100) → (2 0 1 1 2 0 ...)

La prima riga nell'esempio stampa equamente distribuite 0 e 1, mentre la seconda riga produce un elenco di 100 interi con 0, 1 e 2 equamente distribuiti. Utilizzare le funzioni "random" e "normal" per generare numeri casuali in virgola mobile e utilizzare "seed" per variare il seme iniziale per la generazione di numeri casuali.

Per generare il numero prodotto dal lancio di n dadi con m facce, potremmo pensare di generare un numero casuale tra n (quando tutti i dadi valgono 1) e n*m (quando tutti i dadi valgono m).

(define (lancio n m)
  (add n (rand (sub (add (mul n m) 1) n)))
)

(lancio 2 6)
;-> 11

Purtroppo questo ragionamento è sbagliato perchè la nostra funzione considera equiprobabili i numeri tra n e n*m, mentre questo non è vero. Vediamo un esempio con due dadi a sei facce.
Le probabilità dei numeri non sono identiche, infatti risulta:

 1: nil (non può mai uscire 1)
 2: (1,1) --> (1 caso)
 3: (1,2) (2,1) --> (2 casi)
 4: (1,3) (3,1) (2,2) --> (3 casi)
 5: (1,4) (4,1) (2,3) (3,2) --> (4 casi)
 6: (1,5) (5,1) (2,4) (4,2) (3,3) --> (5 casi)
 7: (1,6) (5,2) (2,5) (5,2) (3,4) (4,3) --> (6 casi)
 8: (2,6) (6,2) (3,5) (5,3) (4,4) --> (5 casi)
 9: (3,6) (6,3) (4,5) (5,4) --> (4 casi)
10: (4,6) (6,4) (5,5) --> (4 casi)
11: (5,6) (6,5) --> (2 casi)
12: (6,6) --> (1 caso)

La seguente funzione fornisce il risultato corretto:

(define (lancio-dadi num-dadi num-facce)
  (+ num-dadi (apply + (rand num-facce num-dadi)))
)

(lancio-dadi 3 6)
;-> 16

(define (test)
  (for (i 1 10000000)
    (setq dadi  (+ 1 (rand 10)))
    (setq facce (+ 1 (rand 36)))
    ;(println i { } dadi { } facce)
    (setq lancio (lancio-dadi dadi facce))
    (if (< lancio dadi) (println "error: minore"))
    (if (> lancio (* dadi facce)) (println "error: maggiore"))
))

(test)
;-> nil


Per capire meglio la differenza dei risultati tra le due funzioni, creiamo due liste con le frequenze di 10000 valori generati da ognuna delle due funzioni, poi disegniamo un istogramma per ogni lista.

Creiamo la prima lista.
Generiamo una lista con 10000 lanci:

(setq res1 '())
(for (i 0 9999)
  (push (lancio 2 6) res1 -1)
)
(length res1)

Creiamo la lista delle frequenze:

(setq f1 (array 13 '(0)))
(dolist (el res1)
  (println el)
  (++ (f1 (- el 1)))
)

f1
;-> (0 880 889 913 929 910 914 939 866 902 943 915 0)

Creiamo la seconda lista.
Generiamo una lista con 10000 lanci:

(setq res2 '())
(for (i 0 9999)
  (push (lancio-dadi 2 6) res2 -1)
)
(length res2)

Creiamo la lista delle frequenze:

(setq f2 (array 13 '(0)))
(dolist (el res2)
  (println el)
  (++ (f2 (- el 1)))
)

f2
;-> (0 288 515 870 1145 1354 1643 1385 1162 803 565 270 0)

Adesso dobbiamo creare una funzione che disegna l'istogramma di una lista. Per i nostri scopi sarà sufficiente la seguente funzione che disegna un istogramma ruotato di 90 gradi utilizzando il carattere "*". Il parametro "hmax" definisce l'altezza massima dell'istogramma.

(define (histo lst hmax)
  (local (linee hm scala)
    (setq hm (apply max lst))
    (setq scala (div hm hmax))
    (setq linee (map (fn (x) (round (div x scala))) lst))
    (dolist (el linee)
      ;(println (format "%3d %s %0.2f" (add $idx 1) (dup "*" el) (lst $idx)))
      (println (format "%3d %s %4d" (add $idx 1) (dup "*" el) (lst $idx)))
    )
  )
)

Proviamo a disegnare l'istogramma della prima lista:

(histo f1 50)
;->   1     0
;->   2 ***********************************************  909
;->   3 **********************************************  878
;->   4 **********************************************  892
;->   5 **********************************************  888
;->   6 *************************************************  946
;->   7 *********************************************  870
;->   8 *************************************************  942
;->   9 ************************************************  918
;->  10 **************************************************  962
;->  11 ************************************************  923
;->  12 *********************************************  872
;->  13     0

E poi l'istogramma della seconda lista:

(histo f2 50)
;->   1     0
;->   2 ********  251
;->   3 ****************  525
;->   4 **************************  852
;->   5 ********************************** 1142
;->   6 ***************************************** 1363
;->   7 ************************************************** 1663
;->   8 ****************************************** 1403
;->   9 ********************************** 1133
;->  10 *************************  846
;->  11 ****************  541
;->  12 ********  281
;->  13     0

La prima lista ha una distribuzione pressochè uniforme (tutti i numeri hanno la stessa probabilità).
La seconda lista ha una distribuzione gaussiana centrata sul numero più probabile.

Notazione internazionale

Una lancio di dadi viene codificato con la seguente espressione matematica:

XdY [<-> | <+> | <*> | </>] [N | AdB]

Al numero uscito dal lancio di X dadi con Y facce viene applicata una delle operazioni - o + o * o / con il numero N o con il numero uscito da un lancio di A dadi con B facce.

Esempi:
2d6 + 10
(al lancio di 2 dadi con 6 facce sommare il numero 10)
4d8 - 1d6
(al lancio di 4 dadi con 8 facce sottrarre il lancio di 1 dado con 6 facce)


---------------
Quadrati magici
---------------

Un quadrato magico è una matrice quadrata NxN i cui numeri consistono in numeri consecutivi (da 1 a N) disposti in modo tale che la somma di ogni riga e colonna e di entrambe le diagonali siano uguali alla stessa somma (che è chiamata numero magico o costante magica).
Il numero magico vale: n(n*n + 1)/2

Esistono tre tipi di quadrati magici (catalogati in base alla dimensione del lato)

- dispari (dove n = 3, 5, 7, 9, 11, ecc.)

- singolarmente pari (dove n è multiplo di 2, ma non di 4, n = 6, 10, 14, 18, 22, ...)

- doppiamente pari (dove n è un multiplo di quattro, n = 4, 8, 12, ...

Dato un numero N, scrivere una funzione che crea un quadrato magico di ordine N.

Per la stampa utilizziamo la seguente funzione:

(define (print-matrix matrix)
  (local (row col nmax nmin digit fmtstr)
    ; converto matrice in lista ?
    (if (array? matrix) (setq matrix  (array-list matrix)))
    ; righe della matrice
    (setq row (length matrix))
    ; colonne della matrice
    (setq col (length (first matrix)))
    ; valore massimo
    (setq nmax (string (apply max (flat matrix))))
    ; valore minimo
    (setq nmin (string (apply min (flat matrix))))
    ; calcolo spazio per i numeri
    (setq digit (add 1 (max (length nmax) (length nmin))))
    ; creo stringa di formattazione
    (setq fmtstr (append "%" (string digit) "d"))
    ; stampa
    (for (i 0 (sub row 1))
      (for (j 0 (sub col 1))
        (print (format fmtstr (matrix i j)))
      )
      (println)
    )
  )
)

Dobbiamo scrivere una funzione per ogni tipo di quadrato magico. Cominciamo con quelli di ordine dispari.

1) Quadrati Magici Dispari

(define (qmDispari n)
  (define (f n x y) (% (add x (mul y 2) 1) n))
  (local (val nm row out)
    (setq out '())
    (setq row '())
    ;calcolo quadrato magico
    (for (i 0 (sub n 1))
      (for (j 0 (sub n 1))
        (setq val (add (mul (f n (sub n j 1) i) n)
                       (add (f n j i))
                       1))
        (push val row -1)
      )
      (push row out -1)
      (setq row '())
    )
    ;calcolo numero magico
    (setq nm (div (mul n (add 1 (mul n n))) 2))
    (println nm)
    out
  )
)

(print-matrix (qmDispari 9))
;-> 369
;->   2 75 67 59 51 43 35 27 10
;->  22 14  6 79 71 63 46 38 30
;->  42 34 26 18  1 74 66 58 50
;->  62 54 37 29 21 13  5 78 70
;->  73 65 57 49 41 33 25 17  9
;->  12  4 77 69 61 53 45 28 20
;->  32 24 16  8 81 64 56 48 40
;->  52 44 36 19 11  3 76 68 60
;->  72 55 47 39 31 23 15  7 80

Scriviamo una funzione che controlla la correttezza del quadrato generato

(define (check qm n somma)
  (local (valido srow scol)
    (setq valido true)
    ; controllo diagonali
    (setq srow 0 scol 0)
    (for (i 0 (sub n 1))
      (setq srow (add srow (qm i i)))
      (setq scol (add scol (qm i (sub n i 1))))
    )
    (if (or (!= srow somma) (!= scol somma))
        (setq valido nil))
    ;controllo righe e colonne
    (for (i 0 (sub n 1) 1 valido)
      (setq srow 0 scol 0)
      (for (j 0 (sub n 1) 1 valido )
        (setq srow (add srow (qm i j)))
        (setq scol (add scol (qm j i)))
      )
      (if (or (!= srow somma) (!= scol somma))
          (setq valido nil)
      )
    )
    valido
  )
)

(setq m (qmDispari 9))
;-> 369
(check m 9 369)
;-> true

2) Quadrati Magici Doppiamente Pari

(define (qm4 n)
  (local (r c i bit size mult bitPos nm out v)
    (setq bit 38505)
    (setq size (* n n))
    (setq mult (/ n 4))
    ;creazione della lista)
    (setq out (dup (dup 0 n) n))
    (setq r 0 c 0 i 0)
    (while (< r n)
      (while (< c n)
        (setq bitPos (+ (/ c mult) (* (/ r mult) 4)))
        (if (!= (& bit (<< 1 bitPos)) 0)
          (setq v (+ i 1))
          (setq v (- size i))
        )
        (setf (out r c) v)
        (++ c)
        (++ i)
      )
      (setq c 0)
      (++ r)
    )
    ;calcolo numero magico
    (setq nm (div (mul n (add 1 (mul n n))) 2))
    (println nm)
    out
  )
)

(setq m (qm4 4))
;-> 34
;-> ((1 15 14 4) (12 6 7 9) (8 10 11 5) (13 3 2 16))
(print-matrix m)
;->   1 15 14  4
;->  12  6  7  9
;->   8 10 11  5
;->  13  3  2 16
(check m 4 34)
;-> true

(setq m (qm4 12))
;-> 870
(print-matrix m)
;->    1   2   3 141 140 139 138 137 136  10  11  12
;->   13  14  15 129 128 127 126 125 124  22  23  24
;->   25  26  27 117 116 115 114 113 112  34  35  36
;->  108 107 106  40  41  42  43  44  45  99  98  97
;->   96  95  94  52  53  54  55  56  57  87  86  85
;->   84  83  82  64  65  66  67  68  69  75  74  73
;->   72  71  70  76  77  78  79  80  81  63  62  61
;->   60  59  58  88  89  90  91  92  93  51  50  49
;->   48  47  46 100 101 102 103 104 105  39  38  37
;->  109 110 111  33  32  31  30  29  28 118 119 120
;->  121 122 123  21  20  19  18  17  16 130 131 132
;->  133 134 135   9   8   7   6   5   4 142 143 144
(check m 12 870)
;-> true

3) Quadrati Magici Singolarmente Pari

; Funzione interna che crea un quadrato magico dispari
(define (oddMS n)
  (local (r c squaresize nm out value)
    (setq squaresize (* n n))
    (setq c (/ n 2))
    (setq r 0)
    ;creazione della lista
    (setq out (dup (dup 0 n) n))
    (setq value 1)
    (while (<= value squaresize)
      (setf (out r c) value)
      (cond ((= r 0)
              (if (= c (- n 1))
                  (++ r)
                  (begin
                  (setq r (- n 1))
                  (++ c))
              )
            )
            ((= c (- n 1))
              (-- r)
              (setq c 0)
            )
            ((= (out (- r 1) (+ c 1)) 0)
              (-- r)
              (++ c)
            )
            (true (++ r))
      )
      (++ value)
    )
    ;(println (div (mul n (add 1 (mul n n))) 2))
    out
  )
)

(setq m (oddMS 5))
;-> 65
;-> ((17 24 1 8 15) (23 5 7 14 16) (4 6 13 20 22) (10 12 19 21 3) (11 18 25 2 9))
(print-matrix m)
;->  17 24  1  8 15
;->  23  5  7 14 16
;->   4  6 13 20 22
;->  10 12 19 21  3
;->  11 18 25  2  9
(check m 5 65)
;-> true

(define (qm2 n)
  (local (r c size half grid gridFactors subGrid nColsLeft nColsRigth nm out)
    (setq size (* n n))
    (setq halfN (/ n 2))
    (setq subGridSize (/ size 4))
    (setq subGrid (oddMS halfN))
    (setq gridFactors '(0 2 3 1))
    ;creazione della lista
    (setq out (dup (dup 0 n) n))
    (for (r 0 (- n 1))
      (for (c 0 (- n 1))
        ;(println r { } c)
        (setq grid (+ (* (/ r halfN) 2) (/ c halfN)))
        (setf (out r c) (subGrid (% r halfN) (% c halfN)))
        (setf (out r c) (+ (out r c) (* (gridFactors grid) subGridSize)))
      )
    )
    (setq nColsLeft (/ halfN 2))
    (setq nColsRigth (- nColsLeft 1))
    (for (r 0 (- halfN 1))
      (for (c 0 (- n 1) 1 )
        (if (or (< c nColsLeft) (>= c (- n nColsRigth))
                (and (= c nColsLeft) (= r nColsLeft)))
            ;(if (and (!= c 0) (!= r nColsLeft))
            (if (and (= c 0) (= r nColsLeft))
                (setq c c) ; no operation (NOP)
                (swap (out r c) (out (+ r halfN) c))
            )
        )
      )
    )
    (println (div (mul n (add 1 (mul n n))) 2))
    out
  );local
)

(qm2 6)
;-> 111
;-> ((35 1 6 26 19 24) (3 32 7 21 23 25) (31 9 2 22 27 20) (8 28 33 17 10 15)
;-> (30 5 34 12 14 16) (4 36 29 13 18 11))

(setq m (qm2 6))
(print-matrix m)
;->  35  1  6 26 19 24
;->   3 32  7 21 23 25
;->  31  9  2 22 27 20
;->   8 28 33 17 10 15
;->  30  5 34 12 14 16
;->   4 36 29 13 18 11
(check m 6 111)
;-> true


-------------------
Quadrati magici 3x3
-------------------

Nessun output sulla REPL:
(define (resume) (print "\r\n> "))

Esempio di utilizzo:
(silent <(function)> (print "Fatto") (resume))

Numero magico per i quadrati magici 3x3:
(setq nm (div (mul 3 (add 1 (mul 3 3))) 2))
;-> 15

Funzione che controlla se un quadrato è magico:

(define (check3 qm somma)
  (if (and (= somma (+ (qm 0) (qm 1) (qm 2))) ;riga 0
           (= somma (+ (qm 3) (qm 4) (qm 5))) ;riga 1
           (= somma (+ (qm 6) (qm 7) (qm 8))) ;riga 2
           (= somma (+ (qm 0) (qm 3) (qm 6))) ;colonna 0
           (= somma (+ (qm 1) (qm 4) (qm 7))) ;colonna 1
           (= somma (+ (qm 2) (qm 5) (qm 8))) ;colonna 2
           (= somma (+ (qm 0) (qm 4) (qm 8))) ;diagonale 1
           (= somma (+ (qm 2) (qm 4) (qm 6)))) ;diagonale 2
      true
      nil
  )
)

(check3 '(1 2 3 4 5 6 7 9 8) 15)
;-> nil

Questo è un quadrato magico:

  8 1 6
  3 5 7
  4 9 2

(check3 '(8 1 6 3 5 7 4 9 2) 15)
;-> true

Funzione che genera le permutazioni:

(define (rimuovi x lst)
  (cond
    ((null? lst) '())
    ((= x (first lst)) (rimuovi x (rest lst)))
    (true (cons (first lst) (rimuovi x (rest lst))))
  )
)

(define (permutazioni lst)
  (cond
    ((= (length lst) 1)(list lst))
    (true (apply append(map(lambda (i) (map (lambda (j)(cons i j))
                                            (permutazioni (rimuovi i lst)))) lst)))
  )
)

Generiamo tutte le permutazioni delle cifre da 1 a 9:
(silent (setq all (permutazioni '(1 2 3 4 5 6 7 8 9))) (print "Fatto") (resume))
;-> Fatto

Vediamo quante sono le permutazioni:
(length all)
;-> 362880

Vediamo una permutazione:
(all 1)
;-> (1 2 3 4 5 6 7 9 8)

Verifichiamo la correttezza della funzione di controllo:
(check3 (all 1) 15)
;-> nil

Verifichiamo quali permutazioni sono quadrati magici:

(setq out '())

(dolist (el all)
  (if (check3 el 15)
      (push el out -1)
  )
)

(length out)
;-> 8

out
;-> ((2 7 6 9 5 1 4 3 8)
;->  (2 9 4 7 5 3 6 1 8)
;->  (4 3 8 9 5 1 2 7 6)
;->  (4 9 2 3 5 7 8 1 6)
;->  (6 1 8 7 5 3 2 9 4)
;->  (6 7 2 1 5 9 8 3 4)
;->  (8 1 6 3 5 7 4 9 2)
;->  (8 3 4 1 5 9 6 7 2))

Per attraversare una lista la funzione "dolist" è molto più veloce dell'uso di un ciclo "for" con l'indicizzazione.

(setq out1 '())
(time
(for (i 0 (- (length all) 1))
  (setq el (all i))
  (if (check3 el 15)
      (push el out1 -1)
  )
  (if (= (% i 10000) 0 (println i)))
)
)
;->  1994673.832; 33 minuti...provatela solo se avete tempo...

Salviamo il risultato:

(save "qm3x3.lsp" 'out)
;-> true

Rendiamo il risultato più leggibile:

(dolist (el out)
  (println (el 0) { } (el 1) { } (el 2))
  (println (el 3) { } (el 4) { } (el 5))
  (println (el 6) { } (el 7) { } (el 8))
  (println)
)

                          Lo Shu
2 7 6    2 9 4    4 3 8    4 9 2    6 1 8    6 7 2    8 1 6    8 3 4
9 5 1    7 5 3    9 5 1    3 5 7    7 5 3    1 5 9    3 5 7    1 5 9
4 3 8    6 1 8    2 7 6    8 1 6    2 9 4    8 3 4    4 9 2    6 7 2

Il quarto quadrato magico è lo Shu (simbolo divinatorio e matematico cinese).
Ogni altro quadrato magico di ordine tre è ottenuto dallo Shu per rotazione e/o riflessione.


-------------------
Mastermind numerico
-------------------

(define (guessNumber)
  (local (num num$ found guess turnlst digits numdigits numTurn guessValue digitOK orderOK)
    ; lista di ogni turno
    ; turno -> (numTurn guess$ digitOK orderOK)
    (setq turnlst '())
    ; Inserire il numero di cifre del numero random
    (setq numdigits (input-integer "Numero di cifre (2-10): " 2 10))
    ; Generazione del numero random con cifre tutte diverse
    ; Validi anche i numeri con 0 iniziale (es. 0342)
    (setq num$ "")
    (setq digits (explode "0123456789"))
    (setq num$ (join (slice (randomize digits) 0 numdigits 1)))
    (setq num (int num$))
    ;(println num$)
    (setq numTurn 0)
    (setq found nil)
    ; Ciclo del gioco
    (while (not found)
      ; Inserire il numero (tentativo)
      (setq guess$ (input-string "Numero da provare: "))
      (while (not (guessControl guess$ num$))
        (setq guess$ (input-string "Numero da provare: "))
      )
      (++ numTurn)
      ;confronto tra numero random e guess
      ;numero di cifre di guess$ presenti in num$
      (setq digitOK (checkDigitOK num$ guess$))
      ;numero di cifre di guess$ nello stesso ordine in num$
      (setq orderOK (checkOrderOK num$ guess$))
      ; aggiorno la lista dei turni
      (push (list numTurn guess$ digitOK orderOK) turnlst -1)
      ;stampo la lista dei turni
      (println "turno    numero    cifreOK  ordineOK")
      (dolist (el turnlst)
        (println (format "%3d %10s %9d %9d" el))
      )
      ;controllo fine del gioco (numero indovinato)
      (if (= num$ guess$)
        (begin
          (println "NUMERO INDOVINATO --> " num$)
          (setq found true))
      )
    )
  );local
)

; routine che controlla la correttezza del numero di input (guess)
(define (guessControl guess$ num$)
  (cond ((not (numero? guess$)) (println "Inserire solo cifre...") nil)
        ((!= (length num$) (length guess$))
          (println "Numero di cifre errato...") nil) ;numero di cifre errato
        ((!= (unique (explode guess$)) (explode guess$))
          (println "Numero con cifre ripetute...") nil) ;numero con cifre ripetute
        (true true)
  )
)

; routine che controlla se la stringa è composta solo da cifre
(define (numero? stringa)
  (while (= "0" (stringa 0))
    (setq stringa (slice stringa 1)))
  (if (= (string (int stringa 0)) stringa) true nil))

(numero? "1234")
;-> true
(numero? "012a5")
;-> nil
(numero? "012")
;-> true

;routine che permette l'input di una stringa
(define (input-string message)
  (print message)
  (while (not (string? (read-line)))
    (print message)
  )
  (current-line)
)

;routine che permette l'input di un numero intero (compreso tra minv e maxv)
(define (input-integer message minv maxv)
  (print message)
  (while (or (not (integer? (int (read-line))))
             (> (int (current-line)) maxv)
             (< (int (current-line)) minv))
    (print message)
  )
  (int (current-line))
)

; Restituisce il numero di cifre di str1 che
; hanno la stessa posizione in str2
(define (checkOrderOK str1 str2)
  (local (numOK)
    (setq numOK 0)
    (for (i 0 (- (length str1) 1))
      (if (= (str1 i) (str2 i)) (++ numOK))
    )
    numOK
  )
)

(checkOrderOK "1234" "4321")
;-> 0
(checkOrderOK "123" "124")
;-> 2

; Restituisce il numero di cifre di str1 presenti in str2
(define (checkDigitOK str1 str2)
  (local (numOK)
    (setq numOK 0)
    (for (i 0 (- (length str1) 1))
      (if (!= (find (str1 i) str2) nil) (++ numOK))
    )
    numOK
  )
)

(checkDigitOK "012" "123")
;-> 2

(checkDigitOK "123" "132")
;-> 3

Adesso possiamo provare il gioco:

(guessNumber)
Numero di cifre (2-10): 3
Numero da provare: 515
Numero con cifre ripetute...
Numero da provare: 428
turno    numero    cifreOK  ordineOK
  1        428         2         2
Numero da provare: 183
turno    numero    cifreOK  ordineOK
  1        428         2         2
  2        183         0         0
Numero da provare: 421
turno    numero    cifreOK  ordineOK
  1        428         2         2
  2        183         0         0
  3        421         2         2
Numero da provare: 426
turno    numero    cifreOK  ordineOK
  1        428         2         2
  2        183         0         0
  3        421         2         2
  4        426         2         2
Numero da provare: er4
Inserire solo cifre...
Numero da provare: 1
Numero di cifre errato...
Numero da provare: 12345
Numero di cifre errato...
Numero da provare: 427
turno    numero    cifreOK  ordineOK
  1        428         2         2
  2        183         0         0
  3        421         2         2
  4        426         2         2
  5        427         3         3
NUMERO INDOVINATO --> 427
true


----------------------------
Algoritmo babilonese sqrt(x)
----------------------------

Dato un valore x > 0, l'algoritmo babilonese permette di calcolare un valore approssimato della radice quadrata di x sqrt(x). Questo metodo funziona nel modo seguente:

1) Assegna un valore positivo alla stima-iniziale della radice (quanto più essa è prossima alla radice, tanto migliore è la convergenza dell'algoritmo)
2) calcola la nuova stima come la media di stima-iniziale e x/stima-iniziale
3) Se la differenza tra stima-iniziale e stima è minore della precisione desiderata, allora la stima è la soluzione (radice), altrimenti poni la stima-iniziale uguale alla stima e continua al passo 2.

Questo algoritmo può essere rappresentato dalla seguente formula:

          1              x
x(n+1) = --- * (x(n) + -----)
          2            x(n)

Scriviamo la funzione:

(define (rq x err)
  (local (stima-iniziale stima differenza n)
    (setq n 0)
    (setq stima-iniziale (div x 2)) ;stima iniziale vale x/2
    (setq differenza (add 2 err))   ;differenza iniziale > err
    (while (> differenza err)
      (setq stima (div (add stima-iniziale (div x stima-iniziale)) 2))
      (setq differenza (abs(sub stima-iniziale stima)))
      (setq stima-iniziale stima)
      (++ n)
    )
    (list stima n)
  )
)

(rq 0.38 0.00001)
;-> (0.6164414002968977 6)

(rq 0.09 0.00001)
;-> (0.3 7)

(rq 0.123456789 0.0000001)
;-> (0.3513641828644462 7)
(mul 0.3513641828644462 0.3513641828644462)
;-> 0.123456789

(rq 123456 0.0000001)
(351.363060095964 12)
(mul 351.363060095964 351.363060095964)
;-> 123456

(rq 123456789 0.0000001)
;-> (11111.11106055556 18)
(mul 11111.11106055556 11111.11106055556)
;-> 123456789.0000001

Vediamo una versione che sceglie la stima iniziale in base al valore di x:

(define (rq x err)
  (local (stima-iniziale stima differenza n)
    (setq n 0)
    (if (> x 1)  ;stima iniziale
        (setq stima-iniziale (div x 2))
        (setq stima-iniziale (mul x 2))
    )
    (setq differenza (add 2 err))   ;differenza iniziale > err
    (while (> differenza err)
      (setq stima (div (add stima-iniziale (div x stima-iniziale)) 2))
      (setq differenza (abs(sub stima-iniziale stima)))
      (setq stima-iniziale stima)
      (++ n)
    )
    (list stima n)
  )
)

(rq 0.38 0.00001)
;-> (0.6164414002968979 4)

(rq 0.09 0.00001)
;-> (0.3000000001396984 4)

(rq 0.09 0.0000001)
;-> (0.3 5)

(rq 0.123456789 0.0000001)
;-> (0.3513641828644462 5)
(mul 0.3513641828644462 0.3513641828644462)
;-> 0.123456789

(rq 123456 0.0000001)
(351.363060095964 12)
(mul 351.363060095964 351.363060095964)
;-> 123456

(rq 123456789 0.0000001)
;-> (11111.11106055556 18)
(mul 11111.11106055556 11111.11106055556)
;-> 123456789.0000001

Questa ultima versione ha una convergenza più rapida con i numeri minori di 1.

L'algoritmo può anche essere definito nel modo seguente:

1) Poni il valore iniziale della stima della radice x0 uguale al numero x
2) Inizializza y = 1.
3) Fino al raggiungimento della precisione desiderata:
   a) calcolare prossima stima: x0 = (x0 + y)/2
   b) Imposta y = x / x0

(define (rq x err)
  (local (x0 y)
    (setq y 1)
    (setq x0 (div x 2)) ; stima valore iniziale uguale al numero x
    (while (> (abs (sub x0 y)) err) ;
      (setq x0 (div (add x0 y) 2))
      (setq y (div x x0))
    )
    x0
  )
)

(rq 4.5 0.000001)
;-> 2.121320746178046
(mul (rq 4.5 0.000001) (rq 4.5 0.000001))
;-> 4.500001708165383

(rq 4 0.000001)
;-> 2.00000000000012

La complessità temporale di questo algoritmo è O(log(log(n))).


-----------------------------------------------------
Radice quadrata intera di un numero intero (2^64 bit)
-----------------------------------------------------

(define (isqrt x)
  (local (x1 s g0 g1)
    (cond ((<= x 1) 1)
          ((> x 4294967295) nil)
          (true
            (setq s 1)
            (setq x1 (- x 1))
            (if (> 4294967295 x1) (setq s (+ s 16) x1 (>> x1 32)))
            (if (> 65535 x1) (setq s (+ s 8) x1 (>> x1 16)))
            (if (> 255 x1) (setq s (+ s 4) x1 (>> x1 8)))
            (if (> 15 x1) (setq s (+ s 2) x1 (>> x1 4)))
            (if (> 3 x1) (setq s (+ s 1)))
            (setq g0 (<< 1 s))
            (setq g1 (>> (+ g0 (>> x s)) 1))
            (while (< g1 g0) ; while approssimazione
              (setq g0 g1)   ; strettamente decrescente
              (setq g1 (>> (+ g0 (/ x g0))  1))
            )
          )
    )
    g0
  )
)

(isqrt 4)
;-> 2

(isqrt 18)
;-> 4

(isqrt 65536)
;-> 256

(isqrt 4294967295)
;-> (65535)

(isqrt 4294967296)
;-> nil

(* 4294967296L 4294967296L)
;-> 18446744073709551616L


-------------------------------
Ricerca binaria (binary search)
-------------------------------

La "ricerca binaria" è un algoritmo di ricerca che individua l'indice di un determinato valore in un insieme ordinato di dati. Se il valore non esiste allora l'indice vale -1.
Questo algoritmo cerca un elemento all'interno di una lista ordinata, effettuando mediamente meno confronti rispetto ad una ricerca sequenziale, e quindi più rapidamente rispetto ad essa perché, sfruttando l'ordinamento, dimezza l'intervallo di ricerca ad ogni passaggio.
L'algoritmo è simile a quello della ricerca di una parola sul dizionario: sapendo che il vocabolario è ordinato alfabeticamente, l'idea è quella di iniziare la ricerca non dal primo elemento, ma da quello centrale, cioè a metà del dizionario. Si confronta questo elemento con quello cercato:
- se corrisponde, la ricerca termina indicando che l'elemento è stato trovato;
- se è superiore, la ricerca viene ripetuta sugli elementi precedenti (ovvero sulla prima metà del dizionario), scartando quelli successivi;
- se invece è inferiore, la ricerca viene ripetuta sugli elementi successivi (ovvero sulla seconda metà del dizionario), scartando quelli precedenti.
Se tutti gli elementi vengono scartati, la ricerca termina senza aver trovato il valore.
La ricerca binaria non usa mai più di floor(log(2) N) (logaritmo base 2 di N approssimato per eccesso) confronti.

Attenzione che questo algoritmo è più difficile di quanto sembri da scrivere. Jon Bentley, nel suo libro "Programming Pearls", riferisce che il 90% dei programmatori professionisti non è in grado di scrivere una corretta implementazione della ricerca binaria in due ore, e Donald Knuth, nel secondo volume della sua opera "The Art of Computer Programming", riporta che sebbene il primo codice per la ricerca binaria fu pubblicato nel 1946, la prima ricerca binaria senza errori non fu pubblicata fino al 1962.

Scriviamo questo algoritmo sia in versione iterativa che in versione ricorsiva (e speriamo di farlo correttamente).

Versione iterativa:

(define (bs num lst)
  (local (basso alto indice)
    (setq out -1) ; elemento non trovato
    (setq basso 0) ; inizio lista
    (setq alto (- (length lst) 1)) ; fine lista
    (while (and (>= alto basso) (= out -1))
      (setq indice (>> (+ basso alto))) ; valore centrale indice
      (cond ((> (lst indice) num)
             (setq alto (- indice 1))) ; aggiorno l'indice "alto"
            ((< (lst indice) num)
             (setq basso (+ indice 1))) ; aggiorno l'indice "basso"
            (true (setq out indice)) ; elemento trovato
      )
    );while
    out
  );local
)

(bs 2 '(-31 0 1 2 3 4 65 83 99 782))
;-> 3

(bs -2 '(-31 0 1 2 2 4 65 83 99 782))
;-> -1

La funzione non è in grado di trovare il numero se la lista è ordinata in modo decrescente:

(bs 2 '(782 99 83 65 4 3 2 1 0 -31))
;->  -1 ;il valore 2 esiste con indice 6.

Aggiungiamo un parametro che ci permette di specificare l'ordinamento della lista:
1) > la lista è ordinata in modo crescente
2) < la lista è ordinata in modo decrescente

(define (bs num lst op)
  (local (basso alto indice)
    (setq out -1)
    (setq basso 0)
    (setq alto (- (length lst) 1))
    (while (and (>= alto basso) (= out -1))
      (setq indice (>> (+ basso alto))) ;; right shift
      (cond ((> (lst indice) num)
             (if (= op >) ;controllo dell'ordinamento della lista
                (setq basso (+ indice 1))
                (setq alto (- indice 1))
             ))
            ((< (lst indice) num)
             (if (= op >) ;controllo dell'ordinamento della lista
                (setq alto (- indice 1))
                (setq basso (+ indice 1))
             ))
            (true (setq out indice))
      )
    );while
    out
  );local
)

(bs 2 '(-31 0 1 2 3 4 65 83 99 782) <)
;-> 3

(bs -2 '(-31 0 1 2 2 4 65 83 99 782) >)
;-> -1

(bs 2 '(782 99 83 65 4 3 2 1 0 -31) >)
;-> 6

(bs -2 '(782 99 83 65 4 3 2 1 0 -31) <)
;-> -1

(bs 1 '() >)
;-> -1

(bs 2 '(1 2 2 3) <)
;-> 1 ;restituisce il primo valore del 2

Vediamo la versione ricorsiva:

(define (bs-r num lst op)
  (define (bsr num lst basso alto op)
    (setq indice (>> (+ basso alto)))
    (cond ((< alto basso) -1)
          ((> (lst indice) num)
              (if (= op >)
                  (bsr num lst basso (- indice 1) op)
                  (bsr num lst (+ indice 1) alto op)))
          ((< (lst indice) num)
              (if (= op >)
                  (bsr num lst (+ indice 1) alto op)
                  (bsr num lst basso (- indice 1) op)))
          (true indice)
    );cond
  )
  (if (= lst '())
    -1
    (bsr num lst 0 (length lst) op)
  )
)

(bs-r 2 '(-31 0 1 2 3 4 65 83 99 782) >)
;-> 3

(bs-r -2 '(-31 0 1 2 2 4 65 83 99 782) >)
;-> -1

(bs-r 2 '(782 99 83 65 4 3 2 1 0 -31) <)
;-> 6

(bs-r -2 '(782 99 83 65 4 3 2 1 0 -31) <)
;-> -1

(bs-r 1 '() >)
;-> -1

(bs-r 2 '(1 2 2 3) >)
;-> 2 ;restituisce il secondo valore del 2


--------------------
Frazione generatrice
--------------------

Qual è la frazione generatrice di 1.42703703703...? (il 703 si ripete infinite volte)

1.42703 = (142703 - 152)/99900

Come verifica possiamo calcolare:

152651 / 99900 = 1.42703703703...

Definiamo l'algoritmo di calcolo della frazione generatrice:

Consideriamo ad esempio il numero 1.42703703703..., con le cifre 703 che si ripetono infinite volte.

- si dice periodo il gruppo di cifre che si ripete (nell'esempio, il periodo è 703)
- si dice antiperiodo il gruppo di cifre che sta tra la virgola (punto) e il periodo (nell'esempio, l'antiperiodo è 42)

se l’antiperiodo non c’è, si parla di numero periodico semplice (ad esempio 1,6666... è un numero periodico semplice)

se invece l’antiperiodo è presente, si parla di numero periodico misto (ad esempio 1,3777... è un numero periodico misto)

L'algoritmo è il seguente:

Per costruire la frazione generatrice di un numero decimale periodico si calcola:

1) al numeratore, il numero dato senza la virgola (punto) e senza il segno di periodo, meno (sottrazione) tutto ciò che sta prima del periodo;

2) al denominatore, tanti 9 quante sono le cifre del periodo, seguiti da tanti 0 quante sono le cifre dell’antiperiodo.

3) Dopo aver fatto queste operazioni dobbiamo ridurre la frazione numeratore/denominatore ai minimi termini.

Nel nostro caso:

numero = 1.42(703)
periodo = 703
numero cifre periodo = 3
antiperiodo = 42
numero cifre antiperiodo = 2

Quindi:

N = 142708 - 142

D = 99900 (perchè periodo di 3 cifre --> 999 e antiperiodo di 2 cifre --> 00)

La nostra funzione avrà tre parametri:
                     ___
1) il numero "n" 1.42703
2) in numero di cifre del periodo "np" (3)
3) in numero di cifre dell'antiperiodo "na" (2)

(define (fraz-gen num np na)
  (local (n n1 n2 d d1 d2 t1 t2 temp)
     ; calcolo numeratore
    (setq n1 (mul num (pow 10 (add np na))))
    ;(setq n2 (int (mul num (pow 10 na))))
    (setq n2 (int (mul num (pow 10 na))) 0 10)
    (setq n (sub n1 n2))
    ; calcolo denominatore
    (setq d1 (dup "9" np))
    (setq d2 (dup "0" na))
    (setq d (int (append d1 d2)))
    ;semplifica numeratore/denominatore
    (setq t1 n)
    (setq t2 d)
    (while (!= t2 0)
      (setq temp t2)
      (setq t2 (% t1 temp))
      (setq t1 temp)
    )
    (setq n (/ n t1))
    (setq d (/ d t1))
    ; risultato
    (list n d (div n d))
  )
)

(fraz-gen 1.625 2 1)
;-> (1609 990 1.625252525252525)

(fraz-gen 1.42703 3 2)
;-> (3853 2700 1.427037037037037)

(fraz-gen 10.52803 2 3)
;-> (13897 1320 10.5280303030303)

(fraz-gen 1.2 1 0)
;-> (11 9 1.222222222222222)

(fraz-gen 3.141592 1 5)
;-> (2827433 900000 3.141592222222222)

Nota:
I numeri che hanno come periodo la sola cifra 9 non esistono.
Infatti matematicamente 1.999... = 2.

(fraz-gen 1.9 1 0)
;-> (2 1 2)

(fraz-gen 3.14159 1 4)
;-> (3927 1250 3.1416)

Nota: per un numero non periodico consideriamo lo 0 finale come periodo, per esempio:

1.625 => 1.625(0) con periodo (0) lungo 1 e antiperiodo (625) lungo 3

(fraz-gen 1.625 1 3)
;-> (13 8 1.625)


---------------
Il numero aureo
---------------

Il numero aureo (o rapporto aureo) è il numero ottenuto effettuando il rapporto fra due lunghezze disuguali delle quali la maggiore "a" è medio proporzionale tra la minore "b" e la somma delle due (a+b):
                        
numero aureo (phi) --> (a + b) : a = a : b

Quindi possiamo scrivere:

phi = (a + b)/a = 1 + b/a = 1 + 1/phi

            1
phi = 1 + -----
           phi

Che porta alla seguente equazione di secondo grado:

phi^2 - phi - 1 = 0

Che ha la seguente soluzione (positiva):

phi = (1 + (sqrt 5))/2 = 1.6180339887...

Quindi phi è un numero irrazionale.

Cerchiamo di calcolarlo con il metodo del punto fisso.
La funzione di cui ricerchiamo il punto fisso vale:

phi = 1 + 1/phi

Poniamo il punto fisso iniziale a uno: phi0 = 1

(setq phi0 1)
(setq phi phi0)
(while (!= phi (add 1 (div 1 phi)))
  (setq phi (add 1 (div 1 phi)))
)
;-> 1.618033988749895

Possiamo utilizzare anche la funzione predefinita "series":

(series 1 (fn (x) (div (add 1 x))) 20)
;-> (1 0.5 0.6666666 0.6 0.625 0.6153846 0.619047 0.6176470 0.6181818
;->  0.6179775 0.6180555 0.6180257 0.6180371 0.6180327 0.6180344
;->  0.6180338 0.6180340 0.6180339 0.6180339 0.6180339)

Utilizziamo la funzione "series" per approssimare sqrt(2) = 1.414213562373095:

(series 1 (fn (x) (add 1 (div (add 1 x)))) 20)
;-> (1 1.5 1.4 1.416666666666667 1.413793103448276 1.414285714285714 1.414201183431953
;->  1.41421568627451 1.414213197969543 1.41421362489487 1.414213551646055 1.414213564213564
;->  1.41421356205732 1.414213562427273 1.4142135623638 1.41421356237469 1.414213562372821
;->  1.414213562373142 1.414213562373087 1.414213562373097)


--------------------------
Equazioni di secondo grado
--------------------------

Scriviamo una funzione che calcola le soluzioni di una equazione di secondo grado:

; Equazione di secondo grado: (a*x^2 + b*x + c = 0)
; Soluzioni:
; x1 = -b/(2*a) + (sqrt(b*b - 4*a*c))/(2*a)
; x2 = -b/(2*a) - (sqrt(b*b - 4*a*c))/(2*a)

(define (solve-quadratic a b c)
  (if (and (null? a) (null? b) (null? c))
      (begin
        (println "(solve-quadratic a b c)")
        (println "Calcola le soluzioni dell'equazione: a*x^2 + b*x + c = 0")
        (print {})
      )
  ; else
  (local (x1 i1 x2 i2 delta)
    (setq delta (sub (mul b b) (mul 4 a c)))
    (println delta)
    (cond ((= a 0) ; equazione di primo grado
            (if (!= b 0) (setq x1 (sub 0 (div c b)))))
          ((> delta 0) ; due radici reali
            (setq x1 (div (add (sub 0 b) (sqrt delta)) (mul 2 a)))
            (setq x2 (div (sub (sub 0 b) (sqrt delta)) (mul 2 a)))
            (setq i1 0.0)
            (setq i2 0.0))
          ((< delta 0) ; due radici complesse
            (setq x1 (div (sub 0 b) (mul 2 a)))
            (setq x2 (div (sub 0 b) (mul 2 a)))
            (setq i1 (div (sqrt (sub 0 delta)) (mul 2 a)))
            (setq i2 (sub 0 (div (sqrt (sub 0 delta)) (mul 2 a)))))
          (true
          ;((= delta 0) ; due radici coincidenti
            (setq x1 (sub 0 (div b (mul 2 a))))
            (setq x2 (sub 0 (div b (mul 2 a)))))
    )
    (list (list x1 i1) (list x2 i2))
  )
  ) ;endif
)

(solve-quadratic)
;-> (solve-quadratic a b c)
;-> Calcola le soluzioni dell'equazione: a*x^2 + b*x + c = 0

(solve-quadratic -3 -3 -20)
;-> -231
;-> ((-0.5 -2.533114025595111) (-0.5 2.533114025595111))

(solve-quadratic 3 3 -20)
;-> 249
;-> ((2.129955639676583 0) (-3.129955639676583 0))

(solve-quadratic 3 -3 -20)
;-> 249
;-> ((3.129955639676583 0) (-2.129955639676583 0))

(solve-quadratic -3 -3 20)
;-> 249
;-> ((-3.129955639676583 0) (2.129955639676583 0))

(solve-quadratic 3 3 20)
;-> -231
;-> ((-0.5 2.533114025595111) (-0.5 -2.533114025595111))

(solve-quadratic 0 10 20)
;-> 100
;-> ((-2 nil) (nil nil))


------------------------
Equazione di terzo grado
------------------------

Scriviamo una funzione che calcola le soluzioni di una equazione di terzo grado:

; Equazione di terzo grado: (a*x^3 + b*x^2 + c*x + d = 0)
; Per l'algoritmo di soluzione vedere i seguenti link:
; http://mathworld.wolfram.com/CubicFormula.html
; https://courses.cs.washington.edu/courses/cse590b/13au/lecture_notes/cubic.pdf
; https://courses.cs.washington.edu/courses/cse590b/13au/lecture_notes/solvecubic_p2.pdf

(define (solve-cubic a b c d)
  (local (x1 x2 x3 i1 i2 i3 F G H I J K L M N P Q R S T U)
    (setq x1 0 x2 0 x3 0 i1 0 i2 0 i3 0)
    ; Calcolo discriminanti F, G, H
    ; F = (3*(c/a) - (b*b)/(a*a)) / 3
    (setq F (div (sub (mul 3 (div c a)) (div (mul b b) (mul a a))) 3))
    ; (println "F = " F)
    ; G = ((2*(b*b*b)/(a*a*a)) - (9*b*c/(a*a)) + (27*(d/a))) / 27
    (setq G (div (add (sub (mul 2 (div (mul b b b) (mul a a a))) (div (mul 9 b c) (mul a a))) (mul 27 (div d a))) 27))
    ; (println "G = " G)
    ; H = ((G*G)/4) + ((F*F*F)/27)
    (setq H (add (div (mul G G) 4) (div (mul F F F) 27)))
    ; (println "H = " H)
    ; Controllo discriminanti per determinare il tipo delle radici
    (cond ((> H 0) ; una radice reale e due radici complesse
            ; I = -(G/2) + Math.sqrt(H)
            (setq I (sub (sqrt H) (div G 2)))
            ;(println "I = " I)
            ; J = Math.cbrt(I)
            (setq J (my-pow I (div 1 3)))
            ;(println "J = " J)
            ; K = (-G/2) - Math.sqrt(H)
            (setq K (sub (sub 0 (div G 2)) (sqrt H)))
            ;(println "K = " K)
            ; L = Math.cbrt(K)
            (setq L (my-pow K (div 1 3)))
            ;(println "L = " L)
            ; x1 =  (J + L) - (b/(3*a))
            (setq x1 (sub (add J L) (div b (mul 3 a))))
            ; x2 = -(J + L)/2 - (b/(3*a))
            (setq x2 (sub (sub 0 (div (add J L) 2)) (div b (mul 3 a))))
            ; i2 =  (J - L) * Math.sqrt(3)/2
            (setq i2 (mul (sub J L) (div (sqrt 3) 2)))
            ; x3 =  x2
            (setq x3 x2)
            ; i3 = -i2
            (setq i3 (sub 0 i2)))
          ((and (zero? F) (zero? G) (zero? H)) ; tre radici reali coincidenti
            ; x1 = Math.cbrt(d/a) * (-1)
            (setq x1 (sub 0 (my-pow (div d a) (div 1 3))))
            (setq x2 x1)
            (setq x3 x1))
          ((<= H 0) ; tre radici reali
            ; M = Math.sqrt((G*G)/4 - H)
            (setq M (sqrt (sub (div (mul G G) 4) H)))
            ;(println "M = " M)
            ; N = Math.cbrt(M)
            (setq N (my-pow M (div 1 3)))
            ;(println "N = " N)
            ; P = Math.acos(-(G/(2*M)))
            (setq P (acos (sub 0 (div G (mul M 2)))))
            ;(println "P = " P)
            ; Q = N*(-1)
            (setq Q (sub 0 N))
            ;(println "Q = " Q)
            ; R = Math.cos(P/3)
            (setq R (cos (div P 3)))
            ;(println "R = " R)
            ; S = Math.sqrt(3) * Math.sin(P/3)
            (setq S (mul (sqrt 3) (sin (div P 3))))
            ;(println "S = " S)
            ; T = (b/(3*a)) * (-1)
            (setq T (sub 0 (div b (mul 3 a))))
            ;(println "T = " T)
            ; x1 = 2*N*Math.cos(P/3) - (b/(3*a))
            (setq x1 (sub (mul 2 N (cos (div P 3))) (div b (mul 3 a))))
            ; x2 = Q * (R + S) + T
            (setq x2 (add T (mul Q (add R S))))
            ; x3 = Q * (R - S) + T;
            (setq x3 (add T (mul Q (sub R S)))))
          (true (println "errore"))
    );cond
    (list (list x1 i1) (list x2 i2) (list x3 i3))
  );local
)

; calcola anche le potenze di numeri negativi con esponenti non interi
(define (my-pow x n)
  (if (< x 0)
      ; cambio segno a x, calcolo la potenza, cambio segno al risultato
      (sub 0 (pow (sub 0 x) n))
      (pow x n)))

(pow 3 0.33)
;-> 1.436977652184852
(pow -3 0.33)
;-> 1.#IND
(my-pow 3 0.33)
;-> 1.436977652184852
(my-pow -3 0.33)
;-> -1.442249570307408

Vediamo alcuni esempi:

; una radice reale e due radici complesse
; (x-2)*(x-(2+8i))*(x-(2-8i)) = 0
; x^3 - 6x^2 + 76x - 136 = 0
(solve-cubic 1 -6 76 -136)
;-> ((2 0) (2 7.999999999999999) (2 -7.999999999999999))

; tre radici reali coincidenti
; (x - 2)*(x - 2)*(x - 2) = 0
; x^3 - 6 x^2 + 12 x - 8 = 0
(solve-cubic 1 -6 12 -8)
;-> ((2 0) (2 0) (2 0))

; tre radici reali distinte
; (x-1)*(x+4)*(x-2) = 0
; x^3 + x^2 - 10 x + 8 = 0
(solve-cubic 1 1 -10 8)
;-> ((2 0) (-4 0) (1 0))

; una radice reale e due radici complesse
; 3x^3 - 2x^2 + 4x - 3 = 0
(solve-cubic 3 -2 4 -3)
;-> ((0.7263732804864121 0)
;->  (-0.02985330690987276 1.172949872052025)
;->  (-0.02985330690987276 -1.172949872052025))


------------------------
Sistemi Lineari (Cramer)
------------------------

Proviamo a scrivere un programma che risolve i sistemi lineari.
Utilizzeremo il metodo di Cramer perchè newLISP mette a disposizione una funzione standard per calcolare il determinante di una matrice.

****************
>>>funzione DET
****************
sintassi: (det matrix [float-pivot])

Restituisce il determinante di una matrice quadrata. Una matrice può essere una lista nidificata o un vettore (array).

Opzionalmente 0.0 o un valore molto piccolo può essere specificato in float-pivot. Questo valore sostituisce gli elementi pivot nell'algoritmo di decomposizione LU, che risulta zero quando l'algoritmo incontra una matrice singolare.

(set 'A '((-1 1 1) (1 4 -5) (1 -2 0)))
(det A)
;-> -0.9999999999999998

; trattamento di una matrice singolare
(det '((2 -1) (4 -2)))
;-> nil
(det '((2 -1) (4 -2)) 0)
-0
(det '((2 -1) (4 -2)) 1e-20)
;-> -4e-20

Se la matrice è singolare e float-pivot non è specificato, viene restituito nil.

Vediamo alcuni esempi di risoluzione di un sistema lineare.

Esempio 1

  x + 2y + 3z =  1
-3x - 2y + 3z = -1
 4x - 5y + 2z =  1

Soluzione
 x = detX/det
 y = detY/det
 z = detZ/det

 x = 21/58, y = 4/29, z = 7/58
 x≈0.36207, y≈0.13793, z≈0.12069

Impostiamo i valori della matrice:

(setq m '((1 2 3) (-3 -2 3) (4 -5 2)))
;-> ((1 2 3) (-3 -2 3) (4 -5 2))

Calcoliamo il determinante:

(setq det-m (det m))
;-> 116

Impostiamo il vettore dei termini noti:

(setq n '(1 -1 1))

Calcoliamo determinante per la variabile x sostituendo prima la colonna 0 della matrice con i valori della colonna dei termini noti:

(setf (m 0 0) (n 0))
(setf (m 1 0) (n 1))
(setf (m 2 0) (n 2))
m
;-> ((1 2 3) (-1 -2 3) (1 -5 2))

Calcoliamo il determinante di x:

(setq detX (det m))
;-> 42

Calcoliamo la soluzione per x:

(setq x (div detX det-m))
;-> 0.3620689655172414

Impostiamo i valori della matrice:
(setq m '((1 2 3) (-3 -2 3) (4 -5 2)))

Calcoliamo determinante per la variabile y sostituendo prima la colonna 1 della matrice con i valori della colonna dei termini noti:

(setf (m 0 1) (n 0))
(setf (m 1 1) (n 1))
(setf (m 2 1) (n 2))
m
;-> ((1 1 3) (-3 -1 3) (4 1 2))

Calcoliamo il determinante di y:

(setq detY (det m))
;-> 16

Calcoliamo la soluzione per y:

(setq y (div detY det-m))
;-> 0.1379310344827586

Impostiamo i valori della matrice:
(setq m '((1 2 3) (-3 -2 3) (4 -5 2)))

Calcoliamo determinante per la variabile z sostituendo prima la colonna 2 della matrice con i valori della colonna dei termini noti:

(setf (m 0 2) (n 0))
(setf (m 1 2) (n 1))
(setf (m 2 2) (n 2))
m
;-> ((1 2 1) (-3 -2 -1) (4 -5 1))

Calcoliamo il determinante di z:

(setq detZ (det m))
;-> 14

Calcoliamo la soluzione per z:

(setq z (div detZ det-m))
;-> 0.1206896551724138

Esempio 2

 2x + y +  z =  1
 4x - y +  z = -5
 -x + y + 2z =  5

Soluzione
x = detX/det
y = detY/det
z = detZ/det

x = -1, y = 2, z = 1

Impostiamo i valori della matrice:

(setq m '((2 1 1) (4 -1 1) (-1 1 2)))
m
;-> ((2 1 1) (4 -1 1) (-1 1 2))

Calcoliamo il determinante:

(setq det-m (det m))
;-> -12
(setq n '(1 -5 5))

Calcoliamo determinante per la variabile x sostituendo prima la colonna 0 della matrice con i valori della colonna dei termini noti:

(setf (m 0 0) (n 0))
(setf (m 1 0) (n 1))
(setf (m 2 0) (n 2))
m

Calcoliamo il determinante di x:

(setq detX (det m))
;-> 12

Calcoliamo la soluzione per x:
(setq x (/ detX det-m))
;-> -1

Impostiamo i valori della matrice:
(setq m '((2 1 1) (4 -1 1) (-1 1 2)))

Calcoliamo determinante per la variabile y sostituendo prima la colonna 1 della matrice con i valori della colonna dei termini noti:

(setf (m 0 1) (n 0))
(setf (m 1 1) (n 1))
(setf (m 2 1) (n 2))
m

Calcoliamo il determinante di y:

(setq detY (det m))
;-> 24

Calcoliamo la soluzione per y:

(setq y (/ detY det-m))
;-> 2

Impostiamo i valori della matrice:

(setq m '((2 1 1) (4 -1 1) (-1 1 2)))

Calcoliamo determinante per la variabile z sostituendo prima la colonna 2 della matrice con i valori della colonna dei termini noti:

(setf (m 0 2) (n 0))
(setf (m 1 2) (n 1))
(setf (m 2 2) (n 2))
m

Calcoliamo il determinante di z:

(setq detZ (det m))
;-> -12

Calcoliamo la soluzione per z:

(setq z (/ detZ det-m))
;-> 1

Scriviamo la funzione:

(define (cramer matrice noti)
  (local (dim detm det-i sol copia)
    (setq dim (length matrice))
    (setq sol '())
    (setq copia matrice)
    (setq detm (det copia 0.0))
    ; la soluzione è indeterminata se il determinante vale zero.
    (if (= detm 0) (setq sol nil)
    ;(println detm)
      (for (i 0 (- dim 1))
        (for (j 0 (- dim 1))
          (setf (copia j i) (noti j))
        )
        ; 0.0 -> restituisce 0 (invece di nil),
        ; quando la matrice è singolare
        (setq det-i (det copia 0.0))
        (push (div det-i detm) sol -1)
        (setq copia matrice)
      );endfor
    );endif
    sol
  );local
)

(cramer '((2 1 1) (4 -1 1) (-1 1 2)) '(1 -5 5))
;-> (-1 2 1)

(cramer '((1 2 3) (-3 -2 3) (4 -5 2)) '(1 -1 1))
;-> (0.3620689655172414 0.1379310344827586 0.1206896551724138)

Proviamo con un sistema 8x8:

(cramer
'((2 3 3 -4 -5 3 -2 3)
  (-3 3 -1 2 3 5 -2 3)
  (4 2 4 -4 -2 3 -1 -5)
  (-3 2 2 -4 -1 4 -1 -5)
  (2 6 -3 -4 -4 3 -2 -3)
  (2 -6 -1 3 -3 4 -1 -1)
  (3 -1 -2 -3 -1 3 1 1)
  (1 -2 -3 4 -1 -3 2 3))
'(1 -1 1 2 3 2 -2 2))
;-> (-0.2907517086232766 0.4541737926192612 0.1222139219887456 0.7272295937332997
;->  -0.9577686974650513 0.1669345810796059 0.682061578219236 -0.3880884752566235)

Nota: La regola di Cramer è inadatta per N grande (es. N > 12), sia per l'accuratezza numerica e la sensibilità agli errori, sia perché è molto lenta rispetto ad altri algoritmi.


-----------------------
Sistemi lineari (Gauss)
-----------------------

Per risolvere un sitema lineare utilizzeremo il metodo di eliminazione di Gauss con pivot e poi sostituzione all'indietro (Gaussian elimination with pivot and then backwards substitution).
Per maggiori informazioni sull'algoritmo:

https://it.wikipedia.org/wiki/Metodo_di_eliminazione_di_Gauss

; risolve il sistema lineare A*x = b
(define (gauss A b)
  (local (n m p rowx amax xfac temp temp1 x)
    (setq rowx 0) ;conta il numero di scambio righe
    (setq n (length A))
    (setq x (dup '0 n))
    (for (k 0 (- n 2))
      (setq amax (abs (A k k)))
      (setq m k)
      ; trova la riga con il pivot più grande
      (for (i (+ k 1) (- n 1))
        (setq xfac (abs (A i k)))
        (if (> xfac amax) (setq amax xfac m i))
      )
      ; scambio delle righe
      (if (!= m k) (begin
          (++ rowx)
          (setq temp1 (b k))
          (setq (b k) (b m))
          (setq (b m) temp1)
          (for (j k (- n 1))
            (setq temp (A k j))
            (setq (A k j) (A m j))
            (setq (A m j) temp)
          ))
      )
      (for (i (+ k 1) (- n 1))
        (setq xfac (div (A i k) (A k k)))
        (for (j (+ k 1) (- n 1))
          (setq (A i j) (sub (A i j) (mul xfac (A k j))))
        )
        (setq (b i) (sub (b i) (mul xfac (b k))))
      )
    )
    ; sostituzione all'indietro (backward sostitution)
    (for (j 0 (- n 1))
      (setq p (sub n j 1))
      (setq (x p) (b p))
      (if (<= (+ p 1) (- n 1))
        (for (i (+ p 1) (- n 1))
          (setq (x p) (sub (x p) (mul (A p i) (x i))))
        )
      )
      (setq (x p) (div (x p) (A p p)))
    )
    x
  ); local
)

(gauss '((2 1 1) (4 -1 1) (-1 1 2)) '(1 -5 5))
;-> (-1 2 1)

(gauss '((1 2 3) (-3 -2 3) (4 -5 2)) '(1 -1 1))
;-> (0.3620689655172414 0.1379310344827586 0.1206896551724138)

(setq matrice '((1 1 1 0 0 0 -10 -10)
 (0 0 0 1 1 1 -2 -2)
 (5 1 1 0 0 0 -65 -13)
 (0 0 0 5 1 1 -25 -5)
 (5 5 1 0 0 0 -60 -60)
 (0 0 0 5 5 1 -55 -55)
 (1 5 1 0 0 0 -9 -45)
 (0 0 0 1 5 1 -8 -40)))

(setq noti '(10 2 13 5 12 11 9 8))
;-> (10 2 13 5 12 11 9 8)

(gauss matrice noti)
;-> (0.7500000000000002 -0.2499999999999999 9.5 0.7500000000000002
;->  1.5 -0.2500000000000003 2.379049338482478e-017 7.930164461608264e-018)

Arrotondiamo a 4 cifre decimali dopo la virgola:

(map (fn (x) (round x -4)) (gauss matrice noti))
;-> (0.75 -0.25 9.5 0.75 1.5 -0.25 0 0)

Vediamo la differenza di velocità tra il metodo di Cramer e il metodo di Gauss:

(time (gauss matrice noti) 10000)
;-> 667.316

(time (cramer matrice noti) 10000)
;-> 318.691

Proviamo con un sistea 16x16:

(setq matrice '((1 1 1 0 0 0 -10 -10 -20 -22 -10 -12 -14 -16 22 -42)
 (0 0 0 -1 1 -1 0 0 0 -1 1 1 1 1 -2 -2)
 (5 1 1 0 0 0 5 -1 1 0 0 0 0 0 -65 -13)
 (0 0 0 5 1 1 0 0 0 5 1 -1 1 1 -25 -5)
 (5 5 1 0 0 0 5 -5 1 0 0 0 0 0 -60 -60)
 (0 0 0 5 5 1 0 0 0 5 5 1 -5 1 -55 -55)
 (1 5 1 0 0 0 1 5 -1 0 0 0 0 0 -9 -45)
 (0 0 0 1 5 2 0 0 0 1 -5 2 -5 2 -3 -40)
 (0 4 0 6 5 0 0 4 0 6 5 0 5 0 -8 -30)
 (1 0 4 1 5 1 1 0 4 1 -5 1 5 -1 -8 -40)
 (1 3 3 4 8 2 1 3 3 4 -8 2 8 2 -5 -64)
 (1 3 4 3 -4 2 1 3 3 3 4 2 4 2 -1 -14)
 (2 4 3 1 5 -2 2 4 3 1 0 2 5 2 -1 -24)
 (1 5 3 9 6 2 -1 5 3 9 6 0 6 2 -1 -34)
 (3 6 3 1 7 2 3 -6 3 1 7 2 0 2 -1 -44)
 (9 2 1 1 5 6 9 2 -1 1 5 6 5 0 -6 -74)))

(setq noti '(10 -2 13 -5 12 11 9 -8 -10 12 -18 10 20 16 8 6))

(cramer matrice noti)
;-> (6.073265713499919
;-> -7.895511516493116
;-> 1.832360106508081
;-> 3.230429811886619
;-> -1.455619886107596
;-> -6.476253322763236
;-> 3.679036826897333
;-> 2.718120581717722
;-> 6.958059613240136
;-> -3.641846643266388
;-> 2.958481343355023
;-> -12.86237050078677
;-> -2.628371168374938
;-> 4.849669122127303
;-> 0.6839772385617239
;-> -0.8092477063837188)

(gauss matrice noti)
;-> (6.073265713499932
;->  -7.895511516493109
;->  1.832360106508014
;->  3.230429811886656
;->  -1.455619886107596
;->  -6.476253322763209
;->  3.679036826897329
;->  2.718120581717728
;->  6.958059613240156
;->  -3.641846643266435
;->  2.958481343355025
;->  -12.86237050078677
;->  -2.628371168374938
;->  4.849669122127305
;->  0.6839772385617227
;->  -0.8092477063837177)

(time (gauss matrice noti) 10000)
;-> 4114.972

(time (cramer matrice noti) 10000)
;-> 1526.089

La funzione built-in "det" è molto veloce...


-------------
Numeri Brutti
-------------

I numeri Brutti sono numeri positivi i cui fattori primi includono solo 2, 3, 5. Ad esempio, 6, 8
sono brutti mentre 14 non è brutto in quanto include un altro fattore primo 7. Notare che 1 è
trattato come un numero brutto.
Scrivere un programma per trovare l'n-esimo numero Brutto.

Prima scriviamo una funzione per verificare se un dato numero è un numero Brutto:

(define (brutto? num)
  (cond ((= 0 num) nil)
        ((= 1 num) true)
        ((= 0 (% num 2)) true)
        ((= 0 (% num 3)) true)
        ((= 0 (% num 5)) true)
  )
)

(map brutto? (sequence 1 10))
;-> (true true true true true true nil true true true)

Poi scriviamo il programma per trovare l'n-esimo numero Brutto:

(define (brutto num)
  (local (conta out)
    (setq out '())
    (setq conta 0)
    (setq n 0)
    (while (< conta num)
      (if (brutto? n) (begin (++ conta) (push n out -1)))
      (++ n)
    )
    (last out)
  )
)

(brutto 10)
;-> 12

(brutto 10000)
;-> 13635


-----------------
Numeri Poligonali
-----------------

Un numero poligonale è un numero che può essere rappresentato mediante uno schema geometrico regolare in modo da raffigurare un poligono regolare.

I numeri poligonali derivano dalle seguenti operazioni:

1 + 1 + 1 + 1 + 1 + ...    genera numeri interi       1, 2, 3, 4, 5 ...
1 + 2 + 3 + 4 + 5 + ...    genera numeri triangulari  1, 3, 6, 10, 15 ...
1 + 3 + 5 + 7 + 9 + ...    genera numeri quadrati     1, 4, 9, 16, 25 ...
1 + 4 + 7 + 10 + 13 + ...  genera numeri pentagonali  1, 5, 12, 22, 35 ...
1 + 5 + 9 + 13 + 17 + ...  genera numeri esagonali    1, 6, 15, 28, 45 ...
1 + 6 + 11 + 16 + 21 + ... genera numeri eptagonali   1, 7, 18, 34, 55 ...
1 + 7 + 13 + 19 + 25 + ... genera numeri ottagonali   1, 8, 21, 40, 65 ...

Formule:
numeri triangolari = (n * (n - 1))/2
numeri quadrati    = n * n
numeri pentagonali = (n * (3*n - 1))/2
numeri esagonali   = n * (2*n - 1)
numeri eptagonali  = (5*n*n - 3*n)/2
numeri ottagonali  = (3*n*n - 2*n)
...
numeri p-gonali = p*n*(n - 1)/2 - n*(n - 2)

I numeri triangolari possono essere ottenuti anche in modo ricorsivo:

T(1) = 1
T(n) = T(n-1) + n per n > 1

Definiamo una funzione che calcola il numero n-esimo del numero poligonale con p lati:

(define (numpoligonale p n)
  (- (/ (* p n (- n 1)) 2) (* n (- n 2)))
)

(numpoligonale 3 2)
;-> 3

(numpoligonale 3 3)
;-> 6

(numpoligonale 8 5)
;-> 65

Adesso definiamo una funzione che costruisce una lista di n numeri poligonali con p lati:

(define (numpoligonale-list tipo num)
  (local (out)
    (setq out '())
    (for (x 1 num)
       ;(println out)
       (extend out (list(numpoligonale tipo x)))
    )
    ;(reverse _out)
  )
)

(numpoligonale-list 3 20)
;-> (1 3 6 10 15 21 28 36 45 55 66 78 91 105 120 136 153 171 190 210)

(numpoligonale-list 6 10)
;-> 1 6 15 28 45 66 91 120 153 190)

Nota: Ogni numero esagonale è anche un numero triangolare.

(numpoligonale-list 4 10)
;-> (1 4 9 16 25 36 49 64 81 100)


--------------
Torre di Hanoi
--------------

La Torre di Hanoi è un rompicapo matematico composto da tre paletti e un certo numero di dischi di grandezza decrescente, che possono essere infilati in uno qualsiasi dei paletti.

               paletto A              paletto B           paletto C

                   ||                    ||                  ||
                   ||                    ||                  ||
                +------+                 ||                  ||
disco 1         +------+                 ||                  ||
                   ||                    ||                  ||
             +------------+              ||                  ||
disco 2      +------------+              ||                  ||
                   ||                    ||                  ||
          +------------------+           ||                  ||
disco 3   +------------------+           ||                  ||

Il gioco inizia con tutti i dischi incolonnati su un paletto in ordine decrescente (il disco più piccolo si trova in cima). Lo scopo del gioco è spostare tutti i dischi su un paletto diverso potendo muovere solo un disco alla volta e potendo mettere un disco solo su un altro disco più grande, mai su uno più piccolo.
Il gioco fu inventato nel 1883 dal matematico francese Edouard Lucas. La leggenda narra che in un tempio Indù alcuni monaci sono impegnati a spostare su tre colonne di diamante 64 dischi d'oro secondo le regole della Torre di Hanoi: quando i monaci completeranno il lavoro, il mondo finirà.
La proprietà matematica base è che il numero minimo di mosse necessarie per completare il gioco è (2^n - 1), dove n è il numero di dischi. Ad esempio con 3 dischi, il numero minimo di mosse vale 7. Quindi i monaci di Hanoi dovrebbero effettuare almeno 18.446.744.073.709.551.615 mosse prima che il mondo finisca (n = 64).
La soluzione generale è data dal seguente algoritmo ricorsivo.
Identifichiamo i paletti con le lettere A, B e C, e i dischi con i numeri da 1 (il più piccolo) a n (il più grande). I passi necessari sono:
 - Spostare i primi n-1 dischi da A a B. (Questo lascia il disco n da solo sul paletto A)
 - Spostare il disco n da A a C
 - Spostare n-1 dischi da B a C
Per spostare n dischi si richiede di compiere un'operazione elementare (spostamento di un singolo disco) ed una complessa, ossia lo spostamento di n-1 dischi. Tuttavia anche questa operazione si risolve nello stesso modo, richiedendo come operazione complessa lo spostamento di n-2 dischi. Iterando questo ragionamento si riduce il processo complesso ad uno elementare, ovvero lo spostamento di n - (n-1) = 1 disco.
Questo algoritmo ha una complessità esponenziale.
Si può dimostrare che la Torre di Hanoi è risolvibile per qualsiasi valore di "n".

La seguente funzione risolve il problema della torre di hanoi (con A=1, B=2, C=3):

(define (solve-hanoi n from to using)
  (cond ((> n 0)
         (solve-hanoi (- n 1) from using to)
         (println "da " from " a " to)
         (solve-hanoi (- n 1) using to from))
         (true nil)
  )
)

(solve-hanoi 3 1 3 2)
;-> da 1 a 3
;-> da 1 a 2
;-> da 3 a 2
;-> da 1 a 3
;-> da 2 a 1
;-> da 2 a 3
;-> da 1 a 3
;-> nil

Se vogliamo ottenere la lista delle mosse in una lista possiamo scrivere:

(define (solve-hanoi n from to using)
  (cond ((> n 0)
         (solve-hanoi (- n 1) from using to)
         ;(println "da " from " a " to)
         (push (list from to) sol -1)
         (solve-hanoi (- n 1) using to from))
         (true nil)))

(define (hanoi numdischi start end use)
  (let (sol '())
    (solve-hanoi numdischi start end use)
  sol))

(hanoi 3 1 3 2)
;-> ((1 3) (1 2) (3 2) (1 3) (2 1) (2 3) (1 3))

(hanoi 4 1 3 2)
;-> ((1 2) (1 3) (2 3) (1 2) (3 1) (3 2) (1 2) (1 3)
;->  (2 3) (2 1) (3 1) (2 3) (1 2) (1 3) (2 3))

Infine la seguente funzione mostra la soluzione passo per passo:

(define (print-hanoi numdisk lst)
  (setq stato (list (sequence 1 numdisk) '() '()))
  (println "Stato iniziale")
  (println stato)
  (dolist (el lst)
    (setq da (pop (stato (- (el 0) 1))))
    (push da (stato (- (el 1) 1)))
    ;(println "da " (el 0) " a " (el 1))
    (println (+ $idx 1) ". da: " (char (+ 64 (el 0))) " a: " (char (+ 64 (el 1))))
    (print stato)
    (read-line)
  ))

(print-hanoi 4 (hanoi 4 1 3 2))
;-> Stato iniziale
;-> ((1 2 3 4) () ())
;-> 1. da: A a: B
;-> ((2 3 4) (1) ())
;-> 2. da: A a: C
;-> ((3 4) (1) (2))
;-> 3. da: B a: C
;-> ((3 4) () (1 2))
;-> ...
;-> 14. da: A a: C
;-> (() (1) (2 3 4))
;-> 15. da: B a: C
;-> (() () (1 2 3 4))


------------------
Indovina il numero
------------------

Si tratta di un gioco con due giocatori, il primo pensa ad un numero da 1 a 100 (ad esempio 45).
Il secondo giocatore prova ad indovinare il numero (ad esempio con 40).
Il primo giocatore deve dire se il numero proposto è "uguale" (fine del gioco) "maggiore" (bigger) o "minore" (smaller) del numero che pensato. A questo punto il secondo giocatore propone un nuovo numero, il primo risponde e si continua in questo modo fino a quando non viene indovinato il numero pensato.
Scrivere un programma in cui il computer cerca di indovinare il numero da voi pensato.

(define (indovina-numero)
  (>> (+ small big))) ; restituisce il valore (small + big)/2

(define (smaller)
  (setf big (dec (indovina-numero)))
  (indovina-numero))

(define (bigger)
  (setf small (inc (indovina-numero)))
  (indovina-numero))

(define (inizia-gioco)
  (setf small 1)
  (setf big 100)
  (indovina-numero))

Supponiamo di aver scelto il numero 80 e iniziamo il gioco:

(inizia-gioco)
;-> 50    ; il computer prova con 50
(bigger)  ; il nostro numero è più grande
;-> 75    ; il computer prova con 75
(bigger)  ; il nostro numero è più grande
;-> 88    ; il computer prova con 88
(smaller) ; il nostro numero è più piccolo
;-> 81    ; il computer prova con 88
(smaller) ; il nostro numero è più piccolo
;-> 78    ; il computer prova con 88
(bigger)  ; il nostro numero è più grande
;-> 79    ; il computer prova con 88
(bigger)  ; il nostro numero è più grande
;-> 80    ; il computer ha indovinato il nostro numero


----------------------
Il problema Monty Hall
----------------------

Si tratta di un gioco in cui vengono mostrate al concorrente tre porte chiuse. Dietro ad una si trova il premio, mentre ciascuna delle altre due sono vuote. Il giocatore può scegliere una delle tre porte, vincendo il premio corrispondente. Dopo che il giocatore ha selezionato una porta, ma non l'ha ancora aperta, il conduttore del gioco – che conosce ciò che si trova dietro ogni porta – apre una delle altre due, rivelando una delle due porte vuote, e offre al giocatore la possibilità di cambiare la propria scelta iniziale, passando all'unica porta restante.
Quale comportamento del giocatore (cambiare la porta o rimanere con la scelta iniziale) massimizza la probabilità di vincere il premio?
La soluzione può essere ottenuta in diversi modi (Teorema di Bayes, Diagrammi di Venn, Teorema della probabilità totale), ma noi cercheremo di risolvere il problema tramite la scrittura di funzioni che calcolano le probabilità delle diverse azioni.

Iniziamo con la funzione che cambia sempre la prima scelta:

(define (monty-cambiaporta n)
  (setq vincita 0)
  (dotimes (i n)
    (setq premio (+ 1 (rand 3)))      ; il premio si trova in 1 o 2 o 3
    (setq scelta (+ 1 (rand 3)))      ; la prima scelta vale 1 o 2 o 3
    ; se il premio è diverso dalla scelta, allora abbiamo vinto.
    ; Questo perchè abbiamo scelto sempre di cambiare la scelta con la porta che rimane.
    ; Ricorda che il conduttore elimina sempre una porta vuota,
    ; quindi se non abbiamo indovinato con la prima scelta, cambiando abbiamo sicuramente vinto.
    (if (!= premio scelta) (++ vincita))
  )
  (setq prob-vincita (mul (div vincita n) 100)) ; calcoliamo la percentuale di vincite
)

(monty-cambiaporta 10000)
;-> 66.25 ;il risultato teorico vale 2/3 = 0.666666 [66.66 %]

Adesso scriviamo la funzione che tiene sempre la prima scelta (non cambia mai la porta):

(define (monty-tieneporta n)
  (setq vincita 0)
  (dotimes (i n)
    (setq premio (+ 1 (rand 3)))      ; il premio si trova in 1 o 2 o 3
    (setq scelta (+ 1 (rand 3)))      ; la prima scelta vale 1 o 2 o 3
    ; se il premio è uguale alla scelta, allora abbiamo vinto.
    (if (= premio scelta) (++ vincita))
  )
  (setq prob-vincita (mul (div vincita n) 100)) ; calcoliamo la percentuale di vincite
)

(monty-tieneporta 10000)
;-> 33.42  ;il risultato teorico vale 1/3 = 0.333333 [33.33 %]

Quindi cambiare la porta migliora la probabilità del giocatore di vincere il premio, portandola da 1/3 a 2/3.


--------------------------
Il problema del compleanno
--------------------------

Considerando n persone, quanto vale la probabilità che due persone compiano gli anni nello stesso giorno?
Il problema del compleanno è stato formulato nel 1939 da Richard von Mises.

Per effettuare il calcolo, si ricorre alla formula per la probabilità condizionata con le seguenti ipotesi:
- gli anni sono tutti di 365 giorni
- i giorni dell'anno sono tutti equiprobabili

Il modo più semplice per calcolare la probabilità P(n) che ci siano almeno due persone di un gruppo di n persone che compiano gli anni lo stesso giorno è calcolare dapprima la probabilità P1(n) che ciò non accada. Il ragionamento è questo: data una qualunque persona del gruppo (indipendentemente dalla data del suo compleanno), vi sono 364 casi su 365 in cui il compleanno di una seconda persona avvenga in un giorno diverso, se si considera una terza persona, ci sono 363 casi su 365 in cui compie gli anni in un giorno diverso dalle prime due persone e via dicendo.
In formule, la probabilità che tutti gli n compleanni cadano in date diverse vale:

        364   363         365-n+1           364!
P1(n) = --- * --- * ... * ------- = ----------------------
        365   365           365     365^(n-1) * (365 - n)!

Quindi la probabilità del suo evento complementare, cioè che esistano almeno due compleanni uguali, vale:

                               364!
P(n) = 1 - P1(n) = 1 - ----------------------
                       365^(n-1) * (365 - n)!

Definiamo la funzione fattoriale (per i numeri big integer):

(define (fattoriale n)
  (setq fact 1L)
  (for (x 1L n)
    (setq fact (* fact x))
  );for end
)

La seguente funzione calcola il valore di x!/y! (con x > y)

(define (fattoriali-semplifica x y)
  (setq fact 1L)
  (for (i x (+ 1 y))
    (setq fact (* fact i))
  );for end
)

(fattoriali-semplifica 300 200)
;-> 38807387193016483645683371924167275439580023008808434498936549308160840242981998
;-> 71839239153657492092277838092154244528689124699666247577409105786352279708206119
;-> 37899469540337072285732213325595760757119468974039367680000000000000000000000000L

(/ (fattoriale 300) (fattoriale 200))
;-> 38807387193016483645683371924167275439580023008808434498936549308160840242981998
;-> 71839239153657492092277838092154244528689124699666247577409105786352279708206119
;-> 37899469540337072285732213325595760757119468974039367680000000000000000000000000L

(- (fattoriali-semplifica 300 200) (/ (fattoriale 300) (fattoriale 200)))
;-> 0L

Definiamo la funzione potenza (per i numeri big integer):

(define (potenza n m)
  (setq pot 1L)
  (dotimes (x m)
    (setq pot (* pot n))
  )
  pot
)

;-> 81402749386839761113321L

Adesso possiamo scrivere la funzione finale che calcola le probabilità del problema del compleanno:

(define (compleanno n)
  (setq num (fattoriali-semplifica 364 (- 365 n)))
  (setq den (potenza 365 (- n 1)))
  (sub 1 (div num den))
)

Più concisamente:

(define (compleanno n)
  (sub 1 (div (fattoriali-semplifica 364 (- 365 n)) (potenza 365 (- n 1))))
)

(compleanno 22)
;-> 0.4756953076625502

(compleanno 23)
;-> 0.5072972343239853

(compleanno 30)
;-> 0.7063162427192686

(compleanno 50)
;-> 0.9703735795779884

(compleanno 100)
;-> 0.9999996927510721

I risultati ci dicono che la probabilità che almeno due persone in un gruppo compiano gli anni lo stesso giorno è molto superiore a quanto si potrebbe pensare intuitivamente:
infatti già con 23 persone la probabilità è circa 0.51,
con 30 persone essa supera 0.70,
con 50 persone arriva addirittura a 0.97,
con 100 persone siamo quasi sicuri 0.99999969.
Comunque per ottenere l'evento certo (1) occorre considerare un gruppo di almeno 366 persone.


----------------------
Algoritmo di Karatsuba
----------------------

L'algoritmo di Karatsuba (1960) è un algoritmo di moltiplicazione rapida per moltiplicare numeri interi. La sua complessità è  O(n^log2(3)) (circa O(n^1.585)) mentre la complessità della moltiplicazione normale vale O(n^2). Il metodo di Karatsuba è asintoticamente molto più veloce.

Prendiamo due numeri, x e y.
Esempio: 12345 e 6789.
Troviamo una base b e potenza m per separarli.
Usiamo la base = 10 con m che vale la metà della lunghezza delle cifre dei numeri.
In questo caso, m sarà 2, quindi 10 ^ 2 = 100. Divideremo i 2 numeri usando questo moltiplicatore.
La forma che vogliamo è:

x = x1*b^m + x0
y = y1*b^m + y0

Utilizzando l'esempio:

x1 = 123
x0 = 45

y1 = 67
y2 = 89

b = 10 e m = 2

Quindi:

12345 = 123 * 10^2 + 45
6789 = 67 * 10^2 + 89

L'algoritmo ricorsivo è il seguente:

Se x < 10 o y < 10, restituire x * y. La moltiplicazione a una cifra è il caso base.
Altrimenti:
Sia z2 = karatsuba(x1, y1). x1 e y1 sono le cifre più significative (le variabili locali "alte").
Sia z0 = karatsuba(x0, y0). x0 e y0 sono le cifre meno significative (le variabili locali "basse").
Sia z1 = karatsuba (x1 + y0, x0 + y1) - z0 - z2.

E il risultato è la seguente somma: z2 * b^2m + z1 * b^m + z0

Definiamo la funzione potenza per i numeri interi:

(define (potenza n m)
  (let (pot 1L) (dotimes (x m) (setq pot (* pot n))))
)

(potenza 3 6)
;-> 729L

Definiamo la funzione che implementa l'algoritmo di karatsuba:

(define (karatsuba num1 num2)
  (local (m m2 high1 low1 high2 low2 z0 z1 z2)
    (cond ((or (< num1 10) (< num2 10)) (* num1 num2))
          (true
            (setq m (max (length (string num1)) (length (string num2))))
            (setq m2 (/ m 2))
            (setq n1$ (string num1))
            (setq n2$ (string num2))
            (setq high1 (int (slice n1$ 0 (- (length n1$) m2))))
            (setq low1  (int (slice n1$ (- (length n1$) m2) m2)))
            (setq high2 (int (slice n2$ 0 (- (length n2$) m2))))
            (setq low2  (int (slice n2$ (- (length n2$) m2) m2)))
            ;(println high1 { } low1)
            ;(println high2 { } low2)
            (setq z0 (karatsuba low1 low2))
            (setq z1 (karatsuba (+ low1 high1) (+ low2 high2)))
            (setq z2 (karatsuba high1 high2))
            (+ (* z2 (potenza 10 (* m2 2))) (* (- z1 z2 z0) (potenza 10 m2)) z0)
          )
    )
  );local
)

(karatsuba 12 12)
;-> 144

(karatsuba 13 17)
;-> 221

(karatsuba 120 11)
;-> 1320

(karatsuba 12345 6789)
;-> 83810205

(mul 12345 6789)
;-> 83810205

(time (karatsuba 12345 6789) 10000)
;-> 359.359

Ecco un'altra implementazione dell'algoritmo di Karatsuba:

(define (karatsuba x y)
    (karatsuba1 x y 256)  ; in generale, opportuna potenza di 2 p (x , y < 2p)
)

(define (karatsuba1 x y p)  ; x, y, p: interi non negativi, p potenza di 2
    (if (= p 1)
        (* x y)
        (let ((x1 (/ x p)) (x0 (% x p))
              (y1 (/ y p)) (y0 (% y p))
              (q (/ p 2)))
          (let ((z2 (karatsuba1 x1 y1 q))
                (z0 (karatsuba1 x0 y0 q)))
            (let ((z1 (- (karatsuba1 (+ x1 x0) (+ y1 y0) q) (+ z2 z0))))
              (+ (* z2 p p) (* z1 p) z0)
            )
          )
        )
     )
)

(karatsuba 12 12)
;-> 144

(karatsuba 12345 6789)
;-> 83810205

(time (karatsuba 12345 6789) 10000)
;-> 33347.174

Nota:
Nel caso di rappresentazioni binarie le operazioni di quoziente e prodotto relativi a una potenza di 2 (2^k) si riducono semplicemente a spostamenti (right/left shift) di k cifre.
Analogamente, il resto della divisione per 2^k corrisponde alla selezione delle ultime k cifre.

Per implementare l'algoritmo anche per i numeri big integer dobbiamo tenere conto del carattere "L" al termine di ogni numero intero big integer.

(define (karatsuba num1 num2)
  (local (len1 len2 m m2 high1 low1 high2 low2 z0 z1 z2)
    (cond ((or (< num1 10) (< num2 10)) (* num1 num2))
          (true
            (setq len1 (length (string num1)))
            (if (= (last (string num1)) "L") (-- len1))
            (setq len2 (length (string num2)))
            (if (= (last (string num1)) "L") (-- len2))
            (setq m (max len1 len2))
            (setq m2 (/ m 2))
            (setq n1$ (string num1))
            (if (= (last n1$) "L") (setq n1$ (chop n1$)))
            (setq n2$ (string num2))
            (if (= (last n2$) "L") (setq n2$ (chop n2$)))
            (setq high1 (bigint (slice n1$ 0 (- (length n1$) m2))))
            (setq low1  (bigint (slice n1$ (- (length n1$) m2) m2)))
            (setq high2 (bigint (slice n2$ 0 (- (length n2$) m2))))
            (setq low2  (bigint (slice n2$ (- (length n2$) m2) m2)))
            ;(println high1 { } low1)
            ;(println high2 { } low2)
            (setq z0 (karatsuba low1 low2))
            (setq z1 (karatsuba (+ low1 high1) (+ low2 high2)))
            (setq z2 (karatsuba high1 high2))
            (+ (* z2 (potenza 10 (* m2 2))) (* (- z1 z2 z0) (potenza 10 m2)) z0)
          )
    )
  );local
)

(karatsuba 12345 6789)
;-> 83810205

(karatsuba 9223372036854775807 9223372036854775807)
;-> 85070591730234615847396907784232501249L

(* 9223372036854775807L 9223372036854775807L)
;-> 85070591730234615847396907784232501249L

(time (karatsuba 12345 6789) 10000)
;-> 687.468

La funzione per i big integer è veloce la metà della versione per interi.


-------------------------------
Formati A0, A1, A2, A3, A4, ...
-------------------------------

Formato A0:
Similitudine rettangoli:   s(1)/s(0) = s(2)/s(1) = s(0)/2s(1)
Superficie convenzionale:  s(0)*s(1) = A(0) = 1 mq = 10000 cmq

Lato maggiore formato A0 in cm:
(setq s0 (mul 100 (pow 2 (div 1 4))))
;-> 118.9207115002721

Lato minore formato A0 in cm:
(setq s1 (mul 100 (pow 2 (div -1 4))))
;-> 84.08964152537145

Lato maggiore dei fogli in formato Ak: s(k)

  s(k+2) = s(k) / 2
  s(0) = s0 = 118.9207115002721
  s(1) = s1 = 84.08964152537145

(define (lato k)
; lato: numero reale (misura lato)
; k: numero naturale (indice formato)
    (if (< k 2)
        (if (= k 0) s0 s1)      ; misure conosciute
        (div (lato (- k 2)) 2)  ; piegando due volte la lunghezza dei lati si dimezza
    )
)

(define (formato k)
  (local (s0 s1)
    (setq s0 (mul 100 (pow 2 (div 1 4))))
    (setq s1 (mul 100 (pow 2 (div -1 4))))
    (list (lato (+ k 1)) (lato k))
  )
)

Esempio: lati formato A4
(formato 4)
;-> (21.02241038134286 29.73017787506803)

Esempio: lati formato A2
(formato 2)
;-> (42.04482076268572 59.46035575013605)

Esempio: lati formato A0
(formato 0)
;-> (84.08964152537145 118.9207115002721)

(formato 3)
;-> (29.73017787506803 42.04482076268572)


-----------------------------------
Moltiplicazione del contadino russo
-----------------------------------

Si esegue per mezzo di raddoppi e dimezzamenti successivi.
Esempio: 83*154. Si dimezza il numero 83 (considerando i valori interi) e si raddoppia il 154. Si sommano le righe della colonna del 154 corrispondenti alle righe dispari nella colonna del numero 83. Totale: 12782.

      dispari  -->  83  |   154  <--
      dispari  -->  41  |   308  <--
                    20  |   616
                    10  |  1232
      dispari  -->   5  |  2464  <--
                     2  |  4928
      dispari  -->   1  |  9856  <--
                         -------
154 + 308 + 2464 + 9856 = 12782

(* 83 154)
;-> 12782

(+ 154 308 2464 9856)
;-> 12782

;; Algoritmo del contadino Russo per la moltiplicazione:

(define (moltiplicazione-russa a b)
  (molt-russa a b 0L))

(define (molt-russa x y z)
    (cond ((= y 0) z)
          ((even? y) ; y pari
           (molt-russa (* 2L x) (/ y 2L) z))
          (true      ; y dispari
           (molt-russa (* 2L x) (/ y 2L) (+ z x))
          )
    ) ; valore risultante: z + xy
)

(moltiplicazione-russa 12 12)
;-> 144L

(moltiplicazione-russa 12345 6789)
;-> 83810205L

(moltiplicazione-russa 12345232332323 6782323232323239)
;-> 83729356055942287981803754197L

(time (moltiplicazione-russa 12345232332323 6782323232323239) 100000)
;-> 2406.6

Notiamo che la nostra funzione è ricorsiva di coda, quiondi possiamo usare la tecnica di "memoization":

(define-macro (memoize mem-func func)
  (set (sym mem-func mem-func)
    (letex (f func c mem-func)
      (lambda ()
        (or (context c (string (args)))
        (context c (string (args)) (apply f (args))))))))

(define (moltiplicazione-russa-m a b)
  (molt-russa-m a b 0L))

(memoize molt-russa-m (lambda (x y z)
    (cond ((= y 0L) z)
          ((even? y) ; y pari
           (molt-russa-m (* 2L x) (/ y 2L) z))
          (true      ; y dispari
           (molt-russa-m (* 2L x) (/ y 2L) (+ z x))
          )
    ) ; valore risultante: z + xy
))

(moltiplicazione-russa-m 12 12)
;-> 144L

(moltiplicazione-russa-m 12345 6789)
;-> 83810205L

(moltiplicazione-russa-m 12345232332323 6782323232323239)
;-> 83729356055942287981803754197L

(time (moltiplicazione-russa-m 12345232332323 6782323232323239) 100000)
;-> 328.118

Con la tecnica di memoization la nostra funzione è diventata 7 volte più veloce.

Vediamo la velocità della funzione primitiva di addizione "*":

(* 12345232332323L 6782323232323239)
;-> 83729356055942287981803754197L

(time (* 12345232332323L 6782323232323239) 100000)
;-> 91.905


---------------------
Distanza di Manhattan
---------------------

Date le coordinate di due punti su una griglia (scacchiera), determinare la loro distanza minima (distanza di manhattan) e il numero di percorsi tra i due punti con distanza minima.
È possibile muoversi solo lungo gli assi x e y (solo in verticale e in orizzontale, non in diagonale)

Esempio:

Punto A = (ax,ay) = (4,3)
Punto B = (bx,by) = (2,1)

 4 +--+--+--+--+--+
   |  |  |  |  |  |
 3 +--+--+--+--A--+
   |  |  |  |  |  |
 2 +--+--+--+--+--+
   |  |  |  |  |  |
 1 +--+--B--+--+--+
   |  |  |  |  |  |
 0 +--+--+--+--+--+
   0  1  2  3  4  5

distanza di manhattan = somma del valore assoluto delle differenze delle coordinate.
distanza di manhattan = abs(bx - ax) + abs(by - ay)
distanza di manhattan = (+ (abs (- 2 4)) (abs (- 1 3))) = 4

Quanti percorsi esistono che vanno da A a B e hanno lunghezza 4?

Notiamo che la distanza è simmetrica, cioè dist(A,B) = dist(B,A), quindi possiamo supporre di spostarci solo verso "destra" e verso l'"alto".
Quello che ci interessa è la distanza tra le coordinate:
dist(x) = abs(bx-ax) = 2
dist(y) = abs(by-ay) = 2

Adesso scriviamo una funzione ricorsiva che utilizza questi valori di distanza per calcolare il numero totale dei percorsi minimi tra i due punti.
Poichè ogni volta ci dobbiamo muovere a destra o verso l'alto possiamo richiamare la stesse funzioni con uno dei parametri (destra o alto) diminuito di 1. Queste funzioni vengono chiamate tante volte quanto vale la distanza tra le coordinate. Facendo la somma di queste funzioni otteniamo il numero di percorsi minimi.

La funzione ricorsiva per il calcolo dei percorsi è la seguente:

(define (percorsi-manhattan alto destra);
    (if (or (= alto 0) (= destra 0)) 1
        (+ (percorsi-manhattan (- alto 1) destra)
           (percorsi-manhattan alto (- destra 1)))
    )
)

(percorsi-manhattan 2 2)
;-> 6

(define (manhattan x1 y1 x2 y2)
  (list
    (+ (abs (- x2 x1)) (abs (- y2 y1)))
    (percorsi-manhattan (abs (- x2 x1)) (abs (- y2 y1)))
  )
)

(manhattan 4 3 2 1)
;-> (4 6)

(manhattan 1 1 10 10)
;-> (18 48620)


-------------------------------------------------
Modello di crescita di una popolazione di conigli
-------------------------------------------------

Questo modello è stato discusso nel libro "Liber Abbaci" di Leonardo Pisano (Fibonacci) scritto nell'anno 1202.

- All'istane iniziale t=0 c'e' una coppia di conigli fertili
- I conigli nati all'istante t diventano fertili esattamente dopo un mese, all'istante t+1
- Una coppia di conigli fertile all'istante t genera una nuova coppia di conigli ad ogni mese successivo t+1, t+2, ...
- I conigli non muoiono nell'intervallo di tempo considerato
- I conigli nascono sempre a coppie: un maschio e una femmina.

Quante coppie di conigli ci saranno dopo un anno?

Stiamo parlando del numero di Fibonacci:

(define (coppie-fertili n)       ; valore: naturali
    (if (= n 0) 1
        (+ (nascita-nuove-coppie (- n 1)) (coppie-fertili (- n 1)))
    )
)

(define (nascita-nuove-coppie n)
    (if (= n 0) 0
        (coppie-fertili (- n 1))
    )
)

(for (x 1 10) (print (coppie-fertili x) { }))
;-> 1 2 3 5 8 13 21 34 55 89

Il numero di conigli al mese x è dato da C(x+1) (dove C è la funzione coppie-fertili):

(define (num-conigli mese)
  (coppie-fertili (add mese 1)))

(for (x 1 12) (print (num-conigli x) { }))
;-> 2 3 5 8 13 21 34 55 89 144 233 377

(time (num-conigli 35)) ;24157817
;-> 14656.997 ;14.7 secondi

La funzione è lenta possiamo utilizzare la macro "memoize" oppure scrivere una funzione iterativa. Vediamo entrambi i casi per la formula di Fibonacci: F(n+2) = F(n+1) + F(n)

Versione memoized:

(define-macro (memoize mem-func func)
  (set (sym mem-func mem-func)
    (letex (f func c mem-func)
      (lambda ()
        (or (context c (string (args)))
        (context c (string (args)) (apply f (args))))))))

(define (fibo n)
  (if (< n 2) 1
    (+ (fibo (- n 1)) (fibo (- n 2)))))

(memoize fibo-m
  (lambda (n)
    (if (< n 2) 1
      (+ (fibo-m (- n 1)) (fibo-m (- n 2))))))

(define (num-conigli mese)
  (fibo-m (add mese 2)))

(for (x 1 12) (print (num-conigli x) { }))
;-> 2L 3L 5L 8L 13L 21L 34L 55L 89L 144L 233L 377L

(num-conigli 35)
;-> 24157817L

(time (num-conigli 35))
;-> 0

Versione iterativa:

(define (fibo-i n)
  (local (a b c)
    (setq a 0L b 1L c 0L)
    (for (i 0 n)
      (setq c (+ a b))
      (setq a b)
      (setq b c)
    )
    a
  )
)

(define (num-conigli mese)
  (fibo-i (add mese 1)))

(for (x 1 12) (print (num-conigli x) { }))
;-> 2L 3L 5L 8L 13L 21L 34L 55L 89L 144L 233L 377L

(num-conigli 35)
;-> 24157817L

(time (num-conigli 35))
;-> 0

Con la versione iterativa il calcolo è immediato.


---------------
The Game of Pig
---------------

Il gioco è stato inventato da John Scarne nel 1945.
Ad ogni turno, ogni giocatore lancia ripetutamente un dado finché non viene tirato un 1 o il giocatore decide di "passare":
Se il giocatore lancia un 1, il punteggio del turno è nullo e passa la mano al prossimo giocatore.
Se il giocatore lancia un altro numero (2..6), il numero viene aggiunto al punteggio del turno e il turno del giocatore continua.
Se un giocatore decide di "passare", il suo punteggio del turno viene aggiunto al suo punteggio totale, e diventa il turno del prossimo giocatore.
Vince il giocatore che arriva o supera 100 (poichè il turno deve terminare per tutti i giocatori, potrebbero esserci più giocatori che superano 100, allora il vincitore è quello con il punteggio più alto).

Esempio:

Turno |  Player | punteggio Turno | punteggio Totale
----------------------------------------------------
1     |  A      | (2-2-3-5) 12    | 12
1     |  B      | (2-4-5-1)  0    |  0
2     |  A      | (6-1)      0    | 12
2     |  B      | (3-4-4)   11    | 11
3     |  A      | (3-4-2)    9    | 21
3     |  B      | (3-4)      7    | 18
4     |  ...    | ...       ...   | ...

Quale strategia massimizza le probabilità di vittoria ?

Quanto vale il valore medio dei punti ottenuti prima che esca un 1 ?

La seguente funzione crea una lista con n elementi del tipo (lanci totale):

(define (mediaVal n)
  (local (freq tot val lanci continua)
    (setq freq '())
    (for (i 0 n)
      (setq continua true)
      (setq tot 0)
      (setq val 0)
      (setq lanci 0)
      (while continua
        (setq val (add (rand 6) 1))
        (++ lanci)
        (if (= val 1)
          (begin
            (setq continua nil)
            (push (list lanci tot) freq -1)
          )
          (setq tot (add tot val))
        )
      )
    )
    freq
  )
)

(mediaVal 10)
;-> ((2 6) (7 25) (3 8) (3 9) (6 18) (4 15) (5 17) (2 6) (12 40) (2 5) (8 32))

Creiamo una lista con 100000 elementi:

(silent (setq f (mediaVal 100000)))

Analizziamo il risultato:

Numero totale di lanci:
(apply add (map first f))
;-> 600613 ;numero totale di lanci

Numero medio di lanci:
(div (apply add (map first f)) (length f))
;-> 6.006 ;numero medio di lanci

Punteggio totale:
(apply add (map last f))
;-> 2003171 ;punteggio totale

Punteggio medio per ogni turno:
(div (apply add (map last f)) (length f))
;-> 20.03 ;punteggio medio per ogni turno

Adesso scriviamo un programma che simula "The game of Pig":

(define (pigs n maxvalA maxlanciA maxvalB maxlanciB)
  (local (res vittA vittB)
    (setq vittA 0 vittB 0)
    (for (i 0 n)
      (setq res (game maxvalA maxlanciA maxvalB maxlanciB))
      (if (= res "A")
        (++ vittA)
        (++ vittB)
      )
    )
    (list vittA vittB)
  )
)

Vediamo la funzione che simula una partita tra due giocatori A e B. Con i parametri possiamo stabilire per ogni giocatore:
1) il numero massimo di lanci per ogni giocata (maxlanci)
2) il valore massimo per ogni giocata (maxval)
In questo modo possiamo variare la strategia dei giocatori per definire quale sia la migliore.

(define (game maxvalA maxlanciA maxvalB maxlanciB)
  (local (totA totB parA parB valA valB playgame continua)
    (setq totA 0 totB 0)
    ; "playgame" controlla il termine di una partita
    (setq playgame true)
    ; "playgame" diventa nil quando uno dei due giocatori ha superato i 100 punti
    (while playgame
      ; player A
      (setq parA 0)
      (setq lanciA 0)
      ; "continua" controlla se la giocata del giocatore è terminata
      ; "continua" diventa nil se:
      ; esce un 1 OR
      ; il giocatore ha raggiunto il numero massimo di lanci OR
      ; il giocatore ha raggiunto il valore massimo
      (setq continua true)
      (while continua
        ; lancio del dado
        (setq valA (add (rand 6) 1))
        (++ lanciA)
        (if (= valA 1)
          (begin ; è uscito 1
            ; annullo il punteggio parziale
            (setq parA 0)
            ; tocca al giocatore B
            (setq continua false)
          )
          (begin ; non è uscito 1 (2..6)
            ;aggiorno punteggio parziale A
            (setq parA (add parA valA))
          )
        )
        ;(println "valA = " valA { } "parA = " parA { } "lanciA = " lanciA)
        ;(println "totA = " totA)
        ;(read-key)
        ; controllo superamento max lanci
        (if (>= lanciA maxlanciA) (setq continua false))
        ; controllo superamento max lanci
        (if (>= parA maxvalA) (setq continua false))
      )
      ; aggiorno punteggio totale A
      (setq totA (add totA parA))
      ;(println "totA = " totA)
      ; controllo fine del gioco
      (if (> totA 100) (setq playgame false))
      ;--------------------------------------------
      ; player B
      (setq parB 0)
      (setq lanciB 0)
      ; "continua" controlla se la giocata del giocatore è terminata
      ; "continua" diventa nil se:
      ; esce un 1 OR
      ; il giocatore ha raggiunto il numero massimo di lanci OR
      ; il giocatore ha raggiunto il valore massimo
      (setq continua true)
      ;(while (and continua playgame) ;B non gioca l'ultimo turno
      (while continua
        ; lancio del dado
        (setq valB (add (rand 6) 1))
        (++ lanciB)
        (if (= valB 1)
          (begin ; è uscito 1
            ; annullo il punteggio parziale
            (setq parB 0)
            ; tocca al giocatore A
            (setq continua false)
          )
          (begin ; non è uscito 1 (2..6)
            ;aggiorno punteggio parziale B
            (setq parB (add parB valB))
          )
        )
        ;(println "valB = " valB { } "parB = " parB { } "lanciB = " lanciB)
        ;(println "totB = " totB)
        ;(read-key)
        ; controllo superamento max lanci
        (if (>= lanciB maxlanciB) (setq continua false))
        ; controllo superamento max lanci
        (if (>= parB maxvalB) (setq continua false))
      )
      ; aggiorno punteggio totale B
      (setq totB (add totB parB))
      ;(println "totB = " totB)
      ; controllo fine del gioco
      (if (> totB 100) (setq playgame false))
      ;(println totA { } totB)
    );while playgame
    ; determino il vincitore
    (if (> totA totB) "A" "B")
  )
)

(game 100 2 20 2)
;-> "B"

Giochiamo con i parametri (maxvalA maxlanciA maxvalB maxlanciB):

(pigs 100000 100 8 100 8)
;-> (49811 50190)
(pigs 100000 100 8 20 4)
;-> (45632 54369)
(pigs 100000 20 8 20 4)
;-> (56483 43518)
(pigs 100000 20 5 20 4)
;-> (53505 46496)
(pigs 100000 50 8 20 4)
;-> (45734 54267)
(pigs 100000 30 8 20 4)
;-> (46641 53360)
(pigs 100000 20 20 20 4)
;-> (56520 43481)
(pigs 100000 20 20 20 100)
;-> (49661 50340)
(pigs 100000 30 5 20 5)
;-> (49904 50097)
(pigs 100000 20 10 20 3)
;-> (66592 33409)
(pigs 100000 25 12 20 10)
;-> (50046 49955)
(pigs 100000 30 15 20 10)
;-> (38903 61098)
(pigs 100000 20 10 21 15)
;-> (51128 48873)
(pigs 100000 25 12 25 12)
;-> (49668 50333)
(pigs 1000000 25 12 25 12)
;-> (497380 502621)

Come si vede sembra che utilizzando 20 e 25 come valori massimi per ogni giocata (maxval) si massimizzano la probabilità di vittoria. Dalle prove effettuate sembra che 25 sia leggermente migliore che 20.
L'articolo "Practical Play of the Dice Game Pig" di Neller e Presser:
http://cs.gettysburg.edu/~tneller/papers/umap10.pdf
affronta il gioco matematicamente e raggiunge le stesse conclusioni: il numero 20 e il numero 25 massimizzano le probabilità di vittoria. Comunque l'articolo suggerisce una strategia migliore che può essere sintetizzata nelle seguenti due regole (supponiamo per il giocatore A a cui tocca la mossa):

1) se il punteggio di A è maggiore o uguale a 71, allora deve lanciare i dadi per raggiungere 100.
2) altrimenti deve lanciare i dadi per raggiungere il valore:

  21 + int((PuntiB - PuntiA)/8)


------------------
Il gioco dei salti
------------------

Dato una lista di numeri interi non negativi, si è inizialmente posizionati nel primo indice della lista. Ogni elemento della lista rappresenta la massima lunghezza di salto in avanti da quella posizione. La funzione deve restituire il numero minimo di passi per raggiungere la fine della lista oppure "nil" se non è possibile raggiungere la fine della lista (cioè l'ultimo indice).
Ad esempio:
A = (2 3 1 1 4) restituisce 2.
A = (3 2 1 0 4) restituisce falso.
A = (3 2 2 0 4) restituisce true.

Dobbiamo calcolare l'indice massimo che può essere raggiunto.
Possiamo avere due casi:
1) dalla posizione attuale non è possibile raggiungere la prossima posizione
2) dalla posizione attuale è possibile raggiungere la prossima posizione (in questo caso occorre controllare se abbiamo raggiunto la fine della lista).
Dalla posizione "i" l'indice più grande che può essere raggiunto vale: i + A(i).

Ecco un esempio
idx 0 1 2 3 4
A   3 2 1 0 4
max 3 3 3 0

(define (salto? lst)
  (local (lun idxMax passi)
    (cond ((<= (length lst) 1) 0) ;siamo già alla fine della lista
          (true
           (setq idxMax (lst 0))
           (setq passi 0)
           (setq lun (length lst))
           (for (i 0 (sub lun 1) 1 (or (and (<= idxMax i) (= (lst i) 0)) (>= idxMax (sub lun 1))))
              (if (> (add i (lst i)) idxMax)
                (begin
                ; aggiorno idxMax e passi
                  (setq idxMax (add i (lst i)))
                  (setq passi (add passi 1)))
              )
           )
           ; controllo della posizione finale
           (if (>= idxMax (sub lun 1))
               (setq passi (add passi 1))
               nil
           )
          );true
     );cond
  );local
)

Da notare l'espressione (or (and (<= idxMax i) (= (lst i) 0)) (>= idxMax (sub lun 1))) che fa uscire dal ciclo for quando:

(and (<= idxMax i) (= (lst i) 0)) non possiamo procedere e non abbiamo raggiunto la fine

oppure

(>= idxMax (sub lun 1)) siamo arrivati alla fine della lista.

(salto? '(2 3 1 1 4))
;-> 2
(salto? '(3 2 1 0 4))
;-> nil
(salto? '(3 2 2 0 4))
;-> 2
(salto? '(1 2 3 0 5))
;-> 3
(salto? '(6 2 3 0 0 0 1 5))
;-> 2
(salto? '(1 2 5 1 1 1 1 1))
;-> 3


--------------------------------------------
Ricerca stringa in un testo (algoritmo base)
--------------------------------------------

Dato un testo e una stringa (pattern), scrivere una funzione che ritorna gli indici di tutte le occorrenze della stringa contenute nel testo.
Si può presumere che il testo sia più lungo della stringa.
Esempi:
Input:  txt [] = "TESTO DI PROVA"
        str [] = "TEST"
Output: (0)

Input: txt [] = "OOHOOXOOWOOHOOHO"
       str [] = "OOHO"
Output: (0 9 12)

Questo algoritmo viene chiamato "naive pattern searching":
Facciamo scorrere la stringa (pattern) sul testo carattere per carattere per verificarne la corrispondenza. Se viene trovata una corrispondenza, scorriamo in avanti di uno per ricercare le occorrenze successive.

(define (trova pattern testo)
  (local (m n j out)
    (setq out '())
    (setq m (length pattern))
    (setq n (length testo))
    ; ciclo per far scorrere il pattern carattere per carattere
    (for (i 0 (sub n m))
      ; dall'indice corrente i, verifico la corrispondenza del pattern sul testo
      (setq j 0)
      (while (and (< j m) (= (testo (add i j)) (pattern j)))
        (++ j)
      )
      ;(if (= j m) (println i))
      ; se ho trovato una corrispondenza, aggiorno il risultato
      (if (= j m) (push i out -1))
    )
    out
  );local
)

(trova "TEST" "TEST: TESTO DI PROVA")
;-> (0 6)

(trova "OOHO" "OOHOOXOOWOOHOOHO")
;-> (0 9 12)

(trova "aba" "abababababa")
;-> (0 2 4 6 8)

Qual è il caso migliore?
Il caso migliore si verifica quando il primo carattere del pattern non è presente nel testo.
txt [] = "AABCCAADDEE";
pat [] = "FAA";
Il numero di confronti nel migliore dei casi è O(n).

Qual è il caso peggiore?
Il caso peggiore si verifica nei seguenti scenari.
1) Quando tutti i caratteri del testo e del pattern sono uguali.
txt [] = "AAAAAAAAAAAAAAAAAA";
pat [] = "AAAAA";
2) Il caso peggiore si verifica anche quando solo l'ultimo carattere è diverso.
txt [] = "AAAAAAAAAAAAAAAAAB";
pat [] = "AAAAB";
Il numero di confronti nel caso peggiore è O(m*(n-m+1)).

Nei testi italiani le lettere ripetute sono improbabili, ma questo potrebbero verificarsi in altri casi (ad esempio nei testi binari).


-----------------------------------------
Ricerca stringa in un testo (algoritmo Z)
-----------------------------------------

Questo algoritmo trova tutte le occorrenze di una stringa (pattern) in un testo in tempo lineare. Sia "n" la lunghezza del testo, sia "m" quella del pattern, quindi il tempo totale impiegato è O(m+n) con complessità dello spazio lineare. La complessità di tempo e spazio è uguale all'algoritmo KMP, ma questo algoritmo è più semplice da capire.
In questo algoritmo, costruiamo una lista Z.
Cos'è la lista Z?
Per una stringa str[0..n-1], la lista Z ha la stessa lunghezza della stringa. Un elemento Z[i] di Z memorizza la lunghezza della sottostringa più lunga che inizia da str[i] che è anche un prefisso di str[0..n-1]. La prima voce dell'array Z non ha significato in quanto la stringa completa è sempre prefisso di se stessa.

Esempio:
Indice           0   1   2   3   4   5   6   7   8   9  10  11
Testo            a   a   b   c   a   a   b   x   a   a   a   z
Z Valori         x   1   0   0   3   1   0   0   2   2   1   0

Altri esempi:
str = "aaaaaa"
Z = (x 5 4 3 2 1)

str = "aabaacd"
Z = (x 1 0 2 1 0 0)

str = "abababab"
Z = (x 0 6 0 4 0 2 0)

In che modo la lista Z è utile nella ricerca di pattern in tempo lineare?
L'idea è quella di concatenare pattern e testo e creare una stringa "P$T" dove P è il pattern, $ è un carattere speciale che non deve essere presente nel pattern e nel testo, e T è il testo. Costruire la lista Z per la stringa concatenata. Nella lista Z, se il valore Z in qualsiasi punto è uguale alla lunghezza del pattern, allora il pattern è presente in quel punto.

Esempio:
Pattern P = "aab",  Testo T = "baabaa"

La stringa concatenata vale = "aab~baabaa"

La lista Z per la stringa concatenata vale (x 1 0 0 0 3 1 0 2 1).
Poichè la lunghezza del pattern vale 3, il valore 3 presente nella lista Z indica che il pattern si trova nel testo.

Come costruire la lista Z?
Una soluzione semplice è costituita da due cicli annidati, il ciclo esterno percorre ogni indice e il ciclo interno trova la lunghezza del prefisso più lungo che corrisponde (match) alla sottostringa che inizia con l'indice corrente. La complessità temporale di questa soluzione è O(n^2).
Possiamo costruire la lista Z in tempo lineare.
L'idea è di mantenere un intervallo [L, R] che è l'intervallo con Rmax tale che [L, R] è una sottostringa di prefisso (sottostringa che è anche prefisso).

I passaggi per mantenere questo intervallo sono i seguenti:

1) Se i > R allora non esiste una sottostringa di prefisso che inizi prima di e termina dopo i, quindi ripristiniamo L e R e calcoliamo nuovo [L, R] confrontando str [0 ..] in str [i ..] e ottenendo Z [i] (= R-L + 1).

2) Se i <= R allora lascia K = i-L, ora Z[i] >= min(Z[K], R-i+1) perché str[i ..] corrisponde a str[K ..] per almeno R-i+1 caratteri (essi si trovano nell'intervallo [L, R] che sappiamo essere una sottostringa di prefisso).
Ora bisogna trattare due sottocasi:

a) Se Z[K] < R-i+1 allora non esiste una sottostringa di prefisso a partire da str[i] (altrimenti Z[K] sarebbe più grande) quindi Z[i] = Z[K] e l'intervallo [L, R] rimane lo stesso.

b) Se Z[K] >= R-i+1, allora è possibile estendere l'intervallo [L, R], quindi imposteremo L come i e inizieremo il controllo della corrispondenza da str[R] in poi per calcolare una nuova R con cui aggiorneremo l'intervallo [L, R] e calcoleremo Z [i] (= R - L + 1).

Per una migliore comprensione della procedura, vedere la seguente animazione:
http://www.utdallas.edu/~besp/demo/John2010/z-algorithm.htm

L'algoritmo viene eseguito in tempo lineare perché non confrontiamo mai un carattere minore di R e con la corrispondenza aumentiamo R di uno, quindi ci sono al massimo T confronti. Nel caso di mancata corrispondenza, questa avviene solo una volta per ogni i (a causa della quale R si arresta), questo comporta al massimo T confronti, quindi la complessità totale rimane lineare.

La seguente funzione restituisce una lista di indici se il "pattern" (stringa) viene trovato nel "testo", altrimenti restituisce la lista vuota:

(define (trovaZ pattern testo)
  (local (concat ll Z out)
    (setq out '())
    ; Crea stringa concatenata "P~T"
    (setq concat (append pattern "~" testo))
    (setq ll (length concat))
    (setq Z (dup  0 ll))
    ; Costruisce la lista array
    (setq Z (creaZlista concat Z))
    ; Loop sulla lista Z per cercare i match
    (for (i 0 (sub ll 1))
      (if (= (Z i) (length pattern))
        ; aggiunge l'indice trovato al risultato
        (push (add i (- (length pattern)) (- 1)) out -1)
      )
    )
    out
  );local
)

; Crea la lista Z per la stringa str
(define (creaZlista str Z)
  (local (n L R k)
    (setq n (length str))
    ; [L,R] crea un a finestra che corrisponde con il prefisso di str
    (setq L 0 R 0)
    (for (i 0 (sub n 1))
      ; se i>R allora niente corrisponde,
      ; quindi calcoliamo Z[i] usando il metodo base.
      (if (> i R)
        (begin
          (setq L i R i)
          ; R-L = 0 all'inizio, per iniziare il controllo dall'indice 0.
          ; Per esempio, per "ababab" e i = 1,
          ; il valore di R rimane 0 e Z[i] diventa 0.
          ; Per la stringa "aaaaaa" e i = 1,
          ; Z[i] e R diventano 5
          (while (and (< R n) (= (str (sub R L)) (str R)))
            (++ R)
          )
          (setq (Z i) (sub R L))
          (-- R)
        )
        ;else
        ; k = i-L, in questo modo k è relativo al numero
        ; che corrisponde all'intervallo [L,R].
        (begin
          (setq k (sub i L))
          ; se Z [k] è inferiore all'intervallo rimanente
          ; allora Z [i] sarà uguale a Z [k].
          ; Ad esempio, str = "ababab", i = 3, R = 5 e L = 2
          (if (< (Z k) (add R (- i) 1))
              (setq (Z i) (Z k))
              ; Per esempio str = "aaaaaa" e i = 2, R vale 5,
              ; L vale 0
              ;else
              (begin
                (setq L i)
                (while (and (< R n) (= (str (sub R L)) (str R)))
                  (++ R)
                )
                (setq (Z i) (sub R L))
                (-- R)
              )
          )
        )
      );if
    );for
    Z
  );local
)

(trovaZ "max" "max is the maximum")
;-> (0 11)

(trovaZ "maxx" "max is the maximum")
;-> ()

(trovaZ "aba" "abababababa")
;-> (0 2 4 6 8)


-----------------------
Distanza di Levenshtein
-----------------------

La distanza di Levenshtein (LD) è una misura della somiglianza tra due stringhe A e B. La distanza è il numero di cancellazioni, inserimenti o sostituzioni richieste per trasformare A in B. Per esempio:

- se A è "pippo" e B è "pippo", le stringhe sono identiche e non sono necessarie trasformazioni, quindi LD (A, B) = 0

- se A è "pippo" e B è "pluto", allora LD (A, B) = 3, perché tre sostituzioni (modifica "i" in "l", "p" in "u" e "p" in "l" ) sono sufficienti per trasformare A in B.

Maggiore è la distanza di Levenshtein, minore è la somiglianza tra le stringhe.

L'algoritmo per il calcolo dell distanza di Levenshtein è stato inventato dal russo Vladimir Levenshtein nel 1965.

Questo algoritmo viene utilizzato per:
- Controllo ortografico
- Riconoscimento vocale
- Analisi del DNA
- Rilevamento di plagio

Algoritmo:
Passo | Descrizione
------|------------
   1  | Impostare n = lunghezza di A
      | Impostare m = lunghezza di B.
      | Se n = 0 e m = 0, restituire nil e uscire.
      | Se n = 0, restituire m e uscire.
      | Se m = 0, restituire n e uscire.
      | Costruire una matrice contenente 0..m righe e 0..n colonne (m + 1) x (n + 1).

   2  | Inizializzare la prima riga con l'intervallo dei valori 0..n.
      | Inizializzare la prima colonna con l'intervallo dei valori 0..m.

   3  | Esaminare ciascun carattere di s (i da 1 a n).

   4  | Esaminare ciascun carattere di t (j da 1 a m).

   5  | Se s [i] è uguale a [j], il costo è 0.
      | Se s [i] non è uguale a [j], il costo è 1.

   6  | Impostare la cella D[i, j] della matrice uguale al minimo di:
      | a. La cella immediatamente sopra più 1: D[i-1, j] + 1.
      | b. La cella immediatamente a sinistra più 1: D[i, j-1] + 1.
      | c. La cella diagonalmente sopra a sinistra più il costo: D[i-1, j-1] + costo.

   7  | Dopo le iterazioni dei passi (3, 4, 5, 6), la distanza si trova nella cella D[n,m].


Passi 1 e 2        Passi 3 -> 6 con i = 1      Passi 3 -> 6 con i = 2
    D U M B O           D U M B O                   D U M B O
  0 1 2 3 4 5         0 1 2 3 4 5                 0 1 2 3 4 5
D 1                D  1 0                      D  1 0 1
A 2                A  2 1                      A  2 1 1
M 3                M  3 2                      M  3 2 2
B 4                B  4 3                      B  4 3 3
O 5                O  5 4                      O  5 4 4
L 6                L  6 5                      L  6 5 5

                   Passi 3 -> 6 con i = 3      Passi 3 -> 6 con i = 4
                        D U M B O                   D U M B O
                      0 1 2 3 4 5                 0 1 2 3 4 5
                   D  1 0 1 2                  D  1 0 1 2 3
                   A  2 1 1 2                  A  2 1 1 2 3
                   M  3 2 2 1                  M  3 2 2 1 2
                   B  4 3 3 2                  B  4 3 3 2 1
                   O  5 4 4 3                  O  5 4 4 3 2
                   L  6 5 5 4                  L  6 5 5 4 3

                   Passi 3 -> 6 con i = 5     Passo 7  D[m, n] = 2
                        D U M B O                 D U M B O
                      0 1 2 3 4 5               0 1 2 3 4 5
                   D  1 0 1 2 3 4             D 1 0 1 2 3 4
                   A  2 1 1 2 3 4             A 2 1 1 2 3 4
                   M  3 2 2 1 2 3             M 3 2 2 1 2 3
                   B  4 3 3 2 1 2             B 4 3 3 2 1 2
                   O  5 4 4 3 2 1             O 5 4 4 3 2 1
                   L  6 5 5 4 3 2             L 6 5 5 4 3>2<

La distanza si trova nell'angolo in basso a destra della matrice, ovvero 2. Infatti "DUMBO" può essere trasformato in "DAMBOL" sostituendo "A" per "U" e aggiungendo "L" (una sostituzione e un inserimento = due modifiche).

Vediamo prima una versione ricorsiva:

(define (ld A B)
  (define (ld-aux A lstA B lstB)
    (cond ((zero? lstA) lstB)
          ((zero? lstB) lstA)
          (true
            (min (+ (ld-aux (rest A) (- lstA 1) B lstB) 1)
                 (+ (ld-aux A lstA (rest B) (- lstB 1)) 1)
                 (+ (ld-aux (rest A) (- lstA 1) (rest B) (- lstB 1))
                                 (if (= (first A) (first B)) 0 1))
            )
          )
    )
  );define
  (ld-aux (explode A) (length A) (explode B) (length B))
)

(ld "top" "do")
;-> 2

(ld "topo" "dopo")
;-> 1

(ld "mister" "mostro")
;-> 3

(ld "rosettacode" "raisethysword")
;-> 8

(time (ld "rosettacode" "raisethysword"))
;-> 166616.661 ; 167 secondi

Questa versione è molto lenta.

Adesso scriviamo una funzione iterativa:

(define (ld A B)
  (local (n m D costo)
    (setq n (length A))
    (setq m (length B))
    (setq D (array (add n 1) (add m 1)))
    (cond ((and (zero? n) (zero? m)) nil)
          ((zero? n) m)
          ((zero? m) n)
          (true
            (for (i 0 n) (setf (D i 0) i))
            (for (j 0 m) (setf (D 0 j) j))
            (for (i 1 n)
              (for (j 1 m)
                (if (= (A (sub i 1)) (B (sub j 1)))
                  (setq costo 0)
                  (setq costo 1)
                )
                (setf (D i j) (min (add (D (sub i 1) j) 1)
                                   (add (D i (sub j 1)) 1)
                                   (add (D (sub i 1) (sub j 1)) costo)))
              )
            )
          )
    );cond
    (D n m)
  );local
)

(ld "topo" "dopi")
;-> 2
(ld "top" "lo")
;-> 2
(ld "lo" "top")
;-> 2
(ld "mister" "mostro")
;-> 3
(ld "rosettacode" "raisethysword")
;-> 8
(time (ld "rosettacode" "raisethysword"))
;-> 1.002
(ld "massimo" "omissam")
;-> 4
(ld "massimiliano" (reverse "massimiliano"))
;-> 8
(ld "abcdefgh" (reverse "abcdefgh"))
;-> 8
(ld "newLISP" "Common LISP")
;-> 7

La distanza Levenshtein è stata utilizzata:
1. nell'implementazione di un calcolatore per la distanza tra matrici
2. per la valutazione percettiva delle misurazioni della distanza dialettale.
3. per la marcatura automatica di dettati musicali.
4. per la corrispondenza approssimativa nelle espressioni regolari.
5. per identificare se due sequenze genetiche hanno funzioni simili.
6. per filtrare blocchi di elenchi e-mail (indirizzi spam candidati) entro un valore soglia.
7. come esploratore per i nomi di bambini.
8. per nominare prodotti e servizi come domini, marchi, ecc.
9. per condurre ricerche fuzzy nel tuo ambiente preferito.
10. per i motori di ricerca spamdex - convertendo casualmente il testo in una serie di caratteri incomprensibili.
11. per i motori di ricerca che generano spam - aggiungendo sistematicamente le modifiche a testi validi.
12. come parte di una routine per il controllo ortografico.
13. per identificare contenuti duplicati e plagio.
14. come criterio di ordinamento.


--------------
Social Network
--------------

Due parole sono amiche se hanno una distanza di Levenshtein pari a 1.
Cioè, possiamo aggiungere, rimuovere o sostituire esattamente una lettera nella parola A per creare la parola B.
Il Social Network di una parola è composto da tutti i suoi amici, a cui vanno sommati gli amici dei suoi amici, a cui vanno sommati gli amici degli amici dei suoi amici e così via.
Scrivere un programma per trovare il Social Network di una parola utilizzando il file "nomi.txt" che contiene circa 9000 nomi italiani.

Dobbiamo avere una funzione che, dato un nome, genera tutti i suoi amici (cioè tutti i nomi che hanno distanza pari a uno) utilizzando il file "nomi.txt". Le seguenti due funzioni fanno proprio questo e sono state prese e adattate dal forum di newLISP (autori: kanen e rickyboy).

; Distanza di Leveshtein
; (delete, insert, modify)
; by kanen/rickyboy
; Uso:
;  (setf found-words (get-friendsLD "benefit" word-list))
;

(define (get-friendsLD word word-list)
  (let ((new-words '())
        (alphabet (explode "abcdefghijklmnopqrstuvwxyz"))
        (tmpWord ""))
    ;; Deletes (removing one letter)
    (for (i 0 (- (length word) 1))
      (setf tmpWord word)
      (pop tmpWord i)
      (push tmpWord new-words -1))
    ;; Modifies (one letter to another)
    (for (i 0 (- (length word) 1))
      (set 'tmpWord word)
      (dolist (a alphabet)
        (when (not (= (word i) a))
          (setf (tmpWord i) a)
          (push tmpWord new-words -1))))
    ;; Inserts (add a letter)
    (for (i 0 (length word))
      (dolist (a alphabet)
        (set 'tmpWord word)
        (push (push a tmpWord i) new-words -1)))
    (intersect new-words word-list)))

Questa funzione permette anche lo scambio (swap) di lettere adiacenti (si tratta della distanza di Leveshtein-Damerau):

; Distanza di Leveshtein-Damerau
; (delete, insert, modify, swap)
; by kanen/rickyboy
; Uso:
;  (setf found-words (get-friendsLDD "benefit" word-list))
;
(define (get-friendsLDD word word-list)
  (let ((new-words '())
        (alphabet (explode "abcdefghijklmnopqrstuvwxyz"))
        (tmpWord ""))
    ;; Deletes (removing one letter)
    (for (i 0 (- (length word) 1))
      (setf tmpWord word)
      (pop tmpWord i)
      (push tmpWord new-words -1))
    ;; Swaps (swap adjacent letters)
    (for (i 0 (- (length word) 2))
      (set 'tmpWord word)
      (push (push (pop tmpWord i) tmpWord (+ 1 i)) new-words -1))
    ;; Modifies (one letter to another)
    (for (i 0 (- (length word) 1))
      (set 'tmpWord word)
      (dolist (a alphabet)
        (when (not (= (word i) a))
          (setf (tmpWord i) a)
          (push tmpWord new-words -1))))
    ;; Inserts (add a letter)
    (for (i 0 (length word))
      (dolist (a alphabet)
        (set 'tmpWord word)
        (push (push a tmpWord i) new-words -1)))
    (intersect new-words word-list)))

Per provarle useremo prima il file "nomi-prova.txt":

(define (resume) (print "\r\n> "))
(silent (setq word-list (parse (read-file "nomiA.txt" "\r\n"))) (print "Fatto") (resume))
word-list
;-> ("eva" "leana" "lena" "liana" "lina" "luana" "luano" "luca"
;->  "luce" "lucia" "luisa" "luna" "max" "roberta" "una" "uno")

(get-friendsLD "luca" word-list)
;-> ("luna" "luce" "lucia")

Adesso utilizziamo il file "nomi.txt":

(silent (setq word-list (parse (read-file "nomi.txt" "\r\n"))) (print "Fatto") (resume))
(length word-list)
;-> 8913

(setq amici (get-friendsLD "luca" word-list))
;-> ("luna" "luce" "lucia")

Abbiamo la funzione che calcola gli amici di una parola (nome). Adesso dobbiamo scrivere la funzione che calcola il Social Network di una parola (nome).
La funzione seguente non è ottimizzata, ma è abbastanza semplice: la spiegazione del metodo di calcolo si trova nei commenti:

(define (social x)
  (local (out lst tmp stop len-out)
    ; calcola la lista risultato per la prima volta
    (setq out (get-friendsLD x word-list))
    ; lista di nomi di cui cercare gli amici (lista ricerca)
    (setq lst out)
    (setq stop nil)
    ;lunghezza della lista risultato
    (setq len-out (length out))
    (while (= stop nil)
      ; per ogni nome della lista ricerca calcoliamo
      ; una lista con tutti gli amici e poi la uniamo alla lista risultato
      (setq tmp '())
      (dolist (el lst)
        (extend tmp (get-friendsLD el word-list))
      )
      (setq out (union out tmp))
      ; se la lista risultato ha la stessa lunghezza di quella precedente
      ; (vuol dire che non abbiamo aggiunto alcun nome)...
      (if (= (length out) len-out)
        ;allora stop
        (setq stop true)
        ;altrimenti...
        (begin
          ;(println len-out { } (length out))
          ;aggiorna la lunghezza della lista risultato
          (setq len-out (length out))
          ;crea la nuova lista ricerca partendo dalla lista risultato
          ;togliendo gli elementi della lista ricerca attuale
          (setq lst (difference out lst))
        )
      )
    )
    out
  );local
)

(silent (setq word-list (parse (read-file "nomi-demo.txt" "\r\n"))) (print "Fatto") (resume))
(social "luca")
;-> ("luna" "luce" "lucia" "una" "lena" "lina" "luca" "luana" "uno" "leana" "liana" "luano")

Adesso proviamo con il file "nomi.txt" senza visualizzare il risultato sulla REPL perchè la lista è molto grande. Salveremo il risultato nel file "social-luca.txt"

(silent (setq word-list (parse (read-file "nomi.txt" "\r\n"))) (print "Fatto") (resume))
;(social "luca")

(time (setq amici (social "luca")))
;-> 102772.905 ; 1 min 42 sec

(length amici)
;-> 5534

Adesso scriviamo il risultato nel file "social-luca.txt":

(setq datafile (open "social-luca.txt" "write"))
(write datafile (join amici " "))
(close datafile)


-------
Skyline
-------

Viene data una serie di n rettangoli in nessun ordine particolare. Hanno larghezze e altezze variabili, ma i loro bordi inferiori sono collineari, in modo che sembrino edifici su un orizzonte. Per ogni rettangolo, viene data la posizione x del bordo sinistro, la posizione x del bordo destro e l'altezza. Il compito è disegnare un contorno attorno alla serie di rettangoli in modo che rappresenti la loro forma complessiva rispetto all'orizzonte (skyline).
Esempio:

Input lista Rettangoli
(setq ret '((1 3 3) (2 4 4) (5 8 2) (6 7 4) (8 9 4)))

Output lista Skyline:
((1 3) (2 4) (4 0) (5 2) (6 4) (7 2) (8 4) (9 0))

     Rettangoli                          Skyline

     |                                   |
   5 |                                 5 |
     |                                   |
     |                                   |
   4 |     +-----+     +--+  +--+      4 |     O-----+     O--+  O--+
     |     |     |     |  |  |  |        |     |     |     |  |  |  |
     |     |     |     |  |  |  |        |     |     |     |  |  |  |
   3 |  +--|--+  |     |  |  |  |      3 |  O--+     |     |  |  |  |
     |  |  |  |  |     |  |  |  |        |  |        |     |  |  |  |
     |  |  |  |  |     |  |  |  |        |  |        |     |  |  |  |
   2 |  |  |  |  |  +--|--|--+  |      2 |  |        |  O--+  O--+  |
     |  |  |  |  |  |  |  |  |  |        |  |        |  |           |
     |  |  |  |  |  |  |  |  |  |        |  |        |  |           |
   1 |  |  |  |  |  |  |  |  |  |      1 |  |        |  |           |
     |  |  |  |  |  |  |  |  |  |        |  |        |  |           |
     |  |  |  |  |  |  |  |  |  |        |  |        |  |           |
   0 |-----------------------------    0 |-----------O--------------O--
     0  1  2  3  4  5  6  7  8  9        0  1  2  3  4  5  6  7  8  9

I punti della lista skyline sono contrassegnati con la lettera "O".

Creazione di un vettore delle altezze massime "hmap"
Creiamo un vettore di (hmax + 1) elementi, dove hmax è l'altezza del rettangolo più alto.
Per ogni rettangolo (i j h) assegniamo a tutte le celle di hmap da i a (j-1) il valore massimo tra quello contenuto nella cella corrente e h.

Creazione della lista dei punti della linea
Visitiamo il vettore hmap e riportiamo sulla lista solo i punti (con il relativo valore) che sono diversi dal punto precedente.

Complessità Temporale: O(n)
Complessità Spaziale: O(max(h)) dove max(h) è l'altezza massima dei rettangoli

Considerando i rettangoli dell'esempio:

indice  0 1 2 3 4 5 6 7 8 9  vettore hmap
        0 0 0 0 0 0 0 0 0 0  valori iniziale
          3 3                valori dopo il primo ret (1 3 3)
            4 4              valori dopo il secondo ret (2 4 4)
                  2 2 2      valori dopo il terzo ret (5 8 2)
                    4        valori dopo il quarto ret (6 7 4)
                        4    valori dopo il quinto ret (8 9 4)
        0 3 4 4 0 2 4 2 4 0  valori finali

hmap = (0 3 4 4 0 2 4 2 4 0)

Possiamo scrivere la funzione:

(define (skyline lst)
  (local (len hmap linea)
    ;calcolo valore massimo altezza
    (setq len (add (apply max (flat lst)) 1))
    ; creazione vettore con tutti valori a zero
    (setq hmap (array len '(0)))
    ;Calcolo valori per hmap
    (dolist (el lst)
      (for (i (el 0) (sub (el 1) 1))
        (setf (hmap i) (max (el 2) (hmap i)))
      )
    )
    hmap
    ;calcolo punti visibili
    (setq out '())
    (for (i 0 (sub len 1))
      (if (zero? i)
        ; controllo primo punto hmap[0]
        ; se hmap[0] è diverso da zero, allora lo aggiungo al risultato
        (if (!= (hmap 0) 0) (push (list 0 (hmap i)) out -1))
        ; controllo punti successivi
        ; inserisco il valore di hmap[i] solo se è diverso dal precedente
        (if (!= (hmap i) (hmap (sub i 1))) (push (list i (hmap i)) out -1))
      )
    )
    out
  );local
)

(setq ret '((1 3 3) (2 4 4) (5 8 2) (6 7 4) (8 9 4)))
(skyline ret)
;-> ((1 3) (2 4) (4 0) (5 2) (6 4) (7 2) (8 4) (9 0))

(setq ret '((0 3 3) (2 4 4) (5 8 2) (6 7 4) (8 9 4)))

(setq ret '((2 9 10) (3 6 15) (5 12 12) (13 16 10) (15 17 5)))
(skyline ret)
;-> ((2 10) (3 15) (6 12) (12 0) (13 10) (16 5) (17 0))


-------------
Knuth-shuffle
-------------

Knuth-shuffle (oppure Fisher-Yates shuffle) è un algoritmo per mescolare casualmente gli elementi di un array.
Data una lista con N elementi (idx: 0..N-1), lo pseudo-codice dell'algoritmo è il seguente:

for i from N downto 1 do:
     let j = numero intero casuale nell'intervallo 0 <= j <= i
     swap lista[i] con lista[j]

(define (knuth-shuffle lst)
  (local (N j)
    (setq N (length lst))
    (for (i (- N 1) 0 -1)
      (setq j (rand (+ i 1)))
      (swap (lst i) (lst j))
    )
    lst
  )
)

(knuth-shuffle '(1 2 3 4 5 6 7 8 9 0))
;-> (3 7 9 5 1 0 4 6 8 2)
(knuth-shuffle '(1 2 3 4 5 6 7 8 9 0))
;-> (6 4 9 3 2 7 8 1 5 0)
(knuth-shuffle '(1 2 3 4 5 6 7 8 9 0))
;-> (9 0 7 5 8 1 3 4 6 2)
(knuth-shuffle '(1 2 3 4 5 6 7 8 9 0))
;-> (3 6 5 2 1 4 0 8 7 9)

Estrazione del lotto:
(knuth-shuffle (sequence 1 90))
;-> (13 28 18 32 62 56 19 67 89 54 63 81 61 27 78 75 10 39 46 48 52 4 57 55 29 42 16
;->  24 66 77 44 65 58 15 11 83 85 40 38 6 74 45 3 22 64 79 17 37 49 26 41 70 12 9 73
;->  68 35 72 84 36 7 47 60 30 80 90 14 33 51 59 50 43 20 21 82 1 5 86 8 31 2 69 25 23
;->  34 53 87 88 76 71)

Controlliamo il risultato:
(= (apply + (knuth-shuffle (sequence 1 90))) (apply + (sequence 1 90)))
;-> true

Controlliamo meglio:
(difference (knuth-shuffle (sequence 1 90)) (sequence 1 90))
;-> ()

newLISP ha anche una funzione apposita: "randomize":

(randomize (sequence 1 90))
;-> (41 43 55 59 78 76 4 67 3 40 25 70 56 83 33 30 61 68 17 44 9 27 73 65 24 12 5 37
;->  64 82 85 18 75 36 72 89 54 32 28 48 46 84 14 22 52 60 50 51 15 2 35 69 38 11 71
;->  23 62 53 16 45 31 34 87 47 10 57 26 1 86 81 29 90 74 88 19 80 20 42 8 21 39 58 13
;->  77 63 49 6 79 7 66)


-------------------
Bussola e direzioni
-------------------

La bussola è divisa principalmente nelle quattro direzioni cardinali: nord, sud, est e ovest. Questi punti possono essere ulteriormente suddivisi con l'aggiunta delle quattro direzioni intercardinali (o ordinali) - nord-est (NE), sud-est (SE), sud-ovest (SO) e nord-ovest (NO) - per indicare gli otto venti principali. Nell'uso meteorologico, vengono aggiunti ulteriori punti intermedi tra il cardinale e le direzioni intercardinali, come nord-nord est (NNE) per dare i sedici punti di una rosa di bussola.
La bussola del marinaio ha 32 punti poichè aggiunge punti come nord per est (NbE oppure NxE) tra nord e nord-nordest, e nordest per nord (NEbN oppure NExN) tra nord-nordest e nord-est. Un punto di bussola consente di fare riferimento a una direzione specifica (o azimut) in modo colloquiale, senza ricorrere ai gradi.

(define (bussola32-lista)
  (local (gradi nomi i j)
    (setq gradi '(0.0 16.87 16.88 33.75 50.62 50.63 67.5 84.37
                  84.38 101.25 118.12 118.13 135.0 151.87 151.88
                  168.75 185.62 185.63 202.5 219.37 219.38 236.25
                  253.12 253.13 270.0 286.87 286.88 303.75 320.62
                  320.63 337.5 354.37 354.38))
    (setq nomi '("North                " "North by east        " "North-northeast      "
                 "Northeast by north   " "Northeast            " "Northeast by east    "
                 "East-northeast       " "East by north        " "East                 "
                 "East by south        " "East-southeast       " "Southeast by east    "
                 "Southeast            " "Southeast by south   " "South-southeast      "
                 "South by east        " "South                " "South by west        "
                 "South-southwest      " "Southwest by south   " "Southwest            "
                 "Southwest by west    " "West-southwest       " "West by south        "
                 "West                 " "West by north        " "West-northwest       "
                 "Northwest by west    " "Northwest            " "Northwest by north   "
                 "North-northwest      " "North by west        " "North                " ))
    (for (i 0 31)
      (setq j (add 0.5 (div (mul 32 (gradi i)) 360)))
      (println (format "%2d  %.22s  %6.2f %6.2f" (add (mod j 32) 1) (nomi (mod j 32)) (gradi i) j))
    )
    nil
  )
)

(bussola32-lista)
;->  1  North                    0.00
;->  2  North by east           16.87
;->  3  North-northeast         16.88
;->  4  Northeast by north      33.75
;->  5  Northeast               50.62
;->  6  Northeast by east       50.63
;->  7  East-northeast          67.50
;->  8  East by north           84.37
;->  9  East                    84.38
;-> 10  East by south          101.25
;-> 11  East-southeast         118.12
;-> 12  Southeast by east      118.13
;-> 13  Southeast              135.00
;-> 14  Southeast by south     151.87
;-> 15  South-southeast        151.88
;-> 16  South by east          168.75
;-> 17  South                  185.62
;-> 18  South by west          185.63
;-> 19  South-southwest        202.50
;-> 20  Southwest by south     219.37
;-> 21  Southwest              219.38
;-> 22  Southwest by west      236.25
;-> 23  West-southwest         253.12
;-> 24  West by south          253.13
;-> 25  West                   270.00
;-> 26  West by north          286.87
;-> 27  West-northwest         286.88
;-> 28  Northwest by west      303.75
;-> 29  Northwest              320.62
;-> 30  Northwest by north     320.63
;-> 31  North-northwest        337.50
;-> 32  North by west          354.37
nil

(define (bussola32 gradi)
  (local (nomi j)
    (setq nomi '("North" "North by east" "North-northeast"
                  "Northeast by north" "Northeast" "Northeast by east"
                  "East-northeast" "East by north" "East"
                  "East by south" "East-southeast" "Southeast by east"
                  "Southeast" "Southeast by south" "South-southeast"
                  "South by east" "South" "South by west"
                  "South-southwest" "Southwest by south" "Southwest"
                  "Southwest by west" "West-southwest" "West by south"
                  "West" "West by north" "West-northwest"
                  "Northwest by west" "Northwest" "Northwest by north"
                  "North-northwest" "North by west" "North"))
    (setq j (add 0.5 (div (mul 32 gradi) 360)))
    (nomi (mod j 32))
  )
)

(bussola32 84.37)
;-> "East by north"

(bussola32 84.38)
;-> "East"


--------------------------------------
Puzzle (a b c + a b c + a b c = c c c)
--------------------------------------

Data la seguente operazione:

a b c +
a b c +
a b c =
--------
c c c

Trovare il valore delle cifre a, b e c.

Soluzione 1

Matematicamente risulta 3*(abc) = ccc che può essere scritto come:

  300a + 30b + 3c = 100c + 10c + c

Raggruppiamo il termine "c":

  300a + 30b = 108c

Dividiamo per 3:

  100a + 10b = 36c

Inoltre possiamo notare che deve risultare:

  c + c + c = [x]c

dove l'eventuale [x] può valere 1 o 2.

Vediamo quali cifre soddisfano questo vincolo:

(for (i 0 9)
  (if (< (* 3 i) 10)
      (if (= i (* 3 i)) (println i)) ; valori minori di 10 (una cifra)
      (if (= i (% (* 3 i) 10)) (println i)) ; valori maggiori di 10 (due cifre)
  )
)
;-> 0
;-> 5

Solo il numero 5 è una soluzione accettabile (altrimenti la somma sarebbe nulla).
Quindi abbiamo:

  a b 5 +
  a b 5 +
  a b 5 =
  --------
  5 5 5

Adesso deve risultare:

  b + b + b + 1 = [x]5

dove l'eventuale [x] può valere 1 o 2.

Vediamo quali cifre soddisfano questo vincolo:

(for (i 0 9)
  (if (< (* 3 i) 10)
      (if (= 5 (+ 1 (* 3 i))) (println i)) ; valori minori di 10 (una cifra)
      (if (= 5 (% (+ 1 (* 3 i)) 10)) (println i)) ; valori maggiori di 10 (due cifre)
  )
)
;-> 8

Quindi abbiamo:

  a 8 5 +
  a 8 5 +
  a 8 5 =
  --------
  5 5 5

Adesso deve risultare:

  a + a + a + 2 = 5

Il termine [x] non compare perchè "a" deve essere minore di 10.

Quindi risolviamo quest'ultima equazione:

3*a = 3 ==> a = 1

  1 8 5 +
  1 8 5 +
  1 8 5 =
  --------
  5 5 5

Soluzione 2 (forza bruta)

Calcolare tutte le combinazioni delle cifre da 0 a 9:

(define (combinazioni k nlst)
  (cond ((zero? k)     '(()))
        ((null? nlst)  '())
        (true
          (append (map (lambda (k-1) (cons (first nlst) k-1))
                       (combinazioni (- k 1) (rest nlst)))
                  (combinazioni k (rest nlst))))))

(setq prove (combinazioni 3 '(1 2 3 4 5 6 7 8 9 0)))
(length prove)
;-> 120

Calcolare tutte le permutazioni per ogni elemento della lista delle combinazioni:

(define (rimuovi x lst)
  (cond
    ((null? lst) '())
    ((= x (first lst)) (rimuovi x (rest lst)))
    (true (cons (first lst) (rimuovi x (rest lst))))))

(define (permutazioni lst)
  (cond
    ((= (length lst) 1)(list lst))
    (true (apply append(map(lambda (i) (map (lambda (j)(cons i j))
                                            (permutazioni (rimuovi i lst)))) lst)))))

(setq num (map (fn (x) (permutazioni x)) prove))

Eliminare un livello di annidamento:

(setq num (flat num 1))
(length num)
;-> 720

Calcolare il valore di ogni elemento della lista " num" (formato elemento (a b c)):
(setq numeri (map (fn (x) (+ (* 100 (first x)) (* 10 (first (rest x))) (last x))) num))

Ordinare i numeri:
(sort numeri)

Applicare la seguente funzione di controllo alla lista "numeri":

(define (calcola n)
  (local (val val$ n$ out)
    (setq n$ (string n))
    (setq val (+ n n n))
    (setq val$ (string val))
    (cond ((< n 100) nil)
          ((> val 999) nil)
          ((or (!= (val$ 0) (val$ 1)) (!= (val$ 0) (val$ 2)) (!= (val$ 1) (val$ 2))) nil)
          ((!= (val$ 2) (n$ 2)) nil)
          (true n)
    )
  )
)

(calcola 123)
;-> nil

(setq lsol (map (fn (x) (calcola x)) numeri))

Eliminare tutti gli elementi nil:

(clean null? lsol)
;-> (185)

Soluzione:
a = 1
b = 8
c = 5


---------------
Numero mancante
---------------

Data una lista contenente n numeri distinti presi da 0, 1, 2, ..., n, trovare quello mancante nella lista. Ad esempio, data la lista nums = (0  1  3), la funzione dovrebbe restituire 2.

Soluzione 1 - Matematica

(define (mancante lst)
  (local (somma n)
    (setq n (length lst))
    (setq somma (apply + lst))
    (- (/ (* n (+ n 1)) 2) somma)
  )
)

(setq lst '(9 0 5 4 7 1 6 8 2))
(mancante lst)
;-> 3

Soluzione 2 - Bitwise XOR

(define (mancante lst)
  (let (manca 0)
    (for (i 0 (- (length lst) 1))
      (setq manca (^ manca (^ (+ i 1) (lst i))))
    )
  manca
  )
)

(mancante lst)
;-> 3


--------------------------------------------------
Somma massima di una sottolista (Algoritmo Kadane)
--------------------------------------------------

Data una lista di numeri interi trovare il valore massimo della somma di una sua sottolista.
L'algoritmo di Kadane risolve questo problema per una lista di qualunque dimensione.
In questo caso lo applicheremo ad una lista semplice ad una sola dimensione (1D).

Prima vediamo la soluzione ottenuta con la forza bruta (brute-force).
Data la lista lst = (-1 2 -1 3) i valori delle somme di tutte le sottoliste valgono:

ELEMENTI     Somma   start-index   end-index
-1            -1       0             0
-1,2           1       0             1
-1,2,-1        0       0             2
-1,2,-1,3      3       0             3
2              2       1             1
2,-1           1       1             2
2,-1,3         4       1             3     <--- 4 somma massima sottoliste
-1            -1       2             2
-1,3           2       2             3
3              3       3             3

Dobbiamo scrivere una funzione che calcola la somma di tutte le sottoliste:

(define (maxSumSub lst)
  (local (n max_sum max_start max_end)
    (setq n (length lst))
    (setq max_sum (lst 0))
    (setq max_start 0)
    (setq max_end 0)
    (for (start 0 (- n 1))
      (for (end start (- n 1))
        (setq sum (calcSum lst start end))
        (if (> sum max_sum)
          (begin
            (setq max_sum sum)
            (setq max_start start)
            (setq max_end end))
        )
      )
    )
    (list max_sum max_start max_end)
  );local
)

(define (calcSum lst i j)
  (local (sum)
    (setq sum 0)
    (for (k i j)
      (setq sum (+ sum (lst k)))
    )
  )
)

(setq lst '(-1 2 -1 3))
;-> (-1 2 -1 3)
(maxSumSub lst)
;-> (4 1 3)

(setq lst '(5 7 -3 2 9 6 16 22 21 29 -14 10 12))
(maxSumSub lst)
;-> (122 0 12)

Questo algoritmo ha complessità temporale O(n^3).

Dobbiamo utilizzare un algoritmo più veloce.

L'algoritmo di Kadane inizia con un ragionamento induttivo: se conosciamo la somma massima del subarray che termina con la posizione i (si chiami questo B[i]), qual è la somma massima del subarray che termina alla positione i + 1 (equivalentemente, quanto vale B[i+1]) ? La risposta risulta essere relativamente semplice: o la somma massima del subarray che termina con la posizione i + 1 include la somma massima della subarray che termina alla posizione i come prefisso, oppure no (in altre parole, B[i+1] = max(A[i+1], A[i+1] + B[i]), dove A[i+1] è l'elemento all'indice i + 1).

L'algoritmo può essere codificato nel seguente modo:

(define (getMaxSum lst)
  (local (currentMax totalMax)
    (setq currentMax (lst 0))
    (setq totalMax (lst 0))
    (for (i 1 (- (length lst) 1))
      ; aggiorno il valore massimo della somma corrente
      ; sommandolo al valore corrente
      (setq currentMax (add (lst i) (max currentMax 0)))
      ; verifico se occorre aggiornare il valore massimo totale
      (setq totalMax (max totalMax currentMax 0))
    )
  )
)

(setq lst '(5 7 -3 2 9 6 16 22 21 29 -14 10 12))
(getMaxSum lst)
;-> 122

(setq lst '(-2 1 -3 4 -1 2 1 -5 4))
(getMaxSum lst)
;-> 6

La soluzione completa consiste nel restituire tre valori:
1) il valore della somma massima
2) l'indice di inizio della sottolista massima
2) l'indice di fine della sottolista massima
Inoltre bisogna trattare il caso della lista vuota e quello delle liste che hanno tutti valori negativi.

La funzione definitiva è la seguente:

(define (kadaneIdx lst)
  (local (currentMax totalMax startIdx endIdx tempIdx)
    (cond ((null? lst) (list nil nil nil))
          (true
            (setq currentMax (lst 0))
            (setq totalMax (lst 0))
            (setq startIdx 0)
            (setq endIdx 0)
            (setq tempIdx 0)
            (for (i 1 (- (length lst) 1))
              ; aggiorno il valore massimo della somma corrente
              (setq currentMax (add currentMax (lst i)))
              ; spezziamo la condizione che calcola
              ; il massimo tra totalMax currentMax e 0,
              ; per tenere conto degli indici coinvolti
              (cond ((< currentMax 0)
                      (setq currentMax 0)
                      (setq tempIdx (add i 1))
                    )
                    ((< totalMax currentMax)
                      (setq totalMax currentMax)
                      (setq startIdx tempIdx)
                      (setq endIdx i)
                    )
              )
            )
            ; controllo soluzione negativa ==> tutti i numeri sono negativi
            (if (< totalMax 0)
              (begin
                ; cerco il valore massimo della lista e il relativo indice
                (setq startIdx -1)
                (dolist (el lst)
                  (if (>= el totalMax) (setq totalMax el startIdx $idx))
                )
                (setq endIdx startIdx)
              )
            )
            (list totalMax startIdx endIdx)
          );true
    );cond
  );local
)

(setq lst '(5 7 -3 2 9 6 16 22 21 29 -14 10 12))
(kadaneIdx lst)
;-> (122 0 12)

(setq lst '(-2 1 -3 4 -1 2 1 -5 4))
(kadaneIdx lst)
;-> (6 3 6)

(setq lst '(1 2 3 -20 5 6))
(kadaneIdx lst)
;-> (11 4 5)

(setq lst '(10 -1 2 11))
(kadaneIdx lst)
;-> (22 0 3)

(setq lst '(-11 -10 -12))
(kadaneIdx lst)
(-10 1 1)

(setq lst '())
(kadaneIdx lst)
;-> (nil nil nil)

L'algoritmo Kadane ha complessità temporale O(n).


----------------------------------
Prodotto massimo di una sottolista
----------------------------------

Data una lista di numeri interi trovare il valore massimo del prodotto di una sua sottolista.
Per risolvere questo problema potremmo utilizzare l'algoritmo di Kadane e modificarlo per tenere conto degli elementi con valore 0 e del fatto che il prodotto può cambiare segno in funzione del segno dei moltiplicandi.
Invece utilizziamo un metodo più semplice che però non è ottimale in termini di tempo e di spazio.

(define (maxProd lst)
  (local (n maxprod pos neg)
    (setq n (length lst))
    (setq pos (array n '(0)))
    (setq neg (array n '(0)))
    (setq (pos 0) (lst 0)) ; pos[i] contiene il prodotto positivo fino a lst[i]
    (setq (neg 0) (lst 0)) ; neg[i] contiene il prodotto negativo fino a lst[i]
    (setq maxprod (lst 0))
    (for (i 0 (- n 1))
      ; il massimo dei tre valori
      (setq (pos i) (max (max (mul (pos (- i 1)) (lst i)) (mul (neg (- i 1)) (lst i))) (lst i)))
      ; il minimo dei tre valori
      (setq (neg i) (min (min (mul (pos (- i 1)) (lst i)) (mul (neg (- i 1)) (lst i))) (lst i)))
      (setq maxprod (max maxprod (pos i)))
    )
    maxprod
  )
)

(setq lst '(6 -3 -10 0 2))
(maxProd lst)
;-> 180
Sottolista: (6 -3 -10)

(setq lst '(-1 -3 -10 0 60))
(maxProd lst)
;-> 60
Sottolista: (60)

(setq lst '(-2 -3 0 -2 -40))
(maxProd lst)
;-> 80
Sottolista: (-2 -40)

(setq lst '(-1 -2 -3))
(maxProd lst)
;-> 6

(setq lst '(0 -1))
(maxProd lst)
;-> 0

(setq lst '(0 0 0 0))
(maxProd lst)
;-> 0


-----------------------
Problema delle N-Regine
-----------------------

Il problema delle N-Regine consiste nel trovare il modo di posizionare N Regine (pezzo degli scacchi) su una scacchiera NxN in modo che nessuna di esse sia sotto cattura.
Il problema è risolvibile solo per N >= 4.
Risolveremo il problema con il metodo di backtracking (che è una forma di ricorsione).
Per capire il funzionamento dell'algoritmo, risolveremo prima il problema passo per passo utilizzando una scacchiera 4x4.

Algoritmo di backtracking
1) All'inizio, posizioniamo una regina (X) nella casella (1,1)

   X 0 0 0
   0 0 0 0
   0 0 0 0
   0 0 0 0

2) Ora la seconda regina non può essere piazzata nelle colonne 1 e 2 poiché tali posizioni possono essere attaccate dalla prima regina.
Quindi piazziamo la regina due inizialmente a (2,3)

   X 0 0 0
   0 0 X 0
   0 0 0 0
   0 0 0 0

3) La terza regina può essere piazzata a (4,2).

   X 0 0 0
   0 0 X 0
   0 0 0 0
   0 X 0 0

4) Ora, quando proviamo a piazzare una regina nella terza fila, non troviamo alcuna casella disponibile perché sono tutte attaccate dalla prima regina o dalla seconda regina.
Quindi torniamo indietro (backtracking) e cerchiamo di mettere la terza regina in una nuova posizione. Purtoppo non esiste nessuna posizione disponibile per la terza regina, allora torniamo indietro e riposizioniamo la seconda regina a (2,4) (che è la prima casella disponibile).

   X 0 0 0
   0 0 0 X
   0 0 0 0
   0 0 0 0

5) Ora, quando piazziamo la terza regina, c'è solo una posizione possibile che è (3,2), quindi poniamo la terza regina in (3,2).

   X 0 0 0
   0 0 0 X
   0 X 0 0
   0 0 0 0

6) Ancora una volta finiamo senza nessuna posizione per piazzare la prossima regina. Quindi torniamo indietro, ma non ci sono posizioni alternative nemmeno per la terza e la seconda regina. Quindi torniamo indietro e cambiamo la posizione della prima regina come (1,2)

   0 X 0 0
   0 0 0 0
   0 0 0 0
   0 0 0 0

7) Ora per mettere la seconda regina, abbiamo solo una scelta che è (2,4)

   0 X 0 0
   0 0 0 X
   0 0 0 0
   0 0 0 0

8) Allo stesso modo, per posizionare la terza regina, abbiamo una sola posizione possibile (3,1)

   0 X 0 0
   0 0 0 X
   X 0 0 0
   0 0 0 0

9) Infine, abbiamo una posizione possibile per posizionare la quarta regina che è (4,3)

   0 X 0 0
   0 0 0 X
   X 0 0 0
   0 0 X 0

In questo modo si ottiene una possibile soluzione al problema delle N-Regine e l'algoritmo termina.

(define (isAttacked x y board N)
  (local (out)
    ; controllo righe e colonne
    (for (i 0 (- N 1))
      ;righe
      (if (and (= (board x i) 1) (!= i y))
        (setq out true))
      ;colonne
      (if (and (= (board i y) 1) (!= i x))
        (setq out true))
    )
    ; controllo diagonali
    (for (i 0 (- N 1))
      (for (j 0 (- N 1))
        (if (or (= (+ i j) (+ x y)) (= (- i j) (- x y)))
            (if (and (or (!= i x) (!= j y)) (= 1 (board i j)))
                (setq out true)
            )
        )
      )
    )
    out
  );local
)

(setq board '((1 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0)))
(isAttacked 1 1 board 4)
;-> true
(isAttacked 2 2 board 4)
;-> true
(isAttacked 1 2 board 4)
;-> nil

(define (nQueens board level N)
  (local (out j)
    (cond ((= level N) (setq out true) (show board N))
          (true
            (setq j 0)
            (while (and (< j N) (!= out true))
              (if (isAttacked level j board N) (setq j j)
                  (begin
                    (setq (board level j) 1)
                    (if (nQueens board (+ level 1) N) (setq out true)
                        (setq (board level j) 0))
                  )
              )
              (++ j)
            )
          )
    )
    out
  )
  ;(println board)
)

(define (show board)
    (for (i 0 (- N 1))
      (for (j 0 (- N 1))
        (print (board i j) { })
      )
      (println { })
    )
)

(setq size 4)
(setq board (array size size '(0)))
(nQueens board 0 size)
;-> 0 1 0 0
;-> 0 0 0 1
;-> 1 0 0 0
;-> 0 0 1 0
;-> true

(setq size 8)
(setq board (array size size '(0)))
(nQueens board 0 size)
;-> 1 0 0 0 0 0 0 0
;-> 0 0 0 0 1 0 0 0
;-> 0 0 0 0 0 0 0 1
;-> 0 0 0 0 0 1 0 0
;-> 0 0 1 0 0 0 0 0
;-> 0 0 0 0 0 0 1 0
;-> 0 1 0 0 0 0 0 0
;-> 0 0 0 1 0 0 0 0
;-> true

(setq size 21)
(setq board (array size size '(0)))
(nQueens board 0 size)
;-> 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
;-> 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
;-> 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
;-> 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
;-> 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
;-> 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0
;-> 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0
;-> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0
;-> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
;-> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0
;-> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0
;-> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0
;-> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0
;-> 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0
;-> 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0
;-> 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0
;-> 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0
;-> 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
;-> 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0
;-> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0
;-> 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0
;-> true

(setq size 21)
(setq board (array size size '(0)))
(time (nQueens board 0 size))
;-> 31058.105 ; 31 secondi

Adesso scriviamo un programma che visualizza tutte le soluzioni per una scacchiera NxN.

(define (nregine n riga)
(catch
  (local (k)
    (cond ((>= riga n)
           ; stampa di una soluzione
           (for (i 0 (- n 1))
               (for (j 0 (- n 1))
                 (if (= (griglia i j) 1)
                     (print "■ ")
                     (print "∙ ")
                 )
               )
               (println "")
           )
           (println "")
           (throw 1))
          (true
           ; contatore soluzioni
           (setq k 0)
           ; ricerca soluzioni
           (for (i 0 (- n 1))
              (if (libera? griglia riga i n) (begin
                  (setq (griglia riga i) 1)
                  (setq k (+ k (nregine n (+ riga 1))))
                  (setq (griglia riga i) 0))
              )
           )
           (throw k))
    ))))

(define (libera? griglia x y n)
(catch
  (local (tmp)
    (if (zero? x) (throw true))
    (for (z x 1 -1)
      (if (and (>= (- x z) 0) (>= (- y z) 0) (!= (griglia (- x z) (- y z)) 0))
          (throw nil))
      (if (and (>= (- x z) 0) (!= (griglia (- x z) y) 0))
          (throw nil))
      (if (and (>= (- x z) 0) (< (+ y z) n) (!= (griglia (- x z) (+ y z)) 0))
          (throw nil))
    )
    true)))

(define (n-regine n)
  (local (griglia)
    (setq griglia (array n n '(0)))
    (nregine n 0)))

(n-regine 4)
;-> ∙ ■ ∙ ∙    ∙ ∙ ■ ∙
;-> ∙ ∙ ∙ ■    ■ ∙ ∙ ∙
;-> ■ ∙ ∙ ∙    ∙ ∙ ∙ ■
;-> ∙ ∙ ■ ∙    ∙ ■ ∙ ∙
;-> 2

(n-regine 8)
;-> ■ ∙ ∙ ∙ ∙ ∙ ∙ ∙    ■ ∙ ∙ ∙ ∙ ∙ ∙ ∙    ■ ∙ ∙ ∙ ∙ ∙ ∙ ∙    ■ ∙ ∙ ∙ ∙ ∙ ∙ ∙
;-> ∙ ∙ ∙ ∙ ■ ∙ ∙ ∙    ∙ ∙ ∙ ∙ ∙ ■ ∙ ∙    ∙ ∙ ∙ ∙ ∙ ∙ ■ ∙    ∙ ∙ ∙ ∙ ∙ ∙ ■ ∙
;-> ∙ ∙ ∙ ∙ ∙ ∙ ∙ ■    ∙ ∙ ∙ ∙ ∙ ∙ ∙ ■    ∙ ∙ ∙ ■ ∙ ∙ ∙ ∙    ∙ ∙ ∙ ∙ ■ ∙ ∙ ∙
;-> ∙ ∙ ∙ ∙ ∙ ■ ∙ ∙    ∙ ∙ ■ ∙ ∙ ∙ ∙ ∙    ∙ ∙ ∙ ∙ ∙ ■ ∙ ∙    ∙ ∙ ∙ ∙ ∙ ∙ ∙ ■
;-> ∙ ∙ ■ ∙ ∙ ∙ ∙ ∙    ∙ ∙ ∙ ∙ ∙ ∙ ■ ∙    ∙ ∙ ∙ ∙ ∙ ∙ ∙ ■    ∙ ■ ∙ ∙ ∙ ∙ ∙ ∙
;-> ∙ ∙ ∙ ∙ ∙ ∙ ■ ∙    ∙ ∙ ∙ ■ ∙ ∙ ∙ ∙    ∙ ■ ∙ ∙ ∙ ∙ ∙ ∙    ∙ ∙ ∙ ■ ∙ ∙ ∙ ∙
;-> ∙ ■ ∙ ∙ ∙ ∙ ∙ ∙    ∙ ■ ∙ ∙ ∙ ∙ ∙ ∙    ∙ ∙ ∙ ∙ ■ ∙ ∙ ∙    ∙ ∙ ∙ ∙ ∙ ■ ∙ ∙
;-> ∙ ∙ ∙ ■ ∙ ∙ ∙ ∙    ∙ ∙ ∙ ∙ ■ ∙ ∙ ∙    ∙ ∙ ■ ∙ ∙ ∙ ∙ ∙    ∙ ∙ ■ ∙ ∙ ∙ ∙ ∙
;-> 
;-> ∙ ■ ∙ ∙ ∙ ∙ ∙ ∙    ∙ ■ ∙ ∙ ∙ ∙ ∙ ∙    ∙ ■ ∙ ∙ ∙ ∙ ∙ ∙    ∙ ■ ∙ ∙ ∙ ∙ ∙ ∙
;-> ∙ ∙ ∙ ■ ∙ ∙ ∙ ∙    ∙ ∙ ∙ ∙ ■ ∙ ∙ ∙    ∙ ∙ ∙ ∙ ■ ∙ ∙ ∙    ∙ ∙ ∙ ∙ ∙ ■ ∙ ∙
;-> ∙ ∙ ∙ ∙ ∙ ■ ∙ ∙    ∙ ∙ ∙ ∙ ∙ ∙ ■ ∙    ∙ ∙ ∙ ∙ ∙ ∙ ■ ∙    ■ ∙ ∙ ∙ ∙ ∙ ∙ ∙
;-> ∙ ∙ ∙ ∙ ∙ ∙ ∙ ■    ■ ∙ ∙ ∙ ∙ ∙ ∙ ∙    ∙ ∙ ∙ ■ ∙ ∙ ∙ ∙    ∙ ∙ ∙ ∙ ∙ ∙ ■ ∙
;-> ∙ ∙ ■ ∙ ∙ ∙ ∙ ∙    ∙ ∙ ■ ∙ ∙ ∙ ∙ ∙    ■ ∙ ∙ ∙ ∙ ∙ ∙ ∙    ∙ ∙ ∙ ■ ∙ ∙ ∙ ∙
;-> ■ ∙ ∙ ∙ ∙ ∙ ∙ ∙    ∙ ∙ ∙ ∙ ∙ ∙ ∙ ■    ∙ ∙ ∙ ∙ ∙ ∙ ∙ ■    ∙ ∙ ∙ ∙ ∙ ∙ ∙ ■
;-> ∙ ∙ ∙ ∙ ∙ ∙ ■ ∙    ∙ ∙ ∙ ∙ ∙ ■ ∙ ∙    ∙ ∙ ∙ ∙ ∙ ■ ∙ ∙    ∙ ∙ ■ ∙ ∙ ∙ ∙ ∙
;-> ∙ ∙ ∙ ∙ ■ ∙ ∙ ∙    ∙ ∙ ∙ ■ ∙ ∙ ∙ ∙    ∙ ∙ ■ ∙ ∙ ∙ ∙ ∙    ∙ ∙ ∙ ∙ ■ ∙ ∙ ∙
;-> 
;-> ...
;-> 
;-> ∙ ∙ ∙ ∙ ∙ ∙ ∙ ■    ∙ ∙ ∙ ∙ ∙ ∙ ∙ ■    ∙ ∙ ∙ ∙ ∙ ∙ ∙ ■    ∙ ∙ ∙ ∙ ∙ ∙ ∙ ■
;-> ∙ ■ ∙ ∙ ∙ ∙ ∙ ∙    ∙ ■ ∙ ∙ ∙ ∙ ∙ ∙    ∙ ∙ ■ ∙ ∙ ∙ ∙ ∙    ∙ ∙ ∙ ■ ∙ ∙ ∙ ∙
;-> ∙ ∙ ∙ ■ ∙ ∙ ∙ ∙    ∙ ∙ ∙ ∙ ■ ∙ ∙ ∙    ■ ∙ ∙ ∙ ∙ ∙ ∙ ∙    ■ ∙ ∙ ∙ ∙ ∙ ∙ ∙
;-> ■ ∙ ∙ ∙ ∙ ∙ ∙ ∙    ∙ ∙ ■ ∙ ∙ ∙ ∙ ∙    ∙ ∙ ∙ ∙ ∙ ■ ∙ ∙    ∙ ∙ ■ ∙ ∙ ∙ ∙ ∙
;-> ∙ ∙ ∙ ∙ ∙ ∙ ■ ∙    ■ ∙ ∙ ∙ ∙ ∙ ∙ ∙    ∙ ■ ∙ ∙ ∙ ∙ ∙ ∙    ∙ ∙ ∙ ∙ ∙ ■ ∙ ∙
;-> ∙ ∙ ∙ ∙ ■ ∙ ∙ ∙    ∙ ∙ ∙ ∙ ∙ ∙ ■ ∙    ∙ ∙ ∙ ∙ ■ ∙ ∙ ∙    ∙ ■ ∙ ∙ ∙ ∙ ∙ ∙
;-> ∙ ∙ ■ ∙ ∙ ∙ ∙ ∙    ∙ ∙ ∙ ■ ∙ ∙ ∙ ∙    ∙ ∙ ∙ ∙ ∙ ∙ ■ ∙    ∙ ∙ ∙ ∙ ∙ ∙ ■ ∙
;-> ∙ ∙ ∙ ∙ ∙ ■ ∙ ∙    ∙ ∙ ∙ ∙ ∙ ■ ∙ ∙    ∙ ∙ ∙ ■ ∙ ∙ ∙ ∙    ∙ ∙ ∙ ∙ ■ ∙ ∙ ∙
;-> 92


------------------------------
Somma delle cifre di un numero
------------------------------

Calcolare la somma delle cifre di un numero ripetutamente fino a quando la somma ha una sola cifra.

Esempi:

n = 1234 ==> 1 + 2 + 3 + 4 = 10 ==> 1 + 0 = 1

n = 5674 ==> 5 + 6 + 7 + 4 = 22 ==> 2 + 2 = 4

(define (digitSum n)
  (if (zero? n) 0
    (if (zero? (% n 9)) 9
      (% n 9))))

(digitSum 1234)
;-> 1

(digitSum 5674)
;-> 4

(digitSum 2345345345343453453453535353453453451345678901)
;-> 5L

Complessità temporale O(1).

Ted Walther ha scritto una funzione più elegante:

(define (digital_root n)
    (+ 1 (% (- n 1) 9)))

Vediamo adesso la dimostrazione matematica.

Prendiamo un numero numero positivo N. Scrivendo N in termini di cifre abbiamo:

N = Sum[ d[i] * 10^i ], dove d[0], d[1], d[2], ... sono le cifre di N. la somma inizia con i = 0.

Nota che 10^1 = (9*1 + 1), 10^2 = (9*11 + 1), 10^3 = (9*111 + 1), e così via.

Quindi possiamo scrivere:

N = (9*1 + 1) d[0] + (9*11 + 1) d[1] + (9*111 + 1) d[2] + ...

= 9 * (1*d[0] + 11*d[1] + 111*d[2] + ...) + d[0] + d[1] + d[2] + ...

= (multiplo di 9) + d[0] + d[1] + d[2] + ...

Quindi (N mod 9) = d[0] + d[1] + d[2] + ...

In altre parole il risultato deriva da una proprietà fondamentale dell'aritmetica modulare, vale a dire:

a*b mod n ≡ (a mod n)*(b mod n)

Poichè 10 mod 9 ≡ 1 abbimo 10^i mod 9 ≡ (10 mod 9)^i = 1^i = 1 per qualunque potenza i di 10.

Nella notazione decimale, un intero positivo N è rappresentato come una sequenza inversa di cifre d (i) tale che:

N = ∑ d(i)*10^i ⇒ N mod 9 ≡ ∑ (d(i)*10^i mod 9) ≡ ∑ d(i) mod 9
    i                       i                     i

Notare che qualsiasi numero intero positivo in base b è congruente alla somma delle sue cifre modulo (b-1) per qualsiasi base.

Per completezza riportiamo una funzione che calcola la somma delle cifre di un numero (non ripetutamente):

(define (digit-sum n)
  (let (out 0)
    (while (!= n 0)
      (setq out (+ out (% n 10)))
      (setq n (/ n 10))
    )
    out))

(digit-sum 123456789L)
;-> 45


--------------------------
Coppia di punti più vicina
--------------------------

Data una serie di n punti nel piano, trovare la coppia di punti che hanno distanza minore.

Esempio: L = ((1 3) (4 4) (1 1) (2 5) (6 3) (8 5) (6 1) (6 5) (3 2) (2 4)

      |
    6 |
      |
    5 |       O               O       O
      |
    4 |       O       O
      |
    3 |   O                   O
      |
    1 |           O
      |
    1 |   O                   O
      |
    0 ---------------------------------------
      0   1   2   3   4   5   6   7   8   9

(define (closestPairs lst)
  (local (cp vec dist minDist)
    (setq minDist 9223372036854775807) ; valore massimo int64
    (setq cp '())
    ; trasformo la lista in un vettore per guadagnare in velocità
    (setq vec (array (length lst) 2 (flat lst)))
    (for (p1 0 (- (length vec) 1))
      (for (p2 p1 (- (length vec) 1))
        (if (!= (vec p1) (vec p2))
          (begin
            (setq dist (add (mul (sub (vec p1 0) (vec p2 0)) (sub (vec p1 0) (vec p2 0)))
                            (mul (sub (vec p1 1) (vec p2 1)) (sub (vec p1 1) (vec p2 1)))))
            (if (< dist minDist)
              (begin
                (setq minDist dist)
                (setq cp (list (vec p1) (vec p2)))
                ;(println minDist)
              )
            )
          )
        )
      )
    )
    (println minDist)
    cp
  )
)

(setq lst '((1 3) (4 4) (1 1) (2 5) (6 3) (8 5) (6 1) (6 5) (3 2) (2 4)))
(closestPairs lst)
;-> 1
;-> ((2 5) (2 4))

Vediamo un altro esempio:

(setq lst '((-1 -3) (-4 -4) (1 1) (-2 -5) (6 3) (8 5) (6 1) (6 5) (3 2) (2 4)))
(closestPairs lst)
;-> 4
;-> ((6 3) (6 1))

Vediamo con una lista di 10000 punti:

(silent
  (setq a (rand 10000 10000))
  (setq b (rand 10000 10000))
  (setq c (map list a b))
  (setq d (unique c))
)

(time (println (closestPairs d)))
;-> 1
;-> ((2815 1408) (2815 1409))
;-> 22071.601

La funzione è lenta (22 secondi) perchè ha una complessità temporale O(n^2)).

Vediamo la differenza del numero di cicli tra due for innestati (i = 0 e j = 0) e due for con il secondo ciclo che inizia da i = j:

(setq n 100)
(setq n 1000)
(setq n '(100 1000 10000 100000))
(dolist (el n)
  (setq num 0 num1 0)
  ; primo ciclo
  (for (i 0 (- el 1))
    (for (j 0 (- el 1))
      (++ num)
    )
  )
  ; secondo ciclo
  (for (i 0 (- el 1))
    (for (j i (- el 1))
      (++ num1)
    )
  )
  (println el { } num { } num1)
)
;-> 100 10000 5050
;-> 1000 1000000 500500
;-> 10000 100000000 50005000
;-> 100000 10000000000 5000050000

Il primo ciclo ha n^2 cicli, il secondo ha (n^2)/2 cicli (la complessità temporale è la stessa).

Comunque per risolvere questo problema esistono diversi algoritmi con tempo O(n*log(n), ad esempio "sweep-line" oppure "divide and conquer".
Esiste anche un algoritmo casuale che, in linea teorica, ha tempo O(n). In pratica è leggermente migliore dell'algoritmo sweep-line, ma è più semplice da implementare.

L'algoritmo funziona in fasi successive. L'idea è che in ogni fase abbiamo già scoperto una coppia di punti a una distanza d e possiamo chiederci se un'altra coppia esiste a una distanza minore. Per questo, dividiamo lo spazio in una griglia con il passo di d/2 in entrambe le direzioni. La scelta di un passo della griglia di d/2 invece di d garantisce la presenza, al massimo, di un elemento per cella, facilitando l'elaborazione. Ogni punto appartiene quindi ad una cella della griglia. Sia P l'insieme di punti per i quali abbiamo già verificato che le distanze tra ogni coppia di punti di P è almeno d. Quindi, ogni cella della griglia contiene al massimo un punto di P.
La griglia è rappresentata da una hash-map che associa ad ogni cella non vuota il punto di P che contiene. Al momento di aggiungere un punto p a P e alla hash-map, è sufficiente testare la sua distanza con i punti q contenuti nelle celle 5×5 attorno alla cella p.

Nota: Ogni cella della griglia contiene al massimo un punto. Quando consideriamo un nuovo punto p è sufficiente misurarne la distanza con i punti contenuti nelle celle vicine.

Se viene rilevata una coppia di punti alla distanza d' < d, la procedura viene riavviata dall'inizio con una nuova griglia di passo d'/2.

Nota: per calcolare la cella associata a un punto (x, y) nella griglia con un dato passo, è sufficiente dividere ogni coordinata per il passo e poi arrotondare per difetto (floor).

Supponiamo che l'accesso alla hash-map richieda un tempo costante, così come il calcolo di quale cella contiene un dato punto. Se i punti in input sono scelto in un ordine uniformemente casuale, allora quando viene elaborato il punto i-esimo (3 ≤ i ≤ n), miglioriamo la distanza d con probabilità 1/(i −1). Quindi la complessità attesa è nell'ordine di:

Sum[i=3..n] (i/(i - 1))

quindi lineare in n.

Adesso possiamo scriviamo la funzione finale.

Funzione che calcola la distanza tra due punti:

(define (dist p1 p2)
  (sqrt (+ (* (- (p1 0) (p2 0)) (- (p1 0) (p2 0)))
           (* (- (p1 1) (p2 1)) (- (p1 1) (p2 1))))))

(dist '(2 2) '(3 3))
;-> 1.414213562373095

Funzione che calcola la cella di un punto:

(define (cell punto passo)
  (let ((x (punto 0)) (y (punto 1)))
    (list (int (floor (div x passo))) (int (floor (div y passo))))))

Funzione che cerca di minimizzare la distanza:

(define (migliora lst d)
(catch
  (local (x y cella q pq)
    (new Tree 'hash)
    (dolist (p lst)
      (setq cella (cell p (div d 2)))
      (setq x (cella 0) y (cella 1))
      (for (x1 (- x 2) (+ x 2))
        (for (y1 (- y 2) (+ y 2))
          (if (true? (hash (string (list x1 y1))))
              (begin
                (setq q (hash (string (list x1 y1))))
                (setq pq (dist p q))
                (if (< pq d)
                  (begin
                    (delete 'hash)
                    (throw (list pq p q))
                  )
                )
              )
          )
        )
      )
      (hash (string (list x y)) p)
    )
    (delete 'hash)
    nil)))

(define (closest-pairs lst)
  (local (p q d tri)
    (setq p (lst 0))
    (setq q (lst 1))
    (setq d (dist p q))
    (while (> d 0)
      (setq tri (migliora lst d))
      (if tri
          (setq d (tri 0) p (tri 1) q (tri 2))
      ;else
          (setq d -1)
      )
    )
    (list p q)))

Proviamo la funzione:

(setq lst '((1 3) (4 4) (1 1) (2 5) (6 3) (8 5) (6 1) (6 5) (3 2) (2 4)))
(closest-pairs lst)
;-> ((2 4) (2 5))

Vediamo un altro esempio:

(setq lst '((-1 -3) (-4 -4) (1 1) (-2 -5) (6 3) (8 5) (6 1) (6 5) (3 2) (2 4)))
(closest-pairs lst)
;-> ((6 1) (6 3))

Vediamo con la lista di 10000 punti che avevamo generato precedentemente:

(time (println (closest-pairs d)))
;-> ((1363 5070) (1363 5071))
;-> 745.132

(dist '(1363 5070) '(1363 5071))
;-> 1

Il tempo di esecuzione è passato da 22 secondi a meno di un secondo.

La precedente funzione "closest-Pairs" aveva un output con punti diversi ((2815 1408) (2815 1409)), ma la distanza minima vale 1 in entrambi i casi. Questo accade perchè il secondo algoritmo è basato sulla casualità, infatti se mischiamo i punti della lista d è probabile che si ottenga lo stesso risultato del primo algoritmo:

(println (closest-pairs (randomize d)))
;-> ((2815 1409) (2815 1408))


--------------------------------------------
Moltiplicazione tra numeri interi (stringhe)
--------------------------------------------

Il creatore di newLISP (Lutz Mueller) ha scritto la seguente funzione che moltiplica due numeri interi passati come stringhe (è valida anche per numeri big-integer).

(define (big* x y) ; a and b are strings of decimal digits
    (letn ( nx (length x)
            ny (length y)
            np (+ nx ny)
            X (array nx (reverse (map int (explode x))))
            Y (array ny (reverse (map int (explode y))))
            Q (array (+ nx 1) (dup 0 (+ nx 1)))
            P (array np (dup 0 np))
            carry 0
            digit 0 )
        (dotimes (i ny) ; for each digit of the multiplier
            (dotimes (j nx) ; for each digit of the multiplicant
                (setq digit (+ (* (Y i) (X j)) carry) )
                (setq carry (/ digit 10))
                (setf (Q j) (% digit 10)) )
            (setf (Q nx ) carry)
            ; add Q to P shifted by i
            (setq carry 0)
            (dotimes (j (+ nx 1))
                (setq digit (+ (P (+ j i)) (Q j) carry))
                (setq carry (/ digit 10))
                (setf (P (+ j i)) (% digit 10)) )
        )
    ; translate P to string and return
    (setq P (reverse (array-list P)))
    (if (zero? (P 0)) (pop P))
    (join (map string P))
    )
)

(big* "12345678" "12345678")
;-> "152415765279684"


------------------
Numeri pandigitali
------------------

I numeri pandigitali sono numeri che contengono tutte le dieci (10) cifre 0..9 solo una volta.
Alcune volte sono consoderati pandigitali anche i numeri che contengono tutte le nove (9) cifre 1..9 solo una volta.
I numeri con zero all'inizio non vengono considerati.

Nota: I numeri pandigitali sono divisibili per 9.

Iniziamo con i numeri pandigitali (10):

(define (pan10a? n)
  (local (out)
    (cond ((or (< n 1023456789) (> n 9876543210) (!= 0 (% n 9))) (setq out nil))
          ((= (length (intersect (explode (string n)) '("0" "1" "2" "3" "4" "5" "6" "7" "8" "9"))) 10)
           (setq out true))
    )
    out
  )
)

(define (pan10b? n)
  (cond ((or (< n 1023456789) (> n 9876543210) (!= 0 (% n 9))) nil)
        (true
          (let (lst '(0 0 0 0 0 0 0 0 0 0))
            (while (!= n 0)
              (setf (lst (% n 10)) 1)
              (setq n (/ n 10))
            )
            ;(println lst)
            (if (ref '0 lst) nil true)
          )
        )
  )
)

Primo numero pandigitale (10):     1023456789
Millesimo numero pandigitale (10): 1024658793

(define (test10a)
  (setq conta 0)
  (for (i 1023456789 1024658793) (if (pan10a? i) (++ conta)))
  conta
)

(test10a)
;-> 1000

(time (test10a))
;-> 1044.941

(define (test10b)
  (setq conta 0)
  (for (i 1023456789 1024658793) (if (pan10b? i) (++ conta)))
  conta
)

(test10b)
;-> 1000

(time (test10b))
;-> 605.393

Vediamo ora in numeri pandigitali (9):

(define (pan9a? n)
  (local (out)
    (cond ((or (< n 123456789) (> n 987654321) (!= 0 (% n 9))) (setq out nil))
          ((= (length (intersect (explode (string n)) '("1" "2" "3" "4" "5" "6" "7" "8" "9"))) 9)
           (setq out true))
    )
    out
  )
)

(define (pan9b? n)
  (cond ((or (< n 123456789) (> n 987654321) (!= 0 (% n 9))) nil)
        (true
          (let (lst '(0 -1 -1 -1 -1 -1 -1 -1 -1 -1))
            (while (!= n 0)
              (setf (lst (% n 10)) 1)
              (setq n (/ n 10))
            )
            ;(println lst)
            (if (ref '-1 lst) nil true)
          )
        )
  )
)

(define (test9a)
  (setq conta 0)
  (for (i 123456789 123987654) (if (pan9a? i) (++ conta)))
  conta
)

(test9a)
;-> 720

(time (test9a))
;-> 449.521

(define (test9b)
  (setq conta 0)
  (for (i 123456789 123987654) (if (pan9b? i) (++ conta)))
  conta
)

(test9b)
;-> 720

(time (test9b))
;-> 277.714


--------------------------------------
Somma dei divisori propri di un numero
--------------------------------------

Prima versione:

(define (sum-proper-divisors n)
  (setq res 0)
  (setq m (sqrt n))
  (setq i 2)
  (while (<= i m)
      (if (zero? (% n i))   ; se 'i' è divisore di 'n'
          (if (= i (/ n i))              ; se entrambi i divisori sono uguali...
            (setq res (+ res i))         ; allora aggiungilo una volta,
            (setq res (+ res i (/ n i))) ; altrimenti aggiungili entrambi.
          )
      )
      (setq i (+ i 1))
  )
  (+ 1 res)
)

Seconda versione:

(define (somma-divisori-propri n)
  (local (somma fine)
    (setq somma 0)
    (setq fine (int (sqrt n)))
    (for (i 2 fine)
      (if (zero? (% n i))
        (setq somma (+ somma i (/ n i)))
      )
    )
    (if (= n (* fine fine) (setq somma (- somma fine))))
    (+ 1 somma)
  )
)

Terza versione:

(define (factor-group x)
  (if (= x 1) '(1 1)
    (letn (fattori (factor x)
          unici (unique fattori))
      (transpose (list unici (count unici fattori)))
    )
  )
)

(factor-group 220)
;-> ((2 2) (5 1) (11 1))

(factor-group 1)
;-> (1 1)

(define (somma-divisori-propri-fast n)
  (if (= n 1) '0
    (begin (setq res 1)
     (setq lst (factor-group n))
     (dolist (el lst)
       (setq somma-el 0)
       (for (i 0 (last el))
         (setq somma-el (+ somma-el (pow (first el) i)))
       )
       (setq res (* res somma-el))
     )
     (- res n)) ;somma divisori propri (tutti tranne se stesso)
  )
)

(sum-proper-divisors 12345678901234567)
;-> 1763668414462089
(somma-divisori-propri 12345678901234567)
;-> 1763668414462089
(somma-divisori-propri-fast 12345678901234567)
;-> 1763668414462089

(time (sum-proper-divisors 12345678901234567))
;-> 17358.122
(time (somma-divisori-propri 12345678901234567))
;-> 8089.74
(time (somma-divisori-propri-fast 12345678901234567))
;-> 199.812


----------------------------
Labirinti (calcolo percorsi)
----------------------------

Un labirinto è un percorso o un insieme di percorsi, in genere con uno o più ingressi e con nessuna o più uscite.
Per risolvere un labirinto (maze) utilizzeremo il seguente algoritmo che trova la soluzione (se esiste) in modo ricorsivo. Si parte da un valore iniziale X e Y. Se i valori X e Y non sono su un muro, il metodo (funzione) richiama se stesso con tutti i valori X e Y adiacenti, assicurandosi di non aver utilizzato in precedenza quei valori X e Y. Se i valori X e Y sono quelli della posizione finale, salva tutte le istanze precedenti del metodo (risultati parziali) creando una matrice con il percorso risolutivo.
Questo metodo non garantisce che la soluzione trovata sia quella più breve.

(define (solveMaze matrice sRow sCol eRow eCol)
  (local (maze row col visited correctPath startRow startCol endRow endCol)
    ; matrice labirinto
    (setq maze matrice)
    ; righe della matrice
    (setq row (length maze))
    ; colonne della matrice
    (setq col (length (first maze)))
    ; matrice delle celle visitate
    (setq visited (array row col '(nil)))
    ; matrice soluzione del labirinto
    (setq correctPath (array row col '(nil)))
    ; posizione iniziale: riga
    (setq startRow sRow)
    ; posizione iniziale: colonna
    (setq startCol sCol)
    ; posizione finale: riga
    (setq endRow eRow)
    ; posizione finale: colonna
    (setq endCol eCol)
    ;
    ; funzione recursive solve
    ;
    (define (recursiveSolve x y)
      (catch
        (local (return)
          ;controllo se abbiamo raggiunto la fine e non è un muro
          (if (and (= x endRow) (= y endCol) (!= (maze x y) 2))
              (throw (setf (correctPath x y) true))
          )
          ; cella muro o cella visitata
          (if (or (= (maze x y) 2) (= (visited x y) true)) (throw nil))
          ; imposta cella come visitata
          (setf (visited x y) true)
          ; controllo posizione riga 0
          (if (!= x 0)
              ; richiama la funzione una riga in basso
              (if (recursiveSolve (- x 1) y)
                  (throw (setf (correctPath x y) true))
              )
          )
          ; controllo posizione riga (row - 1)
          (if (!= x (- row 1))
              ; richiama la funzione una riga in alto
              (if (recursiveSolve (+ x 1) y)
                  (throw (setf (correctPath x y) true))
              )
          )
          ; controllo posizione colonna 0
          (if (!= y 0)
              ; richiama la funzione una colonna a sinistra
              (if (recursiveSolve x (- y 1))
                  (throw (setf (correctPath x y) true))
              )
          )
          ; controllo posizione colonna (col - 1)
          (if (!= y (- col 1))
              ; richiama la funzione una colonna a destra
              (if (recursiveSolve x (+ y 1))
                  (throw (setf (correctPath x y) true))
              )
          )
          return
        );local
      ) ;catch
    ); recursiveSolve
    ;
    ; Chiama la funzione ricorsiva di soluzione
    ; Se (recursiveSolve startRow startCol) ritorna nil,
    ; allora il labirinto non ha soluzione.
    ; Altrimenti la matrice booleana "correctPath"
    ; contiene la soluzione (valori true).
    (if (recursiveSolve startRow startCol) (showPath correctPath))
  );local
)

(define (showPath matrix)
  (local (row col)
    ; righe della matrice
    (setq row (length matrix))
    ; colonne della matrice
    (setq col (length (first matrix)))
    ; stampa
    (for (i 0 (- row 1))
      (for (j 0 (- col 1))
        (if (matrix i j) (print " 1") (print " 0"))
      )
      (println)
    )
    true
  )
)

Esempio 1:
; matrice labirinto (1 = libero, 2 = muro)

 1 1 1 1
 2 2 1 1
 1 2 2 1
 2 2 2 1
 1 1 1 1

; definizione labirinto
(setq righe 5)
(setq colonne 4)
(setq matrice (array righe colonne '(1 1 1 1  2 2 1 1  1 2 2 1  2 2 2 1  1 1 1 1)))
(solveMaze matrice 0 0 4 3)
;-> 1 1 1 0
;-> 0 0 1 1
;-> 0 0 0 1
;-> 0 0 0 1
;-> 0 0 0 1

Esempio 2:
; matrice labirinto (1 = libero, 2 = muro)

 1 1 2 1 2
 2 1 1 1 2
 2 1 2 2 2
 2 1 1 1 1

; definizione labirinto
(setq righe 4)
(setq colonne 5)
(setq matrice (array righe colonne '(1 1 2 1 2  2 1 1 1 2  2 1 2 2 2  2 1 1 1 1)))
(solveMaze matrice 0 0 3 4)
;-> 1 1 0 0 0
;-> 0 1 0 0 0
;-> 0 1 0 0 0
;-> 0 1 1 1 1

Esempio 3:
; matrice labirinto (1 = libero, 2 = muro)

 1 1 2 1 2 1 1 1 2 1 2 1 2 1 2 2 1 1 1 2
 2 1 1 1 2 2 1 1 1 1 1 2 2 1 1 1 1 1 2 2
 2 1 2 2 2 2 2 1 1 2 2 2 1 2 2 2 2 1 2 1
 2 1 1 1 1 1 2 2 2 1 1 1 1 2 2 2 1 2 1 2
 1 2 2 2 2 1 2 2 1 2 1 2 1 2 2 1 1 2 2 2
 1 2 2 2 2 1 1 1 1 2 1 2 1 2 2 1 1 2 2 2
 1 2 2 2 2 2 2 2 1 2 1 2 1 2 2 1 2 1 2 2
 1 2 2 2 2 2 2 2 1 1 1 2 1 2 2 1 1 1 2 2
 1 2 2 2 2 2 2 2 1 2 2 2 1 1 1 1 2 1 1 1
 1 2 2 2 2 2 2 2 1 2 2 2 1 2 2 1 2 2 2 1
 1 2 2 2 2 2 2 2 1 2 2 2 1 2 2 1 2 2 2 1
 1 2 2 2 2 2 2 2 1 2 2 2 1 2 2 1 2 2 2 1

Soluzione:

 * * 2 1 2 1 1 1 2 1 2 1 2 1 2 2 1 1 1 2
 2 * 1 1 2 2 1 1 1 1 1 2 2 1 1 1 1 1 2 2
 2 * 2 2 2 2 2 1 1 2 2 2 1 2 2 2 2 1 2 1
 2 * * * * * 2 2 2 1 * * * 2 2 2 1 2 1 2
 1 2 2 2 2 * 2 2 1 2 * 2 * 2 2 1 1 2 2 2
 1 2 2 2 2 * * * * 2 * 2 * 2 2 1 1 2 2 2
 1 2 2 2 2 2 2 2 * 2 * 2 * 2 2 1 2 1 2 2
 1 2 2 2 2 2 2 2 * * * 2 * 2 2 * * * 2 2
 1 2 2 2 2 2 2 2 1 2 2 2 * * * * 2 * * *
 1 2 2 2 2 2 2 2 1 2 2 2 1 2 2 1 2 2 2 *
 1 2 2 2 2 2 2 2 1 2 2 2 1 2 2 1 2 2 2 *
 1 2 2 2 2 2 2 2 1 2 2 2 1 2 2 1 2 2 2 *

; definizione labirinto
(setq righe 12)
(setq colonne 20)

(setq matrice (array righe colonne '(
 1 1 2 1 2 1 1 1 2 1 2 1 2 1 2 2 1 1 1 2
 2 1 1 1 2 2 1 1 1 1 1 2 2 1 1 1 1 1 2 2
 2 1 2 2 2 2 2 1 1 2 2 2 1 2 2 2 2 1 2 1
 2 1 1 1 1 1 2 2 2 1 1 1 1 2 2 2 1 2 1 2
 1 2 2 2 2 1 2 2 1 2 1 2 1 2 2 1 1 2 2 2
 1 2 2 2 2 1 1 1 1 2 1 2 1 2 2 1 1 2 2 2
 1 2 2 2 2 2 2 2 1 2 1 2 1 2 2 1 2 1 2 2
 1 2 2 2 2 2 2 2 1 1 1 2 1 2 2 1 1 1 2 2
 1 2 2 2 2 2 2 2 1 2 2 2 1 1 1 1 2 1 1 1
 1 2 2 2 2 2 2 2 1 2 2 2 1 2 2 1 2 2 2 1
 1 2 2 2 2 2 2 2 1 2 2 2 1 2 2 1 2 2 2 1
 1 2 2 2 2 2 2 2 1 2 2 2 1 2 2 1 2 2 2 1)))

(solveMaze matrice 0 0 11 19)
;-> 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
;-> 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
;-> 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
;-> 0 1 1 1 1 1 0 0 0 0 1 1 1 0 0 0 0 0 0 0
;-> 0 0 0 0 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0
;-> 0 0 0 0 0 1 1 1 1 0 1 0 1 0 0 0 0 0 0 0
;-> 0 0 0 0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 0 0
;-> 0 0 0 0 0 0 0 0 1 1 1 0 1 0 0 1 1 1 0 0
;-> 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 0 1 1 1
;-> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
;-> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
;-> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1

Esempio 4:
; matrice labirinto (1 = libero, 2 = muro)

 1 1 2 1 2 1 1 1 2
 2 1 1 1 2 2 1 1 1
 2 1 2 2 2 2 2 1 1
 2 1 1 1 1 1 2 2 2
 1 2 2 2 2 1 2 2 1
 1 2 2 2 2 1 2 1 1
 1 2 2 2 2 2 2 2 1
 1 2 2 2 2 2 2 2 1
 1 2 2 2 2 2 2 2 1

Nessuna soluzione.

; definizione labirinto
(setq righe 9)
(setq colonne 9)

(setq matrice (array righe colonne '(
 1 1 2 1 2 1 1 1 2
 2 1 1 1 2 2 1 1 1
 2 1 2 2 2 2 2 1 1
 2 1 1 1 1 1 2 2 2
 1 2 2 2 2 1 2 2 1
 1 2 2 2 2 1 2 1 1
 1 2 2 2 2 2 2 2 1
 1 2 2 2 2 2 2 2 1
 1 2 2 2 2 2 2 2 1)))

(solveMaze matrice 0 0 8 8)
;-> nil

(solveMaze matrice 0 0 5 5)
;-> 1 1 0 0 0 0 0 0 0
;-> 0 1 0 0 0 0 0 0 0
;-> 0 1 0 0 0 0 0 0 0
;-> 0 1 1 1 1 1 0 0 0
;-> 0 0 0 0 0 1 0 0 0
;-> 0 0 0 0 0 1 0 0 0
;-> 0 0 0 0 0 0 0 0 0
;-> 0 0 0 0 0 0 0 0 0
;-> 0 0 0 0 0 0 0 0 0

Esempio 5:
; matrice labirinto (1 = libero, 2 = muro)

 1 1 2 1 2 1 1 2 1
 2 1 1 1 2 2 1 1 1
 2 1 2 2 2 2 2 1 2
 2 1 1 1 1 1 2 1 1
 1 2 2 2 2 1 2 2 1
 1 2 2 2 2 1 1 1 1
 1 1 1 1 1 2 1 2 1
 1 2 2 2 1 2 1 2 1
 1 2 2 2 1 1 1 2 1

Soluzione:

 1 1 2 1 2 1 1 2 *
 2 1 1 1 2 2 1 * *
 2 1 2 2 2 2 2 * 2
 2 1 1 1 1 1 2 * *
 1 2 2 2 2 1 2 2 *
 1 2 2 2 2 1 * * *
 * * * * * 2 * 2 1
 * 2 2 2 * 2 * 2 1
 * 2 2 2 * * * 2 1

; definizione labirinto
(setq righe 9)
(setq colonne 9)

(setq matrice (array righe colonne '(
 1 1 2 1 2 1 1 2 1
 2 1 1 1 2 2 1 1 1
 2 1 2 2 2 2 2 1 2
 2 1 1 1 1 1 2 1 1
 1 2 2 2 2 1 2 2 1
 1 2 2 2 2 1 1 1 1
 1 1 1 1 1 2 1 2 1
 1 2 2 2 1 2 1 2 1
 1 2 2 2 1 1 1 2 1)))

(solveMaze matrice 8 0 0 8)
;-> 0 0 0 0 0 0 0 0 1
;-> 0 0 0 0 0 0 0 1 1
;-> 0 0 0 0 0 0 0 1 0
;-> 0 0 0 0 0 0 0 1 1
;-> 0 0 0 0 0 0 0 0 1
;-> 0 0 0 0 0 0 1 1 1
;-> 1 1 1 1 1 0 1 0 0
;-> 1 0 0 0 1 0 1 0 0
;-> 1 0 0 0 1 1 1 0 0


--------------------------
Moltiplicazioni di fattori
--------------------------

Dato un numero N, creare la lista dei numeri che possono essere ottenuti dal prodotto di tutte le combinazioni dei fattori primi del numero N.
Nota: i numeri primi restituiscono una lista vuota.

Esempio:
N = 12
Fattori = 2 2 3
Prodotti = 2*2 2*3 2*2*3 = 4 6 12

(define (combinazioni k nlst)
  (cond ((zero? k)     '(()))
        ((null? nlst)  '())
        (true
          (append (map (lambda (k-1) (cons (first nlst) k-1))
                       (combinazioni (- k 1) (rest nlst)))
                  (combinazioni k (rest nlst))))))

(setq fattori (factor 12))

(setq c1 (combinazioni 1 fattori))
;-> ((2) (2) (3))
(setq c2 (combinazioni 2 fattori))
;-> ((2 2) (2 3) (2 3))
(setq c3 (combinazioni 3 fattori))
;-> ((2 2 3))

(setq r1 (map (fn (x) (apply * x)) c1))
;-> (2 2 3)
(setq r2 (map (fn (x) (apply * x)) c2))
;-> (4 6 6)
(setq r3 (map (fn (x) (apply * x)) c3))
;-> (12)
(setq r (append r1 r2 r3))
;-> (2 2 3 4 6 6 12)
(setq r (unique r))
;-> (2 3 4 6 12)
(setq r (difference r fattori))
;-> (4 6 12)

Esempio con N = 36:

(setq fattori (factor 36))
(setq c1 (combinazioni 1 fattori))
;-> ((2) (2) (3) (3))
(setq c2 (combinazioni 2 fattori))
;-> ((2 2) (2 3) (2 3) (2 3) (2 3) (3 3))
(setq c3 (combinazioni 3 fattori))
;-> ((2 2 3) (2 2 3) (2 3 3) (2 3 3))
(setq c4 (combinazioni 4 fattori))
;-> ((2 2 3 3))

(setq r1 (map (fn (x) (apply * x)) c1))
;-> (2 2 3 3)
(setq r2 (map (fn (x) (apply * x)) c2))
;-> (4 6 6 6 6 9)
(setq r3 (map (fn (x) (apply * x)) c3))
;-> (12 12 18 18)
(setq r4 (map (fn (x) (apply * x)) c4))
;-> (36)

(setq r (difference (unique(append r1 r2 r3 r4)) fattori))
;-> (4 6 9 12 18 36)

Possiamo scrivere la funzione:

(define (mult-fact n)
  (local (fattori c r out)
    (setq out '())
    (setq fattori (factor n))
    (if (= fattori nil) '()
      (begin
        (for (i 1 (length fattori))
          (setq c (combinazioni i fattori))
          (setq r (map (fn (x) (apply * x)) c))
          (push r out -1)
        )
        (sort (difference (unique (flat out)) fattori))
      )
    );if
  );local
)

(mult-fact 12)
;-> (4 6 12)

(mult-fact 36)
;-> (4 6 9 12 18 36)

(mult-fact 100)
;-> (4 10 25 20 50 100)

(mult-fact 31)
;-> ()

(mult-fact 1)
;-> ()

(mult-fact 10032)
;-> (4 6 8 12 16 22 24 33 38 44 48 57 66 76 88 114 132 152 176 209 228
;->  264 304 418 456 528 627 836 912 1254 1672 2508 3344 5016 10032)

Vediamo per curiosità quale numero fino a diecimila genera la lista più lunga.

(define (entro10000)
  (setq lungo 0)
  (setq val 0)
  (for (i 10 10000)
    (if (> (length (mult-fact i)) lungo)
      (setq lungo (length (mult-fact i)) val i)
    )
  )
  (println "numero: " val { --- } "lunghezza: " lungo)
)

(entro10000)
;-> numero: 7560 --- lunghezza: 59


---------------------------------------------
Problemi patologici dei numeri floating point
---------------------------------------------

La Chaotic Bank Society offre questo investimento ai propri clienti.
Per prima cosa depositi (e - 1) euro dove e è 2.7182818 ... la base dei logaritmi naturali.

Dopo ogni anno, il saldo del tuo account verrà moltiplicato per il numero di anni che sono passati e verranno rimossi 1 euro in costi di servizio.

Così ...

dopo 1 anno, il saldo verrà moltiplicato per 1 e 1 euro verrà rimosso per le spese di servizio.
dopo 2 anni il saldo sarà raddoppiato e 1 euro rimosso.
dopo 3 anni il saldo sarà triplicato e 1 euro rimosso.
...
dopo 10 anni, moltiplicato per 10 e 1 euro rimosso, e così via.

Quale sarà il tuo saldo dopo 25 anni?

Risultato corretto:
    Saldo iniziale: (e - 1)
    Saldo = (Saldo * anno) - 1 (per 25 anni)
    Saldo dopo 25 anni: 0.0399387296732302

Proviamo con una funzione che utilizza i numeri floating point:

(define (banca)
  (local (e deposito)
    ;definiamo il numero e
    (setq e (exp 1))
    (setq deposito (sub e 1))
    (for (i 1 25)
      (setq deposito (sub (mul deposito i) 1))
      (println i { } deposito)
    )
    deposito
  )
)

(banca)
;-> 1   0.7182818284590451
;-> 2   0.4365636569180902
;-> 3   0.3096909707542705
;-> 4   0.2387638830170822
;-> 5   0.1938194150854109
;-> 6   0.1629164905124654
;-> 7   0.1404154335872576
;-> 8   0.1233234686980609
;-> 9   0.1099112182825479
;-> 10  0.09911218282547907
;-> 11  0.09023401108026974
;-> 12  0.08280813296323686
;-> 13  0.07650572852207915
;-> 14  0.07108019930910814
;-> 15  0.06620298963662208
;-> 16  0.05924783418595325
;-> 17  0.007213181161205284
;-> 18 -0.8701627390983049
;-> 19 -17.53309204286779
;-> 20 -351.6618408573559
;-> 21 -7385.898658004473
;-> 22 -162490.7704760984
;-> 23 -3737288.720950264
;-> 24 -89694930.30280632
;-> 25 -2242373258.570158
;-> -2242373258.570158

Il risultato è sbagliato, poichè gli arrotondamenti delle operazioni floating point fanno divergere i calcoli.
Per risolvere il problema possiamo usare le frazioni, cioè eseguiamo tutti i calcoli con le frazioni (numeri interi) e usiamo la divisione solo per ottenere il valore del risultato come floating point. Per fare questo dobbiamo rappresentare anche il numero "e" con una frazione:

e = 106246577894593683 / 39085931702241241

Le funzioni per utilizzare le quattro operazioni delle frazioni sono le seguenti:

(define (semplifica frac)
  (local (num den n d temp, nums dens)
    (setq num (first frac))
    (setq den (last frac))
    (setq n (first frac))
    (setq d (last frac))
    ; calcola il numero massimo che divide esattamente numeratore e denominatore
    (while (!= d 0)
      (setq temp d)
      (setq d (% n temp))
      (setq n temp)
    )
    (setq nums (/ num n))
    (setq dens (/ den n))
    ; controllo del segno
    (cond ((or (and (< dens 0) (< nums 0)) (and (< dens 0) (> nums 0)))
           (setq nums (* nums -1))
           (setq dens (* dens -1))
          )
    )
    (list nums dens)
  )
)

(define (+f frac1 frac2 redux)
  (local (num den n1 d1 n2 d2)
    (setq n1 (first frac1))
    (setq d1 (last frac1))
    (setq n2 (first frac2))
    (setq d2 (last frac2))
    (setq num (+ (* n1 d2) (* n2 d1)))
    (setq den (* d1 d2))
    (if redux (list num den)
          (semplifica (list num den))
    )
  )
)

(define (-f frac1 frac2 redux)
  (local (num den n1 d1 n2 d2)
    (setq n1 (first frac1))
    (setq d1 (last frac1))
    (setq n2 (first frac2))
    (setq d2 (last frac2))
    (setq num (- (* n1 d2) (* n2 d1)))
    (setq den (* d1 d2))
    (if redux (list num den)
          (semplifica (list num den))
    )
  )
)

(define (*f frac1 frac2 redux)
  (local (num den n1 d1 n2 d2)
    (setq n1 (first frac1))
    (setq d1 (last frac1))
    (setq n2 (first frac2))
    (setq d2 (last frac2))
    (setq num (* n1 n2))
    (setq den (* d1 d2))
    (if redux (list num den)
          (semplifica (list num den))
    )
  )
)

(define (/f frac1 frac2 redux)
  (local (num den n1 d1 n2 d2)
    (setq n1 (first frac1))
    (setq d1 (last frac1))
    (setq n2 (first frac2))
    (setq d2 (last frac2))
    (setq num (* n1 d2))
    (setq den (* d1 n2))
    (if redux (list num den)
          (semplifica (list num den))
    )
  )
)

Adesso riscriviamo la funzione che calcola il valore finale dell'investimento:

(define (banca)
  (local (e deposito)
    ;definiamo il numero e
    (setq e '(106246577894593683L 39085931702241241L))
    (setq deposito (-f e '(1 1)))
    (for (i 1 25)
      (setq deposito (-f (*f deposito (list i 1)) '(1 1)))
      (println i { } deposito { } (div (first deposito) (last deposito)))
    )
    deposito
  )
)

(banca)
;-> 1  (28074714490111201L 39085931702241241L) 0.7182818284590452
;-> 2  (17063497277981161L 39085931702241241L) 0.4365636569180905
;-> 3  (12104560131702242L 39085931702241241L) 0.3096909707542714
;-> 4  (9332308824567727L 39085931702241241L) 0.2387638830170857
;-> 5  (7575612420597394L 39085931702241241L) 0.1938194150854282
;-> 6  (6367742821343123L 39085931702241241L) 0.1629164905125695
;-> 7  (5488268047160620L 39085931702241241L) 0.1404154335879862
;-> 8  (4820212675043719L 39085931702241241L) 0.1233234687038897
;-> 9  (4295982373152230L 39085931702241241L) 0.1099112183350075
;-> 10 (3873892029281059L 39085931702241241L) 0.09911218335007542
;-> 11 (3526880619850408L 39085931702241241L) 0.09023401685082953
;-> 12 (3236635735963655L 39085931702241241L) 0.08280820220995427
;-> 13 (2990332865286274L 39085931702241241L) 0.07650662872940559
;-> 14 (2778728411766595L 39085931702241241L) 0.07109280221167809
;-> 15 (2594994474257684L 39085931702241241L) 0.06639203317517139
;-> 16 (2433979885881703L 39085931702241241L) 0.06227253080274239
;-> 17 (2291726357747710L 39085931702241241L) 0.05863302364662064
;-> 18 (2165142737217539L 39085931702241241L) 0.05539442563917152
;-> 19 (2051780304892000L 39085931702241241L) 0.05249408714425882
;-> 20 (1949674395598759L 39085931702241241L) 0.04988174288517631
;-> 21 (1857230605332698L 39085931702241241L) 0.04751660058870241
;-> 22 (1773141615078115L 39085931702241241L) 0.04536521295145283
;-> 23 (1696325444555404L 39085931702241241L) 0.04339989788341503
;-> 24 (1625878967088455L 39085931702241241L) 0.04159754920196069
;-> 25 (1561042474970134L 39085931702241241L) 0.03993873004901714
;-> (1561042474970134L 39085931702241241L)

Questa volta il risultato è esatto.

Sul forum di newLISP, rickyboy ha fornito le seguenti funzioni equivalenti:

(define (rat n d)
  (let (g (gcd n d))
    (map (curry * 1L)
         (list (/ n g) (/ d g)))))

(define (+rat r1 r2)
  (rat (+ (* (r1 0) (r2 1))
          (* (r2 0) (r1 1)))
       (* (r1 1) (r2 1))))

(define (-rat r1 r2)
  (rat (- (* (r1 0) (r2 1))
          (* (r2 0) (r1 1)))
       (* (r1 1) (r2 1))))

(define (*rat r1 r2)
  (rat (* (r1 0) (r2 0))
       (* (r1 1) (r2 1))))

(define (/rat r1 r2)
  (rat (* (r1 0) (r2 1))
       (* (r1 1) (r2 0))))


------------------
Numerali di Church
------------------

Nella codifica di Church dei numeri naturali, il numero N viene codificato da una funzione che applica il suo primo argomento N volte al suo secondo argomento.

Church ZERO restituisce sempre la funzione identità, indipendentemente dal suo primo argomento. In altre parole, il primo argomento non viene applicato al secondo argomento.
Church UNO applica il suo primo argomento f solo una volta al secondo argomento x, producendo f(x).
Church DUE applica il suo primo argomento f due volte al suo secondo argomento x, producendo f(f(x))
e ogni successivo numero della Chiesa applica il suo primo argomento una volta in più al secondo argomento, f(f(f(x))), f(f(f(f(x)))) ... Il numero Church 4, per ad esempio, restituisce una composizione quadrupla della funzione fornita come primo argomento.
Le operazioni aritmetiche sui numeri naturali possono essere similmente rappresentate come funzioni sui numeri di Church.

Definiamo i numeri di Church:

(define (zero f x) x)
(define (uno f x) (f x))
(define (due f x) (f (f x)))
(define (tre f x) (f (f (f x))))
(define (quattro f x) (f (f (f (f x)))))
(define (cinque f x) (f (f (f (f (f x))))))
(define (sei f x) (f (f (f (f (f (f x)))))))
(define (sette f x) (f (f (f (f (f (f (f x))))))))
(define (otto f x) (f (f (f (f (f (f (f x))))))))
(define (otto f x) (f (f (f (f (f (f (f (f x)))))))))
(define (nove f x) (f (f (f (f (f (f (f (f (f x))))))))))

(zero inc 0)
;-> 0
(uno inc 0)
;-> 1
(due inc 0)
;-> 2

Oppure:

(setq f inc)
(setq x 0)
(zero f x)
;-> 0
(sei f x)
;-> 6

Definiamo la funzione successore "succ":

(define (succ n f x) (f (f n x)))

(succ 0 inc 0)
;-> 1
(succ 3 inc 0)
;-> 4
(succ 2 inc 0)
;-> 3

Definiamo la funzione somma "plus":

(define (plus m n f x) (f m (f n x)))
(plus 3 2 inc 0)
;-> 5
(plus (due inc 0) 5 inc 0)
;-> 7
(plus (due f x) 5 f x)
;-> 7

Adesso dovremmo definire la funzioni precedente "prec", la funzione moltiplicazione "molt" e la funzione sottrazione "minus". Dopo aver avuto un aiuto da kosh ho deciso di utilizzare il suo metodo per definire i numerali di Church (https://gist.github.com/kosh04/262332)

La funzione "expand" espande solo i simboli che iniziano con una lettera maiuscola:

(define-macro (LAMBDA)
  (append (lambda) (expand (args))))

(define DEFINE define)

Numeri naturali e aritmetica:

; 0: = λfx.x
(DEFINE ZERO (LAMBDA (F) (LAMBDA (X) X)))
; 1: = λfx.fx
(DEFINE UNO  (LAMBDA (F) (LAMBDA (X) (F X))))
(define UNO  (LAMBDA (F) (LAMBDA (X) (F X))))
; 2: = λfx.f (fx)              ; 1: = λfx.fx
(DEFINE DUE  (LAMBDA (F) (LAMBDA (X) (F (F X)))))
(define DUE  (LAMBDA (F) (LAMBDA (X) (F (F X)))))
; 3: = λfx.f (f (fx))
(DEFINE TRE  (LAMBDA (F) (LAMBDA (X) (F (F (F X))))))
(DEFINE QUATTRO (LAMBDA (F) (LAMBDA (X) (F (F (F (F X)))))))
(DEFINE CINQUE  (LAMBDA (F) (LAMBDA (X) (F (F (F (F (F X))))))))
(DEFINE SEI  (LAMBDA (F) (LAMBDA (X) (F (F (F (F (F (F X)))))))))

; SUCC: = λnfx.f (n f x)
(DEFINE (SUCC N) (LAMBDA (F) (LAMBDA (X) (F (N F X)))))

; PLUS: = λmnfx.m f (n f x)
(DEFINE (PLUS M N) (LAMBDA (F) (LAMBDA (X) ((M F) ((N F) X)))))
(define (PLUS M N) (LAMBDA (F) (LAMBDA (X) ((M F) ((N F) X)))))

; MOLT: = λ mn f. M (n f)
(DEFINE (MOLT M N) (LAMBDA (F) (LAMBDA (X) ((N (M F) X)))))

; POW: = λbe.e b
(DEFINE (POW B E) (E B))

(define (to-number x) ((x (lambda (n) (+ n 1))) 0))

(define (to-lambda n) (if (< 0 n) (SUCC (to-lambda (- n 1))) (ZERO)))

(to-number ZERO)
;-> 0
(to-number UNO)
;-> 1
(to-number DUE)
;-> 2

La funzione seguente prende un intero e ritorna il numero nella forma di Church:

(define (reduce stencil sq) (apply stencil sq 2))

(define (num n)
(cond
   ((= n 0) 'x)
   ((< n 2) '(f x))
   (true (reduce (fn (l i) (list 'f l)) (cons '(f x) (sequence 2 n)) ))))

(define (church-encode n)
  (letex ((body (num n)))
    (fn (f x) body)))

(church-encode 0)
;-> (lambda (f x) x)
(church-encode 4)
;-> (lambda (f x) (f (f (f (f x)))))

(num 0)
;-> x

(num 4)
;-> (f (f (f (f x))))

Per adesso mi fermo qui, devo ragionarci un pò di più :-)


-----------------------------------
Creazione e valutazione di polinomi
-----------------------------------

Supponiamo di avere il polinomio y(x) = 3*x^2 - 7*x + 5 e di voler calcolare i valori di y per x che varia da 0 a 10 (con passo 1).
Possiamo definire una funzione che rappresenta il polinomio:

(define (poly x)
  (+ 5 (mul 7 x) (mul 3 (pow x 2))))

(poly 0)
;-> 5

E poi per ottenere i valori cercati possiamo scrivere:

(for (x 0 10) (println x { } (poly x)))
;-> 0 5
;-> 1 15
;-> 2 31
;-> 3 53
;-> 4 81
;-> 5 115
;-> 6 155
;-> 7 201
;-> 8 253
;-> 9 311
;-> 10 375

Poichè i polinomi hanno una struttura ben definita possiamo scrivere una funzione che prende i coefficienti di un polinomio e restituisce una funzione che rappresenta il polinomio:
Ad esempio, il polinomio:

 y(x) = 4*x^3 + 5*x^2 + 7*x + 10

viene rappresentato dalla funzione:

 (lambda (x) (add 10 (mul x 7) (mul (pow x 2) 5) (mul (pow x 3) 4)))

La nostra funzione deve quindi costruire una nuova funzione lambda che rappresenta il polinomio (lavoriamo sulla funzione lambda come se fosse una lista).

; y(x) = 4*x^3 + 5*x^2 + 7*x + 10)
; (setq poly (crea-polinomio '(4 5 7 10)))
; poly -> (lambda (x) (add 10 (mul x 7) (mul (pow x 2) 5) (mul (pow x 3) 4)))

(define (crea-polinomio coeff)
  (local (fun body)
    (reverse coeff)
    (setq fun '(lambda (x) x)) ;funzione lambda base
    (setq body '()) ;corpo della funzione
    (push 'add body -1)
    (push (first coeff) body -1) ;termine noto
    (push (list 'mul 'x (coeff 1)) body -1) ;termine lineare
    (for (i 2 (- (length coeff) 1))
      (push (list 'mul (list 'pow 'x i) (coeff i)) body -1)
    )
    (setq (last fun) body) ;modifica corpo della funzione
    fun
  )
)

Adesso possiamo definire una nuova funzione "poly" che rappresenta il nostro polinomio:

(setq poly (crea-polinomio '(4 5 7 10)))
;-> (lambda (x) (add 10 (mul x 7) (mul (pow x 2) 5) (mul (pow x 3) 4)))

Valutando il polinomio per x = 0 otteniamo il termine noto:

(poly 0)
;-> 10

Usiamo la funzione "poly" in un ciclo for:

(for (x 0 10) (println x { } (poly x)))
;-> 0 10
;-> 1 26
;-> 2 76
;-> 3 184
;-> 4 374
;-> 5 670
;-> 6 1096
;-> 7 1676
;-> 8 2434
;-> 9 3394
;-> 10 4580

Proviamo con i dati del primo esempio:

(setq poly2 (crea-polinomio '(3 7 5)))
;-> (lambda (x) (add 5 (mul x 7) (mul (pow x 2) 3)))

(for (x 0 10) (println x { } (poly2 x)))
;-> 0 5
;-> 1 15
;-> 2 31
;-> 3 53
;-> 4 81
;-> 5 115
;-> 6 155
;-> 7 201
;-> 8 253
;-> 9 311
;-> 10 375

Sul forum di newLISP, raph.ronnquist ha fornito la seguente funzione per creare polinomi:

(define (make-poly coeff)
  (let ((rank (length coeff))
        (polyterm (fn (k) (case (dec rank)
                                (0 k)
                                (1 (list 'mul 'x k))
                                (true (list 'mul (list 'pow 'x rank) k))))))
    (push (cons 'add (reverse (map polyterm coeff))) (copy '(fn (x))) -1)))

(setq poly3 (make-poly '(3 7 5)))
;-> (lambda (x) (add 5 (mul x 7) (mul (pow x 2) 3)))
(setq poly-x (make-poly '(4 5 7 10)))
;-> (lambda (x) (add 10 (mul x 7) (mul (pow x 2) 5) (mul (pow x 3) 4)))

Sul forum di newLISP, rickyboy ha fornito la seguente funzione per creare polinomi con la regola di Horner:

(define (make-poly-horner coeffs)
  (push (if (< (length coeffs) 2)
            (first coeffs)
            (apply (fn (acc c) (list 'add c (cons 'mul (list 'x acc))))
                   coeffs 2))
        (copy '(fn (x))) -1))

(setq poly4 (make-poly-horner '(3 7 5)))
;-> (lambda (x) (add 5 (mul x (add 7 (mul x 3)))))

(poly4 0)
;-> 5

I due metodi danno risultati leggermente diversi perchè i polinomi non sono uguali, quindi le operazioni sui numeri floating producono approssimazioni diverse.
(setq poly2 (crea-polinomio '(3.2 7.2 -1.5 -2.2)))
(setq poly4 (make-poly-horner '(3.2 7.2 -1.5 -2.2)))

(for (x 0 10 0.5)
  (if (!= (poly2 x) (poly4 x))
      (println x { } (poly2 x) { } (poly4 x))))
;-> 0.5 -0.7500000000000001 -0.75
;-> 3 144.5 144.5
;-> 3.5 217.95 217.9500000000001
;-> 6.5 1171.05 1171.05
;-> 7 1437.7 1437.7
;-> 8 2085 2085.000000000001

In questo caso l'errore è molto piccolo:
(setq eps 1e-3)

(for (x 0 10 0.5)
  (if (> (abs (sub (poly2 x) (poly4 x))) eps)
      (println x { } (poly2 x) { } (poly4 x))))
;-> nil



------------------------------
Quadrato perfetto di un numero
------------------------------

Determinare se un numero n è un quadrato perfetto.

Usiamo la funzione radice quadrata (sqrt):

(define (square? n)
  (let (v (+ (sqrt n 0.5)))
    (= n (* v v))))

(square? 400)
;-> true

(square? 1736364774)
;-> nil

(time (map square? (sequence 2 1000000)))
;-> 225.77

Facciamo un test per vedere se la funzione è corretta:

(for (i 2 1e7)
  (if (not (square? (* i i))) (println i { } (* i i))))
;-> nil

Un metodo alternativo:

(define (square1? n)
  (catch
    (let (i (max 1 (int (- (sqrt n) 1))))
      (while (<= (* i i) n)
        (if (and (= (% n i) 0) (= i (/ n i))) (throw true))
        (++ i)
      )
      (throw nil)
    )
  )
)

(square1? 400)
;-> true

(square1? 1736364774)
;-> nil

(time (map square1? (sequence 2 1000000)))
;-> 2253.451

Test:

(for (i 2 1e6)
  (if (not (square1? (* i i))) (println i { } (* i i))))
;-> nil

Un altro metodo è quello di fattorizzare il numero n e poi, se tutti gli esponenti dei fattori sono numeri pari, allora n è un quadrato perfetto.

Esempio:
n = 400
(factor 400)
;-> (2 2 2 2 5 5)

400 = 20*20 = 2^4 * 5^2

Poichè 4 e 2 (gli esponenti) sono numeri pari allora 400 è un quadrato perfetto.

Ecco la funzione:

(define (square2? n)
  (let (f (factor n))
    (catch
      (dolist (x (count (unique f) f))
        (if (odd? x) (throw nil))
        true
      )
    )
  )
)

(square2? 400)
;-> true

(square2? 1736364774)
;-> nil

(time (map square2? (sequence 2 1000000)))
;-> 3534.401

Test:

(for (i 2 1e5)
  (if (not (square2? (* i i))) (println i { } (* i i))))
;-> nil

Un altro algoritmo (molto lento).

Dato il numero n:
1) a = 5*n
2) b = 5
3) Affinchè (a >= b)
      a = a - b
      b = b + 10
4) Quando (a < b):
   se e solo se (a == 0) allora n è un quadrato perfetto

Ecco la funzione:

(define (square3? n)
  (let ((a (* 5 n)) (b 5))
    (while (>= a b)
      (setq a (- a b))
      (++ b 10)
    )
    (zero? a)
  )
)

(square3? 400)
;-> true

(square3? 1736364774)
;-> nil

(time (map square3? (sequence 2 1000000)))
;-> 80311.923

Test:

(for (i 2 1e4)
  (if (not (square3? (* i i))) (println i { } (* i i))))
;-> nil

Inoltre valgono le seguenti due regole:

1) Se un numero ha 2 o 3 o 7 o 8 nel posto dell'unità, allora non è un quadrato perfetto.

(define (digit-1 n)
  (if (zero? (/ n 10))
      n
      (digit-1 (/ n 10))
  )
)

(digit-1 (* 343 343))
;-> 1

2) Se la somma delle cifre di un numero non vale 1 o 4 o 7 o 9, allora non è un quadrato perfetto.

(define (digit-sum n) (+ 1 (% (- n 1) 9)))

(digit-sum (* 361 361))
;-> 1

Infine, ecco una soluzione abbastanza veloce che funzione anche per i numeri big integer:

(define (square4? n)
  (local (a)
    (setq a n)
    (while (> (* a a) n)
      (setq a (/ (+ a (/ n a)) 2L))
    )
    (= (* a a) n)
  )
)

(square4? 400L)
;-> true

(square4? 1736364774L)
;-> nil

(* 83968 83968)
;-> 7050625024

(square4? (* 83968L 83968L))
;-> true

Ma attenzione, occorre passare dei numeri big integer (L) per ottenere il risultato corretto:

(square4? (* 83968 83968))
;-> nil ;errore

(square4? (* 383747464646473736473647364736L 383747464646473736473647364736L))
;-> true

(time (map square4? (sequence 2L 1000000L)))
;-> 2578.611

Test:

(for (i 2 1e6)
  (if (not (square4? (* (bigint i) (bigint i))) (println i { } (* i i)))))
;-> nil


-----------------------------
Potenza perfetta di un numero
-----------------------------

Determinare se un numero intero è potenza perfetta di un altro numero intero.

Cominciamo col determinare se un numero n è potenza del numero 3.

(define (power-of-3? n)
  (if (zero? (% n 3))
        (power-of-3? (/ n 3))
        (= n 1)
  )
)

(power-of-3? 9)
;-> true
(power-of-3? 6)
;-> nil
(power-of-3? 81)
;-> true
(power-of-3? 847288609443)
;-> true

Vediamo la velocità della funzione:

(time (map power-of-3? (sequence 4 1e7)))
;-> 2676.189

Notiamo che la somma delle cifre di ogni numero che è potenza di 3 vale 9 (tranne 0 e 3).
Per calcolare la somma delle cifre di un numero usiamo la seguente funzione:

(define (digitSum n) (+ 1 (% (- n 1) 9)))

Verifichiamo la nostra ipotesi:

(for (i 4 1e6)
  (if (and (power-of-3? i) (!= 9 (digitSum i)))
    (println "Error: " i)
  )
)
;-> nil

Non è vero il contrario, cioè esistono tanti numeri che hanno come somma delle cifre il valore 9, ma non sono potenze del numero 3.

(for (i 4 1e2)
  (if (and (= 9 (digitSum i)) (not (power-of-3? i)))
    (println "Error: " i)
  )
)
;-> Error: 18
;-> Error: 36
;-> Error: 45
;-> Error: 54
;-> Error: 63
;-> Error: 72
;-> Error: 90
;-> Error: 99

Possiamo generalizzare la funzione per determinare se un numero m è potenza del numero n.

Versione funzionale (può generare un errore di stack-overflow):

(define (power-of? n m)
  (if (zero? (% m n))
        (power-of? n (/ m n))
        (= m 1)
  )
)

(power-of? 3 117)
;-> nil
(power-of? 4 4096)
;-> true
(power-of? 4 20)
;-> nil
(power-of? 7 2401)
;-> true
(power-of? 3 847288609443)
;-> true

Versione iterativa:

Con la divisione:

(define (power-of-div? x y)
  (cond ((or (zero? x) (zero? y)) nil)
        ((= x 1) (= y 1))
        ((= x -1) (or (= y 1) (= y -1)))
        (true
          (while (zero? (% y x))
            (setq y (/ y x))
          )
          (= y 1))))

Con la moltiplicazione:

(define (power-of-mul? x y)
  (let (num x)
    (while (< (abs num) (abs y))
      (setq num (* num x))
    )
    (= num y)))

(time (power-of-div? 3 847288609443) 100000)
;-> 217.472
(time (power-of-mul? 3 847288609443) 100000)
;-> 227.419.609

(power-of-div? 3 117)
;-> nil
(power-of-mul? 3 117)
;-> nil
(power-of-div? 4 4096)
;-> true
(power-of-mul? 4 4096)
;-> true
(power-of-div? 4 20)
;-> nil
(power-of-mul? 4 20)
;-> nil
(power-of-div? 7 2401)
;-> true
(power-of-mul? 7 2401)
;-> true
(power-of-div? 3 847288609443)
;-> true
(power-of-mul? 3 847288609443)
;-> true
(power-of-div? -2 -8)
;-> true
(power-of-mul? -2 -8)
;-> true
(power-of-div? -2 8)
;-> nil
(power-of-mul? -2 8)
;-> nil
(power-of-div? -2 -16)
;-> nil
(power-of-mul? -2 -16)
;-> nil
(power-of-div? -2 16)
;-> true
(power-of-mul? -2 16)
;-> true

(power-of-div?  1  1)
;-> true
(power-of-mul?  1  1)
;-> true
(power-of-div?  1 -1)
;-> nil
(power-of-mul?  1 -1)
;-> nil
(power-of-div? -1  1)
;-> true               CORRETTO
(power-of-mul? -1  1)
;-> nil ;              ERRORE: (pow -1 2) ;-> 1
(power-of-div? -1 -1)
;-> true
(power-of-mul? -1 -1)
;-> true

(pow -1 2)
(pow -1 2)


Un altro metodo è quello di utilizzare i logaritmi. L'idea è di calcolare il logaritmo di y in base x. Se risulta essere un numero intero, allora il numero y è una potenza perfetta, altrimenti non lo è.
Ricordiamo che matematicamente risulta:

logb(x) = logc(x) / logc(b)

E in newLISP la funzione "log" ha la seguente sintassi:

(log num num-base)

Quindi la funzione è la seguente:

(define (ispower? x y) (= (log y x) (int (log y x))))

oppure nel modo seguente:

(define (ispower? x y) (= (log y x) (ceil (log y x))))

(ispower? 2 16)
;-> true
(ispower? 3 81)
;-> true

Test di correttezza delle due funzioni:
(for (x 2 100)
  (for (y x 1000)
    (if (> y x)
        (if (!= (ispower? x y) (power-of? x y)) (println x { } y)))))
;-> 3 243
;-> 5 125
;-> 6 216
;-> 10 1000

Il test è fallito infatti risulta (per esempio):

(log 243 3)
;-> 4.999999999999999

(ceil (log 243 3))
;-> 5
(int (log 243 3))
;-> 4

Per finire, scriviamo una funzione che calcola se un numero intero n è potenza di un qualsiasi numero intero.
Un numero n viene detto una potenza perfetta quando n = m^k è un numero intero e m>1 e k>=2.
Consideriamo la fattorizzazione di un numero: n = p1^a1 * p2^a2 *...* pk^ak
Il numero n è una potenza perfetta se e solo se (MCD a1 a2 ... ak) > 1

La funzione "factor-exp-list" calcola la lista degli esponenti della fattorizzazione del numero x:

(define (factor-exp-list x)
  (if (= x 1) '(1)
    (letn (fattori (factor x)
           unici (unique fattori))
       (count unici fattori))))

1000 = 2^3 * 5^3
(factor-exp-list 1000)
;-> (3 3)

Adesso possiamo scrivere la funzione "checkpower" che calcola se un numero è una potenza perfetta:

(define (checkpower n)
  (local (a out)
    (if (> (setq a (apply gcd (factor-exp-list n))) 1)
        (list (ceil (pow n (div 1 a))) a)
        nil)))

(checkpower (pow 3 12))
;-> (3 12)

(checkpower (pow 4 25))
;-> (2 50)

(checkpower (+ (pow 3 7) 1))
;-> nil

(checkpower 4096)
;-> (2 12)


-------------------------
Problema della segretaria
-------------------------

Il problema della segretaria è un problema che dimostra uno scenario che coinvolge la teoria dell'arresto ottimale.
La forma base del problema è la seguente: immagina un amministratore che vuole assumere la miglior segretaria da n candidate. Le candidate vengono intervistate una per una in ordine casuale. Una decisione su ciascuna candidata particolare deve essere presa immediatamente dopo il colloquio. Una volta respinta, una candidata non può essere richiamata. Durante il colloquio, l'amministratore ottiene informazioni sufficienti per classificare con un punteggio la candidata. La domanda riguarda la strategia ottimale (regola di arresto) per massimizzare la probabilità di selezionare la miglior candidata. Se la decisione può essere rinviata alla fine, allora la scelta viene fatta al termine di tutti i colloqui, selezionando la candidata con il punteggio maggiore. La difficoltà è che la decisione deve essere presa immediatamente: la candidata deve essere presa o scartata.

La probabilità di vincita ottimale è sempre almeno 1/e (dove e è la base del logaritmo naturale). La regola di arresto ottimale prescrive sempre di rifiutare le prime n/e candidate che vengono intervistate e quindi fermarsi alla prima candidata che è migliore di tutti le candidate intervistate finora (o si continua fino all'ultima candidata se ciò non si verifica mai). A volte questa strategia è chiamata regola di arresto 1/e , perché la probabilità di fermarsi alla migliore candidata con questa strategia è circa 1/e già per valori piccoli n. Il metodo per la soluzione del problema (la regola di arresto) è semplice e seleziona la migliore candidata circa il 37% delle volte, indipendentemente dal fatto che ci siano 100 o 100 milioni di candidate.

Sebbene ci siano molte varianti, il problema di base può essere definito come segue:

1) C'è una singola posizione da riempire.
2) Ci sono n candidate per la posizione e il valore di n è noto.
3) Le candidate, se viste complessivamente, possono essere classificate dalla migliore alla peggiore in modo inequivocabile.
4) I punteggi relativi alle valutazioni devono essere tutti diversi.
5) Le candidate vengono intervistate in sequenza in ordine casuale.
6) Immediatamente dopo un colloquio, la candidata intervistata viene accettata o respinta e la decisione è irrevocabile.
7) La decisione di accettare o respingere una candidata si basa solo sui punteggi delle candidate intervistate finora.

L'obiettivo della soluzione generale è trovare un metodo che renda massima probabilità di selezionare il miglior candidato dell'intero gruppo.

La politica ottimale per il problema è una regola di arresto. Con questa, l'intervistatore rifiuta le prime (r - 1) (considerando che la candidata M abbia il miglior punteggio tra queste (r - 1) candidate), quindi seleziona, tra le candidate successive, la prima candidata che ha un punteggio migliore della candidata M. Si può dimostrare che la strategia ottimale sta in questa classe di strategie. Con un taglio arbitrario r, la probabilità che sia selezionato il miglior richiedente vale:

P(r) = (r - 1)/n * sum[i=1...i=n] 1/(i-1)

Definiamo una funzione per calcolare questo valore:

(define (P r n)
  (local (somma out)
    (setq out 0)
    (if (= r 1) (setq out (div 1 n))
        (begin
          (setq somma 0)
          (for (i r n)
            (setq somma (add somma (div 1 (sub i 1))))
          )
          (setq out (mul somma (div (sub r 1) n)))
        )
    )
  out
  )
)

(P 1 1)
;-> 1

(P 1 2)
;-> 0.5

(P 2 3)
;-> 0.5

(P 3 5)
;-> 0.4333333

(P 37 100)
;-> 0.371014595504193

La teoria afferma che il taglio ottimo vale n/e

(div 1 (exp 1))
;-> 0.3678794411714423

Proviamo con un esempio per capire come funziona.

Abbiamo 100 candidati con punteggi variabili da 1 a 100:

(setq cand (randomize (sequence 0 99)))
;-> (76 64 72 83 55 63 29 95 89 74 61 71 60 49 3 8 2 58
;->  53 98 24 15 38 69 43 94 39 8 21 5 19 41 80 59 20 44
;->  28 82 73 7 75 36 77 14 79 25 67 11 85 9 47 32 16 88
;->  12 90 17 0 91 46 26 93 99 35 18 37 13 42 22 50 66 52
;->  96 97 48 62 51 4 70 45 87 6 92 4 27 65 54 23 34 86 31
;->  1 33 30 78 57 40 56 10 81)

La teoria afferma che il taglio ottimo vale n/e:

(div 1 (exp 1))
;-> 0.3678794411714423

(setq taglio (round (div 100 (exp 1))))
;-> 37

Calcoliamo il punteggio massimo dal primo fino al taglio:
(apply max (slice cand 0 taglio))
;-> 98

Quindi nelle rimanenti candidate (dal taglio alla fine della lista) troviamo la candidata con punteggio 99, che è la miglioer ed è quella che verrà selezionata.

Adesso scriviamo una funzione che calcola la percentuale di successo (cioè quante volte selezioniamo la migliore candidata) con due parametri, il numero delle candidate n e il numero dei colloqui (cioè quante volte ripetiamo il test).

(define (secretary n prove)
  (local (cand taglio m1 m2 success found)
    (setq success 0)
    ;Definiamo il taglio
    ; 1/e = (div 1 (exp 1))) = 0.3678794411714423
    (setq taglio (round (div n (exp 1))))
    (for (i 1 prove)
      ; Generiamo la lista dei punteggi per le candidate
      (setq cand (randomize (sequence 0 (- n 1))))
      ;Calcoliamo il valore massimo FINO al taglio
      (setq m1 (apply max (slice cand 0 taglio)))
      ;Cerchiamo il primo valore > m1 dal resto della lista
      ;se non esiste tale valore, allora m2 vale l'ultimo candidato
      (setq m2 (last cand))
      (setq found nil)
      (dolist (el (slice cand taglio) found)
        (if (> el m1) (setq m2 el found true))
      )
      ;se m2 > max allora abbiamo scelto la candidata migliore
      ;(if (>= m2 (apply max cand) (++ success)))
      ;se m2 = (n - 1) allora abbiamo scelto la candidata migliore
      ;(if (= m2 (- n 1)) (++ success))
      (if (= m2 (- n 1)) (++ success))
    )
    (div success prove)
  )
)

(secretary 100 100)
;-> 0.35

(secretary 100 1000)
;-> 0.365

(secretary 100 10000)
;-> 0.3668

(secretary 100 100000)
;-> 0.36995

(time (println (secretary 1000 100000)))
;-> 0.36794
;-> 14018
;-> 14018

Quindi con il taglio ottimo selezioniamo la segretaria migliore il 37% delle volte.

Adesso vogliamo verificare se il taglio ottimo n/e è veramente ottimo. Per fare questo scriviamo una funzione simile alla precedente, ma che utilizza il taglio dal 2% dei candidati al 98% dei candidati con passo dell'1%. Prima abbiamo bisogno di aggiungere il parametro percentuale (perc) alla funzione "secretary".

(define (secretary1 n prove perc)
  (local (cand taglio m1 m2 success found)
    ; numero di successi
    (setq success 0)
    ;Definiamo il taglio
    ; 1/e = (div 1 (exp 1))) = 0.3678794411714423
    ;(setq taglio (round (mul n (div 1 (exp 1)))))
    (setq taglio (round (mul n perc)))
    (for (i 1 prove)
      ; Generiamo la lista dei punteggi per le candidate
      ; I punteggi devono essere tutti diversi
      (setq cand (randomize (sequence 0 (- n 1))))
      ;
      ;Definiamo il taglio
      ; 1/e = (div 1 (exp 1))) = 0.3678794411714423
      ;(setq taglio (round (mul n (div 1 (exp 1)))))
      ;
      ;Calcoliamo il valore massimo FINO al taglio
      (setq m1 (apply max (slice cand 0 taglio)))
      ;Cerchiamo il primo valore > m1 dal resto della lista
      ;se non esiste tale valore, allora m2 vale l'ultimo candidato
      (setq m2 (last cand))
      (setq found nil)
      (dolist (el (slice cand taglio) found)
        (if (> el m1) (setq m2 el found true))
      )
      ;se m2 > max allora abbiamo scelto la candidata migliore
      ;(if (>= m2 (apply max cand) (++ success)))
      ;se m2 = (n - 1) allora abbiamo scelto la candidata migliore
      (if (= m2 (- n 1)) (++ success))
    )
    (div success prove)
  )
)

Proviamo la funzione con il taglio ottimo:

(secretary1 100 10000 0.37)
;-> 0.3688

Adesso scriviamo la funzione di test:

(define (test numero try)
  (let (out '())
    (for (i 0.02 0.98 0.01)
      (push (list i (secretary1 numero try i)) out -1)
    )
    out
  )
)

(time (println (test 1000 100000)))
;-> ((0.02 0.07912) (0.03 0.10446) (0.04 0.12815) (0.05 0.14926) (0.06 0.16773)
;->  (0.07 0.18446) (0.08 0.19901) (0.09 0.21840) (0.10 0.23036) (0.11 0.24187)
;->  (0.12 0.25638) (0.13 0.26558) (0.14 0.27721) (0.15 0.28404) (0.16 0.29332)
;->  (0.17 0.30204) (0.18 0.30775) (0.19 0.31570) (0.20 0.32219) (0.21 0.32700)
;->  (0.22 0.33187) (0.23 0.33872) (0.24 0.34584) (0.25 0.34686) (0.26 0.35190)
;->  (0.27 0.35387) (0.28 0.35426) (0.29 0.35849) (0.30 0.36257) (0.31 0.36373)
;->  (0.32 0.36782) (0.33 0.36693) (0.34 0.36981) (0.35 0.36654) (0.36 0.36841)
;->  (0.37 0.36798) (0.38 0.37075) (0.39 0.36919) (0.40 0.37071) (0.41 0.36927)
;->  (0.42 0.36649) (0.43 0.36714) (0.44 0.36583) (0.45 0.36196) (0.46 0.35700)
;->  (0.47 0.35620) (0.48 0.35523) (0.49 0.35266) (0.50 0.34981) (0.51 0.34740)
;->  (0.52 0.34153) (0.53 0.33946) (0.54 0.33874) (0.55 0.32996) (0.56 0.32723)
;->  (0.57 0.32194) (0.58 0.31821) (0.59 0.31414) (0.60 0.31107) (0.61 0.30513)
;->  (0.62 0.29896) (0.63 0.29224) (0.64 0.28734) (0.65 0.28199) (0.66 0.28114)
;->  (0.67 0.26891) (0.68 0.26747) (0.69 0.25871) (0.70 0.25116) (0.71 0.24809)
;->  (0.72 0.23956) (0.73 0.23304) (0.74 0.22672) (0.75 0.21875) (0.76 0.21029)
;->  (0.77 0.20602) (0.78 0.19533) (0.79 0.18661) (0.80 0.18105) (0.81 0.17393)
;->  (0.82 0.16428) (0.83 0.15788) (0.84 0.14896) (0.85 0.13921) (0.86 0.13023)
;->  (0.87 0.12356) (0.88 0.11341) (0.89 0.10416) (0.90 0.09511) (0.91 0.08739)
;->  (0.92 0.07860) (0.93 0.06842) (0.94 0.05824) (0.95 0.04976) (0.96 0.03982)
;->  (0.97 0.03023) (0.98 0.01985))
;-> 964754.466

Come possiamo vedere, i risultati calcolati confermano la teoria, cioè il taglio ottimo è circa il 37%.

Per definire meglio la validità del metodo sarebbe interessante vedere quanto siamo lontani dal punteggio massimo, quando non selezioniamo la segretaria migliore utilizzando il taglio ottimo. Per fare questo modifichiamo la funzione "secretary":

(define (secretary2 n prove)
  (local (cand taglio m1 m2 success found delta)
    (setq success 0)
    (setq delta 0)
    ;Definiamo il taglio
    ; 1/e = (div 1 (exp 1))) = 0.3678794411714423
    (setq taglio (round (div n (exp 1))))
    (for (i 1 prove)
      ; Generiamo la lista dei punteggi per le candidate
      (setq cand (randomize (sequence 0 (- n 1))))
      ;Calcoliamo il valore massimo FINO al taglio
      (setq m1 (apply max (slice cand 0 taglio)))
      ;Cerchiamo il primo valore > m1 dal resto della lista
      ;se non esiste tale valore, allora m2 vale l'ultimo candidato
      (setq m2 (last cand))
      (setq found nil)
      (dolist (el (slice cand taglio) found)
        (if (> el m1) (setq m2 el found true))
      )
      ;se m2 > max allora abbiamo scelto la candidata migliore
      ;(if (>= m2 (apply max cand) (++ success)))
      ;se m2 = (n - 1) allora abbiamo scelto la candidata migliore
      ;(if (= m2 (- n 1)) (++ success))
      (if (= m2 (- n 1)) (++ success))
      ;somma le distanze tra la candidata scelta e quella migliore
      (setq delta (+ delta (- (- n 1) m2)))
    )
    (println (div success prove))
    (println delta)
    (div delta prove)
  )
)

(secretary2 100 100000)
;-> 0.37281  ; percentuale di successo
;-> 1888047  ; totale distanze
;-> 18.88047 ; distanza media

(secretary2 1000 100000)
;-> 0.37051   ; percentuale di successo
;-> 18267139  ; totale distanze
;-> 182.67139 ; distanza media

Con questo metodo si seleziona una candidata che ha circa il 18% di punteggio inferiore alla candidata migliore (in media).


-----------------------
Numeri con tre divisori
-----------------------

Trovare tutti i numeri fino al milione che hanno tre divisori.
Ad esempio, il numero 10 ha quattro divisori: 1, 2, 5 e 10.

Scriviamo una funzione per calcolare i divisori di un numero N.

(define (divisori n)
  (local (lista-div m i)
    (setq lista-div '(1)) ; aggiungo il numero 1
    (setq m (int (sqrt n)))
    (setq i 2)
    (while (<= i m)
        (if (zero? (% n i))   ; se 'i' è divisore di 'n'
            (if (= i (/ n i)) ; se entrambi i divisori sono gli stessi aggiungine uno,
                              ; altrimenti aggiungili entrambi
              (push i lista-div -1)
              (begin (push i lista-div -1) (push (/ n i) lista-div -1))
            )
        )
        (++ i)
    )
    (push n lista-div -1) ; aggiungo il numero stesso
    (sort lista-div)
  )
)

(divisori 1000)
;-> (1 2 4 5 8 10 20 25 40 50 100 125 200 250 500 1000)

Facciamo una prova per vedere quanto tempo occorre per trovare la soluzione:

(define (prova n)
  (for (i 2 n)
    (if (= (length (divisori i)) 3) (println i { } (divisori i))))
)

(prova 1e6)
;-> 4 (1 2 4)
;-> 9 (1 3 9)
;-> 25 (1 5 25)
;-> 49 (1 7 49)
;-> 121 (1 11 121)
;-> 169 (1 13 169)
;-> 289 (1 17 289)
...
;-> 954529 (1 977 954529)
;-> 966289 (1 983 966289)
;-> 982081 (1 991 982081)
;-> 994009 (1 997 994009)

Vediamo quanti sono i numeri da ricercare:

(define (prova1 n)
  (let (out 0)
    (for (i 2 n)
      (if (= (length (divisori i)) 3) (++ out)))
  out
  )
)

(prova1 1e6)
;-> 168

(time (prova1 1e6))
;-> 94695.56 ; circa 95 secondi

La funzione è molto lenta, quindi cerchiamo di ottimizzarla. Inannzitutto la funzione "divisori" calcola una lista di divisori, ma a noi in interessa sapere soltanto se un numero ha esattamente 3 divisori.
Riscriviamo la funzione per i divisori:

(define (numdiv3 n)
  (local (num m i)
    (setq num 1) ; il numero 1
    (setq m (int (sqrt n)))
    (setq i 2)
    (while (<= i m)
        (if (zero? (% n i))   ; se 'i' è divisore di 'n'...
            (if (= i (/ n i)) ; se entrambi i divisori sono gli stessi ...
              (++ num)   ; allora aggiungine uno,
              (++ num 2) ; altrimenti aggiungili entrambi
            )
        )
        (if (> num 2) (setq i m)) ;numero da scartare
        (++ i)
    )
    (++ num 1) ; il numero stesso
  )
)

Proviamo questa nuova funzione:

(define (prova2 n)
  (let (out 0)
    (for (i 2 n)
      (if (= (numdiv3 i) 3) (++ out)))
  out
  )
)

(prova2 1e6)
;-> 168

(time (prova2 1e6))
;-> 12788.932 ; circa 13 secondi

Abbiamo ottenuto un buon miglioramento della velocità, ma possiamo fare meglio.

I divisori vengono in coppie, quindi per la maggior parte dei numeri il conteggio dei divisori è un numero pari. Per esempio, i divisori di 24 sono 1 e 24, 2 e 12, 3 e 8, e 4 e 6, quindi 24 ha 8 divisori.
L'unica volta in cui un numero può avere un numero dispari di divisori è quando il numero è un quadrato perfetto. Ad esempio, i divisori di 36 sono 1 e 36, 2 e 18, 3 e 12, 4 e 9 e 6 e 6, gli ultimi due sono duplicati, quindi 36 ha 9 divisori.
E l'unica volta in cui un numero può avere 3 divisori è quando il numero è un quadrato di un numero primo. Ad esempio, i divisori di 25 sono 1, 5 e 25.

Quindi possiamo modificare il ciclo for e controllare solo i numeri quadrati. In questo modo il valore di n passato alla funzione vale 1000, poichè 1000x1000 = 1000000 (un milione). Inoltre controlliamo solo i quadrati dei numeri dispari (perchè non esistono numeri primi pari oltre al numero 2).

(define (prova3 n)
  (let (out 1) ; il numero 4
    (for (i 3 n 2)
      (if (= (numdiv3 (* i i)) 3) (++ out)))
  out
  )
)

(prova3 1000)
;-> 168

(time (prova3 1000))
;-> 32.965

Questo è un miglioramento enorme. Provamo a modificare la funzione per testare anche se il numero è primo:

(define (prova4 n)
  (let (out 1) ; il numero 4
    (for (i 3 n 2)
      (if (= (length (factor i)) 1) ; se il numero è primo...
        (if (= (numdiv3 (* i i)) 3) (++ out)))
    )
  out
  )
)

(prova4 1000)
;-> 168

(time (prova4 1000))
;-> 30.968

I tempi di "prova3" e "prova4" sono quasi uguali (poichè il calcolo del numero primo pur eliminando molti numeri, ma richiede tempo).

Scriviamo la funzione finale che ritorna una lista con tutti i numeri che hanno 3 divisori:

(define (divisori3 n)
  (let (out '(4)); il numero 4
    (for (i 3 n 2)
      (if (= (length (factor i)) 1) ; se il numero è primo...
        (if (= (numdiv3 (* i i)) 3) (push (* i i) out -1)))
    )
  out
  )
)

(divisori3 1000)
;-> (4 9 25 49 121 169 289 361 529 841 961 1369 1681 1849 2209 2809
;->  3481 3721 4489 5041 5329 6241 6889 7921 9409 10201 10609 11449
;->  11881 12769 16129 17161 18769 19321 22201 22801 24649 26569
;->  27889 29929 32041 32761 36481 37249 38809 39601 44521 49729
;->  51529 52441 54289 57121 58081 63001 66049 69169 72361 73441
;->  76729 78961 80089 85849 94249 96721 97969 100489 109561 113569
;->  120409 121801 124609 128881 134689 139129 143641 146689 151321
;->  157609 160801 167281 175561 177241 185761 187489 192721 196249
;->  201601 208849 212521 214369 218089 229441 237169 241081 249001
;->  253009 259081 271441 273529 292681 299209 310249 316969 323761
;->  326041 332929 344569 351649 358801 361201 368449 375769 380689
;->  383161 398161 410881 413449 418609 426409 434281 436921 452929
;->  458329 466489 477481 491401 502681 516961 528529 537289 546121
;->  552049 564001 573049 579121 591361 597529 619369 635209 654481
;->  657721 674041 677329 683929 687241 703921 727609 734449 737881
;->  744769 769129 776161 779689 786769 822649 829921 844561 863041
;->  877969 885481 896809 908209 935089 942841 954529 966289 982081
;->  994009)

(length (divisori3 1000))
;-> 168

(time (divisori3 1000))
;-> 33.964


----------------------
Congettura di Goldbach
----------------------

Nel 1742, il matematico prussiano Christian Goldbach scrisse una lettera a Leonhard Euler in cui proponeva la seguente congettura:

  "Ogni numero intero maggiore di 2 può essere scritto come la somma di tre numeri primi."

Considerava 1 un numero primo, una convenzione successivamente abbandonata. Quindi oggi, la congettura originale di Goldbach sarebbe stata scritta:

  "Ogni numero intero maggiore di 5 può essere scritto come la somma di tre numeri primi."

Euler, diventando interessato al problema, rispose con una versione equivalente della congettura:

  "Ogni numero pari maggiore di 2 può essere scritto come la somma di due numeri primi,"

aggiungendo che lo considerava un teorema del tutto certo ("ein ganz gewisses Theorema"), nonostante non fosse in grado di dimostrarlo.

La prima congettura è oggi nota come congettura di Goldbach "ternaria" o "debole", la seconda come congettura di Goldbach  "binaria" o "forte". La congettura che tutti gli interi dispari maggiori di 9 siano la somma di tre numeri primi dispari è chiamata congettura di Goldbach "debole". Entrambe le domande sono rimaste irrisolte da allora, sebbene la forma debole della congettura sia molto più vicina alla risoluzione di quella forte.

La maggior parte dei matematici ha sempre ritenuto che la congettura (sia nella forma debole che in quella forte) sia vera, almeno per numeri interi sufficientemente grandi, principalmente basata su considerazioni statistiche incentrate sulla distribuzione probabilistica dei numeri primi: più grande è il numero, più modi ci sono disponibili affinché quel numero sia rappresentato come la somma di altri due o tre numeri e più "probabile" diventa che almeno una di queste rappresentazioni è costituita interamente da numeri primi.

Nel 2012 e 2013 Harald Helfgott ha pubblicato su internet due articoli che dimostrerebbero la congettura debole incondizionatamente per ogni intero maggiore di 7.

La congettura forte non è ancora stata dimostrata.

Vediamo come calcolare la coppia di numeri che soddisfano la congettura di Goldbach per ogni numero pari maggiore di due.

Utilizziamo il Crivello (sieve) di Eratostene per calcolare i numeri primi fino a n. Questa funzione restituisce un vettore di valori booleani dove l'indice i-esimo è primo se vettore(i) vale true.

(define (sieve n)
  (local (primi p)
    (setq primi (array (add 1 n) '(true)))
    (setf (primi 0) nil) ; 0 non è primo
    (setf (primi 1) nil) ; 1 non è primo
    (setq p 2)
    (while (<= (* p p) n)
      (if (= (primi p) true))
      (for (i (* p p) n p) (setq (primi i) nil))
      (++ p)
    )
    ; se vogliamo la lista dei numeri
    ;(slice (filter true? (map (fn (x) (if x $idx)) primi)) 2)
    ; se vogliamo la lista dei valori booleani (indicizzata)
    primi
  )
)

Adesso scriviamo la funzione che cerca la coppia di numeri primi che sommati valgono n:

(define (coppia n)
  (local (primi stop out)
    (setq primi (sieve n))
    (setq stop nil)
    ; attraversiamo la lista per trovare la prima coppia
    ; di numeri primi che sommati valgono n
    (dolist (el primi stop)
       (if (and el (primi (- n $idx)))
           (begin
            (setq stop true)
            (setq out (list $idx (- n $idx)))
           )
       )
    )
    out
  )
)

(coppia 4)
;-> (2 2)

Verifichiamo la congettura per valori fino a n:

(define (testGoldbach n)
  (local (primi out)
    (setq out '())
    (setq primi (sieve n))
    (for (i 4 n 2)
      (setq stop nil)
      (dolist (el primi stop)
        (if (and el (primi (- i $idx)))
            (begin
              (setq stop true)
              ; se vogliamo stampare le coppie
              ;(println (list $idx (- i $idx)))
              ; se vogliamo memorizzare le coppie in una lista
              ;(push (list $idx (- i $idx)) out -1)
            )
        )
      )
      (if (null? stop) (println "errore con numero: " i))
    )
    ;out
    'fine
  )
)

(testGoldbach 10000)
;-> fine ; nessun errore

(time (testGoldbach 100000))
;-> 38084.502

Infine scriviamo la funzione che genera tutte le coppie di numeri primi che sommate valgono n:

(define (coppie n)
  (local (primi out)
    (setq out '())
    (setq primi (sieve n))
    ; attraversiamo la lista per trovare la prima coppia
    ; di numeri primi che sommati valgono n
    (dolist (el primi)
       (if (and el (primi (- n $idx)))
           (push (list $idx (- n $idx)) out -1)
       )
    )
    out
  )
)

(coppie 20)
;-> ((3 17) (7 13) (13 7) (17 3))


-------------------------------------------
Problema dei travasi ed equazioni diofantee
-------------------------------------------

Avendo a disposizione una fontana e due recipienti, rispettivamente da 9 e da 15 litri, come si può a raccogliere precisamente 12 litri d’acqua?

In generale, dati due contenitori non graduati e una quantità infinita di liquido, è possibile avere, con una serie di riempimenti, svuotamenti e travasi, una fissata quantità in un solo recipiente?

Indichiamo con A e B i due contenitori e con a e b le loro capacità e c la quantità di liquido da ottenere. Dove a, b, c sono numeri naturali e (0 < c < max(a,b)).

Indichiamo con la coppia (x,y) un particolare stato del problema, caratterizzato dalla quantità di liquido x contenuto nel contenitore A e dalla quantità di liquido y contenuta in B. Dove x, y sono numeri naturali e (0 <= x <= a), (0 <= y <= b).

Lo stato iniziale è quindi rappresentato dalla coppia (0,0) e quello da raggiungere è (c,y) per qualche y, oppure (x,c) per qualche x.

Le azioni che permettono di passare da uno stato ad un altro sono descritte nel seguente schema:

Riempimenti
-----------
Azione         Risultato                            Vincoli
RiempiA        A viene completamente riempito.      A non deve essere pieno.
RiempiB        B viene completamente riempito.      B non deve essere pieno.

Travasi
-------
TravasoAB      A viene svuotato in B, fino a che    A non deve essere vuoto e
               A è vuoto oppure B è pieno.          B non deve essere pieno.
TravasoBA      B viene svuotato in A, fino a che    B non deve essere vuoto e
               B è vuoto oppure A è pieno.          A non deve essere pieno.

Svuotamenti
-----------
SvuotaA        A viene completamente svuotato.      A non deve essere vuoto.
SvuotaB        B viene completamente svuotato.      B non deve essere vuoto.

Adesso vediamo gli effetti delle azioni su un generico stato iniziale (x,y):

Iniziale      Azione      Finale
 (x,y)        RiempiA      (a,y)
 (x,y)        RiempiB      (x,b)
 (x,y)        TravasoAB    (0,x+y) oppure (x+y-b,b)
 (x,y)        TravasoBA    (x+y,0) oppure (a,x+y-a)
 (x,y)        SvuotaA      (0,y)
 (x,y)        SvuotaB      (x,0)

Nota: se si parte dallo stato (0,0) non si ottengono mai stati in cui 0 < x < a e 0 < y < b.

Ogni problema dei travasi con contenitori di capienza a e b e quantità da realizzare c può essere formalizzato nel modo seguente:

Dati tre numeri naturali a, b, c Îe 0 < c < max(a,b), trovare una sequenza di azioni che permetta di passare dallo stato iniziale (0,0) a quello (c,y) per qualche y, oppure a quello (x, c) per qualche x.

Per risolvere il problema ci servono alcune nozioni di teoria di numeri.

Teorema della divisione e del resto
-----------------------------------
Dati due numeri interi a e b esistono solo due numeri interi q e r che soddisfano la seguente relazione:

  a = q*b + r  con 0 <= r < b

q prende il nome di “quoziente” della divisione di a per b
r prende il nome di “resto” della divisione di a per b

Ddefinizione: equazioni diofantee di primo grado
------------------------------------------------
Si dice equazione diofantea (di 1° grado) ogni equazione della forma:

ax + by = c

dove a, b, c numeri interi relativi e a e b non entrambi nulli

Si dice soluzione dell’equazione diofantea ogni coppia (x0,y0) con x0 e y0 numeri interi relativi tale che:

a*x + b*y = c

Teorema fondamentale delle equazioni diofantee di primo grado
-------------------------------------------------------------
Un'equazione diofantea di primo grado

  ax + by = c

con a, b, c numeri interi relativi e a e b non entrambi nulli ha soluzioni se e solo se c è un multiplo del Massimo Comun Denominatore di (a,b).

In tal caso se (x0,y0) è una soluzione dell’equazione, tutte le soluzioni (x(n),y(n)) si trovano con le formule:

                    b                              a
    x(n) = x0 + ----------*n       y(n) = y0 - ----------*n
                 MCD(a,b)                       MCD(a,b)

al variare di n.

Nota: se a e/o b sono negativi si considera il MCD dei loro valori assoluti.

Esempio: 8x - 6y = 26
a = 8
b = -6
c = 26
MCD(8, 6) = 2

Quindi c è multiplo di MCD(a,b): (26 mod 2) = 0
Una soluzione vale (1,-3), quindi tutte le soluzioni si ottengono dalle formule:

                b                  -6
x(n) = x0 + ----------*n = 1 + ----------*n = 1 - 3*n
             MCD(a,b)           MCD(8,6)

                a                   8
y(n) = y0 + ----------*n = -3 + ----------*n = -3 - 4*n
             MCD(a,b)            MCD(8,6)

Quindi risulta:
...
n = -2 --> (7,5)
n = -1 --> (4,1)
n = 0  --> (1,-3)
n = 1  --> (-2,-7)
n = 2  --> (-5,-11)
...

Vedremo in seguito come viene calcolata la prima soluzione (x0,y0). Adesso dobbiamo vedeere quali sono le possibili strategie per risolvere il problema.

Strategia Destra
----------------
Si definisce "strategia destra" ogni sequenza di azioni che segue le seguenti regole:
1) Se A è vuoto lo si riempie con RiempiA.
2) Se A non è vuoto lo si svuota con un numero finito di travasi TravisaAB e
svuotamenti SvuotaB di B fino ad uno stato (0,y) con y<b.

Strategia Sinistra
------------------
Si definisce "strategia sinistra" ogni sequenza di azioni che segue le seguenti regole:
1) Se B è vuoto lo si riempie con RiempiB
2) Se B non è vuoto lo si svuota con un numero finito di travasi TravasiBA e
svuotamenti SvuotaA di A fino ad uno stato (x,0) con x<a.

Nota: si osservi che applicando la strategia destra (sinistra) a partire dallo stato (0,0) si effettua un primo riempimento di A (di B) (regola 1), poi si raggiunge lo stato (0,y) con y<b (lo stato (x,0) con x<a) (regola 2), da qui si può ricominciare e andare avanti quanto si vuole alternando le regole 1 e 2.
Si noti inoltre che nella strategia destra (sinistra) per ogni stato ottenuto del tipo (0,y) (del tipo (x,0)) si ha y = n*a - m*b (x = n*b - m*a) dove n è il numero di riempimenti di A (di B) e m il numero di svuotamenti di B (di A).

Adesso siamo in grado di definire in quali casi il problema dei travasi ha una soluzione.

Teorema
Dati tre numeri naturali a, b, c con 0 < c < max(a,b) CNES affinché il problema dei travasi con contenitori di capienza a, b e quantità da realizzare c sia risolubile, è che c sia un multiplo di MCD(a,b).

Applichiamo ora il teorema appena dimostrato al problema dei travasi proposto all'inizio.
Avendo a disposizione una fontana e due recipienti, rispettivamente da 9 e da 15 litri, come si può a raccogliere precisamente 12 litri d’acqua?
In virtù del teorema il problema è risolubile perché 12 è un multiplo di MCD(9,15)=3.
Mostreremo ora come la strategia destra permette di raggiungere lo stato (0,6) e la
strategia sinistra lo stato (6,0).

Strategia destra
Inizio  Azione     Fine
(0,0)   RiempiA    (9,0)
(9,0)   TravasoAB  (0,9)
(0,9)   RiempiA    (9,9)
(9,9)   TravasoAB  (3,15)
(3,15)  SvuotaB    (3,0)
(3,0)   TravasoAB  (0,3)
(0,3)   RiempiA    (9,3)
(9,3)   TravasoAB  (0,12)

Strategia sinistra
Inizio  Azione     Fine
(0,0)   RiempiB    (0,15)
(0,15)  TravasoBA  (9,6)
(9,6)   SvuotaA    (0,6)
(0,6)   RiempiB    (6,15)
(6,15)  TravasoBA  (9,12)
(9,12)  SvuotaA    (0,12)
(0,12)  TravasoBA  (12,0)

Osserviamo che nella strategia sinistra le ultime due azioni sono inutili ai fini della
risoluzione del problema, ed eliminandole, la strategia sinistra si dimostra in questo caso "migliore": 6 azioni per quella sinistra contro le 8 di quella destra.

Per finire vediamo un algoritmo per trovare la soluzione (x0,y0), se esiste, di una equazione diofantea lineare a due incognite.

Possiamo usare l'algoritmo euclideo esteso. Innanzitutto, supponiamo che a e b siano non negativi. Quando applichiamo l'algoritmo euclideo esteso per a e b, possiamo trovare il loro massimo comune divisore g e due numeri xg e yg tali che:

a*xg + b*yg = g

Se c è divisibile per g = gcd(a, b), allora l'equazione diofantea data ha una soluzione, altrimenti non ha alcuna soluzione. La dimostrazione è semplice: una combinazione lineare di due numeri è sempre divisibile per il loro comune divisore.

Ora supponiamo che c sia divisibile per g, quindi abbiamo:

a*xg*c/g + b*yg*c/g = c

Pertanto una delle soluzioni dell'equazione diofantea è:

x0 = xg*c/g
y0 = yg*c/g

Questo metodo funziona anche quando a e/o b sono negativi.

(define (gcdex a b)
  (local (x y lastx lasty temp)
    (setq x 0)
    (setq y 1)
    (setq lastx 1)
    (setq lasty 0)
    (while (not (zero? b))
      (setq q (div a b))
      (setq r (% a b))
      (setq a b)
      (setq b r)
      (setq temp x)
      (setq x (- lastx (* q x)))
      (setq lastx temp)
      (setq temp y)
      (setq y (- lasty (* q y)))
      (setq lasty temp)
    )
    ; Adesso la variabile a contine il valore di gcd
    ;(println a { } b { } x { } y { } lastx { } lasty)
    (list a lastx lasty)))

(gcdex 120 23)
;-> 1 0 23 -120 -9 47
;-> (-9 47)

(gcdex 8 -6)
;-> 2 0 3 4 1 1
;-> (1 1)

(define (diofanto a b c)
  (local (gcdex-lst g xg yg out)
    (setq out '())
    (setq gcdex-lst (gcdex a b))
    (setq g (first gcdex-lst))
    (setq xg (first (rest gcdex-lst)))
    (setq yg (last gcdex-lst))
    (println g { } xg { } yg)
    (cond ((not (zero? (% c g))) (setq out '()))
          (true
            (setq out (list (div (mul xg c) g) (div (mul yg c) g)))))
    out))

(diofanto 8 -6 26)
;-> 2 1 1
;-> (13 13)

Infatti risulta:

(+ (* 13 8) (* 13 -6))
;-> 26


---------------
Primi circolari
---------------

Un numero primo è circolare se i numeri che otteniamo da tutte le sue rotazioni sono primi. Per esempio il numero 3779 è un nuero primo circolare perchè risulta:

numero base: 3779 -> numero primo
rotazione 1: 7793 -> numero primo
rotazione 2: 7937 -> numero primo
rotazione 3: 9377 -> numero primo

Trovare tutti i numeri primi circolari sotto al milione.

(define (primo? n)
   (if (< n 2) nil
       (= 1 (length (factor n)))))

(define (prime-rot n)
  (local (num cand valid)
    (for (i 2 n)
      ; se i è primo
      (if (primo? i)
        (begin
           ; controlliamo se sono primi i numeri ruotati
           (setq cand i)
           (setq valid true)
           (for (i 1 (- (length cand) 1) 1 (not valid))
             (setq cand (int (rotate (string cand))))
             (if (not (primo? cand)) (setq valid nil))
           )
           ; se il numero è valido, allora lo stampiamo
           (if valid (print i { }))
        ))
    )
    'end
  )
)

(prime-rot 1000000)
;-> 2 3 5 7 11 13 17 31 37 71 73 79 97 113 131 197 199 311 337
;-> 373 719 733 919 971 991 1193 1931 3119 3779 7793 7937 9311
;-> 9377 11939 19391 19937 37199 39119 71993 91193 93719 93911
;-> 99371 193939 199933 319993 331999 391939 393919 919393
;-> 933199 939193 939391 993319 999331 end

(time (prime-rot 1000000))
;-> ;-> 1368.633


---------------------------------
Radici di un polinomio (Bairstow)
---------------------------------

Questo programma utilizza il metodo di Bairstow per trovare le radici reali e complesse di un poliomiale con coefficienti reali. Il metodo fornisce un processo iterativo per trovare le radici reali e complesse usando solo l'aritmetica reale.

Inoltre, poiché si basa sul metodo di Newton per un sistema di due equazioni non lineari in due incognite, ha la proprietà di convergenza rapida del metodo di Newton per i sistemi di equazioni. Il principale svantaggio di questo metodo è che a volte non coverge alla soluzione. Questo perché è difficile trovare un'ipotesi iniziale che soddisfi le rigide condizioni necessarie per assicurare la convergenza. Quando queste condizioni non sono soddisfatte, la sequenza di approssimazioni può allontanarsi dalle radici desiderate o può iterare indefinitamente intorno alle radici.

Il programma ottiene un'approssimazione iniziale a due radici del polinomio e usa queste due radici per stimare i valori iniziali iniziali dell'interazione di Bairstow. Questi valori sono i coefficienti r e s di un fattore quadratico approssimativo x^2 + rx + s, del polinomio dato. Il polinomio dato passerà attraverso la divisione sintetica per il fattore quadratico che alla fine fornirà tutte le radici reali o complesse in forma singola o in coppia a seconda del grado del polinomio.

Il programma è la traduzione in newLISP del programma in C disponibile all'indirizzo:

https://github.com/DipakMajhi/Roots_of_a_Polynomial

in cui potete trovare anche un articolo (pdf) con tutte le spiegazioni sull'algoritmo.

(define (linear-aux a0 a1)
  ;(println (sub (div a0 a1)))
  (push (list (sub (div a0 a1))) sol -1))

(define (quadratic-aux t r s)
  (local (deter x1 x2 x1r x1i x2r x2i)
    (setq deter (sub (mul r r) (mul 4 s t)))
    ;(println t { } r { } s)
    (cond ((>= deter 0)
           (setq x1 (div (add (sub r) (sqrt deter)) (mul 2 t)))
           (setq x2 (div (sub (sub r) (sqrt deter)) (mul 2 t)))
           ;(println "x1: " x1 { } "x2: " x2)
           (push (list x1 x2) sol -1)
          )
          (true
           (setq x1r (div (sub r) (mul 2 t)))
           (setq x1i (div (sqrt (abs deter)) (mul 2 t)))
           (setq x2r x1r)
           (setq x2i (sub x1i))
           ;(println "x1r: " x1r { , } "x1i: " x1i)
           ;(println "x2r: " x2r { , } "x2i: " x2i)
           (push (list (list x1r x1i) (list x2r x2i)) sol -1)
           ;(push (list x1r x1i) sol -1)
           ;(push (list x2r x2i) sol -1)
          ))))

(define (bairstow coeff)
  (local (w j i n
          t deter p q x1 x2 x1r x1i r s ds dr
          a b c d sol)
    (setq sol '())
    (setq x1 0.0)
    (setq x2 0.0)
    (setq r 0.1)
    (setq s 0.1)
    (setq a (array 100 '(0)))
    (setq b (array 100 '(0)))
    (setq c (array 100 '(0)))
    (setq d (array 100 '(0)))
    (setq (b 4) 0)
    (setq (b 3) 0)
    ;assegna i coefficienti al vettore "a"
    (dolist (el (reverse coeff))
      (setq (a $idx) el)
    )
    ;(println a)
    (setq n (- (length coeff) 1))
    (setq w n)
    (cond ((= w 1) (linear-aux (a 0) (a 1)) (-- w))
          ((= w 2) (quadratic-aux (a 2) (a 1) (a 0)) (setq w (- w 2)))
          (true
           (while (>= w 3)
             (for (j 1 50)
               (setq (b n) (a n))
               (setq (b (- n 1)) (sub (a (- n 1)) (mul r (b n))))
               (for (i (- n 2) 1 -1)
                 (setq (b i) (sub (a i) (mul r (b (+ i 1))) (mul s (b (+ i 2)))))
               )
               (setq (b 0) (sub (a 0) (mul s (b 2))))
               (setq (c n) (b n))
               (setq (c (- n 1)) (sub (b (- n 1)) (mul r (c n))))
               (for (i (- n 2) 2 -1)
                 (setq (c i) (sub (b i) (mul r (c (+ i 1))) (mul s (c (+ i 2)))))
               )
               (setq (c 1) (sub (mul s (c 3))))
               (setq (d n) (b n))
               (setq (d (- n 1)) (sub (b (- n 1)) (mul r (d n))))
               (for (i (- n 2) 3 -1)
                 (setq (d i) (sub (b i) (mul r (d (+ i 1))) (mul s (d (+ i 2)))))
               )
               (setq (d 2) (sub (b 2) (mul s (d 4))))
               (setq dr (div
                        (sub (mul (b 0) (d 3)) (mul (b 1) (d 2)))
                        (add (mul (sub (d 2) (mul r (d 3))) (d 2)) (mul s (d 3) (d 3)))))
               (setq ds (div
                        (sub (add (mul (b 1) s (d 3)) (mul (b 0) (sub (d 2) (mul r (d 3))))))
                        (add (mul (sub (d 2) (mul r (d 3))) (d 2)) (mul s (d 3) (d 3)))))
               (setq p (sub r dr))
               (setq q (sub s ds))
               (setq r p)
               (setq s q)
            )
            (setq t 1)
            (quadratic-aux t r s)
            (setq w (- w 2))
            (for (i n 0 -1)
              (setq (a (- n i)) (b (- n i)))
            )
            (for (i n 0 -1)
              (setq (a (- n i)) (a (+ (- n i) 2)))
            )
          )
          (cond ((= w 2) (quadratic-aux (b 4) (b 3) (b 2)) (setq w (- w 2)))
                ((= w 1) (linear-aux (b 2) (b 3)) (-- w))
          )
        )
    )
    sol
  )
)

Vediamo alcuni esempi:

4x - 32 = 0
(bairstow '(4 32))
;-> ((-8))

2x^2 -4x + 10 = 0
(bairstow '(2 -4 10))
;-> (((1 2) (1 -2)))

x^2 -3x + 2 = 0
(bairstow '(1 -3 2))
;-> ((2 1))

4x^3 + 2x^2 -4*x + 10 = 0
(bairstow '(4 2 -4 10))
;-> (((0.6563019928818721 0.9739090873711072)
;->   (0.6563019928818721 -0.9739090873711072))
;->  (-1.812603985763744))
WolframAlpha
x≈0.656301992881872 + 0.973909087371107 i
x≈0.656301992881872 - 0.973909087371107 i
x≈-1.81260398576374

3x^4 - 2x^3 - x^2 + 4x + 10 = 0
(bairstow '(3 -2 -1 4 10))
;-> (((-0.871136997600388 0.7358894057211269)
;->   (-0.871136997600388 -0.7358894057211269))
;->  ((1.204470330933721 1.054769962446627)
;->   (1.204470330933721 -1.054769962446627)))
WolframAlpha
x≈-0.871136997600388 + 0.735889405721127 i
x≈-0.871136997600388 - 0.735889405721127 i
x≈1.20447033093372 + 1.05476996244663 i
x≈1.20447033093372 - 1.05476996244663 i

5x^5 - 4x^4 + 7x^3 + 8x^2 + 9x + 3 = 0
(bairstow '(5 -4 7 8 9 3))
;-> (((-0.3480864445180198 0.6520958216175604)
;->   (-0.3480864445180198 -0.6520958216175604))
;->  ((0.9531760543651267 1.329888453606416)
;->   (0.9531760543651267 -1.329888453606416))
;->  (-0.4101792196942135))
WolframAlpha
x≈-0.348086 - 0.652096 i
x≈-0.348086 + 0.652096 i
x≈0.953176 - 1.32989 i
x≈0.953176 + 1.32989 i
x≈-0.410179

x^9 - 2x^8 + 3x^7 + 0x^6 + 5x^5 - 4x^4 + 7x^3 + 8x^2 + 9x + 3 = 0
(bairstow '(1 -2 3 0 5 -4 7 8 9 3))
;-> (((-0.3612218566283093 0.6913476051961196)
;->   (-0.3612218566283093 -0.6913476051961196))
;->  ((-0.739130448788589 0.9706810141091354)
;->   (-0.739130448788589 -0.9706810141091354))
;->  ((1.251229097959007 1.099346245887554)
;->   (1.251229097959007 -1.099346245887554))
;->  ((1.053720393127137 1.34449644051663)
;->   (1.053720393127137 -1.34449644051663))
;->  (-0.4091943713384922))

WolframAlpha
x≈-0.361222 + 0.691348 i
x≈-0.361222 - 0.691348 i
x≈-0.73913 + 0.970681 i
x≈-0.73913 - 0.970681 i
x≈1.25123 + 1.09935 i
x≈1.25123 - 1.09935 i
x≈1.05372 + 1.3445 i
x≈1.05372 - 1.3445 i
x≈-0.409194

Calcoliamo il valore del polinomio per una radice:
x^9 - 2 x^8 + 3 x^7 + 0 x^6 + 5 x^5 - 4 x^4 + 7 x^3 + 8 x^2 + 9 x + 3
dove x = 1.251229097959007 - 1.099346245887554 i
Risultato:
2.99×10^-14 + 6.8×10^-15 i


-------------
Nomi ordinati
-------------

Abbiamo una lista con alcuni nomi in ordine alfabetico:

(andrea bea carla eva francesca marco pietro roberta sandra)

Se mischiamo i nomi della lista:

1) qual'è la probabilità che la lista mischiata sia ordinata come quella iniziale?
2) qual'è la probabilità che almeno un nome sia allo stesso posto della lista iniziale?
3) qual'è la probabilità limite del punto 2) al tendere di n all'infinito (n = numero dei nomi)?

Vediamo di calcolare queste probabilità prima con delle simulazioni e poi matematicamente.

1) qual'è la probabilità che la lista mischiata sia ordinata come quella iniziale?

(define (prob1 n)
  (local (base test conta)
    (setq conta 0)
    (setq base '(andrea bea carla eva francesca marco pietro roberta sandra))
    (setq test (randomize base))
    (for (i 1 n)
      (setq test (randomize test))
      (if (= base test) (++ conta))
    )
    (list conta n (div conta n))
  )
)

(prob1 1000000)
;-> (3 1000000 3e-006)

(prob1 10000000)
;-> (28 10000000 2.8e-006)

(prob1 100000000)
;-> (251 100000000 2.51e-006)

Matematicamante risulta che esistono 9!=362880 possibilità di ordinare la lista. Quindi la probabilità cercata vale:

prob1 = 1 / 9! = (div 1 362880) = 2.755731922398589e-006

2) qual'è la probabilità che almeno un nome sia allo stesso posto della lista iniziale?
Per semplificare il codice consideriamo una lista costituita da soli numeri:

(1 2 3 4 5 6 7 8 9)

In questo modo due liste hanno un elemento in comune se troviamo almeno uno 0 nella differenza tra gli elementi delle due liste:

(if (find 0 (map - base test)) (++ conta))

(define (prob2 n)
  (local (base test conta)
    (setq conta 0)
    (setq base '(1 2 3 4 5 6 7 8 9))
    (setq test (randomize base))
    (for (i 1 n)
      (setq test (randomize test))
      (if (find 0 (map - base test)) (++ conta))
    )
    (list conta n (div conta n))
  )
)

(prob2 100)
;-> (60 100 0.6)
(prob2 1000)
;-> (632 1000 0.632)
(prob2 10000)
;-> (6238 10000 0.6238)
(prob2 100000)
;-> (63361 100000 0.63361)
(prob2 1000000)
;-> (632357 1000000 0.632357)
(prob2 10000000)
;-> (6320110 10000000 0.632011)

Dal punto di vista matematico considerando una lista con i primi 5 numeri abbiamo:

P(1) = 1/5 e

P(1 e 2) = 1/5 * 1/4

Utilizziamo il principio di inclusione-esclusione per calcolare la probabilità che il numero 1 o 2 o 3 o 4 o 5 sia piazzato correttamente (almeno uno).

P(1 o 2 o 3 ... o 5) = P(1) + P(2) + P(3) + P(4) + P(5)
                       - P(1 e 2) - P(2 e 3) - ...
                       + P(1 e 2 e 3) + P(2 e 3 e 4) + ...
                       - P(1 e 2 e 3 e 4) - P(2 e 3 e 4 e 5) - ...
                       + P(1 e 2 e 3 e 4 e 5)

                     = 5*(1/5)
                       - 5C2*(1/5)(1/4)
                       + 5C3*(1/5)(1/4)(1/3)
                       - 5C4*(1/5)(1/4)(1/3)(1/2)
                       + (1/5)(1/4)(1/3)(1/2)(1/1)

                     = 5*(1/5)
                       - 5*2*(1/5)(1/4)
                       + 5*3*(1/5)(1/4)(1/3)
                       - 5*4*(1/5)(1/4)(1/3)(1/2)
                       + (1/5)*(1/4)*(1/3)*(1/2)*(1/1)

        5*4    1    5*4*3     1      5*4*3*2       1          1
  = 1 - --- * --- + ----- * ----- - --------- * ------- + ---------
        1*2   5*4   1*2*3   5*4*3    1*2*3*4    5*4*3*2   5*4*3*2*1

  = 1 - 1/2! + 1/3! - 1/4! + 1/5! =

  = 1 - 0.5 + 0.166666667 - 0.041666667 + 0.008333333 = 0.633333333

Questa è la probabilità che almeno uno dei 5 numeri sia piazzato correttamente.

La formula generalizzata per n numeri è la seguente:

P = 1 - (-1)^n 1/n!

Nel caso di nove elementi risulta:

P(nove) = 1 - 0.5 + 0.166666667 - 0.041666667 + 0.008333333
          - 0.001388889 + 0.000198413 - 2.48016E-05 + 2.75573E-06 = 0.632120811

Quindi il valore calcolato matematicamente corrisponde al valore della simulazione.

3) qual'è la probabilità che almeno un nome sia allo stesso posto della lista iniziale quando il numero n dei nomi/elementi tende all'infinito?

La formula da considerare è la seguente:

sum[2 <= n <= ∞] (1 - (-1)^n/(n!))

Scriviamo la funzione che calcola la probabilità per una lista con n elementi:

; funzione fattoriale per biginteger
(define (fact n) (apply * (map bigint (sequence 1 n))))

(define (prob3 n)
  (local (val)
    (setq val 1L)
    (for (i 2 n)
      (setq val (sub val (div (pow -1 i) (fact i))))
    )
    val))

Controlliamo il risultato del secondo quesito:

(prob3 9)
;-> 0.632120811287478

Vediamo cosa accade quando cresce il valore di n:

(prob3 50)
;-> 0.6321205588285578
(prob3 100)
;-> 0.6321205588285578
(prob3 200)
;-> 0.6321205588285578

Nota: (1 - 1/e) = 0.6321205588285578

(sub 1 (div 1 (exp 1)))
;-> 0.6321205588285577


-------------------------------
Distanza di numeri in una lista
-------------------------------

Data una lista di numeri interi e un numero intero restituire una lista con tutte le distanze di quel numero con se stesso. Se il numero non esiste restituire la lista vuota. Se il numero compare solo una volta restituire il valore dell'indice.

Per esempio:

lista input = (2 1 3 5 4 2 1 4 1 6 5 6 7 8 4 1 2 4 1)
numero = 1
lista output = (4 1 6 2)

dove:
1 3 5 4 2 1      ->  4 posti di distanza tra i primi due 1
1 4 1            ->  1 posto di distanza tra i secondi due 1
1 6 5 6 7 8 4 1  ->  6 posti di distanza tra i terzi due 1
1 2 4 1          ->  2 posti di distanza tra i quarti due 1

Metodo procedurale:

(setq lst '(2 1 3 5 4 2 1 4 1 6 5 6 7 8 4 1 2 4 1))
(setq num 1)

(define (segment1 num lst)
  (local (idx1 idx2 conta out)
    (setq idx1 -1 idx2 -1 conta 0 out '())
    (dolist (el lst)
      (if (= el num) ; quando i numeri sono uguali
          (begin
            (if (= idx1 -1) ; se il primo indice è vuoto...
              (setq idx1 $idx) ; allora prendiamo l'indice attuale ($idx)
              (begin ; altrimenti $idx è il secondo indice
                (push (- $idx idx1 1) out -1)
                (++ conta)
                ; il primo indice diventa l'indice attuale
                (setq idx1 $idx)
              )
            )
          )
      )
    )
    (if (and (= conta 0) (>= idx1 0))
       idx1
       out
    )
    ;(println out { } idx1 { } idx2 { } conta)
  ))

(segment1 num lst)
;-> (4 1 6 2)

(segment1 8 lst)
;-> 13

(segment1 1 '(1 0 3 4))
;-> 0

(segment1 9 lst)
;-> ()

(segment1 9 '())
;-> '()

Metodo funzionale:

(setq lst '(2 1 3 5 4 2 1 4 1 6 5 6 7 8 4 1 2 4 1))
(setq num 1)

Troviamo tutti gli indici di un elemento in una lista:

(ref-all num lst)
;-> ((1) (6) (8) (15) (18))

Poi rendiamo piatta la lista:

(flat (ref-all num lst))
;-> (1 6 8 15 18)

Per calcolare la differenza tra gli elementi consecutivi di una lista lista usiamo la funzione seguente:

(define (dist lst) (map - (rest lst) (chop lst)))
(dist lst)
;-> (-1 2 2 -1 -2 -1 3 -3 5 -1 1 1 1 -4 -3 1 2 -3)

Infine dobbiamo togliere il valore 1 ad ogni elemento:

(map -- (dist (flat (ref-all num lst))))
;-> (4 1 6 2)

Adesso vediamo il caso in cui il numero non esiste nella lista:

(ref-all 22 lst)
;-> ()

Quindi scriviamo la funzione finale:

(define (segment2 num lst)
  (cond ( (= (ref-all num lst) '())
          '()
        )
        ( (= (length (flat (ref-all num lst))) 1)
          (first (flat (ref-all num lst)))
        )
        (true (map -- (dist (flat (ref-all num lst)))))
  ))

Semplifichiamo:

(define (segment2 num lst)
  (let (idx (flat(ref-all num lst)))
    (cond ( (= idx '())
          '()
          )
          ( (= (length idx) 1)
            (first idx)
          )
          (true (map -- (dist idx)))
    )))

(segment2 num lst)
;-> (4 1 6 2)

(segment2 8 lst)
;-> 13

(segment2 1 '(1 0 3 4))
;-> 0

(segment2 9 lst)
;-> ()

(segment2 9 '())
;-> '()

Test di velocità

(setq lst '(2 1 3 5 4 2 1 4 1 6 5 6 7 8 4 1 2 4 1
            2 1 3 5 4 2 1 4 1 6 5 6 7 8 4 1 2 4 1
            2 1 3 5 4 2 1 4 1 6 5 6 7 8 4 1 2 4 1
            2 1 3 5 4 2 1 4 1 6 5 6 7 8 4 1 2 4 1
            2 1 3 5 4 2 1 4 1 6 5 6 7 8 4 1 2 4 1))

(time (segment1 1 lst) 50000)
;-> 402.887

(time (segment2 1 lst) 50000)
;-> 187.527


-------------------------------------------
Ascensore difettoso ed equazioni diofantine
-------------------------------------------

Un ascensore in edificio di 65 piani è difettoso.
Ogni volta che qualcuno vuole salire, l'ascensore sale di 8 piani se può. Se l'ascensore non può salire di 8 piani, rimane nello stesso punto (se siamo al 63° piano e premiamo "su", l'ascensore rimane al 63° piano).
E ogni volta che qualcuno vuole scendere, l'ascensore scende di 11 piani se può.
In caso contrario, l'ascensore rimane nello stesso punto. (se premiamo "giù" dal piano 9, l'ascensore rimane al piano 9).
L'ascensore parte dal primo piano. È possibile raggiungere tutti i piani dell'edificio?

Nella tabella sottostante, ogni piano può essere raggiunto da una combinazione di salita di 8 piani e discesa di 11 piani.
Le righe orizzontali mostrano l'ascensore che sale di 8 piani alla volta e le colonne verticali sono quando l'ascensore scende di 11 piani alla volta. Questi sono tutti i piani raggiungibili.
Se in questa matrice esistono tutti i numeri da 1 a 65, allora i piani sono tutti raggiungibili.

1 9 17 25 33 41 49 57 65
     6 14 22 30 38 46 54 62
        3 11 19 27 35 43 51 59
              8 16 24 32 49 48 56 64
                 5 13 21 29 37 45 53 61
                    2 10 18 26 34 42 50 58
                          7 15 23 31 39 47 55 63
                             4 12 20 28 36 44 52 60

Scriviamo la funzione che costruisce la matrice e poi verifichiamo la sua completezza.

(define (up start)
  (if (<= (+ start 8) 65)
      (+ start 8)
      start))

(up 60)
;-> 60
(up 56)
;-> 64

(define (down start)
  (if (>=  (- start 11) 1)
      (- start 11)
      start))

(down 1)
;-> 1
(down 12)
;-> 1
(down 11)
;-> 11

(define (line-up start)
  (local (val out)
    (setq out '())
    (setq val start)
    (push val out -1)
    (while (<= (+ val 8) 65)
      (setq val (+ val 8))
      (push val out -1)
    )
    out))

(line-up 1)
;-> (1 9 17 25 33 41 49 57 65)
(line-up 63)
;-> (63)

(define (controllo-piani)
  (local (piano base curline lista-piani)
    (setq lista-piani '())
    (setq base (line-up 1))
    (setq curline base)
    (push base lista-piani -1)
    ; affinchè non otteniamo una linea uguale
    ; a quella iniziale
    (do-until (= curline base)
      (setq piano nil)
      ; cerchiamo il primo valore utile (maggiore di 11)
      (dolist (el curline piano)
        (if (> el 11) (setq piano (- el 11)))
      )
      ; costruiamo la linea di piani corrente
      (setq curline (line-up piano))
      ; e la aggiungiamo al risultato
      (push curline lista-piani -1)
    )
    ; lista-piani contiene tutti i piani raggiungibili
    ; (anche con valori multipli)
    ; controllo di completezza (esistono tutti i piani da 1 a 65?)
    (difference (unique (flat lista-piani)) (sequence 1 65))
    ))

(controllo-piani)
;-> ()

Quindi tutti i piani sono raggiungibili.

Nota: per spostarsi da un piano x ad un piano y occorre partire dal numero x e seguire il percorso nella matrice (destra --> su) (basso --> giù).
Esempio: dal piano 6 al piano 10

6 14 22 30 38 46 54
                 43
                 32
                 21
                 10

Dal punto di vista matematico stiamo essenzialmente cercando soluzioni intere alla seguente equazione:

 8x – 11y = piano

Questi tipi di equazioni sono noti come "equazioni lineari diofantee (diofantine)"
Per un'equazione generale, ax + by = c, le soluzioni esistono se e solo se
c è un multiplo del massimo comune divisore di a e b. Più precisamente:
l'equazione diofantina ha una soluzione (dove x e y sono numeri interi) se e solo se c è un multiplo del massimo comune divisore di a e b. Inoltre, se (x, y) è una soluzione, allora le altre soluzioni hanno la forma (x + k*v, y - k*u), dove k è un numero intero arbitrario e u e v sono i quozienti di a e b (rispettivamente) dal massimo comune divisore di a e b.

Nel nostro caso MCD(8, -11) = 1, quindi, poichè qualunque numero di piano (da 1 a 65) è multiplo di 1, significa che tutte le 65 equazioni diofantine sono risolvibili e, di consegunenza, tutti i piani sono raggiungibili.

Per finire scriviamo una funzione che trova (se esite) una soluzione di ogni equazione diofantina lineare:

; algoritmo di Euclide esteso
; per il calcolo del Massimo Comun Divisore (GCD)
(define (gcd-ext a b)
    (cond ((zero? b)
           (setq x 1 y 0)
           a)
          (true
           (setq g (gcd-ext b (% a b)))
           (setq x1 x y1 y)
           (setq x y1)
           (setq y (- x1 (mul y1 (div a b))))
           g)
    ))

(gcd-ext 18 24)
;-> 6

Funzione che calcola una soluzione dell'equazione lineare diofantea:

(define (diofanto-base a b c)
  (local (x y x1 y1 val)
    (setq val (gcd-ext a b))
    (cond ((!= (% c val) 0)
           '()
          )
          (true
            (list (mul x (div c val)) (mul y (div c val)))
          )
    )))

(diofanto-base 4 18 10)
;-> (-20 5)

(diofanto-base 8 -11 1)
;-> (-5 -6)


----------------
Monete e griglie
----------------

Abbiamo una moneta di diametro D e un tavolo su cui è disegnata una griglia di quadrati che hanno lato L (con L > D). Lanciando la moneta sul tavolo, qual'è la probabilità che la moneta non intersechi la griglia? (cioè cada interamente in un quadrato della griglia).

Affinchè la moneta non intersechi nessuna linea della griglia, il centro del cerchio deve essere posizionato sufficientemente lontano dalle linee della griglia. Questo luogo di punti rappresenta tutti i punti di non-intersezione. Possiamo trovare l'area di questo luogo e dividerlo per l'area totale di un quadrato della griglia per calcolare la probabilità cercata.
I punti di non-intersezione sono il quadrato di lato (L - D). Questo perché il centro del cerchio
deve essere a più di L/2 di distanza da tutti i lati di un quadrato della griglia. Quindi il centro del cerchio deve trovarsi in un quadrato di lato (L - 2*(D/2)) = (L - D).

          L
   +---------------+
   |     (L-D)     |
   |    +-----+    |
   |    |     |    | L
   |    |     |    |
   |    +-----+    |
   |               |
   +---------------+

L'area di questo quadrato vale (L - D)^2. L'area di un quadrato della griglia vale S^2.
La probabilità di non-intersezione è il rapporto di queste aree: ((L-D)/L)^2.

Vediamo di verificarlo con una simulazione.

(define (rand-xy vmax)
  (list (mul (random) vmax) (mul (random) vmax)))

(rand-xy 10 10)
;-> (6.168401135288553 4.876857814264351)

(define (lancio lato diametro)
  (local (xy xcur ycur)
    (setq xy (rand-xy lato))
    (setq xcur (first xy))
    (setq ycur (last xy))
    (if (and (> xcur (div diametro 2))
            (< xcur (sub lato (div diametro 2)))
            (> ycur (div diametro 2))
            (< ycur (sub lato (div diametro 2))))
    )
  )
)

(lancio 10 5)
2.587359233375042 0.02258369701223792

(lancio 10 5)
6.757103183080538 6.714987640003662

(define (test n l d)
  (local (dentro fuori)
    (for (i 1 n)
      (if (lancio l d)
          (++ dentro)
          (++ fuori)
      )
    )
    (println "dentro = " dentro " - " (div dentro (add dentro fuori)) "%")
    (println "fuori = " fuori " - " (div fuori (add dentro fuori)) "%")
    (println "% dentro (teorica) = " (pow (div (sub l d) l)) "%")
  ))

(test 100000 10 5)
;-> dentro = 25007 - 0.25007%
;-> fuori = 74993 - 0.74993%
;-> % dentro (teorica) = 0.25%

(test 100000 1.5 1)
;-> dentro = 11165 - 0.11165%
;-> fuori = 88835 - 0.88835%
;-> % dentro (teorica) = 0.1111111111111111%

La simulazione produce risultati in linea con la teoria.


---------------
Teorema di Pick
---------------

Il teorema di Pick è un teorema di geometria che permette di calcolare l'area di un poligono semplice i cui vertici hanno coordinate intere.
Dato un poligono semplice i cui vertici hanno coordinate intere (poligono lattice), abbiamo:

I il numero di punti con coordinate intere interni al poligono;
B il numero di punti con coordinate intere sul perimetro del poligono (vertici compresi).

L'area A del poligono può essere calcolata tramite la formula:

A = I + B/2 - 1

Possiamo usare questa formula per calcolare quanti sono i punti con coordinate intere interni al poligono.

La funzione per il calcolo dell'area di un poligono è la seguente:

(define (area polygon)
  (local (res)
    (setq res 0)
    (for (i 0 (- (length polygon) 2))
      (setq res (add res
                     (mul (sub (polygon i 0) (polygon (+ i 1) 0))
                          (add (polygon i 1) (polygon (+ i 1) 1)))))
    )
    (abs (div res 2))))

Funzione che calcola il numero dei punti con coordinate intere che si trovano sul perimetro del poligono:

(define (bound-point polygon)
  (local (dx dy size bb)
    ; i vertici del poligono sono tutti sul perimetro
    (setq size (length polygon))
    (setq bb size)
    ; ciclo per tutti i lati del poligono
    (for (i 0 (- size 1))
      (setq dx (- (polygon i 0) (polygon (% (+ i 1) size) 0)))
      (setq dy (- (polygon i 1) (polygon (% (+ i 1) size) 1)))
      ; gcd + 1 produce i punti sul perimetro, quindi gcd - 1 produce tutti i punti
      ; che si trovano sul segmento tranne i due punti estremi
      (setq bb (+ bb (abs (gcd dx dy)) -1))
    )
    bb))

Il numero di punti che hanno coordinate intere lungo un segmento di linea vale: GCD(dx,dy) + 1
dove MCD è il Massimo Comun Divisore (Greatest Common Divisor - GCD)
dx è la distanza tra le coordinate x dei punti
dy è la distanza tra le coordinate y dei punti

Vediamo il perchè:
supponiamo che il nostro segmento inizi nel punto (x1, y1) con coordinate intere e termini nel punto (x2, y2) con coordinate intere. La pendenza di questo segmento vale (y1-y2)/(x1-x2)
Possiamo semplificare questa frazione in a/b in modo tale che MCD (a, b) = 1
Ora se iniziamo dal punto (x1, y1) e aumentiamo x1 di b e y1 di a, cosa succederà?
Il nostro nuovo punto sarà: (x1 + b, y1 + a)
Avrà coordinate intere e la sua pendenza sarà (y1 + a-y1)/(x1 + b-x1) = a/b quindi è ancora sulla stessa pendenza del nostro segmento di linea.
E possiamo ripetere tale procedura per generare tali punti fino a quando (x1 + b * k, y1 + a * k) = (x2, y2)
Quindi quanti punti di questo tipo ci sono in totale? (x1-x2)/b + 1 oppure (y1-y2)/a + 1
prendiamo come soluzione (y1-y2)/a + 1
E (y1-y2)/(x1-x2) = a/b
Come semplificare di nuovo le frazioni? Utilizzando il MCD.

a = (y1-y2)/MCD(abs (y1-y2), abs (x1-x2))
b = (x1-x2)/MCD(abs (y1-y2), abs (x1-x2))

Quindi (y1-y2)/a + 1 = (y1-y2)/((y1-y2)/MCD(abs(y1-y2), abs(x1-x2))) + 1 = MCD(abs(y1-y2), abs(x1-x2)) + 1

Per calcolare i punti interni al poligono usiamo il teorema di Pick:

(define (interior-point polygon)
  (+ (- (area polygon) (/ (bound-point polygon) 2)) 1))

Adesso proviamo le funzioni che abbiamo scritto. Possiamo verificare i risultati disegnando i poligoni di esempio su un foglio di carta a quadretti.

; un quadrato
(setq poly '((0 0) (5 0) (5 5) (0 5) (0 0)))
(area poly)
;-> 25
(bound-point poly)
;-> 20
(interior-point poly)
;-> 16

(setq poly '((4 9) (8 9) (14 3) (7 3) (7 6) (4 6) (4 9)))
(area poly)
;-> 33
(bound-point poly)
;-> 26
(interior-point poly)
;-> 21

(setq poly '((2 6) (4 4) (6 6) (8 4) (10 4) (10 1) (9 1) (7 3) (4 3) (2 1) (2 6)))
(area poly)
;-> 20
(bound-point poly)
;-> 26
(interior-point poly)
;-> 9

(setq poly '((3 2) (6 5) (6 7) (2 5) (3 2)))
(area poly)
;-> 10
(bound-point poly)
;-> 8
(interior-point poly)
;-> 7


---------------------------------
Problema dei fiammiferi di Banach
---------------------------------

Una persona ha due scatole di fiammiferi nello zaino. Ogni volta che ha bisogno di un fiammifero lo prende da una delle due scatole (cioè, ha la stessa probabilità di prenderlo da una delle due scatole). Ad un certo punto sceglierà una scatola che non contiene alcun fiammifero: qual è la probabilità che ci siano esattamente k fiammiferi nell'altra scatola?

La soluzione matematica (senza dimostrazione) è la seguente:

               (2*n - k)!
p(k,n) = -----------------------
          n!*(n - k)!*2^(2*n-k)

Vediamo di scrivere un programma che simula questo problema e poi confrontiamo i risultati con quelli generati dalla formula sopra.

La seguente funzione simula lo svuotamento di una delle due scatole e restituisce il numero di fiammiferi dell'altra scatola:

(define (box m)
  (local (box1 box2)
    (setq box1 m box2 m)
    (while (and (>= box1 0) (>= box2 0))
      (if (zero? (rand 2))
          (-- box1)
          (-- box2)
      )
    )
    ;(println box1 { - } box2)
    ; il ciclo si ferma con box1=-1 oppure box2=-1
    (if (= box1 -1)
        box2
        box1
    )
  )
)

(box 40)
;-> 5
(box 40)
;-> 0

Adesso vediamo la funzione che calcola la probabilità per valori di k da 1 a n (numero dei fiammiferi):

(define (banach n prove)
  (local (sol res)
    (setq sol (array (+ n 1) '(0)))
    (for (i 1 prove)
      (setq res (box n))
      ;(print res { })
      (setf (sol res) (+ (sol res) 1))
    )
    ;(println sol)
    (map (fn(x) (mul 100 (div x (apply + sol)))) sol)
  )
)

Vediamo cosa accade con un milione di prove:

(banach 40 1000000)
;-> (8.8874 8.9236 8.756500000000001 8.5153 8.262600000000001
;->  7.7165 7.2776 6.6639 6.0641 5.3545 4.7031 4.0201 3.3735
;->  2.7765 2.2529 1.7751 1.3587 1.0171 0.7549 0.5440999999999999
;->  0.3697 0.2397 0.1619 0.1025 0.05860000000000001 0.0335 0.0198
;->  0.0086 0.0043 0.0021 0.0006000000000000001 0.0004 9.999999999999999e-005
;->  9.999999999999999e-005 9.999999999999999e-005 0 0 0 0 0 0)

Il risultato è un distribuzione di probabilità e ci mostra che:

8.8874% è la probabilità che rimangano "0" fiammiferi
8.9236% è la probabilità che rimanga "1" fiammifero
8.7565% è la probabilità che rimangano "2" fiammiferi
...
0% è la probabilità che rimangano "40" fiammiferi

Vediamo cosa accade con 10 milioni di prove:

(banach 40 10000000)
;-> (8.887029999999999 8.898639999999999 8.78139 8.553900000000001 8.22129 7.79082 7.28017
;->  6.680590000000001 6.04414 5.3579 4.679980000000001 4.01594 3.37442 2.78878 2.24326
;->  1.76941 1.35602 1.02151 0.74282 0.52745 0.36279 0.24164 0.15645 0.09701 0.05805
;->  0.03308 0.01864 0.008880000000000001 0.0044 0.00206 0.00087 0.00042 0.00014 8.999999999999999e-005
;->  2e-005 0 0 0 0 0 0)

E con 100 milioni di prove:

(banach 40 100000000)
;-> (8.893085000000001 8.890554 8.779613999999999 8.54871 8.226092 7.793252000000001
;->  7.276094 6.683678 6.034226 5.357866 4.686191 4.021178 3.376403 2.787189 2.243892
;->  1.766746 1.356101 1.018071 0.746408 0.530042 0.362362 0.24248 0.156536 0.09760199999999999
;->  0.057683 0.032535 0.018259 0.009047000000000001 0.004389000000000001 0.002141 0.0009069999999999999
;->  0.000444 0.000133 6.9e-005 2.1e-005 0 0 0 0 0 0)

Adesso scriviamo la funzione che risolve il problema con la formula matematica:

(define (binomiale n k)
  (local (M q)
    (setq M (array (+ n 1) (+ k 1) '(0)))
    (for (i 0 n)
      (setq q (min i k))
      (for (j 0 q)
        (if (or (= j 0) (= j i))
          (setq (M i j) 1)
          (setq (M i j) (+ (M (- i 1) (- j 1)) (M (- i 1) j)))
        )
      )
    )
    (M n k)
  );local
)

(binomiale 10 4)
;-> 210

(define (fact n)
  (if (zero? n)
      1L
      (apply * (map bigint (sequence 1 n)))))

(fact 0)
;-> 1L
(fact 3)
;-> 6L

               (2*n - k)!
p(k,n) = -----------------------
          n!*(n - k)!*2^(2*n-k)

(define (banach-p n)
  (local (num den sol)
    (setq sol '())
    (for (k 0 n)
      (setq num (fact (- (* 2 n) k)))
      (setq den (* (fact n) (fact (- n k)) (pow 2 (- (* 2 n) k))))
      ;(setq sol (mul 100 (div num den)))
      ;(println (format "%2.3f" sol))
      (push (mul 100 (div num den)) sol -1)
    )
    sol
  )
)

(banach-p 40)
;-> (8.89278787739072 8.892787877390719 8.780220942233877 8.555087071920188
;->  8.221771991196025 7.789047149554129 7.269777339583854 6.680335933671648
;->  6.039755775648342 5.368671800576303 4.688135938531419 4.018402233026928
;->  3.377787384283506 2.781707257645241 2.241973013624522 1.766402980431442
;->  1.358771523408802 1.019078642556601 0.7440891675810103 0.5280632802187816
;->  0.3635845535932595 0.2423897023955064 0.1561154015428685
;->  0.09689921475074599 0.05779953160570813 0.03302830377469035
;->  0.01801543842255837 0.009341338441326565 0.004582543386311143
;->  0.002115020024451297 0.0009123615791750694 0.0003649446316700277
;->  0.0001340612932665408 4.468709775551359e-005 1.331105039525937e-005
;->  3.472447929198096e-006 7.716550953773547e-007 1.403009264322463e-007
;->  1.957687345566229e-008 1.864464138634503e-009 9.094947017729285e-011)

I risultati della simulazione sono simili a quelli calcolati matematicamente, anche se sui valori nulli e/o piccolissimi abbiamo gli errori relativi maggiori.


--------------
Window sliding
--------------

Questa tecnica mostra come un ciclo for annidato possa essere convertito (in alcuni problemi) in un singolo ciclo for per ridurre la complessità temporale.
Vediamo un problema illustrativo in cui possiamo applicare questa tecnica:

Dato una lista di numeri interi di dimensione "n". Il nostro scopo è calcolare la somma massima di "k" elementi consecutivi nella lista.
Input  : lst = (100 200 300 400)
         k = 2
Output : 700

Input  : lst = (1 4 2 10 23 3 1 0 20)
         k = 4
Output : 39
Si ottiene la somma massima con la sottolista (4 2 10 23) di lunghezza 4.

Input  : lst = (2 3)
         k = 3
Output : nil
Non esiste una sottolista di dimensione 3 poiché la dimensione dell'intera lista è 2.

Analizziamo prima il problema con l'approccio della forza bruta. Iniziamo con il primo indice e sommiamo fino al k-esimo elemento. Lo facciamo per tutti i possibili blocchi consecutivi o gruppi di k elementi. Questo metodo richiede un ciclo for annidato, il ciclo for esterno inizia con l'elemento iniziale del blocco di k elementi e il ciclo interno o annidato si sommerà fino all'elemento k-esimo.

(define (max-sub-sum lst k)
  (local (max-sum curr-sum)
    (setq max-sum -9223372036854775808)
    (for (i 0 (- (length lst) k))
      (setq curr-sum 0)
      (for (j 0 (- k 1))
        (setq curr-sum (add curr-sum (lst (+ i j))))
        ; Aggiorno il risultato se richiesto
        (setq max-sum (max curr-sum max-sum))
      )
    )
    max-sum))

(max-sub-sum '(3 2 5 6 1) 3)
;-> 13

(max-sub-sum '(1 10 4 7 11 3 1 15 5 6) 3)
;-> 26

(max-sub-sum '(1 10 4 7 11 3 1 15 5 6) 4)
;-> 32

(max-sub-sum '(20 10 4 7 11 3 1 15 5 6) 4)
;-> 41

Questo algoritmo ha complessità temporale O(k*n) perchè contiene due cicli for.

Possiamo ridurre la complessità temporale utilizzando la tecnica "window sliding" (finestra scorrevole):

si consideri una finestra di lunghezza n (che rappresenta l'intera lista) e un pannello di vetro che vi è fissato di lunghezza k. Inizialmente il pannello si trova all'estrema sinistra della finestra (ovvero inizia all'indice 0) e copre k indici/elementi. Ora correliamo i valori della finestra con quelli coperti dal pannello calcolando la somma dei k elementi coperti dal pannello (curr-sum). Ora applichiamo una forza sul pannello in modo che si sposti di una distanza unitaria in avanti: il pannello coprirà i prossimi k elementi consecutivi, quindi calcoliamo il valore di curr-sum per questi k elementi e andiamo avanti scorrendo in questo modo fine al raggiungimento della fine della finestra (lista).

Applichiamo la tecnica "window sliding" al nostro problema:

Calcoliamo la somma dei primi k elementi su n termini utilizzando un ciclo lineare e memorizziamo la somma nella variabile window-sum.
Quindi attraversiamo linearmente la lista fino a raggiungere la fine e contemporaneamente teniamo traccia della somma massima.
Per ottenere la somma corrente del blocco di k elementi basta sottrarre il primo elemento del blocco precedente e aggiungere l'ultimo elemento del blocco corrente.
La seguente rappresentazione grafica rende chiaro come la finestra scorre atraverso la lista.

lst = (3 2 5 6 1)
k = 3

| windowsum | = 3 + 2 + 5 = 10
---------------------
| 3 | 2 | 5 | 6 | 1 |
---------------------

    | curr-sum  | = windowsum - 3 + 6 = 10 - 3 + 6 = 13
---------------------
| 3 | 2 | 5 | 6 | 1 |
---------------------

        | curr-sum  | = windowsum - 2 + 1 = 13 - 2 + 1 = 12
---------------------
| 3 | 2 | 5 | 6 | 1 |
---------------------

(define (max-sub-sum lst k)
  (local (max-sum window-sum)
    (setq max-sum 0)
    ; calcola la somma della prima finestra
    (for (i 0 (- k 1))
        (setq max-sum (add max-sum (lst i)))
    )
    ; Calcola le somme delle finestre rimanenti
    ; rimuovendo il primo elemento della precedente finestra e
    ; aggiungendo l'ultimo elemento della finestra corrente.
    (setq window-sum max-sum)
    (for (i k (- (length lst) 1))
      (setq window-sum (sub (add window-sum (lst i)) (lst (- i k))))
      (setq max-sum (max max-sum window-sum))
    )
    max-sum))

(max-sub-sum '(3 2 5 6 1) 3)
;-> 13

(max-sub-sum '(3 2 5 -6 1) 3)
;-> 10

Come funziona?

| windowsum | = 3 + 2 + 5 = 10
---------------------
| 3 | 2 | 5 | 6 | 1 |
---------------------

    | curr-sum  | = windowsum - 3 + 6 = 10 - 3 + 6 = 13
---------------------
| 3 | 2 | 5 | 6 | 1 |
---------------------

        | curr-sum  | = windowsum - 2 + 1 = 13 - 2 + 1 = 12
---------------------
| 3 | 2 | 5 | 6 | 1 |
---------------------

Se volessimo conoscere anche gli elementi della sotto-lista che sommano al valore massimo dobbiamo modificare la funzione:

(define (max-sub-sum lst k)
  (local (max-sum window-sum sub-val)
    (setq max-sum 0)
    ; calcola la somma della prima finestra
    (for (i 0 (- k 1))
        (setq max-sum (add max-sum (lst i)))
    )
    (setq sub-val (slice lst 0 k))
    ; Calcola le somme delle finestre rimanenti
    ; rimuovendo il primo elemento della precedente finestra e
    ; aggiungendo l'ultimo elemento della finestra corrente.
    (setq window-sum max-sum)
    (for (i k (- (length lst) 1))
      (setq window-sum (sub (add window-sum (lst i)) (lst (- i k))))
      (if (> window-sum max-sum)
        (begin
        (setq max-sum window-sum)
        ; valori sotto-lista con somma massima
        (setq sub-val (slice lst (- (+ i 1) k) k)))
      )
    )
    (list max-sum sub-val)))

(max-sub-sum '(3 2 5 6 1) 3)
;-> (13 (2 5 6))

(max-sub-sum '(3 2 5 -6 1) 3)
;-> (10 (3 2 5))

(max-sub-sum '(1 10 4 7 11 3 1 15 5 6) 3)
;-> (26 (15 5 6))

(max-sub-sum '(1 10 4 7 11 3 1 15 5 6) 4)
;-> (32 (10 4 7 11))

(max-sub-sum '(20 10 4 7 11 3 1 15 5 6) 4)
;-> (41 (20 10 4 7))

Poichè abbiamo un solo ciclo "for" all'interno della funzione, la complessità temporale vale O(n).

Window sliding con lunghezza variabile
--------------------------------------
Questa tecnica può essere implementata anche utilizzando un pannello scorrevole di lunghezza variabile.
Vediamo un altro problema in cui possiamo applicare questa tecnica.

Data una stringare, trova la lunghezza della sotto-stringa (finestra) più piccola che contiene tutti i caratteri distinti della stringa data. Per esempio per la stringa "aabcbcdbca", il risultato sarebbe 4 poiché la finestra più piccola vale "dbca".

Approccio: Fondamentalmente un pannello di caratteri viene mantenuto utilizzando due puntatori, ovvero "Inizio" e "Fine". Questi puntatori di "Inizio" e "Fine" possono essere utilizzati rispettivamente per ridurre e aumentare la dimensione del pannello. Ogni volta che il pannello contiene tutti i caratteri di una determinata stringa, il pannello viene rimpicciolito dal lato sinistro per rimuovere i caratteri extra e quindi la sua lunghezza viene confrontata con il pannello più piccolo trovato finora.
Se nel pannello attuale non è possibile cancellare più caratteri allora iniziamo ad aumentare la dimensione del pannello partendo dalla fine fino a quando tutti i caratteri distinti presenti nella stringa sono presenti anche nel pannello. Infine, troviamo la dimensione minima di ogni pannello.

  I                       F
-----------------------------------------
| a | a | b | c | b | c | d | b | c | a |
-----------------------------------------

      I                   F
-----------------------------------------
| a | a | b | c | b | c | d | b | c | a |
-----------------------------------------

      I                       F
-----------------------------------------
| a | a | b | c | b | c | d | b | c | a |
-----------------------------------------

      I                           F
-----------------------------------------
| a | a | b | c | b | c | d | b | c | a |
-----------------------------------------

      I                           F
-----------------------------------------
| a | a | b | c | b | c | d | b | c | a |
-----------------------------------------

                          I           F
-----------------------------------------
| a | a | b | c | b | c | d | b | c | a |
-----------------------------------------

(define (find-min-sub str)
  (local (dist-conta visited
          start start-idx min-len
          conta curr-conta len-win)
    (setq visited (array 256 '(nil)))
    ; conta tutti i caratteri distinti
    (setq dist-conta 0)
    (for (i 0 (- (length str) 1))
      (if (null? (visited (char (str i) 0 true)))
        (begin
        (setf (visited (char (str i) 0 true)) true)
        (++ dist-conta))
      )
    )
    ; fondamentalmente manteniamo una finestra di caratteri
    ; che contiene tutti i caratteri della stringa data
    (setq start 0 start-idx -1 conta 0
          min-len 9223372036854775807)
    (setq curr-conta (array 256 '(0)))
    (for (j 0 (- (length str) 1))
      ; conta tutte le occorrenze dei caratteri della stringa
      (setf (curr-conta (char (str j) 0 true)) (+ (curr-conta (char (str j) 0 true)) 1))
      ; se troviamo un carattere distinto,
      ; allora incrementiamo il conto
      (if (= (curr-conta (char (str j) 0 true)) 1)
          (++ conta)
      )
      ; se tutti i caratteri corrispondono...
      (if (= conta dist-conta)
          (begin
          ; proviamo a ridurre la finestra:
          ; controlla se un qualsiasi carattere si verifica più volte
          ; rispetto alla sua occorrenza nel pattern,
          ; se sì allora rimuoverlo dall'inizio
          ; e rimuovere anche i caratteri che non servono.
          (while (> (curr-conta (char (str start) 0 true)) 1)
            (if (> (curr-conta (char (str start) 0 true)) 1)
                (setf (curr-conta (char (str start) 0 true)) (- (curr-conta (char (str start) 0 true)) 1))
            )
            (++ start)
          )
          ; Update window size
          (setq len-win (- (+ j 1) start))
          (if (> min-len len-win)
              (setq min-len len-win
                    start-idx start)
          ))
      )
    )
    ; restituisce la sotto-stringa da start-idx
    ; a lunga min-len
    (slice str start-idx min-len)))

(find-min-sub "aabcbcdbca")
;-> "dbca"

(find-min-sub "sdajkghasdghjkfadfsjh")
;-> "asdghjkf"


-------------------
Il gioco di Wythoff
-------------------

Il gioco di Wythoff è un gioco di sottrazione matematica per due giocatori, giocato con due pile di monete. I giocatori, a turno, rimuovono alcune monete da una o entrambe le pile. Quando si rimuovono le monete da entrambe le pile, allora il numero di monete rimosse da ogni pila deve essere uguale. Il gioco termina con la vittoria del giocatore che rimuove l'ultima moneta.

Una descrizione equivalente del gioco è quello di una regina degli scacchi che viene posizionata in una casella di una scacchiera e ogni giocatore può spostare la regina verso l'angolo in basso a sinistra della scacchiera (a1): sud, ovest o sud e ovest, per un qualsiasi numero di caselle. Il vincitore è il giocatore che riesce a posizionare la regina nell'angolo.

Una qualunque posizione nel gioco può essere descritta da una coppia di numeri interi (n, m) con n ≤ m, che rappresentano la quantità di monete di entrambe le pile o le coordinate della regina. La strategia del gioco ruota attorno a posizioni "fredde" e posizioni "calde": in una posizione fredda, il giocatore a cui spetta di muovere perderà anche con la miglior giocata, mentre in una posizione calda, il giocatore a cui spetta di muoversi vincerà con la migliore giocata. La strategia ottimale da una posizione "calda" è quella di spostarsi in qualsiasi posizione "fredda" raggiungibile.

La classificazione delle posizioni "calde" e "fredde" può essere eseguita in modo ricorsivo con le seguenti tre regole:

1) (0,0) è una posizione fredda.

2) Qualsiasi posizione dalla quale è possibile raggiungere una posizione fredda con un solo movimento è una posizione calda.

3) Se ogni mossa porta a una posizione calda, allora una posizione è fredda.

Ad esempio, tutte le posizioni della forma (0, m) e (m, m) con m > 0 sono calde, per la regola 2.
Tuttavia, la posizione (1,2) è fredda, perché le uniche posizioni che possono essere raggiunte da essa, (0,1), (0,2), (1,0) e (1,1), sono tutti calde. Le posizioni fredde (n, m) con i valori più piccoli di ne m sono (0, 0), (1, 2), (3, 5), (4, 7), (6, 10) e (8, 13).

Wythoff ha scoperto che le posizioni fredde seguono uno schema regolare determinato dal rapporto aureo φ (sezione aurea). In particolare:

se k è un numero naturale e

n(k) = floor(k*φ) = floor(m(k)*φ) - n(k)
m(k) = floor(k*φ²) = floor(n(k)*φ) = n(k) + k

dove φ è il rapporto aureo, allora (nk, mk) è la k-esima posizione fredda.

Ricordiamo che il rapporto aureo vale:

φ = (sqrt(5) + 1)/2 = 1.618033988749895

Proviamo a scrivere due funzioni che calcolano queste sequenze:

n(k)=floor(k*(sqrt(5)+1)/2)

In altre parole, la sequenza n(k) è formata da numeri che sono multipli del rapporto aureo arrotondati all'intero minore.

m(k)=floor(k*(sqrt(5)+3)/2)

In altre parole, la sequenza m(k) è formata dai numeri dei corrispondenti n(k) sommati al valore di k.

Vediamo una tabella con i valori:

|--------------|-----|-------|-------|-------|--------|--------|--------|--------|--------|
|      k       |  0  | 1     | 2     | 3     | 4      | 5      | 6      |  7     |  8     |
|--------------|-----|-------|-------|-------|--------|--------|--------|--------|--------|
|     k*φ      |  0  | 1.618 | 3.236 | 4.854 | 6.472  | 8.090  | 9.708  | 11.326 | 12.944 |
|--------------|-----|-------|-------|-------|--------|--------|--------|--------|--------|
| (floor k*φ)  |  0  | 1     | 3     | 4     | 6      | 8      | 9      | 11     | 12     |
|--------------|-----|-------|-------|-------|--------|--------|--------|--------|--------|
|     k*φ²     |  0  | 2.618 | 5.236 | 7.854 | 10.472 | 13.090 | 15.708 | 18.326 | 20.944 |
|--------------|-----|-------|-------|-------|--------|--------|--------|--------|--------|
| (floor k*φ²) |  0 -| 2     | 5     | 7     | 10     | 13     | 15     | 18     | 20     |
|--------------|-----|-------|-------|-------|--------|--------|--------|--------|--------|

(define (nk k) (floor (mul k (div (add (sqrt 5) 1) 2))))
(define (mk k) (floor (mul k (div (add (sqrt 5) 3) 2))))

(define (fredde k)
  (let (out '())
    (for (i 1 k)
      (push (list (nk i) (mk i)) out -1))
    out))

(fredde 10)
;-> ((1 2) (3 5) (4 7) (6 10) (8 13) (9 15) (11 18) (12 20) (14 23) (16 26))

Vediamo dove si trovano queste posizioni nel caso della regina nella scacchiera:

▄ = posizioni fredde

   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
15 |   |   |   |   |   |   |   |   |   | ▄ |   |   |   |   |   |   |
   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
14 |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
13 |   |   |   |   |   |   |   |   | ▄ |   |   |   |   |   |   |   |
   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
12 |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
11 |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
10 |   |   |   |   |   |   | ▄ |   |   |   |   |   |   |   |   |   |
   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 9 |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   | ▄ |
   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 8 |   |   |   |   |   |   |   |   |   |   |   |   |   | ▄ |   |   |
   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 7 |   |   |   |   | ▄ |   |   |   |   |   |   |   |   |   |   |   |
   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 6 |   |   |   |   |   |   |   |   |   |   | ▄ |   |   |   |   |   |
   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 5 |   |   |   | ▄ |   |   |   |   |   |   |   |   |   |   |   |   |
   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 4 |   |   |   |   |   |   |   | ▄ |   |   |   |   |   |   |   |   |
   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 3 |   |   |   |   |   | ▄ |   |   |   |   |   |   |   |   |   |   |
   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 2 |   | ▄ |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 1 |   |   | ▄ |   |   |   |   |   |   |   |   |   |   |   |   |   |
   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 0 | ▄ |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
     0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15


--------------------
Ordinamento per rime
--------------------

L'ordinamento per rime (rhyming sort) consiste nell'ordinare una lista di parole in base alla rima. Si tratta semplicemente di ordinare le parole da destra a sinistra.

(define (rimesort lst)
  (map reverse (sort (map reverse lst))))

(rimesort '("sasso" "masso" "gradasso" "spasso" "grasso"))
;-> ("gradasso" "masso" "spasso" "grasso" "sasso")


---------------
Lista circolare
---------------

Implementiamo una struttura dati che si comporta come una lista circolare.

; creiamo un contesto per la struttura
(context 'circ-list)
; inizializzazione della lista circolare
(define (circ-list:init lst)
  (let (n (length lst))
    (setq
          circ-list:items (array n lst)
          circ-list:i 0
          circ-list:end n)))
; valore elemento corrente della lista circolare (con avanzamento)
(define (circ-list:next)
  (cond ((= circ-list:i circ-list:end)
          (setq circ-list:i 0)
          (++ circ-list:i)
          (circ-list:items (- circ-list:i 1)))
        (true
          (++ circ-list:i)
          (circ-list:items (- circ-list:i 1)))))
; valore elemento corrente della lista circolare (senza avanzamento)
(define (circ-list:cur) (circ-list:items (- circ-list:i 1)))
; indice del prossimo elemento della lista circolare
(define (circ-list:index) circ-list:i)
; lunghezza della lista circolare
(define (circ-list:len) circ-list:end)
;valore della lista circolare
(define (circ-list:values) circ-list:items)
; ritorniamo al contesto principale
(context MAIN)

proviamo la nostra struttura:

(circ-list:init (sequence 1 3))
;-> 3 ; numero di elementi della lista
(circ-list:next)
;-> 1
(circ-list:next)
;-> 2
(circ-list:next)
;-> 3
(circ-list:next)
;-> 1
(circ-list:next)
;-> 2
(circ-list:cur)
;-> 2 ;valore attuale
(circ-list:index)
;-> 2 ;indice del prossimo numero
(circ-list:len)
;-> 3 ;lunghezza della lista
(circ-list:values)
;-> (1 2 3) ; valori della lista


------------------------
Circuito automobilistico
------------------------

Unaa pista automobilistica è costituita da un circuito stradale chiuso (es. un cerchio).
Una quantità di benzina (sufficiente per completare il giro del circuito) viene suddivisa in n quantità diverse che vengono piazzate in modo casuale in n punti lungo la pista.
Determinare, se esiste, da quale punto occorre partire per poter terminare il giro del circuito (in una direzione o nell'altra).

Definiamo le variabili:

Benzina:  b(1), b(2), ..., b(n)
Punti:    P(1), P(2), ..., P(n)
Muove:    m(1), m(2), ..., m(n)

dove b(i) è la quantità di benzina diponibile nel punto P(i)
e m(i) è la benzina necessaria per passare da P(i) a P(i+1)
e m(n) è la benzina necessaria per passare da P(n) a P(1)

Poniamo:

 x(i) = b(i) - m(i)
 s(i) = x(1) + x(2) + ... + x(i)
 (da notare che s(n) = 0)

 Dall'insieme di numeri di s, scegliamo un indice r tale che s(r) <= s(i) per ogni valore di i.
 Allora, per ogni i risulta:

 x(r+1)                       = s(r+1) - s(r) >= 0
 x(r+1) + x(r+2)              = s(r+2) - s(r) >= 0
 ...
 x(r+1) + x(r+2) + ... + x(i) = s(i) - s(r) >= 0

 Quindi partendo dalla posizione (r + 1) abbiamo:

 b(r+1) >= m(r+1),
 b(r+1) + b(r+2) >= m(r+1) + m(r+2),
 ...
 e la macchina ha sempre abbastanza benzina per raggiungere il punto successivo e terminare il circuito.

 Esempio:

  (2)          5          (1)         5           (5)  1  (4)  1  (3)     3      (2)
   x-----------------------x-----------------------x-------x-------x--------------x
  P1                      P2                      P3      P4      P5             P1

Totale benzina: 15
; benzina al punto (i)
(setq b '(2 1 5 4 3))
; benzina per passare dal punto i al punto i+1
(setq m '(5 5 1 1 3))
; lista delle differenze
(setq x (map - b m))
;-> (-3 -4 4 3 0)
; lista delle somme progressive delle differenze
(setq s '())
(for (i 1 (- (length x) 1))
  (push (apply + (slice x 0 i)) s -1))
;-> (-3 -7 -3 0)
; cerchiamo il valore minimo:
(apply min s)
;-> 7

Nella lista s il numero -7 è minore di tutti gli altri e ha indice 3 (nel circuito), quindi dovremo partire dal punto successivo del circuito, cioè dal punto P4.


----------------------------------------
Il problema delle studentesse di Kirkman
----------------------------------------

"8 queens is to Kirkman as amateur is to professional" — Phil Dorin

Il problema delle studentesse di Kirkman è un problema di calcolo combinatorio proposto dal reverendo Thomas Kirkman nel 1850 che lo formulò nel modo seguente:

Quindici ragazze in una scuola escono in fila per tre (fianco a fianco) per sette giorni consecutivi: come è possibile disporle quotidianamente in modo che nessuna possa camminare due volte insieme (nella stessa fila)?

Ecco una soluzione con le ragazze (A,B,C,D,E,F,G,H,I,J,K,L,K,M,N,O):

Sun	Mon	Tue	Wed	Thu	Fri	Sat
--- --- --- --- --- --- ---
ABC ADG AEJ AFO AHK AIM ALN
DEF BEH BFL BDM BGN BKO BIJ
GHI CJM CHO CGL CFI CEN CDK
JKL FKN DIN EIK DJO DHL EGO
MNO ILO GKM	HJN	ELM	FGJ	FHM

Per risolvere questo problema non è possibile generare tutti gli arrangiamenti possibili e poi controllarli, uno per uno, per vedere se soddisfa i vincoli del problema.
Ci sono 15! modi in cui le ragazze possono essere disposte in un giorno e ci sono (15!)^7 modi per scegliere le sette disposizioni giornaliere.

(define (fact-i num)
  (let (out 1L)
    (for (x 1L num)
      (setq out (* out x)))))

(define (** num power)
    (let (out 1L)
        (dotimes (i power)
            (setq out (* out num)))))

(** (fact-i 15) 7)
;-> 6538788315119179526047380411895480779825576
;-> 867866060412873080832000000000000000000000L

Un numero di casi impossibile da analizzare...

Il problema può essere risolto tramite la costruzione di un "Kirkman triple system" di ordine n=2 o con altri metodi ai matematica avanzata (almeno per me). In questo caso vediamo un metodo risolutivo analitico/grafico sviluppato dal Prof. Dr. Reinhard Laue:

http://www.algorithm.uni-bayreuth.de/en/research/discreta/EXAMPLES/kirkman.html

Nota: per capire il metodo di soluzione vedere l'animazione "kirkman.gif" nella cartella "data".

Il diagramma mostra le 15 ragazze disposte in cerchi concentrici (1 7 7), ma raggruppate in 5 file di 3 tramite una linea di collegamento. La disposizione delle ragazze per il giorno successivo viene trovata "ruotando" le linee di collegamento in senso antiorario.

Dal punto di vista algoritmico possiamo trovare questa soluzione con la seguente funzione (in cui le ragazze sono rappresentate con numeri da 0 a 14):

(define (ruota x)
  (cond ((zero? x) 0)
        ((= x 14) 8)
        ((= x 7) 1)
        (true (+ x 1))))

(define (kirkman)
  (setq s '(0 1 8 2 6 14 3 4 13 5 7 11 9 10 12))
  (for (i 1 7)
    (setq s (map ruota s))
    (println s)))

(kirkman)
;-> (0 2 9 3 7 8 4 5 14 6 1 12 10 11 13)
;-> (0 3 10 4 1 9 5 6 8 7 2 13 11 12 14)
;-> (0 4 11 5 2 10 6 7 9 1 3 14 12 13 8)
;-> (0 5 12 6 3 11 7 1 10 2 4 8 13 14 9)
;-> (0 6 13 7 4 12 1 2 11 3 5 9 14 8 10)
;-> (0 7 14 1 5 13 2 3 12 4 6 10 8 9 11)
;-> (0 1 8 2 6 14 3 4 13 5 7 11 9 10 12)
;-> (0 1 8 2 6 14 3 4 13 5 7 11 9 10 12)

Esistono 7 soluzioni differenti per questo problema e Kirkman le ha trovato tutte nel 1850:

Soluzione 1
[ A B C , D E F , G H I , J K L , M N O ]
[ A D G , B E J , C F M , H K N , I L O ]
[ A E N , B D O , C H L , F I K , G J M ]
[ A I M , B G L , C D K , E H O , F J N ]
[ A H J , B K M , C E I , D L N , F G O ]
[ A F L , B I N , C J O , D H M , E G K ]
[ A K O , B F H , C G N , D I J , E L M ]

Soluzione 2
[ A B C , D E F , G H I , J K L , M N O ]
[ A D G , B E J , C F M , H K N , I L O ]
[ A E N , B D O , C H L , F I K , G J M ]
[ A L M , B G K , C D I , E H O , F J N ]
[ A I J , B H M , C E K , D L N , F G O ]
[ A F H , B I N , C J O , D K M , E G L ]
[ A K O , B F L , C G N , D H J , E I M ]

Soluzione 3
[ A B C , D E F , G H I , J K L , M N O ]
[ A D G , B E J , C F M , H K N , I L O ]
[ A E N , B D O , C H L , F I K , G J M ]
[ A H M , B I N , C D K , E G L , F J O ]
[ A K O , B L M , C E I , D H J , F G N ]
[ A F L , B G K , C J N , D I M , E H O ]
[ A I J , B F H , C G O , D L N , E K M ]

Soluzione 4
[ A B C , D E F , G H I , J K L , M N O ]
[ A D G , B E J , C F M , H K N , I L O ]
[ A E N , B D O , C H L , F I K , G J M ]
[ A I J , B L M , C D K , E H O , F G N ]
[ A H M , B G K , C E I , D L N , F J O ]
[ A F L , B I N , C G O , D H J , E K M ]
[ A K O , B F H , C J N , D I M , E G L ]

Soluzione 5
[ A B C , D E F , G H I , J K L , M N O ]
[ A D G , B E J , C F M , H K N , I L O ]
[ A E O , B D N , C H L , F I K , G J M ]
[ A I N , B G L , C D K , E H M , F J O ]
[ A H J , B K O , C E I , D L M , F G N ]
[ A F L , B I M , C J N , D H O , E G K ]
[ A K M , B F H , C G O , D I J , E L N ]

Soluzione 6
[ A B C , D E F , G H I , J K L , M N O ]
[ A D G , B E J , C F M , H K N , I L O ]
[ A E O , B D N , C H L , F I K , G J M ]
[ A L N , B G K , C D I , E H M , F J O ]
[ A I J , B H O , C E K , D L M , F G N ]
[ A F H , B I M , C J N , D K O , E G L ]
[ A K M , B F L , C G O , D H J , E I N ]

Soluzione 7
[ A B C , D E F , G H I , J K L , M N O ]
[ A D G , B E J , C H M , F K N , I L O ]
[ A E L , B D N , C G K , F I M , H J O ]
[ A F O , B L M , C D I , E H K , G J N ]
[ A H N , B I K , C E O , D J M , F G L ]
[ A I J , B F H , C L N , D K O , E G M ]
[ A K M , B G O , C F J , D H L , E I N ]


-------------------------------
Contadino, lupo, capra e cavoli
-------------------------------

Il problema del lupo della capra e dei cavoli fa parte di una classe di problemi in cui occorre attraversare un fiume secondo alcuni vincoli. Questo problema ha dato origine al modo di dire "salvare capra e cavoli" con cui si intende risolvere in maniera ottimale una situazione con interessi contrastanti.
Il quesito è il seguente:
Un contadino deve attraversare un fiume con un lupo, una pecora e dei cavoli. La barca può trasportare (oltre a lui) soltanto uno tra il lupo, la capra e i cavoli. Non è possibile lasciare da soli il lupo e la capra (il lupo mangerebbe la capra) o la capra e i cavoli (la capra mangerebbe i cavoli). Quindi come trasportare tutti sull'altra riva del fiume evitando di perdere la capra o i cavoli ("salvare capra e cavoli")?

Nel libro "Cabinet of Mathematical Curiosities" di Ian Stewart viene mostrata una rappresentazione geometrica dello spazio degli stati del problema che rende semplice la ricerca della soluzione (vedi figura "clcc.png" nella cartella "data").

Stato iniziale              Stato finale
Lupo   0                    Lupo   1
Capra  0                    Capra  1
Cavoli 0                    Cavoli 1

Esempio di transizione: (0,0,0) -> (1,0,0)

Lista stati:

(0,0,0)
(0,0,1)
(0,1,0)
(0,1,1)
(1,0,0)
(1,0,1)
(1,1,0)
(1,1,1)

Stati non validi:

(0,1,1) capra e cavoli
(1,1,0) lupo e capra

Lo stato iniziale nello spazio 3D della terna lupo-capra-cavolo (lupo, capra, cavoli) vale (0,0,0). Lo 0 rappresenta la riva di partenza del fiume e 1 rappresenta la riva di destinazione. L'obiettivo è arrivare quindi allo stato (1,1,1). Nello spazio (lupo, capra, cavoli), la direzione x rappresenta i movimenti del lupo, la direzione y quelli della capra e z quelli del cavolo. Pertanto le 8 possibili combinazioni di terne (stati del sistema) sono rappresentate dagli 8 vertici del cubo.

Adesso possiamo eliminare i seguenti 4 percorsi:

1) da (0,0,0) a (1,0,0) poiché lascia la capra con i cavoli

2) da (0,0,0) a (0,0,1) poiché lascia il lupo con la capra

3) da (0,1,1) a (1,1,1) poiché lascia capra con i cavoli

4) da (1,1,0) a (1,1,1) poiché lascia il lupo con la capra

A questo punto è sufficiente viaggiare lungo i percorsi rimanenti e le 2 soluzioni sono immediatamente evidenti, per esempio: (0,0,0) - (0,1,0) - (1,1,0) - (1,0,0) - (1,0,1) - (1,1,1).

Dal punto di vista computazionale per la soluzione seguiremo l'algoritmo presentato nel libro "Artificial Intelligence: Structures and strategies for complex problem solving" di Luger e Stubblefield che verrà implementato in newLISP.

farmer = contadino
wolf = lupo
goat = capra
cabbage = cavoli

L'algoritmo ricorsivo ricerca lo spazio degli stati in modo depth-first usando una lista "been-list" per tenere traccia degli stati visitati evitando i possibili cicli infiniti. Definiamo lo spazio degli stati come tipo di dati astratto utilizzando alcune funzioni. Uno stato viene rappresentato come una lista di quattro elementi i cui valori indicano la posizione del contadino (farmer), del lupo (wolf), della capra (goat) e dei cavoli (cabbage): ad esempio (e w e w) significa che il primo elemento (contadino) si trova a est, il secondo elemento (lupo) si trova a ovest (west), il terzo elemento (capra) si trova ad est e l'ultimo elemento (cavoli) si trova a ovest.
Per costruire uno stato usiamo la funzione "make-state" (state-constructor) che prende come argomento la posizione dei quattro elementi e restituisce uno stato. Per accedere alla posizione di un elemento usiamo quattro funzioni "farmer-side", "wolf-side", "goat-side" e "cabbage-side" che prendono in ingresso uno stato e restituiscono la posizione dell'elemento.

(define make-state (f w g c) (list fwgc))
(define (farmer-side state) (state 0))
(define (wolf-side state) (state 1))
(define (goat-side state) (state 2))
(define (cabbage-side state) (state 3))

Queste funzioni vengono usate per implementare le quattro azioni di spostamento che possono essere effettuate:
attraversare il fiume da solo o con il lupo o con la capra o con il cavolo.
Ogni azione utilizza le funzioni di accesso per dividere uno stato nei suoi componenti. Una funzione chiamata "opposite" determina la nuova posizione degli elementi che attraversano il fiume e poi la funzione "make-state" riunisce il tutto in un nuovo stato. Durante queste azioni dobbiamo assicurarci che gli stati che raggiungiamo/visitiamo siano sicuri e li controlliamo con la funzione "safe" prima di applicare ogni azione di movimento degli elementi:

(safe '(w w w w)) ; stato sicuro -> stato
;-> (w w w w)
(safe '(e w w e)) ; il lupo mangia la capra -> stato non sicuro -> nil
;-> nil
(safe '(w w e e)) ; la capra mangia il cavolo -> stato non sicuro -> nil
;-> nil

Pertanto, qualsiasi azione che sposta in uno stato non sicuro restituirà nil invece di quello stato. L'algoritmo ricorsivo depth-first verifica questo risultato (nil) e lo utilizza per eliminare lo stato dalla soluzione.
In questo modo la funzione di azione/spostamento del contadino "farmer-take-self" viene così definita:

(define (farmer-takes-self state)
   (safe (make-state (opposite (farmer-side state))
                     (wolf-side state)
                     (goat-side state)
                     (cabbage-side state))))

Le restanti funzioni di spostamento sono definite in modo simile, ma includono un test condizionale per determinare se il contadino e il potenziale passeggero si trovano dalla stessa parte del fiume. Se non è possibile effettuare uno spostamento perché il contadino e il passeggero non sono sulla stessa riva, allora queste funzioni restituiscono nil:

(define (farmer-takes-wolf state)
   (cond ((= (farmer-side state) (wolf-side state))
             (safe (make-state (opposite (farmer-side state))
                               (opposite (wolf-side state))
                               (goat-side state)
                               (cabbage-side state))))
         (true nil)))

(define (farmer-takes-goat state)
   (cond ((= (farmer-side state) (goat-side state))
             (safe (make-state (opposite (farmer-side state))
                               (wolf-side state)
                               (opposite (goat-side state))
                               (cabbage-side state))))
         (true nil)))

(define (farmer-takes-cabbage state)
   (cond ((= (farmer-side state) (cabbage-side state))
             (safe (make-state (opposite (farmer-side state))
                               (wolf-side state)
                               (goat-side state)
                               (opposite (cabbage-side state)))))
     (true nil)))

Queste definizioni utilizzano le funzioni di creazione e gestione dello stato viste sopra e una funzione "opposite" che restituisce l'opposto di un dato lato:

(define (opposite side)
   (cond ((= side 'e) 'w)
             ((= side 'w) 'e)))

Per quanto riguarda la funzione "safe" dobbiamo controllare i seguenti due stati non sicuri:
1) il contadino si trova sulla riva opposta rispetto al lupo e alla capra
2) il contadino si trova sulla riva opposta rispetto alla capra e i cavoli
Se lo stato è sicuro, viene restituito invariato, altrimenti viene restituito nil.

(define (safe state)
   (cond ((and (= (goat-side state) (wolf-side state))
               (not (= (farmer-side state) (wolf-side state))))  nil)
         ((and (= (goat-side state) (cabbage-side state))
               (not (= (farmer-side state) (goat-side state)))) nil)
         (true state)))

La funzione "path" implementa la ricerca ricorsiva depth-first con backtracking nello spazio degli stati. Questa funzione prende tre argomenti (uno stato, un goal e una lista di stati visitati) e effettua le seguenti operazioni:
a) controlla se lo stato vale nil (questo implica che path deve restituire nil)
b) controlla se state = goal, questo significa che abbiamo ottenuto la soluzione
c) controlla se lo stato si trova nella lista degli stati visitati e, in caso negativo, genera i quattro stati successivi e poi chiama se stessa ricorsivamente su ognuno di questi quattro stati per cercare un percorso verso la soluzione (goal).

(define (path state goal been-list)
   (cond ((null? state) nil)
         ((= state goal)
          (reverse (cons state been-list)))
         ((not (member state been-list))
          (or (path (farmer-takes-self state) goal (cons state been-list))
              (path (farmer-takes-wolf state) goal (cons state been-list))
              (path (farmer-takes-goat state) goal (cons state been-list))
              (path (farmer-takes-cabbage state) goal (cons state been-list))))))

Nota: la funzione "or" valuta i suoi argomenti a turno finché uno di essi non restituisce un valore diverso da nil. Quando
ciò si verifica, "or" termina senza valutare gli altri argomenti e restituisce questo valore non-nil come risultato. Pertanto, "or" non solo viene utilizzato come operatore logico, ma fornisce anche un modo per controllare le ramificazioni all'interno dello spazio di ricerca. Usiamo "or" al posto di "cond" perché il valore che viene testato e il valore che deve essere restituito, se il test è diverso da nil, sono gli stessi.

Ogni volta che la funzione "path" si richiama ricorsivamente per generare un nuovo stato, viene aggiunto lo stato genitore nella lista degli stati visitati "been-list". Per assicurarsi che lo stato corrente non sia un elemento della lista "been-list" (cioè che non sia già stato visitato) utilizziamo la funzione primitiva "member". Ciò si ottiene controllando lo stato corrente per l'appartenenza alla "been-list" prima di generare i suoi discendenti.

Nota: Piuttosto che fare in modo che una funzione restituisca solo il successo o il fallimento della condizione, è meglio restiture il percorso effettivo della soluzione. Perché la serie di stati del percorso della soluzione è già
contenuta nella lista "been-list", viene usata la funzione "member" che restituisce questa lista.

Quando lo stato corrente è uguale al goal, allora dobbiamo aggiungere questo stato alla lista "been-list" e poi invertire la lista che è stata costruita in ordine inverso.

Infine possiamo scrivere la funzione "solve-fwgc" che inizia la ricerca e che può essere chiamata, ad esempio, nel modo seguente:

 (solve-fwgc '(e e e e) '(w w w w))

per cercare un percorso di soluzione da est a ovest (west).

Mettendo tutto insieme:

; Funzione soluzione
(define (solve-fwgc state goal)
    (path state goal '()))
; Algoritmo ricorsivo di ricerca depth-first
(define (path state goal been-list)
   (cond ((null? state) nil)
         ((= state goal)
          (reverse (cons state been-list)))
         ((not (member state been-list))
          (or (path (farmer-takes-self state) goal (cons state been-list))
              (path (farmer-takes-wolf state) goal (cons state been-list))
              (path (farmer-takes-goat state) goal (cons state been-list))
              (path (farmer-takes-cabbage state) goal (cons state been-list))))))
; Queste funzioni definiscono le mosse legali nello spazio degli stati.
; Prendono come argomento uno stato e restituisono lo stato prodotto da quell'operazione.
(define (farmer-takes-self state)
   (safe (make-state (opposite (farmer-side state))
                     (wolf-side state)
                     (goat-side state)
                     (cabbage-side state))))
(define (farmer-takes-wolf state)
   (cond ((= (farmer-side state) (wolf-side state))
             (safe (make-state (opposite (farmer-side state))
                               (opposite (wolf-side state))
                               (goat-side state)
                               (cabbage-side state))))
         (true nil)))
(define (farmer-takes-goat state)
   (cond ((= (farmer-side state) (goat-side state))
             (safe (make-state (opposite (farmer-side state))
                               (wolf-side state)
                               (opposite (goat-side state))
                               (cabbage-side state))))
         (true nil)))
(define (farmer-takes-cabbage state)
   (cond ((= (farmer-side state) (cabbage-side state))
             (safe (make-state (opposite (farmer-side state))
                               (wolf-side state)
                               (goat-side state)
                               (opposite (cabbage-side state)))))
     (true nil)))
; Queste funzioni definiscono lo spazio degli stati
; come un tipo di dati astratto.
(define (make-state f w g c) (list f w g c))
(define (farmer-side state) (state 0))
(define (wolf-side state) (state 1))
(define (goat-side state) (state 2))
(define (cabbage-side state) (state 3))
; La funzione "opposite" prende un lato e
; restituisce il lato opposto
(define (opposite side)
   (cond ((= side 'e) 'w)
             ((= side 'w) 'e)))
; La funzione "safe" restituisce nil se uno stato non è sicuro
; oppure restituisce lo stato invariato se è sicuro.
(define (safe state)
   (cond ((and (= (goat-side state) (wolf-side state))
               (not (= (farmer-side state) (wolf-side state))))  nil)
         ((and (= (goat-side state) (cabbage-side state))
               (not (= (farmer-side state) (goat-side state)))) nil)
         (true state)))

Proviamo la funzione soluzione in entrambi i sensi (est -> ovest e ovest -> est):

(solve-fwgc '(e e e e) '(w w w w))
;-> ((e e e e) (w e w e) (e e w e) (w w w e) (e w e e) (w w e w) (e w e w) (w w w w))

(solve-fwgc '(w w w w) '(e e e e))
;-> ((w w w w) (e w e w) (w w e w) (e e e w) (w e w w) (e e w e) (w e w e) (e e e e))

Oppure:

(define (cross-the-river)
  (let ((start (make-state 'e 'e 'e 'e))
        (goal (make-state 'w 'w 'w 'w)))
       (path start goal '())))

(cross-the-river)
;-> ((e e e e) (w e w e) (e e w e) (w w w e) (e w e e) (w w e w) (e w e w) (w w w w))


--------------------------------
Ancora la congettura di Goldbach
--------------------------------

La congettura di Goldbach è uno dei più vecchi problemi irrisolti nella teoria dei numeri. Essa afferma che ogni numero pari maggiore di 2 può essere scritto come somma di due numeri primi (che possono essere anche uguali).

Per esempio:

  4 = 2 + 2
  6 = 3 + 3
  8 = 3 + 5
 10 = 3 + 7 = 5 + 5
 12 = 5 + 7
 14 = 3 + 11 = 7 + 7

Nel 1742, il matematico prussiano Christian Goldbach scrisse una lettera a Eulero in cui propose la seguente congettura:

  "Ogni numero intero maggiore di 5 può essere scritto come somma di tre numeri primi."

Eulero, interessandosi al problema, rispose riformulando il problema nella seguente versione equivalente:

  "Ogni numero pari maggiore di 2 può essere scritto come somma di due numeri primi."

La versione di Eulero è la forma nella quale la congettura è formulata attualmente e viene talvolta chiamata anche col nome di congettura forte di Goldbach. La congettura debole di Goldbach, che è implicata dalla congettura forte, asserisce che tutti i numeri dispari maggiori di 7 possono essere scritti come somma di tre primi.

1) Programma per la verifica della congettura forte di Goldbach
   "Ogni numero pari maggiore di 2 può essere scritto come somma di due numeri primi."

(define (primes-to num)
  (cond ((= num 1) '())
        ((= num 2) '(2))
        (true
         (let (lst '(2))
          (setq arr (array (+ num 1)))
          (for (x 3 num 2)
                (when (not (arr x))
                  (push x lst -1)
                  (for (y (* x x) num (* 2 x) (> y num))
                      (setf (arr y) true)))) lst))))

(define (goldbach num)
  (local (primi i diff)
    (cond ((even? num)
           (setq primi (primes-to num))
           ; controlliamo solo fino alla metà di num
           (setq i 0)
           (while (<= (primi i) (/ num 2))
             ; calcoliamo la differenza tra
             ; il numero primo corrente e num
             (setq diff (- num (primi i)))
             ; cerchiamo se la differenza (diff)
             ; è un numero primo
             (if (find diff primi)
                 ; stampa il risultato
                 (println (primi i) " + " diff " = " num)
             )
             (++ i)
           )))))

(goldbach 10)
;-> 3 + 7 = 10
;-> 5 + 5 = 10

(goldbach 14)
;-> 3 + 11 = 14
;-> 7 + 7 = 14

(goldbach 100)
;->  3 + 97 = 100
;-> 11 + 89 = 100
;-> 17 + 83 = 100
;-> 29 + 71 = 100
;-> 41 + 59 = 100
;-> 47 + 53 = 100

2) Programma per la verifica della congettura debole di Goldbach
   "Tutti i numeri dispari maggiori di 7 possono essere scritti come somma di tre primi."

(define (prime? num)
   (if (< num 2) nil
       (= 1 (length (factor num)))))

(define (goldbach-weak num)
  (for (j 2 (- num 3))
    (if (prime? j)
        (for (k j (- num j 1))
          (if (prime? (- num j k))
              (if (and (prime? k) (= num (+ num (- j) k)))
                  (println j " " k " " (- num j k))))))))

(goldbach-weak 7)
;-> 2 2 3

(goldbach-weak 9)
;-> 2 2 5
;-> 3 3 3

(goldbach-weak 101)
;-> 2 2 97
;-> 11 11 79
;-> 17 17 67
;-> 29 29 43
;-> 41 41 19
;-> 47 47 7

Infine vediamo l'algoritmo proposto nel libro "Algorithms" 4 Edizione di Robert Sedgewick e Kevin Wayne che cerca di trovare la somma di due primi anche per i numeri dispari:

(define (goldbach-all num)
  (local (isprime conta lista fattore j)
    (setq isprime (array num '(true)))
    (setf (isprime 0) nil)
    (setf (isprime 1) nil)
    ; Eratostene
    (setq fattore 2)
    (while (< (* fattore fattore) num)
      (if (isprime fattore) (begin
          (setq j fattore)
          (while (< (* fattore j) num)
            (setf (isprime (* fattore j)) nil)
            (++ j)
          ))
      )
      (++ fattore)
    )
    ; conta i numeri primi
    (setq conta 0)
    (for (i 2 (- num 1))
      (if (isprime i) (++ conta))
    )
    ; mette i primi in una lista
    (setq lista (array conta '(0)))
    (setq idx 0)
    (for (i 0 (- num 1))
      (if (isprime i) (begin
          (setf (lista idx) i)
          (++ idx))
      )
    )
    ; controlla se num può essere espresso
    ; come somma di due primi
    (setq sx 0)
    (setq dx (- idx 1))
    (setq continua true)
    (while (and (<= sx dx) continua)
      (cond ((= (+ (lista sx) (lista dx)) num)
             (setq continua nil))
            ((< (+ (lista sx) (lista dx)) num)
             (++ sx))
            (true (-- dx))
      )
    )
    ; stampa il risultato
    (if (= (+ (lista sx) (lista dx)) num)
        (println (lista sx) " + " (lista dx) " = " num)
        (println num " non è esprimibile come somma di due primi.")
    )))

(goldbach-all 10003292)
;-> 349 + 10002943 = 10003292

(goldbach-all 10000001)
;-> 10000001 non è esprimibile come somma di due primi.

(goldbach-all 10000021)
;-> 2 + 10000019 = 10000021


----------------------
Triangolo di Steinhaus
----------------------

Questo è un problema tratto dal libro di Hugo Steinhaus "Cento problemi di matematica elementare", Boringhieri, 1987.
Cominciamo scrivendo una lista di N segni "+" e "-".
La quantità e la disposizione dei segni "+" e "-" è a piacere.
Per esempio:

+ + - + - + +

Continuiamo scrivendo altre linee rispettivamente di N-1, N-2, ..., 1 di segni "+" e "-" con le seguenti regole:
1) sotto una coppia di segni uguali scrivete un "+"
2) sotto una coppia di segni diversi scrivete un "-"

Le coppie sono formate dal primo e dal secondo elemento, dal secondo e dal terzo elemento, dal terzo e dal quarto elemento, ..., fino all'ultima coppia formata dal penultimo e dall'ultimo elemento.

Ecco come viene compilato il nostro esempio (N=7):

+ + - + - + +
+ - - - - +
- + + + -
- + + -
- + -
- -
+

Se contiamo quanti sono i "+" e i "-" scopriamo che ci sono esattamente 14 "+" e 14 "-".

Il problema è quello di decidere per quali valori di N esistono dei triangoli con un uguale numero di "+" e di "-".

Definiamo alcuni termini:

"Ordine del triangolo": il numero iniziale N di segni

"Triangolo bilanciato": un triangolo con tanti "+" quanti "-"

Inoltre, è evidente che il numero totale di segni "+" e "-" in un triangolo di Steinhaus è un numero triangolare. Partendo con N segni tale numero vale T = (N*(N - 1))/2. Pertanto, affinché si possano costruire triangoli bilanciati, il numero T deve essere divisibile per 2, cioè deve essere pari e ciò è possibile solo se: N è divisibile per 4 oppure (N-1) è divisibile per 4. In tal caso risulta:

a) (N % 4) = 0 e ((N-1) % 4) = 3 (esempio N=8)

oppure

b) ((N-1) % 4) = 0 e (N % 4) = 1 (esempio N=9)

Attenzione: la condizione è necessaria, ma non sufficiente.

Questo significa che se iniziamo con 3, 4, 7, 8, ... segni, possiamo trovare dei triangoli BILANCIATI. Ma potremmo anche non trovarli. Dipende da come abbiamo disposto inizialmente i segni.Però possiamo sempre trovare qualche sistemazione dei segni che produce un triangolo bilanciato.
Se invece iniziamo con 2, 5, 6, 9, 10, ... segni, non troveremo mai un triangolo bilanciato, per quanto cambiamo la sistemazione iniziale dei segni.

Vediamo come implementare alcune funzioni per gestire questo problema.

Funzione che controlla e calcola la parità tra due segni:

(define (parity s1 s2)
  (if (= s1 s2) '+ '-))

Funzione che calcola la prossima riga del triangolo:

(define (next-row row)
  (map parity (chop row) (rest row)))

Funzione che calcola il triangolo di Steinhaus:

(define (steinhaus row)
  (let ((r row) (out (list row)))
    (while (> (length r) 1)
      (setq r (next-row r))
      (push r out -1)
    )
    out))

(steinhaus '(+ + - + - + +))
;-> ((+ + - + - + +) (+ - - - - +) (- + + + -) (- + + -) (- + -) (- -) (+))

+ + - + - + +
+ - - - - +
- + + + -
- + + -
- + -
- -
+

Funzione cha calcola il numero dei segni "+":

(define (number-of-plus triangle)
  (first (count '(+) (flat triangle))))

Funzione che calcola il numero dei segni "-":

(define (number-of-minus triangle)
  (first (count '(-) (flat triangle))))

Funzione che calcola la parità in un triangolo di Steinhaus (restituisce la differenza tra il numero di segni "+"e il numero di segni "-"):

(define (parity-triangle triangle)
  (- (number-of-plus triangle) (number-of-minus triangle)))

Funzione che verifica se un triangolo di Steinhaus è bilanciato:

(define (balanced? triangle)
  (zero? (parity-triangle triangle)))

Facciamo un test:

(setq t (steinhaus '(+ + - + - + +)))
;-> ((+ + - + - + +) (+ - - - - +) (- + + + -) (- + + -) (- + -) (- -) (+))
(number-of-plus t)
;-> 14
(number-of-minus t)
;-> 14
(parity-triangle t)
;-> 0
(balanced? t)
;-> true

Funzione che verifica se un triangolo di Steinhaus può essere bilanciato (Se la funzione ritorna nil, allora il triangolo non può mai essere bilanciato. Se la funzione ritorna true, allora il triangolo può essere bilanciato (ma non è detto che lo sia nello stato attuale):

(define (possible-balanced? triangle)
  (let (len (length (triangle 0)))
    (or (= (% len 4) 0) (= (% len 4) 3))))

(possible-balanced? t)
;-> true

Possiamo cercare, se esiste, un triangolo di Stenhaus bilanciato che non rispetta la condizione a) o b).

Funzione che crea una sequanze iniziale casuale di segni "+" e "-":

(define (create-sequence len)
  (let (seq (rand 2 len))
    (setq seq (replace '1 seq '+))
    (setq seq (replace '0 seq '-))))

(create-sequence 10)
;-> (- - + + - + - + + +)

Funzione che effettua un numero definito di test su triangoli casuali:

(define (test-steinhaus min-len max-len num-test)
  (local (seq t)
    (for (i 1 num-test)
      ; crea sequenza casuale iniziale
      (setq seq (create-sequence (+ min-len (rand (+ (- max-len min-len) 1)))))
      ; crea il triangolo di Stenhaus
      (setq t (steinhaus seq))
      ; controlla se è bilanciato, ma la teoria dice che non potrebbe esserlo
      (if (and (balanced? t) (not (possible-balanced? t)))
          (println t)))))

Proviamo a fare un test (la funzione è molto lenta):

(time (println (test-steinhaus 10 1000 1000)))
nil
;-> 304400.886

Non abbiamo trovato alcun controesempio della regola matematica.

Adesso scriviamo una funzione che, dato un numero N, calcola un triangolo di Steinhaus bilanciato (se esiste).
Utilizziamo una ricerca casuale riscrivendo alcune funzioni per migliorare l'efficienza. Inoltre usiamo i numeri 1 e 0 al posto dei segni "+" e "-".

(define (find-balanced lunghezza iter)
(catch
  (local (seq s len)
    (cond ((or (= (% lunghezza 4) 0) (= (% lunghezza 4) 3))
           (for (i 1 iter)
             (setq len lunghezza)
             (setq seq (rand 2 len))
             (setq s seq)
             (setq t (stein))
             (if (balanced? t) (throw (println s)))
           )
           (println "Triangolo bilanciato non trovato."))
          (true (println "Triangolo bilanciato impossible."))
    ))))

(define (stein)
  (let (out '())
    (setq out (list seq))
      (while (> len 1)
        (setq seq (next))
        (push seq out -1)
        (-- len)
      )
    out))

(define (next)
  (local (out)
    (setq out '())
    (for (i 0 (- len 2))
      (if (= (seq i) (seq (+ i 1)))
          ;(push '+ out -1)
          (push 1 out -1)
          ;(push '- out -1)
          (push 0 out -1)
      )
    )
    out))

(define (balanced? triangle)
  (let (ab (count '(0 1) (flat triangle)))
    (= (first ab) (last ab))))

Proviamo a cercare qualche triangolo di Stenhaus bilanciato:

(find-balanced 12 10000)
;-> (1 1 0 0 0 0 1 0 0 0 1 1)

(find-balanced 20 10000)
;-> (0 0 0 1 0 1 1 0 1 1 0 0 0 0 1 1 1 0 0 0)

(find-balanced 10 10000)
;-> Triangolo bilanciato impossible.

(find-balanced 100 10)
;-> Triangolo bilanciato non trovato.

(find-balanced 100 10000)
;-> (0 0 1 1 0 0 0 0 1 1 1 0 0 0 0 0 1 1 1 1 0 0 1 0 0 1 0 0 1 1 1 0 1
;->  0 1 0 0 0 1 1 0 1 0 0 0 1 1 1 1 0 1 0 0 0 1 1 1 1 1 1 1 1 1 0 1 1 
;->  1 0 1 0 1 0 1 0 0 1 0 1 0 1 1 0 1 1 1 1 0 1 0 0 1 1 1 1 1 1 0 1 1 0)

(time (println (find-balanced 1000 100000)))
;-> (0 0 1 0 0 0 0 1 0 1 0 0 0 1 0 1 1 1 0 0 1 0 1 1 1 1 1 1 0 1 0 1 1 0 0 1 0 1 1 0
;-> ...
;->  1 0 1 1 0 1 1 1 1 1 0 0 1 0 1 1 1 1 1 0 0 0 0 1 1 0 1 1 1 1 1 0 1 0 0 0 0 1 0 1)
;-> 103230.324


---------------
L'ago di Buffon
---------------

Dato un ago di lunghezza L lanciato su un piano con linee parallele a distanza D, qual'è la probabilità che esso intersechi una linea?

-----/--------------------------------
    /                 /   ————
        /            /
-------/------------------------------
 \                      /      \
  \        \   ————    /        \
------------\-------------------------

Si può dimostrare che la probabilità vale:

     2     L
P = --- * ---
     π     D

P = probabilità che l'ago intersechi una parallela
D = distanza tra le linee parallele
L = lunghezza dell'ago

Vediamo come implementare una simulazione del processo.

Come generare segmenti casuali di lunghezza prefissata?

Il problema è analogo a quello di calcolare punti casuali su una circonferenza di un dato raggio (uguale alla lunghezza del segmento) e centro nel punto (xc, yc). Quindi il nostro segmento casuale di lunghezza fissa è dato dal centro della circonferenza (generato in modo casuale) e da un punto casuale sulla circonferenza (questo segmento ha lunghezza pari al raggio della circonferenza).

Se il centro e il raggio sono fissi, l'unica cosa che cambia è l'angolo. Quindi, calcoliamo un angolo casuale tra 0 e 360 gradi (o 0 e 2π radianti) e lo usiamo per ottenere le coordinate x-y usando la conversione in coordinate polari.

x = r * cos (θ)
y = r * sin (θ)

Aggiungiamo le coordinate (xc, yc) del centro come offset e otteniamo le coordinate del punto sulla circonferenza.

π = 3.1415926535897931
2*π = 6.2831853071795862

Funzione che calcola la distanza tra due punti:

(define (dist2d x1 y1 x2 y2)
  (sqrt (add (mul (sub x1 x2) (sub x1 x2))
             (mul (sub y1 y2) (sub y1 y2)))))

Funzione che genera un numero casuale (float) in un intervallo:

(define (rand-range min-val max-val)
  (add min-val (mul (random) (add (sub max-val min-val)))))

(rand-range 10 20)
;-> 15.59190649128697

Funzione che genera un segmento casuale:

(define (rand-segment len xmin xmax ymin ymax)
  (local (x1 y1 x2 y2 angle)
    (setq x1 (rand-range (add len xmin) (sub xmax len)))
    (setq y1 (rand-range (add len ymin) (sub ymax len)))
    (setq angle (mul (random) 6.2831853071795862))
    (setq x2 (add x1 (mul len (cos angle))))
    (setq y2 (add y1 (mul len (sin angle))))
    ; Verifica che la lunghezza del segmento sia len
    ;(println (dist2d x1 y1 x2 y2))
    (list x1 y1 x2 y2)
  ))

(rand-segment 20 50 100 50 100)
;-> (75.6358531449324 71.93304239020966 82.85095640306095 53.27983127323191)

Funzione che verifica l'intersezione tra il segmento e le rette parallele:

(define (intersects pts len dd)
(catch
  (let (base 0)
    (while (<= base (add ymax len))
      (if (and (> (pts 1) base) (< (pts 3) base)) (throw true))
      (if (and (> (pts 3) base) (< (pts 1) base)) (throw true))
      (setq base (add base dd))
    )
    nil)))

Funzione che effettua la simulazione:

(define (simula len dd xmin xmax ymin ymax iter)
  (local (out)
    (for (i 1 iter)
      (if (intersects (rand-segment len xmin xmax ymin ymax) len dd)
          (++ out)))
    (div out iter)))

(simula 20 30 50 100 50 100 10000)
;-> 0.4282

Calcoliamo il valore vero della probabilità:

(define (prob len dd)
  (div (mul 2 len) (mul dd 3.1415926535897931)))

(prob 20 30)
;-> 0.4244131815783876

Proviamo a calcolare π con la formula della probabilità:

     2     L
π = --- * ---
     P     D

(define (pigreco prob len dd)
  (div (mul 2 len) (mul dd prob)))

Proviamo a verificare con il valore esatto (0.4244131815783876):

(pigreco 0.4244131815783876 20 30)
;-> 3.141592653589793

Adesso proviamo a calcolare π con il valore della probabilità generato da una simulazione:

(pigreco (simula 20 30 50 100 50 100 10000) 20 30)
;-> 3.124755878446996

Proviamo con altri valori:

(prob 5 10)
;-> 0.3183098861837907

(pigreco (prob 5 10) 5 10)
;-> 3.141592653589793

(pigreco (simula 5 10 10 100 10 100 1000000) 5 10)
;-> 3.14694997608318


-----------------------------
La scimmia e le noci di cocco
-----------------------------

C'è un mucchio di noci di cocco, di proprietà di cinque uomini. Un uomo divide il mucchio in cinque pile uguali, dando la noce di cocco rimasta a una scimmia che passa e trattiene la sua parte. Il secondo uomo quindi ripete la procedura, divide il mucchio rimanente in cinque, poi regala la noce rimasta ad una scimmia e trattiene la sua parte, così come il terzo, il quarto e il quinto. (Ognuno di loro trova una noce di cocco rimasta quando divide il mucchio per cinque e la regala ad una scimmia). Infine, il gruppo divide le noci di cocco rimanenti in cinque pile uguali: questa volta non sono rimaste noci di cocco.
Quante noci di cocco c'erano nella pila originale?

Sia N la grandezza della pila originale e F il numero di noci di cocco ricevute da ciascun marinaio dopo la divisione finale in 5 parti uguali. Quindi il numero di noci di cocco rimaste prima della divisione finale vale F*5 + 1. Se poniamo questa quantità n, allora il numero rimanente prima della divisione dell'ultimo marinaio vale:

  n' = (n * 5/4) + 1

invertendo la procedura del marinaio. Ma ogni marinaio esegue la stessa procedura, quindi si crea una serie ricorsiva di 5 di tali n (sostituendo n con n' e generando una nuova n'), la quinta e ultima delle quali è lo stesso N, il numero di noci di cocco prima della divisione dal primo marinaio. Sostituendo successivamente n' e n otteniamo:

  N = (((((F*5 + 1)*5/4 + 1)*5/4 + 1)*5/4 + 1)*5/4 + 1)*5/4 + 1

che si riduce alla seguente equazione diofantina:

  1024*N = 15625*F + 11529

Secondo un teorema fondamentale, questa equazione ha una soluzione se e solo se 11529 è un multiplo del più grande divisore comune di 1024 e 15625. 1024 = 4^5 e 15625 = 5^6, quindi il loro MCD è 1 ed essendo 11529 multiplo di 1, allora l'equazione è risolvibile.

L'equazione diofantina è la seguente:

  ax + by = c

dove a, b, c numeri interi relativi e a e b non entrambi nulli.

Nel nostro caso abbiamo:

  1024*N - 15625*F = 11529

Le funzioni seguenti risolvono l'equazione diofantina:

(define (gcdex a b)
  (local (x y lastx lasty temp)
    (setq x 0)
    (setq y 1)
    (setq lastx 1)
    (setq lasty 0)
    (while (not (zero? b))
      (setq q (div a b))
      (setq r (% a b))
      (setq a b)
      (setq b r)
      (setq temp x)
      (setq x (- lastx (* q x)))
      (setq lastx temp)
      (setq temp y)
      (setq y (- lasty (* q y)))
      (setq lasty temp)
    )
    ; Adesso la variabile a contine il valore di gcd
    ;(println a { } b { } x { } y { } lastx { } lasty)
    (list a lastx lasty)))

(define (diofanto a b c)
  (local (gcdex-lst g xg yg out)
    (setq out '())
    (setq gcdex-lst (gcdex a b))
    (setq g (first gcdex-lst))
    (setq xg (first (rest gcdex-lst)))
    (setq yg (last gcdex-lst))
    (println g { } xg { } yg)
    (cond ((not (zero? (% c g))) (setq out '()))
          (true
            (setq out (list (div (mul xg c) g) (div (mul yg c) g)))))
    out))

(diofanto 1024 15625 11529)
;-> -1 4776 313
;-> (-55062504 3608577)

La soluzione di base vale (x0,y0) = (-55062504 -3608577):

(define (eq x y)
  (+ (* 1024 x) (* -15625 y) (- 11529)))

(eq -55062504 -3608577)
;-> 0

Le altre infinite soluzioni sono date dalle seguenti formule:

                b
x(n) = x0 + ----------*n =
             MCD(a,b)

                a
y(n) = y0 - ----------*n =
             MCD(a,b)

Poichè la soluzione di base non è accettabile (perchè ha valori negativi) possaimo calcolare la prima soluzione con termini positivi usando le due equazioni precedenti.

(gcd 1024 -15625)
;-> 1

x(n) = -55062504 + (-15625*n)

y(n) = -3608577 + (1024*n)

(define (calc-y n) (+ -3608577 (* 1024 n)))
(define (calc-x n) (+ -55062504 (* 15625 n)))

Il primo valore per cui le soluzioni sono entrambe positive vale 3525
(calc-y  3525)
;-> 1023

(calc-x 3525)
;-> 15621

Quindi la soluzione vale N = 15621 e F = 1023.

=============================================================================

====================================================

 DOMANDE PROGRAMMATORI (CODING INTERVIEW QUESTIONS)

====================================================

Informatica (definizione formale dell’Association for Computing Machinery - ACM):
è lo studio sistematico degli algoritmi che descrivono e trasformano l’informazione, la loro teoria e analisi, il loro progetto, e la loro efficienza, realizzazione e applicazione.

Molte persone confondono l'informatica con quelle aree professionali che riguardano l'utilizzo dei programmi per l'ufficio (es. Office), la navigazione sul web o il gaming. In realtà, l'informatica vera e propria (che si distingue in teorica e applicata) è lo studio e la progettazione di algoritmi e linguaggi capaci di permettere a un computer di eseguire operazioni in modo automatico. In questo senso l'informatica (Computer Science) richiede notevoli conoscenze e competenze in materie come la matematica, la logica, la linguistica, la psicologia, l'elettronica, l'automazione, la telematica, e altre.

Mentre occorrono notevoli conoscenze teoriche e tecniche per appartenere alla categoria degli informatici, per appartenere a quella degli utenti finali ne occorrono decisamente di meno – talvolta solo il minimo indispensabile – e questo grazie al lavoro dei primi, costantemente orientato a rendere sempre più semplice l’uso del computer per tutti.

Un informatico dovrebbe sempre avere un interesse profondo per i fondamenti teorici dell'informatica. Che poi, per professione o per passione, spesso faccia lo sviluppatore di software è possibile, ma non è così scontanto, poichè può sfruttare le proprie capacità di problem solving in diversi ambiti. In ogni caso l'informatica, almeno nella sua parte applicativa, è una disciplina fortemente orientata al problem solving.

---------------
Notazione Big-O
---------------

Il seguente elenco mostra (in maniera essenzialmente pratica) le varie complessità temporali degli algoritmi:

O(1)
Il tempo di esecuzione di un algoritmo a tempo costante non dipende dalla dimensione dell'input. Un tipico algoritmo a tempo costante è una formula diretta che calcola il risultato della risposta.

O(log(n))
Un algoritmo logaritmico spesso dimezza la dimensione dell'input ad ogni passaggio. Il tempo di esecuzione di un tale algoritmo è logaritmico, perché log2(n) è uguale al numero di volte che n deve essere diviso per 2 per ottenere 1.

O(sqrt(n))
Un algoritmo di radice quadrata è più lento di O(log(n)) ma più veloce di O(n). Una proprietà speciale delle radici quadrate è che sqrt(n) = n/sqrt(n). Quindi n elementi possono essere suddivisi in O(sqrt (n)) blocchi di O(sqrt (n)) elementi.

O(n)
Un algoritmo lineare passa attraverso l'input un numero costante di volte. Questo è spesso la migliore complessità temporale possibile, perché di solito è necessario accedere ogni elemento di input almeno una volta prima di calcolare la risposta.

O(n*log(n))
Questa complessità temporale spesso indica che l'algoritmo ordina l'input, perché la complessità temporale degli algoritmi di ordinamento efficienti è O(n*log(n)). Un'altra situazione è che l'algoritmo utilizzi una struttura dati in cui ogni operazione richiede un tempo pari a O(log(n)).

O(n^2)
Un algoritmo quadratico spesso contiene due cicli annidati. È possibile passare attraverso tutte le coppie degli elementi di input in tempo O(n^2).

O(n^3)
Un algoritmo cubico contiene spesso tre cicli annidati. È possibile passare attraverso tutte le terne degli elementi di ingresso in tempo O(n^3).

O(2^n)
Questa complessità temporale spesso indica che l'algoritmo itera tutti i sottoinsiemi degli elementi di input. Ad esempio, i sottoinsiemi di (1 2 3) sono (), (1), (2), (3), (1 2), (1 3), (2 3) e (1 2 3).

O(n!)
Questa complessità temporale indica spesso che l'algoritmo itera attraverso tutte le permutazioni degli elementi di input. Ad esempio, le permutazioni di (1 2 3) sono (1 2 3), (1 3 2), (2 1 3), (2 3 1), (3 1 2) e (3, 2, 1).

Un algoritmo è polinomiale se la sua complessità temporale è al massimo O(n^k) dove k è una costante. Tutte le complessità temporali elencate sopra, eccetto O(2^n) e O(n!), sono polinomiali. In pratica, la costante k è solitamente piccola, e quindi una complessità temporale polinomiale significa (più o meno) che l'algoritmo può elaborare input di grandi dimensioni.
Comunque esistono importanti problemi per i quali non si conosce alcun algoritmo polinomiale, cioè non è possibile risolverli in modo efficiente. I problemi NP-hard sono un insieme importante di problemi, per i quali nessun algoritmo polinomiale è noto.

Valori della notazione Big-O in funzione del numero di input:

 n  costante  logaritmo   sqrt(n)   lineare   nlogn      quadrato   cubo    esponenziale
      O(1)    O(log(n))  O(sqrt(n))   O(n)   O(n*log(n))   O(n^2)   O(n^3)       O(2^n)
 1     1         1          1          1        1             1        1            1
 2     1         1          1          2        2             4        8            4
 4     1         1          2          4        2            16       64           16
 8     1         3          3          8       24            64      512          256
16     1         4          4         16       64           256     4096        65536
32     1         5          6         32      160          1024    32768   4294967296
64     1         6          8         64      384          4096   262144   1.84x10^19

Ma cosa significa esattamente che un algoritmo funziona in tempo O(f(n))?

Vuol dire che ci sono due costanti C e n0 tali che l'algoritmo esegua al massimo c*f(n) operazioni per tutti gli input in cui n ≥ n0. Pertanto, la notazione O fornisce un limite superiore per il tempo di esecuzione dell'algoritmo per input sufficientemente grandi. La notazione O non viene usata per fornire una stima accurata della complessità temporale.

Ci sono anche altre due notazioni comuni. La notazione Omega fornisce un limite inferiore per il tempo di esecuzione di un algoritmo. La complessità temporale di un algoritmo è Omega(f(n)), se ci sono due costanti C e n0 tali che l'algoritmo esegua almeno operazioni C*f(n) per tutti gli input dove n ≥ n0. Infine, la notazione Theta fornisce un limite esatto. La complessità temporale di un algoritmo è Theta(f(n)) se valgono sia O(f(n)) che Omega(f(n)). In pratica, Theta(f(n)) è una funzione che si trova compresa tra le funzioni O(f(n)) e Omega(f(n)).


-----------------------------------
Contare i bit di un numero (McAfee)
-----------------------------------

Dato un numero intero positivo n, contare il numero di bit che hanno valore 1 nella sua rappresentazione binaria.

Possiamo trasformare il numero in binario e contare quanti bit hanno valore 1.
Le funzioni di conversione decimale e binario sono le seguenti:

(define (bin2dec n)
  (if (zero? n) n
      (+ (% n 10) (* 2 (bin2dec (/ n 10))))))

(define (dec2bin n)
   (if (zero? n) n
       (+ (% n 2) (* 10 (dec2bin(/ n 2))))))

Siccome non dobbiamo ricreare il numero binario, ci limiteremo a contare i bit con valore 1.

Con l'operazione modulo (% n 2), estraiamo il bit più a destra del numero n (il bit meno significativo).
Esempio: consideriamo il numero 25

(dec2bin 25)
;-> 11001

Calcoliamo (% 25 2):
(% 25 2)
;-> 1

Poi calcoliamo (% 12 2), con 25/2 = 12
(% 12 2)
;-> 0

(% 6 2)
;-> 0

(% 3 2)
;-> 1

(% 1 2)
;-> 1

Ed ecco la funzione per contare i bit con valore 1:

(define (bit1 n)
  (let (conta 0)
    (while (> n 0)
       (if (= (% n 2) 1) (++ conta))
       (setq n (/ n 2))
    )
    conta
  )
)

(bin2dec 10001011001)
;-> 1113
(bit1 1133)
;-> 6

(bin2dec 1110011010001)
;-> 7377
(bit1 7377)
;-> 7

Per estrarre il bit più a destra di un numero possiamo usare anche le funzioni bitwise:
usando l'operatore bitwise AND "&", l'espressione (n & 1) produce un valore che è 1 o 0, a seconda del bit meno significativo di x: se l'ultimo bit è 1 allora il risultato di (x & 1) vale 1, altrimenti vale 0.
Usando l'operatore SHIFT ">>", l'espressione (n >> 1) sposta (shifta) di un bit verso destra il valore del numero n. In altre parole, divide il numero n per 2.
La funzione diventa:

(define (nbit1 n)
  (let (conta 0)
    (if (< n 0) (setq n (sub 0 n))) ; altrimenti il ciclo non termina
    (while (> n 0)
      (if (= (& n 1) 1) (++ conta))
      (setq n (>> n))
    )
    conta
  )
)

(bin2dec 10001011001)
;-> 1113
(nbit1 1133)
;-> 6

(bin2dec 1110011010001)
;-> 7377
(nbit1 7377)
;-> 7
(nbit1 -1133)
;-> 6
(int "-10001101101" 0 2)
;-> -1133

Nota: il valore del bit più significativo dopo lo spostamento è zero per i valori di tipo senza segno (unsigned). Per i valori di tipo con segno (signed), il bit più significativo viene copiato dal bit del segno del valore prima dello spostamento come parte dell'estensione del segno, quindi il ciclo non termina mai se n è di tipo con segno e il valore iniziale è negativo.

Ora vediamo quale metodo è più veloce:

(bit1 123456789)
;-> 16

(time (bit1 123456789) 100000)
;-> 527.479

(nbit1 123456789)
;-> 16

(time (nbit1 123456789) 100000)
;-> 494.247

La funzione che usa gli operatori bitwise è leggermente più veloce.


---------------------------------------------
Scambiare il valore di due variabili (McAfee)
---------------------------------------------

Come scambiare il valore di due variabili (swap) senza utilizzare una variabile di appoggio?

Primo metodo (somma/sottrazione):

Vediamo il funzionamento algebrico:
a = 1
b = 2

a = a + b --> a = a + b = 3 e b = 2
b = a - b --> b = ((a + b) - b) = 1 e a = 3
a = a - b --> a = (a + b) - ((a + b) - b) = 2

(setq a 1 b 2)
(println {a = } a { - b = } b)
;-> a = 1 - b = 2
(setq a (+ a b))
(setq b (- a b))
(setq a (- a b))
(println {a = } a { - b = } b)
;->  a = 2 - b = 1

(define (scambia x y)
  (setq x (+ x y))
  (setq y (- x y))
  (setq x (- x y))
  (list x y)
)

(scambia 2 3)
;-> (3 2)
(scambia -2 -3)
;-> (-3 -2)

Secondo metodo (map):

(setq a 1 b 2)
(println {a = } a { - b = } b)
;-> a = 1 - b = 2
(map set '(a b) (list b a))
(println {a = } a { - b = } b)
;-> a = 2 - b = 1

Terzo metodo (xor):

(setq a 5 b 10)
(setq a (^ a b))
;-> 15
(setq b (^ a b))
;-> 5
(setq a (^ a b))
;-> 10

Ricordiamo che lo XOR ha la seguente tabella di verità:

x y | out
---------
0 0 |  0
0 1 |  1
1 0 |  1
1 1 |  0

Quando si applica lo XOR a due variabili, i bit della prima variabile vengono utilizzati per alternare i bit nell'altro. A causa della natura di questo cambiamento, non importa quale variabile venga usata per alternare l'altra poichè i risultati sono gli stessi. Lo stesso bit nella stessa posizione in entrambi i numeri produce uno 0 in quella posizione nel risultato. I bit opposti producono un 1 in quella posizione.

(setq a (^ a b))
a è ora impostato sulla maschera di bit combinata di a e b. b ha ancora il valore originale.

(setq b (^ a b))
b è ora impostato sulla maschera di bit combinata di (a XOR b) e b. La b si cancella, quindi ora b è impostato sul valore originale di a. a è ancora impostato sulla maschera di bit combinata di a e b.

(setq a (^ a b))
a è ora impostato sulla maschera di bit combinata di (a XOR b) e a. (ricorda, b contiene effettivamente il valore originale di a adesso). La a si cancella, e quindi a è ora impostato sul valore originale di b.

Scriviamo la funzione (dobbiamo controllare che le variabili non contengano lo stesso numero, altrimenti il risultato sarebbe zero per entrambe):

(define (scambia x y)
  (cond ((= x y) (list x y))
        (true (setq x (^ x y))
              (setq y (^ x y))
              (setq x (^ x y))
              (list x y)
        )
  )
)

(scambia 5 25)
;-> (25 5)

(scambia 15 5)
;-> (5 15)

Quarto metodo (newLISP):

(setq a 1 b 2)
;-> 2
(swap a b)
;-> 1
(list a b)
;-> (2 1)


------------------------
Funzione "atoi" (McAfee)
------------------------

La funzione "atoi" del linguaggio C converte una stringa in un numero intero.
Implementare la funzione "atoi".

Per una corretta implementazione devono essere considerati i seguenti casi:

1. stringa di input vuota o nulla
2. spazi vuoti nella stringa di input
3. segno +/-
4. calcolare il valore della stringa
5. trattare i valori min & max

(define (atoi s)
  (local (flag i val)
    (cond ((or (null? s) (< (length s) 1)) 0) ; stringa nulla, valore nullo
          (true
            (setq s(trim s))
            (setq flag "+")
            (setq i 0)
            ; acquisizione segno
            (if (= (s 0) "-")
                (begin (setq flag "-") (++ i))
                (if (= (s 0) "+") (++ i))
            )
            (setq val 0)
            (while (and (> (length s) i) (>= (s i) "0") (<= (s i) "9"))
              (setq val (add (mul val 10) (sub (char (s i)) (char "0"))))
              (++ i)
            )
            ; controllo segno del risultato
            (if (= flag "-") (setq val (sub 0 val)))
            ; controllo overflow
            (if (> val 9223372036854775807) (setq val -9223372036854775808))
            (if (< val -9223372036854775808) (setq val 9223372036854775807))
          );true
    );cond
    (int val)
  );local
)

(atoi "9223372036854775808")
;-> -9223372036854775808
(int "9223372036854775808")
;-> -9223372036854775808

(atoi "-9223372036854775809")
;-> 9223372036854775807
(int "-9223372036854775809")
;-> 9223372036854775807

(atoi "123")
;-> 123
(int "123")
;-> 123

(atoi " -345hj5")
;-> -345
(int " -345hj5")
;-> -345

(atoi "")
;-> nil
(int "")
;-> nil

(atoi nil)
;-> nil
(int nil)
;-> nil


-------------------------------------
Somma di numeri in una lista (Google)
-------------------------------------

Data una lista di numeri e un numero k, restituire se due numeri dalla lista si sommano a k.
Ad esempio, dati (10 15 3 7) e k di 17, restituisce true da 10 + 7 che vale 17.
Bonus: puoi farlo in un solo passaggio (cioè O(n))?

Se vogliamo trovare la somma di ogni combinazione di due elementi di una lista il metodo più ovvio è quello di creare due for..loop sulla lista e verificare se soddisfano la nostra condizione.
Tuttavia, in questi casi, puoi sempre ridurre il numero di iterazioni avviando il secondo ciclo dal corrente elemento della lista, perché, ad ogni passo del primo ciclo, tutti gli elementi precedenti sono già confrontati tra loro.
Per esempio:

(define (test n , k)
  (for (i 1 n)
    (for (j 1 n)
      (++ k)))
  (println n { } k))

(test 100)
;-> 100 10000
(test 1000)
;-> 1000 1000000
(test 10000)
;-> 10000 100000000

(div 10000 100)
;-> 100
(div 1000000 1000)
;-> 1000
(div 100000000 10000)
;-> 10000

(define (test2 n , k)
  (for (i 1 n)
    (for (j i n)
      (++ k)))
  (println n { } k))

(test2 100)
;-> 100 5050
(test2 1000)
;-> 1000 500500
(test2 10000)
;-> 10000 50005000

(div 5050 100)
;-> 50.5
(div 500500 1000)
;-> 500.5
(div 50005000 10000)
;-> 5000.5

Comunque la complessità temporale rimane sempre O(n^2).

Quindi la soluzione è iterare sulla lista e per ogni elemento cercare se qualsiasi elemento della lista successiva somma fino a 17.

(define (sol lst n)
  (local (out ll)
    (setq out nil)
    (setq ll (- (length lst) 1))
    (for (i 0 ll 1 (= out true)) ; se out vale true, allora esce dal for..loop
      (for (j i ll)
        (if (= n (add (nth i lst) (nth j lst)))
          (setq out true)
        )
      )
    )
    out))

(sol '(10 15 3 7) 17)
;-> true

(sol '(3 15 10 7) 17)
;-> true

(sol '(3 15 10 7) 21)
;-> nil

Possiamo risolvere il problema in O(n) utilizzando una hash-map per verificare se, per il valore corrente "val" della lista, esiste un valore "somma - val" che sommato al primo produce il valore della "somma". Poichè attraversiamo la lista una sola volta il tempo vale O(n). Questa volta la funzione restituisce una lista con tutte le coppie di valori che formano la somma.

Algoritmo:
1) Creare una hash-map
2) Per ogni elemento val della lista lst
    Se (somma - val) esiste nella hash-map,
       allora aggiungere la coppia ((somma - val), val) nella lista soluzione
    Aggiungere val alla hash-map
3) Restituire la lista soluzione

(define (sol1 lst somma)
  (local (temp out)
    (setq out '())
    (new Tree 'hash)
    (dolist (val lst)
      (setq temp (- somma val))
      (if (hash (string temp))
          (push (list temp val) out -1)
      )
      (hash (string val) val)
    )
    (delete 'hash)
    out))

(sol1 '(10 15 3 7) 17)
;-> ((7 10))

(sol1 '(-2 3 7 -9 2) 5)
;-> ((-2 7) (3 2))

(sol1 '(3 -2 15 10 7 -4 -11) 21)
;-> ()


---------------------------------
Aggiornamento di una lista (Uber)
---------------------------------

Data una lista di interi, restituire una nuova lista in modo tale che ogni elemento nell'indice i della nuova lista sia il prodotto di tutti i numeri nella lista originale tranne quello in i.
Ad esempio, se il nostro input fosse (1 2 3 4 5), l'uscita prevista sarebbe (120 60 40 30 24).
Se il nostro input fosse (3 2 1), l'output atteso sarebbe (2 3 6).
Se il nostro input fosse (3 2 1 0), l'output previsto sarebbe (0 0 0 6).
Se il nostro input fosse (0 3 2 1 0), l'output previsto sarebbe (0 0 0 0).

La soluzione intuitiva porta alla funzione seguente:

(define (sol1 lst)
  (setq out '())
  (dolist (i lst)
    (setq p 1)
    (setq idx $idx)
    (dolist (j lst)
      (if (!= idx $idx)
          (setq p (mul p j)))
    )
    ;(push p out)
    (push p out -1)
  )
)

(sol1 '(1 2 3 4 5))
;-> (120 60 40 30 24)

(sol1 '(1 0 3 4 5))
;-> (0 60 0 0 0)

(sol1 '(3 2 1 0))
;-> (0 0 0 6)

(sol1 '(1 0 3 0 5))
;-> (0 0 0 0 0)

Un altro metodo deriva dalla seguente osservazione: nella nuova lista il valore dell'elemento i vale il prodotto di tutti i numeri diviso il numero dell'elemento i. Ad esempio con una lista di tre elementi (a b c) otteniamo:

primo elemento:    a * b * c / a = b * c
secondo elemento:  a * b * c / b = a * c
terzo elemento:    a * b * c / c = a * b

Quindi dobbiamo calcolare il prodotto di tutti gli elementi della lista e poi dividere questo valore con il valore di ogni elemento. In questo modo otteniamo il prodotto di tutti gli elementi tranne quello corrente.
Adesso dobbiamo tenere conto degli elementi con valore zero:

1. Uno zero nella lista.
In questo caso, il risultato dovrebbe essere tutti zero tranne l'elemento che ha valore 0: questo elemento dovrebbe contenere il prodotto di tutti gli altri.

2. Due zeri o più nella lista.
Questo caso è più o meno come il primo, ma la lista risultante contiene sempre solo zeri. Perché c'è sempre uno zero nel prodotto.

Per considerare questi due casi calcoliamo il prodotto di tutti gli elementi tranne quelli che hanno valore zero e contiamo anche quanti zeri ci sono nella lista.
Quindi se abbiamo due o più zeri nella lista iniziale, possiamo restituire una lista con tutti zeri.
Altrimenti, iteriamo la lista per sostituire gli elementi che valgono zero con il prodotto che abbiamo calcolato e assegnare il valore zero a tutti gli altri elementi.

La funzione è la seguente:

(define (sol2 lst)
  (local (prod numzeri out)
    (if (< (length lst) 2) (setq out lst) ; lista con meno di due elementi --> lista
        (begin
          (setq out '())
          (setq prod 1)
          (setq numzeri 0)
          ; calcolo del prodotto degli elementi e del numero di zeri
          (dolist (el lst)
            (if (zero? el) (++ numzeri)
                (setq prod (mul prod el))
            )
          )
          (cond ((> numzeri 1) (setq out (dup 0 (length lst)))) ; restituisco una lista con tutti zeri
                ((= numzeri 1) (dolist (el lst)
                                  (if (zero? el) (push prod out -1) ; valore del prodotto sugli elementi che hanno valore zero
                                      (push 0 out -1) ; valore zero su tutti gli altri elementi
                                  )
                               )
                )
                (true (dolist (el lst)
                        (push (div prod el) out -1) ; assegnazione di prodotto / elemento
                      )
                )
          )
        );begin
    );if
    out
  );local
)

(sol2 '(1 2 3 4 5))
;-> (120 60 40 30 24)

(sol2 '(3 2 1))
;-> (2 3 6)

(sol2 '(3 2 1 0))
;-> (0 0 0 6)

(sol2 '(0 3 2 1 0))
;-> (0 0 0 0 0)


------------------------------------
Ricerca numero su una lista (Stripe)
------------------------------------

Data una lista di numeri interi, trova il primo intero positivo mancante in tempo lineare e spazio costante. In altre parole, trova il numero intero positivo più basso che non esiste nella lista. La lista può contenere anche duplicati e numeri negativi.
Ad esempio, l'input (3 4 -1 1) dovrebbe restituire 2.
L'input (1 2 0) dovrebbe restituire 3.
È possibile modificare la lista di input.

Possiamo notare che gli indici di una lista e i numeri interi sono la stessa cosa.
Quindi inseriamo ogni numero intero positivo di una lista al suo posto e poi iteriamo di nuovo per trovare il primo numero mancante. Se non troviamo il numero mancante (la lista è completa di tutti i numeri), allora restituiamo la lunghezza della lista.

(define (sol lst)
  (local (out ll)
    (setq out -1)
    (setq ll (- (length lst) 1))
    (dolist (el lst)
      (cond ((< el 0) nil) ; numero negativo: non fare niente
            ((>= el (length lst)) nil) ; numero oltre la lista: non fare niente
            (true   (setf (nth el lst) el))
      )
    )
    (for (x 1 ll 1 (!= out -1))
      (if (!= (nth x lst) x) (setq out x))
    )
    (if (= out -1) (setq out (+ ll 1)))
    (list out lst)
  )
)

(sol '(6 5 4 3 2 1 0))
;-> (7 (0 1 2 3 4 5 6))

(sol '(4 4 -1 1))
;-> (2 (4 1 -1 1))

(sol '(4 0 -1 1 2 5 7 9))
;-> (3 (0 1 2 1 4 5 7 7))


-------------------------------------
Decodifica di un messaggio (Facebook)
-------------------------------------

Data la mappatura a = 1, b = 2, ... z = 26 e un messaggio codificato, contare il numero di modi in cui può essere decodificato.
Ad esempio, il messaggio "111" restituirebbe 3, poiché potrebbe essere decodificato come "aaa" (1)(1)(1), "ka" (11)(1) e "ak" (1)(11).
Puoi presumere che i messaggi siano decodificabili. Per esempio, "001" non è permesso.

Molti dei problemi di analisi delle liste e delle stringhe sono basati sulla ricorsione.
Per iniziare è sempre utile risolvere manualmente alcuni casi banali, cercando di utilizzare i risultati di un caso precedente:

- se la lunghezza di una stringa è uno, c'è sempre un modo per decodificarlo,

"1": ("1")
----------
F ("1") = 1

- se la lunghezza è 2, abbiamo sempre un modo con tutte le cifre separatamente, più uno se un numero è inferiore a 26.

"12": ("1","2") e ("12")
------------------------
F ("12 ") = f ("12") + 1

- se la lunghezza è 3, possiamo usare i risultati del precedente calcoli, perché sappiamo già come affrontare le stringhe più brevi.

F ("123") = f ("1") * F ("23 ") + F ("12") * f ("3") = 3

- Tutti i casi successivi possono essere calcolati utilizzando le definizioni precedentemente definite:

F ("4123") = f ("4") * F ("123") + f ("41") * F ("23") = 3

Inoltre utilizzeremo una funzione "decodifica?" che ritorna "1" se la stringa è decodificabile e "0" altrimenti.

(define (sol s)
  (local (lun p)
    (setq lun (length s))
    (setq p (s 0))
    (cond ((= 1 lun) (decodifica? s))
          ((= 2 lun) (if (= p "0") (decodifica? s) (add (decodifica? s) 1)))
          (true (add (mul (decodifica? (slice s 0 1)) (sol (slice s 1)))
                     (mul (decodifica? (slice s 0 2)) (sol (slice s 2)))))
    )
  )
)

(define (decodifica? ss)
  (setq v (int ss 0 10))
  (if (= (s 0) "0") ; la forma "01" non è valida
      0
      (if (and (> v 0) (<= v 26))
          1
          0
      )
  )
)

(sol "111")
;-> 3

(sol "111233423421")
;-> 32

(sol "4123")
;-> 3

(sol "101")
;-> 1


-------------------------------------------
Implementazione di un job-scheduler (Apple)
-------------------------------------------

Implementare un job scheduler che prende come parametri una funzione "f" e un intero "n" e chiama "f" dopo "n" millisecondi.

Definiamo una funzione che rende un numero pari o dispari in maniera casuale.

(define (g)
  (if (zero? (rand 2))
      ; se esce 0, allora diventa o rimane pari
      (if (odd? num)  (println "diventa pari: " (++ num))
                      (println "rimane pari: " num))
      ; se esce 1, allora diventa o rimane dispari
      (if (even? num) (println "diventa dispari: " (++ num))
                      (println "rimane dispari: " num))
  )
)

Definiamo il valore iniziale del numero:

(define num 1)

E infine scriviamo il nostro job-scheduler:

(define (job f n)
  ; funziona anche in questo modo perchè "num" è una variabile globale
  ; e viene vista anche dalla funzione "g".
  ;(setq num 1)
  (while true
    (sleep n)
    (g)
  )
)

Lanciamo il nostro job-scheduler che eseguirà la funzione "g" ogni 2 secondi:

(job fun 2000)
;-> rimane dispari: 1
;-> rimane dispari: 1
;-> diventa pari: 2
;-> diventa dispari: 3
;-> rimane dispari: 3
;-> diventa pari: 4
;-> rimane pari: 4
;-> diventa dispari: 5
;-> rimane dispari: 5
;-> rimane dispari: 5
;-> diventa pari: 6
;-> diventa dispari: 7
;-> rimane dispari: 7
;-> rimane dispari: 7
;-> diventa pari: 8
;-> rimane pari: 8
;-> rimane pari: 8
;-> rimane pari: 8
;-> rimane pari: 8
;-> rimane pari: 8
;-> diventa dispari: 9
;-> diventa pari: 10


---------------------------------------
Massimo raccoglitore d'acqua (Facebook)
---------------------------------------

Dati n numeri interi non negativi a1, a2, ..., an, dove ognuno rappresenta un punto di coordinate
(i, ai), n linee verticali sono disegnate in modo tale che i due estremi della linea i siano ad (i, ai)
e (i, 0). Trova due linee, che insieme all'asse x formano un contenitore, in modo tale che il
il contenitore contenga più acqua.

Esempio:
                           6
     6         5           |
     5         |     4     |
     4      3  |  3  |  3  |  3
     3   2  |  |  |  |  |  |  |
     2   |  |  |  |  |  |  |  |
     1   |  |  |  |  |  |  |  |
         ----------------------
         0  1  2  3  4  5  6  7

(setq lst '(2 3 5 3 4 3 6 3))

Questa è la soluzione grafica:

                         6
   6         5           |
   5         |OOOOOOOOOOO|
   4      3  |OOOOOOOOOOO|  3
   3   2  |  |OOOOOOOOOOO|  |
   2   |  |  |OOOOOOOOOOO|  |
   1   |  |  |OOOOOOOOOOO|  |
       ----------------------
       0  1  2  3  4  5  6  7

In questo caso le linee del contenitore che contengono più acqua sono la 2 (con valore 5) e la 6 (con valore 6).
L'altezza h del contenitore è data dal valore minore, cioè quello della linea 2 che vale 5.
La larghezza d del contenitore è la distanza tra le due linee (cioè la differenza degli indici), che vale (6 - 2) = 4.
L'area del contenitore massimo vale A = h*d = 5*4 = 20.

Attenzione: l'area massima non sempre è delimitata dai due valori massimi. Il seguente esempio mostra un caso in cui i valori massimi non delimitano l'area massima:

                                       9
     9                                 |     8
     8                              7  |     |
     7                              |  |     |
     6         5                    |  |     |
     5         |     4     4        |  |     |
     4      3  |  3  |  3  |  3  3  |  |  3  |
     3   2  |  |  |  |  |  |  |  |  |  |  |  |
     2   |  |  |  |  |  |  |  |  |  |  |  |  |
     1   |  |  |  |  |  |  |  |  |  |  |  |  |
        ---------------------------------------
         0  1  2  3  4  5  6  7  8  9  10 11 12

(setq lst '(2 3 5 3 4 3 4 3 3 7 9 3 8))

Questa è la soluzione grafica:

                                       9
     9                                 |     8
     8                              7  |     |
     7                              |  |     |
     6         5                    |  |     |
     5         |OOOOOOOOOOOOOOOOOOOO|OO|OOOOO|
     4      3  |OOOOOOOOOOOOOOOOOOOO|OO|OOOOO|
     3   2  |  |OOOOOOOOOOOOOOOOOOOO|OO|OOOOO|
     2   |  |  |OOOOOOOOOOOOOOOOOOOO|OO|OOOOO|
     1   |  |  |OOOOOOOOOOOOOOOOOOOO|OO|OOOOO|
        ---------------------------------------
         0  1  2  3  4  5  6  7  8  9  10 11 12

Poniamo l'area del contenitore a 0.
Iniziamo a scansionare la lista di numeri da sinistra (sx) e da destra (dx).
Se (valore di sinistra) < (valore di destra), allora spostarsi da sinistra verso destra e trovare un valore maggiore del (valore di sinistra).
Se (valore di sinistra) > (valore di destra), allora spostarsi da destra verso sinistra e trovare un valore maggiore del (valore di destra).
Durante la scansione occorre tenere traccia del valore massimo dell'area del contenitore.
Tale area è data dalla moltiplicazione tra differenza degli indici correnti (larghezza) e il valore minimo dei valori correnti (altezza).

Possiamo scrivere la soluzione:

(define (sol lst)
  (local (areamax dx sx i1 i2 v1 v2 dmax vmax d h)
    (setq areamax 0)
    (setq sx 0)
    (setq dx (sub (length lst) 1))
    (while (< sx dx)
      (setq d (sub dx sx))
      (setq h (min (lst sx) (lst dx)))
      (if (> (mul d h) areamax)
        (begin  (setq areamax (mul d h))
                (setq i1 sx i2 dx)
                (setq v1 (lst i1))
                (setq v2 (lst i2))
                (setq vmax h)
                (setq dmax d)
        )
      )
      (if (< (lst sx) (lst dx))
          (++ sx)
          (-- dx)
      )
      ;(println "isx = " sx " - idx" dx)
    )
    (list areamax dmax vmax i1 i2 v1 v2)
  )
)

(sol '(2 3 5 3 4 3 6 3))
;-> (20 4 5 2 6 5 6)
; 5 e 6 --> h=5, distanza indici tra 5 e 6 d = (6-2) = 4  ==> area = h*d = 5*4 = 20

(sol '(2 8 5 3 4 3 7 3))
;-> (35 5 7 1 6 8 7)
;-> 35 ; 7 e 8 --> h=7, distanza indici tra 7 e 8 d = (6-1) = 5  ==> area = h*d = 7*5 = 35

(sol '(2 3 5 3 4 3 4 3 3 7 9 3 8))
;-> (50 10 5 2 12 5 8)

Se vogliamo sapere solo l'area massima, allora la soluzione è la seguente:

(define (sol lst)
  (local (areamax dx sx)
    (setq areamax 0)
    (setq sx 0)
    (setq dx (sub (length lst) 1))
    (while (< sx dx)
      (setq areamax (max areamax (mul (sub dx sx) (min (lst sx) (lst dx)))))
      (if (< (lst sx) (lst dx))
          (++ sx)
          (-- dx)
      )
    )
    areamax
  )
)

(sol '(1 5 4 3))
;-> 6

(sol '(3 1 2 4 5))
;-> 12

(sol '(2 3 5 3 4 3 6 3))
;-> 20

(sol '(2 8 5 3 4 3 7 3))
;-> 35

(sol '(2 3 5 3 4 3 4 3 3 7 9 3 8))
;-> (50)

Consideriamo nuovamente questo ultimo esempio:

                                       9
     9                                 |     8
     8                              7  |     |
     7                              |  |     |
     6         5                    |  |     |
     5         |     4     4        |  |     |
     4      3  |  3  |  3  |  3  3  |  |  3  |
     3   2  |  |  |  |  |  |  |  |  |  |  |  |
     2   |  |  |  |  |  |  |  |  |  |  |  |  |
     1   |  |  |  |  |  |  |  |  |  |  |  |  |
        ---------------------------------------
         0  1  2  3  4  5  6  7  8  9  10 11 12

(setq lst '(2 3 5 3 4 3 4 3 3 7 9 3 8))

(sol '(2 3 5 3 4 3 4 3 3 7 9 3 8))
;-> (50 10 5 2 12 5 8)

Come abbiamo visto questa è la soluzione grafica:

                                       9
     9                                 |     8
     8                              7  |     |
     7                              |  |     |
     6         5                    |  |     |
     5         |OOOOOOOOOOOOOOOOOOOO|OO|OOOOO|
     4      3  |OOOOOOOOOOOOOOOOOOOO|OO|OOOOO|
     3   2  |  |OOOOOOOOOOOOOOOOOOOO|OO|OOOOO|
     2   |  |  |OOOOOOOOOOOOOOOOOOOO|OO|OOOOO|
     1   |  |  |OOOOOOOOOOOOOOOOOOOO|OO|OOOOO|
        ---------------------------------------
         0  1  2  3  4  5  6  7  8  9  10 11 12

Ma se invece vogliamo considerare la soluzione seguente:

                                       9
     9                                 |     8
     8                              7  |     |
     7                              |  |     |
     6         5                    |  |     |
     5         |OOOOOOOOOOOOOOOOOOOO|  |     |
     4      3  |OOOOOOOOOOOOOOOOOOOO|  |  3  |
     3   2  |  |OOOOOOOOOOOOOOOOOOOO|  |  |  |
     2   |  |  |OOOOOOOOOOOOOOOOOOOO|  |  |  |
     1   |  |  |OOOOOOOOOOOOOOOOOOOO|  |  |  |
        ---------------------------------------
         0  1  2  3  4  5  6  7  8  9  10 11 12

allora dobbiamo scrivere una nuova funzione per calcolare la soluzione.


----------------------------------------
Quantità d'acqua in un bacino (Facebook)
----------------------------------------

Dati n interi non negativi che rappresentano una mappa di elevazione in cui la larghezza di ciascuna barra è 1, calcolare la quantità massima di acqua che è in grado di contenere.

Esempi:

lista = (2 0 2)
acqua = 2

   202
2  |x|
1  |x|
0  ---
   012

Possiamo avere "2 unità di acqua" (x) nello spazio intermedio.

lista: (3 0 0 2 0 4)
acqua: 10

  300204
       |
3 |xxxx|
2 |xx|x|
1 |xx|x|
0 ------
  012345

"3 * 2 unità" di acqua tra 3 e 2,
"1 unità" in cima alla barra 2,
"3 unità" tra 2 e 4.

lista: (0 1 0 2 1 0 1 3 2 1 2 1)
acqua: 6

  010210132121
3        |
2    |xxx||x|
1  |x||x||||||
0 ------------
  012345678901

"1 unità" tra i primi 1 e 2,
"4 unità" tra i primi 2 e 3,
"1 unità" in cima alla barra 9 (tra il penultimo 1 e l'ultimo 2).

Un elemento dell'array può immagazzinare acqua se ci sono barre più alte a sinistra e a destra. Possiamo trovare quantità di acqua da immagazzinare in ogni elemento trovando l'altezza delle barre sui lati sinistro e destro. L'idea è di calcolare la quantità d'acqua che può essere immagazzinata in ogni elemento dell'array. Ad esempio, considera l'array (3 0 0 2 0 4), possiamo memorizzare due unità di acqua agli indici 1 e 2, e una unità di acqua all'indice 2.

Una soluzione semplice consiste nel percorrere ogni elemento dell'array e trovare le barre più alte sui lati sinistro e destro. Prendere la minore delle due altezze. La differenza tra altezza minima e altezza dell'elemento corrente è la quantità di acqua che può essere immagazzinata in questo elemento dell'array. La complessità temporale di questa soluzione è O(n^2).

Una soluzione efficiente consiste nel pre-calcolare la barra più alta a sinistra e a destra di ogni barra nel tempo O(n). Quindi utilizzare questi valori pre-calcolati per trovare la quantità di acqua in ogni elemento dell'array. Di seguito vediamo l'implementazione di questa ultima soluzione.

(define (bacino lst)
  (local (lun sx dx acqua)
      (setq lun (length lst))
      (setq sx (array lun))
      (setq dx (array lun))
      (setq acqua 0)
      ; riempimento sx
      (setf (sx 0) (lst 0))
      (for (i 1 (sub lun 1))
        (setf (sx i) (max (sx (sub i 1)) (lst i)))
      )
      ; riempimento dx
      (setf (dx (sub lun 1)) (lst (sub lun 1)))
      (for (i (sub lun 2) 0 -1)
        (setf (dx i) (max (dx (add i 1)) (lst i)))
      )
      ; bar vale min(sx[i], dx[i]) - arr[i]
      (for (i 0 (sub lun 1))
        (setq bar-acqua (sub (min (sx i) (dx i)) (lst i)))
        (print bar-acqua { })
        (setq acqua (add acqua bar-acqua))
      )
   )
)

(bacino '(2 0 2))
;-> 2 0 2

(bacino '(3 0 0 2 0 4))
;-> 0 3 3 1 3 0 10

(bacino '(0 1 0 2 1 0 1 3 2 1 2 1))
;-> 0 0 1 0 1 2 1 0 0 1 0 0 6

(bacino '(1 1 1 1 1 1 1 1 1 1 1 1)) ; bacino piatto
;-> 0 0 0 0 0 0 0 0 0 0 0 0 0

Vediamo un altro esempio:

lista: (2 3 5 3 4 3 4 3 3 7 9 3 8))

         2353434337938
     9             |
     8             | |
     7            || |
     6            || |
     5     |      || |
     4     | | |  || |
     3    ||||||||||||
     2   |||||||||||||
     1   |||||||||||||
        ---------------
         0123456789012

Soluzione:
acqua: 15

         2353434337938
     9             |
     8             |x|
     7            ||x|
     6            ||x|
     5     |xxxxxx||x|
     4     |x|x|xx||x|
     3    ||||||||||||
     2   |||||||||||||
     1   |||||||||||||
        ---------------
         0123456789012

Totale x = 15

(bacino '(2 3 5 3 4 3 4 3 3 7 9 3 8))
;-> 0 0 0 2 1 2 1 2 2 0 0 5 0 15

Un ultimo esempio:

lista: (2 0 3 0 5 0 3 0 4 0 3 0 4 0 3 0 3 0 7 0 9 0 3 0 8)

         2030503040304030307090308

     9                       |
     8                       |   |
     7                     | |   |
     6                     | |   |
     5       |             | |   |
     4       |   |   |     | |   |
     3     | | | | | | | | | | | |
     2   | | | | | | | | | | | | |
     1   | | | | | | | | | | | | |
        ---------------------------
         0123456789012345678901234

Soluzione:
acqua: 78

         2030503040304030307090308

     9                       |
     8                       |xxx|
     7                     |x|xxx|
     6                     |x|xxx|
     5       |xxxxxxxxxxxxx|x|xxx|
     4       |xxx|xxx|xxxxx|x|xxx|
     3     |x|x|x|x|x|x|x|x|x|x|x|
     2   |x|x|x|x|x|x|x|x|x|x|x|x|
     1   |x|x|x|x|x|x|x|x|x|x|x|x|
        ---------------------------
         0123456789012345678901234

Totale x = 78

(bacino '(2 0 3 0 5 0 3 0 4 0 3 0 4 0 3 0 3 0 7 0 9 0 3 0 8))
;-> 0 2 0 3 0 5 2 5 1 5 2 5 1 5 2 5 2 5 0 7 0 8 5 8 0 78


--------------------------
Sposta gli zeri (LeetCode)
--------------------------

Data una lista di numeri, scrivere una funzione per spostare tutti gli 0 alla fine della lista mantenendo l'ordine relativo degli elementi diversi da zero.
Ad esempio, data la lista (0 1 0 3 12), dopo aver chiamato la funzione, la lista dovrebbe essere (1 3 12 0 0).

Risolviamo questo problema in due modi: il primo con le funzioni predefinite di newLISP e il secondo considerando la lista come un vettore ed utilizzando gli indici

Nel primo caso notiamo che:

con find-all possiamo creare la lista degli zeri:

(setq zeri (find-all 0 '(0 1 0 3 12)))
;-> (0 0)

con filter possiamo creare la lista di tutti i numeri diversi da zero:

(define (pos? x) (> x 0))
(setq numeri (filter pos? '(0 1 0 3 12)))
;-> (1 3 12)

infine uniamo le due liste con append:

(append numeri zeri)
;-> (1 3 12 0 0)

Quindi la funzione è la seguente:

(define (sol lst)
  (define (pos? x) (> x 0))
  (append (filter pos? lst) (find-all 0 lst))
)

(sol '(0 1 0 3 12))
;-> (1 3 12 0 0)
(sol '(1 0 1 0 3 0 4 0 0))
;-> (1 1 3 4 0 0 0 0 0)

Nel secondo caso utilizziamo due cicli con due indici "i" e "j". Il primo ciclo salta gli zeri e sposta in numeri nella lista, mentre il secondo ciclo scrive gli zeri alla fine della lista. L'indice "i" tiene conto della posizione dove vanno spostati i numeri (e implicitamente conta anche il numero di zeri), mentre l'indice "j" scansiona la lista.

(define (sol lst)
  (local (lun i j)
    (setq i 0 j 0)
    (setq lun (length lst))
    ; ciclo che salta gli zeri e sposta i numeri
    (while (< j lun)
      (if (!= 0 (lst j))
        (begin (setq (lst i) (lst j)) (++ i))
      )
      (++ j)
    )
    ; ciclo che scrive gli zeri alla fine della lista
    (while (< i lun)
      (setq (lst i) 0)
      (++ i)
    )
    lst
  )
)

(sol '(0 1 0 3 12))
;-> (1 3 12 0 0)
(sol '(1 0 1 0 3 0 4 0 0))
;-> (1 1 3 4 0 0 0 0 0)


---------------------------------------
Intersezione di segmenti (byte-by-byte)
---------------------------------------

La soluzione è basata su un algoritmo del libro di Andre LeMothe "Tricks of the Windows Game Programming Gurus".
In generale, una linea ha una delle forme seguenti (interscambiabili):

Y-Intercetta:  y = m*x + b
Pendenza:      (y – y0) = m*(x – x0)
Due punti:     (y – y0) = (x – x0)*(y1 – y0)/(x1 – x0)
Generale:      a*x + b*y = c
Parametrica:   P = p0 + V*t

Il caso generale dell'intersezione è il seguente:

     y
     |                 (x1,y1)
     |                    /
     |                   /
     |                  /
     |      (x2,y2)    / p0
     |         \      /
     |          \    /
     |        p1 \  /
     |            \/ (ix,iy)
     |            /\
     |           /  \
     |          /    \
     |       (x0,y0)  \
     |                 \
     |               (x3,y3)
    -|-------------------------------- x

Il primo segmento di linea p0 ha coordinate (x0, y0) e (x1, y1).
Il secondo segmento di linea p1 ha coordinate (x2, y2) e (x3, y3).
Comunque p0 e p1 possono avere qualsiasi orientamento.

Equazione 1 - Pendenza del punto di p0: (x - x0) = m0 * (y - y0)
Data da m0 = (y1 - y0) / (x1 - x0) e (x - x0) = m0 * (y - y0)

Equazione 2 - Pendenza del punto di p2: Equazione 2: (x - x2) = m1 * (y - y2)
data da m1 = (y3 - y2) / (x3 - x2) e (x - x2) = m1 * (y - y2)

Ora abbiamo un sistema di due equazioni in due incognite:
Equazione 1: (x - x0) = m0 * (y - y0)
Equazione 2: (x - x2) = m1 * (y - y2)

Risolvendo il sistema con le matrici o per sostituzione otteniamo la seguente soluzione:

Equazione 3:

x = (-m0 / (m1 - m0)) * x2 + m0 * (y2 - y0) + x0

Equazione 4:

y = (m0 * y0 - m1 * y2 + x2 - x0) / (m0 - m1)

Prima di vedere come trattare i casi particolari (ad esempio m0 = m1) scriviamo la funzione:

(define (intersect-line p0x p0y p1x p1y p2x p2y p3x p3y)
  (local (ix iy s1x s1y s2x s2y s t)
    (setq s1x (sub p1x p0x))
    (setq s1y (sub p1y p0y))
    (setq s2x (sub p3x p2x))
    (setq s2y (sub p3y p2y))
    (println "numer = " (add (mul (sub 0 s1y) (sub p0x p2x)) (mul s1x (sub p0y p2y))))
    (println "denom = " (add (mul (sub 0 s2x) s1y) (mul s1x s2y)))
    (setq s (div (add (mul (sub 0 s1y) (sub p0x p2x)) (mul s1x (sub p0y p2y)))
                (add (mul (sub 0 s2x) s1y) (mul s1x s2y))))
    (setq t (div (sub (mul s2x (sub p0y p2y)) (mul s2y (sub p0x p2x)))
                (add (mul (sub 0 s2x) s1y) (mul s1x s2y))))
    (println "s = " s)
    (println "t = " t)
    (cond ((and (>= s 0) (<= s 1) (>= t 0) (<= t 1)) ;intersezione
           (setq ix (add p0x (mul t s1x)))
           (setq iy (add p0y (mul t s1y)))
          )
          (true (setq ix nil) (setq iy nil))
    )
    (list ix iy)
  )
)

Vediamo come si comporta la funzione nei casi normali e nei casi particolari:

; intersezione
(intersect-line 0 0 2 2 0 1 1 0)
;-> numer = -2
;-> denom = -4
;-> s = 0.5
;-> t = 0.25
;-> (0.5 0.5)

; no intersezione
(intersect-line 1 1 3 3 2 3 2 5)
;-> numer = -2
;-> denom = 4
;-> s = -0.5
;-> t = 0.5
;-> (nil nil)

; no intersezione
(intersect-line 1 1 5 6 3 1 4 0)
;-> numer = 10
;-> denom = -9
;-> s = -1.111111111111111
;-> t = 0.2222222222222222
;-> (nil nil)

; paralleli orizzontali
(intersect-line 1 1 3 1 1 3 3 3)
;-> numer = -4
;-> denom = 0
;-> s = -1.#INF
;-> t = -1.#INF
;-> (nil nil)

; paralleli verticali
(intersect-line 1 1 1 3 3 1 3 3)
;-> numer = 4
;-> denom = 0
;-> s = 1.#INF
;-> t = 1.#INF
;-> (nil nil)

; collineari (senza sovrapposizione)
(intersect-line 1 2 3 2 5 2 7 2)
;-> numer = 0
;-> denom = 0
;-> s = -1.#IND
;-> t = -1.#IND
;-> (nil nil)

; collineari (con sovrapposizione)
(intersect-line 1 2 4 2 3 2 6 2)
;-> numer = 0
;-> denom = 0
;-> s = -1.#IND
;-> t = -1.#IND
;-> (nil nil)

; collineari uniti (senza sovrapposizione)
(intersect-line 1 1 2 2 2 2 3 3)
;-> numer = 0
;-> denom = 0
;-> s = -1.#IND
;-> t = -1.#IND
;-> (nil nil)

; collineari uniti (con sovrapposizione)
(intersect-line 1 1 3 3 2 2 4 4)
;-> numer = 0
;-> denom = 0
;-> s = -1.#IND
;-> t = -1.#IND
;-> (nil nil)

; uniti (punto-punto)
(intersect-line 1 2 3 2 3 2 5 4)
;-> numer = 0
;-> denom = 4
;-> s = 0
;-> t = 1
;-> (3 2)

; uniti (segmento-punto)
(intersect-line 1 1 3 3 2 2 5 1)
;-> numer = 0
;-> denom = -8
;-> s = -0
;-> t = 0.5
;-> (2 2)

Se vogliamo trattare i casi particolari in modo diverso da (nil nil) possiamo utilizzare i seguenti predicati:

; indeterminato (0/0)
(div 0 0)
;-> -1.#IND
(NaN? (div 0 0))
;-> true
(inf? (div 0 0))
;-> nil

; indeterminato (inf/inf)
(div (div 5 0) (div 5 0))
;-> -1#IND
(NaN? (div (div 5 0) (div 5 0)))
;-> true
(inf? (div (div 5 0) (div 5 0)))
;-> nil

; infinito (inf)
(div 5 0)
;-> 1.#INF
(inf? (div 5 0))
;-> true
(NaN? (div 5 0))
;-> nil


--------------------------------------
Trovare l'elemento mancante (LeetCode)
--------------------------------------

Abbiamo due liste con gli stessi elementi, ma una lista ha un elemento in meno. Trovare l'elemento mancante della lista più corta.
Esempio:
lista 1: (1 3 4 6 8)
lista 2: (3 1 6 8)
Elemento mancante: 4

Invece di usare due cicli for annidati per trovare l'elemento, possiamo notare che sottraendo la somma degli elementi della lista più corta alla somma degli elementi di quella più lunga otteniamo il valore dell'elemento mancante.

(define (sol lst1 lst2)
  (abs (sub (apply + lst1) (apply + lst2)))
)

(sol '(1 3 4 6 8) '(3 1 6 8))
;-> 4

Possiamo usare anche la funzione difference:

(difference '(1 3 4 6 8) '(3 1 6 8))
;-> (4)

Nota: Dati due valori di una lista con tre scelte (1 2 3), individuare il terzo valore.

(define (altro x y)
    (- 6 (+ x y))
)

(altro 1 2)
;-> 3


--------------------------------
Verifica lista/sottolista (Visa)
--------------------------------

Date due liste A e B composte da n e m interi, verificare se la lista B è una sottolista della lista A.
Esempi:

Lista A (2 3 0 5 1 1 2)
Lista B (3 0 5 1)
B sottolista di A? si

Lista A (1 2 3 4 5)
Lista B (2 5 6)
B sottolista di A? no

Utilizziamo due indici "i" e "j" per attraversare contemporaneamentele le liste A e B.
Se gli elementi delle due liste sono uguali, allora incrementiamo entrambi gli indici (e controllo anche che la lista B non sia terminata);
altrimenti incrementiamo l'indice "i" della lista A e resettiamo a zero l'indice "j" della lista B.
Ecco la funzione:

(define (sol lstA lstB)
  (local (i j lunA lunB out)
    (setq i 0 j 0)
    (setq lunA (length lstA))
    (setq lunB (length lstB))
    (while (and (< i lunA) (< j lunB))
      (cond ((= (lstA i) (lstB j))
             (++ i)
             (++ j)
             (if (= j lunB) (setq out true))
            )
            (true (setq j 0) (++ i))
      )
    )
    out
  )
)

(sol '(2 3 0 5 1 1 2) '(3 0 5 1))
;-> true

(sol '(1 2 3 4 5) '(2 5 6))
;-> nil

(time (sol '(2 3 0 5 1 1 2) '(3 0 5 1)) 100000)
;-> 203

Oppure:

(define (sol A B)
  (if (or (= B (intersect A B)) (= B '())) ;() è sempre una sottolista
    true nil))

(sol '(2 3 0 5 1 1 2) '(3 0 5 1))
;-> true

(sol '(1 2 3 4 5) '(2 5 6))
;-> nil

(time (sol '(2 3 0 5 1 1 2) '(3 0 5 1)) 100000)
;-> 140


----------------------------------
Controllo ordinamento lista (Visa)
----------------------------------

Scrivere una funzione per controllare se una lista è ordinata o meno. La funzione deve avere un parametro che permette di specificare il tipo di ordinamento (crescente o decrescente).

Usiamo la tecnica della ricorsione per risolvere il problema: applico l'operatore di confronto tra il primo e il secondo elemento e poi richiamo la stessa funzione con il resto della lista.
L'operatore di confronto può avere i seguenti valori:
1) >= (lista crescente)
2) >  (lista strettamente crescente)
3) <= (lista decrescente)
4) <  (lista strettamente decrescente)
5) =  (lista con elementi identici)

(define (ordinata? lst operatore)
      (cond ((null? lst) true)
            ((= (length lst) 1) true)
            ; se l'attuale coppia di elementi rispetta l'operatore...
            ((operatore (first (rest lst)) (first lst))
              ; allora controlla la prossima coppia
              (ordinata? (rest lst) operatore))
              ; altrimenti restituisce nil
            (true nil))
)

; lista crescente ?
(ordinata? '(1 1 2 3) >=)
;-> true

; lista strettamente crescente ?
(ordinata? '(1 1 2 3) >)
;-> nil

; lista decrescente ?
(ordinata? '(3 2 1 1) <=)
;-> true

; lista strettamente decrescente ?
(ordinata? '(3 2 1 1) <)
;-> nil

; lista con elementi identici ?
(ordinata? '(1 1 1 1) =)
;-> true

; lista con elementi identici ?
(ordinata? '(3 2 1 1) =)
;-> nil

Per verificare se una lista ha tutti gli elementi identici possiamo usare la seguente funzione:

(define (lista-identica? lst)
  (apply = lst))

; lista con elementi identici ?
(lista-identica? '(2 2 2 2))
;-> true

; lista con elementi identici ?
(lista-identica? '(3 2 1 1))
;-> nil

Possiamo scrivere una funzione più generale che non necessita del parametro relativo all'operatore di confronto e restituisce il tipo di ordinamento della lista.
Usiamo la funzione apply per applicare tutti gli operatori di confronto alla lista:

(apply > '(8 5 3 2))
;-> true

(define (order? lst)
  (cond ((apply =  lst) '= ) ;lista con elementi uguali
        ((apply >  lst) '> ) ;lista strettamente decrescente
        ((apply <  lst) '< ) ;lista strettamente crescente
        ((apply >= lst) '>=) ;lista decrescente
        ((apply <= lst) '<=) ;lista crescente
        (true nil)           ;lista non ordinata
  )
)

(order? '(-1 -1 -1 -1))
;-> =
(order? '(1 2 3 4))
;-> <
(order? '(4 3 2 1))
;-> >
(order? '(4 3 2 1 1))
;-> >=
(order? '(-1 -1 3 4))
;-> <=
(order? '(-1 -2 3 -1))
;-> nil


----------------
Caramelle (Visa)
----------------

Ci sono N bambini in fila. Ad ogni bambino viene assegnato un punteggio.
Devi distribuire caramelle questi bambini in base ai seguenti vincoli:
1. Ogni bambino deve avere almeno una caramella.
2. I bambini con punteggio maggiore ottengono più caramelle rispetto a quelli con punteggio minore (almeno una caramella in più).
3. I bambini che hanno punteggi uguali ottengono lo stesso numero di caramelle
Qual'è il numero minimo di caramelle da distribuire?

Una soluzione semplice è quella di ordinare i punteggi in ordine crescente e poi assegnare le caramelle dando una caramella al punteggio più basso, due caramelle al successivo , tre a quello successivo e così via fino all'ultimo bambino.

(define (caramelle lst)
  (local (somma num doppio)
    (sort lst <)
    (println lst)
    (setq somma 1)
    (setq doppio nil)
    (setq num 1)
    (for (i 1 (sub (length lst) 1))
      (cond ((= (lst i) (lst (sub i 1)))
             (setq doppio true)
             (setq somma (add somma num))
            )
            (true
             (setq doppio nil)
             (++ num) ;aumento le caramelle da distribuire per questo bambino
             (setq somma (add somma num))
            )
      );cond
      ;(println i { } num { } somma)
    );for
    somma
  );local
)

(caramelle '(1 3 3 4))
;-> 8

(caramelle '(0 1 1 1))
;-> 7

(caramelle '(10 2 1 1 1 3 5 4))


-----------------------------------
Unire due liste ordinate (Facebook)
-----------------------------------

L'ordinamento delle liste può essere sia crescente che decrescente. Useremo un parametro "op" con il seguente significato:
- se "op" vale ">" le liste sono ordinate in modo crescente
- se "op" vale "<" le liste sono ordinate in modo decrescente

(define (unisce lst1 lst2 op)
  (local (i j k m n out)
    (if (< (length lst1) (length lst2)) (swap lst1 lst2)) ;la prima lista deve essere più lunga
    (setq m (length lst1))
    (setq n (length lst2))
    (setq i (sub m 1))
    (setq j (sub n 1))
    (setq k (add m n -1))
    (setq out (array (add m n))) ; vettore risultato
    (while (>= k 0)
      (if (or (< j 0) (and (>= i 0) (op (lst1 i) (lst2 j))))
          (begin (setf (out k) (lst1 i))
                 (-- k)
                 (-- i))
          (begin (setf (out k) (lst2 j))
                 (-- k)
                 (-- j))
      )
    )
    (array-list out) ;converte il vettore risultato in lista
  ); local
)

(unisce '(1 2 3 4 5) '(4 5) >)
;-> (1 2 3 4 4 5 5)

(unisce '(4 5) '(1 2 3 4 5) >)
;-> (1 2 3 4 4 5 5)

(unisce '(7 5 4 1) '(6 5 3) <)
;-> (7 6 5 5 4 3 1)


------------------------
Salire le scale (Amazon)
------------------------

Esiste una scala con N scalini e puoi salire di 1 o 2 passi alla volta. Dato N, scrivi una funzione che restituisce il numero di modi unici in cui puoi salire la scala. L'ordine dei passaggi è importante.

Ad esempio, se N è 4, esistono 5 modi unici: (1, 1, 1, 1) (2, 1, 1) (1, 2, 1) (1, 1, 2) (2, 2).

Cosa succede se, invece di essere in grado di salire di 1 o 2 passi alla volta, è possibile salire qualsiasi numero da un insime di interi positivi X? Ad esempio, se X = {1, 3, 5}, potresti salire 1, 3 o 5 passi alla volta.

Questo è un classico problema ricorsivo. Iniziamo con casi semplici e cercando di trovare una regola di calcolo (relazione).

N = 1: [1]
N = 2: [1, 1], [2]
N = 3: [1, 2], [1, 1, 1], [2, 1]
N = 4: [1, 1, 2], [2, 2], [1, 2, 1], [1, 1, 1, 1], [2, 1, 1]

Qual è la relazione?

Gli unici modi per arrivare a N = 3, è di arrivare prima a N = 1, e poi salire di 2 passi, oppure di arrivare a N = 2 e salire di 1 passo. Quindi f(3) = f(2) + f(1).

Questo vale per N = 4? Sì. Dal momento che possiamo arrivare al 4° scalino solo partendo dal 3° scalino e salendo di uno oppure partendo dal 2° scalino e salendo di due. Quindi f(4) = f(3) + f(2).

Generalizziamo, f(n) = f(n - 1) + f(n - 2). Questa è la nota sequenza di Fibonacci.

Versione ricorsiva:

(define (fibo n)
  (if (< n 2) 1
    (+ (fibo (- n 1)) (fibo (- n 2)))))

(fibo 35)
;-> 14930352

(time (fibo 35))
;-> 4456.463

Questa è molto lenta perchè stiamo facendo molti calcoli ripetuti: O(2^N).

Vediamo di velocizzare il calcolo scrivendo una versione ricorsiva memoized e una versione iterativa.

Versione ricorsiva memoized:

(define-macro (memoize mem-func func)
  (set (sym mem-func mem-func)
    (letex (f func c mem-func)
      (lambda ()
        (or (context c (string (args)))
        (context c (string (args)) (apply f (args))))))))

(memoize fibo-m
  (lambda (n)
    (if (< n 2) 1
      (+ (fibo-m (- n 1)) (fibo-m (- n 2))))))

(fibo-m 35)
;-> 14930352

(time (fibo-m 35))
;-> 0

Versione iterativa (che funziona anche per i big integer):

(define (fibo-i n)
  (local (a b c)
    (setq a 0L b 1L c 0L)
    (for (i 0 n)
      (setq c (+ a b))
      (setq a b)
      (setq b c)
    )
    a
  )
)

(fibo-i 35)
;-> 14930352L

(time (fibo-i 35))
;-> 0

Proviamo a generalizzare questo metodo in modo che funzioni usando un numero di passi dall'insieme X.
Un ragionamento simile ci dice che se X = {1, 3, 5}, allora il nostro algoritmo dovrebbe essere f(n) = f(n - 1) + f(n - 3) + f(n - 5).
Se n < 0, allora dobbiamo restituire 0 poiché non possiamo iniziare da un numero negativo di passi.
Se n = 0, allora dobbiamo restituire 1.
Altrimenti dobbiamo restituire ricorsivamente la somma di tutti i risultati delle chiamate alla funzione.

scala(n, X):
    if n < 0:      return 0
    elseif n == 0: return 1
    else: return sum(staircase(n - x, X) for x in X)

Tradotto in newLISP:

(define (scala n lst)
    (if (< n 0)
        0
         (if (= n 0)
            1
            (apply + (map (lambda (x) (scala (sub n x) lst)) lst))
         )
    )
)

(scala 4 '(1 2))
;-> 5

(scala 8 '(4))
;-> 1

(scala 10 '(1 2 3))
;-> 274

(scala 25 '(1 2 3))
;-> 2555757

(time (scala 25 '(1 2 3)))
;-> 2508.452

Anche questo funzione è lenta O(|X|^N), poichè ripetiamo molti calcoli.

Velocizziamo i calcoli scrivendo una versione ricorsiva memoized e una versione iterativa.

Versione ricorsiva memoized:

(define-macro (memoize mem-func func)
  (set (sym mem-func mem-func)
    (letex (f func c mem-func)
      (lambda ()
        (or (context c (string (args)))
        (context c (string (args)) (apply f (args))))))))

(memoize scala-m
  (lambda (n lst)
     (if (< n 0)
        0
         (if (= n 0)
            1
            (apply + (map (lambda (x) (scala-m (sub n x) lst)) lst))
         )
    )
  )
)

(scala-m 4 '(1 2))
;-> 5

(scala-m 8 '(4))
;-> 1

(scala-m 10 '(1 2 3))
;-> 274

(scala-m 25 '(1 2 3))
;-> 2555757

(time (scala-m 25 '(1 2 3)))
;-> 0

Varsione iterativa (programmazione dinamica):

Ogni i-esimo elemento della lista cache conterrà il numero di modi in cui possiamo arrivare al punto i con l'insieme X. Quindi costruiremo la lista da zero utilizzando i valori precedentemente calcolati per trovare quelli successivi:

(define (scala-i num lst)
  (local (ca)
    (setq ca (dup 0 (add num 1)))
    (setf (ca 0) 1)
    (for (i 1 num)
      (dolist (x lst)
        (if (>= (sub i x) 0)
          ;(begin (println "i= " i { } "x= " x)
            (setf (ca i) (add (ca i) (ca (sub i x))))
          ;)
        )
      )
    )
    (ca num)
  );local
)

(scala-i 4 '(1 2))
;-> 5

(scala-i 8 '(4))
;-> 1

(scala-i 10 '(1 2 3))
;-> 274

(scala-i 25 '(1 2 3))
;-> 2555757

(time (scala-i 25 '(1 2 3)))
;-> 0


-----------------------------------------
Numeri interi con segni opposti (MacAfee)
-----------------------------------------

Determinare se due numeri interi hanno segni opposti (true).

Applicando l'operatore bitwise XOR "^" ai quattro casi possibili si ottiene:

(^ -2 3)
;-> -3
(^ -2 -3)
;-> 3
(^ 2 3)
;-> 1
(^ 2 -3)
;-> -1

Vediamo la tavola della verità:

   a   |   b  | XOR | segno
   -----------|-----|-------
  -2   |   3  | -3  | diverso
  -2   |  -3  |  3  | uguale
   2   |   3  |  1  | uguale
   2   |  -3  | -1  | diverso

Possiamo notare che:
- se il risultato dello XOR tra i numeri a e b è negativo, allora i numeri hanno segno diverso.
- se il risultato dello XOR tra i numeri a e b è positivo, allora i numeri hanno segno uguale.

Possiamo scrivere la funzione:

(define (opposti a b)
  (if (> (^ a b) 0) nil true))

(opposti -2 3)
;-> true

(opposti -2 -3)
;-> nil

(opposti 2 3)
;-> nil

(opposti 2 -3)
;-> true


----------------------------
Parità di un numero (McAfee)
----------------------------

Parità: la parità di un numero si riferisce al numero di bit che valgono 1.
Il numero ha "parità dispari", se contiene un numero dispari di 1 bit ed è "parità pari" se contiene un numero pari di 1 bit.

Se n non vale zero, allora creiamo un ciclo che, affinchè n non diventa 0, disattiva a destra uno dei bit impostati a 1 e inverte la parità.
L'algoritmo è il seguente:

A. Inizialmente parità = 0
B. Ciclo while n! = 0
       1. Invertire la parità
          parità = not parità
       2. Annullare il bit 1 più a destra del numero con l'operatore bitwise AND "&"
          n = n & (n-1)
C. Restituire parità (pari o dispari)

Scriviamo la funzione:

(define (parita n)
  (local (out)
    (setq out nil)
    (while (!= n 0)
      (setq out (not out))
      ; annulla il bit più a destra del numero
      (setq n (& n (- n 1))) ; "&" = operatore bitwise AND
      (println n)
    )
    (if (= out true) 'dispari 'pari)
  )
)

Vediamo come funziona (con l'epressione print attivata):

(parita 22) ; 22 -> 10110
;-> 20      ; 20 -> 10100
;-> 16      ; 16 -> 10000
;-> 0       ;  0 -> 0

Per controllare la correttezza utilizziamo le funzioni di conversione tra numero decimale e binario.

(define (bin2dec n)
  (if (zero? n) n
      (+ (% n 10) (* 2 (bin2dec (/ n 10))))))

(define (dec2bin n)
   (if (zero? n) n
       (+ (% n 2) (* 10 (dec2bin(/ n 2))))
   )
)

(dec2bin 1133)
;-> 10001101101

(parita 1133)
;-> pari

(dec2bin 1113)
;-> 10001011001

(parita 1113)
;-> dispari


---------------------------------------
Minimo e massimo di due numeri (McAfee)
---------------------------------------

Scrivere due funzioni per calcolare il minimo e il massimo tra due numeri utilizzando gli operatori bitwise.

Le formule per trovare il minimo e il massimo tra due numeri sono le seguenti:

minimo  = y + ((x - y) & ((x - y) >> (sizeof(int) * CHAR_BIT - 1)))

Questo metodo shifta la sottrazione di x e y di 31 (se la dimensione dell'intero è 32). Se (x-y) è minore di 0, allora ((x-y) >> 31) sarà 1. Se (x-y) è maggiore o uguale a 0, allora ((x - y) >> 31) sarà 0. Quindi se (x >= y), otteniamo il minimo come (y + ((x-y) & 0)) che è y.
Se x < y, otteniamo il minimo come (y + ((x-y) & 1)) che è x.

Allo stesso modo, per trovare il massimo utilizzare la formula:

massimo = x - ((x - y) & ((x - y) >> (sizeof(int) * CHAR_BIT - 1)))

Per interi a 64 bit:

(define (minimo x y)  (+ y (& (- x y) (>> (- x y) 63))))

(define (massimo x y) (- x (& (- x y) (>> (- x y) 63))))

(minimo 10 30)
;-> 10
(minimo 100 30)
;-> 30

Nota: queste funzioni producono un risultato errato per valori maggiori di (2^62 - 1) = 4611686018427387903 o minori di -(2^62 - 1) = -4611686018427387903.


------------------------------
Numero potenza di due (Google)
------------------------------

Determinare se un numero intero positivo n è una potenza di due.

Primo metodo:
Il logaritmo in base 2 di un numero che è una potenza di due è un numero intero.

(define (isPower2 n)
  (if (zero? n) nil
      (= (log n 2) (int (log n 2)))
  )
)

(isPower2 1024)
;-> true

(isPower2 1000)
;-> nil

Secondo metodo:
Un numero potenza di due ha un solo 1 nella sua rappresentazione binaria.

(define (dec2bin n)
   (if (zero? n) n
       (+ (% n 2) (* 10 (dec2bin(/ n 2))))))

(dec2bin 256)
;-> 100000000

(dec2bin 2048)
;-> 100000000000

Questa funzione conta i bit del numero n che hanno valore 1:

(define (bit1 n)
  (let (conta 0)
    (while (> n 0)
       (if (= (% n 2) 1) (++ conta))
       (setq n (/ n 2))
    )
    conta
  )
)

(setq n 1024)
(& n (sub n 1))

(setq n 1000)

(define (isPower2 n)
  (if (= (bit1 n) 1) true nil)
)

(isPower2 1024)
;-> true

(isPower2 1000)
;-> nil

Terzo metodo:
Se sottraiamo il valore 1 ad un numero che è potenza di due, l'unico bit con valore 1 viene posto a 0 e i bit con valore 0 vengono posti a 1:

(dec2bin 1024)
;-> ;-> 10000000000

(dec2bin (sub 1024 1))
;-> 1111111111 ; senza lo zero in testa

Quindi applicando l'operatore bitwise AND "&" ai numeri n e (n - 1) otteniamo 0 se e solo se n è una potenza di due: (n & (n -1)) == 0 se e solo se n è una potenza di due.
Nota: L'espressione n & (n-1) non funziona quando n vale 0.

(define (isPower2 n)
  (if (zero? n) nil
      (if (zero? (& n (sub n 1)) true nil))
  )
)

(isPower2 1024)
;-> true

(isPower2 1000)
;-> nil


----------------------------
Stanze e riunioni (Snapchat)
----------------------------

Data una serie di intervalli di tempo (inizio, fine) per delle riunioni (con tempi che si possono sovrapporre), trovare il numero minimo di stanze richieste.
Ad esempio, la lista ((30 75) (0 50) (60 150)) dovrebbe restituire 2.

Creiamo e ordiniamo due liste "inizio" e "fine", poi le visitiamo in ordine crescente di tempo.
Se troviamo un inizio aumentiamo il numero di stanze, se invece troviamo una fine, allora diminuiamo il numero di stanze.
Inoltre dobbiamo tenere conto del numero massimo di stanze raggiunto.

 | inizio | fine |  tipo  | stanze |
-------------------------------------
 |    0   |      | inizio |    1   |
 |   30   |      | inizio |    2   |
 |        |  50  |  fine  |    1   |
 |   60   |      | inizio |    2   |
 |        |  75  |  fine  |    1   |
 |        | 150  |  fine  |    0   |

(define (min-stanze lst)
  (local (inizio fine stanze_richieste massimo_stanze i j n)
    (setq inizio '())
    (setq fine '())
    (dolist (el lst)
      (push (first el) inizio -1)
      (push (last el) fine -1)
    )
    (sort inizio)
    (sort fine)
    (setq stanze_richieste 0)
    (setq massimo_stanze 0)
    (setq i 0 j 0)
    (setq n (length lst))
    (while (and (< i n) (< j n))
      (if (< (inizio i) (fine j))
        (begin
          (++ stanze_richieste)
          (setq massimo_stanze (max stanze_richieste massimo_stanze))
          (++ i))
        (begin
          (-- stanze_richieste)
          (++ j))
      )
    )
    massimo_stanze
  );local
)

(min-stanze '((20 30) (0 20) (30 40)))
;-> 1

(min-stanze '((30 75) (0 50) (60 150)))
;-> 2

(min-stanze '((90 91) (94 120) (95 112) (110 113) (150 190) (180 200)))
;-> 3

Questo metodo risponde anche ad un'altra domanda:
data una serie di intervalli di tempo, una persona può assistere a tutte le riunioni?
Se il numero minimo di stanze è pari a uno, allora la risposta è affermativa, altrimenti ci sono due o più riunioni che si sovrappongono.
Possiamo risolvere questo problema in modo più semplice.
Se una persona può partecipare a tutte le riunioni, non deve esserci alcuna sovrapposizione tra una riunione e l'altra.
Dopo aver ordinato gli intervalli, possiamo confrontare la "fine" attuale con il prossimo "inizio".

La funzione è la seguente:

(setq lst '((20 30) (0 20) (30 40)))

(define (allMeeting lst)
  (let ((i 0) (out true))
    (sort lst)
    (while (and (< i (- (length lst) 1)) out)
      (if (> (lst i 1) (lst (+ i 1) 0)) (setq out nil))
      (++ i))
    out))

(setq lst '((20 30) (0 20) (30 40)))

(allMeeting lst)
;-> true

(allMeeting '((30 75) (0 50) (60 150)))
;-> nil

(allMeeting '((90 91) (94 120) (95 112) (110 113) (150 190) (180 200)))
;-> nil


----------------------------------
Bilanciamento parentesi (Facebook)
----------------------------------

Data una stringa contenente parentesi tonde, quadre e graffe (aperte e chiuse), restituire
se le parentesi sono bilanciate (ben formate) e rispettano l'ordine ("{}" > "[]" > "()").
Ad esempio, data la stringa "[()] [] {()}", si dovrebbe restituire true.
Data la stringa "([]) [] ({})", si dovrebbe restituire false (le graffe non possono stare dentro le tonde).
Data la stringa "([)]" o "((()", si dovrebbe restituire false.

Usiamo un contatore per ogni tipo di parentesi e verifichiamo la logica corretta durante la scansione della stringa.

La seguente funzione controlla la correttezza delle parentesi:

(define (par s op)
  (local (out p1o p2o p3o ch)
    (setq out true)
    (dostring (c s (= out nil))
      (setq ch (char c))
      (cond ((= ch "(")
              (++ p1o)
            )
            ((= ch "[")
              ; esiste una par "(" non chiusa
              (if (> p1o 0)
                  (setq out nil)
                  (++ p2o)
              )
            )
            ((= ch "{")
              ; esiste una par "(" o "[" non chiusa
              (if (or (> p1o 0) (> p2o 0))
                  (setq out nil)
                  (++ p3o)
              )
            )
            ((= ch ")")
              ; nessuna par "(" da chiudere
              (if (= p1o 0)
                  (setq out nil)
                  (-- p1o)
              )
            )
            ((= ch "]")
              ; esiste una par ")" da chiudere OR
              ; nessuna par "[" da chiudere
              (if (or (> p1o 0) (= p2o 0))
                  (setq out nil)
                  (-- p2o)
              )
            )
            ((= ch "}")
              ; esiste una par ")" da chiudere OR
              ; esiste una par "]" da chiudere OR
              ; nessuna par "{" da chiudere
              (if (or (> p1o 0) (> p2o 0) (= p3o 0))
                  (setq out nil)
                  (-- p3o)
              )
            )
      );cond
    );dostring
    ; controllo accoppiamento parentesi ed errore
    (if (and (zero? p1o) (zero? p2o) (zero? p3o) (= out true))
      true
      nil
    )
  );local
)

(par "{ { ( [ [ ( ) ] ] ) } }")
;-> nil
(par "{ { ( [ [ ( ( ) ] ] ) } }")
;-> nil
(par "{ { [ [ [ ( ) ] ] ] } }")
;-> true
(par "{ { [ [ } } [ ( ) ] ] ]")
;-> nil
(par "{ { [ [ [ ( ) ] ] ] } { [ ( ) ] } }")
;-> true
(par "{ { [ [ [ ( [ ] ) ] ] ] } { [ ( ) ] } }")
;-> nil


------------------------------------------------
K punti più vicini (K Nearest points) (LinkedIn)
------------------------------------------------

Data una lista di N punti (xi, yi) sul piano cartesiano 2D, trova i K punti più vicini ad un punto centrale C (xc, yc). La distanza tra due punti su un piano è la distanza euclidea.
È possibile restituire la risposta in qualsiasi ordine.
Esempi
Input:  punti = ((0,0), (5,4), (3,1)), P=(1,2), K = 2
Output: ((0,0), (3,1))

   5 |
     |
   4 |              X
     |
   3 |  X
     |
   2 |  C
     |
   1 |
     |
   0 X---------------------------
     0  1  2  3  4  5  6  7  8  9

Input:  punti = ((3,3), (5,-1), (-2,4)), P=(0,0), K = 2
Output: ((3,3), (-2,4))

Soluzione A: Ordinamento semplice
Creare una lista con tutte le distanze di ogni punto dal punto centrale. Ordinare la lista delle distanze. Selezionare i primi k punti dalla lista ordinata.

Nota: meglio non usare la funzione sqrt (radice quadrata) nel calcolo della distanza. Le operazioni saranno molto più veloci, soprattutto se i punti hanno coordinate intere.

Lista di punti: ((x0 y0) (x1 y1)...(xn yn))
Punto centrale: P = (xp yp)
Elementi da selezionare: k

;calcola il quadrato della distanza tra due punti
(define (qdist P0 P1)
  (local (x0 y0 x1 y1)
    (setq x0 (first P0))
    (setq y0 (last P0))
    (setq x1 (first P1))
    (setq y1 (last P1))
    ; no radice quadrata (l'ordine dei punti rimane invariato)
    (+ (* (sub x1 x0) (sub x1 x0)) (* (sub y1 y0) (sub y1 y0)))
  )
)

(qdist '(0 0) '(1 1))
;-> 2

(qdist '(1 1) '(1 3))
;-> 4

(define (kClosest punti C k)
  (local (distlst n out)
    (setq out '())
    (setq distlst '())
    (setq n (length punti))
    ; creo la lista delle distanze
    (for (i 0 (- n 1))
      (push (list (qdist (punti i) C) (punti i)) distlst -1)
    )
    (sort distlst) ; sort usa il primo elemento di ogni sottolista
    ;k deve essere minore o uguale a n
    (if (> k n) (setq k n))
    ;trova i k punti con distanza minore dal punto centrale
    (for (i 0 (- k 1))
      (push (distlst i) out -1)
    )
    out
  )
)

(kClosest '((1 1) (8 9) (4 5) (32 12)) '(0 0) 2)
;-> ((2 (1 1)) (41 (4 5)))

Complessità temporale: O(NlogN), dove N è il numero di punti.
Complessità spaziale: O(N).

Soluzione B: Algoritmo Quickselect
Memorizzare tutte le distanze in un array. Trovare l'indice che fornisce l'elemento Kth più piccolo usando un metodo simile al quicksort. Quindi l'elemento dall'indice 0 a (K-1) darà tutti i K punti cercati. Vediamo come funziona questo algoritmo.

Cerchiamo un algoritmo più veloce di NlogN. Chiaramente, l'unico modo per farlo è usare il fatto che i K elementi possono essere in qualsiasi ordine, altrimenti dovremmo fare l'ordinamento che è almeno NlogN.

Supponiamo di scegliere un elemento casuale x = A [i] e di dividere l'array in due parti: una parte con tutti gli elementi minori di x e una parte con tutti gli elementi maggiori o uguali a x. Questo metodo è noto come "quickselect con il pivot x".

L'idea è che selezionando alcuni pivot, ridurremo il problema a metà della dimensione originale in tempo lineare (in media).

La funzione work(i, j, K) ordina parzialmente la sottolista (punti [i], punti [i + 1], ..., punti [j]) in modo che i K elementi più piccoli di questa sottolista si trovino nelle prime posizioni K (i, i + 1, ..., i + K-1).

Innanzitutto, selezioniamo dalla sottolista un elemento casuale da usare come pivot. Per farlo, utilizziamo due puntatori i e j, per spostarsi sugli elementi che si trovano nella parte sbagliata e poi scambiamo questi elementi.

Dopo, abbiamo due parti [oi, i] e [i + 1, oj], dove (oi, oj) sono i valori originali (i, j) quando si chiama work(i, j, K). Supponiamo che la prima parte abbia 10 articoli e che la seconda contenga 15 elementi. Se stessimo cercando di ordinare parzialmente, ad esempio K = 5 elementi, allora abbiamo bisogno di ordinare parzialmente soltanto la prima parte: work(oi, i, 5). Altrimenti, se provassimo a ordinare in parte, K = 17 elementi, allora i primi 10 elementi sono già parzialmente ordinati e abbiamo solo bisogno di ordinare parzialmente i successivi 7 elementi: work(i + 1, oj, 7).

(setq pun '((1 2)(2 2)(4 5)))

(define (kClosest punti C k)
  (local (out)
    ;
    ; Funzione che scambia i valori di due punti
    (define (scambia i j)
      (swap (punti i) (punti j))
    )
    ;
    ; Funzione che calcola il quadrato della distanza
    ; tra il punto C e il punto p(i)
    (define (qdist i)
      (+ (* (sub (first (punti i)) (first C)) (sub (first (punti i)) (first C)))
         (* (sub (last (punti i)) (last C)) (sub (last (punti i)) (last C))))
    )
    ;
    ; Funzione che ordina parzialmente A[i:j+1]
    ; in modo che i primi K elementi siano i più piccoli
    (define (ordina i j k)
      (local (r mid leftH)
        (if (< i j)
            (begin
              ; calcola il pivot
              (setq r (add (rand (+ i 1 (- j))) j))
              (scambia i r)
              (setq mid (partition i j))
              (setq leftH (+ mid 1 (- i)))
              (if (< k leftH)
                  (sort i (- mid 1) k)
              ;else
                  (if (> k leftH)
                    (sort (+ mid 1) j (- k leftH))
                  )
              )
            )
        )
      ); local
    ); ordina
    ;
    ; Partizionamento con il pivot A[i]
    ; Restituisce un indice "mid" tale che:
    ; A[i] <= A[mid] <= A[j] per i < mid < j.
    (define (partition i j)
      (local (oi pivot continua)
        (setq oi i)
        (setq pivot (qdist i))
        (++ i)
        (setq continua true)
        (while continua
          (while (and (< i j) (< (qdist i) pivot))
            (++ i))
          (while (and (<= i j) (> (qdist j) pivot))
            (-- j))
          (if (>= i j)
              (setq continua nil)
              ;(scambia (punti i) (punti j))
              (scambia i j)
          )
        )
        ;(scambia (punti oi) (punti j))
        (scambia oi j)
        j
      )
    );partition
    (ordina 0 (- (length punti) 1) k)
    (slice punti 0 k)
  )
)

(kClosest '((0 0)  (5 4)  (3 1))  '(1 2) 2)
;-> ((0,0), (3,1))

(kClosest '((3 3)  (5 -1) (-2 4)) '(0 0)  2)
;-> ((3 3 ) (-2 4)

(kClosest '((1 1) (8 9) (4 5) (32 12)) '(0 0) 2)
;-> ((1 1) (4 5))

Complessità temporale: in media O(N), dove N è il numero di punti.
Complessità spaziale: O(N)


-----------------------------
Ordinamento colori (LeetCode)
-----------------------------

Data una lista con n elementi che hanno uno dei seguenti valori: "verde", "bianco", "rosso" o "blu". Restituire un'altra lista in modo che gli stessi colori siano adiacenti e l'ordine dei colori sia "verde", "bianco", "rosso" e "blu".
Un colore può non comparire nella lista (es. lista = ("rosso" "verde" "verde" "blu")
Esempio:
Input:  lista = ("rosso" "verde" "bianco" "bianco" "verde" "rosso" "rosso")
Output: lista = ("verde" "verde" "bianco" "bianco" "rosso" "rosso" "rosso")

Per semplificare i calcoli usiamo i numeri 0, 1, 2 e 3 per rappresentare rispettivamente i colori "verde", "bianco",  "rosso" e "blu".

(define (ordinaColori lst)
  (local (val numcolors vec out )
    (setq numcolors (length (unique lst)))
    (setq vec (array numcolors '(0)))
    (setq out '())
    ; riempio il vettore con le frequenze dei numeri (colori)
    (dolist (el lst)
      ; aumentiamo di uno il valore del vettore che si trova all'indice "el"
      (++ (vec el))
    )
    ; per ogni valore del vettore "vec" (vec[i])
    ; inseriamo nella lista l'elemento "i" per vec[i] volte.
    (for (i 0 (- numcolors 1))
      (setq val (vec i))
      (for (j 1 val)
        (push i out -1)
      )
    )
    out
  );local
)

(ordinaColori '(1 2 2 1 1 2 0 0 0 2 2 1))
;-> (0 0 0 1 1 1 1 2 2 2 2 2)

(ordinaColori '(0 1 2 3 0 1 2 3 0 1 2 3))
;-> (0 0 0 1 1 1 2 2 2 3 3 3)


-----------------------------
Unione di intervalli (Google)
-----------------------------

Dato un insieme di intervalli (inizio fine), unire tutti gli intervalli sovrapposti.
Per esempio,

intervalli di ingresso: (8 10) (2 6) (1 3) (15 18)

intervalli di uscita: (1 6) (8 10) (15 18)

     -------
        -------------
                          --------             -----------
  0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18
     ----------------     --------             -----------

(define (unisci-intervalli lst)
  (local (t out)
    (sort lst)
    (setq out '())
    (setq t (first lst))
    (dolist (el lst)
      (if (> $idx 0) ; il primo elemento non ha confronti precedenti
        (begin
          ; confronto tra l'inizio dell'intervallo corrente
          ; e la fine di quello precedente
          (if (<= (first el) (last t))
              (setf (last t) (max (last t) (last el)))
              (begin (push t out -1) (setq t el))
          )
        )
      )
    )
    ; aggiunge l'ultimo invervallo calcolato
    (push t out -1)
    out
  );local
)

(setq lst '((8 10) (2 6) (1 3) (15 18)))

(unisci-intervalli lst)
;-> ((1 6) (8 10) (15 18))

Esempio:

     -------
        -------------
                          --------             -----------
           -------------------
  0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18
     -----------------------------             -----------

(setq lst '((8 10) (1 3) (2 6) (3 9) (15 18)))

(unisci-intervalli lst)
;-> ((1 10) (15 18))


-------------------------------
Somma dei numeri unici (Google)
-------------------------------

In una lista di numeri interi, trovare la somma dei numeri che compaiono una sola volta. Ad esempio, nella lista (4 2 3 1 7 4 2 7 1 7 5), i numeri 1, 2, 4 e 7 appaiono più di una volta, quindi sono esclusi dalla somma e la risposta corretta è 3 + 5 = 8.

Soluzione 1 (ordinamento)

(define (somma-unici lst)
  (local (base conta out)
    (setq out '())
    (sort lst)
    (setq base (first lst))
    (setq conta 1)
    (for (i 1 (- (length lst) 1))
      (if (!= (lst i) base)
        (begin
          (if (= conta 1) (push base out -1))
          (setq base (lst i))
          (setq conta 1)
        )
        (++ conta)
      )
    )
    (apply + out)
  )
)

(somma-unici '(1 2 2 3 4 4 5 5 6 6 6))
;-> 4
(somma-unici '(4 2 3 1 7 4 2 7 1 7 5))
;-> 8
(somma-unici '(1 1 1 2 3 6 6 7 8 8 8))
;-> 12

(time (somma-unici '(4 2 3 1 7 4 2 7 1 7 5)) 10000)
;-> 47.005

Soluzione 2 (hashmap)

(define (somma-unici-2 lst)
  (local (out somma)
    (setq out '())
    (setq somma 0)
    ;crea hashmap
    (new Tree 'myhash)
    ;aggiorna hashmap con i valori della lista (valore contatore)
    (dolist (el lst)
      (if (myhash el)
        ;se esiste il valore aumenta di uno il suo contatore
        (myhash el (+ (int $it) 1))
        ;altrimenti poni il suo contatore uguale a 1
        (myhash el 1)
      )
    )
    ;copia la hashmap su una lista associativa
    (setq out (myhash))
    ;azzera la hashmap
    ;(dolist (el (myhash)) (println el))
    ;(delete 'myhash) ;method 1
    (dolist (el lst) (myhash el nil)) ;method 2
    ;somma i valori unici della lista associativa
    (dolist (el out)
      ;(println (lookup (first el) out))
      (if (= (lookup (first el) out) 1)
        (setq somma (+ somma (int (first el))))
      )
    )
    somma
  )
)

(myhash)
(somma-unici-2 '(1 2 2 3 4 4 5 5 6 6 6))
;-> 4
(somma-unici-2 '(4 2 3 1 7 4 2 7 1 7 5))
;-> 8
(somma-unici-2 '(1 1 1 2 3 6 6 7 8 8 8))
;-> 12

(time (somma-unici-2 '(4 2 3 1 7 4 2 7 1 7 5)) 10000)
;-> 140.011

(time (somma-unici (sequence 1 10000)))
;-> 187.505

(time (somma-unici-2 (sequence 1 10000)))
;-> 406.431

La versione 2 (hashmap) è più lenta della versione 1, ma dovrebbe essere il contrario.
Probabilmente occorre ottimizzare l'uso delle hashmap.


-------------------------------------
Unione di due liste ordinate (Google)
-------------------------------------

Unire due liste ordinate in una terza lista ordinata.

Versione ricorsiva:

(define (merge lstA lstB)
  (define (loop result lstA lstB)
    (cond ((null? lstA) (append (reverse result) lstB))
          ((null? lstB) (append (reverse result) lstA))
          ((< (first lstB) (first lstA))
            (loop (cons (first lstB) result) lstA (rest lstB)))
          (true
            (loop (cons (first lstA) result) (rest lstA) lstB))))
  (loop '() lstA lstB)
)

(setq A '(1 2 3 4 5 6 7 8))
(setq B '(2 3 4 5 11 12 13))

(merge A B)
;-> (1 2 2 3 3 4 4 5 5 6 7 8 11 12 13)
(merge B A)
;-> (1 2 2 3 3 4 4 5 5 6 7 8 11 12 13)

(setq A '(4 5 6 7 8 18 19))
(setq B '(1 2 3 4 5 11 12 13))

(merge A B)
;-> (1 2 3 4 4 5 5 6 7 8 11 12 13 18 19)
(merge B A)
;-> (1 2 3 4 4 5 5 6 7 8 11 12 13 18 19)

Ma la funzione produce un risultato errato se le liste sono ordinate in modo decrescente:

(setq C '(4 3 2))
(setq D '(8 5 3 1))

(merge C D)
;-> (4 3 2 8 5 3 1) ; errore

Per ottenere il risultato corretto è sufficiente modificare l'operatore "<" nella riga:

((< (first lstB) (first lstA))

con l'operatore ">":

((> (first lstB) (first lstA))

Definiamo una funzione in cui l'operatore è un parametro della funzione:

(define (merge lstA lstB op)
  (define (ciclo out lstA lstB)
    (cond ((null? lstA) (extend (reverse out) lstB))
          ((null? lstB) (extend (reverse out) lstA))
          ((op (first lstB) (first lstA))
            (ciclo (cons (first lstB) out) lstA (rest lstB)))
          (true
            (ciclo (cons (first lstA) out) (rest lstA) lstB))))
  (ciclo '() lstA lstB)
)

Per liste ordinate crescenti:

(merge A B <)
;-> (1 2 3 4 4 5 5 6 7 8 11 12 13 18 19)
(merge B A <)
;-> (1 2 3 4 4 5 5 6 7 8 11 12 13 18 19)

Per liste ordinate decrescenti:

(merge C D >)
;-> (8 5 4 3 3 2 1)
(merge D C >)
;-> (8 5 4 3 3 2 1)

Da notare che questa versione ricorsiva produce un errore di stack overflow anche con valori non molto grandi (> 1000):

(merge (sequence 1 1000) (sequence 1 1000) <)
;-> ERR: call or result stack overflow in function < : first
;-> called from user function (loop (cons (first lstB) result) lstA (rest lstB))

Versione iterativa:

(define (merge-i lstA lstB op)
  (local (i j out)
    (setq i 0 j 0 out '())
    ; attraversiamo entrambe le liste
    (while (and (< i (length lstA)) (< j (length lstB)))
      ; troviamo l'elemento minore/maggiore
      ; tra gli elementi correnti delle due liste.
      ; Aggiungiamo l'elemento alla lista out
      ; e incrementiamo l'indice della lista corrispondente
      (if (op (lstA i) (lstB j))
        (begin (push (lstA i) out -1) (++ i))
        (begin (push (lstB j) out -1) (++ j))
      )
    )
    ; Aggiungiamo gli elementi rimanenti della lista lstA (veloce)
    (if (< i (length lstA))
      (extend out (slice lstA i))
    )
    ; Aggiungiamo gli elementi rimanenti della lista lstA (lenta)
    ;(while (< i (length lstA))
    ;  (push (lstA i) out -1)
    ;  (++ i)
    ;)
    ; Aggiungiamo gli elementi rimanenti della lista lstB (veloce)
    (if (< j (length lstB))
      (extend out (slice lstB j))
    )
    ; Aggiungiamo gli elementi rimanenti della lista lstB (lenta)
    ;(while (< j (length lstB))
    ;  (push (lstB j) out -1)
    ;  (++ j)
    ;)
    out
  )
)

(setq A '(1 2 3 4 5 6 7 8))
(setq B '(2 3 4 5 11 12 13))

(merge-i A B <)
;-> (1 2 2 3 3 4 4 5 5 6 7 8 11 12 13)
(merge-i B A <)
;-> (1 2 2 3 3 4 4 5 5 6 7 8 11 12 13)

(setq C '(4 3 2))
(setq D '(8 5 3 1))

(merge-i C D >)
;-> (8 5 4 3 3 2 1)
(merge-i D C >)
;-> (8 5 4 3 3 2 1)

Vediamo la differenza di velocità tra le due funzioni:

(time (merge (sequence 1 500) (sequence 1 200) <) 500)
;-> 1751.43

(time (merge-i (sequence 1 500) (sequence 1 200) <) 500)
;-> 474.117

La versione iterativa è circa 3.5 volte più veloce.

Da notare che la funzione ricorsiva genera un problema con la funzione "time". Infatti ripetendo l'operazione di timing, il tempo di esecuzione aumenta (dovrebbe rimanere costante).

(time (merge (sequence 1 500) (sequence 1 200) <) 500)
;-> 1766.856
(time (merge (sequence 1 500) (sequence 1 200) <) 500)
;-> 2224.526
(time (merge (sequence 1 500) (sequence 1 200) <) 500)
;-> 2720.155
(time (merge (sequence 1 500) (sequence 1 200) <) 500)
;-> 3047.918

Sul forum di newLISP ralph.ronnquist ha proposto la seguente spiegazione:

"Molto probabilmente il problema è nella definizione interna define, che probabilmente finisce per far crescere in qualche modo la tabella dei simboli per ogni nuova definizione.
Prova a risolvere il problema utilizzando la seguente funzione temporanea che viene memorizzata nello heap."

(define (mergeH lstA lstB op)
  (let ((ciclo (fn (out lstA lstB)
                 (cond ((null? lstA) (extend (reverse out) lstB))
                       ((null? lstB) (extend (reverse out) lstA))
                       ((op (first lstB) (first lstA))
                        (ciclo (cons (first lstB) out) lstA (rest lstB)))
                       (true
                        (ciclo (cons (first lstA) out) (rest lstA) lstB))))
               ))
    (ciclo '() lstA lstB)
    ))

"Ciò dovrebbe dare lo stesso risultato, tranne per il fatto che la funzione interna è semplicemente un elemento heap e non si aggiunge alla tabella dei simboli."

Proviamo:

(time (merge (sequence 1 500) (sequence 1 200) <) 500)
;-> 1842.392
(time (merge (sequence 1 500) (sequence 1 200) <) 500)
;-> 2290.107
(time (merge (sequence 1 500) (sequence 1 200) <) 500)
;-> 2831.184
(time (merge (sequence 1 500) (sequence 1 200) <) 500)
;-> 2993.474

Purtroppo anche questa soluzione non risolve il problema.

Il creatore di newLISP Lutz ha scritto:

"Come puoi verificare, stampando con (sys-info) non c'è alcun aumento nei livelli di stack o nelle celle lisp tra le chiamate della funzione "merge". Immagino che la risposta sia nello stack e nella gestione della memoria del sistema operativo."

(dotimes (i 5)
   (println (time (merge (sequence 1 500) (sequence 1 200) <) 500))
   (println (sys-info)))

;-> 1797.074
;-> (1186 576460752303423488 431 3 0 2048 0 2948 10705 1414)
;-> 2265.725
;-> (1186 576460752303423488 431 3 0 2048 0 2948 10705 1414)
;-> 2734.743
;-> (1186 576460752303423488 431 3 0 2048 0 2948 10705 1414)
;-> 3031.553
;-> (1186 576460752303423488 431 3 0 2048 0 2948 10705 1414)
;-> 3437.808
;-> (1186 576460752303423488 431 3 0 2048 0 2948 10705 1414)

Nota: Usare "sys-info" per controllare quello che accade a newLISP dopo o durante l'esecuzione del programma.

Invece rickyboy ha proposto la seguente funzione per "aggirare" il problema:

(define (merge-via-loop lstA lstB op)
  (let (out '())
    (until (or (null? lstA) (null? lstB))
      (push (if (op (first lstB) (first lstA))
                (pop lstB)
                (pop lstA))
            out -1))
    (extend out (if (null? lstA) lstB lstA))))

(merge-via-loop A B <)
;-> (1 2 2 3 3 4 4 5 5 6 7 8 11 12 13)

Vediamo la velocità di esecuzione:

(time (merge-via-loop (sequence 1 500) (sequence 1 200) <) 500)
;-> 46.965

Questa funzione è 10 volte più veloce della versione iterativa.

Infine la versione proposta da ralph.ronnquist:

(define (mergeRR lstA lstB op) (sort (append lstA lstB) op))

(mergeRR A B <)
;-> (1 2 2 3 3 4 4 5 5 6 7 8 11 12 13)

Vediamo la velocità di esecuzione:

(time (mergeRR (sequence 1 500) (sequence 1 200) <) 500)
;-> 203.121

Questa funzione è 2 volte più veloce della versione iterativa.


------------------------------------------------------
Prodotto massimo di due numeri in una lista (Facebook)
------------------------------------------------------

Una soluzione efficiente attraversa la lista una sola volta. La soluzione è quella di attraversare la lista e tenere traccia dei seguenti quattro valori:

1) Valore positivo massimo
2) Secondo valore positivo massimo
3) Valore negativo massimo, ovvero un valore negativo con valore assoluto massimo
4) Secondo valore negativo massimo.

Alla fine del ciclo, confrontare i prodotti dei primi due e degli ultimi due e stampare il massimo di due prodotti.

(setq MAXINT 9223372036854775807)
(setq MININT -9223372036854775808)

(define (pairmax lst)
  (local (a b c d)
    (setq a -9223372036854775808 b -9223372036854775808)
    (setq c -9223372036854775808 d -9223372036854775808)
    (dolist (el lst)
      ; controllo se aggiornare i due valori positivi massimi
      (if (> el a)
          (setq b a a el)
          (if (> el b) (setq b el))
      )
      ; controllo se aggiornare i due valori negativi massimi
      (if (and (< el 0) (> (abs el) (abs c)))
          (setq d c c el)
          (if (and (< el 0) (> (abs el) (abs d))) (setq d el))
      )
    )
    (if (> (* c d) (* a b))
        (list c d (* c d))
        (list a b (* a b))
    )
  )
)

(pairmax '(12 13 11 3 4 -3 -4 45 -34 -15 4))
;-> 45 13 585

(pairmax '(12 13 11 3 4 -3 -4 45 -34 -18 4))
;-> (-34 -18 612)

Complessità temporale: O(n) (lineare)


------------------------------------
Distanza di Hamming tra DNA (Google)
------------------------------------

Date due sequenze di DNA (stringhe), determinare la distanza di Hamming. In pratica, occorre calcolare il numero di caratteri diversi tra due stringhe della stessa lunghezza.

La struttura canonica del DNA ha quattro basi: Adenina (Adenine) (A), Citosina (Cytosine) (C), Guanina (Guanine) (G), e Timina (Thymine) (T).

(define (hamming-dist dna1 dna2)
  (let ((nl1 (explode dna1)) (nl2 (explode dna2)))
    (cond ((= (length nl1) (length nl2)) (length (filter not (map = nl1 nl2))))
          (true (println "Error: different length of DNA.")))))

(setq dna1 "AATCCGCTAG")
(setq dna2 "AAACCCTTAG")

(hamming-dist dna1 dna2)
;-> 3


-------------------------------
Controllo sequenza RNA (Google)
-------------------------------

Verificare se una sequenza RNA (stringa) contiene caratteri diversi da "A", "C", "G" e "U".
La funzione deve restituire la lista dei caratteri diversi (i caratteri multipli devono comparire una sola volta).

La struttura canonica del RNA ha quattro basi: Adenina (Adenine) (A), Citosina (Cytosine) (C), Guanina (Guanine) (G), e Uracile (Uracile) (U).

Il primo algoritmo che viene in mente è quello di scorrere la stringa e collezionare in una lista tutti i caratteri che sono diversi da "A", "C", "G" e "U" (al termine occorre eliminare dalla lista i caratteri multipli).

(define (check-rna rna)
  (let (out '())
    (dolist (el (explode rna))
      (cond ((or (= el "A") (= el "C") (= el "G") (= el "U")) out)
            (true (push el out -1)))) (unique out)))

(setq rna1 "AAUCCGCUAG")
(check-rna rna1)
;-> ()

(setq rna2 "AAACCCUUAG")
(check-rna rna2)
;-> ()

(setq rna3 "ACCGTB ABABAUKL")
(check-rna rna3)
;-> ("T" "B" " " "K" "L")

Utilizzando le funzioni built-in sugli insiemi possiamo scrivere la funzione in un modo diverso:

(define (checkrna dna)
  (difference (explode dna) '("A" "C" "G" "U")))

(checkrna rna1)
;-> ()
(checkrna rna2)
;-> ()
(checkrna rna3)
;-> ("T" "B" " " "K" "L")

Vediamo la differenza di velocità:

(setq rna4
 "AGCBFHTGHFGFHSGBCVGTSGAFSRFDUGDTFGRGFGDGRKIDUHFGUAACGTAGCUBFHTGHFGFHSGBCVGTSGAFSRFDGDTFGR")

(time (check-rna rna4) 25000)
;-> 1174.073

(time (checkrna rna4) 25000)
;-> 524.879

Le funzioni built-in sono sempre molto veloci.


-------------------------
Somma di due box (Amazon)
-------------------------

Un box è una lista di coppie chiave/conteggio: ad esempio, un bag contenente due dell'articolo T, tre dell'articolo K e tre dell'articolo Z può essere scritto T2K3Z3. L'unione di due box è un singolo box contenente un elenco di coppie chiave/conteggio di entrambi i box: se esistono chiavi ripetute tri i due box, allora la coppia risultante ha il suo conteggio sommato: ad esempio, l'unione dei box T2K3Z3 e B1R3K2 vale T2K5Z3B1R3. L'ordine degli articoli nei box non è significativo.

Rappresentiamo un box con una lista associativa.

(setq box1 '((T 2) (K 3) (Z 3)))
(setq box2 '((B 1) (R 3) (K 2)))

(lookup 'K box1)
;-> 3

(lookup 'B box1)
;-> nil

(define (sum-box b1 b2)
  (local (out val)
    ; aggiungiamo il primo box al risultato
    (setq out b1)
    (dolist (el b2)
          ;se la chiave dell'elemento di b2 esiste in out
      (if (lookup (first el) out)
          ; allora somma i due valori in out
          ;(setf (lookup (first el) out) (+ (lookup (first el) out) (last el)))
          ; usiamo la varibile anaforica $it di setf
          (setf (lookup (first el) out) (+ $it (last el)))
          ; altrimenti aggiungi l'elemento di b2 in out
          (push el out -1)
      )
    )
    out
  )
)

(sum-box box1 box2)
;-> ((T 2) (K 5) (Z 3) (B 1) (R 3))

(setq box1 '((T 2) (K 3) (Z 3)))
(setq box2 '((B 1) (R 3) (K 2) (K 2) (B 3)))
(sum-box box1 box2)
;-> ((T 2) (K 7) (Z 3) (B 4) (R 3))


----------------------------
Punti vicini a zero (Amazon)
----------------------------

Dato un milione di punti (x, y), scrivere una funzione per trovare i 100 punti più vicini a (0, 0).

La formula della distanza al quadrato tra due punti in cui uno vale (0 0) è la seguente:

(define (dist0 x y) (add (mul x x) (mul y y)))

La soluzione più semplice (ma non la più veloce) è quella di calcolare la distanza al quadrato per ogni punto e poi ordinare il risultato. La lsita che dovremo ordinare è composta da elementi con la seguente struttura:

(distanza coord-x coord-y)

(define (cento lst)
  (let (out '())
    (dolist (el lst)
      (push (list (dist0 (first el) (last el)) (first el) (last el)) out -1)
    )
    (slice (sort out) 0 99)
  )
)

Proviamo con una lista di 10000 punti:

(setq lst (map (fn(x) (list (+ (rand 10000) 1) (+ (rand 10000) 1))) (sequence 1 10000)))

(cento lst)
;-> ((132994 363 35) (133613 322 173) (142322 331 181)
;-> ...
;-> (12966169 3580 387) (13184525 2830 2275) (13267610 3629 313))

Proviamo con una lista di un milione di punti:

(silent (setq lst (map (fn(x) (list (+ (rand 10000) 1) (+ (rand 10000) 1))) (sequence 1 1000000))))

(time (cento lst))
;-> 1984.666

La funzione impiega quasi due secondi per risolvere il problema. Questo risultato è dovuto principalmente alla velocità della funzione built-in "sort".
Un altro metodo sarebbe quello di inserire i punti mantenendo la lista ordinata durante la costruzione (heap). In questo modo non sarebbe necessario il sort finale, ma solo l'estrazione dei primi cento elementi della lista. Poichè newLISP non ha una struttura heap, la creazione di una struttura heap con le liste sarebbe, probabilmente, più lenta dell'uso della funzione "sort".


------------------------
Trova la Funzione (Uber)
------------------------

Scrivere una funzione f in modo che f(f(n)) = -n per ogni numero intero n.

La prima soluzione che mi è venuta in mente...

(define (nega n) (if (>= n 0) (- n) n))

(nega (nega 3))
;-> -3

Ma la prova con i numeri negativi fallisce (il risultato dovrebbe essere +3):

(nega (nega -3))
;-> -3

L'intuizione è stata quella di separare il segno e la grandezza del numero dalla parità del numero.
Quindi ci sono tre regole:

1) Se il numero è pari, mantenere lo stesso segno e avvicinarsi di 1 a 0 (quindi, sottrarre 1 da un numero pari positivo e aggiungere 1 a un numero pari negativo).

2) Se il numero è dispari, cambiare il segno e spostarsi di 1 più lontano da 0 (quindi, moltiplicare per -1 e sottrarre 1 da un numero dispari positivo e moltiplicare per -1 e aggiungere 1 a un numero pari negativo).

3) Nel caso in cui n vale 0, tutto rimane invariato (lo zero non ha segno, quindi non possiamo cambiarlo)

Ecco la funzione:

(define (f n)
  (cond ((and (> n 0) (even? n)) (- n 1))
        ((and (> n 0) (odd? n))  (- (- n) 1))
        ((and (< n 0) (even? n)) (+ n 1))
        ((and (< n 0) (odd? n))  (+ (- n) 1))
        (true 0)))

(f (f 1))
;-> -1
(f (f -1))
;-> 1

(f (f 3))
;-> -3
(f (f -3))
;-> 3

(f (f 0))
;-> 0

Un altro metodo è quello di considerare il numero n come una lista:

(define (f1 n)
 (if (list? n)
     (- (first n))
     (list n)))

(f1 (f1 -1))
;-> 1
(f1 (f1 1))
;-> -1

(f1 (f1 3))
;-> -3
(f1 (f1 -3))
;-> 3

(f1 (f1 0))
;-> 0

Soluzione proposta da "fdb":

(define-macro (f n) (- (n 1)))

(f (f -1))
;-> 1
(f (f 1))
;-> -1

(f (f 3))
;-> -3
(f (f -3))
;-> 3

(f (f 0))
;-> 0


------------------------------------------
Prodotto scalare minimo e massimo (Google)
------------------------------------------

Siano date due liste L1 = (a1 a2 ... an) e L2 = (b1 b2 ... bn). Il prodotto scalare delle due liste vale:

PS = (a1*b1 + a2*b2 + ... + an*bn)

Scrivere due funzioni che, modificando la posizione degli elementi delle due liste, producano il prodotto scalare minimo e il prodotto scalare massimo.

Prima scriviamo una funzione che realizza il prodotto scalare tra due liste:

(define (scalare lst1 lst2) (apply + (map * lst1 lst2)))

(scalare '(1 2) '(3 4))
;-> 11

Il prodotto scalare minimo si ha quando una lista viene ordinata in ordine crescente e l'altra lista viene ordinata in ordine decrescente.

Quindi scriviamo la funzione che calcola il prodotto scalare minimo:

(define (ps-min lst1 lst2) (scalare (sort lst1 <) (sort lst2 >)))

(ps-min '(1 3 -5) '(-2 4 1))
;-> -25

(ps-min '(1 2 3 4 5) '(1 0 1 0 1))
;-> 6

Il prodotto scalare massimo si ha quando entrambe le liste vengono ordinate allo stesso modo (crescente o decrescente).

Quindi scriviamo la funzione che calcola il prodotto scalare massimo:

(define (ps-max lst1 lst2) (scalare (sort lst1 >) (sort lst2 >)))

(ps-max '(1 3 -5) '(-2 4 1))
;-> 23

(ps-max '(1 2 3 4 5) '(1 0 1 0 1))
;-> 12


-------------------
25 numeri (Wolfram)
-------------------

Data una lista di 25 numeri positivi diversi, sceglierne due di questi in modo tale che nessuno degli altri numeri sia uguale alla loro somma o alla loro differenza.

Invece utilizzare un metodo brute-force possiamo ordinare in modo crescente la lista in modo che risulti:
 x(1) < x(2) < ... < x(n)
Se x(n) non è disponibile per essere preso come uno dei desiderati numeri, deve risultare che per ogni numero inferiore x(i), c'è un altro x(j) tale che x(i) + x(j) = x(n). Pertanto, i primi 24 numeri sono associati in modo tale che x(i) + x(n-i-1) = x(n). Ora considera x(n-1) accoppiato ad uno qualsiasi dei numeri x(2), ... ,x(n-2): queste coppie sommano a più di x(n) = x(n-i) + x(1) e quindi anche x2, ..., x(n-2) deve essere accoppiato, questa volta risultando x(2+i) + x(n-2-i) = x(n-1).
Ma questo lascia x((n-1)/2) accoppiato con se stesso, quindi i numeri x(n-1) e x((n-1)/2) risolvono il problema.
Poichè le liste di newLISP sono zero-based (il primo elemento ha indice zero), i numeri che risolvono il problema sono x(23) e x(11).

Scriviamo le funzioni:

Genera un numero compreso tra "a" e "b":

(define (rand-range a b)
  (if (> a b) (swap a b))
  (+ a (rand (+ (- b a) 1))))

Crea una lista con tutti i valori di una hashmap:

(define (getValues hash)
  (local (out)
    (dolist (cp (hash))
      (push (cp 1) out -1)
    )
  out
  )
)

Genera una lista con ordinata in modo crescente con 25 numeri casuali diversi e compresi tra "a" e "b":

(define (sample n a b)
  (local (value out)
    ; creazione di un hashmap
    (new Tree 'hset)
    (until (= (length (hset)) n)
      ; genera valore casuale
      (setq value (rand-range a b))
      ; inserisce valore casuale nell'hash
      (hset (string value) value))
      ; assegnazione dei valori dell'hasmap ad una lista
      (setq out (getValues hset))
      ; eliminazione dell'hashmap
      (delete 'hset)
      (sort out)))

(sample 50 1 1000)
;-> (2 5 9 15 24 57 58 64 92 93 109 120 142 143 148 152
;->  166 167 169 175 194 206 210 226 236 267 273 276 298
;->  302 304 346 351 353 362 365 376 378 386 393 426 427
;->  446 451 458 463 469 480 485 492 505 514 518 520 532
;->  540 564 572 573 586 588 600 602 608 609 612 658 664
;->  678 692 693 700 711 727 736 744 745 747 752 780 784
;->  803 809 823 838 841 844 859 863 876 896 906 919 926
;->  950 956 989 990 997 1000)

(setq lst '(2 5 9 15 24 57 58 64 92 93 109 120 142 143 148 152
 166 167 169 175 194 206 210 226 236 267 273 276 298
 302 304 346 351 353 362 365 376 378 386 393 426 427
 446 451 458 463 469 480 485 492 505 514 518 520 532
 540 564 572 573 586 588 600 602 608 609 612 658 664
 678 692 693 700 711 727 736 744 745 747 752 780 784
 803 809 823 838 841 844 859 863 876 896 906 919 926
 950 956 989 990 997 1000))

Funzione che risolve il problema:

(define (solve lst)
  (list (lst 23) (lst 11)))

Proviamo:

(solve lst)
;-> (226 120)

Quindi la soluzione vale a = 226 e b = 120

Per verificare la soluzione generiamo una lista con tutte le somme e le differenze tra tutti i numeri della lista (Per fare questo usiamo una versione modificata della funzione che calcola il prodotto scalare tra due liste) e poi controlliamo se (a - b) o (a + b) o (b - a) si trovano o meno nella lista.

(define (make-calc lst1 lst2 func)
  (let (out '())
    (if (or (null? lst1) (null? lst2))
        nil
        (dolist (el1 lst1)
          (dolist (el2 lst2)
            (push (func el1 el2) out -1))))))

(make-calc '(1 2 3) '(1 2 3) +)
;-> (2 3 4 3 4 5 4 5 6)
(make-calc '(1 2 3) '(1 2 3) -)
;-> (0 -1 -2 1 0 -1 2 1 0)

Funzione che controlla se (a + b) o (a - b) o (b - a) sono presenti nella lista completa di tutte le somme e di tutte le differenze dei 25 numeri della lista iniziale:

(define (check-num lst a b)
  (local (calc)
    (setq calc (union (make-calc lst lst +) (make-calc lst lst -)))
    (cond ((= true (find (- a b) calc)) true)
          ((= true (find (- b a) calc)) true)
          ((= true (find (+ a b) calc)) true)
          (true nil))))

(check-num lst 226 120)
;-> nil

Proviamo il tutto con un nuovo esempio:

(setq lst (sample 50 1 100))
;-> (1 2 4 6 9 10 11 13 14 17 26 28 29 30 31 32 33 34
;->  35 41 42 43 44 46 48 52 53 54 55 57 58 62 63 64
;->  66 67 68 69 70 71 73 77 79 81 86 89 92 93 95 99)

(setq sol (solve lst))
;-> (46 28)

(setq a (first sol))
;-> 46

(setq b (last sol))
;-> 28

(check-num lst a b)
;-> nil


------------------------
Le cento porte (Wolfram)
------------------------

Date cento porte tutte chiuse, cento studenti affettuano la seguente operazione:

lo studente i-esimo cambia lo stato (apre o chiude) della porta i-esima e di tutte le porte multiple di i.

In altre parole,
lo studente 1 cambia lo stato (apre) la porta 1 e tutte le porte multiple di 1 (cioè tutte le porte)
lo studente 2 cambia lo stato (chiude) della porta 2 e di tutte le porte multiple di 2
lo studente 3 cambia lo stato (apre o chiude) della porta 3 e di tutte le porte multiple di 3
...
lo studente 100 cambia lo stato (apre o chiude) della porta 100

Quali porte rimangono aperte? Perchè?

Scriviamo prima la funzione considerando una lista di cento elementi in cui "1" rappresenta la porta chiusa e "0" rappresenta la porta aperta:

(define (porte? n stampa)
  (local (porte)
    ; partiamo con centouno porte tutte aperte
    ; cioè con valore 1
    ; (consideriamo il primo studente già passato)
    (setq porte (dup 1 (+ n 1)))
    ; tranne la porta 0 che non ci serve
    (setf (porte 0) 0)
    ; per ogni studente...
    (for (s 2 n) ; il primo studente è passato
      ; per ogni porta multipla di s...
      (for (p s n s)
        ; cambiamo lo stato della porta
        (if (= (porte p) 1)
          (setf (porte p) 0)
          (setf (porte p) 1))
      )
      ; stampa dello stato delle porte ad ogni passaggio
      (if stampa (println s { -> } porte))
    )
    porte))

Proviamo a vedere cosa accade con 10 porte:

(porte? 10 true)
;->  2 -> (0 1 0 1 0 1 0 1 0 1 0)
;->  3 -> (0 1 0 0 0 1 1 1 0 0 0)
;->  4 -> (0 1 0 0 1 1 1 1 1 0 0)
;->  5 -> (0 1 0 0 1 0 1 1 1 0 1)
;->  6 -> (0 1 0 0 1 0 0 1 1 0 1)
;->  7 -> (0 1 0 0 1 0 0 0 1 0 1)
;->  8 -> (0 1 0 0 1 0 0 0 0 0 1)
;->  9 -> (0 1 0 0 1 0 0 0 0 1 1)
;-> 10 -> (0 1 0 0 1 0 0 0 0 1 0)
;-> (0 1 0 0 1 0 0 0 0 1 0)

Quindi rimangono aperte le porte 1, 4 e 9.

Proviamo con 100 porte stampando solo gli indici degli elementi che hanno valore 1 (cioè stampiamo i numeri di tutte le porte aperte):

(dolist (el (porte? 100 nil)) (if (= el 1) (print $idx { })))
;-> 1 4 9 16 25 36 49 64 81 100 " "

Si nota che rimangono solo i numeri che sono quadrati perfetti.

Spiegazione:
Lo stato della porta n-esima cambia con lo studente k-esimo per tutti i valori in cui k è divisore di n. I divisori di un numero sono accoppiati (k e j) poichè risulta  n = k * j, cioè k = n / j e j = n / k. Quindi ogni coppia cambia due volte lo stato di una porta (una volta con lo studente k e una volta con lo studente j) lasciando lo stato finale invariato.
Osserviamo che la coppia non esiste quando abbiamo un quadrato perfetto in quanto n = k * k e non esistono studenti con lo stesso numero k. In altre parole, quando lo studente k-esimo passa sulla porta k*k non ha uno studente con il valore corrispondente (k) che cancella la sua modifica. Le porte che sono un quadrato perfetto ricevono un numero dispari di cambiamenti di stato e quindi al termine dei passaggi restano aperte.


-------------------------------------
Insiemi con la stessa somma (Wolfram)
-------------------------------------

Verificare la seguente affermazione:

" Ogni insieme di 10 numeri distinti nell'intervallo [1..100] ha due sottoinsiemi disgiunti non vuoti cha hanno la stessa somma."

Per esempio, l'insieme (1 3 7 76 34 36 4 55 71 88) ha due sottoinsiemi non vuoti (a1 a2...) e (b1 b2...) che hanno la stessa somma.

Il numero di sottoinsiemi di un insieme con n elementi vale (2^n - 1). Si tratta del numero di elementi dell'insieme delle parti (powerset) meno l'insieme vuoto.

Per generare tutti i sottoinsiemi utilizziamo la funzione "powerset-i":

(define (powerset-i lst)
  (define (loop res s)
    (if (empty? s)
      res
      (loop (append (map (lambda (i) (cons (first s) i)) res) res) (rest s))))
  (loop '(()) lst))

(powerset-i '(1 2 3))
;-> ((3 2 1) (3 2) (3 1) (3) (2 1) (2) (1) ())

(length (powerset-i '(1 3 7 76 34 36 4 55 71 88)))
;-> 1024

Adesso dobbiamo sommare tutti i numeri di ogni sottoinsieme e verificare se esiste almeno una coppia di elementi con lo stesso valore.

Mentre scrivevo la funzione che verifica se esiste una coppia di valori uguali in una lista, ho avuto l'intuizione per dimostrare matematicamente l'affermazione del problema.

Ma andiamo con ordine.

Per verificare se esistono elementi doppi in una lista possiamo utilizzare diversi metodi:

1) doppio ciclo sulla lista (il primo prende un elemento alla volta e il secondo controlla se quell'elemento si trova sulla lista)

2) ciclo unico (ogni elemento viene inserito in una hashmap se non è già presente)

3) ciclo unico con una lista di controllo che ha dimensione pari al valore del numero massimo della lista (inizializzo la lista di controllo con tutti 0, poi, per ogni elemento della lista dei numeri imposto il valore 1 all'elemento della lista di controllo che ha indice pari al numero).

Il problema di questa ultima tecnica è che per conoscere il valore massimo contenuto nella lista dei numeri occorrerebbe utilizzare un altro ciclo. Inoltre tale valore massimo potrebbe essere talmente grande da richiedere una lista di controllo enorme.
Per fortuna possiamo calcolare a priori questo valore massimo, senza effettuare alcun ciclo sulla lista. In una lista di 10 numeri in cui i numeri sono diversi e possono variare da 1 a 100, il valore massimo (somma massima) è dato dalla lista (100 99 98 87 96 95 94 93 92 91), la cui somma vale:

(+ 100 99 98 87 96 95 94 93 92 91)
;-> 945

Quindi possiamo scrivere la funzione per la ricerca degli elementi doppi utilizzando una lista di controllo con 1000 elementi.

(define (checkdouble lst)
  (local (board found out)
    (setq board (dup 0 1001))
    (setq found nil)
    (setq out '())
    (dolist (el lst found)
      (if (= (board el) 1)
        (setq found true out el)
        (setf (board el) 1)))
    out))

(checkdouble '(1 2 4 5 6 7 8 9))
;-> ()

(checkdouble '(1 2 4 5 6 1 7 8 9 2))
;-> 1

(define (checksum lst)
  (local (somme)
    ; generiamo il powerset e calcoliamo la somma di ogni sottoinsieme
    (setq somme (map (fn(x) (apply + x)) (powerset-i lst)))
    ; verifichiamo se esistono elementi doppi)
    (checkdouble somme)))

(checksum (randomize (slice (sequence 1 100) 1 10)))
;-> 50

(checksum (randomize (slice (sequence 1 100) 1 10)))
;-> 55

Adesso proviamo 10000 volte per vedere se la funzione restituisce sempre un valore (cioè, se esiste sempre almeno un elemento doppio):

(for (i 1 10000)
  (if (= (checksum (randomize (slice (sequence 1 100) 1 10))) '())
    (println "error")))
;-> nil

Sembra che l'affermazione sia vera.
Adesso dovremmo verificare che gli insiemi che hanno la stessa somma siano disgiunti (cioè non abbiamo elementi in comune). Ma non è necessario scrivere codice, perchè anche se gli insiemi avessero degli elementi in comune, possiamo sempre eliminare questi elementi da entrambi gli insiemi mantenendo uguali le somme dei numeri di entrambi gli insiemi (e rendendo in questo modo gli insiemi disgiunti).

La funzione che abbiamo scritto non prova che l'affermazione sia vera. Possiamo provarla con il seguente ragionamento:

- il numero di somme possibili vale il numero di elementi del powerset (meno l'insieme vuoto), cioè (2^10 - 1) = 1023

- il numero di somme diverse può essere al massimo 945 (che è il valore massimo di una somma)

Quindi abbiamo 1023 somme con 945 valori diversi, per il "principio dei cassetti" ci deve essere per forza almeno due somme con lo stesso valore.

Il principio dei cassetti (pigeon-hole principle), detto anche legge del buco della piccionaia, afferma che se (n + k) oggetti sono messi in n cassetti, allora almeno un cassetto deve contenere più di un oggetto. Formalmente, il principio afferma che se A e B sono due insiemi finiti e B ha cardinalità strettamente minore di A, allora non esiste alcuna funzione iniettiva da A a B.

Nel nostro caso non possiamo riempire 1023 cassetti con solo 945 somme diverse, qualche cassetto deve per forza contenere una somma uguale a quella di un altro cassetto.

Spesso il ragionamento evita di scrivere codice inutile.


------------------------------------
Tripartizione di un intero (Wolfram)
------------------------------------

Quesito A
---------
Dato un numero intero positivo n, trovare i numeri interi positivi x, y e z tale che

1) x * y * z = n

2) x + y + z sia minimo

Ad esempio, dato n = 1890, la risposta corretta è (9 14 15).

Risolviamo il problema con un metodo brute-force: due cicli per x e y che vanno da 1 a n (con alcune piccole ottimizzazioni).

(define (solve n)
  (local (minimo out)
    (setq out 0)
    (setq minimo 999999999)
    ; i arriva fino (sqrt n) + 1
    (for (i 1 (+ (int (sqrt n) 1)))
      ; j parte da i e arriva fino (sqrt n) + 1
      (for (j i (+ (int (sqrt n) 1)))
        (if (zero? (% n (* i j)))
            (if (< (+ i j (/ n (* i j))) minimo)
                (begin
                  (setq out (list i j (/ n (* i j))))
                  (setq minimo (+ i j (/ n (* i j))))))))) out))

(solve 1890)
;-> (9 14 15)

(solve 10000)
;-> (20 20 25)

(solve 1000001)
;-> (1 101 9901)

(solve 123456789)
;-> (9 3607 3803)

(time (solve 123456789))
;-> 6270.58

Nota: Il programma dovrebbe avere un controllo per verificare se n è un numero primo, nel qual caso la soluzione vale (1 1 n).

(solve 48611)
;-> (1 1 48611)

Quesito B
---------
Dato un numero intero positivo n, trovare i numeri interi positivi x, y e z tale che

1) x * y * z = n

2) x + y + z = n

Le soluzioni al sistema (intere e reali/complesse) sono le seguenti:

1) x = 0, z = -y, n = 0

2) x != 0
   y = (n Sqrt[x] - x^(3/2) - Sqrt[-4 n + n^2 x - 2 n x^2 + x^3])/(2 Sqrt[x])
   z = (n Sqrt[x] - x^(3/2) + Sqrt[-4 n + n^2 x - 2 n x^2 + x^3])/(2 Sqrt[x])

3) x != 0
   y = (n Sqrt[x] - x^(3/2) + Sqrt[-4 n + n^2 x - 2 n x^2 + x^3])/(2 Sqrt[x])
   z = (n Sqrt[x] - x^(3/2) - Sqrt[-4 n + n^2 x - 2 n x^2 + x^3])/(2 Sqrt[x])

Invece di utilizzare le soluzioni sopra, modifichiamo la funzione solve per controllare se x + y + x = n:

(define (solve2 n)
  (local (tri val)
    (setq tri '())
    (for (i 1 (+ (int (sqrt n) 1)))
      (for (j i (+ (int (sqrt n) 1)))
        (setq val (% n (* i j)))
        (if (zero? val)
          (if (= (+ i j (/ n (* i j))) n)
            (push (list i j (/ n (* i j))) tri -1)))) tri)))

(solve2 3)
;-> '()

Calcoliamo solve2 con valori da 1 a 1000 per vedere se esiste qualche soluzione:

(define (test100) (for (k 3 1000) (if (!= (solve k) '()) (println (solve k)))))

(test100)
;-> ((1 2 3) (1 3 2) (2 1 3) (2 3 1) (3 1 2) (3 2 1))

Intuitivamente, l'unico numero n per cui risulta (x*y*z = x+y+z = n) vale sei (6), con x = 1, y = 2 e z = 3. Per dimostrarlo supponiamo che risulti (a<=b<=c), quindi (a*b*c = a+b+c <= 3*c). Adesso abbiamo due casi:

1) c = 0, quindi a = b = c = 0

2) a*b <= 3, quindi le quattro possibilità sono (a=0), (a=1, b=1), (a=1, b=2), (a=1, b=3).

Per esclusione, l'unica soluzione vale: (a=1, b=2, c=3).


---------------------
Cifre stampate (Uber)
---------------------

Quesito 1
---------
Quante cifre occorrono per numerare N pagine (facciate) di un libro?

Esempio:
Libro di 10 pagine => 1 2 3 4 5 6 7 8 9 10 => 12345678910 ==> 11 cifre

Nota: la funzione "length" di newLISP restituisce anche la lunghezza di un numero intero.

(define (num-cifre pagine)
  (let (cifre 0)
    (for (i 1 pagine)
      (setq cifre (+ cifre (length i))))))

(num-cifre 562)
;-> 1578

Altro metodo:

(define (num-cifre pagine)
  (apply + (map length (sequence 1 pagine))))

Quesito 2
---------
Quante pagine (facciate) sono state numerate se abbiamo utilizzato D cifre?

Vediamo una soluzione con la forza bruta.

(define (num-pagine cifre)
  (let ((pagine 0) (found nil))
    (until found
      (++ pagine)
      (if (>= (num-cifre pagine) cifre) (setq found true))
    )
    (list pagine (- cifre (num-cifre pagine)))))

(num-pagine 1578)
;-> (562 0) ; 562 pagine esatte

(num-pagine 12300)
;-> (3352 -1) ; manca una cifra per numerare 3352 pagine

(num-pagine 14998)
;-> (4027 -3) ; mancano tre cifre per numerare 4027 pagine

(num-pagine 100000)
;-> (22222 -4) ; mancano 4 cifre per numerare 22222 pagine


-----------------------------
Travasi di liquidi (Facebook)
-----------------------------

Abbiamo due recipienti (1 e 2) che contengono due liquidi diversi (A e B).
All'inizio il recipiente 1 contiene 100 litri del liquido A e 0 litri del liquido B, mentre il recipiente 2 contiene 0 litri del liquido A e 100 litri del liquido B.

Quesito 1
---------
Supponiamo di travasare 10 litri dal recipiente 1 al recipiente 2, poi travasiamo 10 litri dal recipiente 2 al recipiente 1.
È maggiore il liquido B nel recipiente 1 oppure è maggiore il liquido A nel recipiente 2 ?

Il risultato è che sono uguali. Non c'è bisogno di fare calcoli, basta notare che, dopo i due travasi, i livelli dei liquidi nei recipienti sono gli stessi di prima, quindi gli scambi dei liquidi A e B devono essere gli stessi.

Quesito 2
---------
Scrivere una funzione che permette di travasare il liquido da un recipiente ad un altro, in modo che, al termine del travaso, si conoscano sia il numero di litri totale di ogni recipiente, sia la percentuale dei liquidi contenuta in ogni recipiente (e quindi il numero di litri dei liquidi A e B che si trovano in ogni recipiente.)

Partiamo da questa situazione iniziale:
; numero litri bottiglia 1
(setq bot1 100)
; percentuale del liquido A nella bottiglia 1
(setq p1A 100)
; percentuale del liquido B nella bottiglia 1
(setq p1B 0)
; numero litri bottiglia 2
(setq bot2 100)
; percentuale del liquido A nella bottiglia 2
(setq p2A 0)
; percentuale del liquido B nella bottiglia 2
(setq p2B 100)

Funzione che calcola la quantità dato il totale e la percentuale:

(define (quanto val perc) (mul val (div perc 100)))

Funzione di travaso da 1 a 2:

(define (travaso-12 litri)
  (local (qa qb)
    (setq qa (quanto litri p1A))
    (setq qb (quanto litri p1B))
    ;(println qa { } qb)
    (setq p1A p1A) ;non cambia
    (setq p1B p1B) ;non cambia
    (setq p2A (mul 100 (div (add (quanto bot2 p2A) qa) (add bot2 qa qb))))
    (setq p2B (mul 100 (div (add (quanto bot2 p2B) qb) (add bot2 qa qb))))
    (setq bot1 (sub bot1 qa qb))
    (setq bot2 (add bot2 qa qb))
    ;(println bot1 { } p1A { } p1B { } bot2 { } p2A { } p2B)
    (println "Bottiglia 1: " bot1 " litri")
    (println "   liquido A: " (mul bot1 (div p1A 100)) " litri (" p1A"%)")
    (println "   liquido B: " (mul bot1 (div p1B 100)) " litri (" p1B"%)")
    (println "Bottiglia 2: " bot2 " litri")
    (println "   liquido A: " (mul bot2 (div p2A 100)) " litri (" p2A"%)")
    (println "   liquido B: " (mul bot2 (div p2B 100)) " litri (" p2B"%)")
    (list bot1 (mul bot1 (div p1A 100)) (mul bot1 (div p1B 100))
          bot2 (mul bot2 (div p2A 100)) (mul bot2 (div p2B 100)))
  ))

Funzione di travaso da 2 a 1:

(define (travaso-21 litri)
  (local (qa qb)
    (setq qa (quanto litri p2A))
    (setq qb (quanto litri p2B))
    ;(println qa { } qb)
    (setq p2A p2A) ;non cambia
    (setq p2B p2B) ;non cambia
    (setq p1A (mul 100 (div (add (quanto bot1 p1A) qa) (add bot1 qa qb))))
    (setq p1B (mul 100 (div (add (quanto bot1 p1B) qb) (add bot1 qa qb))))
    (setq bot1 (add bot1 qa qb))
    (setq bot2 (sub bot2 qa qb))
    ;(println bot1 { } p1A { } p1B { } bot2 { } p2A { } p2B)
    (println "Bottiglia 1: " bot1 " litri")
    (println "   liquido A: " (mul bot1 (div p1A 100)) " litri (" p1A"%)")
    (println "   liquido B: " (mul bot1 (div p1B 100)) " litri (" p1B"%)")
    (println "Bottiglia 2: " bot2 " litri")
    (println "   liquido A: " (mul bot2 (div p2A 100)) " litri (" p2A"%)")
    (println "   liquido B: " (mul bot2 (div p2B 100)) " litri (" p2B"%)")
    (list bot1 (mul bot1 (div p1A 100)) (mul bot1 (div p1B 100))
          bot2 (mul bot2 (div p2A 100)) (mul bot2 (div p2B 100)))
  ))

Se travasiamo per 10 volte 10 litri da 1 a 2 partendo dalla situzione iniziale otteniamo:

(dotimes (x 10) (travaso-12 10))
;-> Bottiglia 1: 0 litri
;->    liquido A: 0 litri (100%)
;->    liquido B: 0 litri (0%)
;-> Bottiglia 2: 200 litri
;->    liquido A: 99.99999999999999 litri (49.99999999999999%)
;->    liquido B: 100 litri (50.00000000000002%)
;-> (0 0 0 200 99.99999999999999 100)

Adesso, se travasiamo per 10 volte 10 litri da 2 a 1 torniamo alla situazione di partenza, ma con i liquidi mescolati al 50% su entrambi i recipienti:

(dotimes (x 10) (travaso-21 10))
;-> Bottiglia 1: 100 litri
;->    liquido A: 49.99999999999999 litri (49.99999999999999%)
;->    liquido B: 50.00000000000001 litri (50.00000000000001%)
;-> Bottiglia 2: 100 litri
;->    liquido A: 49.99999999999999 litri (49.99999999999999%)
;->    liquido B: 50.00000000000002 litri (50.00000000000002%)
;-> (100 49.99999999999999 50.00000000000001 100 49.99999999999999 50.00000000000002)

Adesso verifichiamo il primo quesito, travasiamo 10 litri da 1 a 2 e poi 10 litri da 2 a 1:

(travaso-12 10)
;-> Bottiglia 1: 90 litri
;->    liquido A: 90 litri (100%)
;->    liquido B: 0 litri (0%)
;-> Bottiglia 2: 110 litri
;->    liquido A: 10 litri (9.090909090909092%)
;->    liquido B: 100 litri (90.90909090909091%)
;-> (90 90 0 110 10 100)

(travaso-21 10)
;-> Bottiglia 1: 100 litri
;->    liquido A: 90.90909090909091 litri (90.90909090909091%)
;->    liquido B: 9.09090909090909 litri (9.09090909090909%)
;-> Bottiglia 2: 100 litri
;->    liquido A: 9.090909090909092 litri (9.090909090909092%)
;->    liquido B: 90.90909090909091 litri (90.90909090909091%)
;-> (100 90.90909090909091 9.09090909090909 100 9.090909090909092 90.90909090909091)

La quantità di liquido B nella bottiglia 1 è uguale alla quantità di liquido A nella bottiglia 2 (9.0909...).
La quantità di liquido A nella bottiglia 1 è uguale alla quantità di liquido B nella bottiglia 2 (90.0909...).


--------------------------
Cambio monete 1 (LinkedIn)
--------------------------

Dato un numero N e una lista di numeri M (m1, m2, ..., mm). Determinare in quanti modi è possibile sommare i numeri per avere N. È possibile utilizzare ogni elemento della lista M infinite volte.
In altre parole, data una cifra N e un insieme di monete (m1, m2, ..., mm), in quanti modi possiamo 'spicciare' la cifra N ?

Per contare il numero totale di soluzioni, possiamo dividere tutte le soluzioni in due insiemi:

1) Soluzioni che non contengono la moneta i-esima mi.
2) Soluzioni che contengono almeno una moneta mi.

Sia conta(Monete, m, N) la funzione per contare il numero di soluzioni, questa può essere scritta come somma di conta(Monete, m-1, N) e conta(Monete, m, N - mi).
Quindi il problema può essere risolto in modo ricorsivo.

(define (conta monete num cifra)
  (cond ((zero? cifra) 1) ;se cifra vale 0, allora una soluzione
        ((< cifra 0) 0)   ;se cifra minore di 0, allora nessuna soluzione
        ; se non ci sono monete e la cifra è maggiore di zero,
        ; allora nessuna soluzione
        ((and (<= num 0) (>= cifra 1)) 0)
        (true
          (println (monete (- num 1)))
          (+ (conta monete (- num 1) cifra)
               (conta monete num (- cifra (monete (- num 1)))))
        )))

(conta '(2 3 5 6) 4 10)
;-> 5
(2 2 2 2 2)
(2 2 3 3)
(2 2 6)
(2 3 5)
(5 5)

(conta '(1 2 3) 3 4)
;-> 4
(1 1 1 1 1)
(1 1 2)
(2 2)
(1 3)

(conta '(5 10) 2 11)
;-> 0

(conta '(2 3) 2 13)
;-> 2
(2 2 2 2 2 3)
(2 2 3 3 3)

(conta '(3 4) 2 17)
;-> 1
(3 3 3 4 4)

Il problema può essere risolto anche con la programmazione dinamica.

(define (conta monete num cifra)
  ; vett[i] memorizza il numero di soluzioni per il valore i.
  ; Servono (n + 1) righe perchè la tabella viene costruita
  ; in modo bottom-up usando il caso base (n = 0).
  (let ((vett (array (+ cifra 1) '(0)))
        (i 0)
        (j 0))
    ; caso base
    (setf (vett 0) 1)
    ; Prende tutte le monete una per una e aggiorna i valori
    ; di vett dove l'indice è maggiore o uguale a quello
    ; della moneta scelta.
    (while (< i num)
      (setq j (monete i))
      (while (<= j cifra)
        (setf (vett j) (+ (vett j) (vett (- j (monete i)))))
        (++ j))
      (++ i))
    (vett cifra)
  ))

(conta '(2 3 5 6) 4 10)
;-> 5
(conta '(1 2 3) 3 4)
;-> 4
(conta '(5 10) 2 11)
;-> 0
(conta '(2 3) 2 13)
;-> 2
(conta '(3 4) 2 17)
;-> 1

Altra soluzione usando la programmazione dinamica:

def make_change(coins, n):
    results = [0 for _ in range(n + 1)]
    results[0] = 1
    for coin in coins:
        for i in range(coin, n + 1):
            results[i] += results[i - coin]
    return results[n]

(setq t (array (+ 5 1) '(0)))

(define (conta monete cifra)
  (let (out (array (+ cifra 2) '(0)))
    (setq (out 0) 1)
    (dolist (el monete)
      (for (i el (+ cifra 1))
        (setf (out i) (+ (out i) (out (- i el))))
      )) (out cifra)))

(conta '(2 3 5 6) 10)
;-> 5
(conta '(1 2 3) 4)
;-> 4
(conta '(5 10) 11)
;-> 0
(conta '(2 3) 13)
;-> 2
(conta '(3 4) 17)
;-> 1


--------------------------
Cambio monete 2 (LinkedIn)
--------------------------

Dato un numero N e una lista di numeri M (m1, m2, ..., mm). Determinare il più breve elenco di numeri che somma a N. È possibile utilizzare ogni elemento della lista M infinite volte.
In altre parole, data una cifra N e un insieme di monete (m1, m2, ..., mm), quale modo di 'spicciare' la cifra N contiene meno monete ?

La soluzione usa la tecnica ricorsiva di backtracking:

(define (cambio-min monete cifra)
  (local (out)
    (setq out '())
    (define (cambio-min-aux end resto cur-out)
      (cond ((< end 0) nil)
            ((zero? resto) (push cur-out out -1))
            ((>= resto (monete end))
              (cambio-min-aux end
                              (- resto (monete end))
                              (push (monete end) cur-out -1)))
            (true (cambio-min-aux (- end 1) resto cur-out))
      )
    )
    (cambio-min-aux (- (length monete) 1) cifra '())
    out
  )
)

(cambio-min '(1 2 5 8) 7)
;-> ((5 2))

(cambio-min '(2) 10)
;-> ((2 2 2 2 2))

(cambio-min '(2 3 5) 10)
;-> ((5 5))


--------------------------------
Primi con cifre uguali (Wolfram)
--------------------------------

Scrivere una funzione che trova tutti i numeri primi sotto a 10 milioni che hanno almeno 5 cifre uguali.

Vediamo prima le funzioni che ci servono per risolvere il problema.

Funzione che calcola i numeri primi da m a n:

(define (sieve-from-to m n)
  (local (arr lst out)
    (setq out '())
    (setq arr (array (+ n 1)) lst '(2))
    (for (x 3 n 2)
        (when (not (arr x))
          (push x lst -1)
          (for (y (* x x) n (* 2 x) (> y n))
              (setf (arr y) true))))
    (if (<= m 2)
        lst
        (dolist (el lst) (if (>= el m) (push el out -1)))
    )
  )
)

(sieve-from-to 10 100)
;-> (11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)

Funzioni di conversione lista <--> intero:

(define (int2list n)
  (let (out '())
    (while (!= n 0)
      (push (% n 10) out)
      (setq n (/ n 10))) out))

(define (list2int lst)
  (let (n 0)
    (dolist (el lst) (setq n (+ el (* n 10))))))

Adesso vediamo il procedimento di soluzione usando dei numeri piccoli:

Troviamo i numeri primi da 100 a 200:

(setq a (sieve-from-to 100 200))
;-> (101 103 107 109 113 127 131 137 139 149 151
;->  157 163 167 173 179 181 191 193 197 199)

Trasformiamo i numeri in liste:

(setq b (map int2list a))
;-> ((1 0 1) (1 0 3) (1 0 7) (1 0 9) (1 1 3) (1 2 7) (1 3 1) (1 3 7)
;->  (1 3 9) (1 4 9) (1 5 1) (1 5 7) (1 6 3) (1 6 7) (1 7 3) (1 7 9)
;->  (1 8 1) (1 9 1) (1 9 3) (1 9 7) (1 9 9))

La funzione "count" conta le occorrenze di ogni elemento della prima lista nella seconda lista. Il risultato è una lista di occorrenze.

Esempio:
(count '(0 1 2) '(1 1 2 2 2 2 3))
;-> (0 2 4)
0 appare 0 volte in (1 1 2 2 2 2 3)
1 appare 2 volte in (1 1 2 2 2 2 3)
2 appare 4 volte in (1 1 2 2 2 2 3)

Contiamo quante volte le cifre 0, 1 e 2 compaiono in ogni cifra/sottolista:

(setq c (map (fn(x) (count '(0 1 2) x)) b))
(setq c (map (fn(x) (count (sequence 0 2) x)) b))
;-> ((1 2 0) (1 1 0) (1 1 0) (1 1 0) (0 2 0) (0 1 1) (0 2 0) (0 1 0)
;->  (0 1 0) (0 1 0) (0 2 0) (0 1 0) (0 1 0) (0 1 0) (0 1 0) (0 1 0)
;->  (0 2 0) (0 2 0) (0 1 0) (0 1 0) (0 1 0))

Scegliamo quelli in cui almeno la cifra 0 o 1 o 2 compare due (2) volte:

(setq d '())
(dolist (el c) (if (find 2 el) (push (b $idx) d -1)))
d
;-> ((1 0 1) (1 1 3) (1 3 1) (1 5 1) (1 8 1) (1 9 1))

Trasformiamo in lista di numeri:

(setq e (map list2int d))
;-> (101 113 131 151 181 191)

Questi sono tutti i numeri primi tra 100 e 200 che hanno la cifra 0 o la cifra 1 o la cifra 2 ripetuta due volte.

Scriviamo la funzione finale in maniera sequenziale:

(define (calcola num cifre)
  (local (a b c d e)
    ;(println "a")
    (setq a (sieve-from-to 10 num))
    ;(println "b")
    (setq b (map int2list a))
    ;(println "c")
    (setq c (map (fn(x) (count (sequence 0 9) x)) b))
    ;(println "d")
    (setq d '())
    ;(dolist (el c) (if (find cifre (last el)) (push (first el) d -1)))
    (dolist (el c) (if (find cifre el) (push (b $idx) d -1)))
    ;(println "e")
    (setq e (map list2int d))
    (length e)
  ))

(calcola 1e7 5)
;-> 1112

(time (calcola 1e7 5))
;-> 5874.936

(calcola 1e5 4)
;-> 40
(calcola 1e6 5)
;-> 53
(calcola 1e7 6)
;-> 35

Possiamo velocizzare la funzione creando la lista "c" in questo modo:

( ((1 0 1) 2) ((1 0 2) 1)...)

Poi questa lista viene filtrata con la funzione "filter".

(define (calcola1 num cifre)
  (local (a b c d e)
    (define (test x) (= (last x) cifre))
    ;(println "a")
    (setq a (sieve-from-to 10 num))
    ;(println "b")
    (setq b (map int2list a))
    ;(println "c")
    (setq c (map (fn(x) (list x (apply max (count (sequence 0 9) x)))) b))
    ;(println "d")
    (setq d (filter test c))
    ;(dolist (el c) (if (= cifre (last el)) (push (first el) d -1)))
    ;(println "e")
    (setq e (map (fn(x) (list2int (first x))) d))
    (length e)
  ))

(calcola1 1e7 5)
;-> 1112

(time (calcola1 1e7 5))
;-> 4859.91

Abbiamo velocizzato la funzione del 20%.

(calcola1 1e5 4)
;-> 40
(calcola1 1e6 5)
;-> 53
(calcola1 1e7 6)
;-> 35


-------------------------------
Intervalli di numeri (Facebook)
-------------------------------

Data una lista di numeri interi restituire una nuova lista con tutti gli intervalli ordinati dei numeri che sono consecutivi nella lista originale. Ad esempio:

lista input:  (2 3 4 7 9 11 12 13 20)
lista output: ((2 4) (7) (9) (11 13) (20))

Quando eseguiamo l'iterazione sulla lista, teniamo traccia di due valori:
1) il primo valore di un nuovo intervallo
2) il valore precedente nell'intervallo

(define (intervalli lst)
  (local (res pre primo)
    (setq res '())
    (cond ((null? lst) (setq res '()))
          ((= (length lst) 1) (setq res lst))
          (true
            ;ordina la lista univoca
            (setq lst (sort (unique lst)))
            (println lst)
            ; elemento precedente
            (setq pre (lst 0))
            ; primo elemento di ogni intervallo
            (setq primo pre)
            (for (i 1 (- (length lst) 1))
              (if (= (lst i) (+ pre 1))
                  (if (= i (- (length lst) 1))
                    (push (list primo (lst i)) res -1)
                  )
              ;else
                  (begin
                    (if (= primo pre)
                        (push (list primo) res -1)
                        (push (list primo pre) res -1)
                    )
                    (if (= i (- (length lst) 1))
                        (push (list (lst i)) res -1)
                    )
                    (setq primo (lst i))
                  )
              )
              (setq pre (lst i))
            )
          )
    )
    res
  )
)

(intervalli '(2 0 1 7 5 4))
;-> ((0 2) (4 5) (7))

(intervalli '(2 3 4 7 9 11 12 13 20))
;-> ((2 4) (7) (9) (11 13) (20))

(intervalli '(10 3 -1 -2 4 -5 8 7 6 -3))
;-> ((-5) (-3 -1) (3 4) (6 8) (10))


---------------------------
Pattern Matching (Facebook)
---------------------------

Implementare una funzione di pattern matching che supporta i caratteri jolly "?" (un  carattere qualunque) e "*" (zero o più caratteri qualunque).

To understand this solution, you can use s="aab" and p="*ab".

(define (isMatch s p)
  (local (i j staridx idx res)
    (setq res -1)
    (setq i 0)
    (setq j 0)
    (setq staridx -1)
    (setq idx -1)
    (while (and (< i (length s)) (= res -1))
      (cond ((and (< j (length p)) (or (= (p j) "?") (= (p j) (s i))))
             (++ i)
             (++ j))
            ((and (< j (length p)) (= (p j) "*"))
             (setq staridx j)
             (setq idx i)
             (++ j))
            ((!= staridx -1)
             (setq j (+ staridx 1))
             (setq i (+ idx 1))
             (++ idx))
            (true (setq res nil))
      )
    )
    (if (= res -1)
      (while (and (< j (length p)) (= (p j) "*"))
        (++ j)
      )
    )
    (if (and (= res -1) (= j (length p)))
        true
        nil
    )
  )
)

(isMatch "aab" "*ab")
;-> true

(isMatch "aaaabbbbcccc" "a*")
;-> true

(isMatch "aaaabbbbcccc" "d*")
;-> nil

(isMatch "aaaabbbbcccc" "a???b???c*")
;-> true

(isMatch "abcdefg" "??cde?g*")
;-> true


------------------------------
Percorsi su una griglia (Uber)
------------------------------

Data una matrice M per N composta da valori 0 e 1 che rappresenta una griglia. Ogni valore 0 rappresenta un muro. Ogni valore 1 rappresenta una cella libera.
Data questa matrice, una coordinata iniziale e una coordinata finale, restituire il numero minimo di passi necessari per raggiungere la coordinata finale partendo dall'inizio. Se non è possibile alcun percorso, restituire nil. Possiamo spostarci verso l'alto, a sinistra, in basso e a destra. Non possiamo attraversare i muri. Non possiamo attraversare i bordi della griglia.
Il percorso risolutivo può essere costruito solo da celle con valore 1 e in un dato momento, possiamo muovere solo di un passo in una delle quattro direzioni. Le mosse valide sono:

Vai su: (x, y) -> (x - 1, y)
Vai a sinistra: (x, y) -> (x, y - 1)
Vai giù: (x, y) -> (x + 1, y)
Vai a destra: (x, y) -> (x, y + 1)

Ad esempio, consideriamo la matrice binaria sotto. Se origine = (0, 0) e destinazione = (7, 5), il percorso più breve dall'origine alla destinazione ha lunghezza 12:

(1 1 1 1 1 0 0 1 1 1)
(0 1 1 1 1 1 0 1 0 1)
(0 0 1 0 1 1 1 0 0 1)
(1 0 1 1 1 0 1 1 0 1)
(0 0 0 1 0 0 0 1 0 1)
(1 0 1 1 1 0 0 1 1 0)
(0 0 0 0 1 0 0 1 0 1)
(0 1 1 1 1 1 1 1 0 0)
(1 1 1 1 1 0 0 1 1 1)
(0 0 1 0 0 1 1 0 0 1)

La soluzione utilizza l'algoritmo di Lee che è una buona scelta nella maggior parte dei problemi di ricerca di percorsi minimi, infatti fornisce sempre la soluzione ottimale, anche se è un pò lento e richiede molta memoria. Questo algoritmo è uguale a Breadth First Search (BFS), ma teniamo traccia della distanza e valutiamo la distanza più breve tra l'insieme delle distanze.

I passaggi fondamentali sono i seguenti:
1. Scegli un punto di partenza e aggiungilo alla coda.
2. Aggiungi le celle adiacenti valide alla coda.
3. Rimuovi la posizione in cui ci si trova dalla coda e passa all'elemento successivo.
4. Ripeti i passaggi 2 e 3 fino a quando la coda è vuota.

Eseguendo questo algoritmo per ogni cella, avremo il numero di passi necessari per arrivare a qualsiasi altro punto dall'inizio.
Naturalmente dovremo ignorare i muri e le celle precedentemente contrassegnate su ogni iterazione ed interrompere le chiamate ricorsive una volta raggiunta la cella finale.

Si noti che in BFS, tutte le celle che hanno il percorso più breve uguale a 1 vengono visitate per prime, seguite dalle celle adiacenti che hanno il percorso più breve come 1 + 1 = 2 e così via .. quindi se raggiungiamo un nodo in BFS, il suo percorso più breve = percorso più breve del genitore + 1. Quindi, la prima occorrenza della cella di destinazione ci dà il risultato e possiamo fermare la nostra ricerca lì. Non è possibile che esista il percorso più breve da un'altra cella per la quale non abbiamo ancora raggiunto il nodo specificato. Se fosse stato possibile tale percorso, lo avremmo già esplorato.

Struttura dei dati:

grid = matrice binaria MxN (0, 1) (1 = aperto, 0 = chiuso)
visited = matrice booleana MxN (true, nil)
lifo = lista (coda lifo) con elementi/nodi di tipo (x-coord y-coord distanza)

Funzione che controlla se una cella della griglia è valida:

(define (isvalid grid visited row col)
  ; la cella è valida se:
  ; 1. si trova nella griglia
  ; 2. ha valore 1
  ; 3. non è stata visitata
  (and (>= row 0) (< row M) (>= col 0) (< col N)
       (= (grid row col) 1)
       (not (visited row col))))

Funzione Breadth First Search di tipo Lee:

; Trova il percorso minimo in una matrice/griglia
; partendo dalla cella (i, j) e arrivando alla cella (x y)
(define (bfs grid i j x y)
  (local (riga colonna lifo visited min-dist
          nodo dist n found)
    (setq found nil)
    ; crea la lista/coda lifo
    (setq lifo '())
    ; le liste riga e colonna permettono di muoversi
    ; facilmente nelle quattro direzioni
    (setq riga '(-1 0 0 1))
    (setq colonna '(0 -1 1 0))
    ; matrice delle celle visitate
    (setq visited (array M N '(nil)))
    ; valore minimo iniziale
    (setq min-dist 9999999999)
    ; marca la cella iniziale come visitata e
    ; aggiunge il nodo della cella iniziale alla lista lifo
    (setf (visited i j) true)
    (push (list i j 0) lifo)
    ; ciclo per visitare i nodi
    ; fino a che coda (lista lifo) non è vuota...
    (while (and lifo (not found))
      ; estrae il nodo dalla coda e lo processa
      (setq nodo (pop lifo))
      ; (i, j) rappresenta la cella corrente...
      (setq i (nodo 0))
      (setq j (nodo 1))
      ; e dist è la distanza minima dalla sorgente
      (setq dist (nodo 2))
      ; se abbiamo raggiunto la destinazione
      ; aggiorniamo la distanza e terminiamo la ricerca
      (if (and (= i x) (= j y))
          (begin
            (setq min-dist dist)
            (setq found true)
          )
      )
      ; se la ricerca non è terminata...
      (if (not found)
        ; controlla le celle raggiungibili con i quattro movimenti
        ; e accoda le celle valide
        (for (k 0 3)
          ; controlla se è possibile passare dalla posizione corrente
          ; alla posizione (i + riga(k), j + colonna(k))
          (if (isvalid grid visited (+ i (riga k)) (+ j (colonna k)))
            (begin
              ; marca la cella come visitata e
              ; aggiungila alla coda.
              (setf (visited (+ i (riga k)) (+ j (colonna k))) true)
              (setq n (list (+ i (riga k)) (+ j (colonna k)) (+ dist 1)))
              (push n lifo)
            )
          )
        )
      )
      ; Restituisci il risultato finale: distanza minima oppure nil.
      (if (= min-dist 9999999999)
        nil
        min-dist
      )
    )
  )
)

Proviamo la funzione:

(setq M 5)
(setq N 5)

(setq matrice
'(( 1 0 1 1 1 )
  ( 1 0 1 0 1 )
  ( 1 1 1 0 1 )
  ( 0 0 0 0 1 )
  ( 1 1 1 0 1 )
  ( 1 1 0 0 0 )))

Punto di partenza: Start = (0 0)
Punto di arrivo: End = (3 4)

(bfs matrice 0 0 3 4)
;-> 11

Celle del percorso minimo:
(0 0) (1 0) (2 0) (2 1) (2 2) (1 2) (0 2) (0 3) (0 4) (1 4) (2 4) (3 4)

Nota:
Se vogliamo muoverci nelle otto direzioni, allora dobbiamo fare le seguenti modifiche al codice:

1) Modificare le lista riga e colonna per elencare tutti gli 8 movimenti possibili da una cella, ovvero alto, destra, basso, sinistra e le 4 mosse diagonali.

(setq riga '(-1 -1 -1 0 1 0 1 1 ))
(setq colonna '(-1 1 0 -1 -1 1 0 1))

2. Controllare tutti gli 8 movimenti possibili dalla cella corrente.

(for (k 0 7) (...))

Adesso dobbiamo restituire anche le celle che compongono il percorso trovato e non solo il suo valore. Per fare questo dobbiamo aggiungere ad ogni nodo un puntatore al nodo genitore. Quindi il nuovo nodo della lista lifo ha la seguente struttura:

(x-coord y-coord dist (x-genitore y-genitore dist))

In questo caso il nodo è una struttura ricorsiva (di lunghezza crescente) del tipo:

(0 3 7 (0 2 6 (1 2 5 (2 2 4 (2 1 3 (2 0 2 (1 0 1 (0 0 0()))))))))

Abbiamo bisogno anche di una funzione che stampa la matrice con il percorso risolutivo:

(define (print-sol matrix sol)
  ; elimina la distanza minima dalla lista della soluzione
  (pop sol)
  (dolist (el sol)
    (setf (matrix (el 0) (el 1)) 2))
  (dolist (r matrix) (println r)))

(define (isvalid grid visited row col)
  ; la cella è valida se:
  ; 1. si trova nella griglia
  ; 2. ha valore 1
  ; 3. non è stata visitata
  (and (>= row 0) (< row M) (>= col 0) (< col N)
       (= (grid row col) 1)
       (not (visited row col))))

La funzione "bfs" finale è la seguente:

; Trova il percorso minimo in una matrice/griglia
; partendo dalla cella (i, j) e arrivando alla cella (x y)
(define (bfs grid i j x y)
  (local (riga colonna lifo visited min-dist
          nodo parent dist n found k sol)
    (setq found nil)
    ; crea la lista/coda lifo
    (setq lifo '())
    ; le liste riga e colonna permettono di muoversi
    ; facilmente nelle quattro direzioni
    (setq riga '(-1 0 0 1))
    (setq colonna '(0 -1 1 0))
    ; matrice delle celle visitate
    (setq visited (array M N '(nil)))
    ; valore minimo iniziale
    (setq min-dist 9999999999)
    ; crea il genitore per la cella origine
    (setq parent '())
    ; marca la cella iniziale come visitata e
    ; aggiunge il nodo della cella iniziale alla lista lifo
    (setf (visited i j) true)
    (push (list i j 0 '()) lifo)
    ; ciclo per visitare i nodi
    ; fino a che coda (lista lifo) non è vuota...
    (while (and lifo (not found))
      ; estrae il nodo dalla coda e lo processa
      (setq nodo (pop lifo))
      ; (i, j) rappresenta la cella corrente...
      (setq i (nodo 0))
      (setq j (nodo 1))
      ; e dist è la distanza minima dalla sorgente
      (setq dist (nodo 2))
      ; se abbiamo raggiunto la destinazione
      ; aggiorniamo la distanza e terminiamo la ricerca
      (if (and (= i x) (= j y))
        (begin
          (setq min-dist dist)
          (setq found true)
          ; la soluzione
        )
      )
      ; se la ricerca non è terminata...
      (if (not found)
        ; controlla le celle raggiungibili con i quattro movimenti
        ; e accoda le celle valide
        (for (k 0 3)
          ; controlla se è possibile passare dalla posizione corrente
          ; alla posizione (i + riga(k), j + colonna(k))
          (if (isvalid grid visited (+ i (riga k)) (+ j (colonna k)))
            (begin
              ; marca la cella come visitata e
              ; aggiungila alla coda.
              (setf (visited (+ i (riga k)) (+ j (colonna k))) true)
              (setq n (list (+ i (riga k)) (+ j (colonna k)) (+ dist 1) nodo))
              (push n lifo)
            )
          )
        )
      )
      ; Restituisce il risultato finale: (distanza minima + celle del percorso) oppure nil.
      (if (= min-dist 9999999999)
        nil
        (begin
          ; crea la lista soluzione
          (setq sol (push min-dist (map (fn(x) (list (x 0) (x 1))) (reverse (explode (flat nodo) 3)))))
          ; stampa la griglia con la soluzione
          (print-sol grid sol)
          sol
        )
      )
    )
  )
)

Proviamo:

(setq M 5)
(setq N 5)

(setq matrice
'(( 1 0 1 1 1 )
  ( 1 0 1 0 1 )
  ( 1 1 1 0 1 )
  ( 0 0 0 0 1 )
  ( 1 1 1 0 1 )
  ( 1 1 0 0 0 )))

(bfs matrice 0 0 3 4)
;-> (2 0 2 2 2)
;-> (2 0 2 0 2)
;-> (2 2 2 0 2)
;-> (0 0 0 0 2)
;-> (1 1 1 0 1)
;-> (1 1 0 0 0)
;-> (11 (0 0) (1 0) (2 0) (2 1) (2 2) (1 2) (0 2) (0 3) (0 4) (1 4) (2 4) (3 4))

Vediamo come viene creata la lista soluzione. Il nodo finale "nodo" vale:

(3 4 11 (2 4 10 (1 4 9 (0 4 8 (0 3 7 (0 2 6 (1 2 5 (2 2 4 (2 1 3 (2 0 2 (1 0 1 (0 0 0()))))))))))))

Quindi possiamo estrarre la soluzione nel modo seguente:

(setq sol '(3 4 11 (2 4 10 (1 4 9 (0 4 8 (0 3 7 (0 2 6 (1 2 5 (2 2 4 (2 1 3 (2 0 2 (1 0 1 (0 0 0())))))))))))))
(setq a (flat sol))
;-> (3 4 11 2 4 10 1 4 9 0 4 8 0 3 7 0 2 6 1 2 5 2 2 4 2 1 3 2 0 2 1 0 1 0 0 0)
(setq b (explode a 3))
;-> ((3 4 11) (2 4 10) (1 4 9) (0 4 8) (0 3 7) (0 2 6) (1 2 5) (2 2 4) (2 1 3) (2 0 2) (1 0 1) (0 0 0))
(setq c (reverse b))
;-> ((0 0 0) (1 0 1) (2 0 2) (2 1 3) (2 2 4) (1 2 5) (0 2 6) (0 3 7) (0 4 8) (1 4 9) (2 4 10) (3 4 11))
(setq d (map (fn(x) (list (x 0) (x 1))) c))
;-> ((0 0) (1 0) (2 0) (2 1) (2 2) (1 2) (0 2) (0 3) (0 4) (1 4) (2 4) (3 4))

Mettendo tutto insieme:

(setq sol (push min-dist (map (fn(x) (list (x 0) (x 1))) (reverse (explode (flat nodo) 3)))))

Vediamo la soluzione dell'esempio iniziale:

(setq M 10)
(setq N 10)

(setq matrice
'((1 1 1 1 1 0 0 1 1 1)
  (0 1 1 1 1 1 0 1 0 1)
  (0 0 1 0 1 1 1 0 0 1)
  (1 0 1 1 1 0 1 1 0 1)
  (0 0 0 1 0 0 0 1 0 1)
  (1 0 1 1 1 0 0 1 1 0)
  (0 0 0 0 1 0 0 1 0 1)
  (0 1 1 1 1 1 1 1 0 0)
  (1 1 1 1 1 0 0 1 1 1)
  (0 0 1 0 0 1 1 0 0 1)))

Origine: (0 0)
Destinazione: (7 5)

(bfs matrice 0 0 7 5)
;-> (2 2 1 1 1 0 0 1 1 1)
;-> (0 2 2 1 1 1 0 1 0 1)
;-> (0 0 2 0 1 1 1 0 0 1)
;-> (1 0 2 2 1 0 1 1 0 1)
;-> (0 0 0 2 0 0 0 1 0 1)
;-> (1 0 1 2 2 0 0 1 1 0)
;-> (0 0 0 0 2 0 0 1 0 1)
;-> (0 1 1 1 2 2 1 1 0 0)
;-> (1 1 1 1 1 0 0 1 1 1)
;-> (0 0 1 0 0 1 1 0 0 1)
;-> (12 (0 0) (0 1) (1 1) (1 2) (2 2) (3 2) (3 3)
;->     (4 3) (5 3) (5 4) (6 4) (7 4) (7 5))


-------------------------
Dadi e probabilità (Visa)
-------------------------

Quali sono le probabilità di vittoria, sconfitta e pareggio di due giocatori che lanciano ognuno un dado con 6 facce (valori da 1 a 6)?
Calcolare le stesse probabilità nel caso in cui il primo giocatore lanci un dado con 7,8,9,10,11 e 12 facce (valori da 1 a numero facce).

Proviamo con una simulazione di lanci per calcolare le probabilità:

(define (dadoni v1 v2 n)
  (local (p1 p2 pp r1 r2)
    (setq p1 0)
    (setq p2 0)
    (setq pp 0)
    (for (i 1 n)
      (setq r1 (rand v1))
      (setq r2 (rand v2))
      (cond ((> r1 r2) (++ p1))
            ((= r1 r2) (++ pp))
            (true (++ p2))
      )
    )
    (println (+ p1 p2 pp) { } (add (div p1 n) (div p2 n) (div pp n)))
    (list p1 (div p1 n) p2 (div p2 n) pp (div pp n))
  )
)

(dadoni 6 6 1000000)
;-> (416485 0.416485 416996 0.416996 166519 0.166519)
(dadoni 7 6 1000000)
;-> (500586 0.500586 356171 0.356171 143243 0.143243)
(dadoni 8 6 1000000)
;-> (562627 0.562627 312738 0.312738 124635 0.124635)
(dadoni 9 6 1000000)
;-> (611542 0.611542 277806 0.277806 110652 0.110652)
(dadoni 10 6 1000000)
;-> (650110 0.65011 249709 0.249709 100181 0.100181)
(dadoni 11 6 1000000)
;-> (682167 0.682167 227011 0.227011 90822 0.090822)
(dadoni 12 6 1000000)
;-> (708841 0.708841 207595 0.207595 83564 0.083564)
(dadoni 100 6 1000000)
;-> (964911 0.964911 24972 0.024972 10117 0.010117)

Adesso calcoliamo rigorosamente queste probabilità/percentuali. Tutte le probabilità vengono calcolate con la formula:

                numero eventi favorevoli
Probabilità = ----------------------------
                numero eventi possibili

Prodotto cartesiano tra due liste:

(define (cp lst1 lst2)
  (let (out '())
    (if (or (null? lst1) (null? lst2))
        nil
        (dolist (el1 lst1)
          (dolist (el2 lst2)
            (push (list el1 el2) out -1))))))


I due dadi:
(setq d1 '(1 2 3 4 5 6))
(setq d2 '(1 2 3 4 5 6))

Lista di tutti gli eventi possibili (ogni elemento della lista rappresenta un lancio e contiene i valori dei dadi lanciati dal primo e dal secondo giocatore):

(setq eventi (cp d1 d2))
;-> ((1 1) (1 2) (1 3) (1 4) (1 5) (1 6) (2 1) (2 2) (2 3) (2 4)
;->  (2 5) (2 6) (3 1) (3 2) (3 3) (3 4) (3 5) (3 6) (4 1) (4 2)
;->  (4 3) (4 4) (4 5) (4 6) (5 1) (5 2) (5 3) (5 4) (5 5) (5 6)
;->  (6 1) (6 2) (6 3) (6 4) (6 5) (6 6))

Calcolo gli eventi favorevoli a p1, quelli favorevoli a p2 e quelli in parità:

(setq p1 0)
(setq p2 0)
(setq pp 0)

(dolist (el eventi)
  (cond ((> (el 0) (el 1)) (++ p1))
        ((< (el 0) (el 1)) (++ p2))
        (true (++ pp))
  )
)

(setq num (length eventi))
(list p1 (div p1 num) p2 (div p2 num) pp (div pp num))
;-> (15 0.4166666666666667 15 0.4166666666666667 6 0.1666666666666667)

Per gli altri dadi otteniamo i seguenti valori:

(setq d1 '(1 2 3 4 5 6 7))
(setq d2 '(1 2 3 4 5 6))
;-> (21 0.5 15 0.3571428571428572 6 0.1428571428571429)

(setq d1 '(1 2 3 4 5 6 7 8))
(setq d2 '(1 2 3 4 5 6))
;-> (27 0.5625 15 0.3125 6 0.125)

(setq d1 '(1 2 3 4 5 6 7 8 9))
(setq d2 '(1 2 3 4 5 6))
;-> (33 0.6111111111111112 15 0.2777777777777778 6 0.1111111111111111)

(setq d1 '(1 2 3 4 5 6 7 8 9 10))
(setq d2 '(1 2 3 4 5 6))
;-> (39 0.65 15 0.25 6 0.1)

(setq d1 '(1 2 3 4 5 6 7 8 9 10 11))
(setq d2 '(1 2 3 4 5 6))
;-> (45 0.6818181818181818 15 0.2272727272727273 6 0.09090909090909091)

(setq d1 '(1 2 3 4 5 6 7 8 9 10 11))
(setq d2 '(1 2 3 4 5 6))
;-> (45 0.6818181818181818 15 0.2272727272727273 6 0.09090909090909091)

Routine di calcolo:

(setq eventi (cp d1 d2))
(setq p1 0)
(setq p2 0)
(setq pp 0)
(dolist (el eventi)
  (cond ((> (el 0) (el 1)) (++ p1))
        ((< (el 0) (el 1)) (++ p2))
        (true (++ pp))
  )
)
(setq num (length eventi))
(list p1 (div p1 num) p2 (div p2 num) pp (div pp num))


----------------------------------
Numeri casuali e fattori (Wolfram)
----------------------------------

Dati due numeri casuali (random), qual'è la probabilità che non abbiano fattori in comune?

Nota: due numeri m e n non hanno fattori in comune quando gcd(m,n) = 1 (cioè i due numeri sono coprimi tra loro).

Dirichlet ha dimostrato che questa probabilità vale:

6 / pi^2 = 1 / [(1/(1*1)) + (1/(2*2)) + (1/(3*3)) + (1/(4*4)) + ...]

----------
Vediamo la dimostrazione a grandi linee:
la probabilità che 2 numeri condividano un divisore primo è 1/p^2. Ciò significa che la probabilità che 2 numeri non condividano un fattore primo vale  (1 - 1/p^2). Allora, 1/2 di tutti i numeri hanno un fattore 2, 1/3 hanno un fattore 3, 1/4 hanno un fattore 4, ecc. Due numeri con fattore 2 sono entrambi (1/2)^2, entrambi con 3 è (1/3)^2, ecc. Questi sono eventi indipendenti quindi possiamo sommare tutte le p.

Verifichiamo l'equazione sopra ponendo A = B(n).

(setq pi (mul 2.0 (acos 0.0)))
;-> 3.141592653589793

(setq A (div 6 (mul pi pi)))
;-> 0.6079271018540267

(define (B n)
  (let (val 0)
    (for (i 1 n)
      (setq val (add val (div 1 (mul i i))))
    )
    (setq val (div 1 val))
  )
)

(B 10000)
;-> 0.6079640597889869

Vediamo la convergenza della serie:

(sub A (B 10000))
;-> -3.695793496027999e-005
(sub A (B 100000))
;-> -3.695757594401883e-006
(sub A (B 1000000))
;-> -3.695753849619621e-007

Scriviamo una funzione che simula il processo.

(setq r1 (rand 100000000))
;-> 74660481
(setq r2 (rand 100000000))
;-> 17410809
(gcd r1 r2)
;-> 3
Quindi r1 e r2 hanno fattori in comune.

Un altro metodo è il seguente (più lungo):

(setq r1 (rand 100000000))
(setq r2 (rand 100000000))

Calcoliamo i fattori primi dei due numeri:

(setq f1 (factor r1))
(setq f2 (factor r2))

Se non ci sono fattori in comune la funzione "count" restituisce una lista con tutti valori 0:

(count f1 f2)
;-> (0 0 0 0 1 0 0)

(count f2 f1)
;-> (1 0)

Per verificare l'esistenza di valori diversi da 0 in una lista possiamo sommare tutti gli elementi e controllare il risultato:

(apply + (count f1 f2))
;-> 1 ; ci sono fattori comuni

Comunque per la nostra funzione di simulazione utilizziamo "gcd":

(define (coprimi% n)
  (local (r1 r2 perc)
    (setq perc 0)
    (for (i 1 n)
      (if (= 1 (gcd (rand 100000000) (rand 100000000)))
        (++ perc)
      )
    )
    (mul 100 (div perc n))
  )
)

(coprimi% 1e7)
;-> 60.79949

Il risultato della simulazione conferma il risultato della formula (0.6079271018540267).


------------------------
Coprimi vicini (Wolfram)
------------------------

Dato un numero n, trovare i primi tre numeri a, b e c, maggiori o uguali a n, tali che:

1. a è coprimo di b,
2. b è coprimo di c,
3. a non è coprimo di c.

Nota: due numeri sono coprimi se e solo se essi non hanno nessun divisore comune eccetto 1 e -1 o, in modo equivalente, se il loro massimo comune divisore è 1.

Dato qualsiasi numero naturale x, questo è certamente coprimo a x + 1. Inoltre, due numeri pari non sono mai coprimi, perché condividono un fattore 2. Quindi, se n è pari, n, n + 1 e n + 2 formano una tripla corretta, e se n è dispari, n + 1, n + 2 e n + 3 formano una tripla adatta.

Sciviamo una funzione che calcola e verifica la soluzione:

(define coprimi (a b) (= 1 (gcd a b)))

(define (coprimi-near n)
  (let ((out '()) (a 0) (b 0) (c 0))
    (cond ((even? n)
           (setq a n)
           (setq b (+ n 1))
           (setq c (+ n 2))
           (println "gcd("a { } b") = " (gcd  a b))
           (println "gcd("b { } c") = " (gcd  b c))
           (println "gcd("a { } c") = " (gcd  a c)))
          ((odd? n)
           (setq a (+ n 1))
           (setq b (+ n 2))
           (setq c (+ n 3))
           (println "gcd("a { } b") = " (gcd  a b))
           (println "gcd("b { } c") = " (gcd  b c))
           (println "gcd("a { } c") = " (gcd  a c)))
    )
    (list a b c)
  )
)

(coprimi-near 10)
;-> gcd(10 11) = 1
;-> gcd(11 12) = 1
;-> gcd(10 12) = 2
;-> (10 11 12)

(coprimi-near 1111)
;-> gcd(1112 1113) = 1
;-> gcd(1113 1114) = 1
;-> gcd(1112 1114) = 2
;-> (1112 1113 1114)


--------------------------
Unione di liste (LinkedIn)
--------------------------

Date due liste costruire la lista unione, cioè una lista con tutti valori non ripetuti delle due liste.
Per esempio, unione (1 3 1 4 4 3) (2 1 5 6 4)  -->  (1 3 4 2 5 6)

Usiamo un dizionario (hash-map) che ci permette di inserire automaticamente solo i valori che non sono già presenti nel dizionario stesso.

(define (unione lst1 lst2)
  (let (out '())
    ; creazione di una hash-map (Hash)
    (new Tree 'Hash)
    ; inserisce i valori della lista 1 sull'hash-map
    ; (solo quelli non presenti nell'hash-map)
    (dolist (el lst1) (Hash el el))
    ; inserisce i valori della lista 2 sull'hash-map
    ; (solo quelli non presenti nell'hash-map)
    (dolist (el lst2) (Hash el el))
    ; creazione della lista di output
    (dolist (el (Hash)) (push (el 1) out -1))
    ; occorre eliminare i valori dalla hash-map
    ; perchè è una variabile globale (è un contesto)
    (delete 'Hash)
    out
  )
)

(unione '(1 3 1 4 4 3) '(2 1 5 6 4))
;-> (1 2 3 4 5 6)


---------------------------
Tripla crescente (LeetCode)
---------------------------

Data una lista non ordinata restituire, se esiste, una sottosequenza crescente di lunghezza 3.
I numeri non devono essere necessariamente consecutivi.
Il problema non richiede di trovare la sottosequenza, ma verificare solo la sua esistenza.

Dal punto di vista formale occorre trovare una sequenza x, y e z, tale che x < y < z.

(define (triple? lst)
  (local (x y z i out)
    (setq out nil)
    (setq x 9223372036854775807)
    (setq y 9223372036854775807)
    (setq i 0)
    (dolist (el lst)
      (setq z el)
      (cond ((>= x z) (setq x z)) ; aggiorna x ad un valore inferiore
            ((>= y z) (setq y z)) ; aggiorna y ad un valore inferiore
            (true (setq out true))
      )
    )
    ; I valori memorizzati in x,y,z non sono
    ; necessariamente la sottosequenza crescente
    ;(println x { } y { } z)
    out
  )
)

(triple? '(10 1 5 4 3))
;-> nil
(triple? '(10 1 5 4 3 4))
;-> true


----------------------------
Stringhe isomorfe (Facebook)
----------------------------

Date due stringhe, determinare se sono isomorfe. Due stringhe sono isomorfe se i caratteri nella prima stringa possono essere sostituiti per ottenere la seconda stringa. Ad esempio, "egg" e "add" sono isomorfe, "foo" e "bar" non lo sono.

Possiamo usare due hashmap che tengono traccia delle mappature char-char. Se un valore è già mappato, non può essere mappato nuovamente.

(define (isomorfe str1 str2)
  (let (out true)
    (cond ((!= (length str1) (length str2))
           (setq out nil))
          ((or (null? str1) (null? str2))
           (setq out nil))
          (true
           (new Tree 'map1)
           (new Tree 'map2)
           (for (i 0 (- (length str1) 1) 1 (not out))
             (setq c1 (str1 i))
             (setq c2 (str2 i))
             (if (map1 c1)
               (if (!= c2 (map1 c1))
                   (setq out nil)
               )
               (if (map2 c2)
                   (setq out nil)
               )
             )
             (map1 c1 c2)
             (map2 c2 c1)
           )
          )
    )
    (delete 'map1)
    (delete 'map2)
    out
  )
)

(isomorfe "egg" "add")
;-> true
(isomorfe "foo" "bar")
;-> nil
(isomorfe "nonna" "lilla")
;-> true

Questa soluzione risolve questo problema in tempo O(n). Un altro metodo è quello di utilizzare un vettore per memorizzare le mappature dei caratteri elaborati (al posto di due hash-map).

1) Se le lunghezze di str1 e str2 non sono uguali, restituire Falso.
2) Per ogni carattere in str1 e str2
    a) Se questo carattere viene visto per la prima volta in str1,
       allora il carattere corrente di str2 non è apparso prima.
       (i) Se il carattere corrente di str2 è stato visto prima, restituisce Falso.
           Contrassegna il carattere corrente di str2 come visitato.
       (ii) Memorizza la mappatura dei caratteri correnti.
    b) Altrimenti controlla se la precedente occorrenza di str1[i] è stata mappata
       allo stesso carattere.

(define (isomorfe? str1 str2)
(catch
  (local (max-len m n marked mapp idx)
    ; lunghezza massima delle stringhe
    (setq max-len 256)
    (setq m (length str1))
    (setq n (length str2))
    ; le stringhe devono avere la stessa lunghezza
    (if (!= m n) (throw nil))
    ; memorizza i caratteri visitati di str1
    (setq marked (array max-len '("0")))
    ; memorizza le corrispondenze di ogni carattere di str1
    ; in quelle di str2
    (setq mapp (array max-len '(-1)))
    (for (i 0 (- n 1))
      (cond ((= (mapp (char (str1 i))) -1)
             (if (= (marked (char (str2 i))) "1")
                 (throw nil))
             ; the next expression don't work...
             ;
             ;(setf (marked (char (str2 i))) "1")
             (setq idx (char (str2 i)))
             (setf (marked idx) "1")
             ; the next expression don't work...
             ;(setf (mapp (char (str1 i))) (str2 i)))
             (setq idx (char (str1 i)))
             (setf (mapp idx) (str2 i)))
            ((!= (mapp (char (str1 i))) (str2 i))
             (throw nil))
      )
    )
    true)))

(isomorfe? "egg" "add")
;-> true
(isomorfe? "foo" "bar")
;-> nil
(isomorfe? "nonna" "lilla")
;-> true


------------------------------
Raggruppamento codici (Google)
------------------------------

Data una lista di soli caratteri 'R', 'G' e 'B', separa i valori
della lista in modo che tutte le R vengano al primo posto, le G al secondo posto e le B al terzo posto.
Ad esempio, dato l'array (G B R R B R G) il risultato vale (R R R G G B B).
La funzione deve risolvere il problema in tempo lineare O(n).

Il seguente algoritmo scorre la lista una volta (quando conta i caratteri), quindi la complessità temporale vale O(n).

(define (gruppo lst)
  (setq c (count '(R G B) lst))
  (extend (dup 'R (first c)) (dup 'G (first (rest c))) (dup 'B (last c))))

(gruppo '(G B R R B R G))
;-> (R R R G G B B)


-----------------------------
Caratteri differenti (Amazon)
-----------------------------

Dato un intero k e una stringa s, trovare la lunghezza della sottostringa più lunga che contiene al massimo k caratteri distinti.

Ad esempio, data s = "abcba" e k = 2, la sottostringa più lunga con k distinti caratteri vale 3 ed è "bcb".

(define (find-len s k)
  (local (start end max-len dist-char test)
    (setq start 0)
    (setq end k)
    (setq max-len k)
    (setq test true)
    (while (< end (length s))
      (++ end)
      (while test
        (setq dist-char (length (unique (explode (slice s start (- end start))))))
        (if (<= dist-char k)
           (setq test nil)
           (++ start)
        )
      )
      (setq test true)
      (setq max-len (max max-len (- end start)))
    )
    max-len))

(find-len "abcba" 2)
;-> 3

(find-len "abcbbba" 2)
;-> 5

(find-len "abcbcbccaaa" 2)
;-> 7

(find-len "abababccccccc" 2)
;-> 8


--------------------------------
Triple con una data somma (Uber)
--------------------------------

Data una lista di numeri distinti, trovare tutte le triple di numeri la cui somma è uguale a un dato numero.

Algoritmo:
1) Ordina la lista e per ogni elemento lst[i] cerca gli altri due elementi lst[l], lst[r] in modo tale che lst[i] + lst[l] + lst[r] = Somma.
2) La ricerca degli altri due elementi può essere eseguita in modo efficiente utilizzando la tecnica a due puntatori quando la lista è ordinata.
3) Esegui un ciclo esterno prendendo la variabile di controllo i e per ogni iterazione inizializza un valore l che è il primo puntatore con i+1 e r con l'ultimo indice.
4) Ora entra in un ciclo while che verrà eseguito fino al valore di l < r.
5) Se lst[i] + lst[l] + lst[r]> Somma, decrementa r ​​di 1 in quanto la somma richiesta 6) è inferiore alla somma corrente.
7) Se lst[i] + lst[l] + lst[r] < Somma, incrementa l di 1 in quanto la somma richiesta è inferiore alla somma corrente.
8) Se lst[i] + lst[l] + lst[r] == Somma abbiamo trovato una soluzione (tre valori).
9) Incrementa i Vai al passo 3.

Complessità temporale dell'algoritmo: O(n^2).

Pseudocodice:
1. Ordinare tutti gli elementi dell'lista
2. Eseguire il loop da i = 0 a n-2.
     Inizializza due variabili indice l = i + 1 e r = n-1
4. while (l < r)
     Controlla se la somma di lst[i], lst[l], lst[r] è uguale al valore Somma,
     allora memorizza il risultato e aggiorna gli indici (l++) e (r--).
5. Se la somma è inferiore alla somma indicata, allora l++
6. Se la somma è maggiore della somma data, allora r--
7. Se non esiste nella lista, soluzione non trovata.

Scriviamo la funzione "tripla":

(define (tripla lst somma)
  (local (l r x n out)
    (setq out '())
    (setq n (length lst))
    (sort lst)
    (for (i 0 (- n 2))
      (setq l (+ i 1))
      (setq r (- n 1))
      (setq x (lst i))
      (while (< l r)
        (cond ((= (+ x (lst l) (lst r)) somma)
               ;(println x { } (lst l) { } (lst r))
               (push (list x (lst l) (lst r)) out -1)
               (++ l)
               (-- r))
              ((< (+ x (lst l) (lst r)) somma)
               (++ l))
              (true (-- r))
        )
      )
    )
    out))

(tripla '(0 -1 2 -3 1 ) -2)
;-> ((-3 -1 2) (-3 0 1))
(tripla '(0 1 2 3 4 5 6 7 8 9 -9 -8 -7 -6 -5 -4 -3 -2 -1) 5)
;-> ((-9 5 9) (-9 6 8) (-8 4 9) (-8 5 8) (-8 6 7) (-7 3 9) (-7 4 8) (-7 5 7)
;->  (-6 2 9) (-6 3 8) (-6 4 7) (-6 5 6) (-5 1 9) (-5 2 8) (-5 3 7) (-5 4 6)
;->  (-4 0 9) (-4 1 8) (-4 2 7) (-4 3 6) (-4 4 5) (-3 -1 9) (-3 0 8) (-3 1 7)
;->  (-3 2 6) (-3 3 5) (-2 -1 8) (-2 0 7) (-2 1 6) (-2 2 5) (-2 3 4) (-1 0 6)
;->  (-1 1 5) (-1 2 4) (0 1 4) (0 2 3))


-----------------------
Somma perfetta (Amazon)
-----------------------

Data una lista di numeri interi e un numero intero K, trovare tutti i sottoinsiemi della lista data i cui elementi sommano esattamente al numero K.

Utilizziamo la funzione "powerset" che genera tutte le sottoliste di una lista e poi verifichiamo se la loro somma è uguale a K.

(define (powerset lst)
  (if (empty? lst)
      (list '())
      (let ( (element (first lst))
             (p (powerset (rest lst))))
           (append (map (fn (subset) (cons element subset)) p) p) )))

(powerset '(1 3 4 2))
;-> ((1 3 4 2) (1 3 4) (1 3 2) (1 3) (1 4 2) (1 4) (1 2)
;->  (1) (3 4 2) (3 4) (3 2) (3) (4 2) (4) (2) ())

Utilizzeremo la funzione "apply":
(apply + '(1 2 3))
;-> 6
(apply + '())
;-> 0

Scriviamo la funzione:

(define (trova-somma lst somma)
  (local (ps out)
    (setq out '())
    (setq ps (powerset lst))
    (dolist (el ps)
       (if (= (apply + el) somma)
           (push el out -1)))
    out))

(trova-somma '(1 2 3 -3 -2 -1) 5)
;-> ((1 2 3 -1) (2 3))
(trova-somma '(1 2 3 -3 -2 -1) 4)
;-> ((1 2 3 -2) (1 3) (2 3 -1))


------------------------------
Mescolare una lista (LeetCode)
------------------------------

Data una lista composta da 2n elementi nella seguente forma:

(x1 x2 ... xn y1 y2 ... yn)

Restituire una lista della forma:

(x1 y1 x2 y2 ... xn yn).

(define (mescola1 lst)
  (local (mid out)
    (setq out '())
    (setq mid (/ (length lst) 2))
    (for (i 0 (- mid 1))
      (push (lst i) out -1)
      (push (lst (+ i mid)) out -1)
    )
    out
  )
)

(mescola1 '(1 2 3 4 5 6 7 8))
;-> (1 5 2 6 3 7 4 8)

(define (mescola2 lst)
  (local (len mid)
    (setq len (length lst))
    (setq mid (/ len 2))
    ;(map list (slice lst 0 mid) (slice lst mid len))
    (flat (map cons (slice lst 0 mid) (slice lst mid len)))
  )
)

(mescola2 '(1 2 3 4 5 6 7 8))
;-> (1 5 2 6 3 7 4 8)

(setq lst (sequence 1 1000))
(time (mescola1 lst) 1000)
;-> 961.217

(setq lst (sequence 1 1000))
(time (mescola2 lst) 1000)
;-> 45.003


-------------------------
Lista somma (geeks4geeks)
-------------------------

Data una lista di numeri interi, sostituire ogni elemento con la somma di tutti gli altri elementi. Per ogni elemento, deve risultare:

lst[i] = sumOfListElements – lst[i]

(define (somma-lst lst)
  (let (sum (apply + lst))
    (setq lst (map (fn (x) (- sum x)) lst))))

(somma-lst '(2 3 4 -5 -4 6 7))
;-> (11 10 9 18 17 7 6)

(somma-lst '(0 0 0 0 0 0))
;-> (0 0 0 0 0 0)

Funzione simile che usa "curry":

(define (somma2-lst lst)
  (let (sum (apply + lst))
    (setq lst (map (curry - sum) lst))))

(somma2-lst '(2 3 4 -5 -4 6 7))
;-> (11 10 9 18 17 7 6)

(somma2-lst '(0 0 0 0 0 0))
;-> (0 0 0 0 0 0)

Prima funzione iterativa:

(define (somma3-lst lst)
  (let (sum (apply + lst))
    (dolist (el lst)
      (setf (lst $idx) (- sum el)))
    lst))

(somma3-lst '(2 3 4 -5 -4 6 7))
;-> (11 10 9 18 17 7 6)

(somma3-lst '(0 0 0 0 0 0))
;-> (0 0 0 0 0 0)

Seconda funzione iterativa che usa "push":

(define (somma4-lst lst)
  (let ((sum (apply + lst)) (out '()))
    (dolist (el lst)
       (push (- sum el) out -1)
    )
    (setq lst out)))

(somma4-lst '(2 3 4 -5 -4 6 7))
;-> (11 10 9 18 17 7 6)

(somma4-lst '(0 0 0 0 0 0))
;-> (0 0 0 0 0 0)

Vediamo la velocità delle funzioni:

(setq lst (sequence 1 1000))
(time (somma-lst lst) 10000)
;-> 857.979

(time (somma2-lst lst) 10000)
;-> 853.820

(time (somma3-lst lst) 10000)
;-> 9807.386

(time (somma4-lst lst) 10000)
;-> 899.060

La prima funzione iterativa è molto lenta perchè per modificare l'elemento i-esimo viene usata l'indicizzazione della lista (lst $idx).


--------------------------------------------
Ordinare una lista di 0, 1 e 2 (geeks4geeks)
--------------------------------------------

Dato una lista composta da 0, 1 e 2. Scrivere una funzione che ordina la lista. L'ordinamento deve mettere prima gli 0 (zero, Le funzioni dovrebbero mettere prima tutti i valori 0 (zero), quindi tutti i valori 1 (uno) e infine tutti i valori 2 (due).

Attraversiamo la lista, contiamo i valori 0, 1 e 2, infine ricostruiamo la lista.

(define (sort-012 lst)
  (local (a b c)
    (setq a 0 b 0 c 0)
    ; contiamo i valori 0, 1 e 2
    (dolist (el lst)
      (cond ((if (= el 0) (++ a)))
            ((if (= el 1) (++ b)))
            ((if (= el 2) (++ c)))
      )
    )
    ;ricostruzione della lista
    (for (i 0 (- a 1)) (setf (lst i) 0))
    (for (i a (- (+ a b) 1)) (setf (lst i) 1))
    (for (i (+ a b) (- (+ a b c) 1)) (setf (lst i) 2))
    lst
  )
)

(sort-012 '(0 2 2 2 1 0 0 2 0 1 1 2 ))
;-> (0 0 0 0 1 1 1 2 2 2 2 2)


------------------------------
Stipendio giusto (geeks4geeks)
------------------------------

Ci sono N dipendenti in un'azienda e ogni dipendente ha una valutazione. I dipendenti ricevono uno stipendio in base alla loro valutazione, cioè, i dipendenti con valutazione   più alta riceveranno uno stipendio maggiore. Un dipendente conosce solo lo stipendio e la valutazione dei suoi vicini, cioè quello a sinistra e quello a destra del dipendente.
Data una lista di N numeri interi positivi, che indica la valutazione di N dipendenti, trovare il minimo stipendio S che dovrebbe essere assegnato per ciascun dipendente, in modo tale che ogni dipendente venga trattato equamente.

Nota: gli stipendi sono solo numeri interi positivi e le valutazioni sono sempre maggiori di zero.

Possono verificarsi i seguenti casi:

Tipo 1: S(i-1) > S(i) < S(i+1)
Tipo 2: S(i-1) < S(i) < S(i+1)
Tipo 3: S(i-1) > S(i) > S(i+1)
Tipo 4: S(i-1) < S(i) > S(i+1)

Per ogni dipendente, in base ai casi precedenti, impostare lo Stipendio basandosi sulle regole seguenti:

Per il tipo 1: porre lo Stipendio a 1
Per il tipo 2: porre lo Stipendio a S(i-1) + 1.
Per il tipo 3: porre lo Stipendio a S(i+1) + 1.
Per il tipo 4: porre lo Stipendio a max(S(i-1), S(i+1)) + 1

(define (salario lst)
  (local (s n)
    (setq n (length lst))
    (setq s (array (+ 2 n) '(0)))
    (push 1e9 lst)
    (push 1e9 lst -1)
    ; tipo 1
    (for (i 1 n)
      (if (and (>= (lst (- i 1)) (lst i))
               (<= (lst i) (lst (+ i 1))))
          (setf (s i) 1)
      ))
    ; tipo 2
    (for (i 1 n)
      (if (and (< (lst (- i 1)) (lst i))
               (<= (lst i) (lst (+ i 1))))
          (setf (s i) (+ (s (- i 1)) 1))
      ))
    ; tipo 3
    (for (i 1 n)
      (if (and (>= (lst (- i 1)) (lst i))
               (> (lst i) (lst (+ i 1))))
          (setf (s i) (+ (s (+ i 1)) 1))
      ))
    ; tipo 4
    (for (i 1 n)
      (if (and (< (lst (- i 1)) (lst i))
               (> (lst i) (lst (+ i 1))))
          (setf (s i) (+ 1 (max (s (- i 1)) (s (+ i 1)))))
      ))
    (slice s 1 n)
  ))

(salario '(1 3 5 4))
;-> (1 2 3 1)

(salario '(5 3 4 2 1 6))
;-> (2 1 3 2 1 2)


----------------------------------
Volo completo (Programming Praxis)
----------------------------------

Su un volo esaurito, 100 persone si mettono in fila per salire sull'aereo. Il primo passeggero della linea ha perso la carta d'imbarco ma è stato autorizzato a entrare, indipendentemente. Si siede a caso. Ogni passeggero successivo prende il proprio posto assegnato, se disponibile, o un posto libero non occupato, altrimenti. Qual è la probabilità che l'ultimo passeggero a bordo dell'aereo trovi il suo posto libero?

Simuliamo il processo con 10 passeggeri:

; posti assegnati ad ogni passeggero
(setq assign (randomize (sequence 0 9)))
; posti liberi
(setq free (sequence 0 9))
; il primo passeggero prende un posto a caso
(println (pop free (rand 10)))
(println (pop assign 0))
assign
free
; Un passeggero prende posto
; se il posto è libero, allora prende quello
; altrimenti ne prende uno a caso (il primo libero)
(dolist (el assign)
  (cond ((= $idx 8)
         (println "Ultimo passeggero: " el)
         (println "posti liberi :" free)
         (if (not (null? (ref el free)))
             true
             nil)
        )
        (true
         (if (ref el free)
             (begin
              (println "il passeggero: " $idx " con posto " el " posto ok " free)
              (pop free (ref el free))
             )
             (begin
              (println "il passeggero: " $idx " con posto " el " posto a caso " (pop free 0)))
             )
        )
  )
)

;-> (1 7 6 4 9 5 0 8 2 3)
;-> (0 1 2 3 4 5 6 7 8 9)
;-> 6
;-> 6
;-> 1
;-> 1
;-> (7 6 4 9 5 0 8 2 3)
;-> (0 1 2 3 4 5 7 8 9)
;-> il passeggero: 0 con posto 7 posto ok (0 1 2 3 4 5 7 8 9)
;-> il passeggero: 1 con posto 6 posto a caso 0
;-> il passeggero: 2 con posto 4 posto ok (1 2 3 4 5 8 9)
;-> il passeggero: 3 con posto 9 posto ok (1 2 3 5 8 9)
;-> il passeggero: 4 con posto 5 posto ok (1 2 3 5 8)
;-> il passeggero: 5 con posto 0 posto a caso 1
;-> il passeggero: 6 con posto 8 posto ok (2 3 8)
;-> il passeggero: 7 con posto 2 posto ok (2 3)
;-> Ultimo passeggero: 3
;-> posti liberi :(3)
;-> true

Scriviamo la funzione di simulazione:

(define (place)
  (local (assign free)
    (setq assign (randomize (sequence 0 99)))
    (setq free (sequence 0 99))
    ; il primo passeggero prende un posto a caso
    (pop free (rand 100))
    (pop assign 0)
    ; Prendere un posto
    ; se il posto è libero, allora prende quello
    ; altrimenti ne prende uno a caso (il primo libero)
    (dolist (el assign)
      (cond ((= $idx 98) ; verifica sull'ultimo passeggero
              ;(println "Ultimo passeggero: " el)
              ;(println "posti liberi :" free)
              (if (not (null? (ref el free)))
                  true
                  nil)
            )
            (true
              (if (ref el free)
                    (pop free (ref el free))
                    (pop free 0)
              )
            )
      )
    )
  )
)

(place)
;-> nil
(place)
;-> nil
(place)
;-> true

Scriviamo una funzione che esegue n volte la simulazione:

(define (test n)
  (let (ok 0)
    (for (i 1 n)
      (if (place) (++ ok)))
    (mul 100 (div ok n))))

Calcoliamo la probabilità simulata:

(test 100000)
;-> 50.078999

(test 100000)
;-> 49.897

(test 1000000)
;-> 49.8934

La simulazione produce un valore di probabilità intorno al 50%.

Vediamo la teoria matematica:

Per ogni passeggero, dopo lo 0-esimo passeggero iniziale, la probabilità di prendere il 99-esimo posto (ultimo) è la probabilità che un passeggero precedente abbia preso il suo posto moltiplicato per la probabilità che prendano il 99-esimo posto del passeggero dai posti rimanenti.

Il passeggero 0-esimo ha una probabilità 1/100 di prendere il posto del 99-esimo passeggero.

Il passeggero 1-esimo ha una probabilità (1/100 * 1/99 = 1/9900) di prendere il posto del  99-esimo passeggero, che è la probabilità che lo 0-esimo passeggero abbia preso il posto del 1-esimo passeggero, moltiplicato per la probabilità che il 1-esimo passeggero prenda il posto del 99-esimo passeggero dai 99 posti rimanenti.

La probabilità che venga preso il posto del secondo passeggero è (1/100 + 1/9900 = 1/99), la probabilità che sia il passeggero 0 o il passeggero 1 si trovino al loro posto. Data la intrinseca simmetria del problema, 1/100 e 1/9900 sono le stesse probabilità dai precedenti calcoli. Poiché gli eventi si escludono a vicenda, è possibile aggiungere le probabilità. Pertanto, il secondo passeggero ha una probabilità (1/99 * 1/98 = 1/9702) di prendere il posto del 99-esimo passeggero, che è la probabilità che lo 0-esimo passeggero o il 1-esimo passeggero abbia preso il posto del secondo passeggero, moltiplicato per la probabilità che il secondo passeggero prenda il posto del 99-esimo passeggero dai 98 posti rimanenti.

Emerge un modello in cui per (x > 0), la probabilità che il sedile del passeggero x sia preso è 1/(100 - x + 1) e la probabilità che l'x-esimo passeggero si trovi nel posto del 99-esimo passeggero è (1/(100 - x + 1)) * (1/(100 - x)).

Ecco la sequenza corrispondente che mostra la probabilità che l'x-esimo passeggero sia al posto del 99-esimo passeggero:

1/100, (1/100) * (1/99), (1/99) * (1/98), (1/98) * (1/97), ..., (1/3) * (1/2), (1/2) (1/1)

Un ragionamento simile può essere utilizzato per un numero diverso di posti iniziali, dove 1/2 sarebbe comunque la probabilità risultante che venga preso il posto dell'ultimo passeggero.

Per trovare la soluzione useremo alcune funzioni per il calcolo con le frazioni e calcoleremo la sequenza delle probabilità di ogni paseggero di trovarsi nel posto del 99-esimo passeggero.
L'ultimo valore è la probabilità che l'ultimo passeggero occupi il proprio posto (la risposta alla domanda).

Funzioni per il calcolo con le frazioni:

(define (rat n d)
  (let (g (gcd n d))
    (map (curry * 1L)
         (list (/ n g) (/ d g)))))

(define (+rat r1 r2)
  (rat (+ (* (r1 0) (r2 1))
          (* (r2 0) (r1 1)))
       (* (r1 1) (r2 1))))

(define (-rat r1 r2)
  (rat (- (* (r1 0) (r2 1))
          (* (r2 0) (r1 1)))
       (* (r1 1) (r2 1))))

(define (*rat r1 r2)
  (rat (* (r1 0) (r2 0))
       (* (r1 1) (r2 1))))

(define (/rat r1 r2)
  (rat (* (r1 0) (r2 1))
       (* (r1 1) (r2 0))))

Funzione che calcola le probabilità:

(define (volo n)
  (local (a b prob)
    (setq prob '())
    (push (list 1 n) prob)
    (for (i 1 (- n 1))
      (setq a (list 1 (- 101 i)))
      (setq b (list 1 (- 100 i)))
      (push (*rat a b) prob -1)
    )
    (dolist (el prob)
      (println $idx ": " el { } (div (el 0) (el 1)))
    )
  ))

(volo 100)
;-> 0: (1 100) 0.01
;-> 1: (1L 9900L) 0.000101010101010101
;-> 2: (1L 9702L) 0.0001030715316429602
;-> 3: (1L 9506L) 0.0001051967178624027
;-> 4: (1L 9312L) 0.0001073883161512028
;-> 5: (1L 9120L) 0.0001096491228070176
;-> 6: (1L 8930L) 0.0001119820828667413
;-> 7: (1L 8742L) 0.0001143902997025852
;-> 8: (1L 8556L) 0.0001168770453482936
;-> 9: (1L 8372L) 0.0001194457716196847
;-> 10: (1L 8190L) 0.0001221001221001221
;-> ...
;-> 88: (1L 156L) 0.00641025641025641
;-> 89: (1L 132L) 0.007575757575757576
;-> 90: (1L 110L) 0.009090909090909091
;-> 91: (1L 90L) 0.01111111111111111
;-> 92: (1L 72L) 0.01388888888888889
;-> 93: (1L 56L) 0.01785714285714286
;-> 94: (1L 42L) 0.02380952380952381
;-> 95: (1L 30L) 0.03333333333333333
;-> 96: (1L 20L) 0.05
;-> 97: (1L 12L) 0.08333333333333333
;-> 98: (1L 6L) 0.1666666666666667
;-> 99: (1L 2L) 0.5

La teoria conferma che il valore di probabilità vale 1/2.


-------------------------
Benzina e stazioni (Uber)
-------------------------

In un percorso chiuso ci sono N stazioni di benzina.
Ogni i-esima stazione ha gas(i) carburante.
Il viaggio dalla stazione i-esima alla stazione successiva consuma carburante pari a cost(i).
Abbiamo a disposizione una macchina con il serbatoio vuoto (ma illimitato) che parte dalla iesima-stazione
Dobbiamo verificare se possiamo ritornare alla stazione di partenza oppure se non esiste alcuna stazione di partenza che permette il giro completo del percorso.

Esempio:

 7           2          12
  A----------B---------C
   \   10        9    /
    \                /
     \ 8          7 /
      \     5      /
       E----------D
      8            10

N    Stazione    Carburante    Percorso    Costo
0     A            7          A <-> B      10
1     B            2          B <-> C       9
2     C           12          C <-> D       7
3     D           10          D <-> E       5
4     E            8          E <-> A       8

Simuliamo il percorso partendo da ogni stazione:

start A (0)
A -> B  Serbatoio=7        Costo=10   --> Serbatoio=7-10=-3 (impossibile)

start B (1)
B -> C  Serbatoio=2        Costo=9    --> Serbatoio=2-9=-7 (impossibile)

start C (2)
C -> D  Serbatoio=12       Costo=7    --> Serbatoio=12-7=5
D -> E  Serbatoio=5+10     Costo=5    --> Serbatoio=15-5=10
E -> A  Serbatoio=10+8=18  Costo=8    --> Serbatoio=18-8=10
A -> B  Serbatoio=10+7=17  Costo=10   --> Serbatoio=17-10=7
B -> C  Serbatoio=7+2=9    Costo=9    --> Serbatoio=9-9=0 (possibile)

start D (3)
D -> E  Serbatoio=10       Costo=5    --> Serbatoio=10-5=5
E -> A  Serbatoio=5+8=13   Costo=8    --> Serbatoio=13-8=5
A -> B  Serbatoio=5+7=12   Costo=10   --> Serbatoio=12-10=2
B -> C  Serbatoio=2+2=4    Costo=8    --> Serbatoio=4-8=-4 (impossibile)

start E (4)
E -> A  Serbatoio=8        Costo=8    -->Serbatoio=8-8=0
A -> B  Serbatoio=0+2=2    Costo=10   -->Serbatoio=2-10=-8 (impossibile)

Poniamo i dati in due liste:

(setq gas '(7 2 12 10 8))
(setq cost '(10 9 7 5 8))

Per ogni stazione calcoliamo la differenza tra il Carburante disponibile e il Costo per arrivarci.

(setq diff (map - gas cost))
;-> (-2 -7 5 5 0)

Un percorso completo è possibile se: Sum[0..n](diff(i)) >= 0

(if (>= (apply + diff) 0)
    (println "possibile")
    (println "impossibile"))
;-> possibile

Adesso dobbiamo calcolare da quale stazione occorre partire per completare il giro.
Se controlliamo ogni stazione di partenza la complessità temporale dell'algoritmo vale O(n^2).
Notiamo che attraversando la lista "diff" possiamo calcolare la stazione di partenza.
Per esempio:
0) partendo da A abbiamo subito il valore negativo -2 che indica che tale stazione non può essere quella iniziale
1) partendo da B abbiamo subito il valore negativo -7 che indica che tale stazione non può essere quella iniziale
2) partendo da C abbiamo 5, poi arriviamo in D e aggiungiamo 5 (5+5=10), poi arriviamo in E e aggiungiamo 0 (10+0=10), poi arriviamo in A e aggiungiamo -2 (10-2=8), poi arriviamo in B e aggiungiamo -7 (8-7=1)
3) partendo da D abbiamo 5, poi arriviamo in E e aggiungiamo 0 (5+0=0), poi arriviamo in A e aggiungiamo -2 (5-2=3), poi arriviamo in B e aggiungiamo -7 (3-7=-4), quindi D non può essere la stazione iniziale
4) partendo da E abbiamo 0, poi arriviamo in A e aggiungiamo -2 (0-2=-2), quindi E non può essere la stazione di partenza.

Quindi è sufficiente analizzare la lista "diff" per determinare da quale stazione dobbiamo partire per terminare il percorso chiuso. Questo può essere fatto con un ciclo soltanto, quindi la complessità temporale vale O(n).

(define (percorso gas cost)
  (local (diff leftGas sum startnode)
    (setq leftGas 0 sum 0 startnode 0)
    (setq diff (map - gas cost))
    (for (i 0 (- (length gas) 1))
      (setq leftGas (+ leftGas (diff i)))
      (setq sum (+ sum (diff i)))
      ; se la somma è minore di 0,
      ; allora scartiamo quella stazione
      (if (< sum 0)
        (setq startnode (+ i 1) sum 0))
    )
    (if (< leftGas 0)
        nil
        startnode)
  )
)

(percorso gas cost)
;-> 2

La stazione di partenza è la 2, cioè C.


-----------------------
Aggiungere uno (Google)
-----------------------

Data una lista che rappresenta un numero intero, scrivere una funzione che aggiunge 1 al numero rappresentato dalla lista tenendo conto del riporto (carry).

(define (add1 lst)
  (local (carry sum out)
    (setq carry 1 sum 0)
    (for (i (- (length lst) 1) 0 -1)
      (setq sum (+ carry (lst i)))
      (setq carry (/ sum 10))
      (push (% sum 10) out)
    )
    (if (> carry 0) (push carry out))
    out))

(setq lst '(1 2 3 4))
(add1 lst)
;-> (1 2 3 4 5)

(setq lst '(9 8 8 9))
(add1 lst)
;-> (9 8 9 0)

(setq lst '(9 9 9 9))
(add1 lst)
;-> (1 0 0 0 0)


------------------------
Numeri romani (LeetCode)
------------------------

Scrivere due funzioni che convertono da numero intero a numero romano e viceversa.
Le funzioni che implementeremo sono valide per i numeri interi nell'intervallo 1..3999.

Conversione da intero a romano
------------------------------

La strategia è quella di convertire il numero utilizzando intervalli differenti:

a) 1<= cifra <=3
b) cifra = 4
c) cifra = 5
d) 5 < cifra <=8
e) cifra = 9

(define (integer2roman num)
  (local (simboli roman scale digit)
    (setq simboli '("I" "V" "X" "L" "C" "D" "M"))
    (setq roman "")
    (setq scale 1000)
    (for (i 6 0 -2)
      (setq digit (/ num scale))
      (if (!= digit 0)
        (cond ((<= digit 3)
                (for (k 1 digit)
                  (push (simboli i) roman -1)
                ))
              ((= digit 4)
                (push (simboli i) roman -1)
                (push (simboli (+ i 1)) roman -1))
              ((= digit 5)
                (push (simboli (+ i 1)) roman -1))
              ((<= digit 8)
                (push (simboli (+ i 1)) roman -1)
                (for (k 1 (- digit 5))
                  (push (simboli i) roman -1)
                ))
              ((= digit 9)
                (push (simboli i) roman -1)
                (push (simboli (+ i 2)) roman -1))

        );cond
      )
      (setq num (% num scale))
      (setq scale (/ scale 10))
    )
    roman
  ))

(integer2roman 3)
;-> "III"

(integer2roman 1234)
;-> "MCCXXXIV"

(integer2roman 4000)
;-> ERR: invalid list index
;-> called from user function (integer2roman 4000)

Conversione da romano a intero
------------------------------

Utilizziamo una tabella di conversione tra cifra romana e cifra numerica.
Poi attraversiamo la stringa romana da sinistra a destra:
a) se la cifra/carattere corrente è maggiore di quella precedente, allora le due cifre formano un numero combinato. Il valore di questo numero (che deve essere aggiunto al risultato corrente) è dato dalla sottrazione della cifra precedente dalla cifra corrente (es. IX = 10 - 1 = 9).
b) altrimenti aggiungere la cifra corrente al risultato e processare la cifra/carattere successivo

Tabella di conversione:

(lookup "I" table)
;-> 1

(define (roman2integer str)
  (let ((out 0)
        (table '(("I" 1) ("V" 5) ("X" 10) ("L" 50) ("C" 100) ("D" 500) ("M" 1000))))
    (for (i 0 (- (length str) 1))
      (if (and (> i 0) (> (lookup (str i) table) (lookup (str (- i 1)) table)))
          (setq out (+ out (lookup (str i) table) (- (* 2 (lookup (str (- i 1)) table)))))
          ;else
          (setq out (+ out (lookup (str i) table)))
      )
    )
    out))

(roman2integer "IX")
;-> 9

(roman2integer "MCCXXXIV")
;-> 1234

(roman2integer (integer2roman 3999))
;-> 3999

Test di correttezza:

(for (i 1 3999)
  (if (!= i (roman2integer (integer2roman i)))
    (println "error: " i)))
;-> nil


-----------------------
Numero singolo (McAfee)
-----------------------

Data una lista di numeri interi positivi ogni numero compare due volte tranne un numero. Trovare il numero singolo.
Nota: la funzione deve attraversare la lista una sola volta O(n).

Usiamo l'operatore XOR (OR esclusivo) che restituisce zero quando viene applicato a due numeri uguali:

(^ 10 10)
;-> 0

Quindi applichiamo lo XOR in maniera iterativa a tutti i numeri della lista. Il valore finale rappresenta il numero singolo.

lst = (1 2 3 2 3)

numero = ((((1 XOR 2) XOR 3) XOR 2) XOR 3) = 1

(define (singolo lst)
  (let (solo (lst 0))
    (for (i 1 (- (length lst) 1))
      (setq solo (^ solo (lst i)))
    )
    solo))

(singolo '(1 3 3))
;-> 1
(singolo '(1 3 3 1 2 2 4 5 6 4 6))
;-> 5
(singolo '(1 3 3 4 1 2 2 4 8 7 7))
;-> 8

Possiamo utilizzare la funzione "apply":

(define (singolo lst) (apply ^ lst))

(singolo '(1 3 3))
;-> 1
(singolo '(1 3 3 1 2 2 4 5 6 4 6))
;-> 5
(singolo '(1 3 3 4 1 2 2 4 8 7 7))
;-> 8

Vediamo la soluzione proposta da fdb:

(define (find-number lst)
	(define Myhash:Myhash)  ; hash table creation, O(1) lookup time
	(set 'total 0)
	(dolist (n lst)
	(if (Myhash n)
		(dec total n)    ; decrease when already added before
		(begin
			(Myhash n true)
			(inc total n))))  ; if not in hash table increase
	(delete 'Myhash)  ; first to delete contents and namespace
	(delete 'Myhash)  ; second to delete symbol
	total)

(find-number '(1 2 3 4 5 3 2 1 5))
;-> 4


--------------------------
Matrici a spirale (Google)
--------------------------

Problema 1
----------
Data una matrice di (m x n) elementi, ritornare una lista con tutti gli elementi della matrice in ordine spirale.
In altre parole, visitare in ordine spirale gli elementi della matrice.
Esempi:

Matrice:
 |1 2 3|
 |4 5 6|
 |7 8 9|  =>  Lista: (1 2 3 6 9 8 7 4 5)

Matrice:
 |1  2  3  4|
 |5  6  7  8|
 |9 10 11 12|  => Lista: (1 2 3 4 8 12 11 10 9 5 6 7)

(define (leggi-spirale matrix)
  (local (row_len col_len output)
    (setq output '())
    (setq row_len (length matrix))
    (setq col_len (length (matrix 0)))
    (order-read matrix 0 row_len 0 col_len output)
  ))

(define (order-read matrix row_s row_len col_s col_len output)
  (let (return nil)
    (cond ((or (<= row_len 0) (<= col_len 0)) (setq return true)))
    (if (not return)
      (cond ((= row_len 1)
             (for (i col_s (+ col_s col_len -1))
               (push (matrix row_s i) output -1)
             )
             (setq return true))
      )
    )
    (if (not return)
      (cond ((= col_len 1)
             (for (i row_s (+ row_s row_len -1))
               (push (matrix i col_s) output -1)
             )
             (setq return true))
      )
    )
    (if (not return)
      (begin
      ; up
      (for (i col_s (+ col_s col_len -2))
        (push (matrix row_s i) output -1)
      )
      ; right
      (for (i row_s (+ row_s row_len -2))
        (push (matrix i (+ col_s col_len -1)) output -1)
      )
      ; down
      (for (i col_s (+ col_s col_len -2))
        (push (matrix (+ row_s row_len -1) (+ (* 2 col_s) col_len -1 (- i))) output -1)
      )
      ; left
      (for (i row_s (+ row_s row_len -2))
        (push (matrix (+ (* 2 row_s) row_len -1 (- i)) col_s) output -1)
      )
      (order-read matrix (+ row_s 1) (+ row_len -2) (+ col_s 1) (+ col_len -2) output)
      )
    ;else
      output
   )
  ))

(leggi-spirale '((1 2 3) (4 5 6) (7 8 9)))
;-> (1 2 3 6 9 8 7 4 5)

(leggi-spirale '((1 2 3 4) (5 6 7 8) (9 10 11 12)))
;-> (1 2 3 4 8 12 11 10 9 5 6 7)

Problema 2
----------
Dato un numero intero positivo n, generare una matrice quadrata di ordine n con tutti i numeri da 1 a n^2 disposti in ordine spirale.
Esempi:
                     |1 2 3|
 n = 3  =>  Matrice: |8 9 4|
                     |7 6 5|

                     | 1  2  3 4|
 n = 4  =>  Matrice: |12 13 14 5|
                     |11 16 15 6|
                     |10  9  8 7|

La soluzione è analoga alla precedente, l'unica differenza sta nel fatto che invece di "leggere" a spirale questa volta "scriviamo" a spirale.

(define (crea-spirale n)
  (local (row_len col_len val matrix)
    (setq row_len n)
    (setq col_len n)
    (setq val 1)
    (setq matrix (array n n '()))
    (order-write matrix 0 row_len 0 col_len val)
  ))

(define (order-write matrix row_s row_len col_s col_len val)
  (let (return nil)
    (cond ((or (<= row_len 0) (<= col_len 0)) (setq return true)))
    (if (not return)
      (cond ((= row_len 1)
             (for (i col_s (+ col_s col_len -1))
               (setf (matrix row_s i) val)
               (++ val)
             )
             (setq return true))
      )
    )
    (if (not return)
      (cond ((= col_len 1)
             (for (i row_s (+ row_s row_len -1))
               (setf (matrix i col_s) val)
               (++ val)
             )
             (setq return true))
      )
    )
    (if (not return)
      (begin
      ; up
      (for (i col_s (+ col_s col_len -2))
        (setf (matrix row_s i) val)
        (++ val)
      )
      ; right
      (for (i row_s (+ row_s row_len -2))
        (setf (matrix i (+ col_s col_len -1)) val)
        (++ val)
      )
      ; down
      (for (i col_s (+ col_s col_len -2))
        (setf (matrix (+ row_s row_len -1) (+ (* 2 col_s) col_len -1 (- i))) val)
        (++ val)
      )
      ; left
      (for (i row_s (+ row_s row_len -2))
        (setf (matrix (+ (* 2 row_s) row_len -1 (- i)) col_s) val)
        (++ val)
      )
      (order-write matrix (+ row_s 1) (+ row_len -2) (+ col_s 1) (+ col_len -2) val)
      )
    ;else
      matrix
   )
  ))

(crea-spirale 3)
;-> ((1 2 3) (8 9 4) (7 6 5))
(1 2 3)
(8 9 4)
(7 6 5)

(crea-spirale 4)
;-> ((1 2 3 4) (12 13 14 5) (11 16 15 6) (10 9 8 7))
( 1  2  3 4)
(12 13 14 5)
(11 16 15 6)
(10  9  8 7)


------------------------------------------------------------------------
Lunghezza della sottostringa più lunga senza caratteri ripetuti (Amazon)
------------------------------------------------------------------------

Data una stringa, trova la lunghezza della sottostringa più lunga senza caratteri ripeturi.
Esempi:
"ABDEFGABEF" -> le sottostringhe più lunghe sono "BDEFGA" e "DEFGAB", con lunghezza 6.
"BBBB"       -> la sottostringa più lunga è "B", con lunghezza 1.

L'approccio più semplice consiste nell'estrarre tutte le sottostringhe da una stringa e quindi calcolare la lunghezza delle sottostringhe con solo caratteri distinti. Ci saranno [(n * (n + 1)) / 2] sottostringhe in una stringa di n caratteri. Questo metodo ha una complessità temporale pessima, ovvero O(n^3).

Possiamo risurre la complessità temporale in tempo lineare O(n) con la tecnica di "window sliding". Questo algoritmo utilizza una variabile per mantenere l'ultimo indice dei caratteri visitati. Si parte dal primo indice e ci spostiamo verso la fine della stringa: teniamo traccia della lunghezza massima della sottostringa con caratteri non ripetuti visitati finora. Quando la stringa viene attraversata, ogni nuovo carattere viene cercato nella parte già visitata della stringa (per questo viene utilizzato un vettore temporaneo). Se il carattere non è presente, la lunghezza corrente viene incrementata di 1. Se il carattere è già presente, possiamo avere due casi:

Caso 1: l'occorrenza precedente di questo carattere non fa parte della sottostringa corrente più lunga. Se questo è vero, la lunghezza corrente viene semplicemente incrementata di 1.

Caso 2: se l'occorrenza precedente di questo carattere fa parte della sottostringa corrente di caratteri non ripetuti, la sottostringa corrente più lunga cambia. Ora, inizia dal carattere che viene subito dopo la precedente occorrenza del carattere attualmente elaborato.

(define (unique-substr str)
  (local (n cur-len max-len prev-idx visited)
    (setq n (length str))
    ; length of current running substring
    (setq cur-len 1)
    ; Initialize the visited array as -1
    ; -1 indicates that the character was not visited
    (setq visited (array 256 '(-1)))
    ; Mark first character as visited with 0
    (setf (visited (char (str 0) 0 true)) 0)
    ; Start from the second character
    (for (i 1 (- n 1))
      (setq prev-idx (visited (char (str i) 0 true)))
      (if (or (= prev-idx -1) (> (- i cur-len) prev-idx))
          ; case 1
          (++ cur-len)
          ; case 2
          (begin
          ; Check if the length of previous running substring
          ; was more than the current or not
          (if (> cur-len max-len)
              (setq max-len cur-len))
          (setq cur-len (- i prev-idx))
          )
      )
      ; Index update of current character
      (setf (visited (char (str i) 0 true)) i)
    )
    ; Compare the length of last current running longest substring
    ; with max-len and update max-len if needed
    (if (> cur-len max-len)
        (setq max-len cur-len)
    )
    max-len))

(unique-substr "ABDEFGABEF")
;-> 6

(unique-substr "BBBB")
;-> 1

(unique-substr "ABCADE")
;-> 5

(time (unique-substr "segfhkqslrkgfhljerhygfqjegrhfqjsrhgfqegrhjfjq") 10000)
;-> 269.309

La seguente funzione utilizza un algoritmo simile al precedente:

(define (unique-substr str)
  (local (last-index len res-num res-str max-char idx cur-idx)
    (setq max-char 256)
    ; Initialize the last index array as -1,
    ; -1 is used to store last index of every character
    (setq last-index (array max-char '(-1)))
    (setq len (length str))
    (setq res-num 0)
    (setq res-str "")
    (setq idx 0)
    (for (j 0 (- len 1))
      ; Find the last index of str[j]
      ; Update i - starting index of current window -
      ; as maximum of current value of i and last
      ; index plus 1
      (setq cur-idx (char (str j) 0 true)) ; for UTF-8
      (setq idx (max idx (+ (last-index cur-idx) 1)))
      ; Update result if we get a larger window
      (setq res-num (max res-num (- (+ j 1) idx)))
      ; Update last index of j
      (setf (last-index cur-idx) j)
    )
    res-num))

(unique-substr "ABDEFGABEF")
;-> 6

(unique-substr "BBBB")
;-> 1

(unique-substr "ABCADE")
;-> 5

(time (unique-substr "segfhkqslrkgfhljerhygfqjegrhfqjsrhgfqegrhjfjq") 10000)
;-> 259.333


---------------------------------------
Rendere palindroma una stringa (Google)
---------------------------------------

Data una stringa, trovare il minor numero di caratteri da aggiungere all'inizio della stringa per renderla palindroma.
Restituire la stringa palindroma ottenuta.
Esempi:
Stringa: "abc"
Output: "cbabc"

La stringa "abc" diventa palindroma aggiungendo "c" e "b" all'inizio della stringa.

L'algoritmo è il seguente:
Fino a che la stringa non è nulla e la stringa corrente non è palindroma:
  se la stringa è palindroma, uscire dal ciclo
  in caso contrario, eliminare l'ultimo carattere della stringa e aggiungerlo alla fine del risultato parziale.
Infine unire la stringa iniziale e il risultato parziale.

Esempio:
stringa: "eva"
risultato: ""
"eva" non è palindroma, allora tolgo l'ultimo carattere "a" e lo aggiungo alla fine del risultato parziale:
stringa: "ev"
risultato parziale: "a"

"ev" non è palindroma, allora tolgo l'ultimo carattere "v" e lo aggiungo alla fine del risultato parziale:
stringa: "ev"
risultato parziale: "av"

"e" è palindroma, allora unisco il risultato parziale e la stringa iniziale:
stringa iniziale: "eva"
risultato parziale: "av"
unione della stringa iniziale con risultato parziale: "av" + "eva" = "aveva"

Vediamo una possibile implementazione:

(define (palindroma? str)
  (= str (reverse (copy str))))

(define (make-palindrome-front str)
  (local (s found out)
    (setq s str)
    (setq out '())
    (while (and (> (length s) 0) (not found))
      ; se la stringa è palindroma, allora stop
      (if (palindroma? s)
          (setq found true)
      ;else
      ; altrimenti toglie l'ultimo carattere della stringa
      ; e lo aggiunge all'inizio della stringa soluzione
          (push (pop s (- (length s) 1)) out -1)
      )
    )
    (append (join out) str)))

(make-palindrome-front "abc")
;-> "cbabc"

(make-palindrome-front "anna")
;-> "anna"

(make-palindrome-front "eva")
;-> "aveva"


--------------------
Cifre diverse (Visa)
--------------------

Quanti numeri hanno cifre diverse da 1 a un milione?

Per vedere se due numeri hanno le stesse cifre possiamo ordinare le cifre in modo decrescente e poi verificare se l'ordinamento è lo stesso per entrambi i numeri. Per fare questa codifica usiamo la funzione "digit-sort":

(define (digit-sort num)
  (let (out 0)
    (dolist (el (sort (explode (string num)) >))
      (setq out (+ (* out 10) (int el))))))

Per esempio i due numeri 45637028 e 65782043 hanno le stesse cifre e quindi producono la stessa codifica:

(digit-sort 45637028)
;-> 87654320
(digit-sort 65782043)
;-> 87654320

Le cifre devono essere uguali anche nella molteplicità, ad esempio 123 è diverso da 1223:

(digit-sort 123)
;-> 321
(digit-sort 1223)
;-> 3221

Possiamo inserire tutte le codifiche in una lista e poi eliminare gli elementi multipli:

(define (unici num)
  (let (out '())
    (for (i 1 num)
      (push (digit-sort i) out -1)
    )
    (length (unique out))))

(unici 1000000)
;-> 8002

(time (unici 1000000))
;-> 4466.223

Proviamo ad utilizzare una hash-map:

(define (unici2 num)
  (let ((key 0) (out '()))
    (new Tree 'myHash)
    (for (i 1 num)
      (setq key (digit-sort i))
      (myHash key key)
    )
    (println (length (myHash)))
    (delete 'myHash)
  ))

(unici2 1000000)
;-> 8002

(time (unici2 1000000))
;-> 4247.46

Le due funzioni hanno tempi simili perchè nella prima funzione la primitiva "unique" è molto veloce e non facciamo nessun accesso random alla lista.


-------------------------
Rapporto minimo (Wolfram)
-------------------------

Abbiamo un numero intero di 5 cifre n. Eliminando la cifra centrale di n otteniamo un altro numero m.
Determinare tutti i numeri n per cui risulta intero il numero n/m.

(define (cerca)
  (let (out '())
    (for (n 10000 99999)
      (setq m (+ (* (/ n 1000) 100) (% n 100)))
      (if (zero? (% n m)) (push (list n m (div n m)) out -1))
    )
    out))

;-> ((10000 1000 10) (11000 1100 10) (12000 1200 10) (13000 1300 10) (14000 1400 10)
;->  (15000 1500 10) (16000 1600 10) (17000 1700 10) (18000 1800 10) (19000 1900 10)
;->  ...
;->  (95000 9500 10)
;->  (96000 9600 10)
;->  (97000 9700 10)
;->  (98000 9800 10)
;->  (99000 9900 10))

(length (cerca))
;-> 90

Dal punto di vista matematico:

n = x*10^4 + y*10^3 + z*10^2 + u*10 + v
m = x*10^3 + y*10^2 + u*10 + v

Poichè n/m deve essere intero, anche (10*m - n)/m deve essere intero:

(10*m - n) = (u - z)*10^2 + (v - u)*10 - v

ma (10*m - n) è un numero di tre cifre mentre m è un numero con quattro cifre, quindi deve risultare:

(10*m - n)/m = 0, cioè (10*m - n) = 0.

Questo implica che deve risultare u = v = z = 0. Quindi i numeri n e m diventano:

n = x*10^4 + y*10^3
m = x*10^3 + y*10^2

cioè n può essere scritto come n = 10^3*N, dove 10 <= N <= 99.

Tra 10 e 99 compresi esistono 90 numeri, quindi i numeri di cinque cifre per cui n/m è un intero sono 90.


-------------------------
Quadrato binario (McAfee)
-------------------------

Dato il numero binario 111...111 composto dalla cifra 1 ripetuta k volte, determinare il suo quadrato (in binario).

Un numero binario con k cifre uguali a 1 può essere scritto:

1 + 2 + 2^2 + 2^3 + ... + 2^(k-1) = 2^k - 1

Il suo quadrato vale:

(2^k - 1)^2 = 2^(2k) - 2^(k+1) + 1 =
            = 2^(k+1)*(2^(k-1) -1) + 1 =
            = 2^(k+1)*(2^(k-2) + 2^(k-3) + ... + 1) + 1 =
            = 2^(2k-1) + 2^(2k-2)+ ... + 2^(k+1) + 1

In binario questo quadrato vale:

111...11 000...000 1
-------- ---------
 (k-1)       k

Per esempio:

a   = 111     (in decimale a = 7)
a^2 = 110001  (in decimale a^2 = 49)

Scriviamo la funzione:

(define (quad-bin bnum)
  (let (ll (length bnum))
    (extend (slice bnum 1 ll) (dup "0" ll ) "1")))

(quad-bin "111")
;-> "110001"
(int "111" 0 2)
;-> 7
(int "110001" 0 2)
;-> 49

(quad-bin "11111111")
;-> "1111111000000001"
(int "11111111" 0 2)
;-> 255
(int "1111111000000001" 0 2)
;-> 65025


----------------------------------
Fattoriale e zeri finali (Wolfram)
----------------------------------

Il numero di zeri finali del fattoriale di un numero intero n è dato da:

  Numero di zeri finali in n! =
= Numero di volte n! è divisibile per 10 =
= Potenza massima di 10 che divide n! =
= Potenza massima di 5 in n!

Utilizzando l'ultima definizione la formula per il calcolo è la seguente:

int(n/5) + int(n/5^2) + int(n/5^3) + ... + int(n/5^k)

Le divisioni di n terminano quando si ottiene un valore inferiore a 5.

Esempio:

n = 1123

(int (/ 1123 5))
;-> 224

Adesso possiamo dividere 1123 per 25 oppure continuare a dividere il precedente risultato per 5:

(int (/ 1123 25))
;-> 44
(int (/ 224 5))
;-> 44

Continuiamo dividendo per 5 il risultato:

(int (/ 44 5))
;-> 8

(int (/ 8 5))
;-> 1

Abbiamo ottenuto un risultato inferiore a 5 e quindi ci fermiamo. Per ottenere il numero di zeri finali basta sommare i risultati di tutte le divisioni:

numero-zeri-finali(1123!) = 224 + 44 + 8 + 1 = 277

In modo ricorsivo possiamo definire una funzione:

(define (zeri n)
  (if (< (/ n 5) 5)
      (/ n 5)
      (+ (/ n 5) (zeri (/ n 5)))))

(zeri 1123)
;-> 277

(zeri 10000)
;-> 2499

Proviamo calcolando il fattoriale e contando gli zeri finali:

(define (fatt n)
  (let (f 1L)
    (for (x 1L n)
      (setq f (* f x)))))

(define (zeri-f x)
  (let (c 0)
    (while (zero? (% x 10))
      (++ c)
      (setq x (/ x 10)))
    c))

(zeri-f (fatt 1123))
;-> 277

(zeri-f (fatt 10000))
;-> 2499

I risultati sono identici in entrambi i casi.


-----------------------------------------------------------
Massima ripetizione di un carattere in una stringa (Google)
-----------------------------------------------------------

Sia data una sequenza di DNA: una stringa composta dai caratteri A, C, G e T. Il tuo compito è trovare la ripetizione più lunga nella sequenza. Questa è una sottostringa di lunghezza massima contenente un solo tipo di carattere.

Il problema può essere risolto utilizzando due puntatori in tempo O(n).
Memorizziamo la lunghezza della sottosequenza ripetuta più lunga che incontriamo e la aggiorniamo quando incontriamo una sottosequenza ripetuta con una lunghezza maggiore di quella salvata in precedenza.

Esempio:
La stringa vale: "ATAAAGCCCCT"
Definiamo una variabile "max-len".
Usiamo un indice "i" partendo dall'inizio della stringa: "i" punta ad "A".
  _
  ATAAAGCCCCT

Verifichiamo se l'elemento "i+1" è diverso "i":
se è vero muoviamo "i" al prossimo carattere.
Adesso " i" punta a "T".
  _
  ATAAAGCCCCT

Ripetendo questo processo, "i" raggiunge "A".
    _
  ATAAAGCCCCT

Adesso il carattere puntato da "i+1" non è diverso dal carattere puntato da "i".
Creiamo un altro puntatore "k" che punta alla stassa posizione nella stringa del puntatore "i".
    _
  ATAAAGCCCCT

Ora continuiamo a muovere in avanti "i" fintanto che l'elemento puntato da "i" è uguale all'elemento puntato da "i+1". In questo modo, il puntatore "i" raggiunge la terza "A" nella stringa. Il prossimo elemento è "G" (a "i+1") che è diverso da quello puntato da "i", quindi fermiamo il movimento di "i".
    _ _
  ATAAAGCCCCT

Adesso per trovare la lunghezza della sottostringa ripetuta sottraiamo il valore del puntatore "k" dal valore del puntatore "i" e aggiungiamo 1 (per considerare anche il carattere alla posizione i-esima).

Indice di "i" = 5
Indice di "k" = 3
Lunghezza-sottostringa = i - k + 1 = 3

Poniamo max-len = Lunghezza-sottostringa (perchè per adesso questa è la lunghezza massima).

Adesso ci muoviamo in avanti e il carattere puntato da "i+1" (che è "G") è diverso dall'elemento puntato da "i" (che è "A"). Continuiamo a muoverci in avanti fino a che "i" punta a "C".
      _
  ATAAAGCCCCT

Adesso il carattere puntato da "i+1" è uguale al carattere puntato da "i".
Come abbiamo fatto prima, poniamo "k" uguale a "i" e incrementiamo "i" fino a che il carattere "i+1" è lo stesso di quello puntato da "i".
Adesso "i" punta alla quarta "C"
          _
  ATAAAGCCCCT

Indice di "i" = 10
Indice di "k" = 7
Lunghezza-sottostringa = i - k + 1 = 4

Adesso dobbiamo aggiornare "max-len" con la lunghezza massima:

max-len = max(max-len, Lunghezza-sottostringa) = 4

Il carattere in "i + 1" è diverso dal carattere in "i", quindi spostiamo "i" in avanti.

"i" ora punta alla fine della stringa, il che significa che abbiamo attraversato l'intera stringa e abbiamo trovato la sottosequenza ripetuta più lunga.

Nota: non abbiamo considerato il caso in cui la sottostringa più lunga si ripete fino all'ultimo carattere. In questo caso dobbiamo "muovere in avanti "i" fintanto che l'elemento puntato da "i" è uguale all'elemento puntato da "i+1"" solo se "i+1" non è la fine della stringa. Per fare questo dobbiamo controllare che "i+1" sia minore alla lunghezza della stringa.

Possiamo scrivere la funzione finale:

(define (max-char-rep str)
  (local (i k max-len len)
    (setq i 0)
    (setq max-len 1) ;solo la stringa nulla ha max-len=0
    (setq len 1)
    (while (!= (+ i 1) (length str))
      (cond ((= (str i) (str (+ i 1)))
              (setq k i)
              ; ciclo attraverso tutti i caratteri uguali
              (while (and (< (+ i 1) (length str)) (= (str i) (str (+ i 1))))
                  (++ i)
                  ;(println i)
                  ;(read-line)
              )
              (setq len (+ i (- k) 1))
              (setq max-len (max max-len len))
            )
            (true (++ i))
      )
    )
    max-len))

(max-char-rep "ATAAAGCCCCT")
;-> 4
(max-char-rep "AAAAA")
;-> 5
(max-char-rep "ATAAAGCCCCTATAAAGTTTTTT")
;-> 6
(max-char-rep "ATGC")
;-> 1


--------------------
Leggere libri (Uber)
--------------------

Ci sono n libri. Eva e Vale le leggeranno tutte. Per ogni libro, conosciamo il tempo necessario per leggerlo.
Entrambi leggono ogni libro dall'inizio alla fine e non possono leggere un libro allo stesso tempo.
Qual è il tempo totale minimo richiesto?

La strategia ottimale è che la prima persona inizi dal libro più corto e legga in ordine crescente e la seconda persona inizi dal libro più lungo, quindi vada al libro più corto e legga in ordine crescente. Questo si traduce nel seguente metodo: se puoi leggere tutti gli altri libri mentre leggi il libro più lungo, allora il tempo totale vale il tempo per leggere il libro più lungo moltiplicato due (il doppio), altrimenti il tempo totale vale il tempo per leggere il resto dei libri più il tempo per leggere il libro più lungo.
In altre parole, la soluzione vale: max(2*tn, somma)
dove somma = t1 + t2 + ... + tn e tn è il più grande dei t(i).

(define (book lst)
  (local (somma tb)
    (setq somma 0 tb 0)
    (dolist (el lst)
      (setq somma (+ somma el))
      (setq tb (max tb el))
    )
    (if (>= tb (- somma tb))
        (* 2 tb)
        somma)))

(book '(2 8 3))
;-> 16


-------------------------
Numero mancante (Wolfram)
-------------------------

Abbiamo una lista di tutti i numeri compresi tra 1,2,…, n tranne uno.
Trovare il numero mancante.

La somma di tuttti i numeri da 1 a n vale:

Sum[1..n](n) = n*(n + 1)/2

Quindi per trovare il numero mancante basta sottrarre alla somma di tutti i numeri la somma di tutti i numeri della lista:

(define (mancante lst)
  (let (n (+ (length lst) 1))
    (- (/ (* n (+ n 1)) 2) (apply + lst))))

(mancante '(1 2 3 4 5 6 8 9 10))
;-> 7


-----------------------------------
Lista strettamente crescente (Visa)
-----------------------------------

Sia data una lista di n numeri interi. Si desidera modificare la lista in modo che sia strettamente crescente, ovvero ogni elemento è più grande dell'elemento precedente.

Ad ogni passo, puoi aumentare il valore di qualsiasi elemento di uno. Qual'è il numero minimo di passi richiesti?

(define (adder lst)
  (local (passi nextval out)
    (setq out '())
    ; numero di passi iniziale
    (setq passi 0)
    ; valore che deve raggiungere il prossimo numero
    (setq nextval (+ (lst 0) 1))
    ; lista di output: il primo valore è uguale
    ; a quello della lista di input
    (push (lst 0) out)
    ; ciclo per ogni valore della lista
    (for (i 1 (- (length lst) 1))
      ; se il numero corrente è maggiore del valore da raggiungere
      (if (> (lst i) nextval)
          (begin
            (push (lst i) out -1)
            ; il numero di passi rimane la stesso
            ; perchè il valore corrente non cambia
            (setq passi passi)
            ; il prossimo valore deve raggiungere il valore corrente + 1
            (setq nextval (+ (lst i) 1)))
          ;else
          (begin
            (push nextval out -1)
            ; il numero dei passi viene aumentato dalla
            ; differenza tra il valore da raggiungere
            ; e il valore corrente della lista
            (setq passi (+ passi nextval (- (lst i))))
            ; il prossimo valore aumenta di 1
            (setq nextval (+ nextval 1)))
      )
      ;(println (lst i) { } nextval { } passi)
    )
  (list passi out)))

(adder '(3 2 1 8 1 1 6))
;-> (28 (3 4 5 8 9 10 11))

(adder '(3 2 5 1 7))
;-> (7 (3 4 5 6 7))

(adder '(3 2 5 7 1))
;-> (9 (3 4 5 7 8))

(adder '(1 1 5 5 4 4 11))
;-> (9 (1 2 5 6 7 8 11))

(adder '(-1 1 -5 5 -4 4))
;-> (20 (-1 1 2 5 6 7))

(adder '(2 2 2 2 2 2))
;-> (15 (2 3 4 5 6 7))


-------------------------
Pile di monete (LinkedIn)
-------------------------

Abbiamo due pile di monete contenenti a e b monete. Ad ogni mossa, possiamo rimuovere una moneta dalla pila di sinistra e due monete dalla pila di destra, oppure due monete dalla pila di sinistra e una moneta dalla pila di destra.
Dati i numeri a e b, determinare se è possibile svuotare entrambe le pile (true o false).

Diciamo che:
x volte prendiamo 2 da "a" e 1 da "b" e
y volte prendiamo 2 da "b" e 1 da "a"

Quindi possiamo scrivere:

a = 2x + 1y

b = 1x + 2y

In altre parole, quando riduciamo "a" di 2, dobbiamo ridurre "b" di 1 e quando riduciamo "a" di 1 dobbiamo ridurre "b" di 2. Quindi, se assumiamo di prendere x volte 2 e y volte 1 per portare "a" a 0, allora dobbiamo prendere x volte 1 e y volte 2 per portare "b" a 0.

Risolvendo le equazioni per x e y otteniamo:

x = (2a - b)/3

y = (2b - a)/3

Adesso x e y devono essere numeri interi, quindi deve risultare:

  (2a - b) % 3 = 0
e
  (2a - b) % 3 = 0

Oppure, (a + b) % 3 = 0.

Inoltre, x e y devono essere maggiori di 0, quindi deve risultare:

  (2a <= b)
e
  (2b <= a)

Adesso possiamo scrivere la funzione:

(define (pile a b)
  (and (>= (* 2 a) b) (>= (* 2 b) a) (zero? (% (+ a b) 3))))

(pile 0 0)
;-> true
(pile 10 5)
;-> true
(pile 13 7)
;-> nil
(pile 25 15)
;-> nil
(pile 3 3)
;-> true


-----------------------------------------------
Numero più grande formato da una lista (Amazon)
-----------------------------------------------

Dato un elenco di interi non negativi, unirli in modo tale che formino il numero più grande possibile. Restituisci il risultato sotto forma di stringa.

Esempio:
Input:  (1 28 9 77)
Output: "977281"

Basta convertire i numeri in stringa, ordinarli e infine unire le stringhe (numeri) ordinate.

(define (largest lst)
  (join (sort (map string lst) >)))

(largest '(54 546 548 60))
;-> "6054854654"

(largest '(54 9 546 548 60))
;-> "96054854654"

(largest '(3 23))
;-> "323"


-----------------------------------------------
Rettagoli e quadrati in una scacchiera (Google)
-----------------------------------------------

A) Quanti rettangoli ci sono in una scacchiera?

B) Quanti quadrati ci sono in una scacchiera?

Soluzione A
-----------
Ci sono 9 linee orizzontali sulla scacchiera e 9 linee verticali. Scegliendo due linee orizzontali distinte e due linee verticali distinte detrminiamo un rettangolo unico. E ogni rettangolo determina una coppia di linee orizzontali e una coppia di linee verticali.

Quindi il numero di rettangoli è binomiale(9 2)^2, cioè 1296.

Generalizzando per una scacchiera m x n il numero di rettangoli è dato da:

num-rect = binomiale((m+1) 2)*binomiale((n+1) 2)

dove:
                      n!
binomiale(n k) = --------------
                 k! *  (n - k)!

Funzione per calcolare il coefficiente binomiale:

(define (binomiale num k)
  (if (> k num)
    0
    (let (r 1L)
      (for (d 1 k)
        (setq r (/ (* r num) d))
        (-- num)
      )
      r)))

(define (rect-grid m n)
  (* (binomiale (+ m 1) 2) (binomiale (+ n 1) 2)))

(rect-grid 8 8)
;-> 1296L
(rect-grid 4 3)
;-> 60L

Possiamo anche derivare una formula diretta sviluppando i binomiali:

num-rect = (m+1)!/(2!*(m-1)!) * (n+1)!/(2!*(n-1)!) = m*(m+1)*n*(n+1)/4

(define (rect-grid2 m n)
  (/ (* m (+ m 1) n (+ n 1)) 4))

(rect-grid2 8 8)
;-> 1296
(rect-grid 4 3)
;-> 60

Soluzione B
-----------
In una scacchiera quadrata 8x8 esistono:

8^2 quadrati 1x1
7^2 quadrati 2x2
6^2 quadrati 3x3
5^2 quadrati 4x4
4^2 quadrati 5x5
3^2 quadrati 6x6
2^2 quadrati 7x7
1^2 quadrati 8x8

Quindi la somma totali dei quadrati vale:

num-quad = 1^2 + 2^2 + 3^2 + 4^2 + 5^2 + 6^2 + 7^2 + 8^2 =

Generalizzando per una scacchiera nxn otteniamo che il numero di quadrati è dato dalla somma dei primi n quadrati:

num-quad = Sum[1..n] (i^2) = (2*n^3 + 3*n^2 + n)/6

(define (square x) (* x x))

(define (quad-rect n)
  (apply + (map square (sequence 1 n))))

(quad-rect 8)
;-> 204

(define (quad-rect2 n)
  (/ (+ (* 2 n n n) (* 3 n n) n) 6))

(quad-rect2 8)
;-> 204

(quad-rect 20)
;-> 2870
(quad-rect2 20)
;-> 2870


----------------------------
Rettangolo perfetto (Google)
----------------------------

Dati N rettangoli allineati lungo l'asse, dove N > 0, determinare se tutti insieme formano una copertura esatta di una regione rettangolare, cioè formano un rettangolo senza buchi ne sovrapposizioni.
Ogni rettangolo è rappresentato come un punto in basso a sinistra e un punto in alto a destra. Ad esempio, un quadrato unitario è rappresentato come [1,1,2,2]. (la coordinata del punto in basso a sinistra è (1, 1) e quella del punto in alto a destra è (2, 2)).

Per formare una copertura esatta deve risultare:
1. L'area della copertura rettangolare deve essere uguale alla somma delle aree di tutti i rettangoli piccoli
2. I quattro angoli del rettangolo/quadrato devono apparire una sola volta.

(define (rect? lst)
  (local (x1 y1 x2 y2 areatot area4 p1 p2 p3 p4 lenhash out)
    (setq out nil)
    (setq x1 99999999 y1 99999999)
    (setq x2 -1 y2 -1)
    ; hash-map per inserire i punti
    (new Tree 'hash)
    (setq areatot 0)
    (dolist (rect lst)
      ; ricerca valori massimi e minimi delle coordinate dei punti
      (setq x1 (min (rect 0) x1))
      (setq y1 (min (rect 1) y1))
      (setq x2 (max (rect 2) x2))
      (setq y2 (max (rect 3) y2))
      ; calcolo area totale
      (setq areatot (+ areatot (* (- (rect 2) (rect 0)) (- (rect 3) (rect 1)))))
      ; creazione della stringa di ogni punto
      (setq p1 (string (list (rect 0) (rect 1))))
      (setq p2 (string (list (rect 0) (rect 3))))
      (setq p3 (string (list (rect 2) (rect 3))))
      (setq p4 (string (list (rect 2) (rect 1))))
      ; se i punti esistono nella hash-map,
      ; allora li elimino
      ; altrimenti li inserisco
      (if (hash p1) (hash p1 nil) (hash p1 p1))
      (if (hash p2) (hash p2 nil) (hash p2 p2))
      (if (hash p3) (hash p3 nil) (hash p3 p3))
      (if (hash p4) (hash p4 nil) (hash p4 p4))
    )
    ; adesso se la hash-map contiene esattamente quattro punti,
    ; e l'area dei quattro punti è uguale all'area totale,
    ; e i quattro punti sono uguali ai valori massimi x1,y1,x2,y2
    ; allora il rettangolo forma una copertura.
    (setq lenhash (length 'hash))
    (setq area4 (* (- x2 x1) (- y2 y1)))
    (setq out (and (= lenhash 4)
                   (= areatot area4)
                   (not (nil? (hash (string (list x1 y1)))))
                   (not (nil? (hash (string (list x1 y2)))))
                   (not (nil? (hash (string (list x2 y1)))))
                   (not (nil? (hash (string (list x2 y2)))))))
    ; eliminazione della hash-map
    (delete 'hash)
    out))

(rect? '((1 1 2 2) (2 1 3 2) (2 2 3 3) (1 2 2 3)))
;-> true

(rect? '((1 0 3 3) (3 0 5 1) (3 1 5 3) (2 3 5 4) (1 3 2 4) (1 4 3 5) (3 4 5 5)))
;-> true

(rect? '((1 0 3 3) (3 0 5 1) (3 1 5 3) (2 3 5 4) (1 3 2 4) (1 4 3 5) (4 4 6 5)))
;-> nil


--------------------------------------------------
Addizione per intervalli (Range addition) (Google)
--------------------------------------------------

Supponiamo di avere una lista (o un vettore) di lunghezza n inizializzata con tutti gli 0 e di ricevere k operazioni di aggiornamento.

Ogni operazione è rappresentata come una tripletta: [startIndex, endIndex, val] che incrementa ogni elemento della sottolista A[startIndex ... endIndex] (startIndex e endIndex inclusi) con val.

Restituire la lista modificata dopo che tutte le k operazioni sono state eseguite.

Esempio:

lunghezza = 5

aggiornamenti = ((1  3  2)
                 (2  4  3)
                 (0  2 -2))

Risultato: (-2 0 3 5 3)

Funzionamento:
Indici:                        0  1  2  3  4
Lista iniziale:              ( 0  0  0  0  0 )

dopo l'operazione (1  3  2): ( 0  2  2  2  0 )

dopo l'operazione (2  4  3): ( 0  2  5  5  3 )

dopo l'operazione (0  2 -2): (-2  0  3  5  3 )

Il problema è abbastanza semplice, ma forse esiste un algoritmo più efficace di quello che applica in sequenza le operazioni di aggiornamento.

La maggior parte delle operazioni di aggiornamento vengono applicate sugli stessi indici diverse volte. Abbiamo  davvero bisogno di aggiornare tutti gli elementi tra startIndex e endIndex?

Proviamo il seguente algoritmo:

1) Aggiorniamo solo il valore a startIndex con +val e il valore a (startIndex + 1) con -val, cioè:
   lista[start]   = lista[start] + val;
   lista[end + 1] = lista[end + 1] - val

2) Alla fine di tutti gli aggiornamenti applichiamo la somma cumulativa ad ogni elemento della lista:
   lista[i] = lista[i] + lista[i-1]

Vediamo il funzionamento:

Indici:                        0  1  2  3  4
Lista iniziale:              ( 0  0  0  0  0 )

dopo l'operazione (1  3  2): ( 0  2  0  0 -2 )

dopo l'operazione (2  4  3): ( 0  2  3  0 -2 )

dopo l'operazione (0  2 -2): (-2  2  3  2 -2 )

dopo la somma              : (-2  0  3  5  3 )

Per ogni aggiornamento (start, end, val) sulla lista, l'obiettivo è ottenere il risultato:

lista(i) = lista(i) + val, per ogni indice da inizio a fine.

L'applicazione della somma finale effettua due cose:

1) Riporta l'incremento val su ogni elemento lista(i) per ogni i >= start

2) Trasferisce l'incremento −val su ogni elemento lista(j) per ogni j > end.

In altre parole, la somma finale aggiorna correttamente tutti i valori degli indici intermedi che non abbiamo modificato durante i singoli aggiornamenti.

La complessità temporale di questo algoritmo vale O(n+k).

Scriviamo la funzione finale:

(define (update-list len update)
  (local (out start end val)
    (setq out (array len '(0)))
    (dolist (upd update)
      (setq val   (upd 2))
      (setq start (upd 0))
      (setq end   (upd 1))
      (setq (out start) (+ (out start) val))
      (if (< end (- len 1))
          (setq (out (+ end 1)) (- (out (+ end 1)) val))
      )
    )
    (for (i 1 (- len 1))
      (setq (out i) (+ (out i) (out (- i 1))))
    )
    out))

Proviamo:

(update-list 5 '((1  3  2) (2  4  3) (0  2 -2)))
;-> (-2 0 3 5 3)


---------------------------
Ordinamento Wiggle (Google)
---------------------------

Data una lista non ordinata, ordinarla in modo che risulti lst[0] <= lst[1] >= lst[2] <= lst[3]....
Ad esempio, data lst = (3 5 2 1 6 4), una possibile risposta è (1 6 2 5 3 4).

Notiamo che è richiesto il seguente ordinamento: il numero negli indici dispari è maggiore dei numeri che si trovano ai due lati (destra e sinistra). Ad esempio lst[1] > lst[0] e lst[1] > lst[2].

Prima soluzione
---------------
Secondo la definizione ci sono molti modi per ordinare in modo Wiggle. Possiamo prima ordinare la lista, quindi iniziamo con il terzo elemento e scambiarlo con il secondo elemento. Poi scambiamo il quinto e il quarto elemento, e così via.

Complessità temporale: O(n*log(n))

(define (wiggle1 lst)
  (sort lst)
  (for (i 2 (- (length lst) 1) 2)
    (swap (lst i) (lst (- i 1)))
  )
  lst)

(setq lst '(3 5 2 1 6 4))
(wiggle1 lst)
;-> (1 3 2 5 4 6)

Seconda soluzione
-----------------
L'ordinamento wiggle ha le seguenti due regole:

  1) se i è dispari, allora lst[i] >= lst[i-1]

  2) se i è pari,    allora lst[i] <= lst[i-1]

Quindi dobbiamo attraversare la lista una sola volta e scambiare le coppie che non rispettano le regole. In particolare, se lst[i] > lst[i-1], dopo lo scambio deve risultare lst[i] <= lst[i-1].

Complessità temporale: O(n)

(define (wiggle2 lst)
  (for (i 1 (- (length lst) 1))
    ; Occorre scambiare:
    ; nums[i] < nums[i-1] per gli indici dispari e
    ; nums[i] > nums[i-1] for gli indici pari
    (if (or (and (= (% i 2) 1) (< (lst i) (lst (- i 1))))
            (and (= (% i 2) 0) (> (lst i) (lst (- i 1)))))
        (swap (lst i) (lst (- i 1)))
    )
    lst))

(setq lst '(3 5 2 1 6 4))
(wiggle2 lst)
;-> (3 5 1 6 2 4)

(wiggle2 '(1 2 3 4 5 6 7 8 9))
;-> (1 3 2 5 4 7 6 9 8)


---------------------------
Generare parentesi (Amazon)
---------------------------

Date n coppie di parentesi, scrivere una funzione per generare tutte le combinazioni di parentesi ben formate. Ad esempio, per n = 3, un insieme di soluzioni è:

"[[[]]]", "[[][]]", "[[]][]", "[][[]]", "[][][]"

L'idea è che se abbiamo ancora una parentesi sinistra, abbiamo due scelte: inserire una parentesi sinistra o una parentesi destra. Ma la condizione per inserire le parentesi destra è che quelle di sinistra presenti siano di più di quelle di destra presenti.
In altre parole, l'i-esimo carattere può essere "[" se e solo se il conteggio di "[" fino a i-esimo è minore di n e i-esimo carattere può essere "]" se e solo se il conteggio di "[" è maggiore rispetto al conteggio di "]" fino all'indice i. Se seguiamo queste due regole, la combinazione risultante sarà sempre bilanciata.
Usiamo una funzione ricorsiva che segue queste due regole.

(define (parentesi num)
  (local (str out)
    (setq str "")
    (setq out '())
    (aux-parentesi "" num num)
    out))

(define (aux-parentesi str sx dx)
  (cond ((and (zero? sx) (zero? dx))
         (push str out -1)
         (setq str ""))
        (true
         (if (> sx 0)  (aux-parentesi (string str "[") (- sx 1) dx))
         (if (< sx dx) (aux-parentesi (string str "]") sx (- dx 1))))))

(parentesi 3)
;-> ("[[[]]]" "[[][]]" "[[]][]" "[][[]]" "[][][]")

(parentesi 4)
;-> ("[[[[]]]]" "[[[][]]]" "[[[]][]]" "[[[]]][]" "[[][[]]]"
;->  "[[][][]]" "[[][]][]" "[[]][[]]" "[[]][][]" "[][[[]]]"
;->  "[][[][]]" "[][[]][]" "[][][[]]" "[][][][]")


------------------------
Maggiori a destra (Visa)
------------------------

Dato una lista di numeri interi, calcolare una lista di interi che contiene, in ogni elemento della lista, il conteggio degli interi nell'elenco originale che sono a destra e sono minori dell'elemento nella posizione corrente della lista originale. Ad esempio, data la lista di input (10 12 8 17 3 24 19), l'output desiderato è (4 3 3 2 2 0 0), perché dal primo elemento della lista, 10, ci sono quattro elementi a destra (12 17 24 19) maggiori di 10, al secondo elemento della lista, 12, ci sono tre elementi (17 24 19) maggiori di 12, al terzo elemento della lista, 8, ci sono tre elementi (17 24 19) maggiori di 8, al quarto elemento della lista, 17, ci sono due elementi (24 19) maggiori di 17, al quinto elemento della lista, 3, ci sono due elementi (24 19) maggiori di 3, al sesto elemento della lista, 24, ci sono 0 elementi maggiori di 24 e al settimo elemento della lista, 19, ci sono 0 elementi maggiori di 19.

Scrivere una funzione per calcolare la lista dei conteggi degli elementi maggiori di ogni elemento.

Il primo metodo che viene in mente è quello di utilizzare due cicli innestati, per ogni elemento calcoliamo quanti elementi maggiori ci sono a destra:

(define (bigger-dx lst)
  (local (len conta)
    (setq len (length lst))
    ; Usiamo un vettore per migliorare la velocità
    (setq arr (array len lst))
    (setq out '())
    ; per ogni elemento
    (for (i 0 (- len 1))
      (setq conta 0)
      ; contiamo i numeri maggiori a destra
      (for (j i (- len 1))
        (if (> (arr j) (arr i)) (++ conta))
      )
      (push conta out -1)
    )
    out))

(setq a '(10 12 8 17 3 24 19))
(bigger-dx a)

(bigger-dx '(-1 -1))
;-> (0 0)

(setq b '(10 12 8 17 8 3 24 19))
(bigger-dx b)
;-> (4 3 3 2 2 2 0 0)

Vediamo i tempi di esecuzione:

(silent (setq t0 (randomize (sequence 1 1000))))
(silent (setq t (randomize (sequence 1 10000))))

(time (bigger-dx t0))
;-> 33.936
(time (bigger-dx t0) 10)
;-> 337.097

(time (bigger-dx t))
;-> 3326.111
(time (bigger-dx t) 10)
;-> 33188.273

Con un metodo simile utilizzando le primitive di newLISP:

(define (bigger1-dx lst)
  (let (out '())
    ; per ogni elemento della lista...
    (dolist (el lst)
      ; calcola quanti sono i numeri a destra
      ; che sono maggiori dell'elemento corrente
      ; e lo inserisco nella lista di output
      (push (length (ref-all el (slice lst $idx) <)) out -1)
    )
    out))

(bigger1-dx a)
;-> (4 3 3 2 2 0 0)

(bigger1-dx '(-1 -1))
;-> (0 0)

(bigger1-dx b)
;-> (4 3 3 2 2 2 0 0)

Vediamo i tempi di esecuzione:

(time (bigger1-dx t0))
;-> 40.891
(time (bigger1-dx t0) 10)
;-> 400.958

(time (bigger1-dx t))
;-> 4380.316
(time (bigger1-dx t) 10)
;-> 54381.611

Nota: in questa ultima funzione non possiamo utilizzare un vettore perchè la funzione "ref-all" si applica solo alle liste.

Queste due soluzioni hanno complessità temporale O(n^2).

Un altro metodo si basa sui seguenti passi:

- trovare l'indice a destra il cui valore è uguale a quello corrente
- calcolare il valore tra questi due e aggiungere il risultato di quell'indice

(define (bigger2-dx lst)
  (local (arr lst-vec res out conta len)
    (new Tree 'hashmap)
    (setq len (length lst))
    (setq arr (array len '(0)))
    (setq lst-vec (array len lst))
    (for (i (- len 1) 0)
      (if (nil? (hashmap (string (lst-vec i))))
          (setf (arr i) -1)
          (setf (arr i) (hashmap (string (lst-vec i))))
      )
      (hashmap (string (lst-vec i)) i)
    )
    (setq res (array len '(0)))
    (for (i (- len 1) 0)
      (setq conta 0)
      (if (= (arr i) -1)
          (begin
            (for (j i (- len 1) -1)
              (if (< (lst-vec i) (lst-vec j))
                  (++ conta)
              )
            )
            (setf (res i) conta))
          (begin ;else
            (for (j i (- (arr i) 1))
              (if (< (lst-vec i) (lst-vec j))
                  (++ conta)
              )
            )
            (setf (res i) (+ conta (res (arr i)))))
      )
    )
    (delete 'hashmap)
    (setq out (array-list res))))

(bigger2-dx a)
;-> (4 3 3 2 2 0 0)

(bigger2-dx '(-1 -1))
;-> (0 0)

(bigger2-dx b)
;-> (4 3 3 2 2 2 0 0)

Vediamo i tempi di esecuzione:

(time (bigger2-dx t0))
;-> 37.927
(time (bigger2-dx t0) 10)
;-> 375.01

(time (bigger2-dx t))
;-> 3627.274
(time (bigger2-dx t) 10)
;-> 36286.99

Una soluzione in tempo O(n*log(n)) può essere ottenuta utilizzando la tecnica merge-sort oppure con la manipolazione dei bit oppure con gli alberi binari di ricerca oppure con i segment tree oppure con la ricerca binaria oppure con gli alberi binari indicizzati. Non esiste una soluzione in tempo O(n).


------------------------------
Numero che raddoppia (Wolfram)
------------------------------

Quale numero positivo raddoppia quando l'ultima cifra si sposta sulla prima?

Esempio:
Numero: 152
Spostiamo l'ultima cifra (2) sulla prima: 215
Ma 215 non è il doppio di 152.

Proviamo un approccio brute-force.

(setq num 152)
Estraiamo l'ultima cifra:
(% num 10)
;-> 2
Estraiamo le altre cifre:
(/ num 10)
;-> 15
Calcoliamo il numero ottenuto:
(setq val  (+ (* (% num 10) (pow 10 (- (length num) 1))) (/ num 10)))
;-> 215

Scriviamo la funzione:

(define (solve num)
  (let (val 0)
    (for (i 1 num)
      (setq val (+ (* (% i 10) (pow 10 (- (length i) 1))) (/ i 10)))
      ;(println i { } val { } (* 2 i))
      ;(read-line)
      (if (= val (* i 2)) (println i { } val)))))

Proviamo a cercare il numero fino ad 1 milione:

(solve 1000000)
;-> nil
(time (solve 1000000))
;-> 356.791

Proviamo con 100 milioni:

(solve 1e8)
;-> nil
(time (solve 1e8))
;-> 35797.039

Sembra che il numero non sia alla portata di un approccio brute-force. Analizzando le proprietà del numero da trovare possiamo notare che, se esiste, la sua ultima cifra è sufficiente per costruirlo.
Infatti, l'ultima cifra non può essere 1, perché in tal caso il numero non può essere raddoppiato inserendo un 1 davanti senza modificare il numero di cifre.
Quindi, proviamo con 2. Il numero finisce con 2 e quando mettiamo questo 2 davanti, raddoppia. Il doppio di un numero che termina con 2 finisce con 4, quindi sappiamo che il numero finisce con 42. Il suo doppio deve finire con 84, il che significa che il numero finisce con 842 e così via (attenzione ai riporti e al numero 10). Dopo un pò incontriamo un 1, a questo punto sappiamo che il numero vale 157894736842, ma se lo  raddoppiamo otteniamo 315789473684, che non ha il 2 davanti, quindi dobbiamo andare avanti. La prossima fermata (cioè quando incontriamo un altro 1) è 105263157894736842, che rispetta la condizione. Infatti:

105263157894736842 * 2 = 210526315789473684

(= (* 105263157894736842 2) 210526315789473684)
;-> true

Ora, iniziando il numero con 3 e fermandosi quando incontriamo un 1, otteniamo 157894736842105263, che è un altro numero che soddisfa la condizione:

(= (* 157894736842105263 2) 315789473684210526)
;-> true

Questo algoritmo viene codificato nella seguente funzione (che utilizza i big-integer).

(define (solve start)
  (local (num doppio carry stop)
    (setq num (bigint start))
    (setq doppio num)
    (setq carry 0L)
    (setq stop nil)
    (until stop
      ;raddoppio la cifra corrente
      (setq doppio (* 2L doppio))
      ; controllo se esiste un riporto precedente
      (if (= carry 1) (setq doppio (+ doppio carry)))
      ; creo il numero
      ;(setq num (int (string (% doppio 10) num)))
      ; se doppio = 10, allora occorre inserire 10 davanti a num e non 0.
      (if (= doppio 10)
          (setq num (+ num (* doppio (** 10 (length num)))))
          (setq num (+ num (* (% doppio 10) (** 10 (length num)))))
      )
      ; controllo se doppio ha un riporto
      (cond ((= doppio 10)
             (setq carry 0L)
             (setq doppio 1L))
            ((> doppio 9)
             (setq carry 1L)
             (setq doppio (% doppio 10)))
            (true
             (setq carry 0L))
      )
      (if (check num) (setq stop true))
      ;(if (or (= doppio 1L) (= doppio 10L))
      ;    (println "check: " num)
      ;    (if (check num) (setq stop true))
      ;)
    )
    num))

Funzione che controlla la condizione:

(define (check num)
  (= (* num 2)
     (+ (* (% num 10) (** 10 (- (length num) 1))) (/ num 10))))

Funzione che calcola la potenza intera di un numero intero:

(define (** num power)
    (let (out 1L)
        (dotimes (i power)
            (setq out (* out num)))))

(check 105263157894736842)
;-> true

Proviamo con il numero 2:

(solve 2)
;-> 105263157894736842L

Proviamo con il numero 3:

(solve 3)
;-> 157894736842105263L

Proviamo con il numero 4:

(solve 4)
;-> 210526315789473684L


------------------------------------------------
Calcolatore rotto (Broken calculator) (LeetCode)
------------------------------------------------

Su una calcolatrice rotta che ha un numero visualizzato sul display, possiamo eseguire due operazioni:

1) Doppio: moltiplica il numero sul display per 2 o
2) Decremento: sottrai 1 dal numero sul display.

Inizialmente, la calcolatrice mostra il numero X.
Restituire il numero minimo di operazioni necessarie per visualizzare il numero Y.

Esempio 1:
input: X = 2, Y = 3
output: 2
Spiegazione: raddoppiare e decrementare {2 -> 4 -> 3}.

Esempio 2:
input: X = 5, Y = 8
output: 2
Spiegazione: decrementare e poi raddoppiare {5 -> 4 -> 8}.

Esempio 3:
input: X = 3, Y = 10
output: 3
Spiegazione: raddoppiare, decrementare e raddoppiare {3 -> 6 -> 5 -> 10}.

Esempio 4:
input: X = 1024, Y = 1
output: 1023
Spiegazione: decrementare 1023 volte.

L'idea è quella di ragionare all'indietro, cioè partiamo da Y:
invece di moltiplicare per 2 o sottrarre 1 da X, potremmo dividere per 2 (quando Y è pari) o aggiungere 1 a Y.
La motivazione per questo è che si scopre che dividiamo sempre per 2:
a) Se Y è pari, se eseguiamo 2 addizioni e una divisione, potremmo invece eseguire una divisione e un'addizione per meno operazioni [(Y + 2)/2 contro Y/2 + 1].
b) Se Y è dispari, se eseguiamo 3 addizioni e una divisione, potremmo invece eseguire 1 addizione, 1 divisione e 1 addizione per meno operazioni [(Y + 3)/2 contro (Y + 1)/2 + 1 ].

Algoritmo

Affinchè Y è maggiore di X, aggiungere 1 se è dispari, altrimenti dividire per 2. Dopo, dobbiamo fare X - Y addizioni per raggiungere X.

(define (pcrotto x y)
  (let (out 0)
    (while (> y x)
      (++ out)
      (if (odd? y)
          (++ y)
          (setq y (/ y 2))
      )
    )
    (setq out (+ out x (- y)))))

(pcrotto 2 3)
;-> 2
(pcrotto 5 8)
;-> 2
(pcrotto 3 10)
;-> 3
(pcrotto 1024 1)
;-> 1023

Complessità temporale: O(log(Y)).
Complessità spaziale: O(1).

Versione ricorsiva:

(define (pcrotto x y)
  (cond ((= x y) 0)
        ((> x y) (- x y))
        ((and (< x y) (even? y))
         (+ 1 (pcrotto x (/ y 2))))
        (true
         (+ 1 (pcrotto x (+ y 1))))))

(pcrotto 2 3)
;-> 2
(pcrotto 5 8)
;-> 2
(pcrotto 3 10)
;-> 3
(pcrotto 1024 1)
;-> 1023


-----------------------------------
Contare le isole (islands) (Google)
-----------------------------------

Data una matrice binaria dove 0 rappresenta l'acqua e 1 rappresenta la terra, contare tutte le isole.
Che cosa è un'isola?
Un gruppo di 1 collegati formano un'isola. Comunque possiamo considerare due tipi di isole:

1) le isole sono solo gli 1 sono connessi nelle 4 direzioni (nord,sud,est,ovest)

oppure

2) le isole sono solo gli 1 sono connessi nelle 8 direzioni (nord,sud,est,ovest,nord-est,nord-ovest,sud-est,sud-ovest)

In altre parole il tipo 1 considera gli 1 in diagonale non connessi, mentre il tipo 2 consdidera gli 1 in diagonale connessi.

Ad esempio, la matrice sottostante contiene 5 isole di tipo 1 o 3 isole di tipo 2:

  1 1 0 0 0
  0 1 0 0 1
  1 0 0 1 1
  0 0 1 0 0
  1 1 1 0 1

Questa è una variazione del problema: "Contare il numero di componenti connessi in un grafo non orientato".

Prima di passare al problema, cerchiamo di capire cos'è un componente connesso. Un componente connesso di un grafo non orientato è un sottografo in cui ogni due vertici sono collegati tra loro da un percorso(s) e che non è connesso a nessun altro vertice al di fuori del sottografo.

Un grafo in cui tutti i vertici sono collegati tra loro ha esattamente un componente connesso, costituito dall'intero grafo. Un grafo di questo tipo con un solo componente connesso è chiamato grafo fortemente connesso.

Il problema può essere risolto applicando la ricerca Depth-First-Search (DFS) per ogni componente. In ogni chiamata DFS(), viene visitato un componente o un sottografo. Poi chiamiamo DFS sul prossimo componente non visitato. Il numero di chiamate a DFS() fornisce il numero di componenti connessi. È possibile utilizzare anche la ricerca Breadth-First-Search (BFS).

Una cella in matrice 2D può essere collegata a a 4 o 8 vicini (a seconda del tipo di isole che vogliamo cercare). Quindi, a differenza dello standard DFS(), dove visitiamo ricorsivamente tutti i vertici adiacenti, qui chiamiamo DFS() ricorsivamente sui 4 o 8 vicini. Teniamo traccia degli 1 visitati in modo che non vengano più visitati.

(define (sicuro? x y)
    (setq col (length (visitati 0)))
    (setq row (length visitati))
    (if (and (>= x 0) (>= y 0) (< x col) (< y row) (nil? (visitati y x)) (= 1 (matrix y x)))
        true
        nil
    ))

(define (dfs x y)
  (local (vicini)
    (cond ((or (= type 1) (nil? type))
           ; Isola di Tipo 1: 4 vicini
           (setq vicini '((1 0) (0 -1) (-1 0) (0 1))))
          ((= type 2)
           ; Isola di Tipo 2: 8 vicini
           (setq vicini '((1 0) (0 -1) (-1 0) (0 1) (-1 1) (1 1) (1 -1) (-1 -1))))
    )
    (setf (visitati y x) true)
    (for (k 0 (- (length vicini) 1))
      (if (sicuro? (+ x (vicini k 0)) (+ y (vicini k 1)) matrix visitati)
          (dfs (+ x (vicini k 0)) (+ y (vicini k 1)) matrix visitati)
      )
    )))

(define (numero-isole x y)
  (local (conta)
    (setq col (length (matrix 0)))
    (setq row (length matrix))
    (setq conta 0)
    (for (i 0 (- row 1))
      (for (j 0 (- col 1))
        (if (sicuro? i j matrix visitati)
            (begin
              (dfs i j matrix visitati)
              (++ conta)
            )
        )
      )
    )
    conta))

(define (conta-isole matrice tipo)
  (local (matrix visitati col row type)
    (setq matrix matrice)
    (setq col (length (matrix 0)))
    (setq row (length matrix))
    (setq visitati (array col row '(nil)))
    (setq type tipo)
    (numero-isole 0 0 matrix visitati)))

(setq matrice '((1 1 0 0 0)
                (0 1 0 0 1)
                (1 0 0 1 1)
                (0 0 1 0 0)
                (1 1 1 0 1)))

Contiamo le isole di tipo 1:

(conta-isole matrice 1)
;-> 5

Contiamo le isole di tipo 2:

(conta-isole matrice 2)
;-> 3


-----------------------------
Lista con prodotto 1 (Amazon)
-----------------------------

Data una lista contenente N numeri interi. In un passo, è possibile aumentare o diminuire di 1 qualsiasi elemento della lista (ma uno soltanto). Trovare il numero minimo di passi richiesti in modo che il prodotto degli elementi della lista diventi 1.

Esempi:

lst = (-2  4  0)
passi = 5
Possiamo cambiare da -2 a -1, da 0 a -1 e da 4 a 1.
Quindi sono necessari un totale di 5 passi per aggiornare gli elementi in modo tale il prodotto finale valga 1.

lst = (-1 1 -1)
passi = 0
Il prodotto della lista vale già 1, quindi non occorre modificare nulla.

(define (prod-uno lst)
  (local (step neg zeri)
    (setq step 0)
    ; quanti numeri negativi
    (setq neg 0)
    ; quanti zeri
    (setq zeri 0)
    (dolist (x lst)
      (cond ((> x 0)
             ; passi per andare a +1
             (setq step (+ step (- x 1))))
            ((= x 0)
             ; passi per andare a -1
             (++ step)
             (++ zeri)
             (++ neg))
            ((< x 0)
            ; passi per andare a -1
             (setq step (+ step (abs (+ x 1))))
             (++ neg))
      )
    )
    ; se esiste un numero dispari di numeri negativi
    ; allora bisogna aggiungere al numero di passi totali:
    ; a) 2 se non esistono zeri nella lista
    ; (perchè servono due passi per arrivare da -1 a +1)
    ; b) 0 se esistono zeri nella lista
    ;; (perchè lo zero si trova già a -1)
    (if (and (odd? neg) (= zeri 0))
        (setq step (+ step 2)))
    step))

(prod-uno '(-1 1 -1))
;-> 0
(prod-uno '(-2 4 0))
;-> 5
(prod-uno '(-2 5 0 0 -12 3 4 1 0))
;-> 24
(prod-uno '(-1 -1))
;-> 0
(prod-uno '(-1 1))
;-> 2
(prod-uno '(-1 1 0))
;-> 1


-------------------------
Somma delle monete (Visa)
-------------------------

Data un insieme di monete, determinare tutte le somme che possono essere ottenute con le monete.
Per esempio:
monete = (4 2 5 2)
somme = (2 4 5 6 7 8 9 11 13)

Il valore massimo di somma che possiamo ottenere è dato dal valore massimo della (valmax) lista moltiplicato per la lunghezza della lista (len).
Creiamo un vettore di lunghezza len * (valmax + 1) con tutti valori 0 (nil).
Per ogni moneta "c"
  attraversiamo il vettore all'indietro e se incontriamo un valore 1 (true) all'indice "i", allora poniamo a 1 (true) il valore all'indice (+ i c).
  poniamo a 1 (true) il valore all'indice "c".
Attraversiamo il vettore e inseriamo nella soluzione gli indici dei valori che valgono 1 (true).

La seguente funzione implementa l'algoritmo:

(define (sum-coin coin-lst)
  (local (dp valmax len out)
    ; troviamo il valore massimo tra le monete
    (setq valmax (apply max coin-lst))
    ; lunghezza della lista
    (setq len (length coin-lst))
    ; vettore con tutti 0
    (setq dp (array (* len (+ valmax 1)) '(0)))
    ; per ogni moneta nella lista
    (dolist (c coin-lst)
      ; per ogni elemento del vettore dp (attraversamento all'indietro)
      (for (i (- (length dp) 1) 1 -1)
        ; se incontriamo il valore 1...
        (if (= (dp i) 1)
            ; allora assegniamo 1 nella posizione (i + c) del vettore
            (setf (dp (+ i c)) 1)
        )
      )
      ; assegniamo 1 alla posizione c del vettore
      (setf (dp c) 1)
    )
    ; creiamo la lista soluzione con tutti
    ; i valori degli indici dove dp(i) vale 1
    (for (i 1 (- (length dp) 1))
      (if (= (dp i) 1) (push i out -1))
    )
    out))

(sum-coin '(4 3 2))
;-> (2 3 4 5 6 7 9)

(sum-coin '(4 2 5 2))
;-> (2 4 5 6 7 8 9 11 13)

(sum-coin '(2 5 10 50 1000 2000))
;-> (2 5 7 10 12 15 17 50 52 55 57 60 62 65 67 1000 1002 1005 1007 1010 1012
;->  1015 1017 1050 1052 1055 1057 1060 1062 1065 1067 2000 2002 2005 2007
;->  2010 2012 2015 2017 2050 2052 2055 2057 2060 2062 2065 2067 3000 3002
;->  3005 3007 3010 3012 3015 3017 3050 3052 3055 3057 3060 3062 3065 3067)


----------------
Boomerang (Visa)
----------------

Dati n punti nel piano che sono tutti distinti a due a due, un "boomerang" è una tupla di punti (i, j, k) tale che la distanza tra i e j è uguale alla distanza tra i e k (l'ordine della tupla è importante).
Trovare il numero di boomerang.

Per ogni punto, calcolare la distanza dal resto dei punti e contare.
Se ci sono k punti che hanno la stessa distanza dal punto corrente, allora ci sono P(k,2) = k * k-1 boomerang.
ad esempio, se p1, p2, p3 hanno la stessa distanza con p0, allora ci sono P(3,2) = 3 * (3-1) = 6 boomerang:
(p1, p0, p2), (p1, p0, p3) (p2, p0, p1), (p2, p0, p3) (p3, p0, p1), (p3, p0, p2)
Per ogni punto possiamo ordinare le distanzee poi calcolare il numero di boomerang nel modo seguente:
  dist = (1 2 1 2 1 5)
  sorted_dist = (1 1 1 2 2 5) ==> 1*3, 2*2, 5*1
  boomerang = 3*(3 - 1) + 2*(2 – 1)*1*(1 – 1) = 8

(define (boomerang punti)
  (local (len dist dx dy k out)
    (setq len (length punti))
    (setq out 0)
    (setq dist (array len '(0)))
    (for (i 0 (- len 1))
      (for (j 0 (- len 1))
        (setq dx (sub (punti i 0) (punti j 0)))
        (setq dy (sub (punti i 1) (punti j 1)))
        (setf (dist j) (add (mul dx dx) (mul dy dy)))
      )
      (println "dist: " dist)
      (sort dist)
      (println "dist (sort): " dist)
      (for (j 1 (- len 1))
        (setq k 1)
        (while (and (< j len) (= (dist j) (dist (- j 1))))
          (++ j)
          (++ k)
        )
        (setq out (+ out (* k (- k 1))))
      )
    )
    out))

(boomerang '((0 0) (1 0) (2 0)))
;-> dist: (0 1 4)
;-> dist (sort): (0 1 4)
;-> dist: (1 0 1)
;-> dist (sort): (0 1 1)
;-> dist: (4 1 0)
;-> dist (sort): (0 1 4)
;-> 2

I due boomerangs sono ((1 0) (0 0) (2 0)) e ((1 0) (2 0) (0 0)).

(boomerang '((3 3) (2 2) (4 2) (4 4)))
;-> dist: (0 2 2 2)
;-> dist (sort): (0 2 2 2)
;-> dist: (2 0 4 8)
;-> dist (sort): (0 2 4 8)
;-> dist: (2 4 0 4)
;-> dist (sort): (0 2 4 4)
;-> dist: (2 8 4 0)
;-> dist (sort): (0 2 4 8)
;-> 10

Complessità temporale: O(n*n*logn)


-----------------------------------
Ricerca in una matrice 2D (Wolfram)
-----------------------------------

Scrivere un algoritmo per cercare un valore in una matrice m x n che ha le seguenti proprietà:
1) I numeri sono tutti interi
2) I numeri di ogni riga sono ordinati in modo crescente da sinistra a destra.
3) Il primo numero di ogni riga è maggiore dell'ultimo numero della riga precedente.
Un esempio è la seguente matrice:

  1  3  5  7
  10 11 16 20
  23 30 34 50

Il modo diretto è quello di iterare su ogni singolo numero nella matrice con due cicli (loop). Questo algoritmo ha complessità temporale O(n^2).
Una soluzione migliore è quella di utilizzare la ricerca binaria che porta la complessità temporale a O(log(n) + log(m)) = O(log(m*n).
La ricerca binaria viene utilizzata per individuare la riga e la colonna corrente dell'elemento della matrice da confrontare con il numero che cerchiamo.

(define (find-matrix matrix num)
(catch
  (local (row col start end tmp)
    (setq row (length matrix))
    (setq col (length (matrix 0)))
    (setq start 0)
    (setq end (- (* row col) 1))
    (while (<= start end)
      (setq mid (/ (+ start end) 2))
      (setq tmp (matrix (/ mid col) (% mid col)))
      (cond ((> tmp num)
             (setq end (- mid 1)))
            ((< tmp num)
             (setq start (+ mid 1)))
            (true (throw (list (/ mid col) (% mid col))))
      )
    )
    nil)))

(setq mx '((1 3 5 7) (10 11 16 21) (22 31 42 77)))

(find-matrix mx 7)
;-> (0 3)
(find-matrix mx 51)
;-> nil
(find-matrix mx 21)
;-> (1 3)

Nota: in newLISP possiamo usare la funzione "ref" per ricercare un elemento in una matrice/lista:
(ref 7 mx)
;-> (0 3)


----------------------------
Invertire le vocali (Google)
----------------------------

Scrivere una funzione che inverte solo le vocali della stringa di input.
Per esempio:
 In = "ciao"    -->  Out = "eouila"
 In = "aiuole"  -->  Out = "eouila"

Usiamo due puntatori, uno da destra (fine) e uno da sinistra (inizio) e ci muoviamo in entrambe le direzioni fino a che non troviamo due vocali. A questo punto scambiamo di posto le due vocali trovate.

(define (inverte-vocali str)
  (setq vocali "aeiouAEIOU")
  (setq chars (explode str))
  (setq start 0)
  (setq end (- (length str) 1))
  (while (< start end)
    (while (and (< start end) (not (find (chars start) vocali)))
           (++ start)
    )
    (while (and (< start end) (not (find (chars end) vocali)))
           (-- end)
    )
    (swap (chars start) (chars end))
    (++ start)
    (-- end)
  )
  (join chars))

(inverte-vocali "ciao")
;-> "coai"
(inverte-vocali "aiuole")
;-> "eouila"
(inverte-vocali "newLISP")
;-> "nIwLeSP"

Soluzione simile che utilizza due puntatori che attraversono la stringa nelle due direzioni.

(define (vocali str)
  (local (i j t)
    (setq i 0 j (- (length str) 1))
    ; fino a che l'indice da sinistra è minore dell'indice da destra...
    (while (< i j)
      ; avanti fino ad una vocale (o indici uguali)
      (until (or (find (str i) "aeiouAEIOU") (= i j)) (++ i))
      ; indietro fino ad una vocale (o indici uguali)
      (until (or (find (str j) "aeiouAEIOU") (= i j)) (-- j))
      ; scambiamo di posto le due vocali trovate
      (setq t (str i))
      (setf (str i) (str j))
      (setf (str j) t)
      (++ i)
      (-- j)
    )
    str
  )
)

(vocali "pippo")
;-> "poppi"

(vocali "eva")
;-> "ave"

(vocali "sfgchjkv")
;-> sfgchjkv

(vocali "stra")
;-> "stra"

(vocali "")
;-> ""


------------------------------
Intervalli mancanti (LeetCode)
------------------------------

Dato una lista ordinata di interi in cui l'intervallo di elementi è compreso in [inferiore, superiore], restiture i numeri/intervalli mancanti.

Ad esempio, la lista (0 1 3 50 75) inferiore = 0 e superiore = 99, deve restituire ("2" "4..49" "51..74" "76..99").

Nota: La soluzione non controlla se si verifca un'overflow dei numeri.

(define (find-range lst inf sup)
  (local (sx dx out)
    (setq out '())
    (setq sx 0 dx 0)
    (for (i -1 (- (length lst) 1))
      (if (>= i 0)
          (setq sx (+ (lst i) 1))
          (setq sx inf)
      )
      (if (< (+ i 1) (length lst))
          (setq dx (- (lst (+ i 1)) 1))
          (setq dx sup)
      )
      (cond ((> sx dx) nil)
            ((= sx dx) (push (string sx) out -1))
            (true (push (string sx ".." dx) out -1))
      )
    )
    out))

(find-range '(0 1 3 50 75) 0 99)
;-> ("2" "4..49" "51..74" "76..99")

(find-range '(-2 0 1 3 20 41 50 75) -100 100)
;-> ("-100..-3" "-1" "2" "4..19" "21..40" "42..49" "51..74" "76..100")

Per restituire tutti i numeri mancanti (invece degli intervalli) possiamo modificare la funzione "find-range" oppure scrivere una nuova funzione. Possiamo risolvere velocemente il problema con le primitive di newLISP:

(define (find-numbers lst inf sup)
  (difference (sequence inf sup) lst))

(find-numbers '(0 1 3 50 75) 0 99)
;-> (2 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
;->  26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46
;->  47 48 49 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68
;->  69 70 71 72 73 74 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90
;->  91 92 93 94 95 96 97 98 99)


----------------------------------
Numeri strobogrammatici (LeetCode)
----------------------------------

Un numero strobogrammatico è un numero che è uguale a se stesso se ruotato di 180 gradi (il centro di rotazione si trova a metà del numero).
Ad esempio, i numeri "69", "88" e "818" sono tutti strobogrammatici.
Scrivere una funzione per determinare se un numero è strobogrammatico.

Rappresentiamo la mappa dei numeri (1 -> 1), (8 -> 8), (0 -> 0), (6 -> 9) e (9 -> 6) con una lista associativa.

Usiamo due puntatori (sinistra e destra) che si muovono, rispettivamente verso destra e verso sinistra.
Fino  a che non risulta sinistra = destra:
  se il numero corrente di sinistra non compare nella lista di mappatura (link) oppure
  se il carattere che mappa il numero corrente di sinistra è diverso
  dal carattere corrente di destra, allora restituiamo nil.
Al termine restituiamo true.

(define (strobogrammatic? num)
(catch
  (local (link s sx dx)
    (setq link '(("1" "1") ("0" "0") ("8" "8") ("6" "9") ("9" "6")))
    (setq s (string num))
    (setq sx 0)
    (setq dx (- (length s) 1))
    (while (<= sx dx)
      (if (or (not (lookup (s sx) link)) (!= (lookup (s sx) link) (s dx)))
          (throw nil)
      )
      (++ sx)
      (-- dx)
    )
    true)))

(setq num 69)
(strobogrammatic? 69)
;-> true
(strobogrammatic? 169)
;-> nil
(strobogrammatic? 1691)
;-> true

Scriviamo una funzione che trova i numeri strobogrammatici fino ad un numero n:

(define (strobogrammatici n)
  (let (out '())
    (for (i 1 n)
      (if (strobogrammatic? i)
          (push i out -1)))
    out))

(strobogrammatici 10000)
;-> (1 8 11 69 88 96 101 111 181 609 619 689 808 818 888 906 916 986
;->  1001 1111 1691 1881 1961 6009 6119 6699 6889 6969 8008 8118 8698
;->  8888 8968 9006 9116 9696 9886 9966)


-----------------------
Bomba sul nemico (Visa)
-----------------------

In una griglia (matrice 2D) ogni cella può essere un muro "W" (wall) o un nemico "E" (enemy) o una cella vuota "0". Possiamo lanciare una bomba in una cella vuota. La bomba colpisce tutti i nemici nella stessa riga e colonna della cella di impatto fino a quando non colpisce un muro.
Scrivere una funzione che massimizza e restituisce il numero di nemici colpiti.
Per esempio nella matrice seguente:

  0 E 0 0
  E 0 W E
  0 E 0 0

posizionando la bomba nella cella (1,1) si colpiscono 3 nemici (che è il valore massimo).

(define (bomba griglia)
  (local (x y somma bx by out)
    (setq out 0)
    (for (i 1 (- (length griglia) 1))
      (for (j 1 (- (length (griglia 0)) 1))
        (if (= (griglia i j) "0")
          (begin
            (setq somma 0)
            (setq x i) (setq y j)
            (while (and (>= x 0) (!= (griglia x y) "W"))
              (if (= (griglia x y) "E") (++ somma))
              (-- x))
            (setq x i) (setq y j)
            (while (and (< x (length griglia)) (!= (griglia x y) "W"))
              (if (= (griglia x y) "E") (++ somma))
              (++ x))
            (setq x i) (setq y j)
            (while (and (>= y 0) (!= (griglia x y) "W"))
              (if (= (griglia x y) "E") (++ somma))
              (-- y))
            (setq x i) (setq y j)
            (while (and (< y (length (griglia 0))) (!= (griglia x y) "W"))
              (if (= (griglia x y) "E") (++ somma))
              (++ y))
            (if (> somma out) (begin
                (setq out (max out somma))
                (setq bx i) (setq by j))
            )
    ))))
    (list (list bx by) out)))

(setq m '(
 ("0" "E" "0" "0")
 ("E" "0" "W" "E")
 ("0" "E" "0" "0")))

(bomba m)
;-> ((1 1) 3)

(setq m '(
 ("0" "E" "0" "0" "0" "E" "0" "0")
 ("E" "W" "W" "E" "0" "E" "W" "E")
 ("0" "E" "0" "0" "0" "W" "0" "0")
 ("W" "E" "0" "W" "0" "E" "0" "E")
 ("0" "E" "0" "0" "0" "W" "0" "0")
 ("0" "E" "0" "0" "0" "E" "W" "0")
 ("W" "E" "0" "W" "0" "E" "0" "E")))

(bomba m)
;-> ((2 7) 3)


----------------------------------
Pitturare una staccionata (Amazon)
----------------------------------

Supponiamo di avere una staccionata con n pali in cui ogni palo può essere dipinto con uno di k colori diversi. Bisogna dipingere tutti i pali in modo che non più di due pali di recinzione adiacenti abbiano lo stesso colore.

(define (pitta n k)
  (local (uguali diversi out)
    (setq uguali 0)
    (setq diversi k)
    (setq out (+ uguali diversi))
    (for (i 2 n)
      (setq uguali diversi)
      (setq diversi (* out (- k 1)))
      (setq out (+ uguali diversi))
    )
    out))

(pitta 10 3)
;-> 27408

(pitta 10 8)
;-> 957345928


-----------------------------------------------------------------
Palindroma più lunga in una stringa (algoritmo Manacher) (Amazon)
-----------------------------------------------------------------

Una parola s è palindroma se il primo carattere di s è uguale all'ultimo, il secondo è
uguale al penultimo e così via. In altri termini, una parola è palindroma se viene letta allo stesso modo sia da sinistra a destra, sia da destra a sinistra.
Il problema della stringa palindroma più lunga consiste nel determinare il maggior numero di caratteri che formano una sotto-stringa palindroma contenuti in una parola.
Per esempio:
input: "aaaabbaa"
output:  "aabbaa"

Questo problema può essere risolto in tempo quadratico con l'algoritmo base, in tempo O(n*log(n)) con array di suffissi e in tempo O(n) con l'algoritmo di Manacher (1975).

(define (manacher str)
  (local (tmp center palind mirror k idx from to)
    ; i caratteri "^", "#" e "$" non devono essere nella stringa str
    ; la stringa "abc" viene trasformata in "^#a#b#c#$"
    (setq tmp (string "^#" (join (explode str) "#") "#$"))
    (setq center 1 dist 1)
    (setq palind (array (length tmp) '(0)))
    (for (i 2 (- (length tmp) 2))
      ; riflette l'indice i rispetto al centro
      (setq mirror (- (* 2 center) i))
      (setf (palind i) (max 0 (min (- dist i) (palind mirror))))
      ; aumenta la stringa palindroma centrata in i
      (while (= (tmp (+ i 1 (palind i))) (tmp (- i 1 (palind i))))
        (++ (palind i))
      )
      ; Se necessario aggiusta il centro
      (if (> (+ i (palind i)) dist)
          (setq center i dist (+ i (palind i)))
      )
    )
    (setq k (palind 1))
    (setq idx 1)
    (for (i 1 (- (length tmp) 2))
      (if (> (palind i) k)
          (setq k (palind i) idx i)
      )
    )
    (setq from (/ (- idx k) 2))
    (setq to (/ (+ idx k) 2))
    ; stringa soluzione
    (slice str from (- to from))))

(manacher "aaaabbaa")
;-> "aabbaa"

(manacher "babcbabcbaccba")
;-> "abcbabcba"

(manacher "abcitopinonavevanonipotixyz")
;-> itopinonavevanonipoti


------------------------------
Permutazioni Palindrome (Uber)
------------------------------

Determinare tutte le stringhe palindrome che possono essere generate da una data stringa.

Funzione che calcola le permutazioni:

(define (perm lst)
  (local (i indici out)
    (setq indici (dup 0 (length lst)))
    (setq i 0)
    (setq out (list lst))
    (while (< i (length lst))
      (if (< (indici i) i)
          (begin
            (if (zero? (% i 2))
              (swap (lst 0) (lst i))
              (swap (lst (indici i)) (lst i))
            )
            (push lst out -1)
            (++ (indici i))
            (setq i 0)
          )
          (begin
            (setf (indici i) 0)
            (++ i)
          )
       )
    )
    out))

Funzione che verifica le permutazioni palindrome:

(define (perm-pali str)
  (local (all out)
    (setq out '())
    (setq all (perm (explode str)))
    ; per ogni permutazione verifichiamo se è palindroma
    (dolist (el all)
      (if (= (join el) (reverse (join el)))
          (push (join el) out -1)
      )
    )
    (unique out)))

(perm-pali "anna")
;-> ("anna" "naan")

(perm-pali "racecar")
;-> ("racecar" "rcaeacr" "craearc" "carerac" "arcecra" "acrerca")

=============================================================================

==========

 LIBRERIE

==========

===================================
 OPERAZIONI CON I NUMERI COMPLESSI
===================================

newLISP non fornisce alcun tipo di numeri e operazioni per gestire i calcoli con i numeri complessi.
Possiamo scrivere alcune funzioni per supportare alcuni calcoli con questi numeri.
Ogni numero complesso (a + ib), dove a = parte_reale e b = parte_immaginaria o complessa, viene rappresentato con una lista (a b).
Per esempio, il numero (2 + i3) viene rappresentata dalla lista (2 3).

Definiamo due funzioni che estraggono la parte reale e quella immaginaria di un numero complesso:

Funzione estrazione parte reale "re"
------------------------------------
(define (re num) (first num))

Funzione estrazione parte immaginaria "im"
------------------------------------------
(define (im num) (last num))

(setq n1 '(3 -12))
(setq n2 '(-2 8))

(re n1)
;-> 3

(im n2)
;-> 8

I numeri complessi possono essere rappresentati in due modi:
1) forma cartesiana (o algebrica) -->  (a + ib)
2) forma esponenziale             -->  |z|*e^it (dove z = modulo, t = angolo)

Vediamo le formule che permettono di trasformare un numero complesso tra le due forme:

Cartesiana --> Esponenziale
Dato il numero complesso z = a + ib:

|z| = sqrt(a^2 + b^2)

    +arccos(a/|z|)   se b >= 0
t =
    -arccos(a/|z|)   se b < 0

Esponenziale --> Cartesiana
Dato il numero complesso z = |z|*e^it:

a = Re(z) = |z|*cos(t)
b = Im(z) = |z|*sin(t)

Adesso dobbiamo scrivere due funzioni che convertono un numero complesso tra le due forme cartesiana ed esponenziale. Anche il numero complesso in forma esponenziale può essere rappresentato da una lista con due valori:

 |z|e^it  -->  (z t)

dove z è il valore del modulo e t è il valore dell'angolo.

Anche in questo caso scriviamo due funzioni che estraggono il modulo e l'angolo da un numero complesso in forma esponenziale:

Funzione estrazione modulo "|z|"
------------------------------------
(define (z num) (first num))

Funzione estrazione angolo "t"
------------------------------------------
(define (t num) (last num))

Inoltre utilizziamo anche la costante di Eulero e la costante pi greco:

(constant '*e*  2.7182818284590451)
(constant '*pi* 3.1415926535897931)

Adesso possiamo scrivere le funzioni di conversione tra le due forme:

Conversione Cartesiana --> Esponenziale
---------------------------------------

(define (ccx2ecx num)
  (let (z (sqrt (add (mul (re num) (re num)) (mul (im num) (im num)))))
       (list z
             (if (< (im num) 0)
                 (acos(div (re num) z))
                 (sub 0 (acos(div (re num) z)))
             )
       )
  )
)

cartesiana: sqrt(3) + 1i

(setq num (list (sqrt 3) 1))
;-> (1.732050807568877 1)

(ccx2ecx num)
;-> (2 -0.5235987755982987)

esponenziale: 2*e^-0.5235987755982987i
(dove -0.5235987755982987 = *pi*/6)

(div *pi* 6)
;-> 0.5235987755982988

Conversione Esponenziale --> Cartesiana
---------------------------------------

(define (ecx2ccx num)
  (list (mul (z num) (cos (t num)))
        (mul (z num) (sin (t num))))
)

esponenziale: 2*e^-0.5235987755982987i

(setq num (list 2 -0.5235987755982987))
;-> (2 -0.5235987755982987)

(ecx2ccx num)
;-> (1.732050807568877 -0.9999999999999997)

cartesiana: 1.732050807568877 -0.9999999999999997i
(dove 1.732050807568877 = sqrt(3))

(sqrt 3)
;-> 1.732050807568877

Siamo pronti per scrivere le funzioni di base per la gestione di calcoli con i muneri complessi:
1) addizione
2) sottrazione
3) moltiplicazione
4) divisione
5) reciproco (o inverso)
6) potenza

Addizione di due numeri complessi "+cx"
---------------------------------------

(define (+cx n1 n2)
  (list (add (re n1) (re n2)) (add (im n1) (im n2)))
)

(+cx n1 n2)
;-> (1 -4)

Sottrazione di due numeri complessi "-cx"
-----------------------------------------

(define (-cx n1 n2)
  (list (sub (re n1) (re n2)) (sub (im n1) (im n2)))
)

(-cx n1 n2)
;-> (5 -20)

Moltiplicazione di due numeri complessi "*cx"
---------------------------------------------

(define (*cx n1 n2)
  (list (sub (mul (re n1) (re n2)) (mul (im n1) (im n2)))
        (add (mul (im n1) (re n2)) (mul (re n1) (im n2))))
)

(*cx n1 n2)
;-> (90 48)

(*cx n2 n1)
;-> (90 48)

Divisione di due numeri complessi "/cx"
---------------------------------------

(define (/cx n1 n2)
  (if (and (zero? (re n2)) (zero? im n2))
    (list nil nil())
    (list (div (add (mul (re n1) (re n2)) (mul (im n1) (im n2)))
               (add (mul (re n2) (re n2)) (mul (im n2) (im n2))))
          (div (sub (mul (im n1) (re n2)) (mul (re n1) (im n2)))
               (add (mul (re n2) (re n2)) (mul (im n2) (im n2)))))
  )
)

(/cx n1 n2)
;->(-1.5 0)

(/cx n2 n1)
;->

Reciproco di un numero complesso "|cx"
-------------------------------------

Il reciproco (o l'inverso) di un numero complesso z = a + i b ≠ 0 è quel numero che moltiplicato per z ha come risultato 1.

(define (|cx n)
  (if (and (= (re n) 0) (= (im n) 0))
      ; (list (nil nil)
      (list (div 1 0) (div 1 0))
      (list (div (re n) (add (mul (re n) (re n)) (mul (im n) (im n))))
            (div (sub 0 (im n)) (add (mul (re n) (re n)) (mul (im n) (im n))))))
)

(setq n '(3 4))
(add (mul (re n) (re n)) (mul (im n) (im n)))

(|cx '(3 4))
;-> (0.12 -0.16)

(*cx '(3 4) '(0.12 -0.16))
;-> (1 0)

Potenza di un numero complesso "^cx"
------------------------------------

(define (^cx n p)
  (cond ((zero? p) (if (= 0 (re n)) (list 0 0) (list 1 0))) ;potenza nulla
        ((= p 1) (list (re n) (im n))) ;potenza uguale ad 1
        ((> p 1) ;potenza positiva maggiore di 1
          (setq t n)
          (for (i 1 (sub p 1))
            (setq t (*cx (list (re t) (im t)) (list (re n) (im n))))
          )
          (list (re t) (im t))
        )
        ((< p 0) ;potenza negativa
          (setq t n)
          (setq p (abs p))
          (for (i 1 (sub p 1))
            (setq t (*cx (list (re t) (im t)) (list (re n) (im n))))
          )
          (|cx (list (re t) (im t))) ; calcolo numero inverso
        )
  )
)

(^cx '(4 2) 2)
;-> (12 16)

(^cx '(4 2) -2)
;-> (0.03 -0.04)

(^cx '(12 16) -2)
;-> (-0.0007 -0.0024)


============================
 OPERAZIONI CON LE FRAZIONI
============================

newLISP non fornisce alcun tipo di numeri e operazioni per gestire i calcoli con le frazioni.
Possiamo scrivere alcune funzioni per supportare il calcolo frazionario con numeri interi.

Ogni frazione numeratore e denominatore (N/D) viene rappresentata con una lista (N D).
Per esempio, la frazione 2/3 viene rappresentata dalla lista (2 3).
Prima di tutto scriviamo una funzione che semplifica una frazione (in altre parole, riduce una frazione ai minimi termini):

Funzione che semplifica una frazione "semplifica"
-------------------------------------------------

(define (semplifica frac)
  (local (num den n d temp, nums dens)
    (setq num (first frac))
    (setq den (last frac))
    (setq n (first frac))
    (setq d (last frac))
    ; calcola il numero massimo che divide esattamente numeratore e denominatore
    (while (!= d 0)
      (setq temp d)
      (setq d (% n temp))
      (setq n temp)
    )
    (setq nums (/ num n))
    (setq dens (/ den n))
    ; controllo del segno
    (cond ((or (and (< dens 0) (< nums 0)) (and (< dens 0) (> nums 0)))
           (setq nums (* nums -1))
           (setq dens (* dens -1))
          )
    )
    (list nums dens)
  )
)

(semplifica '(4 8))
;-> (1 2)

(semplifica '(1000 2500))
;-> (2 5)

(semplifica '(-2 -4))
;-> (1 2)

(semplifica '(-2 4))
;-> (-1 2)

Adesso possiamo scrivere le funzioni per le quattro operazioni.

Funzione che somma due frazioni "+f"
------------------------------------

(define (+f frac1 frac2 redux)
  (local (num den n1 d1 n2 d2)
    (setq n1 (first frac1))
    (setq d1 (last frac1))
    (setq n2 (first frac2))
    (setq d2 (last frac2))
    (setq num (+ (* n1 d2) (* n2 d1)))
    (setq den (* d1 d2))
    (if redux (list num den)
          (semplifica (list num den))
    )
  )
)

Se l'argomento "redux" vale true, allora il risultato non viene semplificato.

(+f '(3 4) '(2 3))
;-> (17 12)

(+f '(2 4) '(2 3))
;-> (7 6)

(+f '(2 4) '(2 3) true)
;-> (14 12)

(+f '(10 100) '(40 100))
;-> (1 2)

Funzione che sottrae due frazioni "-f"
--------------------------------------

(define (-f frac1 frac2 redux)
  (local (num den n1 d1 n2 d2)
    (setq n1 (first frac1))
    (setq d1 (last frac1))
    (setq n2 (first frac2))
    (setq d2 (last frac2))
    (setq num (- (* n1 d2) (* n2 d1)))
    (setq den (* d1 d2))
    (if redux (list num den)
          (semplifica (list num den))
    )
  )
)

(-f '(12 13) '(13 13))
;-> (-1 13)

(-f '(-12 -13) '(-13 -13))
;-> (-1 13)

(+f '(-12 -13) '(-14 -13) true)
;-> (338 169)

(+f '(-12 -13) '(-14 -13))
;-> (2 1)

Funzione che moltiplica due frazioni "*f"
-----------------------------------------

(define (*f frac1 frac2 redux)
  (local (num den n1 d1 n2 d2)
    (setq n1 (first frac1))
    (setq d1 (last frac1))
    (setq n2 (first frac2))
    (setq d2 (last frac2))
    (setq num (* n1 n2))
    (setq den (* d1 d2))
    (if redux (list num den)
          (semplifica (list num den))
    )
  )
)

(*f '(3 6) '(3 5))
;-> (3 10)

(*f '(-3 6) '(3 5) true)
;-> -9 30)

Funzione che divide due frazioni "/f"
-------------------------------------

(define (/f frac1 frac2 redux)
  (local (num den n1 d1 n2 d2)
    (setq n1 (first frac1))
    (setq d1 (last frac1))
    (setq n2 (first frac2))
    (setq d2 (last frac2))
    (setq num (* n1 d2))
    (setq den (* d1 n2))
    (if redux (list num den)
          (semplifica (list num den))
    )
  )
)

(/f '(2 4) '(1 -3))
;-> (-3 2)

(/f '(2 4) '(3 2) true)
;-> (4 12)

Funzione che calcola la potenza di una frazione "^f"
----------------------------------------------------

(define (^f frac power redux)
  (local (num den n d)
    (setq n (first frac))
    (setq d (last frac))
    (setq num (int (pow n power)))
    (setq den (int (pow d power)))
    (if redux (list num den)
          (semplifica (list num den))
    )
  )
)

(^f '(3 4) 4)
;-> (81 256)

(^f '(3 5) 2)
;-> (9 25)

Sul forum di newLISP, rickyboy ha fornito le seguenti funzioni equivalenti (che sono molto più compatte e veloci):

(define (rat n d)
  (let (g (gcd n d))
    (map (curry * 1L)
         (list (/ n g) (/ d g)))))

(define (+rat r1 r2)
  (rat (+ (* (r1 0) (r2 1))
          (* (r2 0) (r1 1)))
       (* (r1 1) (r2 1))))

(define (-rat r1 r2)
  (rat (- (* (r1 0) (r2 1))
          (* (r2 0) (r1 1)))
       (* (r1 1) (r2 1))))

(define (*rat r1 r2)
  (rat (* (r1 0) (r2 0))
       (* (r1 1) (r2 1))))

(define (/rat r1 r2)
  (rat (* (r1 0) (r2 1))
       (* (r1 1) (r2 0))))

Per generalizzare le funzioni che abbiamo scritto, dobbiamo permettere che queste siano in grado di gestire un numero variabile di argomenti (attualmente possiamo passare solo due frazioni alle nostre funzioni).
Usiamo le seguenti funzioni per estrarre il numeratore e il denominatore da una frazione (num den):

Numeratore di (num den)
-----------------------
(define (numf f) (first f))

Denominatore di (num den)
-------------------------
(define (denf f) (last f))

Poi riscriviamo la funzione che semplifica (riduce ai minimi termini) una frazione:

(define (redux f)
  (local (num den)
    (setq num (/ (numf f) (gcd (numf f) (denf f))))
    (setq den (/ (denf f)  (gcd (numf f) (denf f))))
    (cond ((or (and (< den 0) (< num 0)) (and (< den 0) (> num 0)))
            (setq num (* num -1))
            (setq den (* den -1)))
    )
    (list num den)
  )
)

Testiamo la funzione "redux":

(redux '(-30 5))
;-> (-6 1)

(redux '(-30 -5))
;-> (6 1)

(redux '(30 -5))
;-> (-6 1)

(redux '(30 5))
;-> (6 1)

Adesso riscriviamo (in modo più conciso) la funzione che somma due frazioni:

(define (+f-aux f1 f2)
  (redux (list (+ (* (numf f1) (denf f2)) (* (numf f2) (denf f1)))
               (* (denf f1) (denf f2))))
)

Si tratta di una funzione (ausiliaria) che prende come parametro due frazioni.
Adesso scriviamo una macro che permette di applicare la funzione "+f-aux" ad un numero qualunque di frazioni:

(define-macro (+f)
  ; somma tutte le frazioni passate come argomento a due a due
  (apply +f-aux (map eval (args)) 2))

Nota:
L'espressione (apply +f-aux (map eval (args)) 2) permette di chiamare la macro "+f" con gli argomenti quotati (es. (+f '(1 2) '(1 2) '(1 2))).
Se avessimo scritto (apply +f-aux (args) 2) dovremmo chiamare la macro "+f" con gli argomenti non quotati (es. (+f (1 2) (1 2) (1 2))).
Questo è dovuto al fatto che le macro non valutano gli argomenti, quindi è necessario utilizzare la funzione "eval" per valutare gli argomenti.
Vediamo un esempio:

(define-macro (a)
  (args))

(a (1 2) (1 2) (1 2))
;-> ((1 2) (1 2) (1 2))

(define-macro (a)
  (map eval (args)))

(a '(1 2) '(1 2) '(1 2))
;-> ((1 2) (1 2) (1 2))

Adesso possiamo testare la nostra nuova funzione "f+":

(+f '(1 2) '(1 3))
;-> (5 6)

(+f '(1 2) '(1 2) '(1 2))
;-> (3 2)

(+f '(20 2) '(-1 -2) '(1 2))
;-> (11 1)

Riscriviamo tutte le funzioni che operano sulle frazioni:
1) addizione
2) sottrazione
3) moltiplicazione
4) divisione
5) potenza

Funzioni varie
--------------

;numeratore di (num den)
(define (numf f) (first f))

;denominatore di (num den)
(define (denf f) (last f))

;riduzione minimi termini
(define (redux f)
  (local (num den)
    (setq num (/ (numf f) (gcd (numf f) (denf f))))
    (setq den (/ (denf f)  (gcd (numf f) (denf f))))
    (cond ((or (and (< den 0) (< num 0)) (and (< den 0) (> num 0)))
            (setq num (* num -1))
            (setq den (* den -1)))
    )
    (list num den)
  )
)

Addizione frazioni "+f"
-----------------------

;ausiliaria
(define (+f-aux f1 f2)
  (redux (list (+ (* (numf f1) (denf f2)) (* (numf f2) (denf f1)))
               (* (denf f1) (denf f2))))
)

;Addiziona tutte le frazioni passate come argomento a due a due
(define-macro (+f)
  (apply +f-aux (map eval (args)) 2))


========================
 OPERAZIONI CON I TEMPI
========================

In questo capitolo definiremo due funzioni che permettono di addizionare e sottrarre due o più tempi.
Un valore tempo viene definito in ore, minuti, secondi e lo rappresenteremo con una lista con tre valori (h m s). Ad esempio, il tempo 3 ore, 34 minuti e 20 secondi è rappresentato dalla lista (3 34 20). Cominciamo con la funzione che somma due tempi.

Addizione di due tempi "+t"
---------------------------

Definiamo alcune funzioni di estrazione delle ore, minuti e secondi da un tempo:

(define (hh t) (first t))
(define (mm t) (first (rest t)))
(define (ss t) (last t))

Definiamo una funzione che normalizza il tempo, cioè controlla e ricalcola i tempi che hanno valori di minuti e/o secondi maggiori o uguali a 60.

(define (redux-t t)
  (local (h m s)
    (setq h (hh t)) (setq m (mm t)) (setq s (ss t))
    ; normalizza secondi (il valore dei secondi deve essere minore di 60)
    (while (>= s 60) (setq s (sub s 60)) (++ m))
    ; normalizza minuti (il valore dei minuti deve essere minore di 60)
    (while (>= m 60) (setq m (sub m 60)) (++ h))
    (list h m s)
  )
)

(redux-t '(0 6000 12000))
;-> (103 20 0)

Nota: la funzione "redux-t" non riduce valori negativi

; redux-t non riduce valori negativi
(redux-t '(0 -61 0))
;-> (0 -61 0)

(define (+t t1 t2)
  (local (h m s ch)
    ; riduzione dei tempi ai minimi termini
    (setq t1 (redux-t t1))
    (setq t2 (redux-t t2))
    (setq h (add (hh t1) (hh t2)))
    (setq m (add (mm t1) (mm t2)))
    (setq s (add (ss t1) (ss t2)))
    (redux-t (list h m s))
  )
)

(+t '(10 60 60) '(10 30 30))
;-> (21 31 30)

(+t '(60 1200 1200) '(60 120 300))
;-> (142 25 0)

Adesso definiamo la funzione che sottrae due tempi (un pò più complicata).

Sottrazione di due tempi "+t"
-----------------------------

(define (-t t1 t2)
  (local (h m s h1 m1 s1 h2 m2 s2 ch)
    ; riduzione dei tempi ai minimi termini
    (setq t1 (redux-t t1))
    (setq t2 (redux-t t2))
    ; estrazione ore (h), minuti (m), secondi (s)
    (setq h1 (hh t1)) (setq m1 (mm t1)) (setq s1 (ss t1))
    (setq h2 (hh t2)) (setq m2 (mm t2)) (setq s2 (ss t2))
    ; trova il tempo maggiore
    (if (< (add s1 (mul m1 1000) (mul h1 10000))
           (add s2 (mul m2 1000) (mul h2 10000)))
        (begin (swap h1 h2) (swap m1 m2) (swap s1 s2) (setq ch true))
    )
    ; sottrazione dei tempi
    (if (<= s2 s1) (setq s (sub s1 s2))
        (begin (setq s (add 60 (sub s1 s2))) (++ m2))
    )
    (if (<= m2 m1) (setq m (sub m1 m2))
        (begin (setq m (add 60 (sub m1 m2))) (++ h2))
    )
    (setq h (sub h1 h2))
    ; se abbiamo scambiato i due tempi (perchè il primo tempo era minore)
    ; allora cambiamo il segno delle ore o dei minuti o dei secondi
    (if (= ch true)
      (begin
        (setq h (sub 0 h))
        (if (= h 0) (setq m (sub 0 m)))
        (if (and (= h 0) (= m 0) (setq s (sub 0 s))))
      )
    )
    ; risultato
    (list h m s)
  );local
)

(redux-t '(150 300 200))
;-> (155 3 20)

(redux-t '(120 130 201))
;-> (122 13 21)

(-t '(155 3 20) '(122 13 21))
;-> (32 49 59)

(-t '(150 300 200) '(120 130 201))
;-> (32 49 59)

(-t '(120 130 201) '(150 300 200))
;-> (-32 49 59)

(-t '(24 58 2) '(24 58 1))
;-> (0 0 1)

(-t '(24 58 1) '(24 58 2))
;-> (0 0 -1)

(-t '(24 58 1) '(24 59 2))
;-> (0 -1 1)

(-t '(-3 0 0) '(-2 0 0))
;-> (-1 0 0)

(-t '(0 0 -1) '(0 0 -2))
;-> (0 0 1)

(+t '(0 0 -1) '(0 0 -2))
;-> (0 0 -3)

Adesso definiamo due macro che ci permettono di sommare o sottrarre un numero qualsiasi di tempi:

Addizione tempi "+tt"
---------------------

(define-macro (+tt)
  ; somma tutte i tempi passati come argomento a due a due
  (apply +t (map eval (args)) 2))

(+tt '(2 20 20) '(2 20 20) '(2 20 20))
;-> (7 1 0)

Sottrazione tempi "-tt"
-----------------------

(define-macro (-tt)
  ; sottrae tutti i tempi passati come argomento a due a due
  (apply -t (map eval (args)) 2))

(-tt '(2 20 20) '(2 20 20) '(2 20 20))
;-> (-2 20 20)

(+tt '(1 20 40) '(0 20 40) '(1 0 0))
;-> (2 41 20)

(-tt '(1 20 30) '(1 20 35) '(0 0 5))
;-> (0 0 -10)

(+tt '(0 0 -5) '(0 0 5))
;-> (0 0 0)

(-tt '(2 20 30) '(2 20 35))
;-> (0 0 -5)

(-tt '(2 20 30) '(2 20 35) '(0 0 5))
;-> (0 0 -10)


============================
 OPERAZIONI CON GLI INSIEMI
============================

newLISP fornisce alcune funzioni per operare sugli insiemi (set).
Vediamo quali sono e come implementare le funzioni che mancano (alcune di queste funzioni sono prese dal libro "A Practical Introduction to Fuzzy Logic using Lisp", Luis Argüelles Mendez, 2015).

Definiamo due insiemi (liste) per i test:

 (setq A '(a b c d e))

 (setq B '(a c e f g))

;------------------------------------------------------
; intersect (built-in)
;------------------------------------------------------
sintassi 1: (intersect list-A list-B)
sintassi 2: (intersect list-A list-B bool)
output: list

Nella prima sintassi, ritorna una lista che contiene una copia di ogni elemento che si trova sia nella list-A che nella list-B.

(intersect '(3 0 1 3 2 3 4 2 1) '(1 4 2 5))
;-> (2 4 1)

Nella seconda sintassi, ritorna una lista con tutti gli elementi della list-A che si trovano anche nella list-B, senza eliminazione dei duplicati della list-A.
bool è un espressione che deve essere true o nil.
Questa funzione mantiene l'ordine degli elementi della lista originale.

(intersect '(3 0 1 3 2 3 4 2 1) '(1 4 2 5) true)
;-> (1 2 4 2 1)

(intersect '(3 0 1 3 2 3 4 2 1) '(1 4 2 5) nil)
;-> (1 2 4)

;------------------------------------------------------
; difference (built-in)
;------------------------------------------------------
sintassi 1: (difference list-A list-B)
sintassi 2: (difference list-A list-B bool)
output: list

Questa funzione mantiene l'ordine degli elementi della lista originale.

Nella prima sintassi, restituisce la differenza tra gli insieme list-A e list-B.
La lista risultante ha solo gli elementi che si trovano nella list-A, ma non nella list-B.
Tutti gli elementi della lista risultante sono unici, ma le liste possono anche essere non uniche
Gli elementi della lista possono essere qualunque espressione lisp.

(difference '(2 5 6 0 3 5 0 2) '(1 2 3 3 2 1))
;-> (5 6 0)
(difference '(1 1 2 3 4) '(2 4 6 8))
;->  (1 3)
(difference '(1 1 2 3 4) '(2 4 6 8) true)
;-> (1 1 3)

Nella seconda sintassi, la differenza funziona in modalità elenco
bool è un espressione che deve essere true o nil.
Nelle lista risultante, tutti gli elementi di list-B sono eliminati nella list-A, ma i duplicati che si trovano nella list-A vengono mantenuti.

(difference '(2 5 6 0 3 5 0 2) '(1 2 3 3 2 1) true)
;-> (5 6 0 5 0)

(difference '(2 5 6 0 3 5 0 2) '(1 2 3 3 2 1) nil)
;-> (5 6 0)

;------------------------------------------------------
; unique (built-in)
;------------------------------------------------------
sintassi: (unique list)
output: list

Restituisce una lista in cui tutti i duplicati vengono rimossi.
Questa funzione mantiene l'ordine degli elementi della lista originale.

(unique '(2 3 4 4 6 7 8 7))
;-> (2 3 4 6 7 8)

La lista può essere non ordinata, ma una lista ordinata rende il calcolo più veloce.

;------------------------------------------------------
; union (built-in)
;------------------------------------------------------
sintassi: (union list-1 list-2 [list-3 ... ])
output: list

Restituisce una lista con tutti i valori diversi trovati nelle liste passate come argomento.
Questa funzione mantiene l'ordine degli elementi della lista originale.

(union '(1 3 1 4 4 3) '(2 1 5 6 4))
;-> (1 3 4 2 5 6)

;------------------------------------------------------
; belongs?
; "A Practical Introduction to Fuzzy Logic using Lisp", Luis Argüelles Mendez, 2015
;------------------------------------------------------
sintassi: (belongs? x A)
output: boolean

Restituisce true se un elemento x appartiene all'insieme A (nil altrimenti).

(define (belongs? x A)
  (if (or (intersect (list x) A) (= x '())) ;() is always a subset
    true nil))

(belongs? 'a '(a b c d e))
;-> true
(belongs? '() '(a b c d e))
;-> true

;------------------------------------------------------
; subset?
; "A Practical Introduction to Fuzzy Logic using Lisp", Luis Argüelles Mendez, 2015
;------------------------------------------------------
sintassi (subset? A B)
output: boolean

Restituisce true se l'insieme A è sottoinsieme dell'insieme B (nil altrimenti).

(define (subset? A B)
  (if (or (= A (intersect A B)) (= A '())) ;() is always a subset
    true nil))

(subset? '(a b c d e) '(a c e f g))
;-> nil
(subset? '(a b c d e) '(a b c d e))
;-> true

;------------------------------------------------------
; cardinality
;"A Practical Introduction to Fuzzy Logic using Lisp", Luis Argüelles Mendez, 2015
;------------------------------------------------------
sintassi: (cardinality A)
output: integer

Restituisce la cardinalità (numero degli elementi) di un insieme.

(define (cardinality S)
  (length S)
)

;------------------------------------------------------
; equivalent?
; "A Practical Introduction to Fuzzy Logic using Lisp", Luis Argüelles Mendez, 2015
;------------------------------------------------------
sintassi: (equivalent? A B)
output: boolean

Restituisce true se due insiemi sono equipotenti, cioè se hanno lo stesso numero di elementi (nil altrimenti).

(define (equivalent? A B)
  (if (= (cardinality A) (cardinality B)))
)

;------------------------------------------------------
; idem?
;------------------------------------------------------
sintassi: (idem? A B)
output: boolean

Restituisce true se due insiemi hanno gli stessi elementi nello stesso ordine (nil altrimenti).

(define (idem? A B)
  (if (= A B))
)

;------------------------------------------------------
; equal?
;------------------------------------------------------
sintassi: (equal? A B)
output: boolean

Restituisce true se due insiemi hanno gli stessi elementi, anche in ordine diverso (nil altrimenti).

(define (equal? A B)
  (if (= (sort A) (sort B)))
)

(setq A '(a b c))
(setq B '(a c b))
a

(equal? '(a b c) '(b a c))
(equal? A B)
(sort B)
B

;------------------------------------------------------
; disjoint?
; "A Practical Introduction to Fuzzy Logic using Lisp", Luis Argüelles Mendez, 2015
;------------------------------------------------------
sintassi: (disjoint? A B)
output: boolean

Restituisce true se due insiemi non hanno elementi in comune (nil altrimenti).

(define (disjoint? A B)
  (if (= (intersect A B) '()))
)

;------------------------------------------------------
; complement
; "A Practical Introduction to Fuzzy Logic using Lisp", Luis Argüelles Mendez, 2015
;------------------------------------------------------
sintassi: (complement A U)
output: list

Restituisce il complemento di un insieme rispetto all'insieme universo U.

(define (complement A U, lU i set-out)
  (setq set-out '())
  (setq lU (cardinality U))
  (setq i 0)
  (while (< i lU)
    (if (!= (belongs? (nth i U) A) true)
      (setq set-out (cons (nth i U) set-out))
    )
    (++ i) ;this is equivalent to (setq i (+ 1 i))
  );end while
  (reverse set-out)
)

(setq U '(a b c d e f g h))
(setq A '(c d e b h g))

(complement A U)
;-> (a f)

(difference U A) it is the same
;-> (a f)

;------------------------------------------------------
; cartesian-product
;------------------------------------------------------
sintassi: (cartesian-product A B)
output: list

Restituisce il prodotto cartesiano di due insiemi.

; iterative
(define (cartesian-product A B , lA lB i j set-out)
  (setq lA (cardinality A))
  (setq lB (cardinality B))
  (setq i 0 j 0) ;initializes i and j at the same time to zero
  (setq set-out '())
  (while (< i lA)
    (while (< j lB)
    (setq set-out (cons (list (nth i A) (nth j B)) set-out))
      (++ j) ;equivalent to (setq j (+ 1 j))
    );end while j
    (++ i) ;equivalent to (setq i (+ 1 i))
    (setq j 0) ;reinitializes j
  );end while i
  (reverse set-out)
)

(cartesian-product '(a b) '(a c))
;-> ((a a) (a c) (b a) (b c))
(cartesian-product '(a b) '(a b c))
;-> ((a a) (a b) (a c) (b a) (b b) (b c))

; recursive
(define (cart-one x lst)
  (cond
   ((null? lst) '())
   (true (cons (list x (first lst))
               (cart-one x (rest lst))))))

(dist-one 'b '(x y z))
;-> ((b x) (b y) (b z))

(define (cartesian A B)
  (cond
    ((null? A) '())
    (true (append (cart-one (first A) B)
              (cartesian (rest A) B)))))

(cartesian '(a b) '(x y z))
;-> ((a x) (a y) (a z) (b x) (b y) (b z))

;------------------------------------------------------
; powerset
;------------------------------------------------------
sintassi: (powerset A)
output: list

Restituisce l'insieme potenza di un insieme.

(define (powerset lst)
  (if (empty? lst)
      (list '())
      (let ( (element (first lst))
             (p (powerset (rest lst))))
           (append (map (fn (subset) (cons element subset)) p) p) )))

(powerset '(a b c d))
;-> ((a b c) (a b) (a c) (a) (b c) (b) (c) ())


=================
 FUNZIONI WINAPI
=================

Esempio di alcune funzioni che utilizzano le libreria di windows:

(context 'Win32API)

(import "user32.dll" "MessageBoxA")
(import "kernel32.dll" "GetShortPathNameA")
(import "kernel32.dll" "GetLongPathNameA")
(import "shell32.dll" "ShellExecuteA")

(define PATH_MAX 512)

(context MAIN)

;(define NULL 0)

(define (message-box text (title "newLISP"))
  (let ((MB_OK 0))
    (Win32API:MessageBoxA 0 text title MB_OK)))

(define (get-short-path-name pathname)
  (unless (file? pathname)
    (throw-error (list "No such file or directory" pathname)))
  (setq pathname (real-path pathname)) ; to fullpath
  (letn ((len Win32API:PATH_MAX)
         (buf (dup (char 0) (+ len 1)))
         (ret (Win32API:GetShortPathNameA pathname buf len)))
    (slice buf 0 ret)
    ;; (GetShortPathNameA pathname buf len) (get-string buf)
    ))

(define (get-longpathname pathname)
  (letn ((len Win32API:PATH_MAX)
         (buffer (dup (char 0) (+ len 1)))
         (r (Win32API:GetLongPathNameA pathname buffer len)))
    (if (= r 0) (throw-error '("GetLongPathNameA" "failure")))
    (slice buffer 0 r)))

(define (shell-execute app)
  (let ((SW_SHOWNORMAL 1) e)
    (setf e (Win32API:ShellExecuteA 0 "open" app 0 0 SW_SHOWNORMAL))
    ;(if (< e 32) )
    ))
;(shell-execute "C:\\PROGRA~1\\newLISP\\newLISP.exe")
;(shell-execute "C:/")
(shell-execute "http://www.newLISP.org/")

(context MAIN)
;;; EOF


==================================
 OPERAZIONI CON GLI ALBERI BINARI
==================================

Terminologia
------------

Un albero è un insieme finito di nodi tali che:
- esiste un nodo speciale chiamato "root" (radice)
- i nodi rimanenti sono partizionati in (n >= 0) insiemi disgiunti T(1)...T(n), dove ogni T(i) è un "sub-tree" (sotto-albero) della radice.

       radice
        /|\
       / | \
      /  |  \
     /   |   \
    /    |    \
  T(1) T(2)..T(n)

Supponiamo di avere il seguente albero:

              A                livello 1     altezza 0
             /|\
            / | \
           /  |  \
          /   |   \
         /    |    \
        B     C     D          livello 2     altezza 1
       / \    |    /|\
      /   \   |   / | \
     E     F  G  H  I  J       livello 3     altezza 2
    / \
   /   \
  K     L                      livello 4     altezza 3

Un nodo che ha sotto-alberi è il nodo "parent" (genitore) di quel sotto-albero (es. parent(B)).
Le radici di questi sotto-alberi sono i "children" (figli) di quel nodo (es. children(E, F))
I cildren dello stesso parent sono "sibling" (fratelli) (es. siblings(C, D).
La radice del nostro albero è il nodo A.
Il "grado" di un nodo è il numero di sotto-alberi di quel nodo. (es. grado(D) = 3)
La "profondità" (depth) di un nodo è la distanza dal nodo alla radice dell'albero.
Il "livello" (level) sono tutti i nodi che hanno la stessa profondità. Il livello della radice vale 1.
La "altezza" (height) la massima distanza di qualunque nodo dalla radice. Un albero con la sola radice ha altezza 0.

Rappresentazione
----------------

Un albero può essere rappresentato da una lista il cui primo elemento è la radice (root) e i rimanenti elementi sono sottoalberi.
Ad esempio, (A (B (E (K L)) F) (C (G)) (D (H (M)) I J))

Ogni nodo dell'albero può essere visto come un elemento della lista. Esistono tre tipi di nodi:

1) nodo radice (root node)
2) nodo ramo (branch node)
3) nodo foglia (leaf node)

Supponiamo di avere il seguente albero:

                             +-----> PS
                             +-----> AN
             + -----> MARCHE +-----> MC
             |               +-----> AP
             |               +-----> FM
             |
ITALIA ----> + -----> UMBRIA +-----> PG
             |               +-----> TR
             |
             |               +-----> FR
             |               +-----> LT
             + -----> LAZIO  +-----> RI
                             +-----> RM
                             +-----> VT

Un esempio di rappresentazione con una lista potrebbe essere il seguente:

(setq tree '(ITALIA
  (MARCHE (PS AN MC AP FM))
  (UMBRIA (PG TR))
  (LAZIO (FR LT RI RM VT))))
;-> (ITALIA (MARCHE (PS AN MC AP FM)) (UMBRIA (PG TR)) (LAZIO (FR LT RI RM VT)))

In questo caso abbiamo:

nodo radice: ITALIA
nodi ramo: MARCHE UMBRIA LAZIO
nodi foglia: PS AN MC AP FM PG TR FR LT RI RM VT

Possiamo creare questa lista anche in altri modi:

(setq tree (list 'ITALIA (list 'MARCHE (list 'PS 'AN 'MC 'AP 'FM))
                         (list 'UMBRIA (list 'PG 'TR))
                         (list 'LAZIO (list 'FR 'LT 'RI 'RM 'VT))))
;-> (ITALIA (MARCHE (PS AN MC AP FM)) (UMBRIA (PG TR)) (LAZIO (FR LT RI RM VT)))

(setq marche (list 'MARCHE (cons 'PS (cons 'AN (cons 'MC (cons 'AP (cons 'FM)))))))
(setq lazio  (list 'LAZIO  (cons 'FR (cons 'LT (cons 'RI (cons 'RM (cons 'VT)))))))
(setq umbria (list 'UMBRIA (cons 'PG (cons 'TR))))
(setq tree   (cons 'ITALIA (cons marche (cons umbria (cons lazio)))))
;-> (ITALIA (MARCHE (PS AN MC AP FM)) (LAZIO (FR LT RI RM VT)) (UMBRIA (PG TR)))

Altro esempio:

         A
        / \
       /   \
      B     C
     /     / \
    /     /   \
   D     E     F

Un altro tipo di rappresentazione dell'albero con una lista:

(setq lettere '(A (B (D () ())) (C (E () ()) (F () ()))))

nodo radice: A
nodi rami: B C
nodi foglie: D E F

Alberi binari
-------------

Un albero binario è vuoto o è composto da un elemento radice e due sotto-alberi, che sono essi stessi alberi binari. In Lisp rappresentiamo l'albero vuoto con il valore lista vuota '() e l'albero non vuoto dell'elenco (X L R), dove X indica il nodo radice e L e R indicano rispettivamente il sotto-albero sinistro (Left) e destro (Right).

Ad esempio il seguente albero:

           A
          / \
         /   \
        /     \
       B       C
      / \     / \
     /   \   /   \
    D     E ()    F
                 / \
                /   \
               G    ()

viene rappresentato dalla lista:

(A (B (D () ()) (E () ())) (C () (F (G () ()) ())))

Altri esempi sono un albero binario che consiste solo di un nodo radice: (A () ())

Oppure un albero binario vuoto: ()

Un albero binario di livello k è "pieno" quando ha (2^k - 1) nodi.
Un albero binario di livello k è "completo" quando tutti i nomi dei nodi corrispondono (posizionalmente) a quelli di un albero pieno di livello k.

Albero binario pieno    Albero binario completo    Albero binario inclinato

          A                       A                          A
         / \                     / \                        /
        /   \                   /   \                      B
       /     \                 /     \                    /
      B       C               B       C                  C
     / \     / \             / \                        /
    /   \   /   \           /   \                      D
   D     E F     G         D     E

Il seguente albero non è un albero binario completo (il nodo F non corrisponde a quello dell'albero pieno):

          A
         / \
        /   \
       /     \
      B       C
     / \       \
    /   \       \
   D     E       F


Il livello i-esimo di un albero binario può avere al massimo 2^(i-1) nodi.

Un albero binario con k livelli può avere al massimo Sum[1<=i<=k](2^(i-1)) = (2^k - 1) nodi.

In Lisp un albero binario viene rappresentato dalla lista: (T L R)
dove T = nome del nodo
     L = sotto-albero sinistro (Left)
     R = sotto-albero destro (Right)

Il nodo foglia viene rappresentato dalla lista: (T () ())

Esempio:
          A
         / \
        /   \
       B     C
      /     / \
     /     /   \
    D     E     F

(A (B (D nul nul) nul) (C (E nul nul) (F nul nul)))

radice: A
nodi: B C
foglie: D E F

(setq nul '())
(setq tree '(A (B (D nul nul) nul) (C (E nul nul) (F nul nul))))

Nome del nodo:
(first tree)
;-> A

sotto-albero sinistro
(first (rest tree))
;-> (B (D nul nul) nul)

sotto-albero destro
(first (rest (rest tree)))
(last (rest tree))
;-> (C (E nul nul) (F nul nul))

Le funzioni di base per gestire un albero binario sono le seguenti:

(define (empty-tree tree) --> Crea un albero vuoto
(define (empty-tree? tree) --> verifica se un albero è vuoto
(define (tree? lst) --> verifica se una lista è la rappresentazione di un albero binario
(define (make-tree data st-left st-right) --> crea un albero con radice di valore data e con i sottoalberi sinistro (st-left) e destro (st-right)
(define (name-tree tree) --> restituisce il valore/nome dell'albero
(define (left-tree tree) --> restituisce il sotto-albero sinistro dell'albero
(define (right-tree tree) --> restituisce il sotto-albero destro dell'albero

Le ultime tre funzioni potrebbero essere definite nel modo seguente:

(define (name-tree tree) (first tree))
(define (left-tree tree) (first (rest tree)))
(define (right-tree tree) (first (rest (rest tree))))

(name-tree tree)
;-> A

(left-tree tree)
;-> (B (D nul nul) nul)

(right-tree tree)
;-> (C (E nul nul) (F nul nul))

Attraversamento di alberi binari
--------------------------------

Per usare un albero binario dobbiamo essere in grado di visitare tutti i suoi nodi in un certo ordine.
Partendo dalla radice (o da un nodo) di un albero binario abbiamo tre azioni possibili:

        V
       / \
      /   \
     L     R

1) L --> muovi a sinistra (Left)
2) V --> visita il nodo (leggi il valore (Value) del nodo)
3) R --> muovi a destra (Right)

In base alla sequenza di queste azioni abbiamo i seguenti metodi principali di attraversamento:

Attraversamento "Inorder":   L-V-R

Attraversamento "Preorder":  V-L-R

Attraversamento "Postorder": L-R-V

Esempio (espressioni matematiche):

Applicando i metodi di attraversamento all'albero che rappresenta l'espressione aritmetica (A ^ B * C * D + E) otteniamo:

            +
           / \
          *   E
         / \
        *   D
       / \
      ^   C
     / \
    A   B

Inorder Traversal (infix expression) : A ^ B * C * D + E

Preorder Traversal (prefix expression) : + * * ^ A B C D E

Postorder Traversal (postfix expression) : A B ^ C * D * E +

A questo punto conosciamo le nozioni teoriche di base sugli alberi binari e possiamo scrivere alcune funzioni per gestirli:

Crea un albero binario (BST) vuoto "bst-create-empty"

(define (bst-create-empty) '())

Crea un albero binario "bst-create"

(define (bst-create value left-subtree right-subtree)
  (list value left-subtree right-subtree))

Verifica se un albero binario è vuoto "bst-isempty?"

(define (bst-isempty? BST) (null? BST))

Selezione del valore dell'albero binario "bst-value"

(define (bst-value BST) (first BST))

Selezione del sotto-albero sinistro dell'albero binario "bst-left-subtree"

(define (bst-left-subtree BST) (first (rest BST)))

Selezione del sotto-albero destro dell'albero binario "bst-right-subtree"

(define (bst-right-subtree BST) (first (rest (rest BST))))

Attraversamento Inorder "bst-traverse-inorder"

(define (bst-traverse-inorder BST)
    (cond
      ((bst-isempty? BST) '())
      (true (append
              (bst-traverse-inorder (bst-left-subtree BST))
              (list (bst-value BST))
              (bst-traverse-inorder (bst-right-subtree BST))))))

Attraversamento Preorder "bst-traverse-preorder"

(define (bst-traverse-preorder BST)
    (cond
      ((bst-isempty? BST) '())
      (true (append
              (list (bst-value BST))
              (bst-traverse-preorder (bst-left-subtree BST))
              (bst-traverse-preorder (bst-right-subtree BST))))))

Attraversamento Postorder "bst-traverse-postorder"

(define (bst-traverse-postorder BST)
    (cond
      ((bst-isempty? BST) '())
      (true (append
              (bst-traverse-postorder (bst-left-subtree BST))
              (bst-traverse-postorder (bst-right-subtree BST))
              (list (bst-value BST))))))

Vediamo un esempio:

           A
          / \
         /   \
        /     \
       B       C
      / \     / \
     /   \   /   \
    D     E ()    F
                 / \
                /   \
               G    ()

(setq tree '(A (B (D () ()) (E () ())) (C () (F (G () ()) ()))))

(bst-traverse-inorder tree)
;-> (D B E A C G F)

(bst-traverse-preorder tree)
;-> (A B D E C F G)

(bst-traverse-postorder tree)
;-> (D E B G F C A)

Vediamo l'espressione aritmetica precedente:

            +
           / \
          *   E
         / \
        *   D
       / \
      ^   C
     / \
    A   B

(setq arit '(+ (* (* (^ (A () ()) (B () ())) (C () ())) (D () ())) (E () ())))

infix
(bst-traverse-inorder arit)
;-> (A ^ B * C * D + E)

prefix
(bst-traverse-preorder arit)
;-> (+ * * ^ A B C D E) ;

postfix
(bst-traverse-postorder arit)
;-> (A B ^ C * D * E +) ;

Esistono anche altri due metodi di attraversamento degli alberi binari:

1) Breadth-First-Search (attraversamento livello per livello da sinistra a destra)

2) Depth-First-Search (attraversamento per profondità)

Scriviamo altre funzioni utili per la gestione degli alberi binari.

Verifica se una lista è la rappresentazione di un albero binario "bst-istree?"

(define (bst-istree? LST)
  (or (null? LST)
      (and (list? LST)
           (= (length LST) 3)
           (bst-istree? (bst-left-subtree LST))
           (bst-istree? (bst-right-subtree LST)))))

(setq tree '(A (B (D () ()) (E () ())) (C () (F (G () ()) ()))))
(bst-istree? tree)
;-> true

(setq arit '(+ (* (* (^ (A () ()) (B () ())) (C () ())) (D () ())) (E () ())))
(bst-istree? arit)
;-> true

(bst-istree? '(a (b) (c)))
;-> nil

(bst-istree? '(a b))
;-> nil

Conta il numero dei nodi di un albero binario "bst-count-nodes"

(define (bst-count-nodes BST)
  (if (bst-isempty? BST)
      0
      (+ 1 (bst-count-nodes (bst-left-subtree BST))
           (bst-count-nodes (bst-right-subtree BST)))))

(bst-count-nodes tree)
;-> 7

(bst-count-nodes arit)
;-> 9

Conta il numero di foglie di un albero binario "bst-count-leaves"

(define (bst-count-leaves BST)
  (if (bst-isempty? BST)
      0
      (if (and (bst-isempty? (bst-left-subtree BST)) (bst-isempty? (bst-right-subtree BST)))
          (+ 1 (bst-count-leaves (bst-left-subtree BST))
               (bst-count-leaves (bst-right-subtree BST)))
          (+   (bst-count-leaves (bst-left-subtree BST))
               (bst-count-leaves (bst-right-subtree BST))))))

(bst-count-leaves tree)
;-> 3

(bst-count-leaves arit)
;-> 5

Verifica se un albero binario è una foglia: "bst-isleaf?":

(define (bst-isleaf? BST)
    (and (bst-isempty? (bst-left-subtree BST))
         (bst-isempty? (bst-right-subtree BST))))

(bst-isleaf? '(a () ()))
;-> true

(bst-isleaf? '(a (b () ()) (c () ())))
;-> nil

(bst-isleaf? (bst-right-subtree '(a (b () ()) (c () ()))))
;-> true

(bst-isleaf? (bst-left-subtree '(a (b () ()) (c () ()))))
;-> true

Calcola l'altezza di un albero binario "bst-height"

(define (bst-height BST)
    (cond
      ; per convenzione l'altezza di un albero vuoto vale -1
      ((bst-isempty? BST) -1)
      (true (+ 1 (max (bst-height (bst-left-subtree BST))
                      (bst-height (bst-right-subtree BST)))))))

(bst-height tree)
;-> 3

(bst-height arit)
;-> 4

Cerca un valore in un albero binario "bst-find?"

(define (bst-find? BST value)
    (cond ((bst-isempty? BST) nil)
          ((= value (bst-value BST)) true)
          (true (or (bst-find? (bst-left-subtree BST) value)
                    (bst-find? (bst-left-subtree BST) value)))))

(bst-find? tree 'D)
;-> true

(bst-find? arit '^)
;-> true


Alberi binari di ricerca
------------------------

Un albero binario di ricerca (BST - Binary Search Tree) è un albero binario con le seguenti proprietà:

1) Il sottoalbero sinistro di un nodo x contiene soltanto i nodi con chiavi minori della chiave del nodo x
2) Il sottoalbero destro di un nodo x contiene soltanto i nodi con chiavi maggiori della chiave del nodo x
3) Il sottoalbero destro e il sottoalbero sinistro devono essere entrambi due alberi binari di ricerca.

Nota: poichè ogni nodo di un albero binario di ricerca è una "chiave" (key), non possono esistere due nodi con valori uguali.

Questa struttura permette di effettuare in maniera efficiente operazioni come: ricerca, inserimento e cancellazione di elementi.

Esempio:

           8
          / \
         /   \
        /     \
       3      10
      / \       \
     /   \       \
    1     6       14
         / \      /
        /   \    /
       4     7  13

(setq albero '(8 (3 (1 () ()) (6 (4 () ()) (7 () ()))) (10 () (14 (13 () ()) ()))))

(bst-count-nodes albero)
;-> 9

(bst-count-leaves albero)
;-> 4

Per verificare se un dato albero binario è un albero binario di ricerca (cioè soddisfa le proprietà elencate sopra), si può operare nel modo seguente:
- attraversare l'albero con il metodo "inorder"
- se la lista risultante è ordinata in modo crescente, allora è un albero binario di ricerca, altrimenti non lo è.

Nota: questo metodo è valido solo se l'albero non ha valori duplicati (ipotesi delle chiavi univoche)

Verifica se un albero binario è un albero binario di ricerca "bst-istreebst"

(define (bst-istreebst? BST)
  (apply < (bst-traverse-inorder BST)))

(setq albero '(8 (3 (1 () ()) (6 (4 () ()) (7 () ()))) (10 () (14 (13 () ()) ()))))

(bst-istreebst? albero)
;-> true

(bst-istreebst? tree)
;-> nil

(bst-istreebst? arit)
;-> nil

Esempio:

                |
          +--- 14 ---+
          |          |
    +--- 13    +--- 22 ---+
    |          |          |
    1         16    +--- 29 ---+
                    |          |
                   28         30

(setq numtree '(14 (13 (1 () ()) ()) (22 (16 () ()) (29 (28 () ()) (30 () ())))))

(bst-istreebst? numtree)
;-> true

Nota: Quando l'albero binario di ricerca ha valori duplicati possiamo mantenere le stesse funzioni utilizzando una struttura in cui un nodo può avere valori multipli.

Cerca un valore in un albero binario di ricerca "bst-member?"

(define (bst-member? BST value)
    (cond
      ((bst-isempty? BST) nil)
      ((= value (bst-value BST)) true)
      ((< value (bst-value BST)) (bst-member? (bst-left-subtree BST) value))
      (true (bst-member? (bst-right-subtree BST) value))))

Aggiunge un valore in un albero binario di ricerca "bst-add"

(define (bst-add BST value)   ; restituisce un bst con il valore aggiunto
    (cond
      ((bst-isempty? BST)           ; se vuoto, crea un nuovo nodo
       (bst-create value (bst-create-empty) (bst-create-empty)))
      ((< value (bst-value BST))    ; aggiunge il nodo al sotto-albero sinistro...
       (bst-create (bst-value BST)  ; ...aggiungendo un nuovo albero
                   (bst-add (bst-left-subtree BST) value)
                   (bst-right-subtree BST)))
      ((> value (bst-value BST))    ; aggiunge il nodo al sotto-albero destro
       (bst-create (bst-value BST)
                   (bst-left-subtree BST)
                   (bst-add (bst-right-subtree BST) value)))
      (true BST)))                  ; valore presente, non fare nulla anything

Esempio:

        5
       / \
      /   \
     4     6

(setq tri '(5 (4 () ()) (6 () ())))

(bst-add tri 2)
;-> (5 (4 (2 () ()) ()) (6 () ()))

Elimina un valore in un albero binario di ricerca "bst-delete"

(define (bst-delete BST value)   ; restituisce un bst con il valore eliminato
    (cond
      ((bst-isempty? BST) (bst-create-empty))
      ((= value (bst-value BST)) (bst-delete-root BST))
      ((< value (bst-value BST))
       (bst-create (bst-value BST)
                   (bst-delete (bst-left-subtree BST) value)
                   (bst-right-subtree BST)))
      (true ; (> value (bst-value BST))
       (bst-create (bst-value BST)
                   (bst-left-subtree BST)
                   (bst-delete (bst-right-subtree BST) value)))))

(define (bst-delete-root BST)   ; restituisce un bst con la radice eliminata
    (cond
      ; se la radice non ha figli, il risultato è un bst vuoto
      ((bst-isleaf? BST) (bst-create-empty))
      ; se la radice ha un figlio (destro o sinistro),
      ; il risultato è quel figlio (con i suoi sotto-alberi)
      ((bst-isempty? (bst-left-subtree BST)) (bst-right-subtree BST))
      ((bst-isempty? (bst-right-subtree BST)) (bst-left-subtree BST))
      ; se la radice ha due figli,
      ; sostituisci il valore con il figlio più a sinistra del sotto-albero destro
      (true (letn ((replacement-value (bst-value (bst-leftmost-child (bst-right-subtree BST))))
                   (new-right-subtree (bst-delete (bst-right-subtree BST) replacement-value)))
              (bst-create replacement-value (bst-left-subtree BST) new-right-subtree)))))

(define (bst-isleaf? BST)
    (and (bst-isempty? (bst-left-subtree BST))
         (bst-isempty? (bst-right-subtree BST))))

(define (bst-leftmost-child BST)
    (cond
      ((bst-isempty? BST) (bst-create-empty))
      ((bst-isempty? (bst-left-subtree BST)) BST)
      (true (bst-leftmost-child (bst-left-subtree BST)))))

Esempio:

           8
          / \
         /   \
        /     \
       3      10
      / \       \
     /   \       \
    1     6       14
         / \      /
        /   \    /
       4     7  13

(setq albero '(8 (3 (1 () ()) (6 (4 () ()) (7 () ()))) (10 () (14 (13 () ()) ()))))
;-> (8 (3 (1 () ()) (6 (4 () ()) (7 () ()))) (10 () (14 (13 () ()) ())))

(bst-member? albero 3)
;-> true

(setq newtree (bst-add albero 2))
;-> (8 (3 (1 () (2 () ())) (6 (4 () ()) (7 () ()))) (10 () (14 (13 () ()) ())))

                       |
              +--------8---------+
              |                  |
              |                  |
              3                  10
             / \                   \
            /   \                   \
           /     \                   \
          1       6                  14
           \     / \                 /
            \   /   \               /
             2 4     7             13


(bst-delete newtree 2)
;-> (8 (3 (1 () ()) (6 (4 () ()) (7 () ()))) (10 () (14 (13 () ()) ())))
Abbiamo ottenuto lo stesso albero di partenza.

(bst-istreebst? albero)
;-> true

(bst-istreebst? (bst-delete-root albero))
;-> true

Verifica se un albero binario è bilanciato "bst-balanced?"

(define (bst-balanced? BST)
    (cond
      ((bst-isempty? BST) true)
      (true (and (= (bst-height (bst-left-subtree BST)) (bst-height (bst-right-subtree BST)))
                 (bst-balanced? (bst-left-subtree BST))
                 (bst-balanced? (bst-right-subtree BST))))))

(setq albero '(8 (3 (1 () ()) (6 (4 () ()) (7 () ()))) (10 () (14 (13 () ()) ()))))
(bst-count-nodes albero)
;-> 9
(bst-height albero)
;-> 3
(bst-balanced? albero)
;-> nil

(setq albero2 '(8 (3 (1 () ()) (6 () ())) (10 (4 () ()) (5 () ()))))
(bst-count-nodes albero2)
;-> 7
(bst-height albero2)
;-> 2
(bst-balanced? albero2)
;-> true

Verifica se un albero binario è quasi bilanciato "bst-relatively-balanced?"

(define (bst-relatively-balanced? BST)
    (>= 1 (abs (- (bst-height BST) (bst-shortest-path-to-leaf BST)))))

Calcola il percorso minimo fino alla foglia "bst-shortest-path-to-leaf"

(define (bst-shortest-path-to-leaf BST)
    (cond
      ((bst-isempty? BST) -1)
      (true (+ 1 (min (bst-shortest-path-to-leaf (bst-left-subtree BST))
                      (bst-shortest-path-to-leaf (bst-right-subtree BST)))))))

(bst-relatively-balanced? albero)
;-> nil

(bst-relatively-balanced? albero2)
;-> true

(bst-shortest-path-to-leaf albero)
;-> 1

(bst-shortest-path-to-leaf albero2)
;-> 2

Trova il valore minimo di un albero binario di ricerca "bst-find-min"

(define (bst-find-min BST)
    (cond
      ((bst-isempty? BST) nil)
      ((bst-isempty? (bst-left-subtree BST)) (bst-value BST))
      (true (bst-find-min (bst-left-subtree BST)))))

(bst-find-min albero)
;-> 1

Trova il valore massimo di un albero binario di ricerca "bst-find-max"

(define (bst-find-max BST)
    (cond
      ((bst-isempty? BST) nil)
      ((bst-isempty? (bst-right-subtree BST)) (bst-value BST))
      (true (bst-find-max (bst-right-subtree BST)))))

(bst-find-max albero)
;-> 14

Vediamo come creare un albero binario di ricerca (BST) da una lista di numeri:

(define (bst-make lst)
  (let (BST '())
    (dolist (el lst)
      (setf BST (bst-add BST el)))))

(setq lst '(23 12 1 4 5 28 4 9 10 45 89))
(setq albero (bst-make lst))
;-> (23 (12 (1 () (4 () (5 () (9 () (10 () ()))))) ()) (28 () (45 () (89 () ()))))

(bt-istree? albero)
;-> true

(bst-istree? albero)
;-> true

TODO:
- Print ASCII tree on console
- Depth-First-Search
- Breadth-First-Search

Adesso possiamo raggruppare in una libreria tutte le funzioni che abbiamo scritto finira differenziando le funzioni in base al tipo di albero (binario oppure binario di ricerca).

;;
;; Library File: tree-library.lsp
;; Library load: (load "tree-library.lsp")
;;

;;
;;
;; Alberi Binari
;; Binary Tree (BT)
;;
;;

; (bt-create-empty)
; Crea un albero binario (BT) vuoto
; output: '() (un albero binario vuoto)
(define (bt-create-empty) '())


; (bt-create value left-subtree right-subtree)
; Crea un BT
; output: BT
(define (bt-create value left-subtree right-subtree)
  (list value left-subtree right-subtree))


; (bt-isempty? BT)
; Verifica se un BT è vuoto
; output: true o nil
(define (bt-isempty? BT) (null? BT))


; (bt-value BT)
; Selezione del valore del BT
; output: valore del BT (radice del BT)
(define (bt-value BT) (first BT))


; (bt-left-subtree BT)
; Selezione del sotto-albero sinistro del BT
; output: sotto-albero sinistro del BT
(define (bt-left-subtree BT) (first (rest BT)))


; (bt-right-subtree BT)
; Selezione del sotto-albero destro dell'albero binario
; output: sotto-albero destro del BT
(define (bt-right-subtree BT) (first (rest (rest BT))))


; (bt-istree? LST)
; Verifica se una lista è la rappresentazione di un BT
; output: true o nil
(define (bt-istree? LST)
  (or (null? LST)
      (and (list? LST)
           (= (length LST) 3)
           (bt-istree? (bt-left-subtree LST))
           (bt-istree? (bt-right-subtree LST)))))


; (bt-count-nodes BT)
; Conta il numero di nodi del BT
; output: numero di nodi del BT
(define (bt-count-nodes BT)
  (if (bt-isempty? BT)
      0
      (+ 1 (bt-count-nodes (bt-left-subtree BT))
           (bt-count-nodes (bt-right-subtree BT)))))


; (bt-count-leaves BT)
; Conta il numero di foglie del BT
; output: numero di foglie del BT
(define (bt-count-leaves BT)
  (if (bt-isempty? BT)
      0
      (if (and (bt-isempty? (bt-left-subtree BT)) (bt-isempty? (bt-right-subtree BT)))
          (+ 1 (bt-count-leaves (bt-left-subtree BT))
               (bt-count-leaves (bt-right-subtree BT)))
          (+   (bt-count-leaves (bt-left-subtree BT))
               (bt-count-leaves (bt-right-subtree BT))))))


; (bt-height BT)
; Calcola l'altezza del BT
; output: altezza del BT
(define (bt-height BT)
    (cond
      ; per convenzione l'altezza di un albero vuoto vale -1
      ((bt-isempty? BT) -1)
      (true (+ 1 (max (bt-height (bt-left-subtree BT))
                      (bt-height (bt-right-subtree BT)))))))


; (bt-member? BT value)
; Cerca un valore nel BT
; output: true o nil
(define (bt-member? BT value)
    (cond ((bt-isempty? BT) nil)
          ((= value (bt-value BT)) true)
          (true (or (bt-member? (bt-left-subtree BT) value)
                    (bt-member? (bt-left-subtree BT) value)))))


; (bt-isleaf? BT)
; Verifica se il BT è una foglia:
; output: true o nil
(define (bt-isleaf? BT)
    (and (bt-isempty? (bt-left-subtree BT))
         (bt-isempty? (bt-right-subtree BT))))


; (bt-traverse-inorder BT)
; Attraversamento Inorder
; output: lista con tutti i nodi del BT
(define (bt-traverse-inorder BT)
    (cond
      ((bt-isempty? BT) '())
      (true (append
              (bt-traverse-inorder (bt-left-subtree BT))
              (list (bt-value BT))
              (bt-traverse-inorder (bt-right-subtree BT))))))


; (bt-traverse-preorder BT)
; Attraversamento Preorder
; output: lista con tutti i nodi del BT
(define (bt-traverse-preorder BT)
    (cond
      ((bt-isempty? BT) '())
      (true (append
              (list (bt-value BT))
              (bt-traverse-preorder (bt-left-subtree BT))
              (bt-traverse-preorder (bt-right-subtree BT))))))


; (bt-traverse-postorder BT)
; Attraversamento Postorder
; output: lista con tutti i nodi del BT
(define (bt-traverse-postorder BT)
    (cond
      ((bt-isempty? BT) '())
      (true (append
              (bt-traverse-postorder (bt-left-subtree BT))
              (bt-traverse-postorder (bt-right-subtree BT))
              (list (bt-value BT))))))

;;
;;
;; Alberi Binari di Ricerca
;; Binary Search Tree (BST)
;;
;;

; (bst-create-empty)
; Crea un albero binario di ricerca (BST) vuoto
; output: '() (un albero binario di ricerca vuoto)
(define (bst-create-empty) '())


; (bst-create value left-subtree right-subtree)
; Crea un BST
; output: BST
(define (bst-create value left-subtree right-subtree)
  (list value left-subtree right-subtree))


; (bst-isempty? BST)
; Verifica se un BST è vuoto
; output: true o nil
(define (bst-isempty? BST) (null? BST))


; (bst-value BST)
; Selezione del valore del BST
; output: valore del BST (radice del BST)
(define (bst-value BST) (first BST))


; (bst-left-subtree BST)
; Selezione del sotto-albero sinistro del BST
; output: sotto-albero sinistro del BST
(define (bst-left-subtree BST) (first (rest BST)))


; (bst-right-subtree BST)
; Selezione del sotto-albero destro del BST
; output: sotto-albero destro del BST
(define (bst-right-subtree BST) (first (rest (rest BST))))


; (bst-istree? BST)
; Verifica se un albero binario è un BST
; output: true o nil
(define (bst-istree? BST)
  (apply < (bst-traverse-inorder BST)))


; (bst-count-nodes BST)
; Conta il numero di nodi del BST
; output: numero di nodi del BST
(define (bst-count-nodes BST)
  (if (bst-isempty? BST)
      0
      (+ 1 (bst-count-nodes (bst-left-subtree BST))
           (bst-count-nodes (bst-right-subtree BST)))))


; (bst-count-leaves BST)
; Conta il numero di foglie del BST
; output: numero di foglie del BST
(define (bst-count-leaves BST)
  (if (bst-isempty? BST)
      0
      (if (and (bst-isempty? (bst-left-subtree BST)) (bst-isempty? (bst-right-subtree BST)))
          (+ 1 (bst-count-leaves (bst-left-subtree BST))
               (bst-count-leaves (bst-right-subtree BST)))
          (+   (bst-count-leaves (bst-left-subtree BST))
               (bst-count-leaves (bst-right-subtree BST))))))


; (bst-height BST)
; Calcola l'altezza del BST
; output: altezza del BST
(define (bst-height BST)
    (cond
      ; per convenzione l'altezza di un albero vuoto vale -1
      ((bst-isempty? BST) -1)
      (true (+ 1 (max (bst-height (bst-left-subtree BST))
                      (bst-height (bst-right-subtree BST)))))))


;("bst-member? BST value)"
; Cerca un valore nel BST
; output: true o nil
(define (bst-member? BST value)
    (cond
      ((bst-isempty? BST) nil)
      ((= value (bst-value BST)) true)
      ((< value (bst-value BST)) (bst-member? (bst-left-subtree BST) value))
      (true (bst-member? (bst-right-subtree BST) value))))


; (bst-isleaf? BST)
; Verifica se il BST una foglia:
; output: true o nil
(define (bst-isleaf? BST)
    (and (bst-isempty? (bst-left-subtree BST))
         (bst-isempty? (bst-right-subtree BST))))


; (bst-traverse-inorder BST)
; Attraversamento Inorder
; output: lista con tutti i nodi del BST
(define (bst-traverse-inorder BST)
    (cond
      ((bst-isempty? BST) '())
      (true (append
              (bst-traverse-inorder (bst-left-subtree BST))
              (list (bst-value BST))
              (bst-traverse-inorder (bst-right-subtree BST))))))


; (bst-traverse-preorder BST)
; Attraversamento Preorder
; output: lista con tutti i nodi del BST
(define (bst-traverse-preorder BST)
    (cond
      ((bst-isempty? BST) '())
      (true (append
              (list (bst-value BST))
              (bst-traverse-preorder (bst-left-subtree BST))
              (bst-traverse-preorder (bst-right-subtree BST))))))


; (bst-traverse-postorder BST)
; Attraversamento Postorder
; output: lista con tutti i nodi del BST
(define (bst-traverse-postorder BST)
    (cond
      ((bst-isempty? BST) '())
      (true (append
              (bst-traverse-postorder (bst-left-subtree BST))
              (bst-traverse-postorder (bst-right-subtree BST))
              (list (bst-value BST))))))


; (bst-add BST value)
; Aggiunge un valore nel BST
; output: BST
(define bst-add
  (lambda (BST value)
    (cond
      ((bst-isempty? BST)           ; if empty, create a new node
       (bst-create value (bst-create-empty) (bst-create-empty)))
      ((< value (bst-value BST))    ; add node to left subtree
       (bst-create (bst-value BST)  ; (functionally, by building new tree)
                   (bst-add (bst-left-subtree BST) value)
                   (bst-right-subtree BST)))
      ((> value (bst-value BST))    ; add node to right subtree
       (bst-create (bst-value BST)
                   (bst-left-subtree BST)
                   (bst-add (bst-right-subtree BST) value)))
      (true BST))))                 ; it's already there;


; (bst-delete BST value)
; Elimina un valore nel BST
; output: BST
(define (bst-delete BST value)
    (cond
      ((bst-isempty? BST) (bst-create-empty))
      ((= value (bst-value BST)) (bst-delete-root BST))
      ((< value (bst-value BST))
       (bst-create (bst-value BST)
                   (bst-delete (bst-left-subtree BST) value)
                   (bst-right-subtree BST)))
      (true ; (> value (bst-value BST))
       (bst-create (bst-value BST)
                   (bst-left-subtree BST)
                   (bst-delete (bst-right-subtree BST) value)))))


; (bst-delete-root BST)
; Elimina la radice del BST
; output: BST
(define (bst-delete-root BST)   ; return tree with root deleted
    (cond
      ; If the root has no children, result is empty tree
      ((bst-isleaf? BST) (bst-create-empty))
      ; If the root has one child (right or left),
      ; result is that child (and descendants)
      ((bst-isempty? (bst-left-subtree BST)) (bst-right-subtree BST))
      ((bst-isempty? (bst-right-subtree BST)) (bst-left-subtree BST))
      ; If the root has two children,
      ; replace value with leftmost child of right subtree
      (true (letn ((replacement-value (bst-value (bst-leftmost-child (bst-right-subtree BST))))
                   (new-right-subtree (bst-delete (bst-right-subtree BST) replacement-value)))
              (bst-create replacement-value (bst-left-subtree BST) new-right-subtree)))))


; (bst-leftmost-child BST)
; Selezione del sotto-albero più a sinistra del BST
; output: BST
(define (bst-leftmost-child BST)
    (cond
      ((bst-isempty? BST) (bst-create-empty))
      ((bst-isempty? (bst-left-subtree BST)) BST)
      (true (bst-leftmost-child (bst-left-subtree BST)))))


; (bst-balanced? BST)"
; Verifica se un albero binario è bilanciato
; output: true o nil
(define (bst-balanced? BST)
    (cond
      ((bst-isempty? BST) true)
      (true (and (= (bst-height (bst-left-subtree BST)) (bst-height (bst-right-subtree BST)))
                 (bst-balanced? (bst-left-subtree BST))
                 (bst-balanced? (bst-right-subtree BST))))))


; (bst-relatively-balanced? BST)
; Verifica se un albero binario è quasi bilanciato
; output: true o nil
(define (bst-relatively-balanced? BST)
    (>= 1 (abs (- (bst-height BST) (bst-shortest-path-to-leaf BST)))))


; (bst-shortest-path-to-leaf BST)
; Calcola il valore del percorso minimo fino alla foglia del BST
; output: valore del percorso minimo (radice --> foglia)
(define (bst-shortest-path-to-leaf BST)
    (cond
      ((bst-isempty? BST) -1)
      (true (+ 1 (min (bst-shortest-path-to-leaf (bst-left-subtree BST))
                      (bst-shortest-path-to-leaf (bst-right-subtree BST)))))))


; (bst-find-min BST)
; Trova il valore minimo del BST
; output: valore minimo del BST
(define (bst-find-min BST)
    (cond
      ((bst-isempty? BST) nil)
      ((bst-isempty? (bst-left-subtree BST)) (bst-value BST))
      (true (bst-find-min (bst-left-subtree BST)))))


; (bst-find-max BST)
; Trova il valore massimo del BST
; output: valore massimo del BST
(define (bst-find-max BST)
    (cond
      ((bst-isempty? BST) nil)
      ((bst-isempty? (bst-right-subtree BST)) (bst-value BST))
      (true (bst-find-max (bst-right-subtree BST)))))


; (bst-make lst)
; Crea un BST da una lista di numeri
; output: BST
(define (bst-make lst)
  (let (BST '())
    (dolist (el lst)
      (setf BST (bst-add BST el)))))

;(setq lst '(23 12 1 4 5 28 4 9 10 45 89))
;(setq albero (bst-make lst))
;-> (23 (12 (1 () (4 () (5 () (9 () (10 () ()))))) ()) (28 () (45 () (89 () ()))))

'library-tree-loaded
;
; end of library
;

Per caricare la libreria nella REPL:

(load "tree-library.lsp")


=========
 FUNLISP
=========

L'autore di questa libreria di funzioni "funlisp.lsp" è Dmitry Chernyak <dmi@en.feautec.pp.ru>.
La libreria è reperibile all'indirizzo:

http://en.feautec.pp.ru/store/libs/funlib.lsp

;; @module funlib.lsp
;; @author Dmitry Chernyak <dmi@en.feautec.pp.ru>
;; @version 1.22
;; @description The newLISP language unofficial extension module
;; @location http://en.feautec.pp.ru/store/libs/funlib.lsp

(context MAIN)

;; @syntax (push-end <item> <list>)
;;
;; Push <item> to the end of the <list>
;; Equivalent to (push item list -1)
(context 'MAIN:push-end)
(define-macro (push-end:push-end _push lst_push)
  "(push-end item list) - push item to the end of the list"
  (eval (list 'push (quote (eval _push)) lst_push -1)))

;; @syntax (pushl-end <lst> <slst> <index>)
;;
;; Push a list <lst> into the end of a list <slst>
;;
;; @param <slst> must be a list
;;
;; @return the last element of <lst>
;;
;; Effective as in-place alternative to <b>append</b> in case
;; of frequently appending to long list
;;
;; @example
;; (set 'l (1 2 3))
;; (pushl '(4 5 6) l)
;; l => (1 2 3 4 5 6)
(context 'MAIN:pushl-end)
(define-macro (pushl-end:pushl-end lst slst)
  "(pushl-end lst slst) - push a list lst into the end of a list in symbol slst"
  (dolist (l (eval lst))
    (push l (eval slst) -1)))

;; @syntax (dofile (<sym> <str-fnam>e [<str-delim> [<int-strlen>]]) <body>)
;; @syntax (dofile (<sym> <int-fd> [<str-delim> [<int-strlen>]]) <body>)
;;
;; Behaves like 'dolist' but for a file contents
;;
;; @param <sym> iterating symbol
;; @param <str-fname> filename
;; @param <int-fd> opened file descriptor (will be closed on finish)
;; @param <str-delim> "\n" by default; use nil to turn off explicitly
;; @param <int-strlen> 65000 by default. Not limited
;; @param <body> the plain sequence of funcalls
;;
;; @example
;; (dofile (l "/etc/passwd") (print ">") (println l))
;; =>
;; >root:x:0:0:root:/root:/bin/bash
;; >daemon:x:1:1:daemon:/usr/sbin:/bin/sh
;; >bin:x:2:2:bin:/bin:/bin/sh
;; >....
(context 'MAIN:dofile)
(define-macro (dofile:dofile ini)
  "(dofile (sym str-fname|int-fd [str-delim [int-strlen]]) body) - behaves like dolist, but for file's contents"
  (let (
    _sym (ini 0)
    fil (eval (ini 1))
    delim (eval (if (> (length ini) 2) (ini 2) "\n"))
    buflen (eval (if (> (length ini) 3) (ini 3) 65000))
    fd nil
    iter nil buf nil delim_len 0
    _read-buffer nil
    res nil err nil)
    (set 'delim_len (length delim))
    (if (not (set 'fd
      (if
        (string? fil) (open fil "r")
        (integer? fil) fil
        (throw-error "dofile: fname must evaluate to str-fname or int-fd"))))
      (throw-error "dofile: no file descriptor or can't open file"))
    (unless (atom? _sym) (set '_sym (eval _sym)))
    (set 'iter
      (expand (append '(let (_sym buf)) (args)) '_sym))
    (set '_read-buffer
      '(read-buffer fd 'buf buflen))
    (if delim (push 'delim _read-buffer -1))
    (set 'err (catch
      (while (or (eval _read-buffer) buf) ; works since 8.7.0
         (if (and delim (ends-with buf delim))
           (set 'buf (chop buf delim_len)))
         (eval iter))
      'res))
    (close fd)
    (if err res (throw-error res))))

;; @syntax (ecase <exp-switch> (<exp-key1> <body-1>)[ (<exp-key2> <body-2>)...])
;;
;; Like a <b>case</b> with evaluating <exp-key> before testing against evaluated <exp-switch>
;;
;; @param <exp-switch> expression, value of which will be tested against <exp-key> conditions
;; @param <exp-key> expression, value of which will be tested against value
(context 'MAIN:ecase)
(define-macro (ecase:ecase v)
  "(ecase ...) - case with evaluating exp-key before testing"
  (eval (append (list 'case v)
    (map (fn (i) (set-nth 0 i (eval (i 0))))
         (args)))))

;; @syntax (ifempty <exp-value> <exp-replacement>)
;;
;; Replace empty or nil value
;;
;; If the result of <exp-value> is <nil> or is empty, returns the result of
;; <exp-replacement>.
;; Otherwise returns the result of <exp-value>.<br>
;; NOTE: <b>ifempty</b> is a macro, so <exp-replacement> evaluated only when needed.
(context 'MAIN:ifempty)
(define-macro (ifempty:ifempty v r)
  "(ifempty value replacement) - replace empty or nil value"
  (set 'v (eval v))
  (if (or (not v) (empty? v)) (eval r) v))

;; @syntax (ifnil <exp-value> <exp-replacement>)
;;
;; Replace nil value
;;
;; If the result of <exp-value> is <nil>, returns the result of
;; <exp-replacement>.
;; Otherwise returns the result of <exp-value>.<br>
;; NOTE: <b>ifnil</b> is a macro, so <exp-replacement> evaluated only when needed.
(context 'MAIN:ifnil)
(define-macro (ifnil:ifnil v r)
  "(ifempty value replacement) - replace empty or nil value"
  (set 'v (eval v))
  (if v v (eval r)))

;; @syntax (file-tree <dir|dir-list> [<filter-function>])
;;
;; Filesystem tree iterator
;;
;; @param <dir|dir-list> starting directory or a list of several
;; @param <filter-function> filter: (lambda <filename> <dirname> <is-file>)
;; @param <is-file> <true> if filename is a file
;;
;; @return a list of pairs (<filename> <directory>) where <filename> satisfy
;; to filter-function (more precise - see code and examles).<br>
;; <filename> can be either the name of a file or a directory.
;;
;; @example
;; (setq list1 (file-tree "." ))
;; (setq list2 (file-tree "." (fn (x) (starts-with x "b" nil))))
;; ; got files only and skip directories
;; (setq list3 (file-tree "." (fn (f d is-file) is-file)))

;; ORIGIN<br>
;; file-tree was introduced by alex version 2005.12.02.
;; Published at newLisp fan Club forum.
;; funlib has slightly modified version of it.
; by alex (modified)
(context 'MAIN:file-tree)
(define-macro (file-tree:file-tree dir _filter)
  "(file-tree dir|dir-list [filter-function]) - filesystem tree iterator.\nfilter-function: (fn (filename dirname is-file))"
  (if (symbol? _filter) (setq _filter (eval _filter)))
  (letn
    ( result '()
      file-tree-utility
        (lambda (d)
          (dolist (f (replace "." (replace ".." (directory d))))
            (let (isdir (directory? (append d f)))
              (if isdir
                (file-tree-utility (append d f "/")))
              (if (or (not _filter) (_filter f d (not isdir)))
                (push (list f d) result))))))

    (unless (list? dir) (setq dir (list dir)))
    (dolist (d dir)
      (replace "\\" d "/")
      (unless (ends-with d "/") (setq d (append d "/" )))
      (file-tree-utility d))
    result))

;; @syntax (doif (<sym> <expr>) <expr-yes> <expr-no>)
;;
;; Anaphoric if
;;
;; Eval <expr-yes> if <expr> orherwise eval <expr-no><br>
;; While evaluating <expr-yes> or <expr-no> the result of <expr> is stored in <sym>
;; @example
;; (doif (l (lookup key table))
;;   (println "found: " l)
;;   (println "not found"))
(context 'MAIN:doif)
(define-macro (doif:doif test do-yes do-no)
        (eval
    (list let test (list 'if (first test) do-yes do-no))))

(context MAIN)

;; @syntax (inc-p '<sym> [<num>])
;;
;; Post increment function
;;
;; @param <num> increment value, 1 by default
(define (inc-p symb num)
  "(inc-p sym num) - post-increment sym by num"
  (let (old (eval symb))
    (if num (inc symb num) (inc symb))
  old))

;; @syntax (dec-p '<sym> [<num>])
;;
;; Post decrement function
;;
;; @param <num> decrement value, 1 by default
(define (dec-p symb num)
  "(dec-p sym num) - post-decrement sym by num"
  (let (old (eval symb))
    (if num (dec symb num) (dec symb))
  old))

;; @syntax (group <n> <lst>)
;;
;; Group list lst into sublists by n members, truncate the last incomplete group
;;
;; @param <n> number of members in a group, if <n>>0 group from start, else from end
(define (group n lst)
  "(group n lst) - group list by n members, truncate the last incomplete group"
  (letn
    (an (abs n)
     ln (length lst)
     t (% ln an))
    (if (> an ln) (set 'an ln))
    (array-list (array
      (/ ln an) an
      (if (> n 0)
        lst
        (t lst))))))

;; @syntax (group-all <n> <lst>)
;;
;; Group list lst into sublists by n members, save the last incomplete group
;;
;; @param <n> number of members in a group, if <n>>0 group from start, else from end
(define (group-all n lst)
  "(group-all n lst) - group list by n members, save the last incomplete group"
  (letn
    (an (abs n)
     ln (length lst)
     an (if (> an ln) ln an)
     t (% ln an)
     ml (array-list (array
      (/ ln an) an
      (if (> n 0) lst (t lst)))))
    (if (= t 0) ml
      (if (> n 0) (append ml (list ((- ln t) lst)))
        (append (list (0 t lst)) ml)))))

;; @syntax (group-by <lst> <ind-grp> <ind-memb>)
;;
;; Group sublists by a key
;;
;; @param <lst> list of some sublists
;; @param <ind-grp> list of member's indices in a sublists, which will be a KEY-list
;; @param <ind-memb> list of member's indices in a sublists, which will be a VALUE-list
;;
;; Group (select lst ind-memb) <VALUE-list> by (select lst ind-grp) <KEY-list>.<br>
;;
;; Result is an assoc-list where each unique <KEY-list> relies to a list of
;; corresponding <VALUE-lists>.
(define (group-by lst ind-grp ind-memb)
  "(group-by lst ind-grp ind-memb) - group sublists of lst into assoc-list with a key of ind-grp and a list of values of ind-memb indices"
  (let (grp '())
    (dolist (l lst)
      (let (g (select l ind-grp) m (select l ind-memb))
        (if (not
              (replace-assoc
                g grp
                (list g (append ($0 1) (list m)))))
          (push (list g (list m)) grp))))
    grp))

;; @syntax (lesser <int>)
;;
;; @return next lesser int value
;;
;; Equivalent to (- <int> 1)
;;
;; Introduced for readability improvement
(define (lesser x) (- x 1))

;; @syntax (greater <int>)
;;
;; @return next greater int value
;;
;; Equivalent to (+ <int> 1)
;;
;; Introduced for readability improvement
(define (greater x) (+ x 1))

;; @syntax  (append-one <lst> <memb>)
;;
;; Append one any element to the end of the list
(define (append-one lst)
  "(append-one lst arg1 arg2 ...)  - append one or more elements to the end of the list"
  (append lst (args)))

;; @syntax (dirname <str-pathname>)
;;
;; @return a directory part of pathname
;;
;; Split pathname by "/" symbol and return all but last element as a string.<br>
;; If directory part is empty, return ".".<br>
;; Return value is not finished by a "/".
(define (dirname f)
  "(dirname pathname) - return directory part of pathname"
  (ifempty (join (chop (parse f "/")) "/") "."))

;; @syntax (strip-end <str> <fin>)
;;
;; Strip the final substring from the end of string
;; Useful for stripping filename extension
;;
;; @example
;; (strip-end "abcd" "cd") => "ab"
;; (strip-end "abcd" "c") => "abcd"
;; (strip-end "somedir/somefile.txt" ".txt") => "somedir/somefile"
(define (strip-end str fin)
  "(strip-end str fin) - strip the fin-string from the end of str"
  (if (ends-with str fin) (chop str (length fin)) str))

;; @syntax (newlisp-version)
;;
;; @return a version string like "newLisp v8.8.0-p0 on linux"
;;
;; ORIGIN<br>
;; Introduced by Sammo on newLISP Fan Club forum.
(define (newlisp-version)
  "(newlisp-version) - return version string"
  (let (OS '("unknown" "linux" "bsd" "osx" "solaris" "cygwin" "win32"
             "win32-Borland" "WinCE" "Tru64Unix")
        FORMAT "newLISP v%s.%s.%s-p%s on %s")
    (apply format (flat (list FORMAT (explode (string ((sys-info) -2)))
                              (OS ((sys-info) -1)))))))

;; @syntax (int10 <str> <int-default>)
;;
;; String to integer on base 10 conversion
;;
;; Converts a string to an integer strictly on base 10 (despite of leading
;; zeroes etc.)
(define (int10 str def)
  "(int10 str [def]) - converts str to int on base 10"
  (int str (if def def 0) 10))

;; @syntax (doc <sym-function>)
;;
;; Prints help on function
;;
;; If function body has a meaningless string value at it's start,
;; it will be returned, otherwise nil is returned.
;;
;; @example
;; (define (foo bar)
;;   "doc test function"
;;   (if bar (bla-bla-bla)
;;           (aaaarrgghhhh)))
;;
;; (doc foo) => "doc test function"

;; ORIGIN<br>
;; Nigel Brown and HPW has introduced this on newLisp forum.
; by nigelbrown & HPW
(define (doc f)
  "(doc f) - display function f's doc string, if present"
  (if (and (or (lambda? f) (macro? f))(string? (nth 1 f)))
      (nth 1 f)
      nil))

;; @syntax (make-k-permutations <k> <multiset>)
;;
;; Make permutation w/o duplicates
;;
;; @param <k> a permutation length >= (length <multiset>)
;; @param <multiset> a list for permutation
;;
;; Warren-Hanson algorithm for generating permutations of multisets.
;;
;; @example
;; (make-k-permutations 2 '(1 2)) => ((2 1) (1 2))

;; ORIGIN<br>
;; Copied from newLisp code snippets
; from newLisp code snippets
(define (make-k-permutations k multiset)
 "(make-k-permutations k multiset) - make permutations w/o duplicates"
 (let ((pivots (unique multiset)))
   (if (= k 1)
      (map list pivots)
      (let ((acc '()))
        (dolist (p pivots)
          (let ((sub-multiset (remove-from-list p multiset)))
            (dolist (sub-perm
                     (make-k-permutations (- k 1) sub-multiset))
              (push (cons p sub-perm) acc))))
        acc))))

;; @syntax (remove-from-list <elt> <lst>)
;;
;; Nondestructive remove element from list
(define (remove-from-list elt lst)
  "(remove-from-list elt lst) - nondestructive remove element from list"
  (let ((elt-pos (find elt lst)))
    (if elt-pos (pop lst elt-pos))
    lst))

;; @syntax (compose <lst> <lst> ...)
;;
;; Inter-compose lists
;;
;; Generate all possible combinations of lists's elements
;; @example
;; (compose '(a b) '(c d) '(e f))
;; =>
;; ((b d f) (b d e) (b c f) (b c e) (a d f) (a d e) (a c f) (a c e))
(define (compose )
  "(compose lst lst ...) - inter-compose lists"
  (let (res '())
   (compose-support (args) '()) res))

(define (compose-support l s)
  (if (empty? l)
   (push s res)
   (dolist (p (l 0))
    (compose-support (1 l) (append s (list p))))))

;; @syntax (++ '<int-a> <int-b>)
;;
;; Increment <int-a> by <int-b>.
;;
;; @param <int-a> can be either a symbol or a value
;;
;; ORIGIN<br>
;; Sammo has introduced this on newLisp forum.
; by Sammo, modified
(define (++ _a01 _b01)
  "(++ 'int-a int-b) - increment int-a by int-b. int-a can be either a symbol or a value"
  (if (symbol? _a01)
    (set _a01 (+ (or (eval _a01) 0) (or (eval _b01) 1)))
    (+ (or (eval _a01) 0) (or (eval _b01) 1))))

;; @syntax (-- '<int-a> <int-b>)
;;
;; Decrement <int-a> by <int-b>.
;;
;; @param <int-a> can be either a symbol or a value
(define (-- _a01 _b01)
  "(-- 'int-a int-b) - decrement int-a by int-b. int-a can be either a symbol or a value"
  (if (symbol? _a01)
    (set _a01 (- (or (eval _a01) 0) (or (eval _b01) 1)))
    (- (or (eval _a01) 0) (or (eval _b01) 1))))

;; @syntax (p++ '<int-a> <int-b>)
;;
;; Post-increment <int-a> by <int-b>.
(define (p++ _a01 _b01)
  "(p++ int-sym int-num) - post-increment int-sym by int-num"
  (let (_old (eval _a01))
    (++ _a01 (or _b01 1))
  _old))

;; @syntax (p-- '<int-a> <int-b>)
;;
;; Post-decrement <int-a> by <int-b>.
(define (p-- _a01 _b01)
  "(p-- int-sym int-num) - post-decrement int-sym by int-num"
  (let (_old (eval _a01))
    (-- _a01 (or _b01 1))
  _old))

;; @syntax (second <lst>)
;;
;; Returns the second element of a list
(define (second lst)
  "(second lst) - returns the second element from a list"
  (lst 1))

(global 'inc-p 'dec-p 'group 'group-all 'group-by 'lesser 'greater
  'append-one 'dirname 'strip-end 'newlisp-version 'int10 'doc
  'make-k-permutations 'remove-from-list 'compose
        '++ '-- 'p++ 'p-- 'second)


========================
 LITTLE SCHEMER LIBRARY
========================

; Nome del file: "_newlisper.lsp"
; Questa libreria contiene tutte le funzioni (finali) definite dal libro
; "Little Schemer" di Friedman e Felleisen convertite in newLISP.

; Per caricare la libreria: (load "_newlisper.lsp")

(define (flat? lst)
  (cond
    ((null? lst) true)
    ((atom? (first lst)) (flat? (rest lst)))
    (true nil)))

(define (member? atm lst)
  (cond
    ((null? lst) nil)
    (true (or (= (first lst) atm)
              (member? atm (rest lst))))))

(define (rember atm lst)
  (cond
    ((null? lst) '())
    ((= (first lst) atm) (rest lst))
    (true (cons (first lst) (rember atm (rest lst))))))

(define (firsts lst)
  (cond
      ((null? lst) '())
      (true (cons (first (first lst)) (firsts (rest lst))))))

(define (firsts2 lst)
  (if (null? lst) '()
    (let (L '())
      (dolist (x lst)
        (cond
            ((null? x) (push '() L))
            ((atom? x) (push x L))
            ((atom? (first x)) (push (first x) L))
            ((list? (first x)) (push (first x) L))
        )
      )
      (reverse L))))

(define (insertR nuovo vecchio lst)
  (cond
    ((null? lst) '())
    (true (cond
            ((= (first lst) vecchio)
                (cons vecchio (cons nuovo (rest lst))))
            (true (cons (first lst) (insertR nuovo vecchio (rest lst))))))))

(define (insertL nuovo vecchio lst)
  (cond
    ((null? lst) '())
    (true (cond
            ((= (first lst) vecchio)
                (cons nuovo (cons vecchio (rest lst))))
            (true (cons (first lst) (insertL nuovo vecchio (rest lst))))))))

(define (subst nuovo vecchio lst)
    (cond
     ((null? lst) '())
     ((= (first lst) vecchio) (cons nuovo (rest lst)))
     (true (cons (first lst) (subst nuovo vecchio (rest lst))))))

(define (subst2 nuovo vecchio1 vecchio2 lst)
    (cond
      ((null? lst) '())
      ((or (= (first lst) vecchio1) (= (first lst) vecchio2))
       (cons nuovo (rest lst)))
      (true (cons (first lst) (subst2 nuovo vecchio1 vecchio2 (rest lst))))))

(define (multirember atm lst)
  (cond
    ((null? lst) '())
    ((= (first lst) atm) (multirember atm (rest lst)))
    (true (cons (first lst) (multirember atm (rest lst))))
  )
)

(define (multiinsertR nuovo vecchio lst)
    (cond
     ((null? lst) '())
     ((= (first lst) vecchio) (cons vecchio (cons nuovo (multiinsertR nuovo vecchio (rest lst)))))
     (true (cons (first lst) (multiinsertR nuovo vecchio (rest lst))))))

(define (multiinsertL nuovo vecchio lst)
    (cond
     ((null? lst) '())
     ((= (first lst) vecchio) (cons nuovo (cons vecchio (multiinsertL nuovo vecchio (rest lst)))))
     (true (cons (first lst) (multiinsertL nuovo vecchio (rest lst))))))

(define (multisubst nuovo vecchio lst)
    (cond
     ((null? lst) '())
     ((= (first lst) vecchio) (cons nuovo (multisubst nuovo vecchio (rest lst))))
     (true (cons (first lst) (multisubst nuovo vecchio (rest lst))))))

(define (add1 n) (++ n))

(define (sub1 n) (-- n))

(define (o+ n m)
    (cond
     ((zero? m) n)
     (true (add1 (o+ n (sub1 m))))))

(define (o- n m)
    (cond
     ((zero? m) n)
     (true (sub1 (o- n (sub1 m))))))

(define (addtup tup)
    (cond
     ((null? tup) 0)
     (true (o+ (first tup) (addtup (rest tup))))))

(define (o* n m)
    (cond
     ((zero? m) 0)
     (true (o+ n (o* n (sub1 m))))))

(define (tup+ tup1 tup2)
    (cond
     ((null? tup1) tup2)
     ((null? tup2) tup1)
     (true (cons (o+ (first tup1) (first tup2))
             (tup+ (rest tup1) (rest tup2))))))

(define (o> n m)
    (cond
     ((zero? n) nil)
     ((zero? m) true)
     (true (o> (sub1 n) (sub1 m)))))

(define (o< n m)
    (cond
     ((zero? m) nil)
     ((zero? n) true)
     (true (o< (sub1 n) (sub1 m)))))

(define (o= n m)
    (cond
     ((o> n m) nil)
     ((o< n m) nil)
     (else true)))

(define (oexpt n m)
    (cond
     ((zero? m) 1)
     (true (o* n (oexpt n (sub1 m))))))

(define (oquotient n m)
    (cond
     ((o< n m) 0)
     (true (add1 (oquotient (o- n m) m)))))

(define (length- lst)
    (cond
     ((null? lst) 0)
     (true (add1 (length- (rest lst))))))

(define (pick n lst)
    (cond
     ((zero? (sub1 n)) (first lst))
     (true (pick (sub1 n) (rest lst)))))

(define (rempick n lst)
    (cond
     ((zero? (sub1 n)) (rest lst))
     (true (cons (first lst) (rempick (sub1 n) (rest lst))))))

(define (no-nums lst)
    (cond
     ((null? lst) '())
     (true
      (cond
       ((number? (first lst)) (no-nums (rest lst)))
       (true (cons (first lst) (no-nums (rest lst))))))))

(define (all-nums lst)
    (cond
     ((null? lst) '())
     ((number? (first lst)) (cons (first lst) (all-nums (rest lst))))
     (true (all-nums (rest lst)))))

(define (eqan? a1 a2)
    (cond
     ((and (number? a1) (number? a2)) (o= a1 a2))
     ((and (number? a1) (number? a2)) (o= a1 a2))
     ((or (number? a1) (number? a2) nil))
     (true (= a1 a2))))

(define (occur a lst)
    (cond
     ((null? lst) 0)
     ((= (first lst) a) (add1 (occur a (rest lst))))
     (true (occur a (rest lst)))))

(define (one? n) (= n 1))

(define (rempick n lst)
    (cond
     ((one? n) (rest lst))
     (true (cons (first lst) (rempick (sub1 n) (rest lst))))))

(define (rember* a S)
    (cond
     ((null? S) '())
     ((atom? (first S))
      (cond
       ((= (first S) a) (rember* a (rest S)))
       (true (cons (first S) (rember* a (rest S))))))
     (true (cons (rember* a (first S)) (rember* a (rest S))))))

(define (insertR* nuovo vecchio S)
    (cond
     ((null? S) '())
     ((atom? (first S))
      (cond
       ((= (first S) vecchio) (cons vecchio (cons nuovo (insertR* nuovo vecchio (rest S)))))
       (true (cons (first S) (insertR* nuovo vecchio (rest S))))))
     (true (cons (insertR* nuovo vecchio (first S)) (insertR* nuovo vecchio (rest S))))))

(define (occur* a S)
    (cond
     ((null? S) 0)
     ((atom? (first S))
      (cond
       ((= (first S) a) (add1 (occur* a (rest S))))
       (true (occur* a (rest S)))))
     (true (o+ (occur* a (first S)) (occur* a (rest S))))))

(define (subst* nuovo vecchio S)
    (cond
     ((null? S) '())
     ((atom? (first S))
      (cond
       ((= (first S) vecchio) (cons nuovo (subst* nuovo vecchio (rest S))))
       (true (cons (first S) (subst* nuovo vecchio (rest S))))))
     (true (cons (subst* nuovo vecchio (first S)) (subst* nuovo vecchio (rest S))))))

(define (insertL* nuovo vecchio S)
    (cond
     ((null? S) '())
     ((atom? (first S))
      (cond
       ((= (first S) vecchio) (cons nuovo (cons vecchio (insertL* nuovo vecchio (rest S)))))
       (true (cons (first S) (insertL* nuovo vecchio (rest S))))))
     (true (cons (insertL* nuovo vecchio (first S)) (insertL* nuovo vecchio (rest S))))))

(define (member* a S)
    (cond
     ((null? S) nil)
     ((atom? (first S))
      (or (= (first S) a) (member* a (rest S))))
     (true (or (member* a (first S)) (member* a (rest S))))))

(define (leftmost S)
    (cond
     ((atom? S) S)
     (true (leftmost (first S)))))

(define (eqan? a1 a2)
    (cond
     ((and (number? a1) (number? a2)) (= a1 a2))
     ((or (number? a1) (number? a2) nil))
     (true (= a1 a2))))

(define (equal? s1 s2)
    (cond
     ((and (atom? s1) (atom? s2)) (eqan? s1 s2))
     ((or (atom? s1) (atom? s2)) nil)
     (true (eqlist? s1 s2))))

(define (eqlist? lst1 lst2)
    (cond
     ((and (null? lst1) (null? lst2)) true)
     ((or (null? lst1) (null? lst2)) nil)
     (true
      (and (equal? (first lst1) (first lst2))
           (eqlist? (rest lst1) (rest lst2))))))

(define (rember S lst)
    (cond
     ((null? lst) '())
     ((equal? (first lst) S) (rest lst))
     (true
      (cons (first lst)
        (rember S (rest lst))))))

(define (numbered? aexp)
    (cond
     ((atom? aexp) (number? aexp))
     (true
      (and (numbered? (first aexp))
           (numbered? (first (rest (rest aexp))))))))

(define (value nexp)
    (cond
     ((atom? nexp) nexp)
     ((= (first (rest nexp)) 'o+)
      (o+ (value (first nexp))
          (value (first (rest (rest nexp))))))
     ((= (first (rest nexp)) 'o*)
      (o* (value (first nexp))
          (value (first (rest (rest nexp))))))
     (true
      (oexpt (value (first nexp))
             (value (first (rest (rest nexp))))))))

(define (first-sub-exp aexp)
    (first (rest aexp)))

(define (second-sub-exp aexp)
    (first (rest (rest aexp))))

(define (operator aexp)
    (first aexp))

(define (value nexp)
    (cond
     ((atom? nexp) nexp)
     ((= (operator nexp) 'o+)
      (o+ (value (first-sub-exp nexp))
          (value (second-sub-exp nexp))))
     ((= (operator nexp) 'o*)
      (o* (value (first-sub-exp nexp))
          (value (second-sub-exp nexp))))
     (true
      (oexpt (value (first-sub-exp nexp))
             (value (second-sub-exp nexp))))))

(define (first-sub-exp aexp)
    (first aexp))

(define (operator aexp)
    (first (rest aexp)))

(define (sero? n) (null? n))

(define (edd1 n)  (cons '() n))

(define (zub1 n) (rest n))

(define (o+ n m)
    (cond
     ((sero? m) n)
     (true (edd1 (o+ n (zub1 m))))))

(define (lat? lst)
  (cond
    ((null? lst) true)
    ((atom? (first lst)) (lat? (rest lst)))
    (true nil)))

(define (set? lat)
    (cond
     ((null? lat) true)
     ((member? (first lat) (rest lat)) nil)
     (true (set? (rest lat)))))

(define (makeset lat)
    (cond
     ((null? lat) '())
     (true (cons (first lat)
             (makeset
              (multirember (first lat) (rest lat)))))))

(define (subset? s1 s2)
    (cond
     ((null? s1) true)
     (true
      (and (member? (first s1) s2) (subset? (rest s1) s2)))))

(define (eqset? set1 set2)
    (and (subset? set1 set2) (subset? set2 set1)))

(define (intersect? set1 set2)
    (cond
     ((null? set1) nil)
     (true (or (member? (first set1) set2)
               (intersect? (rest set1) set2)))))

(define (intersects set1 set2)
    (cond
     ((null? set1) '())
     ((member? (first set1) set2)
      (cons (first set1) (intersects (rest set1) set2)))
     (true (intersects (rest set1) set2))))

(define (unions set1 set2)
    (cond
     ((null? set1) set2)
     ((member? (first set1) set2) (unions (rest set1) set2))
     (true (cons (first set1) (unions (rest set1) set2)))))

(define (differences  set1 set2)
    (cond
     ((null? set1) '())
     ((member? (first set1) set2) (differences (rest set1) set2))
     (true (cons (first set1) (differences (rest set1) set2)))))

(define (intersectall l-set)
    (cond
     ((null? (rest l-set)) (first l-set))
     (true (intersect (first l-set) (intersectall (rest l-set))))))

(define (a-pair? l)
    (cond
     ((atom? l) nil)
     ((null? l) nil)
     ((null? (rest l)) nil)
     ((null? (rest (rest l))) true)
     (true nil)))

(define (firstp p) (first p))

(define (secondp p) (first (rest p)))

(define (build s1 s2) (cons s1 (cons s2 '())))

(define (thirdp l) (first (rest (rest l))))

(define (fun? rel) (set? (firsts rel)))

(define (revrel rel)
    (cond
     ((null? rel) '())
     (true (cons (build (secondp (first rel))
                        (firstp (first rel)))
             (revrel (rest rel))))))

(define (revrel rel)
    (cond
     ((null? rel) '())
     (true (cons (cons (first (rest (first rel)))
                   (cons (first (first rel)) '()))
             (revrel (rest rel))))))

(define (revpair p)
    (build (secondp p) (first p)))

(define (revrel rel)
    (cond
     ((null? rel) '())
     (true (cons (revpair (first rel))
             (revrel (rest rel))))))

(define (seconds s)
    (cond
     ((null? s) '())
     (true (cons (first (rest (first s)))
             (seconds (rest s))))))

(define (fullfun? fun)
    (set? (seconds fun)))

(define (one-to-one? fun)
    (fun? (revrel fun)))

'library-schemer-loaded


=====================
 MESSAGE-BOX LIBRARY
=====================

L'autore di questa libreria "message-box.lsp" è Dexter Santucci.
La libreria è reperibile all'indirizzo:

https://github.com/DexterLagan/newlisp-message-box

;; @module message-box.lsp
;; @description Definitions and a function to display message boxes on Windows
;; @version 1.0 - comments redone for automatic documentation
;; @author Dexter Santucci 2018
;; <h3>Definitions and a function to display message boxes on Windows</h3>
;; This module is platform-specific (Windows)
;; 
;; Before using the module it must be loaded:
;; <pre>
;; (load "C:\Program Files (x86)/newlisp/modules/message-box.lsp")
;; ; or shorter
;; (module "message-box.lsp")
;; </pre>

(context 'win-message-box)

;;; imports

(import "user32.dll" "MessageBoxA")

;;; defs

; message box types
(constant 'MB_ABORTRETRYIGNORE  	  0x00000002) ; The message box contains three push buttons: Abort, Retry, and Ignore.
(constant 'MB_CANCELTRYCONTINUE 	  0x00000006) ; The message box contains three push buttons: Cancel, Try Again, Continue. Use this message box type instead of MB_ABORTRETRYIGNORE. 
(constant 'MB_HELP              	  0x00004000) ; Adds a Help button to the message box. When the user clicks the Help button or presses F1, the system sends a WM_HELP message to the owner. 
(constant 'MB_OK             	 	    0x00000000) ; The message box contains one push button: OK. This is the default. 
(constant 'MB_OKCANCEL 		 	        0x00000001) ; The message box contains two push buttons: OK and Cancel. 
(constant 'MB_RETRYCANCEL 	 	      0x00000005) ; The message box contains two push buttons: Retry and Cancel. 
(constant 'MB_YESNO 		 	          0x00000004) ; The message box contains two push buttons: Yes and No. 
(constant 'MB_YESNOCANCEL 	 	      0x00000003) ; The message box contains three push buttons: Yes, No, and Cancel. 

; message box icons
(constant 'MB_ICONEXCLAMATION 	    0x00000030) ; An exclamation-point icon appears in the message box.
(constant 'MB_ICONWARNING 	 	      0x00000030) ; An exclamation-point icon appears in the message box.  
(constant 'MB_ICONINFORMATION 	    0x00000040) ; An icon consisting of a lowercase letter i in a circle appears in the message box.  
(constant 'MB_ICONASTERISK 	 	      0x00000040) ; An icon consisting of a lowercase letter i in a circle appears in the message box. 
(constant 'MB_ICONQUESTION 	 	      0x00000020) ; A question-mark icon appears in the message box. 
(constant 'MB_ICONSTOP 		 	        0x00000010) ; A stop-sign icon appears in the message box.
(constant 'MB_ICONERROR 		        0x00000010) ; A stop-sign icon appears in the message box.
(constant 'MB_ICONHAND 		 	        0x00000010) ; A stop-sign icon appears in the message box. 

; message box default button specification
(constant 'MB_DEFBUTTON1 	 	        0x00000000) ; The first button is the default button. MB_DEFBUTTON1 is the default unless another is specified.
(constant 'MB_DEFBUTTON2 	 	        0x00000100) ; he second button is the default button.
(constant 'MB_DEFBUTTON3 	 	        0x00000200) ; The third button is the default button.
(constant 'MB_DEFBUTTON4 	 	        0x00000300) ; The fourth button is the default button.

; message box modality
(constant 'MB_APPLMODAL 		        0x00000000) ; The user must respond to the message box before continuing work in the window (hWnd parameter).
(constant 'MB_SYSTEMMODAL 	 	      0x00001000) ; Same as MB_APPLMODAL except that the message box has the WS_EX_TOPMOST style.
(constant 'MB_TASKMODAL 		        0x00002000) ; Same as MB_APPLMODAL except that all the top-level windows belonging to the current thread are disabled if the hWnd parameter is NULL.

; message box other options
(constant 'MB_DEFAULT_DESKTOP_ONLY 	0x00020000) ; If the current input desktop is not the default desktop, MessageBox does not return until the user switches to the default desktop.
(constant 'MB_RIGHT 			          0x00080000) ; The text is right-justified.
(constant 'MB_RTLREADING 		        0x00100000) ; Displays message and caption text using right-to-left reading order on Hebrew and Arabic systems.
(constant 'MB_SETFOREGROUND 		    0x00010000) ; The message box becomes the foreground window.
(constant 'MB_TOPMOST 			        0x00040000) ; The message box is created with the WS_EX_TOPMOST window style.
(constant 'MB_SERVICE_NOTIFICATION 	0x00200000) ; The caller is a service notifying the user of an event. If this flag is set, the hWnd parameter must be NULL.

; message box return values
(constant 'IDOK				1)
(constant 'IDCANCEL 	2)
(constant 'IDABORT 		3)
(constant 'IDRETRY		4)
(constant 'IDIGNORE 	5)
(constant 'IDYES			6)
(constant 'IDNO				7)
(constant 'IDTRYAGAIN	10)
(constant 'IDCONTINUE 11)

;; @syntax (win-message-box:show <title> <message> <flags>)
;; @return The message box return value.
;;
;; Displays a message box matching the given <title> <message> and <flags>.
;; @example
;; (setq result (win-message-box:show "My Title" "Please select something:" (+ win-message-box:MB_CANCELTRYCONTINUE)))
;;
;; @example
;; (define appname "My Program")
;; (define result (win-message-box:show appname "Please select something:" (+ win-message-box:MB_CANCELTRYCONTINUE)))
;; (case result
;;    (1          (win-message-box:show appname "You clicked on OK."        win-message-box:MB_OK))
;;    (2          (win-message-box:show appname "You clicked on Cancel."    win-message-box:MB_OK))
;;    (10         (win-message-box:show appname "You clicked on Try Again." win-message-box:MB_OK))
;;    (11         (win-message-box:show appname "You clicked on Continue."  win-message-box:MB_OK))
;;    (true       (win-message-box:show appname (append "You clicked on ID: " (string result)) win-message-box:MB_OK)))
;; @example
;; (setq result (win-message-box:show "Test" "Select:" 
;;              (+ win-message-box:MB_SETFOREGROUND 
;;               win-message-box:MB_CANCELTRYCONTINUE 
;;               win-message-box:MB_ICONQUESTION 
;;               win-message-box:MB_DEFBUTTON3))
(define (show title message flags)
  (int (MessageBoxA 0 message title flags)))

; EOF

=============================================================================

===============

 NOTE LIBERE 1

===============

---------------
Perchè newLISP?
---------------

LISP è uno dei linguaggi di programmazione più antichi del mondo, risalente agli anni '50 (progettato da John MacCarthy e sviluppato da Steve Russel nel 1958). Sorprendentemente è sopravvissuto fino ai giorni nostri, ed è ancora vivo e vegeto, anche dopo la nascita di nuovi linguaggi come Python, Ruby o Julia. newLISP è una versione di LISP rivolta principalmente allo scripting, ma in grado di realizzare anche programmi completi. Ecco le principali caratteristiche del linguaggio:

- facile da installare
- veloce
- open-source
- multipiattaforma
- librerie integrate
- espandibile con moduli e shared C-library
- compatibile con il web
- documentazione ottima

Inoltre, infastidisce i puristi del LISP, ed è spesso una buona cosa sfidare lo status quo.
Il creatore del linguaggio è Lutz Mueller (Don Lucio) e la seguente è la cronologia delle release:

Version Year  Changes and Additions
1.0     1991  First version running on Sun4 with SunOS/BSD 4.1
1.3     1993  Windows 3.0 Win16 version released on Compuserve
2.11    1994  Windows 3.0 Win16
3.0     1995  Windows 95 Win32 version
6.0     1999  Open Source UNIX multi platform, licensed GPL
6.3     2001  newLISP-tk Tcl/Tk IDE
6.5.8   2002  PCRE regular expressions
7.1-4   2003  Mac OS X and Solaris support. PDF manual, catch and throw, context variables, Win32 DLL
8.0-3   2004  Arrays, UTF-8 support, forked processes, semaphores, shared memory, default function
8.4-7   2005  Implicit indexing, comma locales, signals and timers, net-eval distributed computing
8.8-9   2006  Prolog-like unify, macro-like variable expansion, more implicit indexing support
9.0     2006  64-bit arithmetic and file support, more array functions, HTTP server mode
9.1     2007  Full 64-bit compile flavor, HTTP/CGI server mode, functors in ref, ref-all, find, replace
9.2     2007  newLISP-GS a Java based GUI library for writing platform independent user interfaces in newLISP
9.3     2008  FOOP – Functional Object Oriented Programming
9.4     2008  Cilk - multiprocessing API implemented in newLISP
10.0    2009  General API cleanup, reference passing, new unified destructive API with setf
10.1    2009  Actor messaging API on Mac OS X, Linux and other UNIX
10.2    2010  FOOP redone with Mutable Objects
10.3    2011  Switchable Internet Protocol between IPv4 and IPv6
10.4    2012  Rewritten message queue interface and extended import API using libffi
10.5    2013  Unlimited precision, integer arithmetic
10.5.2  2013  KMEANS cluster analysis
10.5.7  2014  newLISP in a web browser compiled to JavaScript with good performance
10.6.0  2014  native expansion macro function
10.6.2  2015  minor new functionality
10.7.0  2016  minor new functionality
10.7.1  2017  minor new functionality
10.7.5  2019  minor new functionality and fixed bugs

Indirizzi web:
Home: http://www.newlisp.org
Forum: http://www.newlispfanclub.alh.net/forum/

newLisp ha una sintassi semplice, ma una semantica potente e la sua natura interattiva supporta la prototipazione rapida e incoraggia gli utenti a esplorare e testare soluzioni ai problemi in modo incrementale.

newLISP è un linguaggio di tipo LISP-1, cioè le funzioni e le variabili si trovano nello stesso spazio di nomi (come Scheme). Invece il Common Lisp è un linguaggio di tipo LISP-2, dove le funzioni e le variabili si trovano su due spazi di nomi differenti.


--------------
newLISP facile
--------------

In newLISP tutto è una lista (o s-expression).
Una lista è un insieme di elementi racchiusi da parentesi tonde "(" ")".
Gli elementi di una lista possono essere un'altra lista.
Il primo elemento della lista è "speciale" (funzione).
Il resto della lista sono "normali" (argomenti).
Tutte le liste vengono valutate tranne quelle quotate.

------------------
Apprendere newLISP
------------------

"Alcune considerazioni generali sull'apprendimento della programmazione in newLISP:

Non c'è un "sotto" in newLISP, nessuno stato nascosto, (quasi) tutto è visibile e può essere ispezionato. È possibile utilizzare la funzione "debug" per scorrere attraverso 'define-macro's. Queste non sono macro di espansione compilate come in Common LISP, ma piuttosto fexprs - funzioni senza valutazione automatica dei loro argomenti. Kazimir discute di fexprs in modo più dettagliato sul suo sito.

Non credo sia una buona idea, ad esempio, provare a implementare un "foreach" in newLISP. Ci sono altre funzioni integrate che fanno lo stesso o simili e senza l'overhead di una definizione di funzione / fexpr. Come "map". Kazimir ha semplicemente definito "foreach" come "map".

Non provare a programmare come Common Lisp o Scheme in newLISP. Queste sono linguaggi diversi. Prova a imparare newLISP studiando ed utilizzando le funzioni integrate. Il "nuovo" in newLISP significa una nuova mentalità di programmazione: un approccio Lisp con una mentalità orientata allo scripting di applicazioni, non con una mentalità da Computer Science come sviluppata in Scheme o con una mentalità rivolta alla compilazione del linguaggio come in Common Lisp.

L'introduzione di Cormullion nel WikiBooks è un modo eccellente per imparare nuove LISP. Se si desidera lavorare seriamente in newLISP, è necessario leggere almeno una volta il "Manuale d'uso e riferimento". Ha molti esempi. C'è anche una sezione che raggruppa tutte le funzioni in diverse aree dei problemi. Questo ti aiuterà a scoprire quali funzioni sono già integrate in newLISP.

A volte penso che sarebbe utile avere una "Guida di stile" che definisca determinate convenzioni su come utilizzare il set di funzionalità di newLISP. Poi, pensandoci di nuovo, penso che sarebbe una brutta cosa. Uno dei motivi per cui molti utenti sono attratti da newLISP è la sua malleabilità e flessibilità, che è anche la ragione per cui così tante persone provenienti da professioni creative utilizzano newLISP.

newLISP ti dà la libertà di esprimere la stessa funzionalità in modi e stili diversi, senza costringerti in un "modo giusto" di fare le cose.

Ma sicuramente, ci sono convenzioni emergenti dalla comunità. Ad esempio, racchiudere le macro nel proprio spazio dei nomi è una convenzione adottata spesso."

Lutz

--------------------------
Commentare righe di codice
--------------------------

Per commentare una singola riga utilizzare il carattere ";" ad inizio riga:

;  (println 1 { })

Per commentare una sezione di codice (gruppo di righe) racchiudere la sezione con le parole "[text]" e "[/text]":

[text]
  (print 3 { })
  (print 4 { })
[/text]

(define (test)
;  (println 1 { })
  (print 2 { })
  [text]
  (print 3 { })
  (print 4 { })
  [/text]
  (println 5 { })
)

(test)
;-> 2 5

Questo metodo è molto comodo quando dobbiamo commentare una grande quantità di codice.

Per commentare una sezione di codice (gruppo di righe) possiamo anche racchiudere la sezione con i caratteri "{" e "}"

(define (test1)
;  (println 1 { })
  (print 2 { })
{
  (print 3 { })
  (print 4 { })
}
  (println 5 { })
)

(test1)
;-> 2 5

Il risultato è corretto, ma perdiamo il match visivo con le parentesi "{" "}" che si trovano nella sezione commentata. Per risolvere il problema usiamo il carattere doppio apice al posto delle parentesi graffe.

(define (test2)
;  (println 1 " ")
  (print 2 " ")
{
  (print 3 " ")
  (print 4 " ")
}
  (println 5 " ")
)


------------------------
Stile del codice newLISP
------------------------

Ogni linguaggio ha un proprio stile generale nella scrittura el codice. Comunque anche ogni programmatore ha uno stile proprio che deriva dalla sua esperienza. Fortunatamente newLISP permette di scrivere con stili diversi basta che si rispetti la sintassi delle liste (parentesi).
Lo stile non è uno standard, ma solo il modo preferito di scrivere e leggere i programmi. Il problema nasce quando diversi programmatori lavorano sullo stesso codice. In questo caso occorrono delle regole comuni per evitare di avere stili diversi nello stesso programma. Poichè newLISP deriva dal LISP vediamo quali indicazioni vengono raccomandate per questo linguaggio (Common LISP) e quanto sono aderenti a newLISP (e comunque sta a voi scegliere quale stile di scittura si adatta di più al vostro modo di programmare).

--- Regole Generali ---

Funzioni di primo ordine
------------------------
Tutte le funzioni di primo ordine devono iniziare dalla colonna 1.

Chiusura parentesi
------------------
Le parentesi chiuse non devono essere precedute dal carattere newline.

Esempio:

;; errato
(define (f x)
  (when (< x 3)
    (++ x)
  )
)

;; corretto
(define (f x)
  (when (< x 3)
    (++ x)))

Nota: questa indicazione può non essere la migliore per newLISP.

Diversi programmatori newLISP si allontanano lentamente dalla regola "newline non deve precedere una parentesi chiusa", per usare lo stile di identazione del linguaggio "C". Non solo per una migliore corrispondenza tra le parentesi, ma anche perché è più facile modificare il codice. Nella funzione seguente:

(define (f x)
  (when (< x 3)
    (++ x)
  )
  (pippo x)
)

è molto più facile eliminare o inserire codice prima o dopo le righe in cui le parentesi di chiusura si trovano su righe diverse. Puoi eliminare o inserire una nuova riga senza preoccuparti molto di distruggere l'equilibrio della parentesi. Questo metodo aiuta a gestire programmi con molto codice e la forma visuale delle parentesi facilita l'individuazione dei blocchi di codice.

Comunque è anche vero che lo stile funzionale genera molte parentesi chiuse alla fine di ogni espressione. Quindi ci sono alcuni casi in cui è preferibile chiudere le parentesi sulla stessa linea.

Esempio:

(define (f x)
  (if (< x 3)
    (++ x)
    (begin (pippo x) (++ x))
  )
)

In questo caso la parentesi che chiude "begin" si trova sulla stessa linea.

Per alcuni, il metodo "parentesi chiuse sulla nuova linea" non deve esse usato perchè la lettura dei programmi LISP non deve seguire la corrispondenza delle parentesi, ma seguire l'indentazione. Inoltre  questo metodo richiede più righe per lo stesso codice. In generale, è bene mantenere basso il numero di righe, in modo che la logica del codice sia contenuta in una pagina (o schermata).

Livello di indentazione
-----------------------
Il livello di indentazione (TAB) dovrebbe essere relativamente piccolo. In genere vengono usati due caratteri spazio per ogni rientro (max 4 caratteri spazio).

Esempio:

;; errato
(define (f x)
    (when (< x 3)
        (++ x)
    )
    (pippo x)
)

;; corretto
(define (f x)
  (when (< x 3)
    (++ x)
  )
  (pippo x)
)

;; corretto
(define (f x)
  (when (< x 3)
    (++ x))
  (pippo x))

Con un livello di indentazione piccolo si diminuisce la lunghezza delle righe del programma.

Nomi delle variabili
--------------------
La convenzione è quella di usare lo stile: "dashed-lower-case-names".
I nomi delle variabili vengono scritti in minuscolo e le parole sono separate dal carattere trattino "-" (hyphens). Non utilizzare il carattere underscore "_".
Non utilizzare lettere maiuscole.

giusto: total-time

sbagliato: total_time oppure Total-Time

Un nome di una variabile o funzione (identificatore) deve essere semplice da capire e da leggere. Non dovrebbe essere troppo lungo, ma è meglio un mome lungo che un nome incomprensibile.

giusto: somma-totale

sbagliato: stot

I nomi che rappresentano collezioni di oggetti (es. liste, vettori) devono avere il carattere "s" alla fine (plurale). Non inserire il tipo dell'oggetto nel nome.

giusto: cars

sbagliato: list-of-car

Le variabili globali devono essere racchiuse dal carattere "*" (earmuffing technique):

*global-value*

La variabili costanti devono essere racchiuse dal carattere "+" (earmuffing technique):

+constant-value+

I predicati (funzioni che restituiscono vero (true) o falso (nil) devono avere il carattere "?" alla fine del nome:

primo?

Commenti
--------
1) Numero di punti e virgola ";" (semicolon)
Un singolo punto e virgola viene utilizzato per un commento relativo a una singola riga di codice e si trova sulla stessa riga del codice, ad esempio:

(if (< x err)     ; se x è minore dell'errore
    (calc x)      ; calcola una funzione
    (prova x))    ; altrimenti prova di nuovo

Nota: La funzione "if" è una forma speciale e segue una indentazione differente: le espressioni che devono essere eseguite (calc x) o (prova x) sono allineate alla condizione (< x err).

Due punti e virgola sono usati per un commento che si riferisce a diverse righe di codice. La riga di commento è allineata con le righe di codice e le precede, in questo modo:

(when (< x 2)
  ;; abbandona tutto e ricomincia
  (setq x 0)
  (prova x))

Tre punti e virgola sono usati per i commenti che descrivono una funzione. Tali commenti iniziano sempre nella colonna 1, in questo modo:

;;; Calcola la quantità di spazio tra i simboli
;;; in una lista di valori interi
(define (calcola-spazi-simboli)
  (map calcola (symbols)))

Quattro punti e virgola sono usati per i commenti che si riferiscono ad un intero file e iniziano sempre dalla colonna 1:

;;;; Libreria per il calcolo con i quaternioni
;;;; Operazioni: +, -, *, /

2) Contenuto dei commenti
Come al solito, cerchiamo di essere brevi, senza perdere il contenuto delle informazioni. Affinché i commenti funzionino con le definizioni, una buona idea è usare la forma imperativa del verbo. In questo modo è possibile evitare espressioni ridondanti come "questa funzione...".

Non scrivere:

;;; Questa funzione calcola lo spazio tra i simboli
;;; in una lista di valori interi
(define (calcola-spazi-simboli)

Invece, scrivere in questo modo:

;;; Calcola la quantità di spazio tra i simboli
;;; in una lista di valori interi
(define (calcola-spazi-simboli)
  (map calcola (symbols)))

In genere i commenti di una funzione includono anche l'elenco e la spiegazione dei parametri di input/output e i limiti di applicazione degli stessi.

Stringhe di documentazione (documentation string)
-------------------------------------------------
Una stringa di documentazione è una stringa di caratteri che appare in predeterminate posizioni  nel codice (es: la prima espressione nel corpo di una funzione).
Le stringhe di documentazione differiscono dai commenti in quanto sono disponibili in fase di esecuzione. Le stringhe di documentazione devono essere brevi e devono essere associate al nome di una particolare funzione, classe, ecc. Non devono dare spiegazioni generali sul funzionamento di una biblioteca o di una applicazione.
La prima frase di una stringa di documentazione (che in genere si trova nella prima riga),
dovrebbe fornire una breve descrizione dell'oggetto (come il titolo di un giornale).
Il testo successivo della stringa di documentazione dovrebbe espandersi nella descrizione di
l'oggetto. Questa parte della stringa di documentazione (nel caso in cui l'oggetto sia una funzione) potrebbe contenere precondizioni, situazioni di errore che potrebbero essere segnalate e possibili comportamenti inaspettato.
In una stringa di documentazione, quando è necessario fare riferimento a argomenti di funzioni, nomi di classi o altri oggetti lisp, questi nomi vengono scritti in maiuscolo, in modo che essi
siano facili da trovare.

Le stringhe di documentazione possono essere estratte automaticamente (ad esempio per la creazione del manuale di riferimento delle funzioni).

Al seguente indirizzo web potete trovare la guida sullo stile LISP raccomandato da Google:

https://google.github.io/styleguide/lispguide.xml

Un altra lettura molto interessante è "Tutorial on Good Lisp Programming Style" di Peter Norvig:

https://www.cs.umd.edu/~nau/cmsc421/norvig-lisp-style.pdf

Nota: i programmatori Lisp esperti leggono e comprendono il codice in base all'indentazione invece che al controllo del livello/numero delle parentesi.

La mia idea è che ognuno deve creare ed affinare con il tempo il proprio stile di programmazione, sia in termini di scrittura che di logica. Inoltre consiglio di studiare i programmi dei programmatori esperti (questo è uno dei metodi migliori per imparare).

Il mio approccio è quello di scrivere in stile C quando sviluppo una funzione. Una volta che la funzione è definitiva, cioè testata e corretta, converto le parentesi in stile Lisp.


---------------------------------------
Considerazioni sulle parentesi del LISP
---------------------------------------

LISP è l'acronimo di LISt Processing, ma spesso i commenti di scherno di alcuni programmatori lo definiscono come:
Lots of (Insipid | Irritating | Infuriating | Idiotic | ...) (Spurious | Stubborn | Superfluous | Silly | ...) Parentheses. In questo modo la sintassi del LISP viene accusata di rendere il codice incompresibile da leggere e impossibile da scrivere senza errori. Credo che queste idee siano completamente sbagliate.

Prima di tutto le parentesi rendono il codice semplice da leggere (se correttamente indentato) e la loro sintassi può essere compresa da chiunque in 30 minuti. L'unico problema potrebbe essere quello del bilanciamento delle parentesi, ma è dal 1970 che gli editor si prendono cura di risolvere visualmente questo problema. La sintassi del C è molto più complessa e intricata.

Per quanto riguarda la semantica, possiamo notare che la sintassi annidabile e regolare del LISP permette di creare sia una semantica ricorsiva annidabile naturale, che una semantica iterativa/gerarchica.

Un altra critica alla sintassi del LISP è quella rendere il linguaggio a "bassa densità di linee di codice": penso che sia vero il contrario, la semantica dei programmi LISP lo compensa in gran parte con la necessità di scrivere molte meno righe di codice per la stessa funzionalità, rendendo la densità complessiva del codice LISP più alta che in qualsiasi altra linguaggio (inoltre il LISP può estendere la propria semantica tramite le macro e la meta-programmazione).

La struttura di programma cresce naturalmente fino a quando non raggiunge la barriera della comprensione umana, ciò che cambia da una linguaggio all'altro non è questa barriera, propria dell'uomo, ma la quantità di cose utili che si possono esprimere all'interno di questa barriera.

Un altro argomento contro la sintassi di Lisp è che le sue parentesi non aiutano a distinguere la semantica all'interno del codice del programma. Questo è vero, ma in LISP le parentesi indicano l'annidamento del codice, ma non le distinzioni semantiche. Ciò non significa che queste distinzioni non possano essere fatte facilmente in LISP tramite l'utilizzo di altri metodi (moduli, simboli,ecc.)

Quanto a ciò che rende necessarie le parentesi, non è una questione di sintassi prefissa opposta alla sinassi infissa: è una questione di arità fissa contro arità variabile. La sintassi prefissa può funzionare completamente senza parentesi, quando si conosce l'arità di ciascun operatore. In realtà, la prima sintassi prefissa sistematica, la famosa Notazione polacca di Jan Lukasiewicz, è stata ideata proprio come un modo per sbarazzarsi del tutto delle parentesi. La variante postfix di questa notazione, nota come notazione polacca inversa (RPN), si trova nel FORTH, nelle calcolatrici HP, nel PostScript e in molte macchine virtuali.
La necessità delle parentesi è dovuta al fatto che LISP ha una sintassi uniforme ed estensibile che deve adattarsi ad un numero arbitrario di argomenti nei moduli del programma. LISP si standardizza su una sintassi generica che è immediatamente leggibile in modo non ambiguo da qualsiasi Lisper anche senza una conoscenza a priori dell'arità di ogni operatore che appare in un dato dominio. LISP consente inoltre agli utenti di estendere il linguaggio attraverso le macro qualora si desideri una sintassi ad-hoc per un dominio specifico. Quindi, ciò che rende necessarie le parentesi è il fatto che la stessa sintassi deve essere estendibile a funzioni e forme variadiche.

Probabilmente queste critiche alle parentesi sono dovute a diversi fattori:
a) l'uso delle parentesi negli altri linguaggi ha un'interpretazione ambigua
b) aspettative di soluzioni per problemi che provengono da altri linguaggi
c) automatica reazione quando si tratta di imparare qualcosa di nuovo e totalmente diverso

Quelli che conoscono bene il LISP si lamentano di tante cose... ma non della sua sintassi. In fondo le parentesi sono l'emozione del LISP come gli spazi bianchi sono l'emozione di Python.

Per quanto mi riguarda ho imparato più facilmente la sintassi del LISP che quella del C. Il timore iniziale delle "parentesi" si è rapidamente trasformato in simpatia e anche dipendenza. Non è stato un "colpo di fulmine", ma si è trasformato in un sentimento profondo :-)
Le parentesi aiutano benissimo ad isolare le espressioni, che quindi possono essere estratte e riposizionate con facilità all'interno del programma. Inoltre occorre ricordare che: "Un programmatore LISP legge il programma dalla sua indentazione, non controllando l'annidamento delle parentesi."

In genere quando si studia un linguaggio di programmazione è meglio attenersi agli idiomi e ai metodi propri del linguaggio. Solo in seguito, una volta acquisita una sufficiente familiarità, si potranno provare nuove strade o implementare le tecniche di altri linguaggi.

"Learn at least one new [programming] language every year. Different languages solve the same problems in different ways. By learning several different approaches, you can help broaden your thinking and avoid getting stuck in a rut." - The Pragmatic Programmers

"Imparare almeno un nuovo linguaggio di programmazione ogni anno. Linguaggi diversi risolvono gli stessi problemi in modi diversi. Imparando diversi approcci, puoi ampliare il tuo pensiero ed evitare rimanere bloccato in un vicolo cieco." - The Pragmatic Programmers

"newLISP is so much like a pile of clay (in a good way ;-), waiting to be formed into whatever the programming potter wishes it to be, that it's better for it to remain faithful to the simple ideas that originated in LISP and stay a pile of clay. Parentheses and all :-)" - michael


---------------------------------------------
Controllare l'output della REPL (prettyprint)
---------------------------------------------

*************************
>>>funzione PRETTY-PRINT
*************************
sintassi: (pretty-print [int-length [str-tab [str-fp-format]])

Riformatta le espressioni per la stampa, il salvataggio o il sorgente e quando si stampa in una console interattiva (REPL). Il primo parametro, int-length, specifica la lunghezza massima della linea e str-tab specifica la stringa utilizzata per indentare le linee. Il terzo parametro str-fp-format descrive il formato predefinito per la stampa di numeri in virgola mobile. Tutti i parametri sono opzionali. pretty-print restituisce le impostazioni correnti o le nuove impostazioni quando vengono specificati i parametri.

(pretty-print)  → (80 " " "%1.15g")  ; default setting

(pretty-print 90 "\t")  → (90 "\t" "%1.15g")

(pretty-print 100)  → (100 "\t" "%1.15g")

(sin 1)    → 0.841470984807897
(pretty-print 80 " " "%1.3f")
(sin 1)    → 0.841

(set 'x 0.0)
x   → 0.000

Il primo esempio riporta le impostazioni predefinite di 80 colonne per la lunghezza massima della linea e uno spazio per il rientro. Il secondo esempio modifica la lunghezza della linea in 90 e il rientro in un carattere TAB. Il terzo esempio modifica solo la lunghezza della linea. L'ultimo esempio modifica il formato predefinito per i numeri in virgola mobile. Ciò è utile quando si stampano numeri in virgola mobile non formattati senza parti frazionarie e questi numeri dovrebbero essere comunque riconoscibili come numeri in virgola mobile. Senza il formato personalizzato, x verrebbe stampato come 0 indistinguibile dal numero in virgola mobile. Sono interessate tutte le situazioni in cui sono stampati numeri in virgola mobile non formattati.

Si noti che pretty-print non può essere utilizzato per impedire la stampa di interruzioni di riga. Per sopprimere completamente la stampa "pretty print", utilizzare la funzione string per convertire l'espressione in una stringa raw non formattata come nell'esempio seguente:

;; print without formatting

(print (string my-expression))

Esempio base:

(pretty-print)
;-> (80 " " "%1.16g")

(pretty-print 70 " " "%1.16g")
;-> (70 " " "%1.16g")


---------------------------
Gestione di file e cartelle
---------------------------

Vediamo alcune funzioni per gestire file e cartelle (folder/directory). Queste funzioni si basano sulle seguenti primitive:

  change-dir      changes to a different drive and directory
  copy-file       copies a file
  delete-file     deletes a file
  directory       returns a list of directory entries
  file-info       gets file size, date, time, and attributes
  make-dir        makes a new directory
  real-path       returns the full path of the relative file path
  remove-dir      removes an empty directory
  rename-file     renames a file or directory

e i predicati "directory?" e "file?".

Vediamo le definizioni del manuale delle funzioni "directory", "directory?" e "file?".

**********************
>>>funzione DIRECTORY
**********************
sintassi: (directory [str-path])
sintassi: (directory str-path str-pattern [regex-option])

Viene restituita una lista di nomi di cartelle per il percorso specificato in str-path. In caso di fallimento, viene restituito nil. Quando str-path viene omesso, viene restituito l'elenco delle cartelle della cartella corrente.

(directory "/ bin")

(directory "c: /")

Il primo esempio restituisce la cartella di / bin, il secondo restituisce una lista di cartelle della cartella  principale (root) dell'unità C:. Notare che sui sistemi MS Windows, è possibile includere una barra (/) nei nomi dei percorsi. Quando viene usata, una barra rovesciata (\) deve essere preceduta da una seconda barra rovesciata (\\).

Nella seconda sintassi, directory può accettare un modello di espressione regolare in str-pattern. Solo i nomi di file che corrispondono al modello verranno restituiti nella lista delle cartelle. In regex-option, possono essere specificate opzioni di espressioni regolari speciali (vedi regex per i dettagli).

(directory "." "\\. c") → ("foo.c" "bar.c")
;; o utilizzando le parentesi graffe come delimitatori del modello di stringa
(directory "." {\ .c}) → ("foo.c" "bar.c")

; mostra solo i file nascosti (che iniziano con il punto)
(directory "." "^ [.]") → ("." ".." ".profile" ".rnd" ".ssh")

L'espressione regolare forza la directory a restituire solo i nomi di file contenenti la stringa ".c".

***********************
>>>funzione DIRECTORY?
***********************
sintassi: (directory? str-path)

Controlla se str-path è una cartella. Restituisce true o nil a seconda del risultato.

(directory? "/etc")
;-> true
(directory? "/usr/local/bin/emacs/")
;-> nil

*****************
>>>funzione FILE?
*****************
syntax: (file? str-path-name [bool])

Verifica l'esistenza di un file in str-name. Restituisce true se il file esiste, in caso contrario, restituisce nil. Questa funzione restituirà true anche per le cartelle. Se il valore facoltativo bool è true, il file non deve essere una cartella e viene restituito str-path-name o nil se il file è una cartella. L'esistenza di un file non implica nulla sulle sue autorizzazioni di lettura o scrittura per l'utente corrente.

(if (file? "afile") (set 'fileNo (open "afile" "read")))

(file? "/usr/local/bin/newlisp" true)
;-> "/usr/local/bin/newlisp"
(file? "/usr/bin/foo" true)
;-> nil
-------------------------------------------------------------------

Per vedere la cartella corrente della REPL di newLISP:

(real-path)
;-> f:\\Lisp-Scheme\\newLisp\\MAX

Per cambiare la cartella corrente della REPL di newLISP:

(change-dir "c:\\util")
;-> true

(change-dir "c:/util")
;-> true

Verifichiamo:

(real-path)
;-> c:\\util

Ritorniamo alla cartella precedente:

(change-dir "f:\\Lisp-Scheme\\newLisp\\MAX")
;-> true

(change-dir "f:/Lisp-Scheme/newLisp/MAX")
;-> true

La funzione "show-tree" mostra tutti i file e le cartelle ricorsivamente a partire da un cartella predefinita:

(define (show-tree dir)
  (dolist (nde (directory dir))
    (if (and (directory? (append dir "/" nde)) (!= nde ".") (!= nde ".."))
          (show-tree (append dir "/" nde))
          (println (append dir "/" nde)))))

(show-tree "f:\\Lisp-Scheme\\newLisp\\MAX")

(show-tree "c:/")

Possiamo anche inserire un contatore per il livello delle cartelle:

(define (show-tree dir counter)
 (dolist (nde (directory dir))
   (if (and (directory? (append dir "/" nde)) (!= nde ".") (!= nde ".."))
        (show-tree (append dir "/" nde) (+ counter 1))
        (println counter ": "(append dir "/" nde)))))

(show-tree "c:/Borland" 0)
;-> 0: c:/Borland/.
;-> 0: c:/Borland/..
;-> 1: c:/Borland/BCC55/.
;-> 1: c:/Borland/BCC55/..
;-> 2: c:/Borland/BCC55/Bin/.
;-> 2: c:/Borland/BCC55/Bin/..
;-> 2: c:/Borland/BCC55/Bin/bcc32.cfg
;-> 2: c:/Borland/BCC55/Bin/bcc32.exe

La funzione primitiva "env" recupera il valore di una variabile d'ambiente del s.o.:

(env "PATH")
;-> "c:\\Program Files (x86)\\Common Files\\..."
(env "USERNAME")
;-> "u42"
(env "PATH")
;-> "c:\\Program Files (x86)\\Common Files\\..."

(env "newLISPDIR")
;-> "C:\\newlisp"
(show-tree (env "newLISPDIR"))

La funzione "show-dir" mostra tutte le cartelle della cartella passata come parametro:

(define (show-dir dir)
  (dolist (nde (directory dir))
    (if (and (directory? (append dir "/" nde)) (!= nde ".") (!= nde ".."))
          (if (directory? (append dir "/" nde))
            (println (append dir "/" nde))))))

(show-dir (env "newLISPDIR"))
(show-dir (real-path))

La funzione "show-file" mostra tutti i file e le cartelle della cartella passata come parametro:

(define (show-file dir)
  (dolist (nde (directory dir))
    (println (append dir "/" nde))))

(show-file (env "newLISPDIR"))
(show-file (real-path))

Per visualizzare/filtrare solo determinati file possiamo usare la funzione seguente:

(filter (fn (f) (ends-with f ".ahk")) (directory))
;-> ("npp-newlisp.ahk" "test.ahk" "_npp-newlisp.ahk" "_vscode.ahk")

(filter (fn (f) (ends-with f ".ahk")) (directory))

Oppure possiamo usare i comandi della shell in due modi:

(exec "dir *.ahk /b")
;-> ("npp-newlisp.ahk" "test.ahk" "_npp-newlisp.ahk" "_vscode.ahk")

(exec "cmd /c dir *.ahk /b")
;-> ("npp-newlisp.ahk" "test.ahk" "_npp-newlisp.ahk" "_vscode.ahk")

Per estrarre il percorso completo di un file:

Unix
(join (chop (parse (real-path "_TODO.txt") "/")) "/")

Windows
(join (chop (parse (real-path "_TODO.txt") "\\")) "\\")
;-> "f:\\Lisp-Scheme\\newLisp\\MAX"

Per creare cartelle (anche annidate) possiamo usare la funzione "makedir":

(define (makedir path)
  (let (old-path (real-path))
        (dolist (p (parse path "/"))
                (make-dir p)
                (change-dir p))
        (change-dir old-path)))

(makedir "one/two/three")
;-> true

Oppure la funzione "mkdirs":

(define (mkdirs path  p)
  (dolist (l (parse path "/"))
    (push l p -1)
    (unless (empty? l) (make-dir (join p "/")))))

(mkdirs "/uno/due/tre")
;-> true

(mkdirs "uno/due/tre")
;-> true

Per cambiare cartella partendo dal percorso di un file:

(define (.. f)
  (join (chop (parse (real-path f) "\\") 2) "\\") )

(define (. f)
  (join (chop (parse (real-path f) "\\") 1) "\\") )

Adesso possiamo cambiare la cartella in due modi:

(change-dir (.. "f:\\Lisp-Scheme\\newLisp\\MAX\\_TODO.txt"))
;-> true
(real-path)
;-> "f:\\Lisp-Scheme\\newLisp"

(change-dir (. "f:\\Lisp-Scheme\\newLisp\\MAX\\_TODO.txt"))
;-> true
(real-path)
;-> "f:\\Lisp-Scheme\\newLisp\\MAX"

Per verificare se una cartella è vuota:

(define (empty-dir? path-to-check)
  (empty? (clean (lambda (x) (or (= "." x) (= ".." x))) (directory path-to-check)))
)

Per verificare se un file esiste all'interno della cartella corrente:

(define (file-exists? file bool) (file? file bool))

(file-exists? "_TODO.txt")
;-> true
(file-exists? "O.txt")
;-> nil
(file-exists? "_TODO.txt" true)
;-> "_TODO.txt"

Per verificare se una cartella esiste all'interno della cartella corrente:

(define (directory-exists? folder) (directory? folder bool))

(directory-exists? "newLISP-Note")
;-> true
(directory-exists? "newLISP-No")
;-> nil
(directory-exists? "MAX")
;-> nil

Per ottenere informazioni su un file o su una cartella usiamo la funzione primitiva "file-info".

**********************
>>>funzione FILE-INFO
**********************
sintassi: (file-info str-name [int-index [bool-flag]])

Restituisce una lista di informazioni sul file o sulla cartella in str_name. L'indice facoltativo int-index specifica il membro della lista da restituire. Quando non viene specificato alcun bool-flag o quando il bool-flag vale nil, vengono restituite informazioni sul collegamento se il file è un collegamento a un file originale. Se bool-flag è diverso da nil, allora vengono restituite le informazioni sul file originale a cui fa riferimento il collegamento.

Offset  Contents
------  --------
  0     size
  1     mode (differs with true flag)
  2     device mode
  3     user ID
  4     group ID
  5     access time
  6     modification time
  7     status change time

A seconda del flag di bool impostato, la funzione riporta sul collegamento (nessun flag o flag nil) o sul file collegato originale (flag vero).

(file-info ".bashrc")
;-> (124 33188 0 500 0 920951022 920951022 920953074)

(file-info ".bashrc" 0)
;-> 124

Nel secondo esempio, viene recuperata l'ultima data di modifica dello stato per la cartella /etc.

file-info fornisce le statistiche del file (dimensione) per un file collegato, non il collegamento, ad eccezione per il campo mode.

(date (file-info "_TODO.txt" 7))
;-> "Wed May 08 17:07:39 2020"

Comandi shell
-------------
Se un ! (punto esclamativo) viene inserito come primo carattere sulla riga di comando seguito da un comando di shell, il comando verrà eseguito. Ad esempio, !ls su Unix o !dir su MS Windows mostrerà un elenco della cartella di lavoro corrente. Non sono consentiti spazi tra il ! e il comando della shell. Simboli che iniziano con ! sono ancora consentiti all'interno delle espressioni o sulla riga di comando se preceduti da uno spazio. Nota: questa modalità funziona solo quando è in esecuzione nella shell e non funziona quando si controlla newLISP da un'altra applicazione.

Per uscire dalla shell newLISP su Linux/Unix, premere Ctrl-D. Su MS Windows, digita (esci) o Ctrl-C, quindi il tasto x.

Utilizzare la funzione exec per accedere ai comandi della shell da altre applicazioni o per passare i risultati a newLISP.
Ad esempio, per creare una lista con tutti i file PDF della cartella corrente basta eseguire:

(setq pdfs (exec "dir *.pdf /B /On"))
;-> ("newLISP.pdf" "test.pdf" "nr.pdf")


-------------------
Funzioni come liste
-------------------

Definiamo una funzione che somma due numeri:

(define (somma a b) (add a b))
;-> (lambda (a b) (add a b))

La variabile "somma" contiene la definizione (come lista) della funzione lambda:

somma
;-> (lambda (a b) (add a b))

La funzione viene restituita come lista:
(list? somma)
;-> true

Ma è anche una funzione lambda:
(lambda? somma)
;-> true

Quindi una funzione lambda può essere trattata come una lista.
Vediamo i parametri della funzione:

(first somma)
;-> (a b)

Vediamo il corpo della funzione:
(last somma)
;-> (add a b)

Modifichiamo la funzione in modo che calcoli la differenza invece che la somma delle variabili a e b:
(setf (first (last somma)) 'sub)
;-> sub

Controlliamo la modifica:
somma
;-> (lambda (a b) (sub a b))

Eseguiamo la funzione somma:
(somma 6 2)
;-> 4 ; abbiamo ottenuto la differenza

Mi piace questo aspetto del linguaggio: automodificante.

Nota: La funzione "define" è solo "syntactic sugar". Infatti le seguenti espressioni sono equivalenti:

(define (somma a b) (add a b))
;-> (lambda (a b) (add a b))

(setq somma '(lambda (a b) (add a b)))
;-> (lambda (a b) (add a b))

Definiamo la funzione "getdef" che prende come parametro il nome di una funzione utente e restituisce (come lista) la definizione lambda della funzione:

(define (getdef func) (if (lambda? func) func nil))

(getdef somma)
;-> (lambda (a b) (+ a b))

(getdef pow)
;-> nil

Adesso definiamo la funzione "funcall" che esegue la funzione passata.

(define (funcall func) (eval (func (args))))

I parametri di funcall non devono essere valutati quando viene chiamata, quindi quotiamo il parametro (lista) "func":

(funcall '(somma 10 20))
;-> 30

(funcall '(somma (somma 10 20) 6))
;-> 36

(funcall '(sin 12))
;-> -0.5365729180004349

Nota: Le parole chiave "lambda" e "fn" incorporate come attributi di una liste e non sono simboli, per esempio:

(first (lambda (x) (+ x x)))
;-> (x) ; non lambda

Quando abbiamo una funzione (o una macro) del tipo:

(define (double x) (+ x x))
;-> (lambda (x) (+ x x))

Possiamo accedere facilamente al corpo della funzione (o della macro):

(last double)
;-> (+ x x)

e modificarlo:

(setf (last double) '(+ x x x))
;-> (+ x x x)

double
;-> (lambda (x) (+ x x x))

Eseguendo la funzione viene eseguito il nuovo corpo della funzione:

(double 3)
;-> 9

Il corpo di una funzione è sempre accessibile ed è un oggetto di prima classe (ordine) in newLISP. In Common LISP o Scheme dopo la valutazione delle funzioni e delle macro (define/defun/lambda/) le espressioni che definiscono le funzioni/macro non sono più accessibili e le parole chiave "lambda" o "macro" sono dei simboli come "print", "map", ecc.
In newLISP la parola "lambda" individua un tipo speciale di lista: la "lambda list". Possiamo utilizzare "cons" su di essa o "append" ad essa e valuta su se stessa.
Le macro funzionano in modo molto diverso in newLISP rispetto al Common LISP o Scheme.

Questo è uno dei motivi per cui mi piace newLISP.


----------
4-4 Puzzle
----------

Definire i seguenti numeri:

  zero, uno, due, tre quattro, cinque, sei, sette, otto, nove

utilizzando per ogni numero una espressione matematica che contiene quattro volte il numero 4.
L'espressione può contenere: + add , - sub , * mul , / div , (), separatore decimale, potenza, radice quadrata, fattoriale e numero periodico (es. .4~ = .444444444444444...)

0 - (setq zero (- 44 44))
0 - (setq zero (+ 4 4 (- 4) (- 4)))
0 - (setq zero (+ 4 4 (- (+ 4 4))))
1 - (setq one (/ 44 44))
1 - (setq one (+ (/ 4 4) (- 4 4)))
1 - (setq one (+ (/ 4 4) (+ 4 (- 4))))
2 - (setq due (/ (* 4 4) (+ 4 4)))
2 - (setq due (+ (/ 4 4) (/ 4 4)))
2 - (setq due (- 4 (/ (+ 4 4) 4)))
3 - (setq tre (/ (+ 4 4 4) 4))
4 - (setq quattro (+ 4 (* 4 (- 4 4))))
5 - (setq cinque (/ (+ 4 (* 4 4)) 4))
6 - (setq sei (+ 4 (/ (+ 4 4) 4)))
7 - (setq sette (- (/ 44 4) 4))
7 - (setq sette (- (+ 4 4) (/ 4 4)))
8 - (setq otto (/ (* 4 (+ 4 4)) 4))
8 - (setq otto (- (* 4 4) (+ 4 4)))
8 - (setq otto (- (+ 4 4 4) 4))
9 - (setq nove (+ (+ 4 4) (/ 4 4)))

Possiamo provare anche con altri numeri:

 42  - (setq quarantadue (+ 44 (sqrt 4) (- 4)))
100  - (setq cento (div 44 .44))
200  - (setq duecento (+ (fact 4) (* 4 44)))
666  - (setq beast (div 444 (sqrt .4444444444444444)))
1000 - (setq mille (- (* 4 (pow 4 4)) (fact 4)))


--------------
Il primo Primo
--------------

Non c'è dubbio che per tutto il XVII secolo e l'inizio del XX secolo molti matematici hanno considerato il numero 1 come primo, ma è anche chiaro che questa definizione non è mai stata una visone unificata dei matematici. Euclide, Mersenne, Eulero, Gauss, Dirichlet, Lucas e Landau tutti hanno omesso 1 dai primi. Gli ultimi matematici a considerare il numero 1 come primo sono stati Lebesgue (1899) e Hardy (1933).
Ad oggi, il primo numero Primo è il numero 2.
"What is the Smallest Prime?" Caldwell, Xiong - Journal of Integer Sequences, Vol.15 (2012)


--------------
Uso delle date
--------------

La data in formato ISO 8601: YYYY-MM-DD hh:mm:ss

2019-06-31 12:42:22

Purtroppo la funzione "date-parse" non funziona in windows.

; (date-parse "2019-06-15 12:42:22" "%Y-%m-%d %H:%M:%S")
; (date-parse "2019-06-31" "%Y-%m-%d")
; (date-parse "2007.1.3" "%Y.%m.%d")

(date)

"Thu Jul 18 11:36:02 2019"

Trasformiamo la data dal formato ISO al formato RFC822:

(apply date-value (map int (parse "2005-10-16 12:12:12" { |-|:} 0)))
;-> 1129464732

(apply date-value (map int (parse "2019-06-15 12:42:22" { |-|:} 0)))
;-> 1560602542

(apply date-value (map int (parse "2007.1.3" { |\.} 0)))
;-> 1167782400

(date (apply date-value (map int (parse "2005-10-16 12:12:12" { |-|:} 0)))  0 "%a, %d %b %Y %H:%M %Z")
;-> "Sun, 16 Oct 2005 14:12 W. Europe Daylight Time"

(date (apply date-value (map int (parse "2019-06-15 12:42:22" { |-|:} 0)))  0 "%a, %d %b %Y %H:%M %Z")
;-> "Sat, 15 Jun 2019 14:42 W. Europe Daylight Time"

(date (apply date-value (map int (parse "2007.1.3" { |\.} 0)))  0 "%a, %d %b %Y %H:%M %Z")
;-> "Wed, 03 Jan 2007 01:00 W. Europe Standard Time"


-------------------------------------------------
Chiusura transitiva e raggiungibilità in un grafo
-------------------------------------------------

ralph.ronnquist:
----------------
Vediamo come definire una "chiusura transitiva". Data una lista di coppie che rappresenta i link di un grafo, determinare le liste di tutti i nodi connessi transitivamente (in altre parole, unire tutte le sotto-liste che hanno in comune qualche elemento (transitivamente)).

Esempio:

 19 ←→ 9 ←→ 4 ←→ 12    3 ←→ 15 ←→ 8    7 ←→ 5 ←→ 0 ←→ 11
            ↕
           13 ←→ 1

(setq grafo '((13 1) (9 19) (4 13) (4 12) (15 8) (3 15) (7 5) (9 4) (11 0) (0 5)))

Una soluzione ricorsiva potrebbe essere la seguente:

(define (trans s (x s) (f (and s (curry intersect (first s)))))
  (if s (trans (rest s) (cons (unique (flat (filter f x))) (clean f x))) x))

(trans grafo)
;-> ((7 5 0 11) (9 19 4 13 1 12) (15 8 3))

rickyboy:
---------
L'input s è una lista di insiemi in cui ogni membro è in relazione l'uno con l'altro. Ad esempio, se uno dei membri di s è (1 2 3) ciascuno di 1, 2 e 3 sono collegati a qualsiasi altro. In termini matematici, se l'input s descrive una relazione (simmetrica) R, allora risulta che 1R2, 2R1, 1R3, 3R1, 2R3 e 3R2 sono tutti veri.

Quindi, ad esempio, il primo membro dell'input di esempio (13 1) implica sia 13R1 che 1R13 (quando l'input di esempio descrive R). Questo perché, l'input di trans e il suo output sono simili, sono entrambi descrizioni di relazione - tranne che l'output è garantito per descriva una relazione di transitività.

Ora, guardando l'input invece come un insieme di link di un grafo, allora la funzione "trans" deve assumere che tutti i link che trova nell'input sono bidirezionali, cioè gli archi (collegamenti) del grafo non sono orientati.

La funzione "trans" unisce (cons) il membro che definisce le relazioni transitive parziali che contengono il link (first s) (per assorbimento/sussunzione) (cioè (unique (flat (filter f x)))), con il sottoinsieme dei membri che definiscono le relazioni transitive parziali in x che sono mutualmente esclusive al link (first s) (cioè clean f x)

Quando utilizziamo la funzione "trans" possiamo accoppiarla con la seguente funzione che crea un predicato per essa:

(define (make-symmetric-relation S)
  (letex ([S] S)
    (fn (x y)
      (exists (fn (s) (and (member x s) (member y s)))
              '[S]))))

Ecco un test che mostra la funzione in azione:

(define (test-trans input x y)
  (let (R     (make-symmetric-relation input)
        Rt    (make-symmetric-relation (trans input))
        yesno (fn (x) (if x 'yes 'no)))
    (list ;; is (x,y) in the original relation?
          (yesno (R x y))
          ;; is (x,y) in the transitive closure?
          (yesno (Rt x y)))))

Ad esempio,
(8 15) è nella relazione originale: quindi, sarà anche nella chiusura transitiva.
(9 13) non è nella relazione originale, ma è nella chiusura transitiva.
(9 15) non è in nessuna delle due.

(define input '((13 1) (9 19) (4 13) (4 12) (15 8) (3 15) (7 5) (9 4) (11 0) (0 5)))

(test-trans input 8 15)
;-> (yes yes)

(test-trans input 9 13)
;-> (no yes)

(test-trans input 9 15)
;-> (no no)

ralph.ronnquist:
----------------
Esatto, la funzione "trans" tratta la sua lista di input s come una raccolta di classi di equivalenza e combina quelle che si sovrappongono nelle più piccole collezioni di classi.

La funzione simile per le relazioni non riflessive (o per gli archi diretti) riguarderebbe piuttosto la "raggiungibilità transitiva", da un elemento a quelli che sono raggiungibili quando si segue l'articolata relazione (links) in un solo senso (in avanti).

Le seguenti due funzioni svolgono questi metodi: una che determina il raggiungimento individuale di un dato elemento, e una che determina il raggiungimento individuale di tutti gli elementi (mappa di raggiungibilità).

versione iniziale:
(define (reach s n (f (fn (x) (= n (x 0)))))
  (cons n (if s (flat (map (curry reach (clean f s))
                           (map (curry nth 1) (filter f s)))))))

Nota: usare la versione iniziale della funzione "reach".

============================================================================
versione finale (rimuove gli elementi multipli con "unique"):
(define (reach s n (f (fn (x) (= n (x 0)))))
  (cons n (if s (unique (flat (map (curry reach (clean f s))
                                   (map (curry nth 1) (filter f s))))))))
============================================================================

(define (reachability s)
  (map (fn (x) (reach s x)) (sort (unique (flat s)))))

 19 ← 9 → 4 → 12    3 → 15 → 8    7 → 5 ← 0 ← 11
          ↓
          13 → 1


(setq grafoD '((13 1) (9 19) (4 13) (4 12) (15 8) (3 15) (7 5) (9 4) (11 0) (0 5)))

(reachability grafoD)
;-> ((0 5) (1) (3 15 8) (4 13 1 12) (5) (7 5) (8)
 ;-> (9 19 4 13 1 12) (11 0 5) (12) (13  1) (15 8) (19))

La "mappa di raggiungibilità" in ogni sottolista indica quali elementi sono raggiungibili dal primo elemento secondo la relazione orientata originale. Per creare la chiusura transitiva basta creare le coppie di associazione dalla mappa di raggiungibilità.

(define (transD s)
  (flat (map (fn (x) (if (1 x) (map (curry list (x 0)) (1 x)) '())) (reachability s)) 1))

(transD grafoD)
;-> ((0 5) (3 15) (3 8) (4 13) (4 1) (4 12) (7 5) (9 19)
;->  (9 4) (9 13) (9 1) (9 12) (11 0) (11 5) (13 1) (15 8))

Il nuovo input (grafoD) crea nuove coppie: (3 8) (4 1) (9 13) (9 1) (9 12) (11 5)

Adesso, come andiamo nell'altra direzione? Ovvero, come si riduce al minor numero di coppie, o almeno si trova una sottolista in modo che le relazioni implicite vengano omesse dall'elenco?

rickyboy:
---------
Ecco la funzione "untransD" che rimuove le relazioni implicite. LAvora considerando ogni arco in s che può essere visto come coppia (src dst) (sebbene dst non è necessario). La funzione "clean" risponde alla domanda "Questo arco è implicato?", che sarà vero (true) quando la raggiungibilità di src, dopo che abbiamo rimosso l'arco da s, è la stessa della raggiungibilità di src sotto s.

(define (untransD s)
  (clean (fn (edge)
           (let (src (edge 0)
                 remove (fn () (apply replace (args))))
             (= (reach s src)
                (reach (remove edge s) src))))
         s))

Per quelli che non hanno familiarità con newLISP, notare la funzione di "remove" (definita nell'associazioni let). Sembra che stia facendo solo ciò che fa la funzione intrinseca "replace": allora, perché non dire semplicemente (replace edge s) invece di (remove edge s)?
La ragione di questo è sottile. La primitiva "replace" è distruttiva e non vogliamo che s cambi durante il runtime di untransD. Definire "remove" come abbiamo fatto qui lo trasforma in una funzione di rimozione non distruttiva (a causa del modello di chiamata di newLISP: la funzione riceve una copia e non il riferimento dell'oggetto).

Ma forse da un punto di vista dei contratti (di ingegneria del software), non dovremmo fare affidamento sull'ordine degli output delle chiamate raggiunte (cioè la sua stabilità).
Anche se possiamo vedere il codice di raggiungibilità, possiamo anche giocare "giocare sicuro" assumendo che non possiamo vedere l'implementazione e quindi sostituire l'uso di = con l'uso di un altro predicato di uguaglianza in cui l'ordine non ha importanza. Potrebbe esserci un modo migliore di quello proposto di seguito:

(define (set-equal? A B)
  (= (sort A) (sort B)))

Anche la primitiva "sort" è distruttiva. Tuttavia, non abbiamo bisogno di A e B (che sono copie anche loro) per qualsiasi altra cosa nell'ambito di questa funzione (dopo che abbiamo finito possiamo distruggerli). Fortunatamente, possiamo riutilizzare set-equal? nei nostri test.

Innanzitutto, ricordiamo cosa fa "transD" in esecuzione sui dati di esempio (input).

(setq input '((13 1) (9 19) (4 13) (4 12) (15 8) (3 15) (7 5) (9 4) (11 0) (0 5)))

(transD input)
;-> ((0 5) (3 15) (3 8) (4 13) (4 1) (4 12) (7 5) (9 19)
;->  (9 4) (9 13) (9 1) (9 12) (11 0) (11 5) (13 1) (15 8))

Adesso vediamo la funzione "untransD" in azione:

(untransD (transD input))
;-> ((0 5) (3 15) (4 13) (4 12) (7 5) (9 19) (9 4) (11 0) (13 1) (15 8))

L'output della funzione sembra uguale alla lista di ingresso.

Come facciamo a testare meglio queste funzioni? Sembra che dovremmo essere in grado di dire che transD e untransD sono una l'inversa dell'altra. Proviamo.

Innanzitutto, si noti che l'input di esempio stesso è privo di relazioni implicite.

(set-equal? input (untransD input))
;-> true

Questo significa che deve valere anche la seguente identità:

(set-equal? input (untransD (transD input)))
;-> nil

Esplorando tutto il codice, credo di aver trovato un bug.

La seguente identità dovrebbe essere vera: la raggiungibilità della chiusura transitiva dell'input è la stessa della raggiungibilità dell'input.

(set-equal? (reachability input)
            (reachability (transD input)))

;-> nil

Cosa succede?

(reachability (transD input))
;-> ((0 5) (1) (3 15 8 8) (4 13 1 1 12) (5) (7 5)
;->  (8) (9 19 4 13 1 1 12 13 1 1 12) (11 0 5 5)
;->  (12) (13 1) (15 8) (19))

Ok, sembra che alcune raggiungibilità non abbiano elementi unici. Eccone una in particolare.

(reach (transD input) 9)
;-> (9 19 4 13 1 1 12 13 1 1 12)

Sembra che abbiamo bisogno della funzione "unique" nella funzione "reach".

(define (reach s n (f (fn (x) (= n (x 0)))))
  (cons n (if s (unique (flat (map (curry reach (clean f s))
                                   (map (curry nth 1) (filter f s))))))))

Bene, adesso funziona.

(reach (transD input) 9)
;-> (9 19 4 13 1 12)

E l'identità viene rispettata, come atteso.

(set-equal? (reachability input)
            (reachability (transD input)))

;-> true

Grazie a ralph.ronnquist e rickyboy.


-----------
Stalin Sort
-----------

Ecco un algoritmo di ordinamento O(n) (single pass) chiamato StalinSort. L'algoritmo scorre l'elenco degli elementi controllando se sono in ordine. Qualsiasi elemento fuori ordine viene eliminato. Alla fine si ottiene un elenco ordinato.

(define (stalinsort lst op)
  (local (out)
    (setq out '())
    (cond ((null? lst) '())
          (true
            (let (base (first lst))
              (push (first lst) out -1)
              (for (i 1 (- (length lst) 1))
                (if (op (lst i) base)
                ;(if (not (op (lst i) base))
                  (begin
                  (push (lst i) out -1)
                  (setq base (lst i)))
                )
              )
              out
            )
          )
    )
  )
)

(stalinsort '(1 3 4 2 3 6 8 5) <=)
;-> (1)
(stalinsort '(1 3 4 2 3 6 8 5) >=)
;-> (1 3 4 6 8)
(stalinsort '(11 8 4 2 3 6 8 5) <=)
;-> (11 8 4 2)
(stalinsort '(11 8 4 2 3 6 8 5) >=)
;-> (11)
(stalinsort '(11 4 8 2 3 6 8 12) <=)
;-> (11 4 2)
(stalinsort '(11 4 8 2 3 6 8 12) >=)
;-> (11 12)


--------------------
Sequenza triangolare
--------------------

Consideriamo il seguente triangolo di numeri interi:

1
1 2
1 2 3
1 2 3 4
1 2 3 4 5
...

Quando il triangolo è appiattito (flattened), produce la lista (1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 ...).
Il compito è scrivere un programma per generare la sequenza appiattita e per calcolare l'ennesimo elemento nella lista.

(define (triangle n idx)
  (local (out)
    (setq out '())
    (for (i 1 n)
      (push (sequence 1 i) out -1)
    )
    (setq out (flat out))
    (if idx (nth idx out) out)
  )
)

(triangle 3)
;-> (1 1 2 1 2 3)
(triangle 3 2)
;-> 2
(triangle 5)
;-> (1 1 2 1 2 3 1 2 3 4 1 2 3 4 5)
(triangle 5 10)
;-> 1


-------------------------
Vettore/lista di funzioni
-------------------------

Creiamo le funzioni:

(define (f0 x) (add x 1))
(define (f1 x) (mul x x))
(define (f2 x) (mul x x x))

Creiamo il vettore che contiene le funzioni:

(setq vet (array 3 (list f0 f1 f2)))
;-> ((lambda (x) (add x 1)) (lambda (x) (mul x x)) (lambda (x) (mul x x x)))

Ogni elemento del vettore contiene una funzione:

(vet 0)
;-> (lambda (x) (add x 1))

Possiamo chiamare le funzioni nel modo seguente:

((vet 0) 2)
;-> 3

((vet 1) 2)
;-> 4

((vet 2) 2)
;-> 8

Utilizzando una lista otteniamo lo stesso risultato:

(setq lst (list f0 f1 f2))
;-> ((lambda (x) (add x 1)) (lambda (x) (mul x x)) (lambda (x) (mul x x x)))

(dolist (el lst) (println (el 2)))
;-> 3
;-> 4
;-> 8


------------------------------------
Numeri dispari differenza di quadrati
-------------------------------------

Ogni numero dispari può essere espresso come differenza di due quadrati.

Dimostrazione:

Prendiamo il numero 5 e rappresentiamolo con delle O:
OOOOO

Dividiamo il numero in due parti:
OOO
O
O

Riempiamo il quadrato:
OOO
OXX
OXX

Quadrato totale (9) - quadrato interno (4) = 5

Scriviamo una funzione che calcola questi numeri:

(define (breaknum n)
  (if (even? n) nil
    (list (* (- n (/ n 2)) (- n (/ n 2))) (* (/ n 2) (/ n 2)) )
  )
)

(breaknum 11)
;-> (36 25)

(breaknum 9527)
;-> (22695696 22686169)


----------
Zero? test
----------

In newLISP abbiamo due modi per verificare se un numero n vale 0:

(zero? n) e (= n 0)

Vediamo se hanno la stesssa velocità. Scriviamo due funzioni che hanno una sola differenza: il modo con cui confrontiamo un valore con il numero zero.

(define (t1 num)
  (let (k 0)
    (dotimes (x num) (if (zero? (rand 2)) (++ k)))
    k))

(define (t2 num)
  (let (k 0)
    (dotimes (x num) (if (= 0 (rand 2)) (++ k)))
    k))

(time (map t1 (sequence 10 10000)))
;-> 5324.556

(time (map t2 (sequence 10 10000)))
;-> 5874.991

Il modo (zero? n) è più veloce.

Proviamo con un altro calcolo al posto di "rand":

(define (t1 num)
  (let (k 0)
    (dotimes (x num) (if (zero? (% num (+ x 1))) (++ k)))
    k))

(define (t2 num)
  (let (k 0)
    (dotimes (x num) (if (= 0 (% num (+ x 1))) (++ k)))
    k))

(time (map t1 (sequence 10 10000)))
;-> 5062.827

(time (map t2 (sequence 10 10000)))
;-> 5663.21

Quindi nei test numerici è meglio utilizzare la funzione "zero?"


-----------------------------------------------
Operazioni su elementi consecutivi di una lista
-----------------------------------------------

Supponiamo di voler calcolare la differenza tra gli elementi consecutivi della seguente lista: (7 11 13 17 19 23 29 31 37)

(setq a '(7 11 13 17 19 23 29 31 37))

(define (dist-lst lst) (map - (rest lst) (chop lst)))

(dist-lst a)
;-> (4 2 4 2 4 6 2 6)

(11 - 7 = 4) (13 - 11 = 2) (17 - 13 = 4)...(37 - 31 = 6)

Possiamo generalizzare la funzione per utilizzare anche altri operatori:

(define (calc-lst lst func ) (map func (rest lst) (chop lst)))

(calc-lst a +)
;-> (18 24 30 36 42 52 60 68)

(11 + 7 = 18) (13 + 11 = 24) (17 + 13 = 30)...(37 + 31 = 68)

Possiamo generalizzare ancora la funzione permettendo di stabilire l'ordine degli operandi. Quando il parametro rev vale true, allora viene effettuata l'operazione (el(n) func el(n+1)), altrimenti viene effettuata l'operazione (el(n+1) func el(n))

(define (calc-lst lst func rev)
  (if rev
      (map func (chop lst) (rest lst))
      (map func (rest lst) (chop lst))))

(calc-lst a -)
;-> (4 2 4 2 4 6 2 6)

(calc-lst a - true)
;-> (-4 -2 -4 -2 -4 -6 -2 -6)

(7 - 11 = -4) (11 - 13 = -2) (13 - 17 = -4)...(31 - 37 = -6)


---------------------------------------------------
Il loop implicito del linguaggio Scheme (named let)
---------------------------------------------------

La seguente funzione in linguggio Scheme converte un numero intero in una lista:

(define (number->list n)
  (let loop ((n n)
             (acc '()))
    (if (< n 10)
        (cons n acc)
        (loop (quotient n 10)
              (cons (remainder n 10) acc)))))

Viene definito un ciclo in cui la variabile n è uguale a n e la variabile acc è uguale all'elenco vuoto. Quindi se n è minore di 10, n viene inserito in acc. Altrimenti, "loop" viene applicato con n uguale a n/10 e acc uguale al cons del resto di n / 10 e della lista accumulata precedentemente, quindi chiama se stesso.
L'idea alla base di let è che permette di creare una funzione interna, che può chiamare se stessa e invocarla automaticamente. Possiamo utilizzare questa idea per scrivere in newLISP una funzione simile:

(define (number->list n)
  ; definiamo la funzione "loop" (può avere qualunque nome)
  (define (loop n acc)
    (if (< n 10)
        (cons n acc)
        (loop (/ n 10) (cons (% n 10) acc))
    )
  )
  ; chiamiamo la funzione "loop"
  (loop n '())
)

(number->list '1234)
;-> (1 2 3 4)

Viene chiamato "loop" perché la funzione chiama se stessa dalla posizione di coda. Questo è noto come ricorsione di coda (tail recursion). In Scheme, con la ricorsione di coda, la chiamata ricorsiva ritorna direttamente al chiamante, quindi non è necessario mantenere il frame di chiamata corrente. È possibile eseguire la ricorsione della coda tutte le volte che si desidera senza causare un overflow dello stack. In newLISP non esiste l'ottimizzazione della ricorsione di coda, quindi dobbiamo stare molto attenti a non causare un errore di stack overflow quando usiamo la tecnica della ricorsione.

Vediamo un altro esempio: il calcolo dell'insieme delle parti (powerset) di una lista.

Versione "named let" in Scheme:
(define (power-set-i lst)
  (let loop ((res '(())) (s lst))
    (if (empty? s)
        res
        (loop (append (map (lambda (i) (cons (first s) i)) res) res) (rest s)))))

Versione "newLISP":
(define (powerset-i lst)
  (define (loop res s)
    (if (empty? s)
      res
      (loop (append (map (lambda (i) (cons (first s) i)) res) res) (rest s))))
  (loop '(()) lst))

(powerset-i '(1 2 3))
;-> ((3 2 1) (3 2) (3 1) (3) (2 1) (2) (1) ())


------------------------------
Brainfuck string encode/decode
------------------------------

Brainfuck è un linguaggio di programmazione esoterico, creato da Urban Müller nel 1993.

Scrivere due funzioni che effettuano le seguenti operazioni:

1) Input -> Stringa, Output -> Programma Brainfuck per stampare la stringa

2) Input -> Programma Brainfuck per stampare la stringa, Output -> stringa

Questa funzione prende una stringa e restituisce un programma (stringa) in linguaggio Brainfuck che stampa la stringa:

(define (gen-bf str)
  (let (o "")
    (dolist (el (explode str))
      (setq o (join (list o (dup "+" (char el)) ".[-]")))
    )
    ;(silent (println o))
  )
)

(gen-bf "ciao")
;-> "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.[-]+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.[-]+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.[-]+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.[-]"

(gen-bf "newLISP")
;-> "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.[-]+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.[-]+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.[-]++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.[-]+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.[-]+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.[-]++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.[-]"

Questa funzione prende un programma (stringa) in linguaggio Brainfuck che stampa la stringa e restituisce la stringa da stampare:

(define (bf str)
  (local (cc)
    (setq cc 0)
    (dolist (el (explode str))
      ; conta i caratteri "+"
      (if (= el "+")
          (++ cc)
          ; e quando finiscono i "+", stampa il carattere relativo al numero dei "+"
          (if (!= cc 0) (begin (print (char cc)) (setq cc 0)))
      )
    )
    (silent (print (format "\n%s " "stop.")))
  )
)

(bf "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.[-]+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.[-]+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.[-]+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.[-]")
;-> ciao
;-> stop.

(bf
"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.[-]+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.[-]+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.[-]++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.[-]+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.[-]+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.[-]++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.[-]")
;-> newLISP
;-> stop.

(bf (gen-bf "Controllo funzioni"))
;-> Controllo funzioni
;-> stop.


------------------------------------
Creare una utilità di sistema (.exe)
------------------------------------

Il codice sorgente e l'eseguibile newLISP.exe possono essere uniti tra loro per creare un'applicazione autonoma utilizzando il flag della riga di comando -x.

;; uppercase.lsp - Link example
(println (upper-case (main-args 1)))
(exit)

Il programma uppercase.lsp prende la prima parola dalla riga di comando e la converte in maiuscolo.

Per compilare questo programma come eseguibile autonomo, eseguire dal terminale la seguente procedura:

Su OSX, Linux e altri UNIX

newlisp -x uppercase.lsp uppercase

chmod 755 uppercase # give executable permission

Su Windows il file di destinazione richiede l'estensione .exe

newlisp -x uppercase.lsp uppercase.exe

newLISP troverà l'eseguibile "newLISP.exe" nel percorso di esecuzione dell'ambiente (PATH) e lo unirà ad una copia del codice sorgente "uppercase.lsp" per creare il programma "uppercase.exe".

Per eseguire il programma eseguire dal terminale il comando:

Su Linux e altri UNIX, se la cartella (directory) corrente si trova nel percorso eseguibile:

uppercase "convert me to uppercase"

Su Linux e altri UNIX, se la directory corrente non si trova nel percorso eseguibile:

./uppercase "convert me to uppercase"

Su windows:

uppercase "convert me to uppercase"

La console dovrebbe stampare:

;-> CONVERT ME TO UPPERCASE

Si noti che nessuno dei file di inizializzazione init.lsp né .init.lsp viene caricato durante l'avvio dei programmi creati in questo modo.

Vediamo come gestire i parametri passati alla linea di comando utilizzando la funzione "main-args".

**********************
>>>funzione MAIN-ARGS
**********************
sintassi: (main-args int-index)

main-args restituisce una lista con diversi elementi di tipo stringa, uno per l'invocazione del programma e uno per ciascuno degli argomenti della riga di comando.

newlisp 1 2 3

> (main-args)
("/usr/local/bin/newlisp" "1" "2" "3")

Dopo che newlisp 1 2 3 viene eseguito al prompt dei comandi, main-args restituisce una lista contenente il nome del programma chiamante e i tre argomenti della riga di comando.

Facoltativamente, main-args può prendere un int-index per l'indicizzazione della lista. Si noti che un indice fuori intervallo causerà la restituzione di zero, non l'ultimo elemento dell'elenco come nell'indicizzazione delle liste.

newlisp a b c

(main-args 0)
;-> "/usr/local/bin/newlisp"
(main-args -1)
;-> "c"
(main-args 2)
;-> "b"
(main-args 10)
;-> nil

Nota che quando newLISP viene eseguito da uno script, main-args restituisce anche il nome dello script come secondo argomento:

#!/usr/local/bin/newlisp
#
# script to show the effect of 'main-args' in script file

(print (main-args) "\n")
(exit)

# end of script file

;; execute script in the OS shell:

script 1 2 3

;-> ("/usr/local/bin/newlisp" "./script" "1" "2" "3")

Prova a eseguire questo script con diversi parametri della riga di comando.

Con lo stesso metodo possiamo scrivere altre funzioni di sistema:

CAT
;;  cat
;;  concatena file
;;  c:> cat file1 file2 file3 ... >stdout
;;
;;  cat.make
;;  (load {c:\newlisp\link.lsp})
;;  (link {c:\newlisp\newlisp.exe} "cat.exe" "cat.lsp")

(map (fn (F) (write-line (read-file F))) (rest (main-args)))
(exit)

newlisp -x cat.lsp cat.exe

TAIL
1) legge tutto il file il cui nome è (nth 1 (main-args))
2) parse in linee
3) usa 'slice' per estrarre le ultime (nth 2 (main-args)) linee (come integer)
4) join e print il risultato

;;  tail
;;
(print (join
        (slice
            (parse (read-file (nth 1 (main-args))) "\r\n")
            (- (integer (nth 2 (main-args)))))
        "\r\n"))
(exit)

newlisp -x tail.lsp tail.exe


----------------------------
Fattoriale, Fibonacci, Primi
----------------------------

(setq MAXINT 9223372036854775807)

Funzione di fattorizzazione:

(define (factorbig n)
  (local (f k i dist out)
    ; Distanze tra due elementi consecutivi della ruota (wheel)
    (setq dist (array 48 '(2 4 2 4 6 2 6 4 2 4 6 6 2 6 4 2 6 4
                           6 8 4 2 4 2 4 8 6 4 6 2 4 6 2 6 6 4
                           2 4 6 2 6 4 2 4 2 10 2 10)))
    (setq out '())
    (while (zero? (% n 2)) (push '2L out -1) (setq n (/ n 2)))
    (while (zero? (% n 3)) (push '3L out -1) (setq n (/ n 3)))
    (while (zero? (% n 5)) (push '5L out -1) (setq n (/ n 5)))
    (while (zero? (% n 7)) (push '7L out -1) (setq n (/ n 7)))
    (setq k 11L i 0)
    (while (<= (* k k) n)
      (if (zero? (% n k))
        (begin
        (push k out -1)
        (setq n (/ n k)))
        (begin
        ;(++ k (dist i))
        (setq k (+ k (dist i)))
        (if (< i 47) (++ i) (setq i 0)))
      )
    )
    (if (> n 1) (push (bigint n) out -1))
    out
  )
)

Funzione fattoriale:

(define (fact n) (if (= n 0) 1 (apply * (map bigint (sequence 1 n)))))

Definiamo una funzione che stampa il fattoriale e la sua scomposizione in fattori fino a n:

(define (test n)
  (local (f fp)
    (for (i 2 n)
      (setq f (fact i))
      (setq fp (factorbig f))
      (println i { } f)
      (println fp)
    )
  )
)

(test 14)
2 2L
(2L)
3 6L
(2L 3L)
4 24L
(2L 2L 2L 3L)
5 120L
(2L 2L 2L 3L 5L)
6 720L
(2L 2L 2L 2L 3L 3L 5L)
7 5040L
(2L 2L 2L 2L 3L 3L 5L 7L)
8 40320L
(2L 2L 2L 2L 2L 2L 2L 3L 3L 5L 7L)
9 362880L
(2L 2L 2L 2L 2L 2L 2L 3L 3L 3L 3L 5L 7L)
10 3628800L
(2L 2L 2L 2L 2L 2L 2L 2L 3L 3L 3L 3L 5L 5L 7L)
11 39916800L
(2L 2L 2L 2L 2L 2L 2L 2L 3L 3L 3L 3L 5L 5L 7L 11L)
12 479001600L
(2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 3L 3L 3L 3L 3L 5L 5L 7L 11L)
13 6227020800L
(2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 3L 3L 3L 3L 3L 5L 5L 7L 11L 13L)
14 87178291200L
(2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 3L 3L 3L 3L 3L 5L 5L 7L 7L 11L 13L)

(pretty-print)
;-> (80 " " "%1.16g")

(pretty-print 70 " " "%1.16g")

(factorbig (fact 100))
;-> (2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L
;->  2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L
;->  2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L
;->  2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L 2L
;->  2L 3L 3L 3L 3L 3L 3L 3L 3L 3L 3L 3L 3L 3L 3L 3L 3L 3L 3L 3L 3L 3L 3L 3L
;->  3L 3L 3L 3L 3L 3L 3L 3L 3L 3L 3L 3L 3L 3L 3L 3L 3L 3L 3L 3L 3L 3L 3L 3L
;->  3L 5L 5L 5L 5L 5L 5L 5L 5L 5L 5L 5L 5L 5L 5L 5L 5L 5L 5L 5L 5L 5L 5L 5L
;->  5L 7L 7L 7L 7L 7L 7L 7L 7L 7L 7L 7L 7L 7L 7L 7L 7L 11L 11L 11L 11L 11L
;->  11L 11L 11L 11L 13L 13L 13L 13L 13L 13L 13L 17L 17L 17L 17L 17L 19L 19L
;->  19L 19L 19L 23L 23L 23L 23L 29L 29L 29L 31L 31L 31L 37L 37L 41L 41L 43L
;->  43L 47L 47L 53L 59L 61L 67L 71L 73L 79L 83L 89L 97L)

Definiamo una funzione per calcolare i numeri di Fibonacci:

(define (fibo-i n)
  (local (a b c)
    (setq a 0L b 1L c 0L)
    (for (i 0 (- n 1))
      (setq c (+ a b))
      (setq a b)
      (setq b c)
    )
    a
  )
)

(fibo-i 10)
;-> 55L

Definiamo una funzione per verificare se un numero è primo:

(define (isprime? n)
  (if (< n 2) nil
    (= 1 (length (factorbig n)))))

(isprime? (fibo-i 20))
;-> nil

Definiamo una funzione che stampa il numero di Fibonacci e la sua scomposizione in fattori fino a n:

(define (test1 n)
  (local (f fp)
    (for (i 2 n)
      (setq f (fibo-i i))
      (setq fp (factorbig f))
      (println i { } f)
      (println fp)
    )
  )
)

(test1 100)
;-> 2 1L
;-> ()
;-> 3 2L
;-> (2L)
;-> 4 3L
;-> (3L)
;-> 5 5L
;-> (5L)
;-> 6 8L
;-> (2L 2L 2L)
;-> 7 13L
;-> (13L)
;-> 8 21L
;-> (3L 7L)
;-> 9 34L
;-> (2L 17L)
;-> 10 55L
;-> (5L 11L)
;-> 11 89L
;-> (89L)
;-> 12 144L
;-> (2L 2L 2L 2L 3L 3L)
;-> 13 233L
;-> (233L)
;-> ...
;-> 83 99194853094755497L
;-> (99194853094755497L)
;-> 84 160500643816367088L
;-> (2L 2L 2L 2L 3L 3L 13L 29L 83L 211L 281L 421L 1427L)
;-> 85 259695496911122585L
;-> (5L 1597L 9521L 3415914041L)
;-> 86 420196140727489673L
;-> (6709L 144481L 433494437L)
;-> 87 679891637638612258L
;-> (2L 173L 514229L 3821263937L)
;-> 88 1100087778366101931L
;-> (3L 7L 43L 89L 199L 263L 307L 881L 967L)
;-> 89 1779979416004714189L
;-> (1069L 1665088321800481L)
;-> 90 2880067194370816120L
;-> (2L 2L 2L 5L 11L 17L 19L 31L 61L 181L 541L 109441L)
;-> 91 4660046610375530309L
;-> (13L 13L 233L 741469L 159607993L)
;-> 92 7540113804746346429L
;-> (3L 139L 461L 4969L 28657L 275449L)
;-> 93 12200160415121876738L
;-> (2L 557L 2417L 4531100550901L)
;-> 94 19740274219868223167L
;-> (2971215073L 6643838879L)
;-> 95 31940434634990099905L
;-> (5L 37L 113L 761L 29641L 67735001L)
;-> 96 51680708854858323072L
;-> (2L 2L 2L 2L 2L 2L 2L 3L 3L 7L 23L 47L 769L 1103L 2207L 3167L)
;-> 97 83621143489848422977L
;-> (193L 389L 3084989L 361040209L)
;-> 98 135301852344706746049L
;-> (13L 29L 97L 6168709L 599786069L)
;-> 99 218922995834555169026L
;-> (2L 17L 89L 197L 19801L 18546805133L)
;-> 100 354224848179261915075L
;-> (3L 5L 5L 11L 41L 101L 151L 401L 3001L 570601L)
;-> (3L 5L 5L 11L 41L 101L 151L 401L 3001L 570601L)

Adesso cerchiamo i numeri di Fibonacci che sono anche primi fino a n.

(define (primi-fib n)
  (for (i 2 n)
    (if (= 1 (length (factorbig (fibo-i i))))
      (println i { } (fibo-i i))
    )
  )
)

(primi-fib 50)
;-> 3 2L
;-> 4 3L
;-> 5 5L
;-> 7 13L
;-> 11 89L
;-> 13 233L
;-> 17 1597L
;-> 23 28657L
;-> 29 514229L
;-> 43 433494437L
;-> 47 2971215073L

(time (primi-fib 100))
;-> 3 2L
;-> 4 3L
;-> 5 5L
;-> 7 13L
;-> 11 89L
;-> 13 233L
;-> 17 1597L
;-> 23 28657L
;-> 29 514229L
;-> 43 433494437L
;-> 47 2971215073L
;-> 83 99194853094755497L
;-> 514886.082 ; 8 minuti e 34 secondi

Definiamo una funzione che converte i millisecondi in minuti e secondi:

(define (ms2min ms)
  (let ((mins (/ ms 1000 60))
       (secs (% (/ ms 1000) 60)))
       (println (format "%d millisec = %d minuti e %d secondi." ms mins secs))
       (list mins secs)
  )
)

(ms2min 514886.082)
;-> 514886 millisec = 8 minuti e 34 secondi.

Sequenza OEIS dei numeri di Fibonacci primi:

2, 3, 5, 13, 89, 233, 1597, 28657, 514229, 433494437, 2971215073,
99194853094755497, 1066340417491710595814572169,
19134702400093278081449423917,

Nota: MAXINT = 9223372036854775807 e MININT = -9223372036854775808

Usiamo la funzione "factor" al posto di "factorbig", ma possiamo arrivare solo fino a n = 92:

(- (fibo-i 92) 9223372036854775807)
;-> -1683258232108429378L

(- (fibo-i 93) 9223372036854775807)
;-> 2976788378267100931L

(define (primi-fib2 n)
  (for (i 2 n)
    (if (= 1 (length (factor (fibo-i i))))
      (println i { } (fibo-i i))
    )
  )
)

(time (primi-fib2 92))
;-> 3 2L
;-> 4 3L
;-> 5 5L
;-> 7 13L
;-> 11 89L
;-> 13 233L
;-> 17 1597L
;-> 23 28657L
;-> 29 514229L
;-> 43 433494437L
;-> 47 2971215073L
;-> 83 99194853094755497L
;-> 1718.801

Il prossimo numero di Fibonacci primo vale:

(fibo-i 131)
;-> 1066340417491710595814572169L)

Vediamo quanto tempo impiega la funzione "factorbig" per verificarlo:

(time (println (factorbig 1066340417491710595814572169L)))

Tanto tanto tempo...


-----
Quine
-----

Un Quine è un programma autoreferenziale che stampa, senza alcun input, il proprio sorgente.
Il nome "quine" fu coniato da Douglas Hofstadter, nel suo famoso libro di scienze "Gödel, Escher, Bach: Un Eterna Ghirlanda Brillante", in onore del filosofo Willard Van Orman Quine (1908–2000), che i coniò l'espressione paradossale "Yields falsehood when appended to its own quotation", yields falsehood when appended to its own quotation, ovvero "Produce una falsità se preceduto dalla propria citazione" produce una falsità se preceduto dalla propria citazione.

Uno degli esempi più famosi (scritto da Chris Hruska) è il seguente:

((lambda (x) (list x (list 'quote x))) '(lambda (x) (list x (list 'quote x))))
;-> ((lambda (x) (list x (list 'quote x))) '(lambda (x) (list x (list 'quote x))))

Infatti valutando l'espressione nella REPL si ottiene come output l'espressione stessa.

Anche il creatore di LISP ha creato un quine (John McCarthy e Carolyn Talcott):

((lambda (x)
   (list x (list (quote quote) x)))
  (quote
     (lambda (x)
       (list x (list (quote quote) x)))))
;-> ((lambda (x) (list x (list (quote quote) x))) (quote (lambda (x)
;->        (list x (list (quote quote) x)))))

Continuiamo con un altro esempio:

((lambda (x) (list x x)) (lambda (x) (list x x)))
;-> ((lambda (x) (list x x)) (lambda (x) (list x x)))

In newLISP, Lutz Mueller (il creatore del linguaggio) ha creato il più corto programma quine:

(lambda (x))
;-> (lambda (x))

Perché in newLISP le espressioni lambda valutano/ritornano a se stesse.

Anche il seguente potrebbe essere un quine (se fossero ammissibili i programmi errati):

ERR: context expected : ERR:
;-> ERR: context expected : ERR:

Invece il seguente è sicuramente un quine:

(lambda (s) (print (list s (list 'quote s))))
;-> (lambda (s) (print (list s (list 'quote s))))

Un altro quine è il seguente:

; Versione originale di PvE:
(define (make-me)
	(println (source 'make-me))
	(println "(println (make-me))")
	(println "(exit)")
	(println ""))
(println (make-me))
;(exit)

; Versione migliorata da Lutz:
(define (quine )
  (println (source 'quine) "(quine)")
  (exit))
(quine)


-----------------------------
I buchi delle cifre numeriche
-----------------------------

Quale numero viene dopo la sequenza: 1, 4, 8, 48, 88, 488, ...

Notiamo che 1 non a buchi, 4 ha un buco, 8 ha due buchi, 48 ha tre buchi, 88 ha quattro buchi, 488 ha cinque buchi, quindi il prossimo numero è 888 perchè è il più piccolo numero che ha sei buchi.

Quindi il problema è quello di trovare il numero intero più piccolo con n buchi nelle sue cifre decimali.

Definiamo una lista associativa in cui ci sono due valori (x y), dove x è la cifra numerica e y è il numero di buchi della cifra:

(setq buchi '((0 1) (1 0) (2 0) (3 0) (4 1) (5 0) (6 1) (7 0) (8 2) (9 1)))
(lookup 1 buchi)
;-> 0
(lookup 8 buchi)
;-> 2

La seguente espressione converte un numero in una lista di cifre:

(map int (explode (string 1234)))
;-> (1 2 3 4)

Adesso scriviamo la funzione:

(define (holesequence num)
  (local (val out)
    (setq val 0 out '())
    (dotimes (n num)
      ;somma dei buchi di tutte le cifre che compongono il numero n
      (if (= val (apply +
            (map (fn (x) (lookup x buchi)) (map int (explode (string n))))))
          (begin (push (list val n) out -1) (++ val)))
    )
    out
  )
)

(holesequence 100000)
;-> ((0 1) (1 4) (2 8) (3 48) (4 88) (5 488)
;->  (6 888) (7 4888) (8 8888) (9 48888))

1  ha 0 (zero) buchi
4  ha 1 (uno) buco
8  ha 2 (due) buchi
48 ha 3 (tre) buchi
88 ha 4 (quattro) buchi
...


-------------------
Ordinare tre numeri
-------------------

Esercizio preso dal libro di Bjarne Stroustrup "Principles and Practice Using C++".

Scrivere una funzione che prende 3 valori interi e li stampa in ordine crescente.

Esempio:
input = 10 4 6
output = 4 6 10

È possibile utilizzare solo le seguenti istruzioni:

1) if
2) cond
3) setq
4) println
5) local
6) let
7) and
8) or

(define (ordina x y z)
  (local (a b c)
    (setq a 0 b 0 c 0) ; al termine: a <= b <= c
    (cond ((and (<= x y) (<= x z)) ; x è minore di y e di z
           (setq a x) ; x è il più piccolo
           ; quale dei due numeri rimanenti è minore?
           (if (<= y z) (setq b y c z) (setq c y b z)))
          ((and (<= y x) (<= y z)) ; y è minore di x e di z
           (setq a y) ; y è il più piccolo
           ; quale dei due numeri rimanenti è minore?
           (if (<= x z) (setq b x c z) (setq c x b z)))
          (true                    ; z è minore di x e di y
           (setq a z) ; z è il più piccolo
           ; quale dei due numeri rimanenti è minore?
           (if (<= x y) (setq b x c y) (setq c x b y)))
    )
    (println a { } b { } c)
  )
)

(ordina 10 4 6)
;-> 4 6 10

(ordina 4 6 10)
;-> 4 6 10

(ordina 10 6 4)
;-> 4 6 10


----------------
Conteggio strano
----------------

Una bambina conta sulle dita di una mano partendo da 1 sul pollice, 2 sul dito indice, 3 sul medio, 4 sul dito anulare e 5 sul mignolo. Quindi torna indietro nella stessa mano, contando 6 sul'anulare, 7 sul medio, 8 sull'indice e 9 sul pollice. Poi continua indefinitamente contando sempre nello stesso modo. Scrivere un programma che, dato un numero intero n, determina su quale dito terminerà quando il  conteggio raggiunge n.

Il conteggio procede nel modo seguente:

 a   b   c   d   e
POL IND MED ANU MIG
 1   2   3   4   5
 9   8   7   6
    10  11  12  13
17  16  15  14
    18  19  20  21
25  24  23  22
    26  27  28  29
33  32  31  30
    34  35  36  37

Il pattern è il seguente:

  1       5   6     9      13  14      18    21  22    25      29
("a b c d e" "d c b a b c d e" "d c b a b c d e" "d c b a b c d e")
              1 2 3 4 5 6 7 8   9    12      16  17    20  22  24

A parte i primi cinque numeri, troviamo sempre una sequenza ripetuta: "d c b a b c d e".

Quindi risulta che ((n-5) mod 8) indica la posizione (indice) nella sequenza ripetuta:

resto:     1 2 3 4 5 6 7 0
sequenza: "d c b a b c d e"

Possiamo scrivere la funzione:

(define (mano n)
  (cond ((<= n 5)
         (cond ((= n 1) 'pollice)
               ((= n 2) 'indice)
               ((= n 3) 'medio)
               ((= n 4) 'anulare)
               ((= n 5) 'mignolo)))
        ((= 1 (% (- n 5) 8)) 'anulare)
        ((= 2 (% (- n 5) 8)) 'medio)
        ((= 3 (% (- n 5) 8)) 'indice)
        ((= 4 (% (- n 5) 8)) 'pollice)
        ((= 5 (% (- n 5) 8)) 'indice)
        ((= 6 (% (- n 5) 8)) 'medio)
        ((= 7 (% (- n 5) 8)) 'anulare)
        (true 'mignolo)
  )
)

(mano 36)
;-> anulare

(mano 8)
;-> indice

(mano 1000)
;-> indice

Possiamo scrivere la funzione in maniera più concisa:

(define (hand n)
  (let ((fingers1 '(pollice indice medio anulare mignolo))
        (fingers2 '(mignolo anulare medio indice pollice indice medio anulare)))
       (if (<= n 5)
           (fingers1 (- n 1))
           (fingers2 (% (- n 5) 8))
       )
  )
)

(hand 36)
;-> anulare

(hand 8)
;-> indice

(hand 1000)
;-> indice

(hand 5)
;-> mignolo


------------------------
Funzioni automodificanti
------------------------

In newLISP le funzioni sono oggetti di prima classe, cioè possono essere passate e restituite da altre funzioni. Inoltre le funzioni possono modificare il codice di altre funzioni durante l'elaborazione (runtime).
Quindi una funzione può modificare e restituire se stessa. Per esempio:

(define (f lst)
  (println (first f))
  (println f)
  (setf (first f) '(lista))
  (println (first f))
  f)

(f '(1 2 3))
;-> (lst)
;-> (lambda (lst) (println (first f)) (println f) (setf (first f) 'lista) (println (first f)) f)
;-> lista
;-> (lambda (lista) (println (first f)) (println f) (setf (first f) 'lista) (println (first f)) f)

In questo caso abbiamo modificato il nome dell'argomento della funzione (da "lst" a "lista"), quindi il comportamento della nuova funzione è uguale al precedente.

Gli elementi che compongono la funzione (argomenti e corpo) vengono identificati con le normali funzioni per il trattamento delle liste:

(define (fun a b) (+ a b))
;-> (lambda (a b) (+ a b))

Gli argomenti della funzione sono il primo elemento della lista/funzione:

(setq arg (first fun))
;-> (a b)

Il corpo della funzione sono tutti i rimanenti elementi della lista/funzione:

lista di tutte le espressioni:
(setq corpo (rest fun))
;-> ((+ a b))

ultima espressione:
(setq corpo (last fun))
;-> (+ a b)

Possiamo modificare questi elementi (arg e corpo) direttamente nella lista/funzione oppure possiamo creare una nuova funzione e poi assegnarla alla funzione desiderata. Per identificare le varie parti della lista/funzione utilizziamo la funzione "nth" (non possiamo utilizzare l'indicizzazione implicita e l'uso di "first" e "rest" è abbastanza scomodo).

(nth 0 fun)
;-> (a b)

(nth 1 fun)
;-> (+ a b)

(nth '(1 0) fun)
;-> +

Adesso supponiamo di voler modificare la funzione fun in modo che faccia la sottrazione degli argomenti (invece che la somma).

Nel caso della modifica diretta della funzione possiamo scrivere:

(setf (nth '(1 0) fun) '-)
;-> -

Abbiamo modificato la funzione "fun":

fun
;-> (lambda (a b) (- a b))

Infatti adesso effettua la sottrazione degli argomenti:

(fun 1 2)
;-> -1

Nel caso in cui creiamo una nuova funzione possiamo scrivere:

(setq fun '(lambda (a b) (+ a b)))
;-> (lambda (a b) (+ a b))

(fun 1 2)
;-> 3

Oppure:

(setq f-aux (append '(lambda (a b)) '((- a b))))
;-> (lambda (a b) (- a b))

(f-aux 1 2)
;-> -1

Oppure:

(setq f-aux (append '(lambda) (list (nth 0 fun) '(- a b))))
;-> (lambda (a b) (- a b))

(setq fun f-aux)
;-> (lambda (a b) (- a b))

(fun 1 2)
;-> -1

Proviamo a scrivere una funzione automodificante che ad ogni chiamata alterna l'addizione e la sottrazione dei suoi argomenti:

(define (boh a b)
  ; AUTOMODIFICA
  ; modifichiamo la funzione alternando gli operatori + e -
  ; (+ a b) --> (- a b)
  ; (- a b) --> (+ a b)
  (if (= (nth '(2 0) boh) '+) (setf (nth '(2 0) boh) '-) (setf (nth '(2 0) boh) '+))
  ; calcolo dell'operazione
  (+ a b)
)

(nth '(2 0) boh)
;-> +

(boh 2 3)
;-> -1

(boh 2 3)
;-> 5

(boh 2 3)
;-> -1

Ad ogni chiamata la funzione alterna tra addizione e sottrazione degli argomenti.

Vediamo una funzione leggermente più complessa:

(define (massimo a b)
  (local (out)
    (if (< a b)
        (setq out b)
        (setq out a))
    (println "il massimo vale: " out)
    out
  )
)

(massimo 2 4)
;-> il massimo vale: 4
;-> 4

massimo
;-> (lambda (a b)
;->  (local (out)
;->   (if (< a b)
;->    (setq out b)
;->    (setq out a))
;->   (println "il massimo vale: " out) out))

(nth 0 massimo)
;-> (a b)

(nth 1 massimo)
;-> (local (out)
;->  (if (< a b)
;->   (setq out b)
;->   (setq out a))
;->  (println "il massimo vale: " out) out)

(length (nth 1 massimo))
;-> 5

(nth '(1 0) massimo)
;-> local

(nth '(1 1) massimo)
;-> (out)

(nth '(1 2) massimo)
;-> (if (< a b) (setq out b) (setq out a))

(nth '(1 3) massimo)
;-> (println "il massimo vale: " out)

(nth '(1 4) massimo)
;-> out

Per modificare le funzioni è fondamentale identificare con "nth" l'esatta posizione della espressione da trattare.

Vediamo un altro esempio:

(define (prova a b)
  (setq x (+ a b))
  (setq y (- a b))
  (* x y))

(nth 0 prova)
;-> (a b)
(length (nth 0 prova))
;-> 2

(nth 1 prova)
;-> (setq x (+ a b))
(length (nth 1 prova))
;-> 3

(nth 2 prova)
;-> (setq y (- a b))
(length (nth 2 prova))
;-> 3

(nth 3 prova)
;-> (* x y)
(length (nth 3 prova))
;-> 3

L'oggetto "lambda" in newLISP non è una parola chiave come una funzione o un operatore incorporato, ma un attributo speciale di una lista: un lista lambda, che si presenta in questo modo:

(lambda)
;-> (lambda )

Come si vede, una lista lambda valuta su se stessa in newLISP e non è necessario quotarla quando la si utilizza come parametro per un'altra funzione.

Quando si costruiscono liste lambda con "append" o "cons", allora "append" associa la proprietà lambda a destra e "cons" a sinistra:

(append (lambda) '((x) (+ x x)))
;-> (lambda (x) (+ x x))

(cons '(x) (lambda (+ x x)))
;-> (lambda (x) (+ x x))

L'esempio "cons" mostra che lambda non è il primo elemento di una lista, ma piuttosto una proprietà di quella lista. Infatti risulta:

(empty? (lambda))
;-> true

(lambda? (lambda))
;-> true


Il metodo di generare funzioni tramite codice viene utilizzato anche per lo sviluppo di "malware", poichè queste funzioni sono "invisibili" ai programmi anti-virus basati su pattern.

Nota: la scrittura di funzioni (auto) modificanti rende il programma difficile da interpretare e da analizzare con il debugger.

Vediamo un altro esempio, una funzione che si comporta come un generatore automodificandosi.

(define (sum (x 0)) (my-inc 0 x))
(define (selfmod x) (setf (last selfmod) (+ (last selfmod) 1)) 0)
;-> (lambda (x) (setf (last selfmod) (+ (last selfmod) 1)) 0)

Vediamo come funziona:

(selfmod)
;-> 1

Adesso rivediamo la definizione della funzione:

selfmod
;-> (lambda (x) (setf (last selfmod) (+ (last selfmod) 1)) 1)
La funzione ha modificato il suo ultimo parametro (dal valore 0 al valore 1).

(selfmod)
;-> 2
selfmod
;-> (lambda (x) (setf (last selfmod) (+ (last selfmod) 1)) 2)

(selfmod)
;-> 3
selfmod
;-> (lambda (x) (setf (last selfmod) (+ (last selfmod) 1)) 3)

Un altro modo di creare un generatore:

(define (selfinc x) (myinc x) 0)
;-> (lambda (x) (myinc x) 0)

(define (myinc x) (inc (last selfinc) x))
;-> (lambda (x) (inc (last selfinc) x))

(selfinc 1)
;-> 1
(selfinc 2)
;-> 3
(selfinc 3)
;-> 6
selfinc
;-> (lambda (x) (myinc x) 6)

Nota: Una funzione definita dall'utente non ha modo di fare riferimento alla funzione da cui è stata invocata, tranne quando ha una sua precedente conoscenza. Quando abbiamo questa necessità, in cui una funzione deve conoscere il nome della chiamante, basta renderla un parametro della chiamata della funzione.


---------------
I cicli (loops)
---------------

In newLISP sono supportati la maggior parte dei metodi di loop tradizionali. Ogni volta che esiste una variabile di loop, è locale nell'ambito del loop, comportandosi secondo le regole di scoping dinamico all'interno dello spazio dei nomi o del contesto corrente:

*** DOTIMES ***
; ripete per un numero di volte
; "i" va da 0 a N - 1
(dotimes (i N)
    ...
)

; dimostra la località di "i"
(dotimes (i 3)
    (print i ":")
    (dotimes (i 3) (print i))
    (println)
)
;-> 0:012
;-> 1:012
;-> 2:012

*** DOLIST ***
; ciclo attraverso una lista
; la variabile "e" prende il valore di ciascun elemento della lista aList
(dolist (e aList)
    ...
)

La funzione "dolist" ha anche una variabile $idx che tiene traccia dell'indice numerico dell'elemento corrente (partendo da 0):

(dolist (e '(a b c d)) (println (list $idx e)))
;-> (0 a)
;-> (1 b)
;-> (2 c)
;-> (3 d)

*** DOSTRING ***
; ciclo attraverso una stringa
; "e" prende il valore numerico ASCII o UTF-8 di ogni carattere della stringa aString
(dostring (e aString)
    ...
)

Per attraversare una stringa possiamo usare anche "dolist" insieme ad "explode".

; ciclo attraverso una stringa
; "e" prende il valore del carattere ASCII o UTF-8 di ogni carattere della stringa aString
(dolist (e (explode aString))
    ...
)

*** DOTREE ***
; ciclo attraverso i simboli di un contesto
; ordinati in ordine alfabetico
(dotree (s CTX)
    ...
)

*** FOR ***
; ciclo che parte da un valore "init",
; termina quando "i" diventa uguale a "N",
; con passo opzionale "step".
; Il segno del passo è irrilevante (dipende solo da N e init)
(for (i init N step)
    ...
)

(for (i 1 9) (print i))
;-> 123456789

(for (i 1 9 2) (print i))
;-> 13579

(for (i 9 1 -2) (print i))
;-> 97531

(for (i 9 1 2) (print i))
;-> 97531

*** WHILE ***
; ciclo finchè una condizione è vera;
; prima controlla la condition, poi esegue il corpo
(while condition
    ...
)

*** UNTIL ***
; ciclo finchè una condizione è falsa;
; prima controlla la condition, poi esegue il corpo
(until condition
    ...
)

*** DO-WHILE ***
; ciclo finchè una condizione è vera;
; prima esegue il corpo poi controlla la condition.
; Il corpo viene eseguito almeno una volta.
(do-while condition
    ...
)

*** DO-UNTIL ***
; ciclo finchè una condizione è falsa;
; prima esegue il corpo poi controlla la condition.
; Il corpo viene eseguito almeno una volta.
(do-until condition
    ...
)

Le funzioni di loop "dolist", "dotimes" e "for" possono anche prendere una condizione di interruzione (break) come argomento aggiuntivo. Quando la condizione di interruzione restituisce true, il ciclo termina:

(dolist (x '(a b c d e f g) (= x 'e))
    (print x))
;->  abcd


---------------------
L'alfabeto web "Leet"
---------------------

L'alfabeto Leet ("Leet") è un altro alfabeto per il linguaggio inglese usato principalmente su internet e sulla messaggistica.
Alcune lettere vengono sosituite con delle cifre. In genre si ha la seguente corrispondenza:

0 = O
1 = I
2 = Z
3 = E
4 = A
5 = S
6 = G
7 = T
8 = B
9 = J

Possiamo scrivere una funzione che converte una stringa in linguaggio Leet.

(setq leet '((O 0) (I 1) (Z 2) (E 3) (A 4) (S 5) (G 6) (T 7) (B 8) (9 J)))

(define (toLeet str)
  (local (out)
    (setq out (explode (upper-case str)))
    (set-ref-all "O" out "0")
    (set-ref-all "I" out "1")
    (set-ref-all "Z" out "2")
    (set-ref-all "E" out "3")
    (set-ref-all "A" out "4")
    (set-ref-all "S" out "5")
    (set-ref-all "G" out "6")
    (set-ref-all "T" out "7")
    (set-ref-all "B" out "8")
    (set-ref-all "J" out "9")
    (join out)
  )
)

(toLeet "Questa frase convertita in Leet")
;-> "QU3574 FR453 C0NV3R7174 1N L337"

Nota che set-ref-all restituisce la stringa modificata oppure nil se non trova una corrispondenza (e quindi non avviene alcuna modifica).

(set-ref-all "C" '("C" "V" "B" "C") "Z")
;-> ("Z" "V" "B" "Z")

(set-ref-all "A" '("C" "V" "B" "C") "Z")
;-> nil

Possiamo scrivere la funzione anche in un altro modo:

(define (toLeet str)
  (local (out)
    (setq out (explode (upper-case str)))
    (dolist (el out)
      (cond ((= el "O") (setq (out $idx) "0"))
            ((= el "I") (setq (out $idx) "1"))
            ((= el "Z") (setq (out $idx) "2"))
            ((= el "E") (setq (out $idx) "3"))
            ((= el "A") (setq (out $idx) "4"))
            ((= el "S") (setq (out $idx) "5"))
            ((= el "G") (setq (out $idx) "6"))
            ((= el "T") (setq (out $idx) "7"))
            ((= el "B") (setq (out $idx) "8"))
            ((= el "J") (setq (out $idx) "9"))
      )
    )
    (join out)
  )
)

(toLeet "Questa frase convertita in Leet")
;-> "QU3574 FR453 C0NV3R7174 1N L337"


----------
Autogrammi
----------

Un autogramma (in greco: αὐτός = sé, γράμμα = lettera) è una frase autodescrittiva nel senso che fornisce la lista dei suoi caratteri. Sono stati inventati da Lee Sallows, che ha anche coniato la parola autogramma. Una caratteristica essenziale è l'uso dei nomi completi dei numeri cardinali come "uno", "due", ecc., nella registrazione dei conteggi dei caratteri. Gli autogrammi sono anche chiamati frasi "auto-enumeranti" o "auto-documentanti". In genere, viene registrato solo il conteggio delle lettere, mentre i segni di punteggiatura vengono ignorati, come in questo esempio (in inglese):

This sentence employs two a's, two c's, two d's, twenty-eight e's, five f's, three g's, eight h's, eleven i's, three l's, two m's, thirteen n's, nine o's, two p's, five r's, twenty-five s's, twenty-three t's, six v's, ten w's, two x's, five y's, and one z.

Se avete tempo potete verificarlo...

Il primo autogramma pubblicato (Sallows 1982) è apparso nella rubrica "Metamagical Themas" di Douglas Hofstadter in Scientific American.

Il compito di produrre un autogramma è intricato e complesso perché l'oggetto da descrivere non può essere conosciuto fino a quando la sua descrizione non è completa.

Per cominciare proviamo a contare le vocali di una frase. Prediamo una frase base con valori iniziali nulli:

(setq a "zero" e "zero" i "zero" o "zero" u "zero")
(setq base '(0 0 0 0 0))
(setq str (string a " a, " e " e, " i " i, " o " o " "e " u " u."))
;-> "zero a, zero e, zero i, zero o e zero u."

Poi contiamo le vocali nella frase:

(setq res (count '("a" "e" "i" "o" "u") (explode str)))
;-> (1 7 1 6 1)

In questo caso: (0 0 0 0 0) != (1 7 1 6 1), cioè i numeri iniziali delle vocali (0 0 0 0 0) non corrispondono a quanto calcolato nella stringa: (1 7 1 6 1).

Quindi la nuova lista base vale:

(setq base res)
;-> (1 7 1 6 1)

Convertiamo questi valori numerici in cifre e ricostruiamo la stringa:

; lista associativa: cifra -> stringa
(setq cifre '((0 "zero") (1 "una") (2 "due") (3 "tre") (4 "quattro")
              (5 "cinque") (6 "sei") (7 "sette") (8 "otto") (9 "nove")))

(setq a (lookup (base 0) cifre))
;-> "una"
(setq e (lookup (base 1) cifre))
;-> "sette"
(setq i (lookup (base 2) cifre))
;-> "una"
(setq o (lookup (base 3) cifre))
;-> "sei"
(setq u (lookup (base 4) cifre))
;-> "una"

(setq str (string a " a, " e " e, " i " i, " o " o " "e " u " u."))
;-> "una a, sette e, una i, sei o e una u."

Poi contiamo le vocali nella frase:

(setq res (count '("a" "e" "i" "o" "u") (explode str)))
;-> (4 5 2 1 4)

Nella stringa ci sono 4 "a", 5 "e", 2 "i" 1 "o" e 4 "u".

In questo caso: (1 7 1 6 1) != (4 5 2 1 4)

Quindi la nuova lista base vale:

(setq base res)
;-> (4 5 2 1 4)

...continuare in questo modo fino a che non si trova una soluzione oppure si entra in un ciclo infinito.

Questo metodo (partendo da (0 0 0 0 0)) genera il seguente ciclo:

 1  (1 7 1 6 1)
 2  (4 5 2 1 4)
 3  (4 4 2 3 6)
 4  (3 5 2 3 4)
 5  (2 6 2 2 4)
 6  (2 6 2 2 5) <--
 7  (1 7 3 1 5)   |
 8  (3 6 2 1 4)   |  Ciclo infinito
 9  (3 5 2 2 4)   |
10  (2 6 2 2 5) <--

La seguente funzione cerca una soluzione e controlla se si entra in un ciclo infinito, inoltre permette di impostare due parametri: i valori della lista iniziale e una stringa all'inizio della frase (che ci permette poi di 'pareggiare i conti'):

(define (autogram start-list init-str)
  (local (a e i o u base res cifre str all)
    (setq found nil)
    (setq ciclo nil)
    (setq all '())
    ; lista associativa: cifra -> stringa
    (setq cifre '((0 "zero") (1 "una") (2 "due") (3 "tre") (4 "quattro")
                  (5 "cinque") (6 "sei") (7 "sette") (8 "otto") (9 "nove")))
    ; lista cifre iniziali
    (setq base start-list)
    ; cifre iniziali
    (setq a (lookup (base 0) cifre))
    (setq e (lookup (base 1) cifre))
    (setq i (lookup (base 2) cifre))
    (setq o (lookup (base 3) cifre))
    (setq u (lookup (base 4) cifre))
    ; fino a che non troviamo una soluzione oppure non troviamo un ciclo...
    (until (or found ciclo)
      ; impostare la stringa
      (setq str (string init-str
            a " a, " e " e, " i " i, " o " o " "e " u " u."))
      ; contare le vocali
      (setq res (count '("a" "e" "i" "o" "u") (explode str)))
      ; se la lista base è uguale alla lista del conteggio -> stop
      ; altrimenti aggiorna i valori dei nuovi conteggi
      (if (= base res) (setq found true) (setq base res))
      (setq a (lookup (base 0) cifre))
      (setq e (lookup (base 1) cifre))
      (setq i (lookup (base 2) cifre))
      (setq o (lookup (base 3) cifre))
      (setq u (lookup (base 4) cifre))
      (println "try: " base)
      ; inserimento lista conteggi per controllo ciclo
      (if (find base all) ; se esiste il conteggio...
        (setq ciclo true) ; allora siamo in un ciclo
        (push base all)   ; altrimenti inserisci conteggio
      )
    )
    (if found (println "sol: " base) (println "ciclo infinito"))
    (println str)
  )
)

(autogram '(0 0 0 0 0) "")
;-> try: (1 7 1 6 1)
;-> try: (4 5 2 1 4)
;-> try: (4 4 2 3 6)
;-> try: (3 5 2 3 4)
;-> try: (2 6 2 2 4)
;-> try: (2 6 2 2 5)
;-> try: (1 7 3 1 5)
;-> try: (3 6 2 1 4)
;-> try: (3 5 2 2 4)
;-> try: (2 6 2 2 5)
;-> ciclo infinito
;-> tre a, cinque e, due i, due o e quattro u.

Potremmo provare con altri valori iniziali, ma in questo caso notiamo che dopo (2 6 2 2 4) troviamo (2 6 2 2 5). Quindi aggiungendo una "u" (per passare da 4 a 5), renderebbe la frase un autogramma. Per fare questo passiamo la seguente stringa iniziale: "Hu! "

(autogram '(0 0 0 0 0) "Hu! ")
;-> try: (1 7 1 6 2)
;-> try: (3 6 2 1 5)
;-> try: (2 6 3 1 5)
;-> try: (2 6 3 1 5)
;-> sol: (2 6 3 1 5)
;-> Hu! due a, sei e, tre i, una o e cinque u.

Abbiamo trovato un'autogramma (anche se con un piccolo trucco):

"Hu! due a, sei e, tre i, una o e cinque u."

Il trucco di aggiungere una stringa iniziale è possibile solo quando tutti i valori delle vocali di una stringa sono minori o uguali a quelli della stringa immediatamente successiva.

"Questa frase ha nove a, una b, sette c, undici d, sedici e, due f, una g, due h, dodici i, una l, sette n, otto o, cinque q, quattro r, sette s, quattordici t, dodici u e due v."

Per ulteriori informazioni: https://en.wikipedia.org/wiki/Autogram

Nota: "QUESTA FRASE HA CINQUE PAROLE" è una frase autoreferenziale.


--------------------------------------------
Ambito dinamico e ambito lessicale (statico)
--------------------------------------------

La nozione di ambito (scope) nei linguaggi di programmazione è tradizionalmente legata a quella delle associazioni (bindings). Un'associazione (binding) è un legame tra un simbolo (o una variabile) e un valore. L'ambito dell'associazione definisce il tipo di"visibilità" del simbolo (o variabile) nel programma e può essere "dinamico" o "lessicale" ("statico").
Secondo l'ambito lessicale (statico), in una espressione, una variabile fa riferimento al costrutto più interno in cui viene dichiarata la variabile (ad esempio, al blocco di codice in cui è definita).
Invece l'ambito dinamico prevede che la variabile esista e possa essere usata solo durante l'estensione dinamica (esecuzione) di una espressione. Una variabile con ambito dinamico viene anche chiamata 'parametro'.
L'associazione dinamica associa i dati all'esecuzione del contesto corrente, e quindi consente di passare i dati alle funzioni senza dover dichiarare esplicitamente questi dati nell'interfaccia della funzione.
Una caratteristica particolare dei binding dinamici è che non sono catturati da una chiusura lessicale (lexical closure). Questo consente alcuni benefici, come la concisione, la modularità e l'adattabilità. Esempi tipici sono il reindirizzamento dell'output di un programma, la definizione di gestori di eccezioni (exception handler), la gestione dello stato dell'host locale in un sistema distribuito, ecc.

newLISP utilizza l'ambito dinamico per la visibilità delle variabili/identificatori, ma può anche usare l'ambito lessicale utilizzando i contesti (context).

In un linguaggio con ambito dinamico è possibile fare riferimento a un identificatore, non solo nel blocco in cui è dichiarato, ma anche in qualsiasi funzione o procedura richiamata dall'interno di quel blocco, anche se la procedura chiamata è dichiarata all'esterno del blocco.

Vediamo un esempio:

(setq x 42)
(define (f x) (g (+ x 2)))
(define (g y) (+ y x))

Quando chiamiamo (f 1) in newLISP accade questo:

(f 1) --> (g (+ 1 2)) --> (g 3) --> (+ 3 1) --> 4

Invece nel linguaggio Scheme (che ha un ambito lessicale) accade questo:

(f 1) --> (g (+ 1 2)) --> (g 3) ---> (+ 3 42) --> 45

In Scheme g può vedere solo la x definita al livello superiore (o qualsiasi livello al di sopra di essa in una definizione nidificata). In newLISP, g vede la x definita "attraverso" la chiamata della funzione applicata f (da cui il termine "dinamico"), poiché quella x è il parametro formale di f.

Vediamo un altro esempio del funzionamento dell'ambito dinamico:

(define (f a b)
  (local (LOC)
    (setq LOC 'dynamic)
    (println "pre f: a -> " a " b -> " b)
    (g a b)
    (println "post f: a -> " a " b -> " b)
  )
)

(define (g x y)
  (println LOC)
  (println "pre g: a -> " a " b -> " b)
  (println "pre g: x -> " x " y -> " y)
  (setq a (* a a))
  (setq b (* b b))
  (setq x (* x x))
  (setq y (* y y))
  (println "post g: a -> " a " b -> " b)
  (println "post g: x -> " x " y -> " y)
)

(f 2 3)
;-> pre f: a -> 2 b -> 3
;-> dynamic               ; "g" vede LOC perchè chiamata dall'interno di "f"
;-> pre g: a -> 2 b -> 3  ; "g" vede "a" perchè chiamata dall'interno di "f"
;-> pre g: x -> 2 y -> 3  ; "g" vede "b" perchè chiamata dall'interno di "f"
;-> post g: a -> 4 b -> 9
;-> post g: x -> 4 y -> 9
;-> post f: a -> 4 b -> 9 ; "f" vede i nuovi valori di "a" e "b".

Questo perchè le variabili libere "a" e "b" sono associate con dei valori nella funzione "f" e l'ambito dinamico permette alla funzione "g" di vedere queste associazioni perchè viene chiamata dall'interno della funzione "f".

Se chiamiamo direttamente la funzione "g" otteniamo un errore:

(g 2 3)
;-> nil                      ; la variabile LOC non esiste
;-> pre g: a -> nil b -> nil ; le variabili "a" e "b" esistono
;-> pre g: x -> 2 y -> 3
;-> ERR: value expected in function * : nil ; errore perchè "a" non esiste.

Questo perchè le variabili libere "a" e "b" non sono associate ad alcun valore e quindi valgono nil.

Ecco un ulteriore esempio:

(define (uno)
  (local (x)
    (setq x 10)
    (due)))

(define (due)
  (local (y)
    (setq y 20)
    (println (+ x y))))

(uno)
;-> 30
x
;-> nil
y
;-> nil

Quando la funzione "uno" chiama la funzione "due" il suo ambito (in particolare il valore della variabile "x") viene passato alla funzione "due". Quindi la funzione "due" conosce sia "x" (che proviene dal contesto di "uno"), sia "y" che è una variabile del proprio contesto.

Il problema dell'ambito dinamico risiede nel fatto, che se usiamo simboli che non sono stati definiti nella nostra funzione, non possiamo sapere se il simbolo è globale oppure è stato "ereditato" da una chiamata di funzione.

Utilizzando i contesti (context) possiamo utilizza l'ambito lessicale anche in newLISP:

(define (f x) (g (+ x 2)))
(context 'g)
(setq x 42)
(define (g:g y) (+ y x))
(context MAIN)
(f 1)

;-> 45

Comunque è molto meglio scrivere funzioni che non hanno variabili "libere" e quindi non occorre creare contesti per queste funzioni.

Ad esempio, si noti che il corpo di g ha due variabili x e y. y è una variabile associata in g, poiché è un parametro formale di g. Tuttavia, x non è associato, ovvero è "libera".

Nelle funzioni non dovrebbero esistere variabili "libere" (devono essere legate a un let o un local), ma nel caso fossero presenti devono riferirsi a variabili globali con nomi racchiusi da asterischi "*" (earmuffing), per evitare di entrare in conflitto con le varibili locali (quelle che entrano nello stack). Per esempio, *MAX-VAL* è una variabile globale (per convenzione).

Questo metodo di programmazione è principio di base della "programmazione strutturata" ed è valido per quasi tutti i linguaggi programmazione.

L'utilizzo dei contesti per avere un ambito lessicale è utile quando si lavora a programmi grandi e/o con un gruppo di programmatori: in questo modo nessuno influisce sul codice degli altri.

Comunque i contesti hanno un proprio ambito dinamico internamente, essi isolano il proprio ambito dinamico rispetto agli altri contesti (in altre parole un contesto è un nuovo spazio di nomi).

Lutz suggerisce anche un altro metodo per utilizzare le variabili globali (e le costanti): inserirle tutte in un contesto. Per esempio:

(set 'Setup:datapath "/home/data")
(set 'Setup:language "english")
(set 'Setup:n-records 12345)

Questo ha anche il vantaggio che tutte le variabili globali e le costanti possono essere salvate/caricate su un file tutte insieme:

Salvataggio variabili e costanti:
(save "setup.lsp" 'Setup)

Caricamento variabili e costanti:
(load "setup.lsp")

L'ambito dinamico costringe il programmatore a scrivere funzioni senza effetti collaterali (side effect).

newLISP comunque permette di utilizzare entrambi gli ambiti: dinamico e lessicale (o statico).

Un libro molto interessante su questo argomento e sul LISP in generale è:
"COMMON LISP: A Gentle Introduction to Symbolic Computation" di David Touretzky.

Alcune raccomandazioni per evitare i problemi dell'ambito dinamico:

(1) Non passare mai simboli quotati alle funzioni. Per passare i riferimenti, utilizzare i  contesti e i funtori di default.

(2) Non utilizzare mai variabili libere all'interno di una funzione, ad eccezione delle variabili chiaramente contrassegnate per l'uso globale da alcune convenzioni di denominazione (ad esempio *earmuffing*).

(3) Inserisci sempre le define-macro nel proprio spazio dei nomi. O ignorale completamente. Non sono una nuova funzionalità essenziale di newLISP.

Seguendo queste tre regole newLISP si comporterà come un linguaggio con ambito lessicale.

Vediamo il perchè della parola "lessicale":
nell'ambito statico, una variabile si riferisce sempre all'associazione di chiusura più vicina (binding). Questa è una proprietà del testo del programma e non è correlata allo stack delle chiamate di runtime. Poiché la corrispondenza di una variabile con l'associazione richiede solo l'analisi del testo del programma, questo tipo di ambito viene chiamato anche "ambito lessicale".

Dal punto di vista storico, newLISP ci comporta come il LISP originale di McCarthy. Poi  Scheme ha introdotto l'ambito lessicale che è stato seguito anche dal Common Lisp (sebbene CL supporti l'ambito dinamico se si dichiarano le variabili locali come speciali). È una delle questioni più controverse nella famiglia dei linguaggi LISP.

Infine riportiamo alcune considerazioni di Lutz:

Per i meno iniziati qui, ecco alcune regole e spiegazioni relative alla cattura delle variabili e ai pericoli percepiti quando non ce ne sono.

- non vi è alcun pericolo di acquisizione di variabili quando si riutilizzano nomi di variabili nelle funzioni nidificate, 'let' ed espressioni di loop nidificati. Tutte le variabili dei parametri vengono salvate internamente su uno stack di ambiente e ripristinate dopo l'uso. Puoi anche fare quanto segue senza pericolo:

(dotimes (i 3) (println "->" i)
    (dotimes (i 3) (println i)))

sebbene il ciclo interno usi lo stesso nome di variabile del ciclo esterno, è totalmente sicuro in newLISP e non sicuro in molte altre lingue.

Lo stesso vale per le funzioni create con 'define'. Anche il seguente codice un pò folle funzionerà perfettamente con 'let' riutilizzando gli stessi nomi di variabili:

(define (foo x y)
   (println x ":" y)
   (let ((x (div x 2)) (y (div y 2)))
      (println x "::" y))
   (println x ":" y))

(foo 3 4)
;-> 3:4
;-> 1.5::2
;-> 3:4
;-> 4 ;restituisce il valore di foo

L'espressione 'let' sa che la x sinistra non è la stessa della x destra. La x sinistra proviene dal 'let' interno e la x destra dal parametro di 'foo'. Dopo aver lasciato 'let' tutto è come prima. Potresti anche chiamare una funzione 'bar' con i nomi dei parametri x e y dall'interno di 'foo' o 'let' e non succederebbe niente di male.

Quando si usano le normali funzioni create con 'define', la cattura variabile può avvenire solo quando si passano simboli tra virgolette. Passare simboli quotati è qualcosa che accade molto raramente in newLISP. Se devi farlo, allora isola quella funzione in un contesto/spazio dei nomi o usa 'args' per recuperare i parametri. Entrambi i metodi sono sicuri contro la cattura delle variabili.

- l'unico vero pericolo di acquisizione variabile si verifica nelle fexpr (define-macro in newLISP). L'uso di qualcosa come "gensym" e "eval" per aggirare il problema funzionerà, ma continuerà a influire sulle prestazioni e ad ogni chiamata verranno creati sempre più simboli da "gensym" e spreco di memoria. Potrebbero essere eliminati dopo l'uso, ma richiederebbero ancora più cicli della CPU. È meglio usare 'args' e non avere alcuna variabile come parametro o racchiudere la macro-funzione e i parametri nel proprio contesto:

(define-macro (foo:foo foo:x foo:y)
   ....
)

; or as an alternative

(context 'foo)
(define-macro (foo x y)
    ...
)
(context MAIN)

; and in either case you can call with the simple name

(foo ...)

'foo' è ora una macro globale (in realtà fexpr) e completamente sicura contro l'acquisizione di variabili, anche quando si passano simboli quoatai. Non si verificano perdite di prestazioni in questo modo, anche quando si scrivono milioni di macro.

- anche qualsiasi altra funzione o macro (fexpr) in un modulo 'foo:this', 'foo:that' è completamente sicuro contro la cattura/confusione variabili, anche quando si passano simboli quotati.

- in ultimo, ma non meno importante: perché newLISP chiama le macro fexprs? Perché dal punto di vista dell'uso vengono utilizzate per ottenere lo stesso risultato: scrivere funzioni che non seguono le solite regole di valutazione dei parametri per la valutazione iniziale di tutti i parametri ma controllano da sole la valutazione dei parametri usando 'eval'. Trovo più utile usare una definizione orientata all'applicazione.'''


----------------------------------
Uso delle espressioni condizionali
----------------------------------

Analizzeremo i metodi consigliati nell'uso delle espressioni: "if", "when", "unless", "cond" e "case".

Quando utilizzare l'espressione "cond"
--------------------------------------
Ci sono alcuni casi in cui "cond" è preferibile ad "if":

1) Quando abbiamo una catena di "if" (skip chain)

sbagliato:

(if condizione1
    esegui-1
    (if condizione-2
        esegui-2
        esegui-3))

giusto:

(cond (condizione-1 esegui-1)
      (condizione-2 esegui-2)
      (true esegui-3)

2) Quando la parte 'then' o 'else' contiene diverse espressioni da valutare (che richiederebbe l'uso di "begin")

sbagliato:

(if condizione-1
    (begin azione-1a
           azione-1b)
    (begin azione-2a
           azione-2b)

giusto:

(cond (condizione-1 esegui-1a esegui-1b)
      (true esegui-2a esegui-2b))

L'espressione "cond" ha una definizione implicita di "begin" per ogni clausola.

3) Quando viene il risultato della condizione rappresenta l'espressione di ritorno

sbagliato:

(let ((val (calcolo-complicato a b c)))
  (if val
      val
      (esegui-altro x y z)))

giusto:

(cond ((calcolo-complicato a b c))
      (true (esegui altro x y z)))

Quando utilizzare l'espressione "case"
--------------------------------------
L'espressione condizionale "case" può essere vista come un caso speciale del condizionale "cond" che risolve il problema di testare il valore di un'espressione con un certo numero di valori costanti (questi valori devono essere costanti perchè non vengono valutati da newLISP).
Il "case" esiste perchè è molto più veloce del cond per questo caso speciale (il compilatore può utilizzare una tabella hash invece di dover testare ogni clausola in sequenza).

sbagliato:

(cond ((= val 1) esegui-1)
      ((= val 2) esegui-2)
      ((= val 3) esegui-3)
      ((= val 4) esegui-4)
      (true esegui-5))

giusto:

(case val
  (1 esegui-1)
  (2 esegui-2)
  (3 esegui-3)
  (4 esegui-4)
  (true esegui-5))

Quando utilizzare l'espressione "when" e "unless"
-------------------------------------------------
Quando l'espressione "if" ha un solo ramo ('then' oppure 'else'), allora è meglio utilizzare "when" o "unless". L'uso di queste due espressioni permettono di risparmiare spazio e rendono il codice più preciso (leggibile).

sbagliato:

(if (un-test a b c)
    (begin (calcolo-1 a b c)
           (calcolo-2 a b c)
           (calcolo-3 a b c)
           ...))

giusto:

(when (un-test a b c)
  (calcolo-1 a b c)
  (calcolo-2 a b c)
  (calcolo-3 a b c)
  ...)

Quando si usa "when" o "unless" la condizione di test non deve essere negata con l'espressione "not".

sbagliato:

(when (not (un-test a b c))
  (calcolo-1 a b c)
  (calcolo-2 a b c)
  (calcolo-3 a b c)
  ...)

giusto:

(unless (un-test a b c)
  (calcolo-1 a b c)
  (calcolo-2 a b c)
  (calcolo-3 a b c)
  ...)

L'uso del test "null?" è consigliato nel caso seguente:

sbagliato:

(when (rest lst))
  (calcolo-1 a b c)
  (calcolo-2 a b c)
  (calcolo-3 a b c)
  ...)

giusto:

(unless (null? (rest lst))
  (calcolo-1 a b c)
  (calcolo-2 a b c)
  (calcolo-3 a b c)
  ...)

Ricordiamo che in newLISP "nil" è diverso dalla lista vuota '():

(= nil '())
;-> nil

Ma si comportano allo stesso modo con l'espressione di test "null?":

(if (null? '()) (println "nullo") (println "non nullo"))
;-> nullo
(if (null? nil) (println "nullo") (println "non nullo"))
;-> nullo
(if (null? 0) (println "nullo") (println "non nullo"))
;-> nullo


------------------------------
select e unselect (antiselect)
------------------------------

Prendiamo dal manuale la definizione della funzione built-in "select":

********************
>>>funzione SELECT
********************
sintassi: (select list list-selection)
sintassi: (select list [int-index_i ... ])

Nelle prime due forme, "select" seleziona uno o più elementi dall'elenco utilizzando uno o più indici specificati dalla list-selection o da int-index_i.

(set 'lst '(a b c d e f g))

(select lst '(0 3 2 5 3))
;-> (a d c f d)

(select lst '(-2 -1 0))
;-> (f g a)

(select lst -2 -1 0)
;-> (f g a)

Nelle seconde due forme, "select" seleziona uno o più caratteri dalla stringa utilizzando uno o più indici specificati dalla list-selection o da int-index_i.

(set 'str "abcdefg")

(select str '(0 3 2 5 3))
;-> "adcfd"

(select str '(-2 -1 0))
;-> "fga"

(select str -2 -1 0)
;-> "fga"

Gli elementi selezionati possono essere ripetuti e non devono apparire in ordine, sebbene ciò acceleri l'elaborazione. L'ordine in list-selection o int-index_i può essere modificato per riorganizzare gli elementi.

Ecco un altro esempio:

(select { ILPSaegilnouw} '(1 9 0 9 8 10 7 12 5 7 7 8 11 0 10 6 13 2 1 4 3))
;-> "Il linguaggio newLISP"

Adesso vediamo la funzione opposta "unselect" che elimina dalla lista "lst" gli elementi che hanno gli indici elencati dalla lista "sel": (unselect lst sel)

(setq lst '(a b c d nil f))

Funzione proposta da newbert:

(define (unselect1 lst sel)
  (select lst (difference (sequence 0 (- (length lst) 1)) sel)))

(unselect1 lst '(1 2))
;-> (a d nil f)

Funzione proposta da fdb:

(define (unselect2 lst sel)
    (select lst (difference (sequence 0 (dec (length lst))) sel)))

(unselect2 lst '(1 2))
;-> (a d nil f)

Funzione proposta da ralph.ronnquist:

(define (unselect3 lst sel) (let (n -1) (clean (fn (x) (member (inc n) sel)) lst)))

(unselect3 lst '(1 2))
;-> (a d nil f)

Vediamo quale funzione è più veloce:

(setq lista '(a b c d nil f g h i j k l m n o p q r s t nil v w x y nil))

(setq sel '(3 7 5 4 7 9 11 3 22 25 4 0 7 13 20 19 18 20 25))

(unselect1 lista sel)
;-> (b c g i k m o p q r v x y)

(unselect2 lista sel)
;-> (b c g i k m o p q r v x y)

(unselect3 lista sel)
;-> (b c g i k m o p q r v x y)

(time (unselect1 lista sel) 100000)
;-> 430.979

(time (unselect2 lista sel) 100000)
;-> 425.475

(time (unselect3 lista sel) 100000)
;-> 1225.691


------------
Generatori 1
------------

Un generatore è una funzione che produce un risultato diverso (generalmente in sequenza) ogni volta che viene chiamata.
Per fare questo occorre ricordare/memorizzare lo stato corrente della funzione. Per questo scopo si usa un contesto (context) che contiene la funzione (funtore del contesto) e i dati necessari. In altra parole si tratta di una funzione con memoria.

(define (gen:gen)
  (setq gen:sum
    (if gen:sum (inc gen:sum) 1)))

Questo potrebbe essere scritto più brevemente, perché "inc" considera nil come zero:

(define (gen:gen)
  (inc gen:sum))

(gen)
;-> 1
(gen)
;-> 2

Quando si scrive gen:gen, viene creato un context chiamato "gen". Questo è uno spazio di nomi (namespace) lessicale contenente i propri simboli usati come variabili e come funzioni. In questo caso il nome-spazio "gen" contiene due simboli: "gen" (funzione/funtore) e "sum" (variabile).
Il primo simbolo di un contesto ha lo stesso nome del contesto in cui è contenuto e viene chiamato "funtore" di default del contesto. In questo caso il contesto si chiama "gen" e quindi il funtore si chiama "gen". Quando si utilizza un nome di contesto al posto di un nome di funzione, newLISP assume il funtore predefinito. Quindi possiamo chiamare la nostra funzione generatore usando (gen). Non è necessario chiamare la funzione usando (gen:gen), (gen) verrà impostato automaticamente su (gen:gen).

Possiamo aggiungere altre funzioni al contesto "gen", ad esempio una funzione che inizializza il generatore:

(define (gen:init x)
  (setq gen:sum x))

(gen:init -1)
;-> -1

(gen)
;-> 0

(gen)
;-> 1

Possiamo usare anche un'altro metodo:

(define (foo:foo x) (if x (set 'foo:sum x)) (inc foo:sum))

(foo)
;-> 1
(foo)
;-> 2
(foo 10)
;-> 11
(foo)
;-> 12
(foo 8)
;-> 9
foo:sum
;-> 9

Queso metodo è meglio perché non è necessario scrivere funzioni aggiuntive per accedere alla somma.Inoltre foo:sum porta in primo piano il qualificatore 'foo'. Infine, ma non meno importante, questo è più facile da capire di una chiusura (closure).

Adesso proviamo a scrivere un generatore di numeri primi.

Prima definiamo la funzione che verifica se un numero è primo:

(define (primo:isprime? n)
  (if (< n 2) nil
    (= 1 (length (factor n)))))

Poi scriviamo la funzione che inizializza il valore dello stato della funzione (cioè la funzione che imposta il valore di partenza della funzione):

(define (primo:start x)
  (setq primo:val x))

Una funzione per verificare il valore dello stato:

(define (primo:print-val) primo:val)

Infine scriviamo la funzione/funtore del contesto "primo" (il parametro "dir" può assumere true o nil e specifica se generare il  primo successivo oppure il primo precedente):

(define (primo:primo dir)
  (local (found num)
    (setq found nil)
    (if (null? dir)
      (setq num (+ primo:val 1))
      (setq num (- primo:val 1))
    )
    (until found
      (if (primo:isprime? num)
          (setq primo:val num found true)
      )
      (if (null? dir)
        (++ num)
        (-- num)
      )
    )
    primo:val
  )
)

Proviamo il tutto:

(primo:start 13)
;-> 13

(primo:print-val)
;-> 13

(primo:isprime? 13)
;-> true

(primo)
;-> 17

(primo)
;-> 19

(primo)
;-> 23

(primo true)
;-> 19

(primo true)
;-> 17

(primo)
;-> 19

Nota: quando programmiamo con i contesti è utile analizzare i simboli che sono stati definiti con la seguente funzione:

(define (simboli contesto)
  (dotree (el contesto) (println el)))

(simboli primo)
;-> primo:isprime?
;-> primo:primo
;-> primo:print-val
;-> primo:start
;-> primo:val

Nota: quando la situazione diventa "caotica" è possibile (consigliato) chiudere la REPL corrente e rilanciare una nuova REPL (per avere tutti i simboli di default).


------------
Generatori 2
------------

In newLISP le funzioni sono oggetti di prima classe (cioè possono essere assegnati alle variabili, passati e/o restituiti da una funzione e possono essere modificati da codice). Questa caratteristica permette di scrivere un altro tipo di generatori utilizzando una funzione automodificante. Supponiamo di avere una funzione somma/accumulatore del tipo seguente:

(setq a 0)
(define (somma (x a)) (inc a x))
;-> (lambda ((x a)) (inc a x))

Se chiamiamo la funzione senza parametri otteniamo il valore di "a":

(somma)
;-> 0

Se chiamiamo la funzione con un parametro otteniamo la somma di "a" e del parametro (che viena assegnata ad "a"):

(somma 3)
;-> 3
a
;-> 3

(somma 2)
;-> 5
a
;-> 5

newLISP ci permette di sostituire il simbolo "a" con il simbolo "0":

(define (somma (x 0)) (inc 0 x))
;-> (lambda ((x 0)) (inc 0 x))

(somma)
;-> 0

(somma 1)
;-> 1

(somma 5)
;-> 6

(somma 15)
;-> 21

Per capire meglio questo metodo analizziamo come è cambiata la funzione "somma" dopo la sua esecuzione:

somma
;-> (lambda ((x 0)) (inc 21 x))

Il simbolo iniziale "0" è stato modificato dalla funzione stessa nel valore della somma "21". Questo processo viene eseguito durante la valutazione e l'espansione dei parametri che vengono applicati al corpo della funzione.

Un altro esempio di generatore utilizza la funzione "expand" per creare funzioni che effettuano lo stream (flusso) di liste o di stringhe:

(define (make-stream lst)
    (letex (stream lst)
        (lambda () (pop 'stream))))
;-> (lambda (lst)
;->  (letex (stream lst) (lambda () (pop 'stream))))

(set 'lst '(a b c d e f g h))

Adesso definiamo la funzione di stream sulla lista "lst":

(define mystream (make-stream lst))
;-> (lambda () (pop '(a b c d e f g h)))

Attiviamo lo stream degli elementi:

(mystream)
;-> a
(mystream)
;-> b
(mystream)
;-> c
Poiché pop funziona sia con le liste che con le stringh, la stessa funzione generatrice può essere utilizzata per generare uno stream di stringhe:

(setq str "abcddefgh")

(define mystream (make-stream str))
;-> (lambda () (pop '"abcddefgh"))

(mystream)
;-> "a"
(mystream)
;-> "b"


-------------------------------
Shift logico e Shift aritmetico
-------------------------------

Shift = Spostamento

Lo shift logico e lo shift aritmetico sono operazioni di manipolazione dei bit (operazioni bitwise).

Shift Logico
------------

Uno "shift logico sinistro" sposta ogni bit di una posizione a sinistra. Il bit meno significativo libero (LSB) viene riempito con zero e il bit più significativo (MSB) viene scartato.

              MSB                         LSB
             +---+---+---+---+---+---+---+---+
scartato <-- | 1 | 0 | 1 | 1 | 0 | 0 | 1 | 1 | <-- 0
             +---+---+---+---+---+---+---+---+
                  /   /   /   /   /   /   /
                 /   /   /   /   /   /   /
                /   /   /   /   /   /   /
             +---+---+---+---+---+---+---+---+
             | 0 | 1 | 1 | 0 | 0 | 1 | 1 | 0 |
             +---+---+---+---+---+---+---+---+

Uno "shift logico destro" sposta ogni bit di una posizione a destra. Il bit meno significativo (LSB) viene scartato e il bit più significativo (MSB) che è vuoto viene riempito con zero.

              MSB                         LSB
             +---+---+---+---+---+---+---+---+
             | 1 | 0 | 1 | 1 | 0 | 0 | 1 | 1 | --> scartato
             +---+---+---+---+---+---+---+---+
                \   \   \   \   \   \   \
                 \   \   \   \   \   \   \
                  \   \   \   \   \   \   \
             +---+---+---+---+---+---+---+---+
       0 --> | 0 | 1 | 0 | 1 | 1 | 0 | 0 | 1 |
             +---+---+---+---+---+---+---+---+

Shift Aritmetico
----------------

Uno "shift aritmetico sinistro" sposta ogni bit di una posizione a sinistra. Il bit meno significativo  (LSB)  che è vuoto viene riempito con zero e il bit più significativo (MSB) viene scartato. È identico allo shift logico sinistro.

              MSB                         LSB
             +---+---+---+---+---+---+---+---+
scartato <-- | 1 | 0 | 1 | 1 | 0 | 0 | 1 | 1 | <-- 0
             +---+---+---+---+---+---+---+---+
                  /   /   /   /   /   /   /
                 /   /   /   /   /   /   /
                /   /   /   /   /   /   /
             +---+---+---+---+---+---+---+---+
             | 0 | 1 | 1 | 0 | 0 | 1 | 1 | 0 |
             +---+---+---+---+---+---+---+---+

Uno "shift aritmetico destro" sposta ogni bit di una posizione verso destra. Il bit meno significativo (LSB) viene scartato e il bit più significativo (MSB) che è vuoto viene riempito con il valore dell'MSB precedente (ora spostato di una posizione verso destra).

              MSB                         LSB
             +---+---+---+---+---+---+---+---+
             | 1 | 0 | 1 | 1 | 0 | 0 | 1 | 1 | --> scartato
             +---+---+---+---+---+---+---+---+
               |\   \   \   \   \   \   \
               | \   \   \   \   \   \   \
               |  \   \   \   \   \   \   \
             +---+---+---+---+---+---+---+---+
             | 1 | 1 | 0 | 1 | 1 | 0 | 0 | 1 |
             +---+---+---+---+---+---+---+---+

In newLISP viene implementato solo lo "shift aritmetico" (quindi manca solo lo shift logico destro).

Vediamo la definizione delle operazioni di Shift dal manuale:

********************
>>>funzione << e >>
********************
sintassi: (<< int-1 int-2 [int-3 ... ])
sintassi: (>> int-1 int-2 [int-3 ... ])
sintassi: (<< int-1)
sintassi: (>> int-1)

Il numero int-1 viene shiftato (spostato) aritmeticamente verso sinistra o verso destra dal numero di bit dato da int-2, quindi shiftato da int-3 e così via. Ad esempio, gli interi a 64 bit possono essere spostati fino a 63 posizioni. Quando si sposta a destra, il bit più significativo viene duplicato (shift aritmetico):

(>> 0x8000000000000000 1)  → 0xC000000000000000  ; not 0x0400000000000000!

(<< 1 3)      →  8
(<< 1 2 1)    →  8
(>> 1024 10)  →  1
(>> 160 2 2)  → 10

(<< 3)        →  6
(>> 8)        →  4

Quando int-1 è l'unico argomento << e >> shifta int-1 di un bit.

Le operazioni di shift aritmetico possono essere utilizzate per dividere o moltiplicare un numero  intero.

Moltiplicazione con lo shift a sinistra
---------------------------------------
Il risultato di un'operazione di shift a sinistra è una moltiplicazione per 2^n, dove n è il numero di posizioni di bit shiftate.

Esempio:

10 * 2 = 20
(<< 10)
;-> 20

-3 * 4 = -12
(<< -3 2)
;-> -12

Divisione con lo shift a destra
-------------------------------
Il risultato di un'operazione di shift a destra è una divisione per 2^n, dove n è il numero di posizioni di bit shiftate.

Esempio:

10 / 2 = 5
(>> 10)
;-> 5

-20 / 4 = -5
(>> -20 2)
;-> -5


----------------------
fold-left e fold-right
----------------------

La funzione generica "fold" rappresenta il modello base di ricorsione su una lista. Anche se newLISP non ha l'ottimizzazione della ricorsione di coda (tail recursion) è interessante e utile capire il funzionamento di questa funzione.

Supponiamo di voler sommare una lista di numeri (1 2 3 4). Il modo più immediato è il seguente:

1 + 2 + 3 + 4

In altre parole, abbiamo inserito l'operatore "+" in mezzo ad ogni elemento. Valutiamo l'espressione:

((1 + 2) + 3) + 4

(3 + 3) + 4

6 + 4  ==>  10

La funzione "fold-left" fa esattamente questo: prende una procedura che ha due parametri, un valore iniziale e una lista. Nel nostro caso la procedura è "+", il valore iniziale è 0 e la lista è (1 2 3 4). La lista iniziale viene "ripiegata" (fold) a "sinistra" (left), quindi si parte dall'ultima elemento della lista e si procede verso sinistra (questo non è un problema perchè l'operazione di somma gode della proprietà associativa a + b = b + a).

Vediamo un esempio di applicazione della funzione "fold-left" in termini di s-espressioni in notazione prefissa:

(fold-left + '(1 2 3 4) 0)

(+ 4 (+ 3 (+ 2 (+ 1 0))))

(+ 4 (+ 3 (+ 2 1)))

(+ 4 (+ 3 3))

(+ 4 6)  ==>  10

Il valore iniziale è importante perchè se la lista di input è vuota, allora questo è il valore che ritorna la funzione "fold-left".

(fold-left + '() 0)  ==>  0

Così possiamo definire una funzione somma in termini di "fold-left":

(define (somma lst) (fold-left + lst 0))

(somma '(1 2 3 4))   ==>  10

(somma '())          ==>  0

La procedura "fold-left" riduce la lista ad un singolo valore.

Vediamo un altro esempio di utilizzo della funzione "fold-left" con i seguenti parametri:

valore iniziale -> lista vuota '()
procedura       -> cons

Eseguiamo la valutazione della seguente espressione:

(fold-left cons '(1 2 3) '())

(cons 3 (cons 2 (cons 1 '())))

(cons 3 (cons 2 '(1)))

(cons 3 '(2 1))

==> '(3 2 1)

Il risultato è l'inversione della lista di input.

Vediamo l'implementazione della funzione "fold-left":

(define (fold-left func lst init)
    (if (null? lst) init
        (fold-left func (rest lst) (func (first lst) init))))

Proviamo a verificare gli esempi:

(fold-left + '(1 2 3 4) 0)
;-> 10

(fold-left + '() 0)
;-> 0

(fold-left cons '(1 2 3) '())
;-> (3 2 1)

Altri esempi:

(fold-left - '(1 2 3 4) 0)
;-> 2
(- 4 (- 3 (- 2 (- 1 0))))
(- 4 (- 3 (- 2 (1))))
(- 4 (- 3 1))
(- 4 2)  ==>  2

(fold-left - '(4 3 2 1) 0)
;-> -2
(- 1 (- 2 (- 3 (- 4 0))))
(- 1 (- 2 (- 3 4)))
(- 1 (- 2 (- 1)))
(- 1 3)  ==> -2

La funzione "fold-left" ha una sorella chiamata "fold-right" che "ripiega" la lista a destra, cioè dal primo valore della lista all'ultimo.

(define (fold-right func lst end)
    (if (null? lst) end
        (func (first lst) (fold-right func (rest lst) end))))

Se la lista è vuota, restituire il valore finale end. In caso contrario, applicare la funzione al primo elemento della lista e al risultato del "folding" di questa funzione e del valore finale verso il resto della lista. Poiché l'operando di destra viene piegato per primo, abbiamo un "folding"  associativo a destra.

Per la maggior parte delle operazioni associative come + e *, "fold-left" e "fold-right" sono completamente equivalenti. Tuttavia, esiste almeno un'importante operazione binaria che non è associativa: cons. Per tutte le nostre funzioni di manipolazione di liste, quindi, dovremo scegliere tra il "folding" associativo sinistro e destro.

Rivediamo la funzione "fold-left":

(define (fold-left func lst init)
    (if (null? lst) init
        (fold-left func (rest lst) (func (first lst) init))))

Questa inizia allo stesso modo della versione associativa di destra, con il test per la lista vuota che restituisce il valore iniziale (accumulatore). Questa volta, tuttavia, applichiamo la funzione all'accumulatore e al primo elemento della lista, invece di applicarla al primo elemento e al risultato del folding della lista. Ciò significa che elaboriamo prima l'inizio, generando una  associatività a sinistra. Una volta raggiunta la fine della lista '(), restituiamo il risultato che abbiamo progressivamente accumulato.

Si noti che func prende i suoi argomenti nell'ordine opposto da "fold-right". In "fold-right", l'accumulatore (end) rappresenta l'ultimo valore da utilizzare dopo il folding della lista. In "fold-left", l'accumulatore (init) rappresenta il calcolo completato per la parte a sinistra della lista. Al fine di preservare la commutatività degli operatori, l'accumulatore deve essere l'argomento a sinistra della nostra operazione in "fold-left", ma l'argomento a destra in "fold-right".

(fold-right - '(1 2 3 4) 0)
;-> -2
(- 1 (- 2 (- 3 (- 4 0))))
(- 1 (- 2 (- 3 4)))
(- 1 (- 2 -1))
(- 1 3) ==> -2

(fold-right - '(4 3 2 1) 0)
;-> 2

La funzione "fold-right" con operatore "cons" e lista vuota '() come valore iniziale, produce una copia della lista:

(fold-right cons '(4 3 2 1) '())
;-> (4 3 2 1)

Possiamo anche definire una funzione "unfold" che è l'opposto di "fold". Data una funzione unaria, un valore iniziale e un predicato unario, "unfold" continua ad applicare la funzione all'ultimo valore fino a quando il predicato è vero, costruendo una lista mentre procede.

(define (unfold func init pred)
  (if (pred init)
      (cons init '())
      (cons init (unfold func (func init) pred))))

Se il predicato è vero, allora "cons" la lista vuota '() sull'ultimo valore, terminando la lista. Altrimenti, "cons" il risultato di "unfolding" del valore successivo (func init) con il valore corrente.

Esempi:

(unfold (fn(x) (* x x)) 2 (fn(x) (> (* x x) 100)))
;-> (2 4 16)

(unfold (fn(x) (sqrt x)) 64 (fn(x) (< x 2)))
;-> (64 8 2.82842712474619 1.681792830507429)

La funzione "fold" (left e right) è una funzione universale, nel senso che ci permette di generare molte altre funzioni. Vediamo alcuni esempi:

Inversione di una lista:

(define (inverte lst) (fold-left cons lst '()))
(inverte '(4 3 2 1))
;-> (1 2 3 4)

Somma degli elementi di una lista:

(define (somma lst) (fold-left + lst 0))
(somma '(1 3 -2 3))
;-> 5

Moltiplicazione degli elementi di una lista:

(define (moltiplica lst) (fold-left * lst 1))
(moltiplica '(1 3 -2 3))
;-> -18

Operatore AND agli elementi di una lista:

(define (and-lst lst) (fold-left and lst true))
(and-lst '(true true nil))
;-> nil
(and-lst '(true true true))
;-> true

Operatore OR agli elementi di una lista:

(define (or-lst lst) (fold-left or lst nil))
(or-lst '(true true nil))
;-> true
(or-lst '(nil nil))
;-> nil

Valore massimo degli elementi di una lista:

(define (max-lst lst)
  (fold-left (fn (old cur) (if (> old cur) old cur)) (rest lst) (first lst)))
(max-lst '(1 3 3 4 8 3 2 4))
;-> 8

Valore minimo degli elementi di una lista:

(define (min-lst lst)
  (fold-left (fn (old cur) (if (< old cur) old cur)) (rest lst) (first lst)))
(min-lst '(1 3 3 4 8 3 2 4))
;-> 1

Lunghezza di una lista:

Pensiamo in termini di definizione di un ciclo. L'accumulatore inizia da 0 e viene incrementato di 1 ad ogni iterazione. Questo ci dà sia il nostro valore di inizializzazione, 0, sia la nostra funzione (fn (x y) (+ x 1)). Un altro modo di vedere questo è "La lunghezza di una lista vale 1 + la lunghezza della sotto-lista alla sua sinistra".

(define (lunghezza lst) (fold-left (fn (x y) (+ x 1)) lst 0))
(lunghezza '(1 2 3 5 8 4 6))
;-> 7

Filtraggio degli elementi di una lista:

Questa funzione mantiene solo gli elementi di una lista che soddisfano un predicato, eliminando tutti gli altri.

(define (filtra pred lst) (fold-right (fn (x y) (if (pred x) (cons x y) y)) lst '()))
(filtra (fn (x) (> x 5)) '(1 45 34 2 3 6))
;-> 45 34 6

Viene testato il valore corrente rispetto al predicato. Se è vero, sostituisce "cons" con "cons", cioè non cambia nulla. Se è falso, elimina il "cons" e restituisce il resto dell'elenco. Questo elimina tutti gli elementi che non soddisfano il predicato, creando una nuova lista che include solo quelli che lo soddisfano.

Nota: la chiave per programmare con il metodo "fold" è pensare solo in termini di ciò che accade ad ogni iterazione. Questo metodo cattura il modello di ricorsione in una lista e i problemi ricorsivi si risolvono meglio lavorando un passo alla volta.

Le stesse due funzioni possono essere scritte anche in modo leggermente diverso. Infatti sono scambiati i parametri (func --> op, init --> base, lst --> xs):

(define (fold-left op base xs)
  (if (null? xs)
      base
      (fold-left op (op base (car xs)) (cdr xs))))

(define (fold-right op base xs)
  (if (null? xs)
      base
      (op (car xs) (fold-right op base (cdr xs)))))

Il metodo Fold utilizza una funzione specificata dall'utente per ridurre una lista di valori a un singolo valore e rappresenta uno delgi idiomi fondamentali della programmazione funzionale. "Fold-left" lavora da sinistra a destra attraverso l'elenco xs, applicando la funzione binaria op alla base e al primo elemento di xs, quindi applicando la funzione binaria op al risultato della prima funzione op e del secondo elemento di xs, e così via, applicando ad ogni passo la funzione binaria op al risultato della precedente funzione op e all'elemento corrente di xs. "fold-right" funziona allo stesso modo, ma da destra a sinistra.


-----------------------
La divisione di Feynman
-----------------------

Ecco un puzzle proposto da Feynman: Divisione lunga.

Ogni punto "." (dot) rappresenta una cifra (qualsiasi cifra da 0 a 9). Ogni "A" rappresenta la stessa cifra (ad esempio, un 3). Nessuno dei punti "." ha lo stesso valore di "A" (cioè, nessun punto "." può valere 3 se "A" vale 3).

    ....A..   | .A.
    ..AA      |------
    ----      | ..A.
     ...A     |
      ..A     |
    -----     |
      ....    |
      .A..    |
      ----    |
       ....   |
       ....   |
       ----   |
          .   |

Per risolvere il problema possiamo pensare di lavorare al contrario, cioè calcolare il valore del prodotto tra il risultato e il divisore e sottoponendolo ad alcuni vincoli.

Per cominciare inseriamo le variabili (A, b, c, d, e, f) per il divisore e il risultato:

  il divisore vale:  ".A."  --> bAc
  il risultato vale: "..A." --> deAf

Quindi calcoliamo il valore (bAc * deAf) = "....A.."

Alcune considerazioni che trasformiamo in vincoli:

1) Il valore cercato ha sette cifre.

2) Il valore A è diverso da b, c, d, e, f.

3) La prima linea della divisione implica che d * bAc deve valere AA modulo 100.

4) La seconda linea della divisione implica che e * bAc deve valere A modulo 10.

5) La terza linea della divisione implica A * bAc è un numero con quattro cifre e la seconda cifra deve essere A.

(define (feynman)
  (local (a b c d e f m1 m2)
    (for (a 0 9)
      (for (b 0 9)
        (for (c 0 9)
          (for (d 0 9)
            (for (e 0 9)
              (for (f 0 9)
                ; calcoliamo i due numeri del prodotto
                ; (moltiplicando e moltiplicatore)
                (setq m1 (+ (* b 100) (* a 10) c))
                (setq m2 (+ (* d 1000) (* e 100) (* a 10) f))
                ; impostiamo i vincoli
                        ; A è diverso dalle altre cifre
                (if (and (!= a b) (!= a c) (!= a d) (!= a e) (!= a f)
                        ; il prodotto ha sette cifre
                          (< 999999 (* m1 m2) 10000000)
                        ; il quinto numero deve valere A
                          (= (int ((explode (string (* m1 m2))) 4)) a)
                        ; d * bAc deve valere AA modulo 100
                          (= (% (* d m1) 100) (+ (* a 10) a))
                        ; e * bAc deve valere A modulo 10
                          (= (% (* e m1) 10) a)
                        ; A * bAc deve avere quattro cifre
                          (< 999 (* a m1))
                        ; la seconda cifra di A * bAc deve valere A
                          (= (int ((explode (string (* a m1))) 1)) a)
                    )
                    (println (list b a c) { * } (list d e a f))
                )))))))))

(feynman)
;-> (4 3 7) * (9 9 3 9)
;-> (4 8 4) * (7 2 8 9)
;-> (4 8 4) * (7 7 8 9)

Non abbiamo una soluzione unica, quindi dobbiamo inserire altri vincoli. Prima di fare questo verifichiamo il primo risultato per vedere se stiamo procedendo con la giusta logica:

(* 437 9939)
;-> 4343343

(* bAc deAf)

; Impostiamo le cifre
(setq b 4 a 3 c 7 d 9 e 9 f 9)
; Calcoliamo i due fattori (moltiplicando e moltiplicatore)
(setq m1 (+ (* b 100) (* a 10) c))
;-> 437
(setq m2 (+ (* d 1000) (* e 100) (* a 10) f))
;-> 9939

; Applichiamo i vincoli:
; A è diverso dalle altre cifre
(and (!= a b) (!= a c) (!= a d) (!= a e) (!= a f))
;-> true
; il prodotto ha sette cifre
(< 999999 (* m1 m2) 10000000)
;-> true
; il quinto numero deve valere A
(= (int ((explode (string (* m1 m2))) 4)) a)
;-> true
; d * bAc deve valere AA modulo 100
(= (% (* d m1) 100) (+ (* a 10) a))
;-> true
; e * bAc deve valere A modulo 10
(= (% (* e m1) 10) a)
;-> true
; A * bAc deve avere quattro cifre
(< 999 (* a m1))
;-> true
; la seconda cifra di A * bAc deve valere A
(= (int ((explode (string (* a m1))) 1)) a)
;-> true

Per ora, sembra che sia tutto corretto.
Un altro vincolo viene osservando che "e" deve essere inferiore a "d", poiché (e * bAc) è un numero di tre cifre, ma (d * bAc) è un numero di quattro cifre. Questo si traduce nella seguente espressione: (< e d).

Riscriviamo la funzione con il nuovo vincolo:

(define (feynman)
  (local (a b c d e f m1 m2)
    (for (a 0 9)
      (for (b 0 9)
        (for (c 0 9)
          (for (d 0 9)
            (for (e 0 9)
              (for (f 0 9)
                ; calcoliamo i due numeri del prodotto
                ; (moltiplicando e moltiplicatore)
                (setq m1 (+ (* b 100) (* a 10) c))
                (setq m2 (+ (* d 1000) (* e 100) (* a 10) f))
                ; impostiamo i vincoli
                        ; A è diverso dalle altre cifre
                (if (and (!= a b) (!= a c) (!= a d) (!= a e) (!= a f)
                        ; il prodotto ha sette cifre
                          (< 999999 (* m1 m2) 10000000)
                        ; il quinto numero deve valere A
                          (= (int ((explode (string (* m1 m2))) 4)) a)
                        ; d * bAc deve valere AA modulo 100
                          (= (% (* d m1) 100) (+ (* a 10) a))
                        ; e * bAc deve valere A modulo 10
                          (= (% (* e m1) 10) a)
                        ; A * bAc deve avere quattro cifre
                          (< 999 (* a m1))
                        ; la seconda cifra di A * bAc deve valere A
                          (= (int ((explode (string (* a m1))) 1)) a)
                        ; "e" deve essere minore di "d"
                          (< e d)
                    )
                    (println (list b a c) { * } (list d e a f) { -> }
                             (list a b c d e f))
                )))))))))

(feynman)
;-> (4 8 4) * (7 2 8 9) -> (8 4 4 7 2 9)

(* 484 7289)
;-> 3527876

Quindi la divisione finale è la seguente:

3527876   | 484
3388      |------
----      | 7289
 1398     |
  968     |
-----     |
  4307    |
  3872    |
  ----    |
   4356   |
   4356   |
   ----   |
      0   |


----------------------------------------
Il linguaggio di programmazione Fractran
----------------------------------------

Fractran è un linguaggio di programmazione esoterico Turing-completo inventato dal matematico John Conway. Un programma Fractran è una lista ordinata di frazioni positive e un numero intero positivo iniziale n. Il programma viene eseguito aggiornando l'intero n come segue:

1) per la prima frazione f nell'elenco per cui n*f è un numero intero, sostituire n con n*f

2) ripetere questa regola fino a quando nessuna frazione dell'elenco produce un numero intero se moltiplicata per n, quindi arrestarsi.

Nel 1987 Conway ha scritto il seguente programma per generare i numeri primi:

(17/91 78/85 19/51 23/38 29/33 77/29 95/23 77/19 1/17 11/13 13/11 15/14 15/2 55/1)

A partire da n = 2, questo programma genera la seguente sequenza di numeri interi:

2, 15, 825, 725, 1925, 2275, 425, 390, 330, 290, 770, ...

Dopo 2, questa sequenza contiene le seguenti potenze di 2:

2^2 = 4, 2^3 = 8, 2^5 = 32, 2^7 = 128, 2^11 = 2048
2^13 = 8192, 2^17 = 131072, 2^19 = 5244288, ...

in cui le potenze rappresentano i numeri primi.

Rappresentiamo il programma Fractran come una lista:

(setq primegame '((17L 91L) (78L 85L) (19L 51L) (23L 38L) (29L 33L)
(77L 29L) (95L 23L) (77L 19L) (1L 17L) (11L 13L) (13L 11L) (15L 14L) (15L 2L) (55L 1L)))

La funzione "fractran" prende il programma e un valore iniziale e restituisce il prossimo valore oppure si ferma se non viene trovato alcun valore intero.

(define (fractran prog n)
  (local (value stop)
    (setq stop nil)
    (dolist (el prog stop)
      (setq value (/ (* (first el) n) (last el)))
      (cond ((null? prog) (setq stop true))
            ((= 0 (% (* (first el) n) (last el)))
                (setq stop true))))
    value))

Nota: Poichè i numeri superano presto il limite degli interi a 64 bit dobbiamo utilizzare i big-integer.

La funzione "run" esegue l'intero programma fractran:

(define (run program start step)
  (dotimes (x step)
    (println start)
    (setq start (fractran program start)))
  'stop)

Proviamo ad eseguire il programma fractran:

(run primegame 2L 10)
;-> 2L
;-> 15L
;-> 825L
;-> 725L
;-> 1925L
;-> 2275L
;-> 425L
;-> 390L
;-> 330L
;-> 290L
;-> stop

Per estrarre i numeri primi occorre verificare se un dato numero intero è una potenza di due.

Definiamo due funzione "ipow" (calcola la potenza intera di un numero) e "ilog" (calcola il logaritmo intero di un numero):

(define (ipow x n)
  (cond ((zero? n) 1)
        ((even? n) (ipow (* x x) (/ n 2)))
        (true (* x (ipow (* x x) (/ (- n 1) 2))))))

(define (ilog n b)
  (if (zero? n) -1
    (+ (ilog (/ n b) b) 1L)))

Un numero n è potenza di due se risulta:

(= n (ipow 2 (ilog n 2)))

(= 1122 (ipow 2 (ilog 1122 2)))
;-> nil
(= 4096 (ipow 2 (ilog 4096 2)))
;-> true

Adesso possiamo scrivere la funzione "run2" che estre i numeri primi:

(define (run2 program start step)
  (dotimes (x step)
    (if (= start (ipow 2 (ilog start 2)))
      (print (ilog start 2) {, }))
    (setq start (fractran program start)))
  'stop)

Eseguiamo il programma per generare i numeri primi:

(run2 primegame 2L 1e6)
;-> 1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, stop

Conway è un ragazzo molto "cattivo" :-)

Da ralph.ronnquist:

(define (run2 program start step)
  (dotimes (x step)
    (let (b (bits x))
       (or (find "1" (1 b)) (print (dec (length b)) ", ")))
    (setq start (fractran program start)))
  'stop)

(run2 primegame 2 100)
;-> 0, 0, 1, 2, 3, 4, 5, 6 stop
(run2 primegame 2 1e6)
;-> 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, stop

Purtroppo la funzione "bits" non funziona con i big integer.

Allora usiamo la seguente funzione:

; Compute "bits" for bigint and int
(constant 'MAXINT (pow 2 62))
(define (prep s) (string (dup "0" (- 62 (length s))) s))
(define (bitsL n)
    (if (<= n MAXINT) (bits (int n))
      (string (bitsL (/ n MAXINT))
              (prep (bits (int (% n MAXINT)))))))


----------------------------
La funzione map semplificata
----------------------------

Definiamo una funzione che simula la funzione "map". Per semplificare esaminiamo solo la situazione unaria, cioè scriveremo una funzione "mappa" che applica una funzione unaria (es. sin, log, ecc.) ad una sola lista.

(define (mappa func lst)
  (if (null? lst) '()
      (cons (func (first lst)) (mappa func (rest lst)))))

(mappa sin '(3 4 5))
;-> (0.1411200080598672 -0.7568024953079282 -0.9589242746631385)

(mappa sqrt '(4 9 25))
;-> (2 3 5)

Possiamo anche applicare una funzione lambda definita dall'utente:

(mappa (fn(x) (* x x)) '(2 3 5))
;-> (4 9 25)


-----------------------------------------------
Generazione della documentazione con newLISPdoc
-----------------------------------------------

Vediamo come sia possibile generare automaticamente la documentazione per le funzioni (sorgenti) di un modulo creato dall'utente.
Supponiamo di voler creare un modulo con due funzioni per la conversione da gradi Celsius a gradi Fahrenheit e viceversa.

Questo è il contenuto del file "doc-demo.lsp":

;; @module doc-demo.lsp
;; @author X Y, xy@doc-demo.com
;; @version 1.0
;;
;; Questo modulo è un esempio per mostrare
;; il funzionamento del programma newlispdoc
;; che genera automaticamente documentazione
;; per i sorgenti newLISP.

;; @syntax (demo:celsius->fahrenheit gradi-celsius)
;; @param <gradi-celsius> valore in gradi Celsius.
;; @return restituisce il valore in gradi Fahrenheit.
;;
;; La funzione 'celsius->fahrenheit' converte
;; i gradi Celsius in gradi Fahrenheit.
;;
;; @example
;; (celsius->fahrenheit 0)        ==> 32
;; (celsius->fahrenheit 100)      ==> 212
;; (celsius->fahrenheit -273.15)  ==> -459.67

; Creiamo le funzioni in un nuovo contesto
(context 'demo)

(define (celsius->fahrenheit gradi-celsius)
  (add (div (mul gradi-celsius 9) 5) 32))

;; @syntax (demo:fahrenheit->celsius gradi-fahrenheit)
;; @paramn <gradi-fahrenheit> valore in gradi Fahrenheit.
;; @return restituisce il valore in gradi Celsius.
;;
;; The function 'celsius->fahrenheit' converte
;; i gradi Celsius in gradi Fahrenheit.
;;
;; @example
;; (fahrenheit->celsius 32)       ==> 0
;; (fahrenheit->celsius 212)      ==> 100
;; (fahrenheit->celsius -459.67)  ==> -273.15

(define (fahrenheit->celsius gradi-fahrenheit)
  (div (mul (sub gradi-fahrenheit 32) 5) 9))

; Ritorniamo al contesto principale
(context MAIN)
; eof ;

Adesso creiamo una cartella (es. doc-demo) in cui copiamo questo file "doc-demo.lsp" e il file "newlispdoc" (c:\newlisp\util\newlispdoc). Poi apriamo il Command Prompt, ci posizioniamo sulla cartella, e digitiamo la seguente riga di comando:

newlisp newlispdoc doc-demo.lsp

Adesso nella cartella troviamo anche i file "index.html" e "doc-demo.lsp.html" che sono la documentazione al nostro modulo.

Se digitiamo il seguente comando:

newlisp newlispdoc -s doc-demo.lsp

viene creato anche il file "doc-demo.lsp.src.html" che è il sorgente (evidenziato) del nostro modulo in formato HTML.

Per maggiori informazioni consultare l'Appendice su newlispdoc.

Per testare il nostro modulo dobbiamo prima caricarlo nella sessione di newLISP:

(load "doc-demo.lsp")
MAIN

Adesso possiamo usare le due funzione definite nel modulo:

(demo:fahrenheit->celsius 32)
;-> 0

(demo:celsius->fahrenheit 100)
;-> 212


-----------------------
Ancora sui numeri primi
-----------------------

Queste sono cinque funzioni simili che verificano se un numero è primo.

(define (primo? n)
   (if (< n 2) nil
       (= 1 (length (factor n)))))

(define (primoa? n)
  ; il numero viene considerato primo
  ; fino a che non troviamo un divisore preciso
  (setq out true)
  (cond ((<= n 3) (setq out true))
        ((or (= (% n 2) 0) (= (% n 3) 0)) (setq out nil))
        (true (setq i 5)
              (while (and (<= (* i i) n) out)
                (if (or (= (% n i) 0) (= (% n (+ i 2)) 0)) (setq out nil))
                (setq i (+ i 6))
              ))) out)

(define (primob? n)
  (local (idx step out)
    (setq out true)
    (cond ((or (= n 2) (= n 3)) true)
          ((or (< n 2) (= (% n 2) 0) (= (% n 3) 0)) nil)
          (true
            (setq idx 5 step 2)
            (while (and (<= (* idx idx) n) out)
              (if (= 0 (% n idx)) (setq out nil))
              (setq idx (+ idx step))
              (setq step (- 6 step ))
            )
            out))))

(define (primoc? n)
  (local (r f test)
    (setq test true)
    (cond ((= n 1) nil)
          ((< n 4) true) ; 2 e 3 sono primi
          ((even? n) nil)
          ;((= (% n 2) 0) nil)
          ((< n 9) true) ; abbiamo già escluso 4,6 e 8
          ((= (% n 3) 0) nil)
          (true
              (setq r (floor (sqrt n)))
              (setq f 5)
              (while (and test (<= f r))
                (if (= (% n f) 0) (setq test nil))
                (if (= (% n (+ f 2)) 0) (setq test nil))
                (++ f 6)
              )
              test))))

(define (primod? n)
  (let ((out true)
        (i 0)
        (w 0)
        (r 0))
    (cond ((= n 1) (setq out nil))
          ((= n 2) (setq out true))
          ((= n 3) (setq out true))
          ((zero? (% n 2)) (setq out nil))
          ((zero? (% n 3)) (setq out nil))
          (true
            (setq i 5)
            (setq w 2)
            (setq r (floor (sqrt n)))
            (while (and out (<= i r))
              (if (zero? (% n i)) (setq out nil))
              (++ i w)
              (setq w (- 6 w))
            )
          )
    )
   out))

Controlliamo che le funzioni diano i risultati corretti:

(= (map primo? (sequence 2 500000)) (map primoa? (sequence 2 500000)))
;-> true
(= (map primo? (sequence 2 500000)) (map primob? (sequence 2 500000)))
;-> true
(= (map primo? (sequence 2 500000)) (map primoc? (sequence 2 500000)))
;-> true
(= (map primo? (sequence 2 500000)) (map primod? (sequence 2 500000)))
;-> true

Vediamo la velocità delle funzioni:

(time (map primo? (sequence 1 1000000)))
;-> 1109.48
(time (map primoa? (sequence 1 1000000)))
;-> 3984.891
(time (map primob? (sequence 1 1000000)))
;-> 6172.891
(time (map primoc? (sequence 1 1000000)))
;-> 3552.159
(time (map primod? (sequence 1 1000000)))
;-> ;-> 5063.098

La funzione più veloce è quella che usa la funzione "factor".

Se invece dobbiamo calcolare i primi n numeri primi, una routine ad hoc è più veloce dell'utilizzo di "factor", perchè non dobbiamo fattorizzare il numero, ma ci fermiamo quando troviamo un divisore del numero:

(define (primi-fino1 n)
  (setq lst '(2))
  (for (i 3 n 2)
    (if (primo? i) (push i lst -1))) lst)

(define (primi-fino2 n)
   (setq arr (array (+ n 1)) lst '(2))
   (for (x 3 n 2)
      (when (not (arr x))
         (push x lst -1)
         (for (y (* x x) n (* 2 x) (> y n))
            (setf (arr y) true)))) lst)

(= (primi-fino1 1000000) (primi-fino2 1000000))
;-> true

(time (primi-fino1 1e6))
;-> 656.265
(time (primi-fino2 1e6))
;-> 203.137

La funzione che non usa "factor" è più veloce.

Infine, una funzione di Kazimir Majorinc per calcolare quanti numeri primi ci sono fino a n.

(setq sieve (lambda(size)
              (let ((flags (array (+ size 1)))
                    (sqrtsize (sqrt size))
                    (total 0))
                   (for (i 2 sqrtsize)
                     (when (not (flags i))
                           (for (k (* i i) size i)
                             ;(nth-set (flags k) 0))
                             (setf (flags k) 0))
                           (inc total)))
                   (for (i (+ sqrtsize 1) size)
                     (unless (flags i)
                             (inc total)))
                   total)))

(sieve 10)
;-> 4
(sieve 100)
;-> 25
(sieve 1000)
;-> 168
(sieve 10000)
;-> 1229
(sieve 1e7)
;-> 664579


----------------------------------------
Un algoritmo: matrice con somme positive
----------------------------------------

Supponiamo di avere una matrice N x M di numeri interi positivi e negativi. Le operazioni possibili sono:
1) cambiare di segno a tutti i numeri di una riga
2) cambiare di segno a tutti i numeri di una colonna

Determinare (se esiste) un algoritmo che utilizzando soltanto le operazioni 1) e 2) rende positiva la somma di ogni riga e ogni colonna della matrice (consideriamo positiva una somma con valore zero).

In genere un algoritmo è un insieme finito di operazioni possibili applicati ad una "situazione iniziale" per trasformarla in una "situazione finale" (quella desiderata).

Quando sviluppiamo un algoritmo dobbiamo rispondere alle seguenti domande:

1) Esiste un insieme finito di operazioni che risolve il problema?

2) Qual'è l'insieme di operazioni che risolve il problema?

Durante l'applicazione delle operazioni la "situazione iniziale" cambia stato numerose volte prima di raggiungere (eventualmente) la "situazione finale": come possiamo essere certi che ogni stato successivo è "migliore" di quello precedente? Quanto ci avviciniamo alla soluzione ad ogni passo?

Nota: per evitare il Paradosso di Zenone (tanti piccoli passi che diminuiscono di valore e non raggiungono mai la meta finale), si può definire un valore minimo P di miglioramento che deve essere affettuato ad ogni passo.

Per il nostro problema possiamo fare la seguente osservazione:

Se una riga (o colonna) ha una somma negativa, allora cambiando il segno a tutti i numeri di quella riga (o colonna) la somma diventa positiva, ma modifichiamo anche le somme delle altre colonne (righe).

Come possiamo essere sicuri di aver migliorato la situazione dopo ogni passo (cioè dopo aver cambiato di segno ad una riga o ad una colonna)?

Per rispondere a questa domanda pensiamo alla somma di tutti i numeri della matrice. Questa è uguale alla somma delle righe o alla somma delle colonne:

ST = Somma Totale = Somma delle Righe = Somma delle Colonne

Quando modifichiamo una riga con somma negativa -S, otteniamo una riga con somma S. Quindi incrementiamo la Somma Totale (ST) di un valore pari a 2*S. Poichè esiste un numero finito di valori di ST (al massimo 2^(n+m)) e ST aumenta sempre ogni volta che cambiamo una riga (o una colonna) negativa, allora dobbiamo per forza raggiungere, alla fine, una situazione in cui tutte le somme delle righe e delle colonne sono positive.

L'algoritmo quindi esiste ed è il seguente:

Per ogni riga (o colonna) della matrice:
se la somma è negativa, allora invertire il segno di tutti i numeri (che rende la somma positiva)

Scriviamo adesso le funzioni necessarie per risolvere il problema.

Genera un numero intero casuale n nell 'intervallo [a..b] (cioè, a <= n <= b):

(define (rand-range a b)
  (if (> a b) (swap a b))
  (+ a (rand (+ (- b a) 1)))
)

Genera una matrice N x M con numeri interi casuali compresi tra "a" e "b":

(define (genera-matrice m n a b)
  (array m n (map (fn(x) (rand-range a b)) (sequence 1 (* a b)))))

(setq m (genera-matrice 5 4 -10 10))
;-> ((2 3 7 7) (3 5 1 -3) (-7 5 1 9) (-5 -7 2 4) (2 -3 0 -9))

(setq m '((2 3 7 7) (3 5 1 -3) (-7 5 1 9) (-5 -7 2 4) (2 -3 0 -9)))

Calcola la somma della riga di una matrice (passate come argomento):

(define (sum-row matrice riga) (apply + (matrice riga)))

(sum-row m 0)
;-> 19

Calcola la somma della colonna di una matrice (passate come argomento):

(define (sum-col matrice col) (apply + ((transpose matrice) col)))

(sum-col m 0)
;-> -5

Cambia il segno di ogni numero della riga di una matrice (passate come argomento):

(define (flip-row matrice riga)
  (for (i 0 (- (length (matrice riga)) 1))
    (setf (matrice riga i) (- (matrice riga i)))) matrice)

(setq m (flip-row m 2))
;-> ((2 3 7 7) (3 5 1 -3) (7 -5 -1 -9) (-5 -7 2 4) (2 -3 0 -9))

Cambia il segno di ogni numero della riga di una matrice (passate come argomento):

(define (flip-col matrice col)
  (for (i 0 (- (length matrice) 1))
    (setf (matrice i col) (- (matrice i col)))) matrice)

(setq m (flip-col m 0))
;-> ((-2 3 7 7) (-3 5 1 -3) (-7 -5 -1 -9) (5 -7 2 4) (-2 -3 0 -9))

Controlla se una matrice ha somma positiva per tutte le righe e tutte le colonne:

(define (check-sum matrice)
    (let (out true)
      (for (i 0 (- (length matrice) 1)) ; righe
        (if (< (sum-row matrice i) 0) (setq out nil)))
      (for (i 0 (- (length (matrice 0)) 1)) ; colonne
        (if (< (sum-col matrice i) 0) (setq out nil)))
      out))

(check-sum m)
;-> nil

La funzione finale che risolve il problema:

(define (solve matrice)
  (until (check-sum matrice)
    (print 'r)
    (for (i 0 (- (length matrice) 1)) ; righe
      (if (< (sum-row matrice i) 0) (setf matrice (flip-row matrice i))))
    (print 'c)
    (for (i 0 (- (length (matrice 0)) 1)) ; colonne
      (if (< (sum-col matrice i) 0) (setf matrice (flip-col matrice i)))))
    matrice)

(setq m (genera-matrice 5 4 -10 10))
;-> ((1 -3 10 3) (-7 -3 -8 5) (9 2 -10 -4) (-9 3 -8 7) (8 2 5 7))

(setq m '((1 -3 10 3) (-7 -3 -8 5) (9 2 -10 -4) (-9 3 -8 7) (8 2 5 7)))

(setq sol (solve m))
;-> rc((1 3 10 3) (7 -3 8 -5) (-9 2 10 4) (9 3 8 -7) (8 -2 5 7))

(check-sum sol)
;-> true

Con matrici più grandi dobbiamo invertire diverse righe e colonne prima di arrivare alla soluzione:

(setq m (genera-matrice 50 40 -1000 1000))
(silent (setq sol (solve m)))
;-> rcrcrcrc

(check-sum sol)
;-> true

Il numero di inversioni dipende dal numero delle righe, dal numero delle colonne e dal valore dei numeri della matrice (non credo che sia facilmente calcolabile a priori).


------------------
Dadi e probabilità
------------------

Quesito 1
---------
In media, quante volte occorre lanciare un dado prima di ottenere tutti i sei i numeri?

Dal punto di vista matematico il numero medio di lanci vale:

  6   6   6   6   6   6
  - + - + - + - + - + - = 14.7
  6   5   4   3   2   1

(add (div 6 6) (div 6 5) (div 6 4) (div 6 3) (div 6 2) (div 6 1)) = 14.7

Vediamo di simulare l'evento con alcune funzioni:

Funzione per il lancio di un dado:

(define (dado num-dadi num-facce)
  (+ num-dadi (apply + (rand num-facce num-dadi))))

(dado 1 6)
;-> 5

Funzione che conta quante volte bisogna lanciare il dado prima di ottenere tutti i valori:

(define (num-lanci)
  (let ((lst (dup 0 7)) (num 0))
    (until (= (apply + lst) 6)
      (setf (lst (dado 1 6)) 1)
      (++ num))
    num))

(num-lanci)
;-> 18

Funzione che calcola la media del numero dei lanci:

(define (solve iter)
  (let (somma 0)
    (for (i 1 iter)
      (setq somma (+ somma (num-lanci))))
    (div somma iter)))

Proviamo a vedere se otteniamo lo stesso valore (14.7):

(solve 1000)
;-> 14.546

(solve 100000)
;-> 14.69487

(solve 1000000)
;-> 14.703081

Quesito 2
---------
In media, quante volte occorre lanciare contemporaneamente 6 dadi prima di ottenere una mano con tutti i numeri (1,2,3,4,5 e 6) in qualunque ordine?

Dal punto di vista matematico il numero medio di lanci vale:

1   6*5*4*3*2*1
- = ----------- = 0.0154321  ==> n = 64.8
n   6*6*6*6*6*6

(div (pow 6 6) (apply * '(1 2 3 4 5 6))) = 64.8

Vediamo di simulare l'evento con alcune funzioni.

Funzione che conta quante volte bisogna lanciare il dado prima di ottenere tutti i valori:

(define (num-lanci6)
  (let ((lst (dup 0 7)) (num 0))
    (until (= (apply + lst) 6)
      (setq lst (dup 0 7))
      (setf (lst (dado 1 6)) 1)
      (setf (lst (dado 1 6)) 1)
      (setf (lst (dado 1 6)) 1)
      (setf (lst (dado 1 6)) 1)
      (setf (lst (dado 1 6)) 1)
      (setf (lst (dado 1 6)) 1)
      (++ num))
    num))

(num-lanci6)
;-> 18

Funzione che calcola la media del numero dei lanci:

(define (solve6 iter)
  (let (somma 0)
    (for (i 1 iter)
      (setq somma (+ somma (num-lanci6))))
    (div somma iter)))

Proviamo a vedere se otteniamo lo stesso valore (64.8):

(solve6 1000)
;-> 64.477

(solve6 10000)
;-> 63.9149

(solve6 100000)
;-> 64.81573

(solve6 500000)
;-> 64.810948


--------------------
Test Vettori e Liste
--------------------

Creazione di un vettore di 10000 elementi:

(silent (setq vet (array 10000 (sequence 0 9999))))
(length vet)
;-> 10000

Creazione di una lista associativa con 10000 elementi:

(silent (setq lst (map list (sequence 0 9999) (sequence 0 9999))))
(length lst)
;-> 10000

Genera un numero casuale in [a..b]:

(define (rand-range a b)
  (if (> a b) (swap a b))
  (+ a (rand (+ (- b a) 1))))

Test accesso sequenziale:

(time (dolist (el vet) (setq x el)) 1000)
;-> 439.966

(time (dolist (el lst) (setq x el)) 1000)
;-> 995.0391314

Test accesso random:

(time (for (i 0 (- (length vet) 1)) (setq x (vet (rand-range 0 9999)))) 1000)
;-> 3452.562

(time (for (i 0 (- (length lst) 1)) (setq x (assoc (rand-range 0 9999) lst))) 1000)
;-> 204534.455

Modifica di una lista on-place:

(silent (setq lst (sequence 0 9999)))
(time (dolist (el lst) (setf (lst $idx) (* el 2))) 100)
;-> 8299.447

Modifica di un vettore on-place con "dolist":

(silent (setq vet (array 10000 (sequence 0 9999))))
(time (dolist (el vet) (setf (vet $idx) (* el 2))) 100)
;-> 91.947

Modifica di un vettore on-place con "for":

(silent (setq vet (array 10000 (sequence 0 9999))))
(time (for (i 0 (- (length vet) 1)) (setf (vet i) (* (vet i) 2))) 100)
;-> 93.917
Nota: stessa velocità di "dolist", ma con "for" facciamo due accessi ad ogni elemento del vettore (vet i).

Modifica di una lista con lista di appoggio:

(setq lst (sequence 0 9999))
(setq out '())
(time (dolist (el lst) (push (* el 2) out -1)) 1000)
;-> 768.231

Modifica di una lista con "map":

(setq lst (sequence 0 9999))
(time (map (fn(x) (* x 2)) lst) 1000)
;-> 940.893

Somma elementi di una lista con "dolist":

(setq lst (sequence 0 9999))
(setq somma 0)
(time (dolist (el lst) (++ somma el)) 1000)
;-> 555.431

Somma elementi di un vettore con "dolist":

(silent (setq vet (array 10000 (sequence 0 9999))))
(setq somma 0)
(time (dolist (el vet) (++ somma el)) 1000)
;-> 552.455

Somma elementi di un vettore con "for":

(silent (setq vet (array 10000 (sequence 0 9999))))
(setq somma 0)
(time (for (i 0 (- (length vet) 1)) (++ somma (vet i))) 1000)
;-> 620.386

Somma elementi di una lista con "apply":

(setq lst (sequence 0 9999))
(time (apply + lst) 1000)
;-> 169.736

Nota: le funzioni "map" e "apply" non sono applicabili ai vettori.


----------------------------------
Un motore per espressioni regolari
----------------------------------

Nel libro "The Practice of Programming" di Rob Pike e Brian Kernighan viene presentato un programma che implementa un interessante motore per le espressioni regolari.

Il programma gestisce le seguenti regole per le espressioni regolari:

    c    matches any literal character c
    .    matches any single character
    ^    matches the beginning of the input string
    $    matches the end of the input string
    *    matches zero or more occurrences of the previous character

Per maggiori informazioni potete riferirvi all'articolo "A Regular Expression Matcher" disponibile sul web:

https://www.cs.princeton.edu/courses/archive/spr09/cos333/beautiful.html

Sul forum di newLISP rickiboy ha pubblicato una versione del programma in newLISP.

Riportiamo questo elegante programma (grazie rickiboy):

Funzioni ausiliarie:

(define-macro (second)
  (letex (xs (args 0)) (if (> (length xs) 1) (xs 1))))

(define (some pred coll) (and (exists pred coll) true))

Codice del motore per le espressioni regolari:

(define (tails coll)
  (map (curry slice coll) (sequence 0 (- (length coll) 1))))

(define (matchstar c regexp text)
  (some (curry matchhere regexp)
        (filter (fn (xs) (or (= c (first xs)) (= "." c) (empty? xs)))
                (tails text))))

(define (matchhere regexp text)
  (if (empty? regexp) true
      (= "*" (second regexp)) (matchstar (first regexp) (slice regexp 2) text)
      (= "$" regexp) (empty? text)
      (empty? text) false
      (= "." (first regexp)) (matchhere (rest regexp) (rest text))
      (= (first regexp) (first text)) (matchhere (rest regexp) (rest text))))

(define (match* regexp text)
  (if (= "^" (first regexp))
      (matchhere (rest regexp) text)
      (some (curry matchhere regexp) (tails text))))

Vediamo alcuni esempi:

(match* "^a" "apro")
;-> true

(match* ".a" "apro")
;-> nil

(match* "a" "apro")
;-> true

(match* ".ro" "apro")
;-> true

(match* "^a..i" "appi")
;-> true

(match* "f*" "ffi")
;-> true

Veramente impressionante.


---------------------------------
Insiemi (set) senza reinserimento
---------------------------------

Definire una struttura insieme che non permette di aggiungere elementi già cancellati. Ad esempio:
lista = (1 2 3 4 5)
(set-add 3) --> lista = (1 2 3 4 5) ; elemento già presente
(set-add 8) --> lista = (1 2 3 4 5 8)
(set-del 5) --> lista = (1 2 3 4 8)
(set-add 5) --> lista = (1 2 3 4 8) ; elemento cancellato

Definiamo due liste, una contiene gli elementi esistenti e una contiene gli elementi cancellati.

(setq items '())
(setq deleted '())

Funzione per aggiungere gli elementi:

(define (set-add el)
  ;se l'elemento è presente oppure è stato cancellato...
  (if (or (find el items) (find el deleted))
      nil ; non fare nulla
      (push el items -1)) ; altrimenti, aggiunge l'elemento al set
  items)

Funzione per cancellare gli elementi:

(define (set-del el)
  (let (idx -1)
    ; se l'elemento è stato cancellato...
    (if (find el deleted)
        nil ; non fare nulla
        ; se l'elemento si trova nella lista...
        (if (setq idx (find el items))
            ;(pop items (find el items))
            ; eliminalo al set e aggiungilo ai cancellati
            (begin (pop items idx) (push el deleted -1))
            ; altrimenti non fare nulla
            nil))
    items))

Aggiungiamo 10 numeri (0..9) alla lista items:

(dotimes (x 10) (set-add x))
;-> (0 1 2 3 4 5 6 7 8 9)

Cancelliamo i numeri 3 e 5:

(set-del 3)
;-> (0 1 2 4 5 6 7 8 9)

(set-del 5)
;-> (0 1 2 4 6 7 8 9)

Aggiungiamo 15 numeri (0..14):

(dotimes (x 15) (set-add x))
;-> (0 1 2 4 6 7 8 9 10 11 12 13 14)


-------------------------------
Funzioni con parametri nominali
-------------------------------

Possiamo passare dei parametri nominali ad una funzione con la seguente tecnica:

(define (func-par)
  (let (x nil y nil)
    (apply set (args))
    (println "x = " x ", y = " y)))

Possiamo chiamare la funzione soltanto con i parametri x e y:

(func-par 'x 1 'y 2)
;-> x = 1, y = 2

Infatti con altri parametri otteniamo nil:

(func-par 'a 1 'b 2)
;-> x = nil, y = nil

Però possiamo inserire x e y in qualunque ordine:

(func-par 'y 2 'x 1)
;-> x = 1, y = 2

Nota: non possiamo usare "setq" al posto di "set" perchè i parametri non devono essere valutati.

Potremmo usare anche una macro:

(define-macro (funcpar)
  (let (x nil y nil)
    (apply set (args))
    (println "x = " x ", y = " y)))

(funcpar x 1 y 2)
;-> x = 1, y = 2

(funcpar a 1 b 2)
;-> x = nil, y = nil

(funcpar y 2 x 1)
;-> x = 1, y = 2


-------------------------
la funzione COMMAND-EVENT
-------------------------

**************************
>>>funzione COMMAND-EVENT
**************************
sintassi: (command-event sym-event-handler | func-event-handler)
sintassi: (command-event nil)

Specifica una funzione definita dall'utente per la preelaborazione della riga di comando newLISP prima che venga valutata. Questo può essere usato per scrivere shell di newLISP interattive personalizzate e per trasformare richieste HTTP durante l'esecuzione in modalità server.

command-event accetta il simbolo di una funzione definita dall'utente o una funzione lambda. La funzione del gestore eventi (event-handler) deve restituire una stringa oppure la riga di comando verrà passata non tradotta a newLISP.

Per forzare solo un prompt e disabilitare l'elaborazione dei comandi, la funzione deve restituire la stringa vuota "". Per ripristinare il comando-evento, utilizzare la seconda sintassi.

L'esempio seguente fa funzionare la shell newLISP come una normale shell Unix quando il comando inizia con una lettera. Ma iniziando la linea con una parentesi aperta o uno spazio avvia la valutazione di newLISP.

(command-event (fn (s)
	(if (starts-with s "[a-zA-Z]" 0) (append "!" s) s)))

Vedere anche la funzione correlata "prompt-event" che può essere utilizzata per personalizzare ulteriormente la modalità interattiva modificando il prompt newLISP.

Il seguente programma può essere utilizzato autonomo o incluso nel file di avvio init.lsp di newLISP:

#!/usr/local/bin/newlisp

; set the prompt to the current directory name
(prompt-event (fn (ctx) (append (real-path) "> ")))

; pre-process the command-line
(command-event (fn (s)
    (if
        (starts-with s "cd")
        (string " " (true? (change-dir (last (parse s " ")))))
        (starts-with s "[a-zA-Z]" 0)
        (append "!" s)
        true s)))

Nella definizione della funzione di traduzione della riga di comando, il comando "cd" Unix riceve un trattamento speciale, per assicurarsi che la directory venga cambiata  anche per il processo newLISP. In questo modo quando utilizziamo un comando shell con "!" al ritorno, newLISP manterrà il cambio della directory.

Le righe di comando per newLISP devono iniziare con uno spazio o una parentesi aperta.
I comandi Unix devono iniziare all'inizio della riga.
Si noti che la lunghezza della riga di comando e la lunghezza della riga nelle intestazioni HTTP sono limitate a 512 caratteri in newLISP.

Esempio presentato da Cormullion sul forum di newLISP:

(define (show l)
  (map (fn (f)
    (println (format {%s is %s} (map string (select (facts f) '(0 1)))))) l))

(define-macro (is a b)
  (cond
    ((= a 'who)   (show (ref-all (list '? b) facts match)))
    ((= a 'what)  (show (ref-all (list b '?) facts match)))
    (true         (push (list (sym a) (sym b)) facts))))

(command-event (fn (s)
   (if (find "is " s)
       (string {(is } (replace {is } s {}) {)})
       s)))
;-> $command-event

Adesso possiamo scrivere nella REPL:

mike is tall
;-> ((mike tall))
john is tall
;-> ((john tall) (mike tall))
peter is old
;-> ((peter old) (john tall) (mike tall))
john is old
;-> ((john old) (peter old) (john tall) (mike tall))
what is john
;-> john is old
;-> john is tall
;-> ("john is old" "john is tall")
john is smart
;-> ((john smart) (john old) (peter old) (john tall) (mike tall))
what is john
;-> john is tall
;-> ("john is smart" "john is old" "john is tall")
who is smart
;-> john is smart
;-> ("john is smart")
who is old
;-> john is old
;-> peter is old
;-> ("john is old" "peter is old")
mike is old
;-> ((mike old) (john smart) (john old) (peter old) (john tall) (mike tall))
who is old
;-> mike is old
;-> john is old
;-> peter is old
;-> ("mike is old" "john is old" "peter is old")

Questo funziona come un preprocessore all'interno di un gestore eventi. Quindi, praticamente, il codice tratta tratta "x IS y" come dati e li trasforma in qualcosa di più leggibile.

----------------------------
Massimo Comun Divisore (MCD)
----------------------------
MCD - Massimo Comune Divisore
GCD - Greatest Common Divisor

Vediamo alcune funzioni per calcolare il MCD:

(define (gcd1_ a b)
  (let (r (% b a))
    (if (= r 0) a (gcd1_ r a))))

(define-macro (my-gcd1) (apply gcd1_ (args) 2))

Questo è un semplice algoritmo non ottimizzato per la velocità. Uno migliore è il seguente:

(define (gcd2_ x y , r)
  (while (> y 0)
    (setq r (% x y))
    (if (> r (>> y 1))(setq r (- y r)))
    (setq x y y r)
  )
  x
)

(define-macro (my-gcd2) (apply gcd2_ (args) 2))

Uno ancora migliore è l'algoritmo binario con spostamento a destra. Il codice originale è in linguaggio C preso da un libro di teoria dei numeri, quella che segue è la traduzione in newLISP:

(define (gcd3_ x y , g t)
  (setq g 0)
  (while (~ (& (| x y) 1))
    (setq x (>> x 1)
          y (>> y 1)
          g (+ g 1)
    )
  )
  (while (~ (& x 1))(setq x (>> x 1)))
  (while (~ (& y 1))(setq y (>> y 1)))
  (while (!= x y)
    (if (< x y)
        (setq t x x y y t))
    (setq x (- x y))
    (while (~ (& x 1))
        (setq x (>> x 1)))
  )
  (<< x g)
)

Tuttavia, quando eseguiamo questo programma rimaniamo bloccati in un ciclo infinito.

Probabilmente il ciclo infinito si trova nelle seguenti espressioni:

(while (~ (& x 1))(setq x (>> x 1)))
(while (~ (& y 1))(setq y (>> y 1)))

oppure qui:

(while (~ (& (| x y) 1))

Il linguaggio C considera lo 0 (zero) com un falso logico e il ciclo while esce quando il valore vale 0. In newLISP lo 0 è invece un vero logico, e "~" (tilde) è una negazione binaria (bit flip), non logica. Quindi le espressioni sopra dovrebbero essere scritte nel modo seguente:

(while (= 0 (& x 1)) ...)

oppure:

(while (zero? (& x 1)) ...)

Quindi la versione finale è questa:

(define (gcd3_ x y , g t)
  (setq g 0)
  (while (zero? (& (| x y) 1))
    (setq x (>> x 1)
          y (>> y 1)
          g (+ g 1)
    ))
  (while (zero? (& x 1))(setq x (>> x 1)))
  (while (zero? (& y 1))(setq y (>> y 1)))
  (while (!= x y)
    (if (< x y)
        (setq t x x y y t))
    (setq x (- x y))
    (while (zero? (& x 1))
        (setq x (>> x 1))))
  (<< x g)
)

(gcd3_ 2018478412740 21241241994)
;-> 6

(define-macro (my-gcd3) (apply gcd_ (args) 2))

Per completezza vediamo anche il calcolo del Minimo Comune Multiplo (mcm):

;Returns the least common multiple of two integers x and y.

(define (lcm_ x y)(* x (/ y (gcd x y))))

(define-macro (lcm)(apply lcm_ (args) 2))

Infine vediamo alcuni test di velocità delle funzioni.

(setq number1 (map int (random 1 1e8 10000)))
(setq number2 (map int (random 1 1e8 10000)))

(time (map gcd1_ number1 number2) 100)
;-> 3187.894
(time (map gcd2_ number1 number2) 100)
;-> 2768.187
(time (map gcd3_ number1 number2) 100)
;-> 8453.914

Vediamo la funzione standard "gcd" (che è la più veloce):

(time (map gcd number1 number2) 100)
;-> 281.56


------------------------
Indicizzazione implicita
------------------------
È possibile creare forme implicite di "rest" e "slice" anteponendo alla lista uno o due numeri per indicare l'offset e la lunghezza. Se la lunghezza è negativa, inizia a contare dalla fine della lista:

(set 'lst '(a b c d e f g))
; or as array
(set 'lst (array 7 '(a b c d e f g)))

(1 lst)      → (b c d e f g)
(2 lst)      → (c d e f g)
(2 3 lst)    → (c d e)
(-3 2 lst)   → (e f)
(2 -2 lst)   → (c d e)

; resting and slicing is always on 8-bit char borders
; even on UTF8 enabled versions

(set 'str "abcdefg")

(1 str)      → "bcdefg"
(2 str)      → "cdefg"
(2 3 str)    → "cde"
(-3 2 str)   → "ef"
(2 -2 str)   → "cde"

(setq lst '(a b c d e))

(0 -1 lst)
;-> (a b c d)
lst
;-> (a b c d e)

(chop lst)
;-> (a b c d)
lst
;-> (a b c d e)

(pop lst)
;-> a
lst
;-> (b c d e)

Se credi che l'indicizzazione implicita sia confusa da interpretare, allora puoi creare una funzione:

(define (drop-last var)(0 -1 var))

Quindi:
(drop-last '("a" "b" "c" "d" "e"))
;-> ("a" "b" "c" "d")

Equivalente a:
(chop '("a" "b" "c" "d" "e"))
;-> ("a" "b" "c" "d")


------------------------------------
nil come valore e nil come risultato
------------------------------------

Ricordiamo che la lista vuota non è "true" o "nil":

(nil? '())
;-> nil

(true? '())
;-> nil

(empty? '())
;-> true

(list? '())
;-> true

(= '() '())
;-> true

Ma in un contesto booleano risulta falsa (nil):

(if '() "vero" "falso")
;-> "falso"

Questo fatto ci permette di velocizzare il codice nel modo seguente:

(setq lst '())
;-> ()

La lista vuota non è uguale a "nil" come valore:

(nil? lst)
;-> nil

Ma è considerata falsa (nil) quando è vuota in un contesto booleano:

(if lst (println "vero") (println "falso"))
;-> falso

Questo permette di scrivere:

(time (if lst 'si 'no) 1000000)
;-> 31.247

Che è molto più veloce di:

(time (if (not (empty? lst)) 'si 'no) 1000000)
;-> 62.506

Inoltre, se non è presente alcuna clausola "else" nell'istruzione "if", viene restituita la valutazione della condizione:

(if lst 'si)
;-> ()

Mentre nel secondo caso avremmo:

(if (not (empty? lst)) 'si)
;-> nil

Questa potrebbe essere una distinzione importante quando si controlla il valore di ritorno di una funzione/macro, per distinguere tra un elemento nil restituito oppure il risultato nil come mancata applicazione della funzione/macro. Supponiamo di voler scrivere una macro che elimina l'ultimo oggetto da una lista. Se utilizziamo la primitiva "pop" otteniamo un errore quando viena applicata alla lista vuota:

(setq lst '(a))
;-> (a)
(pop lst -1)
;-> a

Adesso lst è vuota:
lst
;-> ()

Applicando "pop" otteniamo un errore:

(pop lst -1)
;-> ERR: invalid list index in function pop

Con una macro (Lutz) possiamo scrivere:

(macro (drop L) (if L (pop L -1)))
;-> (lambda-macro (L) (expand '(if L (pop L -1))))

(setq lst '(a))
;-> (a)

(drop lst)
;-> a
(drop lst)
;-> ()

In questo caso, quando la lista è vuota "drop" produce una lista vuota e non un errore.


---------------------
Simulare un iteratore
---------------------

Per simulare velocemente un iteratore possiamo utilizzare un lista di numeri:

(setq s '(3 2 1))

(pop s) ;-> 3
(pop s) ;-> 2
(pop s) ;-> 1
(pop s) ;-> nil

Per simulare un generatore crescente non possiamo usare "pop" con il parametro -1 (cioè non possiamo togliere l'ultimo elemento) perchè si avrebbe un errore quando la lista è vuota:

(setq s '(3 2 1))

(pop s -1) ;-> 1
(pop s -1) ;-> 2
(pop s -1) ;-> 3
(pop s -1) ;-> ERR: invalid list index in function pop

Quindi usiamo una sequenza inversa:

(setq s '(1 2 3))
(pop s) ;-> 1
(pop s) ;-> 2
(pop s) ;-> 3
(pop s) ;-> nil


-------------------------------
"Don't underrate an iterate..."
-------------------------------

"Non sottovalutate l'iterazione..."
Questa è una legge di Lutz, il creatore di newLISP.
Non sempre dobbiamo usare "dolist" per iterare attraverso una lista.

(setq lst (series 1 2 12))
;-> (1 2 4 8 16 32 64 128 256 512 1024 2048)

(map (fn (n) (apply add n)) (explode lst 3))
;-> (7 56 448 3584)

(dolist (n (explode lst 3)) (println (apply add n)))
;-> 7
;-> 56
;-> 448
;-> 3584

(do-while lst (println (apply add (list (pop lst) (pop lst) (pop lst)))))
;-> 7
;-> 56
;-> 448
;-> 3584

(setq lst (series 1 2 12))
;-> (1 2 4 8 16 32 64 128 256 512 1024 2048)
(map (fn (x) (println (x 0) "-" (x 1) "-" (x 2))) (explode lst 3))
;-> 1-2-4
;-> 8-16-32
;-> 64-128-256
;-> 512-1024-2048
;-> (4 32 256 2048)

(map (curry apply (fn (i j k) (println i "-" j "-" k))) (explode lst 3))
;-> 1-2-4
;-> 8-16-32
;-> 64-128-256
;-> 512-1024-2048
;-> (4 32 256 2048)

Da notare l'opzione "int-reduce" in "apply". Quando "int-reduce" è 2, il comportamento è simile alla funzione "fold" o "reduce", quando è più grande di 2 è ancora più divertente.

(apply (fn(_ a b c)(println a {-} b {-} c)) (cons nil lst) 4)
;-> 1-2-4
;-> 8-16-32
;-> 64-128-256
;-> 512-1024-2048

(apply (fn(_ a b c)(println a b c)) (cons nil (sequence 1 9)) 4)
;-> 123
;-> 456
;-> 789


----------------------------
Simboli che iniziano con "$"
----------------------------

Tutti i simboli che iniziano con il carattere "$" sono sempre definiti in MAIN.
Esempio:
(context 'Demo)
;-> Demo
Demo>
(setq $demo "hi!")
;-> "hi!"
Fred>
(symbols)
;-> ()
Demo>
(context MAIN)
;-> MAIN
(symbols)
;-> (! != $ $0 $1 $10 $11 $12 $13 $14 $15 $2 $3 $4 $5 $6 $7 $8 $9
;->  $args $count $demo $idx $it $main-args $x % & * + ++ , - -- /
;->  : < << <= = > >= >> ? @ Class Demo MAIN NaN? Tree ...)

Spiegazione (Lutz):
I simboli che iniziano con $ sono variabili modificate/gestite da newLISP in MAIN e sono accessibili a livello globale. Le variabili da $0 a $15 vengono utilizzate per contenere informazioni delle espressioni regolari e $0 contiene anche l'espressione di sostituzione per diversi "set" e per la funzione "replace". $idx è l'indice corrente di "dolist". $args contiene l'elenco restituito dalla funzione "args" e $main-args contiene lla lista restituita dalla funzione "main-args". Tutti questi simboli sono globali e tutti, tranne $0 a $15, sono protetti e non possono essere modificati dall'utente. L'utente può impostare da $0 a $15 perché ci sono casi in cui ciò è necessario quando si lavora con espressioni regolari.

Inoltre, i simboli che iniziano con $ non vengono salvati quando si salva un contesto (es. (save 'MyContext) o quando si serializzano nuovi oggetti LISP con la funzione "source".

Nota: il nome di una variabile può iniziare con qualsiasi carattere tranne una cifra numerica o un punto e virgola ";" o il cancelletto "#".
Se il primo carattere è un "+" o "-" nessuna cifra può seguirlo.
Dopodiché può seguire qualsiasi carattere tranne "(" ")" "," ":" """ "'" spazio ";" "#"  che terminerà la variabile.
Un simbolo che inizia con "[" e termina con "]" può contenere qualunque carattere all'interno, ad esempio:

[1 &*$()}]

è un simbolo legale.


-------------------------------
Uso di map nelle liste annidate
-------------------------------

In alcuni casi abbiamo bisogno di applicare una funzione a tutti gli elementi di una lista annidata. Ad esempio, poter scrivere qualcosa del tipo:

(map-all abs '(-1 -2 (-3 -4)))

ed ottenere come risultato (1 2 (3 4)) dove tutti i sotto-elementi vengono elaborati e viene mantenuto l'annidamento della lista originale.

La funzione "map" non è progettata per risolvere questo problema, quindi occorre scrivere una funzione specifica.

(define (map-all f lst)
  (let (result '())
    (dolist (el lst)
      (if (list? el)
        (push (map-all f el) result -1)
        (push (f el) result -1)))
    result))

(map-all abs '(-1 -2 (-3 -4)))
;-> (1 2 (3 4))

(define (doppio x) (* 2 x))

(map-all doppio '(-1 -2 (-3 -4)))
;-> (-2 -4 (-6 -8))

(map-all doppio (map-all abs '(-1 -2 (-3 -4))))
;-> (2 4 (6 8))

(setq lst '(((1)) 2 ((3) (4 5 ((6)))) ((6) 7) (8 9)))
(map-all doppio lst)
;-> (((2)) 4 ((6) (8 10 ((12)))) ((12) 14) (16 18))


------------------------------
Funzioni ordinali con le liste
------------------------------

Ecco alcune funzioni per estrarre elementi da una lista in base alla loro posizione ordinale:

(define (primo lst)   (if (> (length lst) 0) (nth 0 lst) 'nil))
(define (secondo lst) (if (> (length lst) 1) (nth 1 lst) 'nil))
(define (terzo lst)   (if (> (length lst) 2) (nth 2 lst) 'nil))
(define (quarto lst)  (if (> (length lst) 3) (nth 3 lst) 'nil))
(define (quinto lst)  (if (> (length lst) 4) (nth 4 lst) 'nil))
(define (sesto lst)   (if (> (length lst) 5) (nth 5 lst) 'nil))
(define (settimo lst) (if (> (length lst) 6) (nth 6 lst) 'nil))
(define (ottavo lst)  (if (> (length lst) 7) (nth 7 lst) 'nil))
(define (nono lst)    (if (> (length lst) 8) (nth 8 lst) 'nil))
(define (decimo lst)  (if (> (length lst) 9) (nth 9 lst) 'nil))

(primo '())
;-> nil
(primo '(1 2 3))
;-> 1
(decimo '(1 2 3 4 5 6 7 8 9 10))
;-> 10


------------------------
gensym e macro igieniche
------------------------

Nei LISP tradizionali esiste la funzione GENSYM che serve per generare un simbolo nuovo ed univoco. Questa funzione viene utilizzata soprattutto per rendere le macro igieniche.
Comunque in newLISP possiamo ottenere lo stesso scopo ed evitare l'acquisizione variabile, utilizzando la funzione "args" per accedere agli argomenti macro o funzioni:

(define-macro (setq1)
   (set (args 0) (eval (args 1))))

(setq1 x 123)
;-> 123
x
;-> 123

Per il templating possiamo usare le funzioni "expand" e "letex". Ecco un esempio per l'uso di "letex" insieme a una definizione di "gensym":

(define (gensym:gensym)
   (if gensym:count
      (inc gensym:count)
      (setq gensym:count 1))
   (sym (string "gs" gensym:count) MAIN))

(gensym)
;-> gs1
(gensym)
;-> gs2

(define setq2
   (letex (s (gensym) v (gensym))
      (lambda-macro (s v) (set s (eval v)))))

;-> (lambda-macro (gs3 gs4) (set gs3 (eval gs4)))

(setq2 y 456)
;-> 456
y
;-> 456

o per avere un "gensym" ancora più sicuro possiamo usare la funzione "uuid":

(define (gen-sym) (string "gs" (uuid)))

(gen-sym)
;-> "gs7D1365E2-78A6-48A6-8C31-B6034840B528"

La prima funzione genera simboli più leggibili dall'uomo, mentre la seconda è utile per il codice interno alla macchina ed sicuro al 100%. "uuid" da sola genera un stringa ID univoca e universale, utile per gli ID di sessione nella programmazione web ecc.

Per le macro, ciò che funziona meglio la maggior parte delle volte, è semplicemente usare "args" come nel primo esempio.


---------------------------
La variabile anaforica $idx
---------------------------

La variabile interna di sistema $idx (variabile anaforica) tiene traccia dell'indice relativo del ciclo (numero intero).
$idx è protetta e non può essere modificata dall'utente.
La variabile anaforica $idx viene utilizzata dalle seguenti funzioni: "dolist", "dostring", "doargs", "dotree", "series", "while", "do-while", "until", "do-until", "map".

Esempi:

(map (fn(x) (list $idx x)) '(a b c))
;-> ((0 a) (1 b) (2 c))

(dolist (el '(a b c)) (print (list $idx el) { }))
;-> (0 a) (1 b) (2 c)

Nota: quando si utilizzano queste funzioni in modo innestato, la variabile $idx fa riferimento sempre al ciclo in cui si trova. Ad esempio:

(define (test)
  (setq lst '((1 2 3) (1 2 3) (1 2 3)))
  (dolist (el lst)
    (setq i 0)
    (while (< i 3)
      (println $idx {-} i)
      (++ i)
    )
  )
)

(test)
;-> 0-0
;-> 1-1
;-> 2-2
;-> 0-0
;-> 1-1
;-> 2-2
;-> 0-0
;-> 1-1
;-> 2-2

Il valore di $idx non è quello della lista, ma quello del ciclo while.
Per usare $idx della lista all'interno del ciclo while occorre utilizzare una variabile ausiliaria (setq idx-lst $idx) ed utilizzare questa all'interno cel ciclo while.

(define (test)
  (setq lst '((1 2 3) (1 2 3) (1 2 3)))
  (dolist (el lst)
    (setq idx-lst $idx)
    (setq i 0)
    (while (< i 3)
      (println idx-lst {-} i)
      (++ i)
    )
  )
)

(test)
;-> 0-0
;-> 0-1
;-> 0-2
;-> 1-0
;-> 1-1
;-> 1-2
;-> 2-0
;-> 2-1
;-> 2-2


--------------------
Gestione dei simboli
--------------------

newLISP fornisce tre funzioni per la gestione dei simboli: "symbols", "symbol?" e "sym".
Vediamo la traduzione delle funzioni dal manuale di newLISP.

*******************
>>>funzione SYMBOLS
*******************
sintassi: (symbols [context])

Quando viene chiamato senza argomento, restituisce una lista ordinata di tutti i simboli nel contesto corrente. Se viene specificato un simbolo di contesto, vengono restituiti i simboli definiti in quel contesto.

*******************
>>>funzione SYMBOL?
*******************
sintassi: (symbol? exp)

Valuta l'espressione exp e restituisce true se il valore è un simbolo. In caso contrario, restituisce nil.

(set 'x 'y)  → y

(symbol? x)  → true

(symbol? 123)  → nil

(symbol? (first '(var x y z)))  → true

La prima istruzione imposta il contenuto di x sul simbolo y. La seconda istruzione controlla quindi il contenuto di x. L'ultimo esempio controlla il primo elemento di una lista.

***************
>>>funzione SYM
***************
sintassi: (sym string [sym-context [nil-flag]])
sintassi: (sym number [sym-context [nil-flag]])
sintassi: (sym symbol [sym-context [nil-flag]])

Converte il primo argomento di tipo stringa, numero o simbolo in un simbolo e lo restituisce. Se non viene specificato un contesto (opzionale) in sym-context, allora viene utilizzato il contesto corrente durante la ricerca o la creazione dei simboli. I simboli verranno creati solo se non esistono già. Quando il contesto non esiste e il contesto è specificato da un simbolo quotato, viene creato anche il simbolo. Se la specifica di contesto non è quotata, il contesto è il nome specificato o la specifica di contesto è una variabile che contiene il contesto.

sym può creare simboli all'interno della tabella dei simboli che non sono simboli legali nel codice sorgente newLISP (ad es. numeri o nomi contenenti caratteri speciali come parentesi, due punti, ecc.). Ciò rende sym utilizzabile come funzione per l'accesso alla memoria associativa, proprio come l'accesso alla tabella hash in altri linguaggi di scripting.

Come terzo argomento facoltativo, è possibile specificare nil per sopprimere la creazione del simbolo se il simbolo non viene trovato. In questo caso, sym non restituisce nil se il simbolo cercato non esiste. Usando quest'ultima forma, sym può essere usato per verificare l'esistenza di un simbolo.

(sym "some")           → some
(set (sym "var") 345)  → 345
var                    → 345
(sym "aSym" 'MyCTX)    → MyCTX:aSym
(sym "aSym" MyCTX)     → MyCTX:aSym  ; unquoted context

(sym "foo" MyCTX nil)  → nil  ; 'foo does not exist
(sym "foo" MyCTX)      → foo  ; 'foo is created
(sym "foo" MyCTX nil)  → foo  ; foo now exists

Poiché la funzione sym restituisce il simbolo cercato o creato, le espressioni con sym possono essere incorporate direttamente in altre espressioni che usano simboli come argomenti. L'esempio seguente mostra l'uso di sym come una funzione simile all'hash per l'accesso alla memoria associativa, nonché l'utilizzo di simboli che non sono simboli legali nel codice newLISP:

;; using sym for simulating hash tables

(set (sym "John Doe" 'MyDB) 1.234)
(set (sym "(" 'MyDB) "parenthesis open")
(set (sym 12 'MyDB) "twelve")

(eval (sym "John Doe" 'MyDB))  → 1.234
(eval (sym "(" 'MyDB))         → "parenthesis open"
(eval (sym 12 'MyDB))          → "twelve"

;; delete a symbol from a symbol table or hash
(delete (sym "John Doe" 'MyDB))  → true

L'ultima espressione mostra come può essere eliminato un simbolo usando "delete".

La terza sintassi consente di utilizzare i simboli anziché le stringhe per il nome del simbolo nel contesto di destinazione. In questo caso, sym estrae il nome dal simbolo e lo utilizzerà come stringa del nome per il simbolo nel contesto di destinazione:

(sym 'myVar 'FOO)  → FOO:myVar

(define-macro (def-context)
  (dolist (s (rest (args)))
    (sym s (first (args)))))

(def-context foo x y z)

(symbols foo)  → (foo:x foo:y foo:z)

La macro "def-context" mostra come questo potrebbe essere usato per creare una macro che crea contesti e le loro variabili in modo dinamico.

Una sintassi della funzione "context" può anche essere utilizzata per creare, impostare e valutare simboli.

Dopo aver letto la definizione delle tre funzioni, vediamo un esempio per capire come newLISP crea/gestisce i simboli.

Creiamo un contesto:
(context 'demo)

Non ci sono simboli nel contesto demo:
(symbols)
;-> ()

Creiamo il simbolo "aa":
(setq aa 10)
(symbols)
;-> (aa)

La funzione "symbol?" valuta l'argomento e verifica se valuta su un simbolo:

(symbol? aa)
;-> nil
Il simbolo "aa" non valuta ad un simbolo, ma al numero 10.

Creiamo un altro simbolo "bb":
(setq bb 'aa)
(symbols)
;-> (aa bb)

(symbol? bb)
;-> true
Questa volta il simbolo "bb" viene valutato e otteniamo il simbolo "aa".

Vediamo cosa accade se applichiamo la funzione "symbol?" ad un simbolo che ancora non esiste "cc":

(symbol? cc)
;-> nil

Sembra tutto corretto, ma vediamo i simboli del contesto:
(symbols)
;-> (aa bb cc)

È stato creato il simbolo "cc". Cosa è successo?
Prima di applicare una funzione newLISP valuta gli argomenti (in questo caso "cc"). Anche se tale valutazione restituisce nil (come in questo caso), newLISP crea comunque un simbolo per la variabile (con valore nil).

Anche quando scriviamo un nome qualunque sulla REPL viene creato un simbolo:

un-nome
;-> nil
(symbols)
;-> (aa bb cc un-nome)

Questo significa che newLISP crea/valuta gli argomenti di ogni funzione prima di applicare la funzione. Quindi, se volessimo sapere se un simbolo esiste nel contesto corrente non possiamo applicare una funzione qualunque (esempio "find") perchè crerebbe il simbolo prima di verificarne l'esistenza e qualunque argomento passato risulta esistente nel contesto:

(symbols)
;-> (aa bb cc un-nome)
(find 'dd (symbols))
;-> 3
(symbols)
;-> (aa bb cc dd un-nome)

Ma allora, come possiamo conoscere se un simbolo esiste in un determinato contesto?
Dobbiamo usare la funzione "sym":

(sym "var" demo nil)
;-> nil
(symbols)
;-> (aa bb cc dd un-nome)

Il simbolo "var" non esiste nel contesto demo (e non viene neanche creato).
Problema risolto. Ma forse è meglio scrivere una funzione ad-hoc:

(define (is-sym symbol ctx)
    (sym symbol (context) nil))

(is-sym "non-presente")
;-> nil

Adesso vediamo un esempio di nome speciale per un simbolo, cioè un nome che può essere generato solo utilizzando la funzione "sym".
Le seguenti espressioni generano un errore:

(set '"name" 3)
;-> ERR: symbol expected in function set : '"name"
(set (quote "name") 3)
;->ERR: symbol expected in function set : '"name"

Ma le seguenti sono valide:

(setf '"name" 3)
;-> -> 3
(setq "name" 3)
;-> 3

Però il simbolo "name" non esiste nei simboli di MAIN:

(sym {"name"} MAIN nil)
;-> nil

Allora dobbiamo utilizzare "sym" per poter usare il nome "name" (con i doppi apici) per un simbolo. Creiamo il simbolo:

(set (sym {"name"}) 3)
;-> 3

Vediamo se si trova nei simboli di MAIN:

(sym {"name"} MAIN nil)
;-> "name"

Per recuperare il valore del simbolo utilizziamo "eval":

(eval (sym {"name"}))
;-> 3

Per cancellare un simbolo dobbiamo usare la funzione "delete".

******************
>>>funzione DELETE
******************
sintassi: (delete symbol [bool])
sintassi: (delete sym-context [bool])

Nella prima sintassi elimina un simbolo simbolo e i riferimenti al simbolo che si trovano in altre espressioni vengono posti al valore nil.

Nella seconda sintassi tutti i simboli dello spazio dei nomi (contesto) a cui fa riferimento sym-context verranno eliminati e i riferimenti ad essi che si trovano in altre espressioni verranno posti a nil. Il simbolo di contesto sym-context verrà modificato in un simbolo normale con valore nil.

Quando l'espressione in bool vale true, i simboli vengono eliminati solo quando non sono referenziati in altre espressioni.

Quando l'espressione in bool vale nil, i simboli verranno eliminati senza alcun controllo di riferimento. Si noti che questa modalità deve essere utilizzata solo se non esistono riferimenti al simbolo al di fuori del suo spazio dei nomi. Se esistono riferimenti esterni, questa modalità può causare arresti anomali del sistema, poiché il riferimento esterno non è impostato a nil quando si utilizza questa modalità. Questa modalità può essere utilizzata per eliminare gli hash dello spazio dei nomi e per eliminare gli spazi dei nomi nei sistemi a oggetti, dove le variabili sono trattate come private.

I simboli protetti di funzioni integrate e simboli speciali come nil e true non possono essere eliminati.

delete restituisce true se il simbolo è stato eliminato correttamente o nil se il simbolo non è stato eliminato.

Quando si elimina un simbolo di contesto, la prima chiamata a delete rimuove il contenuto dello spazio dei nomi di contesto e riduce il simbolo di contesto in un normale simbolo mono-variabile. Una seconda chiamata di delete rimuoverà il simbolo dalla tabella dei simboli.

(set 'lst '(a b aVar c d))
(delete 'aVar)  ; aVar deleted, references marked nil
lst
;-> (a b nil c d)

(set 'lst '(a b aVar c d))
(delete 'aVar true)
;-> nil ; protect aVar if referenced

lst
;-> (a b aVar c d)

;; delete all symbols in a context
(set 'foo:x 123)
(set 'foo:y "hello")
(delete 'foo)
;-> nil  ; foo:x, foo:y deleted

Nell'ultimo esempio verranno eliminati solo i simboli all'interno del contesto foo, ma non il simbolo contestuale stesso. Verrà convertito in un normale simbolo non protetto e conterrà nil.

Si noti che l'eliminazione di un simbolo che fa parte di un'espressione che è attualmente in esecuzione può causare l'arresto anomalo del sistema o avere altri effetti imprevisti.

Per cancellare tutti i simboli di un contesto X possiamo utilizzare la seguente espressione:

(map delete (symbols 'X))

che elimina tutti i simboli contenuti nel contesto X.


-------------------
Funzioni e contesti
-------------------

La seguente funzione permette di definire funzioni come funtori di default nel proprio contesto.

(define (def-static s body)
      (def-new 'body (sym s s)))

Vediamo un esempio di utilizzo:

(def-static 'acc (fn (x) (inc sum x)))
;-> acc:acc
(acc 1)
;-> 1
(acc 1)
;-> 2
(acc 1)
;-> 3
(acc 5)
;-> 8
acc:acc
;-> (lambda (acc:x) (inc acc:sum acc:x))

è possibile utilizzare "def-static" anche come lambda-macro:

(def-static 'mysetq (lambda-macro (p1 p2) (set p1 (eval p2))))
;-> mysetq:mysetq
(mysetq x 123)
;-> 123

e questo è quello che viene generato:

mysetq:mysetq
;-> (lambda-macro (mysetq:p1 mysetq:p2) (set mysetq:p1 (eval mysetq:p2)))

Per avere informazioni sui contesti definiti e sul contesto corrente possiamo usare le seguenti espressioni/funzioni:

(define (contexts-info) (filter context? (map eval (symbols 'MAIN))))
(contexts-info)
;-> (Class MAIN Tree aac mysetq)
(context)
;-> MAIN

(symbols)


------------------
Buon 2020 (e 2021)
------------------

Conto alla rovescia per il nuovo anno:

10 * 9 * 8 + (7 + 6) * 5 * 4 * (3 + 2) * 1 = 2020

...e anche per il prossimo:

10 * 9 * 8 + (7 + 6) * 5 * 4 * (3 + 2) + 1 = 2021

(define (buon-anno)
  (println "Buon " (+ (* 10 9 8) (* (+ 7 6) 5 4 (+ 3 2) 1))))

(buon-anno)
;-> Buon 2020

(setq a (+ (* 10 9 8) (* (+ 7 6) 5 4 (+ 3 2) 1)))
;-> 2020
(setq b (+ (* 10 9 8) (* (+ 7 6) 5 4 (+ 3 2)) 1))
;-> 2021


--------------------------------------
Nascita della teoria della probabilità
--------------------------------------

Chevelier de Mere (1607-1684) era un gentiluomo francese giocatore d'azzardo che è entrato nella storia per aver chiesto aiuto a Blaise Pascal nel risolvere un problema relativo al gioco dei dadi.

La situazione di Chevelier de Mere prevedeva due giochi di dadi. Nel primo, De Mere puntava con probabilità pari di ottenere almeno un sei su quattro tiri di un dado non truccato. Il suo ragionamento era il seguente: con il lancio di un dado il numero 6 ha probabilità 1/6 di uscire (corretto). Poi ha pensato che con il lancio di quattro dadi la probabilità sarebbe 4*(1/6) = 4/6 = 2/3 (sbagliato). Sebbene il suo ragionamento fosse errato, nel corso degli anni ha fatto molti soldi facendo questa scommessa.

Con il successo del primo gioco, de Mere ha modificato il gioco scommettendo con pari probabilità di ottenere almeno un doppio sei lanciando 24 volte una coppia di dadi. Egli riteneva correttamente che la possibilità di ottenere un doppio sei lanciando una coppia di dadi è 1/6 * 1/6 = 1/36. Tuttavia, sbagliava nel pensare che in 24 lanci di una coppia di dadi, la possibilità di ottenere un doppio sei sarebbe stata 24 * 1/36 = 24/36 = 2/3.

Dopo avere perso molti soldi intuì che qualcosa non andava nel secondo gioco dei dadi. Quindi chiese aiuto al suo rinomato amico Blaise Pascal per trovare una spiegazione al problema. In una serie di lettere tra Pascal e Pierre de Fermet, il quesito di de Mere à stato risolto. Da questo sforzo congiunto furono gettate le basi per la teoria della probabilità.
La chiave della soluzione ai problemi di de Mere è la distribuzione binomiale.

Vediamo perché il primo gioco è stato redditizio per de Mere e perché il secondo gioco non lo è stato.

Primo gioco

La probabilità di ottenere un 6 con un dado vale 1/6.
La probabilità di non ottenere almeno un 6 con un dado vale 5/6, quindi la probabilità di non ottenere alcun 6 lanciando 4 dadi vale: (5/6)*(5/6)*(5/6)*(5/6) = (5/6)^4 = 0.482253.
Quindi la probabilità di avere almeno un 6 lanciando 4 dadi vale:

P(un 6 con 4 dadi) = 1 - P(nessun 6 con 4 dadi) =
= 1 - 0.482253 = 0.517747

La probabilità di ottenere almeno un sei su quattro tiri di un dado giusto è 0.517747. Su 100 partite, de Mere avrebbe vinto in media 52 partite. Su 1000 partite, avrebbe vinto in media 518 partite. Supponiamo che ogni scommessa sia di un euro. Quindi de Mere avrebbe guadagnato 36 euro per ogni 1000 euro. Con un guadagno pari al 3.6% (circa).

Secondo gioco

In un lancio di una coppia di dadi, ci sono un totale di 36 possibili esiti (cioè i sei risultati del primo dado combinati con i sei risultati del secondo dado). Di questi 36 risultati, solo uno di questi è un doppio sei. Quindi, la probabilità di ottenere un doppio sei è 1/36 nel tirare un paio di dadi. Allo stesso modo, la probabilità di non ottenere un doppio sei è 35/36.

La probabilità di non ottenere un doppio sei in 24 tiri di una coppia di dadi è:

P(nessun doppio sei in 24 tiri) = (35/36)^24 = 0.5086

Quindi la probabilità di ottenere almeno un doppio sei in 24 tiri è:

P (almeno un doppio sei in 24 rotoli) = 1 - P (nessun doppio sei in 24 rotoli) =
= 1 - 0.5086 = 0.4914

La probabilità di ottenere almeno un doppio sei in 24 tiri di una coppia di dadi è 0.4914. In media, De Mere avrebbe vinto solo circa 49 partite su 100 e l'avversario avrebbe vinto circa 51 partite. Se ogni scommessa vale un euro, la parte avversaria di de Mere vincerebbe 2 franchi per ogni 100 franchi scommessi (con un guadagno di circa il 2%).

Verifichiamo i risultati con una simulazione.

(define (dado) (+ 1 (rand 6)))

(define (game1 n)
  (let ((mere 0) (break nil))
    (for (i 1 n)
      (setq break nil)
      (for (j 1 4 1 break)
        (if (= (dado) 6) (begin
            (++ mere)
            (setq break true)
        ))
      )
    )
    (println "games: " n { } "mere wins: " mere { - } (div mere n)"%")
    (list n mere (div mere n))
  )
)

(game1 1e4)
;-> games: 10000 mere wins: 5149 - 0.5149%
;-> (10000 5149 0.5149)
(game1 1e5)
;-> games: 100000 mere wins: 51845 - 0.51845%
;-> (100000 51845 0.51845)
(game1 1e6)
;-> games: 1000000 mere wins: 518265 - 0.518265%
;-> (1000000 518265 0.518265)
(game1 1e7)
;-> games: 10000000 mere wins: 5180712 - 0.5180712%
;-> (10000000 5180712 0.5180712)
(game1 1e8)
;-> games: 100000000 mere wins: 51774774 - 0.51774774%
;-> (100000000 51774774 0.51774774)
(game1 1e8)
;-> games: 100000000 mere wins: 51774196 - 0.51774196%
;-> (100000000 51774196 0.51774196)

Nota:
se per ogni lancio le vittorie sono il numero di 6 ottenuti, allora la probabilità di vittoria vale 2/3.

(define (game1 n)
  (let ((mere 0) (break nil))
    (for (i 1 n)
      ;(setq break nil)
      (for (j 1 4 1 break)
        (if (= (dado) 6) (begin
            (++ mere)
            ;(setq break true)
        ))
      )
    )
    (println "games: " n { } "mere wins: " mere { - } (div mere n)"%")
    (list n mere (div mere n))
  )
)

(game1 1e7)
;-> games: 10000000 mere wins: 6665579 - 0.6665579% ; 2/3 come pensava de Mere !!!)
;-> (10000000 6665579 0.6665579)

Nota: le seguenti funzioni producono risultati differenti

(define (dadi1) (+ 2 (rand 11)))
(define (dadi) (+ (+ 1 (rand 6)) (+ 1 (rand 6))))

Vediamo la distribuzione dei numeri random creati.

Funzione dadi1:

(setq res1 (array 13))
(for (i 1 10000) (++ (res1 (dadi1))))
res1
;-> (nil nil 927 896 862 863 918 914 882 980 902 968 888)
La distribuzione dei numeri da 2 a 12 è uniforme.

Funzione dadi:

(setq res (array 13))
(for (i 1 10000) (++ (res (dadi))))
res
;-> (nil nil 264 540 850 1098 1427 1703 1388 1073 825 571 261)
La distribuzione dai numeri da 1 a 12 non è uniforme. Questo è corretto ed è dovuto al fatto che i numeri non sono equiprobabili (ad esempio il numero 7 ha la probabilità più alta, perchè può essere formato da 1+6, 2+5, 3+4, 6+1, 4+3 e 5+2)

(define (game2 n)
  (let ((mere 0) (break nil))
    (for (i 1 n)
      (setq break nil)
      (for (j 1 24 1 break)
        (if (= (dadi) 12) (begin
            (++ mere)
            (setq break true)
        ))
      )
    )
    (println "games: " n { } "mere wins: " mere { - } (div mere n)"%")
    (list n mere (div mere n))
  )
)

(game2 1e3)
; games: 1000 mere wins: 524 - 0.524%
;-> (1000 524 0.524)
(game2 1e4)
;-> games: 10000 mere wins: 4933 - 0.4933%
;-> (10000 4933 0.4933)
(game2 1e5)
;-> games: 100000 mere wins: 49140 - 0.4914%
;-> (100000 49140 0.4914)
(game2 1e6)
;-> games: 1000000 mere wins: 491200 - 0.4912%
;-> (1000000 491200 0.4912)
(game2 1e7)
;-> games: 10000000 mere wins: 4914713 - 0.4914713%
;-> (10000000 4914713 0.4914713)

(time (game2 1e7))
;-> 60520.989

Nota: nel 1933 una monografia del matematico russo A. Kolmogorov sviluppa un approccio assiomatico che costituisce la base per la moderna teoria della probabilità ("Foundations of Probability Theory", Chelsea, New York, 1950).


-----------------
Fibonacci(104911)
-----------------

Questo è il più grande numero noto di Fibonacci che è anche primo. Contieneo 21925 cifre ed è stato dimostrato primo da Mathew Steine e Bouk de Water nel 2015.

Con newLISP possiamo calcolare questo numero, ma non possiamo verificare se è primo perchè richiederebbe un tempo lunghissimo.

(define (fibonacci n)
  (let (L '(0L 1L))
    (dotimes (i n)
      (setq L (list (L 1) (apply + L)))
    )
    ;(L 1)
    (last L)
  )
)

(length (setq a (fibonacci 104911)))
;-> 21925

(setq a (fibonacci 104911))


-------------
Conta e leggi
-------------

La sequenza di interi 1, 11, 21, 1211, 111221, ... viene creata partendo dal numero 1 e leggendo i numeri nel modo seguente:

     1 viene letto come 1 volta 1 ==> 11
    11 viene letto come 2 volte 1 ==> 21
    21 viene letto come 1 volta 2 e 1 volta 1 ==> 1211
  1211 viene letto come 1 volta 1, 1 volta 2 e 2 volte 1 ==> 111221
111221 viene letto come 3 volte 1, 2 volte 2 e 1 volta 1 ==> 312211
...

Scrivere una programma che genera questa sequenza fino ad un numero n passato come parametro.

Il problema può essere risolto utilizzando una semplice iterazione.

(define (conta n)
  (local (rip cur out i j res)
    (setq res '("1"))
    (setq out "1")
    (setq i 1)
    (while (< i n)
      (setq cur "")
      (setq rip 1)
      (setq j 1)
      (while (< j (length out))
        (if (= (out j) (out (- j 1)))
          (++ rip)
          (begin
            (setq cur (string cur rip (out (- j 1))))
            (setq rip 1)
          )
        )
        (++ j)
      )
      (setq cur (string cur rip (out (- (length out) 1))))
      (setq out cur)
      (push out res -1)
      (++ i)
    )
    res
  )
)

(conta 6)
;-> ("1" "11" "21" "1211" "111221" "312211")
(conta 12)
;-> ("1" "11" "21" "1211" "111221" "312211" "13112221"
;-> "1113213211" "31131211131221" "13211311123113112211"
;-> "11131221133112132113212221" "3113112221232112111312211312113211")

Nota: la funzione è lenta per numeri superiore a poche decine perchè le stringhe che rappresentano i numeri crescono molto rapidamente e newLISP utilizza il tag [text][/text] per delimitare le stringhe che superano 2047 caratteri. Questo rallenta molto l'esecuzione.

Ecco un altro metodo proposto da Norman:

(println (first (setq n '( 1 ))))
(do-until (< 1000 (length n))
 (dolist (x n (!= (n 0) x)) (push x r))
  (setq n ((length r) n))
  (push (length r) o -1)
  (push (r 0) o -1)
  (setq r '())
  (if (empty? n) (begin (setq n o) (setq o '()) (println (join(map string n ) "")) ))
)


----------------------
Assegnazione parallela
----------------------

newLISP non ha alcuna funzione per l'assegnazione parallela delle variabili. Vediamo la differenza tra assegnazione sequenziale e assegnazione parallela.

(setq a 1 b 1)

Assegnazione sequenziale
(setq a (+ a b))
;-> 2
(setq b (- a b))
;-> 1

Assegnazione parallela
(psetq (a b) ((+ a b) (- a b)))
a -> 2
b -> 0

Cioè entrambe le espressioni (+ a b) e (- a b) vengono calcolate con i valori iniziali a=1 e b=1.

Per definire l'assegnazione parallela scriveremo una macro "psetq" che ha due argomenti:

1. (a b) che rappresenta la lista delle variabili
2. ((+ a b) (- a b)) che rappresenta la lista delle espressioni

Il metodo è quello di valutare (con la funzione "expand") le espressioni sostituendo il valore delle variabili:

(setq a 1 b 1)

(expand (+ a b) 'a 'b)
;-> 2

(expand (- a b) 'a 'b)
;-> 0

Poi assegniamo queste "espansioni" alle variabili della prima lista. Questo è possibile perchè una macro non valuta gli argomenti, infatti se scriviamo le stesse espressioni non in una macro, non possiamo ottenere il risultato voluto:

(setq a (expand (+ a b) 'a 'b))
;-> 2
(setq b (expand (- a b) 'a 'b))
;-> 1 ; questo valore doveva essere 0

Questo perchè l'espressione (setq b (expand (- a b) 'a 'b)) valuta prima gli argomenti e trova che a = 2.

Vediamo come funziona la macro:

(define-macro (psetq)
  (let ((_tx (expand (args 1 0) (args 0 0) (args 0 1)))
        (_ty (expand (args 1 1) (args 0 0) (args 0 1))))
       (println _tx)
       (println _ty)
       (list (set (args 0 0) (eval _tx))
             (set (args 0 1) (eval _ty)))))

Facciamo l'espansione delle espressioni e inseriamo il risultato in "_tx" e "_ty":
(_tx (expand (args 1 0) (args 0 0) (args 0 1)))
(_ty (expand (args 1 1) (args 0 0) (args 0 1)))

Poi assegniamo la valutazione di queste espressioni alle relative variabili:
(set (args 0 0) (eval _tx))
(set (args 0 1) (eval _ty)))))

Proviamo la macro:

(setq a 1 b 1)
(psetq (a b) ((+ a b) (- a b)))
;-> (+ 1 1)
;-> (- 1 1)
;-> (2 0)

(list a b)
;-> (2 0)

La macro funziona correttamente, ma dobbiamo renderla più generale, nel senso che deve permettere di avere qualunque numero di variabili e di espressioni come argomenti (adesso la macro funziona solo con due variabili e due espressioni).

Invece di usare due variabili ("_tx" e "_ty") inseriamo le espressioni espanse in una lista "_var" e poi attraversiamo questa lista assegnando la valutazione delle espressioni alle relative variabili della lista delle variabili.
La lista delle variabili è (args 0), mentre la lista delle espressioni è (args 1).

(define-macro (psetq)
  (let ((_var '()) (_ex '()))
    ; per ogni espressione in (args 1)...
    (for (i 0 (- (length (args 1)) 1))
      ; espande l'espressione i-esima con il valore
      ; di ogni variabile (args 0)
      (setq _ex (expand (args 1 i) (args 0 0)))
      ; ciclo che espande l'espressione i-esima per ogni variabile
      (for (j 1 (- (length (args 0)) 1))
        (setq _ex (expand _ex (args 0 j)))
        (println _ex)
      )
      ; aggiunge l'espressione espansa ad una lista
      (push _ex _var -1)
    )
    (println _var)
    ; assegna ad ogni variabile la valutazione
    ; della relativa espressione della lista creata
    (dolist (el _var)
      (set (args 0 $idx) (eval el))
    )
  )
)

Vediamo alcuni esempi:

(setq x 2 y 3)

(psetq (x y) ((+ 1 y) (+ 1 x)))
;-> (+ 1 3)
;-> (+ 1 2)
;-> ((+ 1 3) (+ 1 2))
(list x y)
;-> (4 3)

(psetq (x y) (3 4))
;-> 3
;-> 4
;-> (3 4)
(list x y)
;-> (3 4)
----------------------

(setq x 2)
(setq y 4)
(setq a 2)

(setq x (- y 1 a))
;-> 1
(setq y (+ x y))
;-> 5

(setq x 2)
(setq y 4)
(setq a 2)

(psetq (x y) ((- y 1 a) (+ y x)))
;-> (- 4 1 a)
;-> (+ 4 2)
;-> ((- 4 1 a) (+ 4 2))
(list x y)
;-> (1 6)
----------------------

(setq x 1)
(setq y 2)
(setq z 3)

(setq x (+ x y z))
;-> 6
(setq y (- z y x))
;-> -5
(setq z (- x y z))
;-> 8

(setq x 1)
(setq y 2)
(setq z 3)

(psetq (x y z) ((+ x y z) (- z y x) (- x y z)))
;-> (+ 1 2 z)
;-> (+ 1 2 3)
;-> (- z 2 1)
;-> (- 3 2 1)
;-> (- 1 2 z)
;-> (- 1 2 3)
;-> ((+ 1 2 3) (- 3 2 1) (- 1 2 3))
(list x y z)
;-> (6 0 -4)
----------------------

(define (test a b c)
  (psetq (a b c) ((+ a b c) (- c b a) (- a b c)))
  (list a b c))

(test 1 2 3)
;-> (+ 1 2 c)
;-> (+ 1 2 3)
;-> (- c 2 1)
;-> (- 3 2 1)
;-> (- 1 2 c)
;-> (- 1 2 3)
;-> ((+ 1 2 3) (- 3 2 1) (- 1 2 3))
;-> (6 0 -4)

(psetq (x y z) (2 3 4))
;-> 2
;-> 2
;-> 3
;-> 3
;-> 4
;-> 4
;-> (2 3 4)

Nel forum di newLISP newBert ha proposto un altro metodo che utilizza la funzione "map":

(setq x 2 y 3)
;-> 3
(map set '(x y) (list (+ 1 y) (+ 1 x)))
;-> (4 3)

(setq x 1 y 2 z 3)
;-> 3
(map set '(x y z) (list (+ x y z) (- z y x) (- x y z)))
;-> (6 0 -4)


----------------------------
Generatore di numeri casuali
----------------------------

Generatore lineare congruenziale
--------------------------------
Il generatore congruenziale lineare (LCG) è l'algoritmo più comune e più vecchio per la generazione di numeri pseudo-cauali. Il generatore è definito dalla relazione di ricorrenza:

X(n+1) = (a*X(n) + c) mod m

dove:
X è la sequenza di valori pseudo-casuali
m,    0 < m         -> modulo
a,    0 < a < m     -> moltiplicatore
c,    0 ≤ c < m     -> incremento
X(0), 0 ≤ X(0) < m  -> il valore iniziale (seed)

Generiamo il numero intero casuale successivo utilizzando il numero intero casuale precedente (con le costanti intere "a" (moltiplicatore) e "c" (incremento). All'inizio occorre fornire anche un valore di partenza (seed), "X(0)". La caratteristica della casualità viene fornita dall'utilizzo dell'aritmetica modulare.

Il periodo di un LCG è al più m, e per alcune scelte di a può essere molto più piccolo. Il LCG ha un periodo pieno se e solo se:

1. c e m sono coprimi (con c > 0)
2. a-1 è divisibile per tutti i fattori primi di m,
3. a-1 è un multiplo/divisibile di 4 se m è un multiplo/divisibile di 4.

Nonostante gli LCG siano generalmente in grado di produrre numeri pseudocasuali decenti, la loro qualità è molto sensibile alla scelta dei coefficienti c, m ed a.

Le caratteristiche principali di un LCG

Efficiente: LCG può produrre molti numeri in breve tempo.

Deterministico: una data sequenza di numeri può essere riprodotta in un secondo momento se si conosce il punto iniziale nella sequenza. Il determinismo è utile se è necessario riprodurre nuovamente la stessa sequenza di numeri in una fase successiva (debug).

Periodico: i LCG sono periodici, il che significa che la sequenza alla fine si ripeterà. Mentre la periodicità non è quasi mai una caratteristica desiderabile, i LCG moderni hanno un periodo così lungo che può essere ignorato per la maggior parte degli scopi pratici.

I LCG sono adatti per applicazioni in cui sono richiesti molti numeri casuali e in cui è utile riprodurre facilmente la stessa sequenza (per esempio, le applicazioni di simulazione e modellazione). I LCG non sono adatti per applicazioni in cui è importante che i numeri siano davvero casuali (imprevedibili), come la crittografia dei dati e il gioco d'azzardo.

Esempio:

(define (LCG m a c s n)
  (let (out '())
    (dotimes (x n)
      (push (setq s (% (+ (* a s) c) m)) out -1))))

(LCG 5 3 1 1 6)
;-> (4 3 0 1 4 3)

Ecco una lista di parametri per LCG in uso in diversi compilatori:

                     m       a                    c
GCC                  2³¹     1103515245           12345
Delphi               2³²     134775813            1
Visual C             2³²     214013               2531011
MMIX (Donald Knuth)  2⁶⁴     6364136223846793005  1442695040888963407
Numerical Recipes    2³²     1664525              1013904223
C++11 (MINSTD)       2³¹−1   48271                0

2^64 = 18446744073709551616
2^32 = 4294967296

(LCG 4294967296 1103515245 12345 1 10)
;-> (1103527590 2524885223 662824084 3295386429 4182499122
;->  2516284547 3655513600 2633739833 3210001534 267834847)

(LCG 4294967296 1103515245 (int (time-of-day)) 1 10)
;-> (1174154431 3237027237 1954923411 4185058793 1775773831
;->  2432844237 1673943195 3515535953 3289127119 3959783541)

Quando "c" vale 0, abbiamo un generatore di numeri casuali di tipo Lehmer (chiamato anche generatore di Park-Miller):

X(n+1) = a*X(n) mod m

Un esempio è il famoso RANDU creato dall'IBM negli anni '60. La formula di questo generatore è la seguente:

V(j+1)=65539*V(j) mod 2^(31)

con V(0) numero intero dispari. Genera interi pseudocasuali V(j) che sono distribuiti uniformemente nell'intervallo [1, 2^31 - 1], ma nelle applicazioni pratiche sono spesso mappati in numeri razionali pseudocasuali X(j) nell'intervallo (0, 1), con la formula:

X(j) = V(j)/2^31

Il RANDU è considerato uno dei peggiori generatori di numeri casuali progettati, ed è stato descritto come "veramente orribile" da Donald Knuth. Il test spettrale ha esito negativo per dimensioni maggiori di 2 e ogni risultato intero è dispari. Tuttavia, almeno otto bit di ordine inferiore vengono eliminati quando convertiti in virgola mobile a precisione singola (32 bit, 24 bit mantissa).

Vediamo un generatore di numeri casuali fornito da Lutz:
(set 'IM 139968)
(set 'IA 3877)
(set 'IC 29573)
(set 'LAST 42)

(define (gen_random maximum)
	(set 'LAST (mod (add (mul LAST IA) IC) IM))
	(div (mul maximum LAST) IM))

(gen_random 100)
;-> 37.46499199817101
(gen_random 100)
;-> 72.90237768632831
(gen_random 100)
;-> 63.64669067215363


---------------------
Liste di associazione
---------------------

Una lista di associazione è una lista con la seguente struttura:

((chiave1 valore11 valore12 valore13 ... valore1N) (chiave2 valore21 valore22 valore23 ... valore2N) ...
 (chiaveM valoreM1 valoreM2 valoreM3 ... valoreMN))

Le funzioni specifiche di queste liste sono:
1) assoc
2) lookup
3) pop-assoc

Vediamo alcuni esempi:

FUNZIONE "assoc"
sintassi: (assoc exp-key list-alist)
sintassi: (assoc list-exp-key list-alist)

(setq lst '((key1 value1) (key2 value2) (key3 value3)))

Recuperare l'associazione con chiave key1:
(assoc 'key1 lst)
;-> (key1 value1)

FUNZIONE "lookup"
sintassi: (lookup exp-key list-assoc [int-index [exp-default]])

Recuperare solo il valore dell'associazione con chiave key1:
(lookup 'key1 lst)
;-> value1

Con int-index = 0:
(lookup 'key1 lst 0 'null)
;-> key1

Con int-index = 1:
(lookup 'key1 lst 1 'null)
;-> value1

Con int-index = 2: (in questo caso non esiste un elemento con indice 2 nella sottolista con chiave key1 e viene restituito l'ultimo elemento associato)
(lookup 'key1 lst 2 'null)
;-> value1

Con una chiave inesistente key5:
(lookup 'key5 lst 1 'null)
;-> null

Usiamo una lista associativa con valori multipli:
(setq lst1 '((key1 value1 value11) (key2 value2 value22) (key3 value3 value33)))

(lookup 'key1 lst1)
;-> value11

Con int-index = 0:
(lookup 'key1 lst1 0 'null)
;-> key1

Con int-index = 1:
(lookup 'key1 lst1 1 'null)
;-> value1

Con int-index = 2: (in questo caso esiste un elemento con indice 2 nella sottolista con chiave key1 e quindi viene restituito)
(lookup 'key1 lst1 2 'null)
;-> value11

Liste associative annidate
(setq lsta '((nome "eva") (eta "23") (esami ((storia 27) (chimica 28)))))

(lookup 'esami lsta)
;-> ((storia 27) (chimica 28))

Verificare se una chiave esiste ed (eventualmente) aggiornare il valore associato:

(letn (key 'nome)
  (if (lookup key lsta)
      (setf (assoc key lsta) (list key "max"))))
;-> (nome "max")
lsta
;-> ((nome "max") (eta "23") (esami ((storia 27) (chimica 28))))

Possiamo scriviamo una versione semplificata delle funzioni "assoc" e "lookup":

(define (car x)    (first x))
(define (cdr x)    (rest x))
(define (caar x)   (first (first x)))
(define (cadar x)  (first (rest (first x))))

(setq lst '((2 a) (1 b) (3 c)))

(define (assoc. key lst)
  (cond ((null? lst) nil)
        ((= (caar lst) key) (cadar lst))
        (true (assoc. key (cdr lst)))))

(assoc. 1 lst)
;-> b
(assoc. 4 lst)
;-> nil

(assoc. 4 '((2 a) (1 b) (3 c)))

(define (lookup. key lst)
  (cond ((null? lst) nil)
        ((= (caar lst) key) (car lst))
        (true (lookup. key (cdr lst)))))

(lookup. 1 lst)
;-> (1 b)
(lookup. 4 lst)
;-> nil


-------------------------------
Funzione Z e ipotesi di Riemann
-------------------------------

La funzione zeta di Riemann è una funzione che riveste una fondamentale importanza nella teoria dei numeri e ha notevoli risvolti in fisica, teoria della probabilità e statistica.
I primi studi su questa funzione furono effettuati da Leonhard Euler nel diciottesimo secolo, ma il nome deriva da Bernhard Riemann, che nel testo "Über die Anzahl der Primzahlen unter einer gegebenen Grösse" del 1859, avanzò l'ipotesi di una relazione tra gli zeri della funzione e la distribuzione dei numeri primi, la celebre "Congettura di Riemann".

Z(s) = 1/1^s + 1/2^s + 1/3^s + 1/4^s + ... =
     = Sum[1/i^s], (1 <= i <= ∞)

Eulero ha dimostrato che:

Z(s) = Prod[1/(1 - p^(-s))], (p numeri primi)

Quindi risulta:

Z(s) = 1/1^s + 1/2^s + 1/3^s + 1/4^s + ... =
     = (1/(1 - 1/2^s)) * (1/(1 - 1/3^s)) * (1/(1 - 1/5^s)) * (1/(1 - 1/7^s)) * ...

(define (ipow x n)
  (cond ((zero? n) 1)
        ((even? n) (ipow (* x x) (/ n 2)))
        (true (* x (ipow (* x x) (/ (- n 1) 2))))))

(ipow 21L 25L)
;-> 1136272165922724266740722458520501L

(define (Z s n)
  (let (out 0L)
    (for (i 1 n)
      (setq out (add out (div (ipow (bigint i) (bigint s)))))
    )
  out))

(setq PI (mul 2.0 (acos 0.0)))
;-> 3.141592653589793
(setq PI (mul 2.0 (asin 1.0)))
;-> 3.141592653589793

Eulero ha dimostrato che per s=2 e s=4 otteniamo:

Z(2) = (PI^2)/6 =
(setq Z2 (div (mul PI PI) 6))
;-> 1.644934066848226

Z(4) = (PI^4)/90 =
(setq Z4 (div (mul PI PI PI PI) 90))
;-> 1.082323233711138

Proviamo con la nostra funzione Z:

(Z 2 100000)
;-> 1.644924066898242
(Z 4 100000)
;-> 1.082323233710861

Vediamo l'errore:

(sub (Z 2 100000) Z2)
;-> -9.999949984074164e-006
(sub (Z 4 100000) Z4)
;-> -2.76889622341514e-013

Notiamo che per s = 0 otteniamo:

Z(0) = 1/1^0 + 1/2^0 + 1/3^0 + ... = 1 + 1 + 1 + ... = infinito

E per valori di (s < 0) otteniamo:

Z(-1) = 1/(1^-1) + 1/2^0 + 1/3^0 + ... = 1^1 + 2^1 + 3^1 + ... = infinito

Quindi per (s <= 0) la funzione Z tende all'infinito.

Riemann ha trovato una funzione analoga a Z(s):

            1          ∞    1        ∞               n!
ζ(s) = ------------- * ∑ --------- * ∑ (-1)^k * ----------- * (k + 1)^-s
         1-2^(1-s)    n=0 2^(n+1)   k=0          k!(n - k)!

ζ(2) = (PI^2)/6

ζ(4) = (PI^4)/90

Ma il valore di ζ(1) è indefinito.

Calcolo degli zeri della funzione ζ:

ζ(s) = 0 per s = -2, -4, -6, -8, -10, ... (per tutti i valori negativi pari di s)

Per i numeri s positivi risulta:

ζ(1/2 + 14.134725142i) = 0
ζ(1/2 + 21.022039639i) = 0
ζ(1/2 + 25.010857580i) = 0
ζ(1/2 + 30.424876126i) = 0

L'ipotesi di Riemann (RH) afferma che tutti gli zeri non banali di ζ si trovano sulla linea 1/2 + iR.
(Gli zeri banali sono quelli per cui s è un numero negativo pari).

L'istituto Clay Mathematics ha messo in palio 1.000.000 di dollari a chi dimostrerà questa ipotesi.

Per finire scriviamo una funzione che calcola Z(s) con numeri floating-point:

(define (Z s n)
  (let (out 0)
    (for (i 1 n)
      (setq out (add out (div (pow i s))))
    )
  out))

(Z 2 1000000)
;-> 1.64493306684877

(Z 4 1000000)
;-> 1.082323233710861


-------------------------------------
Rotazione di stringhe, liste e numeri
-------------------------------------

Scrivere una funzione che produce tutte le rotazioni di una stringa (e di una lista)
Esempio: "abc" -> "abc" "bca" "cab"

(define (ruota str)
  (let ((len (length str))
        (out '()))
    (dotimes (x len)
      (push (rotate str) out))))

(ruota "abc")
;-> ("abc" "bca" "cab")

Funziona anche per le liste:

(ruota '(1 2 3))
;-> ((1 2 3) (2 3 1) (3 1 2))

(setq lst '(a b c))

Vediamo un altro metodo:

(define (ruota2 lst)
  (let (out '())
    (dotimes (x (length lst))
    (push (push (pop lst) lst -1) out))))

(ruota2 '(a b c))
;-> ((a b c) (c a b) (b c a))

Funziona anche per le stringhe:

(ruota2 "abc")
;-> ("abc" "cab" "bca")

Vediamo la differenza di velocità:

(time (ruota (sequence 1 100)) 10000)
;-> 2181.789

(time (ruota2 (sequence 1 100)) 10000)
;-> 1959.412

(time (ruota "abcdefghijklmnopqrstuvwxyz") 10000)
;-> 91.905

(time (ruota2 "abcdefghijklmnopqrstuvwxyz") 10000)
;-> 164.827

Quindi con le stringhe è meglio usare "ruota", mentre con le liste è meglio "ruota2".

Per i numeri possiamo utilizzare un algoritmo diverso notando che risulta:

r(n) = (n + (10^(L(n)) - 1)*(n mod 10))/10

dove L(n) è la lunghezza del numero n.

La funzione che ruota una cifra di un numero:

(define (rotate-num n)
  (/ (+ n (* (- (pow 10 (length n)) 1) (% n 10))) 10))

(rotate-num 123)
;-> 312

Funzione che crea la lista di tutti i numeri ruotati di n (n compreso):

(define (ruota-num num)
  (local (val out)
    (setq val num)
    (setq out '())
    (push val out)
    (for (i 1 (- (length num) 1))
      (setq val (rotate-num val))
      (push val out -1)
    )
    out))

(ruota-num 123456)
;-> (123456 612345 561234 456123 345612 234561)


------------------------------
Quadrato di una lista ordinata
------------------------------

Data una lista di numeri interi ordinati in ordine non decrescente, una funzione che restituISCE una lista con i quadrati di ciascun numero, anch'essa ordinata in ordine non decrescente.
Ad esempio, data (-2 3 7 7 8), l'output desiderato è (4 9 49 49 64).
Attenzione: data (-4 -1 0 3 10), l'output desiderato è (0 1 9 16 100).

(define (quad lst)
  (let (out '())
    (sort (map (fn (x) (* x x)) lst))))

(quad '(-2 3 7 7 8))
;-> (4 9 49 49 64)
(quad '(-4 -1 0 3 10))
;-> (0 1 9 16 100)


-------------------
Somma da due numeri
-------------------

Dato una lista di numeri interi e un numero intero s, trovare tutte le coppie di numeri interi nella lista che si sommano all'intero s oppure restituire che non esistono coppie di questo tipo.
Consideriamo tre algoritmi con le seguenti complessità temporali: O(n²), O(n*log(n)) e O(n).

Il metodo più semplice è quello di considerare ogni elemento della lista sommandolo a tutti gli altri e controllare se sommano al valore s. Complessità temporale O(n²).

(define (find-coppie lst somma)
  (let (out '())
    (for (i 0 (- (length lst) 2))
      (for (j (+ i 1) (- (length lst) 1))
        (if (= somma (+ (lst i) (lst j)))
          (push (list (lst i) (lst j)) out -1)
        )))
  out))

(find-coppie '(1 5 7 -1 5) 6)
;-> ((1 5) (1 5) (7 -1))
(find-coppie '(2 5 17 -1) 7)
;-> (2 5)
(find-coppie '(3 5 6 -1) 10)
;-> ()
(find-coppie '(2 3 4 -2 6 8 9 11) 6)
;-> ((2 4) (-2 8))
(find-coppie (sequence 1 10) 6)
;-> ((1 5) (2 4))

Un altro metodo è quello di ordinare la lista e poi con due indici (basso e alto) attraversiamo la lista:

(define (find-coppie2 lst somma)
  (local (out alto basso)
    (setq out '())
    (setq alto (- (length lst) 1))
    (setq basso 0)
    (sort lst)
    (while (< basso alto)
      (if (= somma (+ (lst basso) (lst alto)))
          (push (list (lst basso) (lst alto)) out -1)
      )
      (if (> (+ (lst basso) (lst alto)) somma)
          (setq alto (- alto 1))
          (setq basso (+ basso 1))
      )
    )
    out))

(find-coppie2 '(1 5 7 -1 5) 6)
;-> ((-1 7) (1 5))
(find-coppie2 '(-1 1 5 5 7) 6)
;-> ((-1 7) (1 5))
(find-coppie2 '(2 5 17 -1) 7)
;-> ((2 5))
(find-coppie2 '(3 5 6 -1) 10)
;-> ()
(find-coppie2 '(2 3 4 -2 6 8 9 11) 6)
;-> ((-2 8) (2 4))
(find-coppie2 (sequence 1 10) 6)
;-> ((1 5) (2 4))

La complessità temporale di questo secondo metodo non è calcolabile esattamente, poichè utilizziamo la funzione "sort" di newLISP (che dovrebbe utilizzare il merge-sort O(n*log(n)). Comunque è il metodo più veloce proprio perchè utilizziamo la versione integrata (compilata) della funzione "sort".

Il terzo metodo è quello di utilizzare una hash-map con il seguente algoritmo:

  Creare una hash-map
  Per ogni numero della lista
    Se il numero corrente si trova nella hash-map,
        allora inserire il numero corrente e (somma - numero corrente) nella soluzione
    Aggiungere (somma - numero corrente) nella hash-map
  Restituire la soluzione

(define (find-coppie3 lst somma)
  (local (out)
    (setq out '())
    (new Tree 'hash)
    (dolist (el lst)
      (if (hash el)
        (push (list (- somma el) el) out -1)
      )
      (hash (string (- somma el)) (- somma el))
    )
    (delete 'hash)
    out))

(find-coppie3 '(1 5 7 -1 5) 6)
;-> ((1 5) (7 -1) (1 5))
(find-coppie3 '(-1 1 5 5 7) 6)
;-> ((1 5) (1 5) (-1 7))
(find-coppie3 '(2 5 17 -1) 7)
;-> ((2 5))
(find-coppie3 '(3 5 6 -1) 10)
;-> ()
(find-coppie3 '(2 3 4 -2 6 8 9 11) 6)
;-> ((2 4) (-2 8))
(find-coppie3 (sequence 1 10) 6)
;-> ((2 4) (1 5))

Questo algoritmo ha complessità temporale O(n).

Vediamo quale metodo è più veloce:

(time (find-coppie (sequence 1 1000) 500) 10)
;-> 5126.398

(time (find-coppie2 (sequence 1 1000) 500) 10)
;-> 17.951

(time (find-coppie3 (sequence 1 1000) 500) 10)
;-> 11.001


---------------------
Mescolamento perfetto
---------------------

Un mescolamento (shuffle) perfetto, divide un mazzo di carte in due metà uguali (deve esserci un numero pari di carte), quindi le interfoglia perfettamente. Alla fine una serie di mescolamenti perfetti riporta un mazzo al suo ordine originale. Ad esempio, con un mazzo di 8 carte (1 2 3 4 5 6 7 8), il primo mescolamento riordina le carte in (1 5 2 6 3 7 4 8), il secondo mescolamento riordina le carte in (1 3 5 7 2 4 6 8) e il terzo mescolamento ripristina l'ordine originale (1 2 3 4 5 6 7 8).

Scrivere una funzione che esegue un mescolamento perfetto. Scrivere una funzione che calcola quanti mescolamenti perfetti sono necessari per riportare un mazzo di n carte all'ordine originale.
Quante mescolamenti perfetti sono necessari per un mazzo da 52 carte?

(setq lst '(1 2 3 4 5 6 7 8))

Funzione che esegue un mescolamento perfetto:

(define (shuffle lst)
  (let ((out '()) (len (length lst)))
    (for (i 0 (- (/ len 2) 1))
      (push (lst i) out -1) ; inserisce il valore i-esimo
      (push (lst (+ i (/ len 2))) out -1) ; inserisce il valore (i + len/2)-esimo
    )
    out))

(shuffle lst)
;-> (1 5 2 6 3 7 4 8)

(shuffle (shuffle (shuffle lst)))
;-> (1 2 3 4 5 6 7 8)

Funzione che calcola il numero di mescolamenti perfetti per avere nuovamente la lista originale:

(define (shuffle-number lst)
  (local (number calc)
    (setq number 1)
    (setq calc (shuffle lst))
    ; fino a che le liste non sono uguali...
    (while (!= lst calc)
      ; calcola un altro mescolamento perfetto
      (setq calc (shuffle calc))
      (++ number)
    )
    (list (length lst) number)
  ))

(shuffle-number lst)
;-> (8 3)
(shuffle-number (sequence 1 52))
;-> (52 8)

Funzione che calcola il numero di mescolamenti perfetti per tutte le liste fino al valore num:

(define (shuffle-list num)
  (let (out '())
    (for (i 2 num 2)
      (push (shuffle-number (sequence 1 i)) out -1)
    )
    out))

(shuffle-list 128)
;-> ((2 1) (4 2) (6 4) (8 3) (10 6) (12 10) (14 12) (16 4)
;->  (18 8) (20 18) (22 6) (24 11) (26 20) (28 18) (30 28) (32 5)
;->  (34 10) (36 12) (38 36) (40 12) (42 20) (44 14) (46 12) (48 23)
;->  (50 21) (52 8) (54 52) (56 20) (58 18) (60 58) (62 60) (64 6)
;->  (66 12) (68 66) (70 22) (72 35) (74 9) (76 20) (78 30) (80 39)
;->  (82 54) (84 82) (86 8) (88 28) (90 11) (92 12) (94 10) (96 36)
;->  (98 48) (100 30) (102 100) (104 51) (106 12) (108 106) (110 36)
;->  (112 36) (114 28) (116 44) (118 12) (120 24) (122 110) (124 20)
;->  (126 100) (128 7))

Notiamo che risulta: (2 1), (4 2), (8 3), (16 4), (32 5), (64 6), (128 7).

Disegniamo un grafico (spartano) con questi dati:

(setq data (shuffle-list 128))

(dolist (el data) (println (el 0) { - } (dup "*" (el 1))))

  2 - *
  4 - **
  6 - ****
  8 - ***
 10 - ******
 12 - **********
 14 - ************
 16 - ****
 18 - ********
 20 - ******************
 22 - ******
 24 - ***********
 26 - ********************
 28 - ******************
 30 - ****************************
 32 - *****
 34 - **********
 36 - ************
 38 - ************************************
 40 - ************
 42 - ********************
 44 - **************
 46 - ************
 48 - ***********************
 50 - *********************
 52 - ********
 54 - ****************************************************
 56 - ********************
 58 - ******************
 60 - **********************************************************
 62 - ************************************************************
 64 - ******
 66 - ************
 68 - ******************************************************************
 70 - **********************
 72 - ***********************************
 74 - *********
 76 - ********************
 78 - ******************************
 80 - ***************************************
 82 - ******************************************************
 84 - **********************************************************************************
 86 - ********
 88 - ****************************
 90 - ***********
 92 - ************
 94 - **********
 96 - ************************************
 98 - ************************************************
100 - ******************************
102 - ****************************************************************************************************
104 - ***************************************************
106 - ************
108 - **********************************************************************************************************
110 - ************************************
112 - ************************************
114 - ****************************
116 - ********************************************
118 - ************
120 - ************************
122 - **************************************************************************************************************
124 - ********************
126 - ****************************************************************************************************
128 - *******

Proviamo a migliorare la funzione "shuffle" scrivendola in stile lisp per renderla più veloce.

La funzione "take" restituisce i primi n elementi di una lista:

(define (take n lst) (slice lst 0 n))

La funzione "drop" restituisce tutti gli elementi di una lista tranne i primi n:

(define (drop n lst) (slice lst n))

(setq lst '(1 2 3 4 5 6 7 8))

(setq lun (length lst))
;-> 8

(take (/ lun 2) lst)
;-> (1 2 3 4)

(drop (/ lun 2) lst)
;-> (5 6 7 8)

(define (shuf lst)
  (let (len (length lst))
    (flat (map (fn(x y) (cons x y)) (take (/ len 2) lst) (drop (/ len 2) lst)))))
    ;(flat (map (fn(x y) (list x y)) (take (/ len 2) lst) (drop (/ len 2) lst)))))

(shuf lst)
;-> (1 5 2 6 3 7 4 8)

(shuf (shuf (shuf lst)))
;-> (1 2 3 4 5 6 7 8)

Test di velocità:

(silent (setq a (sequence 1 10000)))

(time (shuffle a) 10)
;-> 5313.681

(time (shuf a) 10)
;-> 52.914

La funzione "shuf" è 100 volte più veloce della funzione "shuffle".


---------
Mergesort
---------

Il merge sort è un algoritmo di ordinamento basato su confronti che utilizza un processo di risoluzione ricorsivo, sfruttando la tecnica del Divide et Impera, che consiste nella suddivisione del problema in sottoproblemi della stessa natura di dimensione via via più piccola. Fu inventato da John von Neumann nel 1945.
Concettualmente, l'algoritmo funziona nel seguente modo:
1. Se la lista da ordinare ha lunghezza 0 oppure 1, è già ordinata. Altrimenti:
2. La lista viene divisa (divide) in due metà (se la lista contiene un numero dispari di elementi, viene divisa in due sottoliste di cui la prima ha un elemento in più della seconda)
3. Ognuna di queste sottoliste viene ordinata, applicando ricorsivamente l'algoritmo (impera)
4. Le due sottoliste ordinate vengono fuse (combinate). Per fare questo, si estrae ripetutamente il minimo delle due sottoliste e lo si pone nella lista in uscita, che risulterà ordinata.

Nota: le funzioni utilizzano le variabili locali definite durante la chiamata della funzione (sono quelle che compaiono dopo la virgola). In newLISP le funzioni possono essere chiamate con un numero inferiore di argomenti: le variabili non passate dalla chiamata vengono inizializzate a nil e possiamo usarle come variabili locali. Il carattere "," è un simbolo che viene usato per separare le variabili passate da quelle locali.

Questa funzione combina due liste ordinate:

(define (merge a b , c)
  (while (and a b)
    (if (> (a 0) (b 0))
      (begin (push (b 0) c -1) (pop b))
      (begin (push (a 0) c -1) (pop a))
    )
  )
  (while a
    (push (a 0) c -1)
    (pop a))
  (while b
    (push (b 0) c -1)
    (pop b))
  c
)

(merge '(1 7 15) '(2 8 16))
;-> (1 2 7 8 15 16)

Questa funzione esegue il sort:

(define (mergesort a , n l1 l2)
  (set 'n (length a))
  (if (<= n 1)
    a
    (begin
      (dotimes (i (/ n 2))
        (push (pop a) l1 -1))
      (while a
        (push (pop a) l2 -1))
      (set 'l1 (mergesort l1))
      (set 'l2 (mergesort l2))
      (merge l1 l2)
    )
  )
)

(mergesort '(1 3 8 4 2 10 3))
;-> (1 2 3 3 4 8 10)

(mergesort (randomize (sequence 1 100)))
;-> (1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
;->  26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47
;->  48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69
;->  70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91
;->  92 93 94 95 96 97 98 99 100)

Proviamo a scrivere una versione leggermente diversa:

(define (merge1 a b , c)
  (while (and a b)
    (if (> (a 0) (b 0))
        (push (pop b) c -1)
        (push (pop a) c -1)
    )
  )
  (while a (push (pop a) c -1))
  (while b (push (pop b) c -1))
  c
)

(merge1 '(1 7 15) '(2 8 16))
;-> (1 2 7 8 15 16)

(define (mergesort1 a , n l1 l2)
  (set 'n (length a))
  (if (<= n 1)
    a
    (merge1 (mergesort(0 (/ n 2) a) ) (mergesort ((/ n 2) a)))
  )
)

(mergesort1 (randomize (sequence 1 100)))
;-> (1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
;->  26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47
;->  48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69
;->  70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91
;->  92 93 94 95 96 97 98 99 100)

Vediamo la differenza di velocità:

(silent (setq data (randomize (sequence 1 100000))))

(time (mergesort data) 10)
;-> 7724.649

(time (mergesort1 data) 10)
;-> 7466.869

Proviamo la funzione "sort" di newLisp:

(time (sort data) 10)
;-> 406.836

Nota: Questo algoritmo ha complessità temporale O(n log n) (sempre!).


-----------------------------
Cifre crescenti e decrescenti
-----------------------------

Scrivere un programma che genera una lista con le cifre da 1 a n e quelle da (n - 1) a 1. Ad esempio, se n = 5, il programma dovrebbe generare (1 2 3 4 5 4 3 2 1). È consentito utilizzare solo un singolo ciclo e 0 < n < 10.

Nella prima soluzione sfruttiamo il fatto che newLISP permette di aggiungere un elemento sia all'inizio che alla fine di una lista:

(define (cifre1 n)
  (let (out '())
    (push n out)
    ; ciclo unico
    (for (i (- n 1) 1 -1)
      (push i out)    ; aggiunge all'inizio della lista
      (push i out -1) ; aggiunge alla fine della lista
    )
    out))

(cifre1 5)
;-> (1 2 3 4 5 4 3 2 1)

Nella seconda soluzione utilizziamo la funzione "sequence":

(define (cifre2 n)
  (let (out '())
  (extend out (sequence 1 n) (sequence (- n 1) 1))))

(cifre2 5)
;-> (1 2 3 4 5 4 3 2 1)

Vediamo la velocità delle due funzioni:

(time (cifre1 9) 100000)
;-> 155.373

(time (cifre2 9) 100000)
;-> 79.931


---------------
Somma di numeri
---------------

Dati due interi positivi M e N, trovare N numeri che si sommano a M e la differenza tra il più alto e il più basso di questi numeri non dove essere più di uno. Ad esempio: con M = 26 e N = 7, il risultato è (4 4 4 4 4 3 3).

(define (somma n m)
  (let ((q (/ m n))
        (r (% m n)))
    (append (dup (+ q 1) r)
            (dup q (- n r)))))

(somma 7 26)
;-> (4 4 4 4 4 3 3)

(somma 2 10)
;-> (5 5)

(somma 5 11)
;-> (3 2 2 2 2)

(somma 11 3)
;-> (1 1 1 0 0 0 0 0 0 0 0)


----------------
Operatori logici
----------------

newLISP mette a disposizione gli operatori logici AND, OR e NOT. Possiamo scrivere altri operatori logici utilizzando quelli disponibili:

Funzioni booleane:

(define (nand a b) (not (and a b)))
(define (nor a b) (not (or a b)))
(define (xor a b) (if (nand a b) (or a b) nil))
(define (xnor a b) (not (xor a b)))

Funzioni bitwise:

(define (~& a b) (~ (& a b))) ; nand, bitwise
(define (~| a b) (~ (| a b))) ; nor, bitwise

Lo xor is è disponibile come funzione integratea "^":

(define (~^ a b) (~ (^ a b))) ; xnor, bitwise

Proviamo le funzioni:

(setq lst1 '(true true nil nil))
(setq lst2 '(true nil true nil))

(map and lst1 lst2)
;-> (true nil nil nil)

(map or lst1 lst2)
;-> (true true true nil)

(map nand lst1 lst2)
;-> (nil true true true)

(map nor lst1 lst2)
;-> (nil nil nil true)

(map xor lst1 lst2)
;-> (nil true true nil)

(map xnor lst1 lst2)
;-> (true nil nil true)

newLISP non opera una valutazione completa delle espressioni che contengono più di un operatore logico se una bvalutazione parziale è sufficiente per valutare correttamente il risultato:
Ad esempio:

(setq a nil)
(if (or (> 4 3) (setq a 10)))
;-> true

Poichè la prima espressione è vera (> 4 3) newLISP non valuta la successiva espressione (setq a 10) poichè non è necessaria per valutare l'intera espressione a "true":

a
;-> nil

Lo stesso con l'operatore AND:

(setq b nil)
(if (and (< 4 3) (setq b 10)))
;-> nil

Poichè la prima espressione è vera (< 4 3) newLISP non valuta la successiva espressione (setq b 10) poichè non è necessaria per valutare l'intera espressione a "nil":

b
;-> nil


------------
Quick Select
------------
QuickSelect è un algoritmo di selezione per trovare l'elemento K-esimo più piccolo in un elenco non ordinato.

Algoritmo
Dopo aver trovato il pivot (una posizione (indice) che suddivide la lista in due parti: ogni elemento a sinistra è inferiore al pivot e ogni elemento a destra è più grande del pivot) l'algoritmo ricorre solo per la parte che contiene il k-esimo elemento più piccolo.
Se l'indice dell'elemento partizionato (pivot) è superiore a k, l'algoritmo ricorre per la parte sinistra.
Se l'indice (pivot) è uguale a k, allora abbiamo trovato il k-esimo elemento più piccolo e viene restituito.
Se l'indice (pivot) è inferiore a k, l'algoritmo ricorre per la parte destra

Vediamo lo pseudocodice:

A) Selezione
quickSelect(list, left, right, k)
   if left = right
      return list[left]
   // Select a pivotIndex between left and right
   pivotIndex := partition(list, left, right, pivotIndex)
   if k = pivotIndex
      return list[k]
   else if k < pivotIndex
      right := pivotIndex - 1
   else
      left := pivotIndex + 1

B) Partizione
La partizione è trovare il pivot come menzionato sopra. (Ogni elemento a sinistra è inferiore al pivot e ogni elemento a destra è più grande del pivot) Esistono due algoritmi per trovare il pivot della partizione: Lomuto e Hoare

Partizione Lomuto
Questa partizione sceglie un pivot che in genere è l'ultimo elemento della lista. L'algoritmo mantiene l'indice i mentre esegue la scansione della lista utilizzando un altro indice j in modo tale che gli elementi da i (compresi) siano minori o uguali al pivot e che gli elementi da i+1 a j-1 (inclusi) siano maggiori del pivot.
Questo schema degrada a O (n^2) quando la lista è ordinata.

Lomuto(A, lo, hi) is
   pivot := A[hi]
   i := lo
   for j := lo to hi - 1 do
       if A[j] < pivot then
           if i != j then
               swap A[i] with A[j]
           i := i + 1
   swap A[i] with A[hi]
   return i

Partizione Hoare
Hoare utilizza due indici che iniziano alle estremità della lista da partizionare, quindi si muovono l'uno verso l'altro fino a quando non rilevano un'inversione: una coppia di elementi, uno maggiore o uguale al pivot, uno inferiore o uguale al pivot, che sono nell'ordine sbagliato l'uno rispetto all'altro.
Gli elementi invertiti vengono quindi scambiati. Quando gli indici si incontrano, l'algoritmo si interrompe e restituisce l'indice finale. Esistono molte varianti di questo algoritmo.

Hoare(A, lo, hi) is
   pivot := A[lo]
   i := lo - 1
   j := hi + 1
   loop forever
       do
           i := i + 1
       while A[i] < pivot
       do
           j := j - 1
       while A[j] > pivot
       if i >= j then
           return j
       swap A[i] with A[j]

Implementazione
Per definire questa funzione non seguiremo lo pseudocodice, ma utilizzeremo le primitive di newLISP perchè sono più veloci (in particolare la funzione "sort").
Il parametro k può variare da 1 fino alla lunghezza della lista.

(define (kthsmall lst k)
  (cond ((or (> k (length lst)) (< k 1)) nil)
        (true ((sort lst) (- k 1)))))

(kthsmall '(7 10 4 3 20 15) 1)
;-> 3
(kthsmall '(7 10 4 3 20 15) 6)
;-> 20
(kthsmall '(7 10 4 3 20 15) 0)
;-> nil
(kthsmall '(7 10 4 3 20 15) 7)
;-> nil

Con questo metodo possiamo anche definire la funzione "kthbig":

(define (kthbig lst k)
  (cond ((or (> k (length lst)) (< k 1)) nil)
        (true ((sort lst >) (- k 1)))))

(kthbig '(7 10 4 3 20 15) 1)
;-> 20
(kthbig '(7 10 4 3 20 15) 6)
;-> 3
(kthbig '(7 10 4 3 20 15) 0)
;-> nil
(kthbig '(7 10 4 3 20 15) 7)
;-> nil


------------------
Macchina di Turing
------------------

Una macchina di Turing (o più brevemente MdT) è una macchina ideale che manipola i dati contenuti su un nastro di lunghezza potenzialmente infinita, secondo un insieme prefissato di regole ben definite. In altre parole, è un modello astratto che definisce una macchina in grado di eseguire algoritmi e dotata di un nastro potenzialmente infinito su cui vengono letti o scritti dei simboli.

È un potente strumento teorico che viene usato nella teoria della calcolabilità e nello studio della complessità degli algoritmi, in quanto è di notevole aiuto nel comprendere i limiti del calcolo meccanico. La sua importanza è tale che oggi, per definire in modo formalmente preciso la nozione di algoritmo, si tende a ricondurlo alle elaborazioni effettuabili con macchine di Turing.

La MdT come modello di calcolo è stata introdotta nel 1936 da Alan Turing per dare risposta all'Entscheidungsproblem (problema di decisione) proposto da Hilbert nel suo programma di fondazione formalista della matematica.
La questione di Hilbert era la seguente: «esiste sempre, almeno in linea di principio, un metodo meccanico (cioè una metodo rigoroso) attraverso cui, dato un qualsiasi enunciato matematico, si possa stabilire se esso sia vero o falso?»

Nel 1936 Turing pubblicò un articolo intitolato "On computable numbers, with an application to the Entscheidungsproblem", in cui l'autore risolveva negativamente l'Entscheidungsproblem o problema della decidibilità lanciato nel 1900 da David Hilbert e Wilhelm Ackermann.

La soluzione proposta da Turing consiste nell'utilizzo di un modello matematico capace di simulare il processo di calcolo umano, scomponendolo nei suoi passi ultimi.
La macchina è formata da una testina di lettura e scrittura con cui è in grado di leggere e scrivere su un nastro potenzialmente infinito partizionato, in maniera discreta, in caselle. Ad ogni istante di tempo t1, la macchina si trova in uno stato interno s1 ben determinato, risultato dell'elaborazione compiuta sui dati letti.

Lo stato interno, o configurazione, di un sistema è la condizione in cui si trovano le componenti della macchina ad un determinato istante di tempo t. Le componenti da considerare sono:

- il numero della cella osservata
- il suo contenuto
- l'istruzione da eseguire

Tra tutti i possibili stati, si distinguono:

- una configurazione iniziale, per t=t0 (prima dell'esecuzione del programma)
- una configurazione finale, per t=tn (al termine dell'esecuzione del programma)
- delle configurazioni intermedie, per t=ti (prima dell'esecuzione dell'istruzione oi)

Implementare un algoritmo in questo contesto significa effettuare una delle quattro operazioni elementari:

- spostarsi di una casella a destra
- spostarsi di una casella a sinistra
- scrivere un simbolo preso da un insieme di simboli a sua disposizione su una casella
- cancellare un simbolo già scritto sulla casella che sta osservando
- oppure fermarsi

Eseguire un'operazione o1, tra gli istanti di tempo t1 e t2, vuol dire passare dallo stato interno s1 allo stato s2. Più formalmente questo si esprime in simboli come: {s1,a1,o1,s2} da leggersi come: nello stato interno s1 la macchina osserva il simbolo a1, esegue l'operazione o1 e si ritrova nello stato interno s2.
Turing poté dimostrare che un tale strumento è in grado di svolgere un qualsiasi calcolo, ma non si fermò qui: egli capì che la calcolabilità era parente stretta della dimostrabilità e dunque, così come Gödel aveva distrutto i sogni di gloria dei Principia Mathematica di Russell e Whitehead, così le sue macchine potevano definitivamente chiudere la questione dell'Entscheidungsproblem.

L'importanza della MdT deriva dal fatto che permette di compiere tutte le elaborazioni effettuate da tutte le macchine (elettroniche o meccaniche) apparse nella storia dell'umanità, incluse le elaborazioni degli odierni computer, e perfino tutte le dimostrazioni matematiche conosciute.
Infatti, tutte le macchine che si conoscono possono essere ricondotte al modello estremamente semplice di Turing.

Per ogni problema calcolabile esista una MdT in grado di risolverlo: questa è la cosiddetta congettura di Church-Turing, la quale postula in sostanza che per ogni funzione calcolabile esista una macchina di Turing equivalente, ossia che l'insieme delle funzioni calcolabili coincida con quello delle funzioni ricorsive (tuttavia, questa congettura riguarda la calcolabilità degli algoritmi, e non la loro trattabilità).

Gli algoritmi che possono essere implementati da una MdT si dicono "algoritmi Turing-computabili".

Si conoscono diverse varianti della MdT, ma sono tutte equivalenti. Noi useremo una macchina di Turing deterministica formata da un nastro con istruzioni a cinque campi.

Spiegazione informale
---------------------
La macchina può agire sopra un nastro che si presenta come una sequenza di caselle nelle quali possono essere registrati simboli di un ben determinato alfabeto finito. Essa è dotata di una testina di lettura e scrittura (I/O) con cui è in grado di effettuare operazioni di lettura e scrittura su una casella del nastro. La macchina si evolve nel tempo e ad ogni istante si può trovare in uno stato interno ben determinato facente parte di un insieme finito di stati. Inizialmente sul nastro viene posta una stringa che rappresenta i dati che caratterizzano il problema che viene sottoposto alla macchina. La macchina è dotata anche di un repertorio finito di istruzioni che determinano la sua elaborazione in conseguenza dei dati iniziali. L'elaborazione si sviluppa per passi successivi che corrispondono a una sequenza discreta di istanti successivi. Le proprietà precedenti sono comuni a molte macchine formali (automa a stati finiti, automa a pila, ...). Caratteristica delle MdT è quella di disporre di un nastro potenzialmente infinito, cioè estendibile quanto si vuole qualora questo si renda necessario.

Ogni passo dell'elaborazione viene determinato dallo stato attuale s nel quale la macchina si trova e dal carattere c che la testina di I/O trova sulla casella del nastro su cui è posizionata e si concretizza nell'eventuale modifica del contenuto della casella, nell'eventuale spostamento della testina di una posizione verso destra o verso sinistra e nell'eventuale cambiamento dello stato. Quali azioni vengono effettuate a ogni passo viene determinato dalla istruzione, che supponiamo unica, che ha come prime due componenti s e c. Le altre tre componenti dell'istruzione forniscono nell'ordine il nuovo stato, il nuovo carattere e una richiesta di spostamento verso sinistra, nullo o verso destra.

Un'elaborazione della macchina consiste in una sequenza di sue possibili "configurazioni", ogni configurazione essendo costituita dallo stato interno attuale, dal contenuto del nastro (una stringa di lunghezza finita) e dalla posizione sul nastro della testina di I/O. Nei casi più semplici l'elaborazione ad un certo punto si arresta in quanto non si trova nessuna istruzione in grado di farla proseguire. Si può avere un arresto in una configurazione "utile" dal punto di vista del problema che si vuole risolvere, in tal caso quello che si trova registrato sul nastro all'atto dell'arresto rappresenta il risultato dell'elaborazione. Si può avere però anche un arresto "inutile" che va considerato come una conclusione erronea dell'elaborazione. Può anche accadere che un'elaborazione non abbia mai fine (Problema della fermata).

Spiegazione formale
-------------------
Si definisce macchina di Turing deterministica a un nastro e istruzioni a cinque campi, termine che abbreviamo con MdT1n5i, una macchina formale della seguente forma:

T = <S, s0, F, A, β, δ> dove

S è un insieme finito detto insieme degli stati della macchina;

s0 è un elemento di S detto stato iniziale della T;

F è un sottoinsieme di S detto insieme degli stati finali della T;

A è un alfabeto finito detto alfabeto del nastro della T
β è un carattere dell'alfabeto A detto segno di casella vuota del nastro della T

δ : S x A -> S x A x {-1, 0, +1} è detta funzione di transizione della macchina.

Se δ(s,a) = <t,b,m>, la corrispondente quintupla <s,a,t,b,m> può considerarsi come l'istruzione che viene eseguita quando la macchina si trova nello stato "s" e la testina di I/O legge "a" sulla casella sulla quale è posizionata. Essa comporta la transizione allo stato "t", la scrittura del carattere "b" e:

- quando m = -1 lo spostamento della testina di una posizione a sinistra,
- quando m = 0 nessuno spostamento della testina,
- quando m = +1 lo spostamento della testina di una posizione a destra.

Il problema dell'arresto e la sua indecidibilità
------------------------------------------------
In talune circostanze può essere utile considerare una MdT che presenta un'evoluzione illimitata (infatti si considerano infinite le risorse di spazio e tempo a disposizione della macchina). Ad esempio interessa far procedere "illimitatamente" (cioè "quanto risulta utile") una MdT che genera gli elementi di una successione di oggetti (ad es. i successivi numeri primi, o i successivi numeri di Mersenne, o le successive cifre decimali di un numero irrazionale come pi greco). In altri casi invece un'evoluzione illimitata di una MdT è considerata un insuccesso. Quando si vuole che una MdT ricerchi in un insieme numerabile un elemento con determinate caratteristiche ed essa procede nella ricerca senza fornire alcuna indicazione, ci si trova in una situazione decisamente insoddisfacente: non si sa se interrompere un'elaborazione inutile oppure attendere ancora un risultato che potrebbe essere fornito dopo un ulteriore lavoro in tempi accettabili.

È dunque importante poter stabilire se una MdT, o un altro sistema formale equivalente ("lambda-calcolo" di Church, ad es.), quando le si sottopone una stringa (di dati) si arresti o meno. Questo è detto problema della fermata o problema dell'arresto della macchina di Turing. Si trovano casi nei quali si dimostra o si verifica che si ha l'arresto, casi per i quali si dimostra che l'evoluzione non si arresta (ma potrebbe procedere all'infinito) e casi per i quali non si sa dare risposta.

Sembra ragionevole cercare un procedimento generale per decidere uno di questi problemi. Dato che le MdT si rivelano in grado di risolvere tutti i problemi che si sanno risolvere con gli altri procedimenti noti, è sensato chiedersi se esiste una macchina di Turing in grado di decidere per una qualsiasi coppia (M, d) costituita da una MdT M e da una stringa di dati d se, quando si fornisce d a M, questa si evolve fino ad arrestarsi o meno. Questa richiesta è resa ancor più significativa dall'esistenza, dimostrata dallo stesso Turing, di una cosiddetta macchina di Turing universale, macchina in grado di simulare qualsiasi evoluzione di qualsiasi MdT (anche le evoluzioni di se stessa!). Ebbene Turing ha dimostrato che la macchina di Turing universale non è in grado di decidere in ogni caso il problema dell'arresto. Quindi nessuna macchina di Turing può farlo. Questo risultato negativo si esprime dicendo che il problema dell'arresto è Turing-indecidibile. Se si accetta la congettura di Church-Turing sulla portata della macchina di Turing, si conclude che il problema dell'arresto della macchina di Turing è indecidibile.

Questo risultato negativo costituisce un limite per tutti i meccanismi computazionali: esso costituisce un risultato limitativo di grande importanza generale e per lo studio degli algoritmi. L'importanza generale dipende dal fatto che ogni procedimento dimostrativo automatico si trova equivalente a una computazione che può effettuarsi con una macchina di Turing. Va posto in rilievo che la Turing-indecidibilità del problema dell'arresto si dimostra equivalente al teorema di incompletezza di Gödel, il primo fondamentale risultato limitativo per la matematica. Si trova inoltre nello studio degli algoritmi e della loro complessità che dalla indecidibilità dell'arresto si deducono abbastanza agevolmente molti altri risultati limitativi.

Macchina di Turing Universale
-----------------------------
Il problema con le MdT è che è necessario costruirne una diversa per ogni nuovo calcolo da eseguire, per ogni relazione di input/output.
Questo è il motivo per cui introduciamo l'idea di una macchina di turing universale (MdTU), che prende come parametri di ingresso sia i dati di input sul nastro che la descrizione di una MdT. La MdTU può continuare quindi a simulare la MdT sul resto del contenuto del nastro di input. Una macchina di turing universale può quindi simulare qualsiasi altra macchina.

=============================================================================

===============

 NOTE LIBERE 2

===============

-----------------------------
Creare una lista di frequenza
-----------------------------

Data una lista di lettere dell'alfabeto, costruire la lista delle frequenze.

Esempio:
input  -> (a b g f a f g f g h)
output -> ((a 2) (b 1) (g 3) (f 3) (h 1))

Usiamo una hashmap e vediamo le operazioni fondamentali.

Creiamo una hashmap:
(new Tree 'myHash)

Inserimento di un valore 1 (value) associato ad una chiave K (key) -> (myHash "key" value):
(myHash "K" 1)
;-> 1

Recuperiamo il valore tramite la chiave:
(myHash "K")
;-> 1

Inserimento di un nuovo valore 2 (value) associato ad una chiave W (key) -> (myHash "key" value):
(myHash "W" 2)
;-> 2

Elenco di tutti gli elementi (chiave valore) della hashmap:
(myHash)
;-> (("K" 1) ("W" 2))

Se una chiave non esiste, allora newLISP restituisce nil:
(myHash "X")
;-> nil

Per eliminare un valore occorre assegnare il valore nil:
(myHash "K" nil)
;-> nil
(myHash)
;-> (("W" 2))

Aggiorniamo il valore associato ad una chiave esistente ($it = valore precedente):
(myHash "W" (+ $it 3))
;-> 5
(myHash)
;-> (("W" 5))

Adesso scriviamo la funzione che calcola le frequenze:

(define (freq lst)
  (local (out)
    (setq out '())
    (new Tree 'myHash)
    (dolist (el lst)
      ; se la chiave non esiste nella hashmap...
      (if (null? (myHash (string el)))
          ; allora inserisce la chiave con il valore 1
          (myHash (string el) 1)
          ; altrimenti aggiunge uno al valore associato alla chiave (che esiste)
          (myHash (string el) (+ $it 1))
      )
    )
    ; assegna la hashmap ad una lista
    (setq out (myHash))
    ; elimina la hashmap
    (delete 'myHash)
    out))

(freq '(a b g f a f g f g h))
;-> (("a" 2) ("b" 1) ("f" 3) ("g" 3) ("h" 1))
(freq '(1 2 3 4 5 5 4 3 2 1))
;-> (("1" 2) ("2" 2) ("3" 2) ("4" 2) ("5" 2))
(freq '())
;-> ()


--------------------------------------
Approssimazione razionale di un numero
--------------------------------------

Supponiamo di avere un numero x compreso tra 0 e 1. Vogliamo trovare un'approssimazione razionale per x, ma si desidera considerare solo le frazioni con denominatori al di sotto di un determinato valore N.
Ad esempio, supponiamo che x = 1/e = 0.367879...
Le approssimazioni razionali con potenze di 10 nel denominatore sono banali da trovare: 3/10, 36/100, 367/1000, ecc. Ma supponiamo di limitare il valore del denominatore ad un numero intero N=10. Esiste un'approssimazione migliore di 3/10? Sì, 3/8 = 0.375 è un'approssimazione migliore. Quando N=100, allora la frazione migliore vale 32/87 = 0,36781 (che è molto meglio di 36/100).
Come trovare la migliore approssimazione?
Per iniziare usiamo la ricerca con la forza bruta. Ad esempio, se la dimensione massima del denominatore è N, possiamo provare tutte le frazioni con denominatori inferiori o uguali a N.

La funzione è la seguente:

(define (frac x N)
  (local (num den err val)
    (setq err 999999)
    (for (i 1 N)
      (for (j (+ i 1) N)
        (setq val (abs (sub x (div i j))))
        (if (< val err)
            (begin
              (setq err val)
              (setq num i)
              (setq den j)
            ))
      )
    )
    (list num den)
  )
)

(frac 0.367879 100)
;-> (32 87)
(div 32 87)
;-> 0.367816091954023

(frac 0.605551 30)
;-> (17 28)

(frac 0.36 100)
;-> (9 25)
(div 9 25)
;-> 0.36

Nota: se abbiamo un numero x maggiore di 1 allora possiamo calcolare la frazione approssimatrice del suo inverso. Ad esempio se vogliamo calcolare una frazione per approssimare pi greco:

(setq pi (mul 2.0 (acos 0.0)))
;-> 3.141592653589793

Il suo inverso vale:

(div 1 3.141592653589793)
;-> 0.3183098861837907

L'inverso di un numero può essere calcolato più velocemente se non inseriamo 1 nella divisione:

(div 3.141592653589793)
;-> 0.3183098861837907

(frac 0.3183098861837907 1000)
;-> (113 355)

Vediamo quanto vale questa frazione (o meglio, il suo inverso):

(div 355 113)
;-> 3.141592920353983

L'errore vale:

(sub pi (div 355 113))
;-> -2.667641894049666e-007

Possiamo migliorare la precisione della frazione utilizzando un valore di N maggiore (ma non sempre):

(frac 0.3183098861837907 10000)
;-> (113 355)

In questo caso abbiamo ottenuto la stessa frazione approssimatrice. Anche con N=30000 otteniamo lo stesso risultato:

(frac 0.3183098861837907 50000)
;-> (113 355)

Proviamo con il primo esempio (1/e = 0.367879...) e poniamo N=10000:

(frac 0.367879 10000)
;-> (1143 3107)

Con N=1000 avevamo ottenuto:

(frac 0.367879 1000)
;-> (323 878)

Vediamo il valore degli errori in entrambi i casi:

(abs (sub 0.367879 (div 1143 3107)))
;-> 1.705825558584451e-008

(abs (sub 0.367879 (div 323 878)))
;-> 2.548974943061833e-006

Come previsto con N=10000 il risultato è più preciso.

Con questo metodo otteniamo sempre il risultato ottimo, ma possiamo usare solo valori di N minori di 100000, altrimenti il tempo di calcolo diventa molto lungo.
Esiste un algoritmo molto più efficiente che è correlato alla sequenza di Farey.
L'idea è di iniziare con due frazioni, a/b = 0/1 e c/d = 1/1. Aggiorniamo a/b oppure c/d ad ogni passaggio in modo che a/b sia il limite inferiore migliore di x con denominatore non più grande di b, e c/d sarà il limite superiore migliore con denominatore non più grande di d. Ad ogni passo facciamo una sorta di ricerca binaria introducendo il valore "mediant" dei limiti superiore e inferiore. Il valore di "mediant" di a/b e c/d è la frazione (a + c)/(b + d) che si trova sempre tra a/b e c/d.

Scriviamo la funzione:

(define (fraction x N)
  (catch
  (local (a b c d mediant)
    (setq a 0 b 1)
    (setq c 1 d 1)
    (while (and (<= b N) (<= d N))
      (setq mediant (div (+ a c) (+ b d)))
      (cond ((= x mediant)
             (if (<= (+ b d) N)
                 (throw (list (+ a c) (+ b d)))
                 (if (> d b)
                     (throw (list c d))
                     (throw (list a b)))))
            ((> x mediant)
             (setq a (+ a c))
             (setq b (+ b d)))
            (true
             (setq c (+ a c))
             (setq d (+ b d)))
      )
    )
    (if (> b N)
        (throw (list c d))
        (throw (list a b)))
  )))

Questo algoritmo è molto più veloce, ma non produce sempre il risultato ottimo:

(fraction 0.367879 100)
;-> (32 87)

(fraction 0.605551 30)
;-> (3 5)

Questo non è il risultato ottimo, infatti con la funzione "frac" avevamo ottenuto (17 28), che è un'approssimazione migliore per il numero 0.605551.
Inoltre possiamo migliorare l'espressione (= x mediant) con l'espressione:

(< (abs (sub x mediant)) epsilon)

dove epsilon (per esempio 1e-6) rappresenta il valore di accuratezza (infatti non si può determinare correttamente l'uguaglianza tra due numeri in virgola mobile).

Vediamo un altro esempio con il numero "e":

(exp 1)
;-> 2.718281828459045
(div (exp 1))
;-> 0.3678794411714423

(frac (div (exp 1)) 100)
;-> (32 87)
(div 87 32)
;-> 2.71875

(frac (div (exp 1)) 1000)
;-> (323 878)
(div 878 323)
;-> 2.718266253869969

(frac (div (exp 1)) 10000)
;-> (1001 2721)
(div 2721 1001)
;-> 2.718281718281718

Esistono altri metodi per calcolare l'approsimazione razionale di un numero (ad esempio utilizzando le frazioni continue), ma la scelta del metodo dipende dall'uso che vogliamo fare del risultato. In genere ricorriamo ad una frazione quando i numeri in virgola mobile non hanno la precisione che ci serve oppure per velocizzare il calcolo (usando numeri interi i calcoli sono molto più veloci).


----------------------------
Modificare le liste annidate
----------------------------

Per modificare una lista annidata possiamo usare la funzione "setf":

(setq lst '(a 0 (a 1 (b 2 3 4 (c 5 6 7)))))
;-> (a 0 (a 1 (b 2 3 4 (c 5 6 7))))

Adesso per modificare il valore del simbolo "c" possiamo calcolare il suo indice nella lista:

(setq r (ref 'c lst))
;-> (2 2 4 0)

E poi usare l'indicizzazione implicita:

(setf (lst r) 1311234123)
;-> 1311234123

lst
;-> (a 0 (a 1 (b 2 3 4 (1311234123 5 6 7))))


---------------------------------------
Criptare un file sorgente o un contesto
---------------------------------------

Supponiamo di avere un file "fenc.lsp" che contiene le seguenti funzioni:

(define (showinfo) (println "demo encrypt file"))

(define (somma x y) (add x y))

Per criptare questo file possiamo utilizzare la seguente espressione:

(write-file "fenc.enc" (encrypt (read-file "fenc.lsp") "password"))
;-> 106 ;numero di caratteri del file

Adesso possiamo eseguire una funzione dal file criptato nel modo seguente:

(eval-string (encrypt (read-file "fenc.enc") "password"))
;-> (lambda (x y) (add x y))

Viene restitutia solo l'ultima funzione valutata, ma possiamo eseguire qualunque funzione contenuta nel file "fenc.enc":

(showinfo)
;-> demo encrypt file
;-> "demo encrypt file"

(somma 10 4)
;-> 14

Per verificare se un simbolo esiste in un contesto possiamo usare la seguente espressione:

(sym "somma" 'MAIN nil)
;-> somma

(sym "showinfo" 'MAIN nil)
;-> showinfo

(sym "aaabbb" MAIN nil)
;-> nil

Per eliminare tutti i simboli (creati dall'utente) di un contesto possiamo scrivere:

(map delete (symbols 'MAIN))

In questo modo vengono cancellati solo i simboli del contesto che sono stati definiti dall'utente:
(sym "somma" 'MAIN nil)
;-> nil
(sym "showinfo" 'MAIN nil)
;-> nil
(sym "aaabbb" MAIN nil)
;-> nil
(sym "sin" MAIN nil)
;-> sin

Scriviamo due funzioni che salvano/caricano un contesto in/da un file criptato:

;;
;; Salva un contesto in un file criptato con password
;;
;; esempio:
;;
;; (save-encrypted "mycontext.enc" "password" 'MyCTX)
;;
(define (save-encrypted file-name pwd ctx)
  (save ".enctmp" ctx)
  (write-file file-name (encrypt (read-file ".enctmp") pwd))
  (delete-file ".enctmp"))

;;
;; Carica/valuta un file sorgente criptato
;;
;; esempio:
;;
;; (load-encrypted "mycontext.enc" "password")
;;
(define (load-encrypted file-name pwd)
  (write-file ".enctmp" (encrypt (read-file file-name) pwd))
  (load ".enctmp")
  (delete-file ".enctmp"))

Nota: il contesto caricato non deve contenere la funzione "load-encrypted".
L'overload di una funzione in esecuzione provoca l'arresto anomalo del sistema. Inoltre, per un breve periodo di tempo i dati si trovano in un file ".enctmp" in forma non crittografata durante il salvataggio o il caricamento, ma questo file viene eliminato in seguito.


--------------------------
Leggere e stampare un file
--------------------------

Per stampare un file possiamo usare il codice seguente:

(setq fh (open "fenc.lsp" "read"))
(while (read-line fh)
  (setq tl (current-line))
  (println tl)
)
(close fh)
;-> 3
;-> ; demo encrypt file
;-> (define (showinfo) (println "demo encrypt file"))
;->
;-> (define (somma x y) (add x y))
;-> "(define (somma x y) (add x y))"
;-> true

Se vogliamo estrarre solo le linee uniche da un file di testo possiamo usare la seguente funzione:

(set 'uniqueLines '())
  (while (read-line inFile)
    (if (not (member (current-line) uniqueLines))
        (set 'uniqueLines (append uniqueLines (list (current-line))))))
  (close inFile)
  (map (lambda (aLine) (write-line aLine outFile)) uniqueLines)
  (close outFile)


-----------
Lisp reader
-----------

Un "Lisp reader" si riferisce a una procedura Lisp, vale a dire la funzione "read", che legge i caratteri da un flusso di input e li interpreta e li converte come rappresentazioni di oggetti Lisp (AST Abstract Syntax Tree).

In newLISP per valutare un file di testo possiamo usare due metodi:

1) (load "file.lsp")
2) (eval-string (read-file "file.lsp"))

L'unica differenza tra questi due metodi è che la funzione "load" legge il file e allo stesso tempo valuta le espressioni, mentre il secondo metodo legge interamente il file in una stringa e poi la valuta. In altre parole, "load" gestisce senza problemi anche file molto grandi perchè valuta le S-espressioni appena vengono lette, convertendo ed valutando al volo.

newLISP ha anche una funzione "eval" che funziona soltanto con il formato interno delle S-espressioni e non con le stringhe:

(setq x '(+ 3 4))
;-> (+ 3 4)
x
;-> (+ 3 4)
(eval x)
;-> 7

(eval-string "(+ 3 4)")
;-> 7

La seguente funzione simula (in modo semplificato) il comportamento della funzione "read" in Common Lisp:

(define (reader readstr readret)
   (cond
      ((float readstr)
       (if (find "." readstr)
         (setq readret (float readstr))
         (setq readret (integer readstr))
       )
      )
      ((= (slice readstr 0 1)"(")
          (setq readret (eval-string (append "'" readstr)))
      )
      (true
         (setq readret (sym readstr))
      )
   )
)

(eval (reader "(+ 1 2)" a))
;-> 3

(eval (reader "(+ 1 (/ 2 2))" a))
;-> 2

(eval (reader "(add 1.2 (div 2 2))" a))
;-> 2.2


------------------------
Liste e vettori annidati
------------------------

La struttura dati di base è la lista, ma newLISP permette di utilizzare anche i vettori.
I vettori vengono dichiarati con la funzione "array".

*******************
>>> funzione ARRAY
*******************
sintassi: (array int-n1 [int-n2 ...] [list-init])
Crea un vettore con elementi int-n1, inizializzandolo facoltativamente con il contenuto di list-init. È possibile specificare fino a sedici dimensioni per matrici multidimensionali.

Internamente, newLISP crea vettori multidimensionali usando vettori come elementi di un vettore. I vettori/matrici in newLISP devono essere utilizzati ogni volta che l'indicizzazione in un grande lista diventa troppo lenta. Non tutte le funzioni delle liste possono essere utilizzate sui vettori. Per una discussione più dettagliata, consultare il capitolo sui vettori.

(array 5)
;-> (nil nil nil nil nil)

(array 5 (sequence 1  5))
;-> (1 2 3 4 5)

(array 10 '(1 2))
;-> (1 2 1 2 1 2 1 2 1 2)

I vettori possono essere inizializzati con oggetti di qualsiasi tipo. Se vengono forniti meno inizializzatori rispetto agli elementi, l'elenco viene ripetuto fino a quando non vengono inizializzati tutti gli elementi del vettore.

(set 'myarray (array 3 4 (sequence 1 12)))
;-> ((1 2 3 4) (5 6 7 8) (9 10 11 12))

I vettori vengono modificati e sono accessibili utilizzando la maggior parte delle stesse funzioni utilizzate per modificare le litse:

(setf (myarray 2 3) 99) → 99)
myarray
;-> ((1 2 3 4) (5 6 7 8) (9 10 11 99))

(setf (myarray 1 1) "hello")
;-> "hello"
myarray
;-> ((1 2 3 4) (5 "hello" 7 8) (9 10 11 99))

(setf (myarray 1) '(a b c d))
;-> (a b c d)
myarray
;-> ((1 2 3 4) (a b c d) (9 10 11 99))

(nth 1 myarray)
;-> (a b c d)  ; access a whole row

;; use implicit indexing and slicing on arrays

(myarray 1)
;-> (a b c d)

(myarray 0 -1)
;-> 4

(2 myarray)
;-> ((9 10 11 99))

(-3 2 myarray)
;-> ((1 2 3 4) (a b c d))

Bisogna fare attenzione ad usare un vettore quando si sostituisce un'intera riga. La funzione "array-list" può essere usata per riconvertire i vettori in liste:

(array-list myarray)
;-> ((1 2 3 4) (a b c d) (1 2 3 99))

Per riconvertire un elenco in una lista, applicare la funzione "flat" alla lista:

(set 'aList '((1 2) (3 4)))
;-> ((1 2) (3 4))

(set 'aArray (array 2 2 (flat aList)))
;-> ((1 2) (3 4))

La funzione "array?" viene usata per determinare se un'espressione è un vettore:

(array? myarray)
;-> true

(array? (array-list myarray))
;-> nil

Quando si serializzano i vettori usando la funzione "source" o "save", il codice generato include l'istruzione array necessaria per crearli. In questo modo, le variabili che contengono il vettore vengono serializzate correttamente quando si salva con "save" o si creano stringhe di sorgente usando "source".

(set 'myarray (array 3 4 (sequence 1 12)))

(save "array.lsp" 'myarray)

;; Contenuto del file array.lsp ;;

(set 'myarray (array 3 4 (flat '(
  (1 2 3 4)
  (5 6 7 8)
  (9 10 11 12)))))

I vettori possono contenere tipi di dati diversi:

(setq vet (array 10 '(1 2)))
;-> (1 2 1 2 1 2 1 2 1 2)
(vet 1)
;-> 2
(setf (vet 1) "a")
;-> "a"
vet
;-> (1 "a" 1 2 1 2 1 2 1 2)

Considerando le strutture dati annidate possiamo avere i seguenti accoppiamenti di base:

1) lista di liste
2) lista di vettori
3) vettore di liste
4) vettore di vettori (matrici)

Vediamo con semplici esempi il loro uso caso per caso.

Lista di Liste
--------------
Definiamo una lista di liste:

(setq lst-lst '((1 2) (a b) ("c" "d")))

Possiamo accedere agli elementi di questa struttura con l'indicizzazione implicita:

(lst-lst 1)
;-> (a b)

(lst-lst 2 0)
;-> "c"

Per modificare un elemento usiamo ancora l'indicizzazione implicita con la funzione "setf":

(setf (lst-lst 1) 9)
;-> 9
lst-lst
;-> ((1 2) 9 ("c" "d"))

(setf (lst-lst 2 0) "z")
;-> "z"
lst-lst
;-> ((1 2) 9 ("z" "d"))

Per aggiungere un elemento alla lista usiamo la funzione "push":

(push '(k1 k2) lst-lst -1)
;-> ((1 2) 9 ("z" "d") (k1 k2))

Lista di Vettori
----------------
Definiamo tre vettori:

(setq vet1 (array 2 '(1 2)))
;-> (1 2)

(setq vet2 (array 2 '(a b)))
;-> (a b)

(setq vet3 (array 2 '("c" "d")))
;-> ("c" "d")

Definiamo una lista che contiene i tre vettori:

(setq lst-vet (list vet1 vet2 vet3))
;-> ((1 2) (a b) ("c" "d"))

(lst-vet 1)
;-> (a b)

Comunque in questo modo i vettori vengono trasformati in liste all'interno della lista che li contiene:

(array? (lst-vet 1))
;-> nil
(list? (lst-vet 1))
;-> true

Proviamo ad utilizzare la funzione "push" per creare la lista:

(setq lst-vet '())
;-> ()
(push vet1 lst-vet -1)
;-> ((1 2))
(push vet2 lst-vet -1)
;-> ((1 2) (a b))
(push vet3 lst-vet -1)
;-> ((1 2) (a b) ("c" "d"))
lst-vet
;-> ((1 2) (a b) ("c" "d"))

In questo modo i vettori rimangono tali all'interno della lista globale:

(array? (lst-vet 1))
;-> true
(list? (lst-vet 1))
;-> nil

Anche in questo caso possiamo accedere agli elementi di questa struttura con l'indicizzazione implicita (anche se con una sintassi leggermente diversa dovuta al fatto che usiamo i vettori):

(lst-vet 1)
;-> (a b)

((lst-vet 1) 0)
;-> a

Per modificare un elemento usiamo ancora l'indicizzazione implicita con la funzione "setf":

(setf ((lst-vet 1) 0) 'z)
;-> z
lst-vet
;-> ((1 2) (z b) ("c" "d"))

(setf ((lst-vet 2) 0) "z")
;-> "z"
lst-vet
;-> ((1 2) (z b) ("z" "d"))

Per aggiungere un elemento alla lista usiamo la funzione "push":

(push '(k1 k2) lst-vet -1)
;-> ((1 2) 9 ("z" "d") (k1 k2))

(lst-vet 3)
;-> (k1 k2))

Attenzione, in questo modo abbiamo aggiunto una lista (k1 k2), non un vettore:

(list? (lst-vet 3))
;-> true

Vettore di Liste
----------------
Definiamo un vettore di liste inizializzando il vettore direttamente con il valore delle liste:

(setq vet-lst (array 4 '((1 2) (a b) (8 9) ("c" "d"))))
;-> ((1 2) (a b) (8 9) ("c" "d"))
(vet-lst 0)
;-> (1 2)

Verifichiamo che gli elementi del vettore siano delle liste:

(array? vet-lst)
;-> true
(list? (vet-lst 0))
;-> true

Per accedere ad un valore di una lista contenuta nel vettore usiamo l'indicizzazione implicita:

((vet-lst 0) 0)
;-> 1

Per modificare un valore di una lista contenuta nel vettore usiamo l'indicizzazione implicita:

(setf ((vet-lst 0) 0) "0")
;-> "0"

vet-lst
;-> (("0" 2) (a b) (8 9) ("c" "d"))

Per aggiungere un valore ad una lista contenuta nel vettore usiamo l'indicizzazione implicita:

(vet-lst 1)
;-> (a b)

(push 'c (vet-lst 1) -1)
;-> (a b c)
vet-lst
;-> (("0" 2) (a b c) (8 9) ("c" "d"))

Vettore di vettori
------------------
In questo caso stiamo parlando di una matrice, che viene gestita come un vettore con i relativi indici.

Infine scriviamo una funzione che permette di accedere a tutti gli elementi di una lista annidata (uno x uno):

(define (walk-tree tree-list)
    (dolist (elmnt tree-list)
        (if (list? elmnt)
            (walk-tree elmnt)
            (do-something-to elmnt))))

Sostituiamo "do-something-to" con la funzione "print":

(define (walk-tree tree-list)
    (dolist (elmnt tree-list)
        (if (list? elmnt)
            (walk-tree elmnt)
            (print elmnt { }))))

(walk-tree '(a b (c d (e f) g) h i))
;-> a b c d e f g h i " "

(walk-tree '(a (b (c (d (e (f (g (h (i))))))))))
;-> a b c d e f g h i " "

Il nome della funzione "walk-tree" è dovuto al fatto che la lista può rappresentare un albero, come nel seguente esempio:

           A
          / \
         /   \
        /     \
       B       C
      / \     / \
     /   \   /   \
    D     E ()    F
                 / \
                /   \
               G    ()

(setq tree '(A (B (D () ()) (E () ())) (C () (F (G () ()) ()))))

(walk-tree tree)
;-> A B D E C F G nil

La funzione "walk-tree" attraversa l'albero nello stesso ordine della funzione "(bst-traverse-preorder tree)" che abbiamo visto nella sezione dedicata agli alberi binari:

(bst-traverse-preorder tree)
;-> (A B D E C F G)


------------------------------------------------
Conversione di un numero da una base ad un'altra
------------------------------------------------

https://cs.stackexchange.com/questions/10318/the-math-behind-converting-from-any-base-to-any-base-without-going-through-base/10321

Per convertire un numero da una base ad un'altra base dobbiamo fare una considerazione astratta: un numero non è la sua rappresentazione numerica.
Un numero è un oggetto matematico astratto, mentre la sua rappresentazione numerica è una cosa concreta, vale a dire una sequenza di simboli su un foglio (o una sequenza di bit in memoria, o una sequenza di suoni che emettiamo quando comunichiamo un numero). Ciò che confonde è il fatto che non vediamo mai un numero, ma sempre la sua rappresentazione numerica. Quindi finiamo per pensare che il numero sia la rappresentazione.

Pertanto, la domanda corretta da porre non è "come convertire da una base all'altra", ma piuttosto "come faccio a scoprire quale numero è rappresentato da una determinata lista di cifre" e "come trovo la rappresentazione delle cifre di un dato il numero ".

Scriviamo due funzioni, una per convertire una rappresentazione numerica in un numero e un'altra per fare il contrario.
Nota: quando eseguiamo la funzione sullo schermo verrà visualizzato il numero ottenuto nella base 10, ma questo non significa che il computer mantenga i numeri nella base 10 (infatti non è così). Non è rilevante il modo in cui il computer rappresenta i numeri.

(define (todigits n b)
; Converte un numero positivo n nelle cifre della rappresentazione in base b
  (let (digits '())
    (while (> n 0)
      (push (% n b) digits)
      (setq n (/ n b))
    )
    digits))

(todigits 10 2)
;-> (1 0 1 0)

(define (fromdigits digits b)
; Calcola il numero rappresentato dalle cifre (digits) in base b
  (let (n 0)
    (dolist (x digits)
      (setq n (+ (* b n) x))
    )))

(todigits 84 2)
;-> (1 0 1 0 1 0 0)
(todigits 84 3)
;-> (1 0 0 1 0)
(fromdigits '(1 0 0 1 0) 3)
;-> 84

(todigits 100 16)
;-> (6 4)
(fromdigits '(6 4) 16)
;-> 100

(todigits 92 3)
;-> (1 0 1 0 2)
(fromdigits '(1 0 1 0 2) 3)
;-> 92

(fromdigits '(1 0 1 0 2) 4)
;-> 274
(todigits 274 4)
;-> (1 0 1 0 2)

Utilizzando queste due funzioni possiamo scrivere la funzione che risolve il problema:

(define (convert-base digits b c)
; Converte le cifre che rappresentano un numero in base b
; nele cifre che rappresentano il numero in base c
  (todigits (fromdigits digits b) c))

(convert-base '(1 1 2 0) 3 2)
;-> (1 0 1 0 1 0)

Nota: la conversione non passa attraverso una rappresentazione in base 10. Abbiamo convertito la rappresentazione di base b nel numero, quindi il numero in base c. Il numero non era in nessuna rappresentazione (a parte quella interna del computer).

Per rappresentare le cifre contenute in digits in una simbologia standard (0..Z) possiamo usare la funzione seguente:

(define (tosymbol digits b)
; Rappresenta la rappresentazione delle cifre in base b in un simbolo
; valore massimo per la base b = 36
  (local (alfabeto simbolo)
    (setq alfabeto '(0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z))
    (setq simbolo "")
    (dolist (s digits)
      (setq simbolo (string simbolo (alfabeto s)))
    )
    simbolo))

(length alfabeto)
(todigits 10 2)
;-> (1 0 1 0)
(tosymbol '(1 0 1 0) 2)
"1010"

(todigits 31 16)
;-> (1 15)
(fromdigits '(1 15) 16)
;-> 31
(tosymbol '(1 15) 16)
"1F"

(todigits 255 16)
;-> (15 15)
(tosymbol '(15 15) 16)
"FF"


-------------------------------------------
Convertire una stringa in un numero univoco
-------------------------------------------

Data una stringa di lunghezza n costituita da alcuni dei seguenti caratteri  0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ determinare un algoritmo che converte la stringa in un numero univoco. In altre parole, due stringhe differenti devono produrre numeri differenti.

Naturalmente, poichè i numeri interi sono limitati (MAXINT 9223372036854775807) la lunghezza della stringa deve essere inferiore ad un certo valore.

Il nostro algoritmo assegna il numero nel modo seguente:

(setq alfabeto '(0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z))

La stringa "A6HJ92B" si trasforma nel numero:

10×36⁶ + 6×36⁵ + 17×36⁴ + 19×36³ + 9×36² + 2×36 + 11 = 22160072099.

Quindi la funzione è la seguente:

(define (str-int str)
  (local (alfabeto pot n)
    ; valore massimo della potenza
    (setq pot (- (length str) 1))
    (setq alfabeto '("0" "1" "2" "3" "4" "5" "6" "7" "8" "9" "A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O" "P" "Q" "R" "S" "T" "U" "V" "W" "X" "Y" "Z"))
    (setq n 0)
    (dolist (ch (explode str))
      (setq n (+ n (* (find ch alfabeto) (pow 36 (- pot $idx)))))
    )
    n
  )
)

(str-int "A6HJ92B")
;-> 22160072099

(str-int "MASSIMO")
;-> 48542232912

Un numero negativo come risultato indica un overflow nella conversione:

(str-int "DFHASFHASFGHASDFJASDHASDDF")
;-> -3908018479449362464


------
Reduce
------

Il LISP ha la funzione "reduce" che applica una funzione "tra" gli elementi di una lista. Prende il nome dal fatto che riduce la lista ad un singolo elemento. Questo risultato viene ottenuto applicando la funzione ai primi due elementi della lista, poi applicando la funzione al risultato e al terzo elemento della lista, ecc.

In newLISP possiamo scrivere (funzione è stata proposta da nigelbrown):

(define (reduce funct lst)
  (cond
    ;;no elements - return nil
    ((not lst) nil)
    ;; one element - return it
    ((not (rest lst)) (first lst))
    ;; more than one element - recurse
    (true (apply funct (list (first lst) (my-reduce funct (rest lst)))))))

(reduce 'append '((A B) (C D) (E F G) () (H I)))
;-> (A B C D E F G H I)

(reduce '+ '(1 3 4 5))
;-> 13

(reduce 'gcd '(12 32 16))
;-> 4

Attualmente newLISP ha integrato la funzionalità di "reduce" nella funzione "apply":

(apply 'append '((A B) (C D) (E F G) () (H I)))

(apply '+ '(1 3 4 5))
;-> 13

(apply 'gcd '(12 32 16))
;-> 4

(apply 'append '((A B) (C D) (E F G) () (H I)))

Inoltre, possiamo anche specificare il numero di parametri che utilizza la funzione ogni volta che applica la riduzione. Per esempio, se vogliamo usare una funzione che utilizza tre parametri possiamo scrivere:

(define (tri a b c) (+ a b c))

(tri 1 2 3)
;-> 6

Adesso riduciamo la lista utilizzando tre parametri (elementi) per volta:

(apply 'tri '(1 2 3 4 5 6 7) 3)
;-> 28

(1 + 2 + 3) = 6
6 + (4 + 5) = 15
15 + (6 + 7) = 28

Attenzione, la funzione "tri" vuole sempre tre parametri:

(apply 'tri '(1 2 3 4 5 6 7) 2)
;-> ERR: value expected in function + : c
;-> called from user function (tri 1 2)


-----------------
Quadrati nascosti
-----------------

Dato un numero intero n non negativo, determinare quanti quadrati perfetti esistono leggendo le cifre da sinistra a destra.

Esempio:

n = 1625649
quadrati perfetti: (165649 169 16 169 16 1 625 64 256 25 64 49 4 9)

165649 -> (1)(6)2(5)(6)(4)(9)
169    -> (1)(6)2564(9)
16     -> (1)(6)25649
169    -> (1)625(6)4(9)
16     -> (1)(6)25649
1      -> (1)625649
625    -> 1(6)(2)(5)649
64     -> 1(6)256(4)9
256    -> 16(2)(5)(6)49
25     -> 16(2)(5)649
64     -> 1625(6)(4)9
49     -> 16256(4)(9)
4      -> 16256(4)9
9      -> 162564(9)

Da notare che un quadrato perfetto può comparire più di una volta (16, 64 e 169)

La funzione che calcola l'insieme potenza genera tutti i numeri:

(define (powerset lst)
  (if (empty? lst)
      (list '())
      (let ( (element (first lst))
             (p (powerset (rest lst))))
           (append (map (fn (subset) (cons element subset)) p) p) )))

(powerset '(a b c))
;-> ((a b c) (a b) (a c) (a) (b c) (b) (c) ())

Prima dobbiamo scomporre il numero in una lista di cifre-stringa:

(powerset (explode (string 162)))
;-> (("1" "6" "2") ("1" "6") ("1" "2") ("1") ("6" "2") ("6") ("2") ())

Poi ci serve una funzione che ricompone ogni numero rappresenta come cifra-stringa:

(define (lst2int lst) (int (join lst)))

(lst2int '("1" "2" "3"))
;-> 123

(lst2int '())
;-> nil

Poi utilizziamo una funzione che verifica se un numero è un quadrato perfetto:

(define (square? n)
  (let (v (+ (sqrt n 0.5)))
    (= n (* v v))))

(square? 25)
;-> true
(square? 0)
;-> true

Adesso possiamo scrivere la funzione finale:

(define (hidden-square n)
  (local (lst num out)
    (setq out '())
    (setq lst (powerset (explode (string n))))
    (dolist (el lst)
      ;(println el)
      (setq num (lst2int el))
      (if (and num (square? num))
        (push num out -1)
      )
    )
    out))

Proviamo con il numero dell'esempio:

(hidden-square 1625649)
;-> (165649 169 16 169 16 1 625 64 256 25 64 49 4 9)

(hidden-square 1234567890)
;-> (13456 134689 13689 1369 169 16 1 256 25 289 36 49 4 9 0)

Attenzione ai numeri con diversi 1 e 0:

(hidden-square 11110000)
;-> (10000 100 100 100 100 100 100 1 10000 100 100 100 100
;->  100 100 1 10000 100 100 100 100 100 100 1 10000 100 100
;->  100 100 100 100 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)


-----------------
Push, cons e list
-----------------

Vediamo alcune differenze nell'applicazione delle funzioni "push", "cons" e "list". Consideriamo le seguenti operazioni:
1) aggiunta di un elemento ad una lista
2) aggiunta di una lista ad un'altra lista

Primo caso
----------
Aggiungiamo un elemento all'inizio di una lista:

(push 1 '(2 3))
;-> (1 2 3)
(cons 1 '(2 3))
;-> (1 2 3)
(list 1 '(2 3))
;-> (1 (2 3))

Aggiungiamo un elemento in fondo ad una lista:

(push 1 '(2 3) -1)
;-> (2 3 1)
(cons '(2 3) 1)
;-> ((2 3) 1)
(list '(2 3) 1)
;-> ((2 3) 1)

Secondo caso
------------
Aggiungiamo una lista ad un'altra lista:

(push '(1 2) '(3 4))
;-> ((1 2) 3 4)
(cons '(1 2) '(3 4))
;-> ((1 2) 3 4)
(list '(1 2) '(3 4))
;-> ((1 2) (3 4))


-------------
Append esteso
-------------

Vediamo la definizione del manuale della funzione "append":

*******************
>>>funzione APPEND
*******************
sintassi: (append list-1 [list-2 ... ])
sintassi: (append array-1 [array-2 ... ])
sintassi: (append str-1 [str-2 ... ])

Nella prima forma, append funziona con le liste, appendendo le liste list-1 fino a list-nn per formare una nuova lista. Le liste originali non vengono modificate.

(append '(1 2 3) '(4 5 6) '(a b))
;-> (1 2 3 4 5 6 a b)

(set 'aList '("hello" "world"))
;-> ("hello" "world")

(append aList '("here" "I am"))
;-> ("hello" "world" "here" "I am")

Nella seconda forma "append" funziona con i vettori:

(set 'A (array 3 2 (sequence 1 6)))
;-> ((1 2) (3 4) (5 6))
(set 'B (array 2 2 (sequence 7 10)))
;-> ((7 8) (9 10))

(append A B)
;-> ((1 2) (3 4) (5 6) (7 8) (9 10))

(append B B B)
;-> ((7 8) (9 10) (7 8) (9 10) (7 8) (9 10))

Nella terza forma, "append" funziona con le stringhe. Le stringhe in str-n vengono concatenate in una nuova stringa e poi viene restituita.

(set 'more " how are you")
;-> " how are you"

(append "Hello " "world," more)
;-> "Hello world, how are you"

"append" è anche adatta per l'elaborazione di stringhe binarie contenenti zeri. La funzione "string" taglierà le stringhe con zero byte.

È possibile unire caratteri o stringhe utilizzando la funzione "join". Utilizzare la funzione "string" per convertire gli argomenti in stringhe e appenderle in un solo passaggio.

Utilizzare le funzioni "extend" e "push" per appendere ad una lista esistente o ad una stringa modificando la destinazione.

Questa funzione non permette di inserire liste nulle:

(setq a '(1 2))
(append a '(3) '(4) '(5))
;-> (1 2 3 4 5)

(append b '(3) '(4) '(5))
;-> ERR: array, list or string expected in function append : nil

Scriviamo una funzione che permette di utilizzare liste nulle (nil):

(define (append-nil alist )
   (if alist
      (begin
      (setq _nlst alist)
      (dolist (_lst (args))(setq _nlst(append _nlst _lst))))
      (begin
      (setq _nlst (list ))
      (dolist (_lst (args))(setq _nlst(append _nlst _lst))))
   ))

(setq a '(1 2))
;-> (1 2)
(append-nil a '(3)'(4)'(5))
;-> (1 2 3 4 5)
(append-nil b '(3)'(4)'(5))
;-> (3 4 5)

Oppure, utilizzando 'apply append' al posto di 'dolist':

(define (append-nil alist)
  (if alist (append alist (apply append (args)))
            (apply append (args))))

(setq a '(1 2))
;-> (1 2)
(append-nil a '(3)'(4)'(5))
;-> (1 2 3 4 5)
(append-nil b '(3)'(4)'(5))
;-> (3 4 5)


-----------------------------------
newLISP Keywords (Parole riservate)
-----------------------------------

Possiamo ottenere la lista delle parole riservate (keywords) di newLISP con la seguente funzione:

(define (keywords)
  (let (k '())
    (dolist (s (symbols)) (if (primitive? (eval s)) (push s k)))
    ; dobbiamo aggiungere "nil" e "true" perchè:
    ; (primitive? (eval nil))  -> nil
    ; (primitive? (eval true)) -> nil
    (push 'true k)
    (push 'nil k)
    (sort k)))

(keywords)

Nota: i simboli "nil" e "true" non vengono ordinati

(setq a '(nil true b a))
(sort a)
;-> (nil true a b)

Possiamo superare il problema nel modo seguente:

(setq lst '(true nil true b a))
(map sym (sort (map string lst)))
;-> (a b nil true true)


--------------------------------------
Estrazione di dati da un file di testo
--------------------------------------

Supponiamo di voler estrarre tutti i numeri contenuti in un testo (file o stringa).
Un trucco è quello di utlizzare la funzione "replace" con una espressione regolare nel modo seguente:

; Impostare il testo da analizzare
; per un file
(setq txt (read-file "myfile.txt"))
; per una stringa
(setq txt "11 testo 11n1 1000 01 numeri 28 39 20 non 56")
; per una riga csv
(setq txt "11,testo,11,n,1,1000,01,numeri,28,39,20,non,56")

; Impostare il modello (pattern) dell'espressione regolare
; Solo numeri (anche quelli che iniziano con 0)
(setq expr {[0-9]+})
; Solo numeri (senza quelli che iniziano con 0)
(setq expr {[1-9][0-9]+})

; Inizializzare la lista che conterrà i numeri (stringa)
(setq tokens '())

; Utilizzare la funzione "replace"
(replace expr txt (push $0 tokens -1) 0)

; Visualizzare il risultato
; la lista tokens contiene tutti i numeri (token) trovati
tokens

L'elaborazione viene eseguita dall'espressione "replace" che inserisce il numero (token) trovato alla fine della lista e restituisce il numero stesso, quindi "txt" rimarrà invariato al termine.
In altri termini, "replace" è la funzione che analizza il testo.

Vediamo un esempio completo:

(setq txt "11,testo,11,n,1,1000,01,numeri,28,39,20,non,56")
(setq expr {[0-9]+})
(setq tokens '())
(replace expr txt (push $0 tokens -1) 0)
tokens
;-> ("11" "11" "1" "1000" "01" "28" "39" "20" "56")


----------------------------
File di testo windows e unix
----------------------------

In windows il terminatore di ogni linea di un file di testo vale "\r\n".
In unix/linux il terminatore di ogni linea di un file di testo vale "\n".
Per scrivere un file di testo in windows con il terminatore di unix possiamo usare la seguente macro proposta da Lutz:

(define-macro (println-unix)
    (apply print (map eval (args)))
    (print "\n"))

Proviamo:

(device (open "newfile.txt" "write"))
;-> 3
(println-unix "prima riga")
;-> "\n"
(println-unix "seconda riga")
(close (device))
;-> true

Adesso il file "newfile.txt" ha il terminatore di linea di tipo unix. Con notepad++ possiamo verificarlo tramite il menu Edit -> EOL Conversion.


-----
CRC32
-----

Il "cyclic redundancy check" (ovvero controllo di ridondanza ciclico, acronimo CRC) è un metodo per il calcolo di somme di controllo (checksum in inglese). Il controllo CRC viene usato per l'individuazione di errori casuali nella trasmissione dati (a causa di interferenze, rumore di linea, distorsione). Il metodo non è invece affidabile per verificare la completa correttezza dei dati contro tentativi intenzionali di manomissione. A questo scopo è meglio usare altri algoritmi di hash quali MD5 e SHA1.

NewLISP ha una funzione integrata per il calcolo del CRC:

******************
>>>funzione CRC32
******************
sintassi: (crc32 str-data)
Calcula il CRC a 32-bit dal buffer di str-data, iniziando con un valore di CRC uguale a 0xffffffff per il primo byte. "crc32" usa un algoritmo pubblicvato da www.w3.org.

(crc32 "abcdefghijklmnopqrstuvwxyz")
;-> 1277644989

La funzione "crc32" viene spesso utilizzato per verificare l'integrità dei dati nelle trasmissioni di dati non sicure.

Nel forum di newLISP l'utente Sammo ha proposto la seguente versione:

;;   crc32
;;   adapted from CMUCL code written by R. Matthew Emerson
;;   <rme@acm.org> in August 1999 and placed in the public domain
;;
;;   examples and test cases
;;   (format "%08X" (crc "ABC")) --> A3830348
;;   (format "%08X" (crc "abc")) --> 352441C2
;;   (format "%08X" (crc "123456789")) --> CBF43926
;;

(define (my-crc32 buf)
   (update-crc32 0 buf) )

(define (update-crc32 crc buf , i)
   (set 'crc (^ crc 0xFFFFFFFF))
   (dotimes (n (length buf))
      (set 'i (& 0xFF (^ crc (char buf n))))
      (set 'crc (^ (nth i CRC32-TABLE) (>> (& 0x7FFFFFFF (>> crc 1)) 7))) )
   (^ crc 0xFFFFFFFF) )

(setq CRC32-TABLE
   '(0x00000000 0x77073096 0xEE0E612C 0x990951BA 0x076DC419 0x706AF48F
     0xE963A535 0x9E6495A3 0x0EDB8832 0x79DCB8A4 0xE0D5E91E 0x97D2D988
     0x09B64C2B 0x7EB17CBD 0xE7B82D07 0x90BF1D91 0x1DB71064 0x6AB020F2
     0xF3B97148 0x84BE41DE 0x1ADAD47D 0x6DDDE4EB 0xF4D4B551 0x83D385C7
     0x136C9856 0x646BA8C0 0xFD62F97A 0x8A65C9EC 0x14015C4F 0x63066CD9
     0xFA0F3D63 0x8D080DF5 0x3B6E20C8 0x4C69105E 0xD56041E4 0xA2677172
     0x3C03E4D1 0x4B04D447 0xD20D85FD 0xA50AB56B 0x35B5A8FA 0x42B2986C
     0xDBBBC9D6 0xACBCF940 0x32D86CE3 0x45DF5C75 0xDCD60DCF 0xABD13D59
     0x26D930AC 0x51DE003A 0xC8D75180 0xBFD06116 0x21B4F4B5 0x56B3C423
     0xCFBA9599 0xB8BDA50F 0x2802B89E 0x5F058808 0xC60CD9B2 0xB10BE924
     0x2F6F7C87 0x58684C11 0xC1611DAB 0xB6662D3D 0x76DC4190 0x01DB7106
     0x98D220BC 0xEFD5102A 0x71B18589 0x06B6B51F 0x9FBFE4A5 0xE8B8D433
     0x7807C9A2 0x0F00F934 0x9609A88E 0xE10E9818 0x7F6A0DBB 0x086D3D2D
     0x91646C97 0xE6635C01 0x6B6B51F4 0x1C6C6162 0x856530D8 0xF262004E
     0x6C0695ED 0x1B01A57B 0x8208F4C1 0xF50FC457 0x65B0D9C6 0x12B7E950
     0x8BBEB8EA 0xFCB9887C 0x62DD1DDF 0x15DA2D49 0x8CD37CF3 0xFBD44C65
     0x4DB26158 0x3AB551CE 0xA3BC0074 0xD4BB30E2 0x4ADFA541 0x3DD895D7
     0xA4D1C46D 0xD3D6F4FB 0x4369E96A 0x346ED9FC 0xAD678846 0xDA60B8D0
     0x44042D73 0x33031DE5 0xAA0A4C5F 0xDD0D7CC9 0x5005713C 0x270241AA
     0xBE0B1010 0xC90C2086 0x5768B525 0x206F85B3 0xB966D409 0xCE61E49F
     0x5EDEF90E 0x29D9C998 0xB0D09822 0xC7D7A8B4 0x59B33D17 0x2EB40D81
     0xB7BD5C3B 0xC0BA6CAD 0xEDB88320 0x9ABFB3B6 0x03B6E20C 0x74B1D29A
     0xEAD54739 0x9DD277AF 0x04DB2615 0x73DC1683 0xE3630B12 0x94643B84
     0x0D6D6A3E 0x7A6A5AA8 0xE40ECF0B 0x9309FF9D 0x0A00AE27 0x7D079EB1
     0xF00F9344 0x8708A3D2 0x1E01F268 0x6906C2FE 0xF762575D 0x806567CB
     0x196C3671 0x6E6B06E7 0xFED41B76 0x89D32BE0 0x10DA7A5A 0x67DD4ACC
     0xF9B9DF6F 0x8EBEEFF9 0x17B7BE43 0x60B08ED5 0xD6D6A3E8 0xA1D1937E
     0x38D8C2C4 0x4FDFF252 0xD1BB67F1 0xA6BC5767 0x3FB506DD 0x48B2364B
     0xD80D2BDA 0xAF0A1B4C 0x36034AF6 0x41047A60 0xDF60EFC3 0xA867DF55
     0x316E8EEF 0x4669BE79 0xCB61B38C 0xBC66831A 0x256FD2A0 0x5268E236
     0xCC0C7795 0xBB0B4703 0x220216B9 0x5505262F 0xC5BA3BBE 0xB2BD0B28
     0x2BB45A92 0x5CB36A04 0xC2D7FFA7 0xB5D0CF31 0x2CD99E8B 0x5BDEAE1D
     0x9B64C2B0 0xEC63F226 0x756AA39C 0x026D930A 0x9C0906A9 0xEB0E363F
     0x72076785 0x05005713 0x95BF4A82 0xE2B87A14 0x7BB12BAE 0x0CB61B38
     0x92D28E9B 0xE5D5BE0D 0x7CDCEFB7 0x0BDBDF21 0x86D3D2D4 0xF1D4E242
     0x68DDB3F8 0x1FDA836E 0x81BE16CD 0xF6B9265B 0x6FB077E1 0x18B74777
     0x88085AE6 0xFF0F6A70 0x66063BCA 0x11010B5C 0x8F659EFF 0xF862AE69
     0x616BFFD3 0x166CCF45 0xA00AE278 0xD70DD2EE 0x4E048354 0x3903B3C2
     0xA7672661 0xD06016F7 0x4969474D 0x3E6E77DB 0xAED16A4A 0xD9D65ADC
     0x40DF0B66 0x37D83BF0 0xA9BCAE53 0xDEBB9EC5 0x47B2CF7F 0x30B5FFE9
     0xBDBDF21C 0xCABAC28A 0x53B39330 0x24B4A3A6 0xBAD03605 0xCDD70693
     0x54DE5729 0x23D967BF 0xB3667A2E 0xC4614AB8 0x5D681B02 0x2A6F2B94
     0xB40BBE37 0xC30C8EA1 0x5A05DF1B 0x2D02EF8D))

Proviamo:

(my-crc32 "abcdefghijklmnopqrstuvwxyz")
;-> 1277644989


-------------------
Mescolare le parole
-------------------

Una ricerca dell'Universita di Cambridge, ha scoperto che non è importante in quale ordine appaiono le lettere di una parola o di una frase, ma l'unica cosa importante è che la prima e l'ultima lettera siano al posto giusto. Il resto può essere totalmente casuale e saremmo in grado di leggere la parola o la frase senza problemi. Questo perchè la mente umana non legge le singole lettere, ma l'intera parola.

Per verificare questa ricerca usiamo due funzioni: la prima che cambia l'ordine dei caratteri di una parola e la seconda che fa lo stesso con tutte le parole di una frase.

; mescola i caratteri di una parola (es. "hello" -> "hlelo")
; written by Fanda
(define (mix str)
  (if (> (length str) 3)
    (append (str 0) (join (randomize (explode (1 (- (length str) 2) str)))) (str -1))
    str))

; mescola i caratteri delle parole di una frase
; written by Fanda
(define (jumble str)
  (let (w "" break ",. -:?!()[]{}+/\|=*&^%$#@!~`'<>" result "")
    (dolist (c (explode str))
      (if (find c break)
        (begin
          (write-buffer result (append (mix w) c))
          (setq w ""))
        (write-buffer w c)))
    (write-buffer result (mix w))
    result))

(setq str "Una ricerca dell'Universita di Cambridge, ha scoperto che non è importante in quale ordine appaiono le lettere di una parola o di una frase, ma l'unica cosa importante è che la prima e l'ultima lettera siano al posto giusto. Il resto può essere totalmente casuale e saremmo in grado di leggere la parola o la frase senza problemi. Questo perchè la mente umana non legge le singole lettere, ma l'intera parola.")

(println "\n" (jumble str) "\n")
;-> Una rirccea dlel'Unrvtseiia di Crdmibage, ha sropetco che non è iprtmantoe in qlaue odnrie ainaoppo le ltteere di una poarla o di una fsrae, ma l'uicna csoa intaotpmre è che la pimra e l'uimtla ltetera sinao al pstoo gituso. Il rtseo può eersse ttaontmele casaule e srmmaeo in gdaro di lergege la proala o la fsare szena preolbmi. Qetuso pcehrè la metne unama non legge le soginle leertte, ma l'iertna porala.


-------------------
Parsing di stringhe
-------------------

Per fare il parsing di stringhe newLISP mette a disposizione la funzione "parse".

******************
>>>funzione PARSE
******************
sintassi: (parse str-data [str-break [regex-option]])

Divide la stringa risultante dalla valutazione di str-data in token stringa, che vengono quindi restituiti in una lista. Quando non viene fornita alcuna interruzione di stringa "str-break", l'analisi tokenizza secondo le regole di analisi interne di newLISP. Una stringa può essere specificata in "str-break" per la tokenizzare solo al verificarsi di una stringa. Se viene specificato un numero di "regex-regex" o una stringa, è possibile utilizzare un modello di espressione regolare in str-break.

Quando "str-break" non è specificato, la dimensione massima del token è 2048 per le stringhe tra virgolette e 256 per gli identificatori. In questo caso, newLISP utilizza lo stesso tokenizzatore veloce che utilizza per l'analisi dei sorgenti di newLISP. Se si specifica "str-break", non ci sono limiti alla lunghezza dei token. Viene utilizzato un algoritmo diverso che suddivide i dati della stringa di origine "str-data" quando si verifica la stringa "str-break".

; no break string specified
(parse "hello how are you")     → ("hello" "how" "are" "you")

; strings break after spaces, parentheses, commas, colons and numbers.
; Spaces and the colon are swollowed
(parse "weight is 10lbs")       →
(parse "one:two:three" ":")     → ("one" "two" "three")

;; specifying a break string
(parse "one--two--three" "--")  → ("one" "two" "three")

; a regex option causes regex parsing
(parse "one-two--three---four" "-+" 0)
→ ("one" "two" "three" "four")

(parse "hello regular   expression 1, 2, 3" {,\s*|\s+} 0)
→ ("hello" "regular" "expression" "1" "2" "3")

Gli ultimi due esempi mostrano un'espressione regolare come stringa di interruzione con l'opzione predefinita 0 (zero). Invece di { e } (parentesi graffe sinistra e destra), è possibile utilizzare virgolette doppie per limitare il modello/pattern. In questo caso, è necessario utilizzare doppie barre rovesciate all'interno del modello. L'ultimo modello potrebbe essere utilizzato per l'analisi dei file CSV (Comma Separated Values). Per i numeri relativi alle opzioni delle espressioni regolari, vedere regex.

L'analisi/parsing restituirà i campi vuoti attorno ai separatori come stringhe vuote:

; empty fields around separators returned as empty strings
(parse "1,2,3," ",") → ("1" "2" "3" "")
(parse "1,,,4" ",")  → ("1" "" "" "4")
(parse "," ",")      → ("" "")

(parse "")      → ()
(parse "" " ")  → ()

Questo comportamento è necessario durante l'analisi dei record con campi vuoti.

L'analisi di una stringa vuota comporterà sempre una lista vuota.

Utilizzare la funzione regex per spezzare le stringhe e le funzioni directory, find, find-all, regex, replace e search per utilizzare le espressioni regolari.

Possiamo anche usare la seguente funzione per fare il parsing di una stringa:

; Funzione Split
; written by Fanda

(define (parse-no-empty str c)
  (filter (lambda (x) (not (empty? x))) (parse str c)))

(define (split str-data str-break)
  (if (empty? str-break)
    (explode str-data)
    (begin
      (setq str-data (list str-data))
      (dolist (c (explode str-break))
        (setq str-data (flat (map (lambda (s) (parse-no-empty s c)) str-data)))))))


(split "Simple sentence, but useful!" ",! ")
;-> ("Simple" "sentence" "but" "useful")

(split "http://www.yahoo.com" ":/.")
;-> ("http" "www" "yahoo" "com")

(split "Hi++++Hello-----Bye!" "+-!")
;-> ("Hi" "Hello" "Bye")


--------------------------------------
Formattazione di elementi di una lista
--------------------------------------

Quando abbiamo una lista dei valori o variabili possiamo formattare la stampa di questi elementi (alcuni o tutti) utilizzando l'indicizzazione implicita nel modo seguente:

(setq lst '("bob" "this" "that" 3 2 10 "a" 96 "----" 456))
(println (format "%s,%d,%s,%d\n" (lst 0) (lst 4) (lst 1) (lst 7)))
;-> bob,2,this,96

Comunque possiamo anche usare la seguente funzione (scritta da Sammo) che permette di usare "select":

(define (myformat str) (apply format (cons str (flat (args)))))
(println (myformat "%s,%d,%s,%d\n" (select lst 0 4 1 7)))
;-> bob,2,this,96

(println (format "%s,%d,%s,%d\n" (select lst 0 4 1 7)))
;-> bob,2,this,96


-------------
Slice mapping
-------------

Il funzionamento della funzione "map" è il seguente:

(setq data '((1 2) (2 3) (3 4)))
;-> ((1 2) (2 3) (3 4))
(println (map first data))
;-> (1 2 3)

Adesso proviamo un'altra espressione:

(println (map 0 data))
;-> ((1 2) (2 3) (3 4))

e ancora

(println (map 1 data))
;-> ((2) (3) (4))

Per capire gli ultimi due risultati occorre sapere che la forma (idx lst) non rappresenta l'indicizzazione implicita (nth), ma lo "slice" implicito:

(0 '(1 2 3 4))
;-> (1 2 3 4)
(1 '(1 2 3 4))
;-> (2 3 4)
(1 2 '(1 2 3 4))
;-> (2 3)

Quindi (idx lst) applica la funzione "slice" alla lista lst partendo dall'indice idx.

L'indicizzazione implicita ha la forma (lst idx):

(setq data '(1 2 3 4 5))
;-> (1 2 3 4 5)
(data 0)
;-> 1
(data 1)
;-> 2

La funzione "map" applica sempre il primo parametro ad ogni elemento della lista che segue. Comunque è sempre possibile scrivere:

(setq data '(a b c d))
(map 'data '(3 2 1 0))
;-> (d c b a)

Notare che la lista data viene quotata perchè "map" valuta sempre il primo parametro prima di applicarlo (come fa anche l'indicizzazione implicita).
Lo "slice mapping" è utile per raccogliere tutti i primi elementi di una serie di liste e raccoglierli in un'altra lista.


--------------------------------------------
Valore minimo/massimo di una lista di numeri
--------------------------------------------

Il metodo standard per trovare il valore massimo di una lista di numeri è quello di usare la funzione "apply":

(setq num '(3 4 1 6 8 2 34 12 5 8 9 42 3))
(apply max num)
;-> 42

Ma esiste anche un altro metodo (unortodosso):

Inseriamo il simbolo max nella lista num:

(push max num)
;-> (max@40D985 3 4 1 6 8 2 34 12 5 8 9 42 3)

Valutiamo la lista (e troviamo il numero massimo):

(eval num)
;-> 42

Adesso dobbiamo togliere il simbolo "max" dalla lista:

(pop num)
;-> max@40D985
num
;-> (3 4 1 6 8 2 34 12 5 8 9 42 3)

Proviamo con la funzione "min":

(push min num)
;-> (min@40D972 3 4 1 6 8 2 34 12 5 8 9 42 3)
(eval num)
;-> 1
(pop num)
;-> min@40D972
num
;-> (3 4 1 6 8 2 34 12 5 8 9 42 3)

Misuriamo la velocità dei due metodi:

(define (test lst)
    (push max lst 0)
    (eval lst)
    (pop lst))

(time (test num) 1000000)
;-> 234.71

(time (apply max num) 1000000)
;-> 187.861

Inoltre se vogliamo usare una funzione dobbiamo anche restituire il valore, quindi dobbiamo scrivere:

(define (mymax lst)
  (let (out nil)
    (push max lst 0)
    (setq out (eval lst))
    (pop lst)
    out))

(mymax num)
;-> 42

(time (mymax num) 1000000)
;-> 359.282
num
;-> (3 4 1 6 8 2 34 12 5 8 9 42 3)

(time (apply max num) 1000000)
;-> 187.45

Il metodo normale è più veloce, ma il metodo unortodosso è interessante.


-------------------
Sommare una stringa
-------------------

In una stringa composta da cifre e altri caratteri non numerici, le cifre formano una serie di numeri interi positivi. Ad esempio, la stringa "123abc45def" contiene gli interi 123 e 45, la cui somma corrisponde a 168.
Scrivere un programma che accetta una stringa e restituisce la somma degli interi incorporati nella stringa.

; la stringa
(setq str "o123p010iru5")
; la lista che contiene i numeri della stringa
(setq numeri '())
; espressione regolare per individuare i numeri
(setq expr {[0-9]+})
; espressione che estrae i numeri dalla stringa
; e li inserisce nella lista numeri
(replace expr str (push $0 numeri -1) 0)
numeri
;-> ("123" "010" "5")

; conversione delle stringhe in interi e somma di tutti i numeri
; da notare che (int "010") -> 8 (ottale)
(apply + (map (fn (x) (int x 0 10)) numeri))
;-> 138

Adesso scriviamo la funzione finale:

(define (sumstr str)
  (local (numeri expr)
    (setq numeri '())
    (setq expr {[0-9]+})
    (replace expr str (push $0 numeri -1) 0)
    (apply + (map (fn (x) (int x 0 10)) numeri))
  ))

(sumstr "o123p010iru5")
;-> 138

(sumstr "0a0b0c0d")
;-> 0

(sumstr "")
;-> 0

Nel forum di newLISP l'utente fdb ha proposto queste due funzioni:

(define (parse-str str)
  (apply + (map int (clean empty? (parse str {[^0-9]} 0)))))

(parse-str "o123p010iru5")
;-> 136

(define (parse-str str)
  (let (total 0)
    (dolist (s (parse str {[^0-9]} 0))
      (unless (empty? s)
        (inc total (int s))))
    total))

Purtroppo queste non funzionano correttamente ci sono numeri con lo 0 iniziale (che vengono convertiti dalla funzione "int" in base ottale, invece che in base decimale).

Comunque l'ultima funzione di fdb è più veloce.

(time (parse-str "o123p010iru5") 100000)
;-> 184.9
(time (sumstr "o123p010iru5") 100000)
;-> 254.863

Altre funzione proposta da newBert:

 (apply + (map (fn (x) (int (if (starts-with x "0") (rest x) x))) (find-all {[0-9]+} "o123p010iru5")))
;-> 138

Altre funzioni (corrette) proposte da fdb:

(apply + (map int (find-all {[1-9][0-9]*} "o123p010iru5")))
;-> 138

(apply (fn(x y) (+ (int x) (int y))) (find-all {[1-9]\d*} "o123p0010iru5") 2)
;-> 138


-----------------
Numeri palindromi
-----------------

Trovare il numero palindromo più grande che sia il prodotto di due numeri con tre cifre ognuno.
Un palindromo è un numero in cui l'ordine delle cifre è lo stesso quando viene letto da sinistra o da destra, per esempio 104401, 9023209 ecc.
Nel nostro caso: 111111 è un palindromo che è il prodotto di 777 e 143.

Soluzione forza bruta (brute-force)

Funzione che verifica se un numero è palindromo:

(define (palindromo? num)
  (let (str (string num))
    (= str (reverse (copy str)))))

Numero massimo di numeri da verificare:

(* 999 999)
;-> 998001

Ma, poichè i numeri hanno tre cifre, il numero massimo vale:

(* (- 999 100) (- 999 100))
;-> 808201

Inoltre, per evitare ripetizioni, l'indice del secondo ciclo (j) inizia con il valore corrente dell'indice primo ciclo (i).

(define (palnum1)
  (local (num big a b)
    (setq big 0)
    (setq a 100)
    (setq b 100)
    (for (i 100 999)
      (for (j i 999)
        (setq num (* i j))
        (if (palindromo? num)
            (if (> num big) (begin
              (setq big num)
              (setq a i)
              (setq b j))
            )
        )
      )
    )
    (list a b big)
  )
)

(palnum1)
;-> (906609 913 993)

Ottimizzazione della funzione
La soluzione (il più grande palindromo) deve avere almeno 6 cifre poiché stiamo moltiplicando 2 numeri a tre cifre, quindi il numero deve avere almeno 3 cifre univoche che indichiamo con X, Y e Z.

Sol = 100000 * X + 10000 * Y + 1000 * Z + 100 * Z + 10 * Y + X

Possiamo semplificarlo come:

Sol = 100001 * X + 10010 * Y + 1100 * Z

Sol = 11 * (9091 * X + 910 * Y + 100 * Z)

Quindi la soluzione deve essere un multiplo di 11. Dato che 11 è un numero primo, uno dei due numeri moltiplicati deve essere un multiplo di 11. Per questo, se il numero del loop esterno non è un multiplo di 11, il loop interno deve essere un multiplo di 11 e, quindi, possiamo scartare diverse possibilità.

la funzione è la seguente:

(define (palnum2)
  (local (num a b big step)
    (setq big 0)
    (setq step 1)
    (for (i 100 999)
      (setq j 0)
      (if (zero? (% i 11))
          (setq step 1 j 1)
          (setq step 11 j (- i (% i 11)))
      )
      (while (> j 99)
        (setq num (* i j))
        (if (palindromo? num)
            (if (> num big) (begin
              (setq big num)
              (setq a i)
              (setq b j))
            )
        )
        (setq j (- j step))
      )
    )
    (list a b big)
  )
)

(palnum2)
;-> (993 913 906609)

Vediamo la differenza di velocità:

(time (palnum1) 10)
;-> 2417.706

(time (palnum2) 10)
;-> 218.113

La versione ottimizzata è 10 volte più veloce.


-----------------
Frazioni continue
-----------------

Il calcolo della frazione continua di un numero reale consiste nella ripetizione di due operazioni: prendere la parte intera di un numero e prendere il reciproco della sua parte frazionaria.

Ovvero, dato un numero reale "r", ponendo "i" la sua parte intera e "f" la sua parte frazionaria, si ha:

r = i + f = i + 1/(1/f)

Ora 1/f è un numero maggiore di 1, e quindi si può prendere la sua parte intera, e calcolare successivamente gli altri coefficienti. Se in un qualunque momento f è 0, l'algoritmo si ferma: questo avviene se e solo se r è razionale.

Esempio: ricerca della frazione continua di 3.245:

3  |   (3.245 - 3) = 0.245 | 1/0.245 = 4.082
   |                       |
4  |   (4.082 - 4) = 0.082 | 1/0.082 = 12.250
   |                       |
12 | (12.250 - 12) = 0.250 | 1/0.250 = 4.000
   |                       |
4  |   (4.000 - 4) = 0.000 | stop

Questo algoritmo è adatto per i numeri reali, ma può condurre a risultati errati se vengono utilizzati i numeri a virgola mobile (floating point), in quanto piccoli errori nella parte frazionaria possono generare (tramite l'operazione di inversione) grandi differenze nel termine successivo.

Per esempio:

(define (num2fc x)
  (local (out i f)
    (setq out '())
    (setq i (int x))
    (setq f (sub x i))
    (println i { } f { } (div 1 f))
    (while (!= f 0)
      (push i out -1)
      (setq i (int (div 1 f)))
      (setq f (sub (div 1 f) i))
      (println i { } f { } (div 1 f))
      (read-line)
    )
    out
  )
)

(num2fc 3.245)
;-> 3 0.2450000000000001 4.081632653061223
;-> 4 0.0816326530612228 12.25000000000025
;-> 12 0.2500000000002522 3.999999999995964
;-> 3 0.9999999999959641 1.000000000004036
;-> 1 4.035882739117369e-012 247777268231.2113

Come si nota, la frazione continua non converge al valore corretto.

Possiamo lavorare con i numeri interi se utilizziamo l'algoritmo di euclide, infatti i quozienti che compaiono quando applichiamo l'algoritmo ai valori di input a e b sono proprio i numeri che compaiono nella rappresentazione in frazione continua della frazione a/b. Per esempio con a = 1071 e b = 1029 otteniamo:

1071 = 1029 × 1 + 42
              -
1029 = 42 × 24 + 21
            --
42 = 21 × 2 + 0
          -

Quindi la frazione continua di 1071/1029 vale (1 24 2), cioè:

1071            1
----- = 1 + ----------
1029               1
             24 + ---
                   2

Per capire come viene usato l'algoritmo di Euclide per calcolare le frazioni continue possiamo calcolare il massimo comun divisore fra a e b nel modo seguente:

 a          r0           1              1
--- = q0 + ---- = q0 + ----- = q0 + ---------- =
 b          m0           m0                r1
                        ----         q1 + ----
                         r0                r0

              1                          1
= q0 + ----------------  = q0 + ---------------------- = ...
                 1                          1
        q1 + ----------          q1 + ----------------
                    r2                          1
              q2 + ----                q2 + ----------
                    r1                             r3
                                             q3 + ----
                                                   r3

in cui m0 > r0 > r1 > r2 > r3 > ... > 0. Per semplicità si scrive:

a/b = [q0, q1, ..., q(n-1), qn]

Osserviamo che se qn >= 2, allora risulta:

[q0, q1, ..., q(n-1), qn] = [q0, q1, ..., q(n-1), qn-1, 1]

Se a/b è irrazionale allora l'algoritmo euclideo non ha termine, ma la sequenza di quozienti che si calcola costituisce sempre la rappresentazione (ora infinita) di a/b in frazione continua.

Quindi con una variante dell'algoritmo di euclide si ottengono i risultati corretti, ma dobbiamo utilizzare come input il numeratore e il denominatore della frazione che rappresenta il numero razionale (es. 3.245 -> 3245/1000):

(define (fract2fc a b)
  (local (fc r out)
    (setq out '())
    (while (!= 0 r)
      (setq r (% a b))
      (setq fc (/ a b))
      (push fc out -1)
      (setq a b)
      (setq b r)
    )
    ;(println a)
    out
  )
)

(fract2fc 3245 1000)
;-> (3 4 12 4)

3245              1
----- = 3 + ---------------
1000                 1
             4 + ----------
                        1
                  12 + ---
                        4

Un altro esempio:

(fract2fc 1071 1029)
;-> (1 24 2)

1071            1         51
----- = 1 + ---------- = ----
1029               1      49
             24 + ---
                   2

Il valore reale vale:

(div 1071 1029)
;-> 1.040816326530612

Un altro esempio:

(fract2fc 79 22)
;-> (3 1 1 2 4)

Adesso dobbiamo scrivere una funzione che converte una frazione continua in un numero fratto (numeratore e denominatore). In altre parole si tratta del calcolo dei convergenti di una frazione continua.
Utilizziamo le seguenti funzioni per calcolare la somma di due frazioni:

(define (rat n d)
  (let (g (gcd n d))
    (map (curry * 1L)
         (list (/ n g) (/ d g)))))

(define (+rat r1 r2)
  (rat (+ (* (r1 0) (r2 1))
          (* (r2 0) (r1 1)))
       (* (r1 1) (r2 1))))

(define (fc2fract lst)
  (local (num den frac tempfrac)
    (setq tempfrac '())
    (setq fc (reverse lst))
    (setq tempfrac (list 1 (first fc)))
    (println tempfrac) ; prima frazione convergente
    (for (i 1 (- (length fc) 2))
      (setq tempfrac (+rat tempfrac (list (fc i) 1)))
      (swap (tempfrac 0) (tempfrac 1))
      (println tempfrac) ; i-esima frazione convergente
    )
    (setq tempfrac (+rat (list (last fc) 1) tempfrac))
    (list tempfrac (div (first tempfrac) (last tempfrac)))
  )
)

(fc2fract '(1 24 2))
;-> ((51L 49L) 1.040816326530612)

Infatti risulta:

(gcd 1071 1029)
;-> 21

(/ 1071 (gcd 1071 1029))
;-> 51

(/ 1029 (gcd 1071 1029))
;-> 49

(fract2fc 159 49)
;-> (3 4 12)
(fc2fract '(3 4 12))
;-> ((159L 49L) 3.244897959183673)

(fract2fc 79 22)
;-> (3 1 1 2 4)
(div 79 22)
;-> 3.590909090909091
(fc2fract '(3 1 1 2 4))
;-> ((79L 22L) 3.590909090909091)

(fract2fc 3245 1000)
;-> (3 4 12 4)
(fc2fract '(3 4 12 4))
;-> ((649L 200L) 3.245)
(fc2fract '(3 4 12 3 1))
;-> ((649L 200L) 3.245)

Nota:
numero aureo = (1 + sqrt(5))/2 =
1.6180339887498948482045868343656381177203091798057628621354486227052...

(fc2fract '(1 1 1 1 1 1 1 1 1 1 1 1))
;-> ((233L 144L) 1.618055555555556)
(fc2fract '(1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1))
;-> ((514229L 317811L) 1.618033988754323)


-----------------------------------
Liste formate da coppie di elementi
-----------------------------------

Quando abbiamo una lista di elementi e vogliamo lavorare con coppie di elementi è possibile accoppiare gli elementi prima di operare su di essi. Per esempio, data la lista:

(setq lst '(a b c d e f g h))

Possiamo accoppiare gli elementi con la seguente funzione:

;; pair - raggruppa gli elementi di una lista in coppie
;;
;; (pair '(a b c d e f)) => ((a b) (c d) (e f))
;;
(define (pair lst)
  (array-list (array (/ (length lst) 2) 2 lst)))

(pair '(a b c d e f g h))
;-> ((a b) (c d) (e f) (g h))

Se gli elementi da accoppiare si trovano in due liste diverse possiamo usare la funzione "map":

(setq lst1 '(1 2 3 4))
(setq lst2 '(a b c d))
(map list lst1 lst2)
;-> ((1 a) (2 b) (3 c) (4 d))

Adesso possiamo usare una funzione che usa i due valori:

(define (use x y) (string "Params:" x "," y))
(use x y)
;-> "Params:nil,nil"

Esempio: iterazione su una lista di coppie

Sintassi newLISP (non valida):
(dolist ((x y) '(x1 y1 x2 y2)) (use x y))

(map (lambda (z) (apply use z)) '((x1 y1) (x2 y2)))
;-> ("Params:x1,y1" "Params:x2,y2")

Sintassi newLISP (non valida):
(dolist ((name age) '("John" 32 "Richard" 41 "Lucy" 37)) (use name age))

(map (lambda (x) (apply use x)) '(("John" 32) ("Richard" 41) ("Lucy" 37)))
;-> ("Params:John,32" "Params:Richard,41" "Params:Lucy,37")

Esempio: iterazione con due liste

Sintassi newLISP (non valida):
(dolist (a '(a1 a2 a3) b '(b1 b2 b3)) (use a b))

(map use '(a1 a2 a3) '(b1 b2 b3))
;-> ("Params:a1,b1" "Params:a2,b2" "Params:a3,b3")

Esempio: iterazione su una lista di coppie con due indici

Sintassi newLISP (non valida):
(dolist ((x y) '((1 2) (3 4) (5 6))) (use x y))

(map (lambda (x) (apply use x)) '((1 2) (3 4) (5 6)))
;-> ("Params:1,2" "Params:3,4" "Params:5,6")

Nota: "apply" non valuta gli argomenti prima di applicare l'operazione, ma possiamo forzare newLISP a farlo nel modo seguente:

(apply use (map eval '(x1 x2)))

Se vogliamo raggruppare gli elementi di una lista con un numero di elementi variabile possiamo usare la seguente funzione:

(define (group lst n)
  (map (lambda (i) (slice lst i n)) (sequence 0 (sub (length lst) 1) n)))

(group '(1 2 3 4 5 6) 2)
;-> ((1 2) (3 4) (5 6))

(group '(1 2 3 4 5 6 7 8 9) 4)
;-> ((1 2 3 4) (5 6 7 8) (9))

Oppure possiamo usare la funzione integrata "explode":

(explode '(1 2 3 4 5 6) 2)
;-> ((1 2) (3 4) (5 6))

(explode '(1 2 3 4 5 6 7 8 9) 4)
;-> ((1 2 3 4) (5 6 7 8) (9))

Vediamo una funzione che raggruppa con alcuni parametri supplementari:

;; This function performs a multiple slice on a given list
;; One supplies a list and an integer n. The list is broken into a list of sublists of
;; length n. If n is negative the list items are collected going from the end of the list
;; to the beginning. If the optional bool argument is supplied then remaining elements are
;; included in the result.
;; (group '(1 2 3 4 5 6 7) 3)       -> ((1 2 3)(4 5 6))
;; (group '(1 2 3 4 5 6 7) 3 true)  -> ((1 2 3)(4 5 6)(7))
;; (group '(1 2 3 4 5 6 7) -3 true) -> ((1)(2 3 4)(5 6 7))
(define (group lst n bool , len num rep rem start)
  (setq num (abs n))
  (if (< n 0)
      (reverse (map reverse (group (reverse lst) num bool)))
      (= n 0)
      nil
      (begin
        (setq len   (length lst)
              rep   (/ len num)
              rem   (% len num)
              start '()
        )
        (if (< num len)
            (begin
              (dotimes (x rep)
                (setq start (cons (slice lst (* x num) num) start)))
              (if (and bool (> rem 0))
                  (setq start (cons (slice lst (* num rep) rem) start)))
              (reverse start))
            (list lst)))))

(group '(1 2 3 4 5 6 7) 3)
;-> ((1 2 3)(4 5 6))
(group '(1 2 3 4 5 6 7) 3 true)
;-> ((1 2 3)(4 5 6)(7))
(group '(1 2 3 4 5 6 7) -3 true)
;-> ((1)(2 3 4)(5 6 7))
(group '(1 2 3 4 5 6 7) -3)
;-> ((2 3 4) (5 6 7))

Nota: "dolist" itera su una lista, "map" itera su una lista e colleziona i risultati.
Esempi:

(setq L '((1 2) (3 4) (5 6)))
(map first L)
;-> (1 3 5)

(time (dotimes (i 1000000) (map first L)))
;-> 200.49
(time (dotimes (i 1000000) (map (lambda (x) (nth 0 x)) L)))
;-> 420.015
(time (dotimes (i 1000000) (setq r '())(dolist (x L)(push (x 0) r -1))))
;-> 287.697
(time (dotimes (i 1000000) (dolist (x L) (first x))))
;-> 199.496

Infine, vediamo la funzione "dispose" che ragruppa gli elementi di più liste:

(define (dispose) (transpose (args)))

(dispose '(1 2 3) '(4 5 6))
;-> ((1 4) (2 5) (3 6))

(dispose '(1 2 3) '(4 5 6) '(7 8 9))
;-> ((1 4 7) (2 5 8) (3 6 9))

(setq m '(1 2 3 4 5 6 7))
(setq n '(7 6 5 4 3 2 1))
(dispose m n)
;-> ((1 7) (2 6) (3 5) (4 4) (5 3) (6 2) (7 1))


-------------
Liste quotate
-------------

Supponiamo di avere la seguente lista:

(setq L '(1 '(2 3 4)))
(L 0)
;-> 1
(L 1)
;-> '(2 3 4)

Adesso incontriamo uno strano comportamento:

(first (L 1))
;-> ERR: array, list or string expected in function first : (L 1)

Invece la seguente espressione è valida:

(first '(2 3 4))
;-> 2

Proviamo con la funzione "quote" al posto del carattere "'":

(setq Q (quote (1 (quote (2 3 4)))))
(Q 0)
;-> 1
(Q 1)
;-> (quote (2 3 4))

(first (Q 1))
;-> quote

Verifichiamo se la lista interna è quotata:

(quote? (L 1))
;-> true

(quote? (Q 1))
;-> nil

La sottolista '(2 3 4) è un tipo di dato speciale: "quoted-list" (che è un sottotipo del tipo "list"). È simile al sottotipo "lambda" di una lista.

La funzione "quote" e il carattere "'" sono equivalenti quando avviene la valutazione:
in newLISP similar to lambda-type sub-type of list.

(= 'x (quote x))
;-> true

e

(quote? (quote 'x))
;-> true

Ma nelle espressioni seguenti l'espressione (quote x) non viene valutata:

(quote? '(quote x))
;-> nil

e

(list? '(quote x))
;-> true

Proprio come "lambda" il carattere "'" vien risolto durante la traduzione del codice (source parsing). Questo è il perchè abbiamo i predicati "quote?" e "lamba?".

Sia il carattere "'" che la funzione "quote" hanno lo stesso scopo: proteggere una espressione dalla valutazione. Comunque "'" è processato molto più velocemente perchè viene tradotto durante il caricamento del sorgente. La funzione "quote" è necessaria quando vogliamo proteggere una espressione durante il runtime.

Per questo motivo, quando si desidera riscrivere la definizione originale di McCarthy di LISP in newLISP, è necessario utilizzare la funzione "quote" anziché il carattere "'":

(first (first (rest (quote (1 (quote 2 3 4))))))
;-> quote

ottenendo gli stessi risultati di Scheme e del Common Lisp.

Vedi anche il capitolo "La funzione quote e il simbolo '".


------------------------
Il limite sulle stringhe
------------------------

newLISP pone un limite all'utilizzo di stringhe: massimo 2048 caratteri.
Questo crea dei vincoli a diverse operazioni:

- una espressione non può superare 2048 caratteri
- un input da stdin con la funzione "read-line" non può superare 2048 caratteri.
- la funzione "print" non può usare stringhe con più di 2048 caratteri.
- la funzione "parse" non può usare token-size maggiori di 2048 caratteri
- ecc.

Questo limite è stato imposto per ottenere una maggiore velocità nel trattamento delle stringhe, ma può risultare un problema in certi casi. Fortunatamente newLISP offre la possibilità di superare questo problema a scapito di una diminuzione della velocità delle operazioni: utilizzare il tag [text] e [/text].

Creiamo una stringa maggiore di 2048 cartteri e stampiamola:

(setq str (dup "01" 1025))

newLISP crea automaticamente la stringa delimitata dal tag:

[text]01010101.......[/text]

quindi possiamo stamparla senza ulteriori accorgimenti:

(println str)

Se invece vogliamo stampare un testo creato internamente alla funzione "print", dobbiamo usare i tag:

(print
[text]
  <html>
  long long text
  </html>
[/text])

I tag [text] e [/ text] sono usati per delimitare stringhe lunghe (> 2048 char) e sopprimere la traduzione dei caratteri di escape.

Nota: Il trattamento di stringhe maggiori di 2048 caratteri rallenta molto la velocità di esecuzione dei programmi.


-----------------
Aggiunta di liste
-----------------

Se vogliamo aggiungere tutti gli elementi di una lista ad un'altra lista possiamo utilizzare diversi metodi:

(setq lst1 '(a b c d))
(setq lst2 '(1 2 3 4))

Uso di "append":
(setq lst-all (append lst1 lst2))
;-> (a b c d 1 2 3 4)

Uso di "extend"
(setq lst-all (extend lst1 lst2))
;-> (a b c d 1 2 3 4)

In questo ultimo esempio la funzione "extend" aggiunge lst2 a lst1, quindi dopo aver eseguito l'espressione abbiamo lst1 = lst-all (lst1 viene modificato).

Uso di "push":
(setq lst-all '())
(setq lst1 '(a b c d))
(setq lst2 '(1 2 3 4))
(map (fn(x) (push x lst-all -1)) lst1)
;-> ((a) (a b) (a b c) (a b c d))
lst-all
;-> (a b c d)
(map (fn(x) (push x lst-all -1)) lst2)
;-> ((a b c d 1) (a b c d 1 2) (a b c d 1 2 3) (a b c d 1 2 3 4))
lst-all
;-> (a b c d 1 2 3 4)


----------------------
Liberare una variabile
----------------------

Supponiamo di avere una lista L che occupa diversi megabyte di memoria.
Qual'è il modo corretto di liberare quella memoria da uno script in esecuzione?

Basta assegnare il valore nil alla variabile in questione:

(setq L nil)

Il momento che la memoria liberata verrà assegnata alla memoria generale del sistema dipende dal sistema operativo utilizzato. Potrebbe rimanere assegnata al processo fino a che il sistema operativo non la reclamerà, ma newLISP la libera nello stesso momento in cui avviene l'assegnazione a nil.
Se la variabile è locale in una funzione definita dall'utente (con local o let), allora la variabile verrà assegnata a nil al termine della funzione.


------------------------------
Massimo prodotto di due numeri
------------------------------

Trovare i due numeri distinti che formano il prodotto massimo in una lista di numeri interi non negativi.
Input: una lista di n numeri interi non negativi.
Output: il valore massimo che può essere ottenuto moltiplicando due elementi diversi della lista.
In termini matematici, data una lista di numeri interi non negativi (a1, a2, ... an), calcolare:

 max(ai*aj) dove 1<=i<=n e 1<=j<=n

da notare che deve risultare i<>j, ma può essere ai = aj.

Il problema è abbastanza semplice, ma la soluzione ottima (in termini di numero di operazioni dell'algoritmo utilizzato) non è immediata.

La soluzione esaustiva (forza bruta) è quella di calcolare i prodotti di tutte le coppie possibili di numeri e trovare il prodotto maggiore.

(define (maxprod1 lst)
  (let (prodotto 0)
    (for (i 0 (- (length lst) 1))
      (for (j 0 (- (length lst) 1))
        (if (!= i j)
            (if (< prodotto (* (lst i) (lst j)))
                (setq prodotto (* (lst i) (lst j)))
            )
        )
      )
    )
    prodotto
  )
)

(maxprod1 '(1 2 3 4 5 6))
;-> 30

Possiamo migliorare l'algoritmo iniziando il secondo ciclo con j = i + 1.
Purtroppo (o per fortuna) newLISP ha un ciclo "for" che non funziona esattamente come quello degli altri linguaggi. Infatti se il valore dell'indice è superiore a quello del numero limite, allora le espressioni all'interno del ciclo vengono eseguite ugualmente perchè newlisp considera che il ciclo abbia un indice che va all'indietro (-1). Quando l'indice è uguale al numero limite, allora il ciclo termina.

(define (test-for n)
    (for (i 0 n)
      (for (j (+ i 1) n)
        (println i { } j)
      )))

(test-for 2)
;-> 0 1
;-> 0 2
;-> 1 2
;-> 2 3 ; in questo caso risulta j > n, ma newLISP lo esegue lo stesso
;-> 2 2 ; perchè considera che il passo dellindice sia negativo (-1).

Quindi dobbiamo usare "while" nel secondo ciclo:

(define (maxprod2 lst)
  (let (prodotto 0)
    (for (i 0 (- (length lst) 1))
      (setq j (+ i 1))
      (while (<= j (- (length lst) 1))
        (if (< prodotto (* (lst i) (lst j)))
            (setq prodotto (* (lst i) (lst j)))
        )
        (++ j)
      )
    )
    prodotto
  )
)

(maxprod2 '(1 2 3 4 5 6))
;-> 30

Possiamo anche eliminare l'espressione "if" utilizzando la funzione "max":

(define (maxprod3 lst)
  (let (prodotto 0)
    (for (i 0 (- (length lst) 1))
      (setq j (+ i 1))
      (while (<= j (- (length lst) 1))
        (setq prodotto (max prodotto (* (lst i) (lst j))))
        (++ j)
      )
    )
    prodotto
  )
)

(maxprod3 '(1 2 3 4 5 6))
;-> 30

La complessità temporale delle tre funzioni vale O(n^2) (perchè abbiamo due cicli innestati). Verifichiamo le funzioni calcolando i tempi di esecuzione:

(time (maxprod1 (sequence 1 100)) 1000)
;-> 1820.132
(time (maxprod2 (sequence 1 100)) 1000)
;-> 1669.535
(time (maxprod3 (sequence 1 100)) 1000)
;-> 1632.634

Cerchiamo un algoritmo migliore.
Considerando che il massimo prodotto si ottiene moltiplicando i due valori maggiori della lista, possiamo pensare di cercare questi due valori con l'utilizzo di due cicli: un ciclo per trovare l'elemento maggiore e un secondo ciclo per trovare il secondo elemento maggiore.
La funzione che utilizza questo algoritmo è la seguente:

(define (maxprod4 lst)
  (local (idx1 idx2)
    (setq idx1 0)
    (for (i 1 (- (length lst) 1))
      (if (> (lst i) (lst idx1))
          (setq idx1 i))
    )
    (if (= idx1 0)
        (setq idx2 1)
        (setq idx2 0))
    (for (i 0 (- (length lst) 1))
         (if (and (!= i idx1) (> (lst i) (lst idx2)))
             (setq idx2 i))
    )
    (* (lst idx1) (lst idx2))
  )
)

(maxprod4 '(1 2 3 4 5 6))
;-> 30

Questa funzione ha complessità temporale pari a O(2*n) (perchè i due cicli "for" usati sono in serie e non innestati come nei casi precedenti).

(time (maxprod4 (sequence 1 100)) 1000)
;-> 32.91

La funzione "maxprod4" è 50 volte più veloce delle precedenti.

Proviamo ad utilizzare le funzioni integrate di newLISP per risolvere il problema, in particolare la funzione "sort":

(define (maxprod5 lst)
  (sort lst >)
  (* (lst 0) (lst 1)))

(maxprod5 '(1 2 3 4 5 6))
;-> 30

(time (maxprod5 (sequence 1 100)) 1000)
;-> 25.906

Come si vede, la funzione "sort" (che fa molto di più che cercare i due numeri maggiori) è molto veloce. Spesso le soluzioni che utilizzano le funzioni integrate sono molto più semplici da scrivere, anche se non sono le migliori dal punto di vista della complessità computazionale.


----------------
Test di funzioni
----------------

Ok, abbiamo scritto una funzione per risolvere il nostro problema: ma come possiamo assicurarci che sia una soluzione corretta?
Possiamo affidarci a dei test specifici, ma nessuno può effettuare dei test rispetto a tutti i casi che si possono presentare nella vita reale. Inoltre, con l'esperienza, si impara che i nostri programmi non sono quasi mai corretti quando li eseguiamo per la prima volta. Per rendere "solido" un programma dovremo provarlo con una serie di test/casi attentamente progettati.
Nota: Imparare come implementare algoritmi, nonché testare ed eseguire il debug dei programmi sono delle abilità fondamentali per un programmatore.
La capacità di creare "test specifici" dipende fortemente dall'esperienza del programmatore e dalla conoscenza delle strutture dati che vengono utilizzate nella soluzione.

Un metodo che si affianca a quello dei "test specifici" è lo "stress-test", che utilizza la creazione di test in modo automatico per ricercare un eventuale errore nel programma.
Uno "stress-test" consiste di quattro parti:

1. Una implementazione corretta di un algoritmo (anche banale e lenta)

2. Un'implementazione alternativa che vogliamo testare

3. Un generatore casuale di test (input del programma)

4. Un ciclo di tutti i test generati per consentire il confronto tra i risultati delle due implementazioni dell'algoritmo: se i risultati di un qualunque test differiscono, allora dobbiamo visualizzare i valori di input e i valori dell'output.

L'idea alla base dello stress test è che due implementazioni corrette dovrebbe dare la stessa risposta per ogni test (a condizione che la risposta al il problema sia univoca). Se, tuttavia, una delle implementazioni non è corretta, esisterà un test in cui le loro risposte sono diverse. L'unico caso in cui questo non si verifica è quando le implementazioni hanno lo stesso errore (ma questo è molto improbabile).
La generazione automatica dei test (cioè di valori diversi di unput) permette di effettuare migliaia di verifiche/confronti sulle nostre funzioni.

Prendiamo ad esempio le funzioni "maxprod" del capitolo precedente e proviamo a scrivere un generatore automatico di test. In questo caso ogni test necessita di una lista di numeri come input che viene generata in modo casuale:

(setq num-rnd (+ 100 (rand 1000)))
;-> 293
(setq input (sequence 0 num-rnd))
;-> (0 1 ... 293)
(extend input input)
;-> (0 1 ... 293 0 1 ... 293)
(setq test (slice (randomize input) 0 num-rnd))
;-> (181 50 283 207 233 190 146 ...)

La funzione finale:

(define (test n)
  (local (input test nun-rnd)
    ; lunghezza della sequenza
    (setq num-rnd (+ 100 (rand 1000)))
    ; creazione sequenza di numeri
    (setq input (sequence 0 num-rnd))
    ; raddoppiamo la sequenza per avere anche numeri doppi nella lista di input
    (extend input input)
    ; ciclo dei test
    (for (i 1 n)
      (print i { })
      ; generiamo un test: un valore per la lista di input
      (setq test (slice (randomize input) 0 num-rnd))
      ; verifichiamo i risultati delle funzioni
      (if (or (!= (maxprod1 test) (maxprod2 test))
              (!= (maxprod2 test) (maxprod3 test))
              (!= (maxprod3 test) (maxprod4 test))
              (!= (maxprod4 test) (maxprod5 test)))
          ; stampa input e output quando i risultati sono diversi
          (println (maxprod1 test) { } (maxprod2 test) { }
                   (maxprod3 test) { } (maxprod4 test) { }
                   (maxprod5 test) { } test)
      )
    )
    'end-test
  )
)

(test 100)
;->  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
;->  26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47
;->  48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69
;->  70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91
;->  92 93 94 95 96 97 98 99 100 end-test

Nota: la correttezza dei risultati dello "stress-test" dipende dalla correttezza della funzione "test".


-----------------------------------------
Sostituzioni multiple in liste o stringhe
-----------------------------------------

newLISP ha una funzione integrata per modificare liste o stringhe: "replace". Vediamo la definizione del manuale:

*******************
>>>funzione REPLACE
*******************
liste
sintassi: (replace exp-key list exp-replacement [func-compare])
sintassi: (replace exp-key list)

stringhe
sintassi: (replace str-key str-data exp-replacement)
sintassi: (replace str-pattern str-data exp-replacement regex-option)

Sostituzione nelle liste
------------------------
Se il secondo argomento è una lista, "replace" sostituisce tutti gli elementi nella lista list che sono uguali all'espressione in exp-key. L'elemento viene sostituito con exp-replacement. Se manca exp-replacement, tutte le istanze di exp-key verranno eliminate dalla lista.

Si noti che "replace" è distruttiva. Cambia la lista passato ad esso e restituisce la lista modificata. Il numero di sostituzioni effettuate è contenuto nella variabile di sistema $count quando la funzione ritorna. Durante l'esecuzione delle sostituzioni delle espressioni, la variabile di sistema anaforica $it è impostata sull'espressione da sostituire.

Facoltativamente, func-compare può specificare un operatore di confronto o una funzione definita dall'utente. Per impostazione predefinita, func-compare è il = (segno di uguale).

;; list replacement

(set 'aList '(a b c d e a b c d))

(replace 'b aList 'B)
;-> (a B c d e a B c d)
aList
;-> (a B c d e a B c d)
$count
;-> 2  ; number of replacements

;; list replacement with special compare functor/function

; replace all numbers where 10 < number
(set 'L '(1 4 22 5 6 89 2 3 24))

(replace 10 L 10 <)
;-> (1 4 10 5 6 10 2 3 10)
$count
;-> 3

; same as:

(replace 10 L 10 (fn (x y) (< x y)))
;-> (1 4 10 5 6 10 2 3 10)

; change name-string to symbol, x is ignored as nil

(set 'AL '((john 5 6 4) ("mary" 3 4 7) (bob 4 2 7 9) ("jane" 3)))

(replace nil AL (cons (sym ($it 0)) (rest $it))
                (fn (x y) (string? (y 0)))) ; parameter x = nil not used
;-> ((john 5 6 4) (mary 3 4 7) (bob 4 2 7 9) (jane 3))

; use $count in the replacement expression
(replace 'a '(a b a b a b) (list $count $it) =)
;-> ((1 a) b (2 a) b (3 a) b)

Utilizzando le funzioni "match" e "unify" è possibile formulare ricerche sulla lista che sono potenti come le ricerche con le espressioni regolari sulle stringhe:

; calculate the sum in all associations with 'mary

(set 'AL '((john 5 6 4) (mary 3 4 7) (bob 4 2 7 9) (jane 3)))

(replace '(mary *)  AL (list 'mary (apply + (rest $it))) match)
;-> ((john 5 6 4) (mary 14) (bob 4 2 7 9) (jane 3))
$count
;-> 1

; make sum in all expressions

(set 'AL '((john 5 6 4) (mary 3 4 7) (bob 4 2 7 9) (jane 3)))

(replace '(*) AL (list ($it 0) (apply + (rest $it))) match)
;-> ((john 15) (mary 14) (bob 22) (jane 3))
$count
;-> 4

; using unify, replace only if elements are equal
(replace '(X X) '((3 10) (2 5) (4 4) (6 7) (8 8)) (list ($it 0) 'double ($it 1)) unify)
;-> ((3 10) (2 5) (4 double 4) (6 7) (8 double 8))

Eliminazione nelle liste
------------------------
L'ultima forma di "replace" per le liste ha solo due argomenti: l'espressione exp e la lista list. Questa forma rimuove tutte le espressioni exp trovate nella lista.

;; removing elements from a list

(set 'lst '(a b a a c d a f g))
(replace 'a lst)
;-> (b c d f g)
lst
;-> (b c d f g)

$count
;-> 4

Sostituzione nelle stringhe senza espressioni regolari
------------------------------------------------------
Se tutti gli argomenti sono stringhe, "replace" sostituisce tutte le occorrenzw di str-key in str-data con l'espressione valutata exp-replacement e ritorna la stringa modificata. L'espressione in exp-replacement viene valutata per ogni sostituzione. Il numero di sostituzioni effettuate è contenuto nella variabile di sistema $count. Questa forma di "replace" può processare anche gli 0 (zero) binari.

;; string replacement
(set 'str "this isa sentence")
(replace "isa" str "is a")
;-> "this is a sentence"
$count
;-> 1

Sostituzione con le espressioni regolari
----------------------------------------
La presenza di un quarto parametro indica che deve essere effettuata una ricerca con le espressioni regolari il cui modello/pattern viene specificato da str-pattern e da un numero, regex-option, che specifica l'opzione della regex (es. 1 (one) o "i" per ricerche case-insensitive o 0 (zero) per una ricerca standard PCRE (Perl Compatible Regular Expression) senza opzioni). Vedi anche "regex" per maggiori dettagli.

Per default, "replace" sostituisce tutte le occorrenze nella stringa anche se viene inclusa la specifica di beginning-of-line nel modello/pattern di ricerca. Dopo ogni sostituzione, parte una nuova ricerca dalla nuova posizione in str-data. Impostare il bit di opzione a 0x8000 in regex-option costringe "replace" ad sostituire solo la prima occorrenza. La stringa modificata viene restituita.

"replace" con le espressioni regolari imposta anche le variabili di sistema $0, $1 e $2 con il contenuto della espressione e delle sotto-espressioni trovate. La variabile anaforica di sistema $it ha lo stesso valore di $0. Queste variabili possono essere usate per sostituzioni che dipendono dal contenuto dell'espressione trovata durante la sostituzione. I simboli $0, $1, $2 e $it possono essere usati nelle espressioni come tutti gli altri simboli. L'espressione di sostituzione valuta su un valore diverso da una stringa, allora non viene effettuata alcuna sostituzione. In alternativa, si può accedere al contenuto di queste variabili utilizzando ($ 0), ($ 1), ($ 2), ecc. Questo metodo permette l'accesso indicizzato (es ($ i), dove i è un intero) .

Dopo che sono state effettuate tutte le sostituzioni, il numero di sostituzioni è contenuto nella variabile di sistema $count.

;; using the option parameter to employ regular expressions

(set 'str "ZZZZZxZZZZyy")
;-> "ZZZZZxZZZZyy"
(replace "x|y" str "PP" 0)
;-> "ZZZZZPPZZZZPPPP"
str
;-> "ZZZZZPPZZZZPPPP"

;; using system variables for dynamic replacement

(set 'str "---axb---ayb---")
(replace "(a)(.)(b)" str (append $3 $2 $1) 0)
;-> "---bxa---bya---"

str
;-> "---bxa---bya---"

;; using the 'replace once' option bit 0x8000

(replace "a" "aaa" "X" 0)
;-> "XXX"

(replace "a" "aaa" "X" 0x8000)
;-> "Xaa"

;; URL translation of hex codes with dynamic replacement

(set 'str "xxx%41xxx%42")
(replace "%([0-9A-F][0-9A-F])" str
               (char (int (append "0x" $1))) 1)
;-> xxxAxxxB
str
;-> "xxxAxxxB"

$count
;-> 2

La funzione "setf" insieme a "nth", "first" o "last" possono anche essere usate per modificare gli elementi in una lista.

Vedi anche "directory", "find", "find-all", "parse", "regex" e "search" per le altre funzioni che usano le espressioni regolari.

Come abbiamo visto la funzione "replace" sostituisce gli elementi utilizzando una stringa di ricerca. Quando dobbiamo effettuare sostituzioni con diverse stringhe di ricerca occorre applicare la funzione "replace" per ognuna di queste stringhe. Per esempio:

(setq text "albero mela cucina pesce")
(replace "albero" text "pera" 0)
;-> "pera mela cucina pesce"
(replace "cucina" text "formaggio" 0)
;-> "pera mela formaggio pesce"

Possiamo accopiare e mettere tutte le stringhe di ricerca e modifica in una lista e poi utilizzare la seguente espressione:

(setq text "albero mela cucina pesce")
(setq repls '(("albero" "pera") ("cucina" "formaggio")))

(dolist (r repls)
    (replace (first r) text (last r)))
;-> "pera mela formaggio pesce"

Per utilizzare questo metodo, Lutz ha fornito la seguente macro:

(define-macro (replace-all)
    (dolist (r (eval (args 0)))
        (replace (first r) (eval (args 1)) (last r))))

(setq text "albero mela cucina pesce")
;-> "albero mela cucina pesce"
(replace-all repls text)
;-> "pera mela formaggio pesce"
text
"pera mela formaggio pesce"

Risulta comodo accoppiare le modifiche nel caso ci siano parecchie modifiche da effettuare.


-------------
Cambio monete
-------------

Calcolare il numero minimo di monete necessarie per cambiare un valore dato in monete da 1, 5 e 10.

Fino a che il totale è maggiore di zero (totale > 0), prendere una moneta con il valore più grande possibile che non superi il totale, sottrarre il valore della moneta al totale e aggiungere uno al numero che conteggia la quantità di quel taglio di moneta.

return int(money/10) + int((money mod 10)/5) + (money mod 5)

(define (cambio tot)
  (local (m10 m5 m1)
    (setq m10 0 m5 0 m1 0)
    (while (> tot 0)
      (cond ((>= tot 10)
             (setq tot (- tot 10) m10 (+ m10 1)))
            ((>= tot 5)
             (setq tot (- tot 5) m5 (+ m5 1)))
            (true
             (setq tot (- tot 1) m1 (+ m1 1)))
      )
    )
    (list m10 m5 m1 (+ (* m10 10) (* m5 5) (* m1 1)))
  )
)

(cambio 11)
;-> (1 0 1 11)

Se volessimo sapere solo quante monete sono necessarie per cambiare un certo totale, è sufficiente la seguente funzione:

(define (cambionum tot) (+ (/ tot 10) (/ (% tot 10) 5) (% tot 5)))

(cambionum 11)
;-> 2


-----------------
Funzione Harakiri
-----------------

Il titolo non è proprio corretto, perchè non è possibile scrivere una funzione autodistruttiva, ma newLISP permette di scrivere una macro che svolge il compito di "distruzione":

(define-macro (killme)
    (let (temp (eval (args)))
      (delete (args 0))
      temp))

(define (ei-fu x) (+ x x))

(killme ei-fu 21)
;-> 42

Vediamo se la funzione esiste nei simboli di newLISP:

(sym "ei-fu" MAIN nil)
;-> nil

No...la funzione non esiste più!


--------------------------
Ciclo for con numeri float
--------------------------

newLISP permette di utilizzare i numeri floating point come indici per il ciclo for:

(for (t 1 0.0 0.1) (println t))
;-> 1
;-> 0.9
;-> 0.8
;-> 0.7
;-> 0.6
;-> 0.5
;-> 0.3999999999999999
;-> 0.2999999999999999
;-> 0.2
;-> 0.09999999999999998
;-> 0

Questo è dovuto al fatto che non esiste un modo preciso per convertire esattamente un numero da decimale a binario e viceversa.
Quando si confrontano i float è sempre necessario confrontare la differenza dei numeri
contro qualche altra piccola quantità.
La differenza tra:

(setq x 1)
(for (i 1 10) (println (dec 'x 0.1)))
;-> 0.9
;-> 0.8
;-> 0.7000000000000001
;-> 0.6000000000000001
;-> 0.5000000000000001
;-> 0.4000000000000001
;-> 0.3000000000000002
;-> 0.2000000000000002
;-> 0.1000000000000001
;-> 1.387778780781446e-016

e

(for (i 1 0.0 0.1) (println i))
;-> 1
;-> 0.9
;-> 0.8
;-> 0.7
;-> 0.6
;-> 0.5
;-> 0.3999999999999999
;-> 0.2999999999999999
;-> 0.2
;-> 0.09999999999999998
;-> 0

è che newLISP quando esegue cicli "for" e sequenze cerca di evitare l'accumulo
dell'errore di arrotondamento calcolando prima il numero totale di iterazioni,
quindi calcola la variabile del ciclo "i" come prodotto di "step * count"
e non come un incremento ripetuto come nel primo esempio.
In questo modo newLISP non crea mai errori di underrun o overrun nei cicli.

Comunque se vogliamo utilizzare i valori della variabile del ciclo possiamo arrotondarla con le cifre desiderate:

(for (i 1 0.0 0.1) (println (round i -1)))
;-> 1
;-> 0.9
;-> 0.8
;-> 0.7
;-> 0.6
;-> 0.5
;-> 0.4
;-> 0.3
;-> 0.2
;-> 0.1
;-> 0


--------------------------
Nascondere la finestra DOS
--------------------------

Possiamo nascondere la finestrea DOS quando eseguiamo uno script newLISP.
Il seguente esempio mostra le funzioni necessarie per questo problema.

Salvare il seguente script in un file (es. hide.lsp) e poi eseguire dal prompt del DOS:

newlisp hide.lsp

In questo modo la console di newLISP viene nascosta.

; Esempio di script che nasconde la console del DOS (console)
; import functions
(import "kernel32.dll" "FreeConsole")
(import "user32.dll" "MessageBoxA")
; hide console
(FreeConsole)
; function to show messageBox
(define (message-box text (title "newLISP"))
  (let ((MB_OK 0))
    (MessageBoxA 0 text title MB_OK)))
; show a message
(message-box "Ciao da windows")
;(read-line)
(exit)


-----------------------
Funzioni come parametri
-----------------------

In newLISP possiamo passare delle funzioni come parametri:

(define (do-func func arg) (func arg))

(do-func upper-case "hello")
;-> "HELLO"

Per le funzioni definite dall'utente:

(define (stampa txt) (println txt))

(do-func stampa "pippo")
;-> pippo

Se la funzione da passare si trova all'interno di una lista (come simbolo):

(define (do-func func arg) (setq func (eval (first func))) (func arg))

(do-func '(upper-case lower-case) "hello")
;-> "HELLO"


------------------------
Valutazione input utente
------------------------

newLISP ha due funzioni di valutazione: "eval" e "eval-string".
La prima, "eval", accetta un'espressione e la valuta:

(set 'expr '(+ 1 2))
(eval expr)
;-> 3

La seconda, "eval-string", accetta una stringa e la valuta:

(set 'expr "(+ 1 2)")
(eval-string expr)
;-> 3

In realtà ne esiste anche una terza, "read-expr", che prende una stringa e la converte in una espressione (non valutata):

(read-expr "(+ 3 4)")
;-> (+ 3 4)
(eval (read-expr "(+ 3 4)"))
;-> 7

Quindi "eval-string" è una combinazione di "read-expr" e "eval".

Un modo per valutare l'input dell'utente potrebbe essere questo:

(print "Enter the 1st number: ")
(set 'num1 (int (read-line)))
(print "Enter the 2nd number: ")
(set 'num2 (int (read-line)))
(print "Enter an operator [+ - * /]: ")
(set 'op (eval-string (read-line)))
(set 'result (op num1 num2))
(print result)
(exit)

oppure:

(set 'op (eval (sym (read-line))))

La parte fondamentale è l'espressione:

(op num1 num2)

dove op è ovviamente un simbolo.
Bisogna assicurarsi che questo simbolo sia valutato come una funzione,
in questo caso alla funzione built-in della moltiplicazione fra interi "*".
Il carattere "*" di per sé non è la funzione built-in, ma è il simbolo che valuta alla funzione primitiva della moltiplicazione (analogamente a (set 'f (lambda (x) x)), dove f è un simbolo che valuta alla lista lambda).
Occorre definire op in modo che la sua valutazione sia la stessa di "*" (non al simbolo "*"). Possiamo farlo nei modi seguenti:

(set 'op *)

che è equivalente a:

(set 'op (eval '*)) ;

che è equivalente a:

(set 'op (eval (sym "*")));

che è equivalente a:

(set 'op (eval-string "*"))

Invece, (set 'op' *) non funziona, poichè imposta il valore del simbolo op al simbolo "*" (e non alla sua valutazione).

Vediamo la descrizione delle funzioni "eval", "eval-string" e "read-expr" dal manuale:

*****************
>>>funzione EVAL
*****************
sintassi: (eval exp)

"eval" calcola il risultato della valutazione dell'espressione "exp".
La valutazione viene effettuata nel contesto corrente delle variabili.

Esempi:

(set 'expr '(+ 3 4))
;-> (+ 3 4)
(eval expr)
;-> 7
(eval (list + 3 4))
;-> 7
(eval ''x)
;-> x
(set 'y 123)
(set 'x 'y)
;-> y
(eval x)
;-> 123

La valutazione delle variabili avviene nel contesto corrente:

(set 'x 3 'y 4)
(eval '(+ x y))
;-> 7

Vediamo "eval" in un contesto locale:

(let ( (x 33) (y 44) )
    (eval '(+ x y)))
;-> 77

Ancora "eval" nel vecchio contesto dopo essere usciti dal contesto locale:

(eval '(+ x y))
;-> 7

newLISP passa tutti gli argomenti per valore. Utilizzando un simbolo quotato, le espressioni possono essere passate per riferimento attraverso il simbolo. eval può essere utilizzato per accedere al contenuto originale del simbolo:

(define (change-list aList) (push 999 (eval aList)))

(set 'data '(1 2 3 4 5))

(change-list 'data)
;-> (999 1 2 3 4 5)

Nell'esempio, il parametro 'data è quotato, quindi push lavora sulla lista originale.

newLISP permette un metodo più sicuro per passare argomenti per riferimento racchiudendo i dati all'interno di oggetti contesto. Passare i riferimenti nella funzione definita dall'utente usando gli id dello spazio dei nomi evita la cattura della variabile del simbolo passato, nel caso in cui il simbolo passato sia lo stesso di quello usato come parametro nella funzione. Vedi il paragrafo successivo "Passare dati per riferimento".

************************
>>>funzione EVAL-STRING
************************
sintassi: (eval-string str-source [sym-context [exp-error [int-offset]]])

int-offset specifies an optional offset into str-source, where to start evaluation.

La stringa in str-source viene compilata nel formato interno di newLISP e quindi valutata. Il risultato della valutazione viene restituito. Se la stringa contiene più di un'espressione, allora viene restituito il risultato dell'ultima valutazione.

Un secondo argomento facoltativo può essere utilizzato per specificare il contesto in cui la stringa deve essere analizzata e tradotta.

Se si verifica un errore durante l'analisi e la valutazione di str-source, verrà valutato exp-error e verrà restituito il suo risultato.

int-offset specifica un offset opzionale in str-source, da dove iniziare la valutazione.

(eval-string "(+ 3 4)")
;-> 7
(set 'X 123)
;-> 123
(eval-string "X")
;-> 123

(define (repl) ; read print eval loop
  (while true
    (println "=> " (eval-string (read-line) MAIN (last-error)))
  )
)

(set 'a 10)
(set 'b 20)
(set 'foo:a 11)
(set 'foo:b 22)

(eval-string "(+ a b)")
;-> 30
(eval-string "(+ a b)" 'foo)
;-> 33

Il secondo esempio mostra un semplice ciclo eval dell'interprete newLISP.

L'ultimo esempio mostra come specificare un contesto di destinazione per la traduzione. I simboli a e b si riferiscono ora ai simboli e ai loro valori nel contesto foo anziché MAIN.

**********************
>>>funzione READ-EXPR
**********************
sintassi: (read-expr str-source [sym-context [exp-error [int-offset]]])

read-expr analizza le prime espressioni che trova in str-source e restituisce l'espressione tradotta senza valutarla. Un contesto opzionale in sym-context specifica uno spazio dei nomi per l'espressione tradotta.

Dopo una chiamata a read-expr, la variabile di sistema $count contiene il numero di caratteri scansionati.

Se si verifica un errore durante la traduzione di str-source, l'espressione in exp-error viene valutata e il risultato restituito.

int-offset specifica un offset opzionale in str-source dove dovrebbe iniziare l'elaborazione. Quando si chiama ripetutamente read-expr questo numero può essere aggiornato usando $count, il numero di caratteri elaborati.

(set 'code "; a statement\n(define (double x) (+ x x))")

(read-expr code) → (define (double x) (+ x x))

$count
;-> 41

read-expr si comporta in modo simile a eval-string, ma senza il passaggio di valutazione:

(read-expr "(+ 3 4)")
;-> (+ 3 4)

(eval-string "(+ 3 4)")
;-> 7

Utilizzando read-expr è possibile programmare un pre-elaboratore di espressioni di codice personalizzato prima della loro valutazione.

Vedere anche "event-reader" per il processamento di espressioni basate su eventi.


----------------------------
Passare dati per riferimento
----------------------------

Un funtore di default di un contesto può essere usato per contenere dati. Se questi dato contiene una lista o una stringa, allora possiamo usare il nome del contesto come un riferimento al dato stesso:

;; the default functor for holding data

(define Mylist:Mylist '(a b c d e f g))

(Mylist 3) → d

(setf (Mylist 3) 'D) → D

Mylist:Mylist → (a b c D e f g)

;; access list or string data from a default functor

(first Mylist) → a

(reverse Mylist) → (g f e D c b a)

(set 'Str:Str "acdefghijklmnop")

(upper-case Str) → "ACDEFGHIJKLMNOP"

Il più delle volte, newLISP passa i parametri per copia del valore. Ciò rappresenta un potenziale problema quando si passano liste o stringhe di grandi dimensioni a funzioni o macro definite dall'utente. Le stringhe e le liste che vengono inglobate in uno spazio dei nomi utilizzando i funtori di default vengono passati automaticamente per riferimento:

;; use a default functor to hold a list

(set 'Mydb:Mydb (sequence 1 100000))

(define (change-db obj idx value)
    (setf (obj idx) value))

; pass by context reference
(change-db Mydb 1234 "abcdefg")

(Mydb 1234)
;-> "abcdefg"

Qualsiasi argomento di una funzione built-in che richiede una lista o una stringa, ma nessun altro tipo di dati, può ricevere dati passati per riferimento. Qualsiasi funzione definita dall'utente può accettare qualsiasi normale argomento. Qualsiasi funzione definita dall'utente può accettare variabili normali o può accettare un nome di contesto per passare un riferimento al funtore predefinito contenente una lista o una stringa.

Si noti che nelle liste con meno di circa 100 elementi o stringhe di meno di circa 50000 caratteri, la differenza di velocità tra passaggio per riferimento e passaggio per valore è trascurabile. Ma con oggetti (dati) più grandi, le differenze di velocità e di utilizzo della memoria tra passaggio per riferimento e passaggio per valore possono essere significative.

Le funzioni integrate e definite dall'utente sono adatte per entrambi i tipi di argomenti, ma quando si passano i nomi di contesto, i dati verranno passati per riferimento.

I simboli quotati possono anche essere utilizzati per passare i dati per riferimento, ma questo metodo presenta degli svantaggi:

(define (change-list aList) (push 999 (eval aList)))

(set 'data '(1 2 3 4 5))

; note the quote ' in front of data
(change-list 'data)
;-> (999 1 2 3 4 5)

data
;-> (999 1 2 3 4 5)

Sebbene questo metodo sia semplice da comprendere e utilizzare, pone il potenziale problema della cattura della variabile quando si passa lo stesso simbolo utilizzato come parametro di funzione:

;; pass data by symbol reference

(set 'aList '(a b c d))
;-> (a b c d)
(change-list 'aList)
;-> ERR: list or string expected : (eval aList)
;-> called from user defined function change-list

Prima abbiamo visto come inserire i dati in uno spazio dei nomi (contesto) usando il funtore predefinito. Oltre al funtore predefinito è possibile utilizzare qualsiasi simbolo del contesto per memorizzare i dati. Lo svantaggio è che la funzione chiamante deve avere conoscenza del simbolo utilizzato:

;; pass data by context reference

(set 'Mydb:data (sequence 1 100000))

(define (change-db obj idx value)
    (setf (obj:data idx) value))

(change-db Mydb 1234 "abcdefg")

(nth 1234 Mydb:data)
;-> "abcdefg"
; or
(Mydb:data 1234)
;-> "abcdefg"

La funzione riceve lo spazio dei nomi nella variabile obj, ma deve avere la consapevolezza che la lista a cui accedere è contenuta nel simbolo dei dati di quello spazio dei nomi (contesto).

Vediamo la differenza di velocità tra passaggio per riferimento e passaggio per valore:

(silent (setq refer:refer (sequence 1 100000)))
(silent (setq value (sequence 1 100000)))

(define (somma lst) (apply + lst))

(time (somma value) 1000)
;-> 3135.194
(time (somma refer) 1000)
;-> 1916.157


---------------------
Pagamento giornaliero
---------------------

Abbiamo un lingotto d'oro massiccio, contrassegnato con 7 divisioni uguali come segue:

| - | - | - | - | - | - | - |

Bisogna pagare un dipendente ogni giorno per una settimana con un pezzo di lingotto al giorno. È possibile fare questo utilizzando solo due tagli del lingotto?

Possiamo pagare il dipendente se numeriamo il lingotto e poi lo nella maniera seguente:

lingotto numerato

| 1 | 2 | 3 | 4 | 5 | 6 | 7 |

lingotto tagliato in tre parti (taglio tra 12 e 2 e taglio tra 4 e 5):

| 1 |     | 2 | 3 |     | 4 | 5 | 6 | 7 |

Abbiamo ottenuto un pezzo da 1 blocco, un pezzo da 2 blocchi e un pezzo di 4 blocchi.
Per pagare il dipendente dobbiamo operare nel modo seguente:

1° giorno: consegnare il pezzo da 1 blocco
noi: 6 - dipendente: 1
2° giorno: consegnare il pezzo da 2 blocchi e riprendere il pezzo da 1 blocco
noi: 5 - dipendente: 2
3° giorno: consegnare il pezzo da 1 blocco
noi: 4 - dipendente: 3
4° giorno: consegnare il pezzo da 4 blocchi e riprendere i pezzi da 1 e 2 blocchi
noi: 3 - dipendente: 4
5° giorno: consegnare il pezzo da 1 blocco
noi: 2 - dipendente: 5
6° giorno: consegnare il pezzo pezzo da 2 blocchi e riprendere il pezzo da 1 blocco
noi: 1 - dipendente: 6
7° giorno: consegnare il pezzo da 1 blocco
noi: 0 - dipendente: 7

Con questo metodo abbiamo pagato il dipendente 1 blocco d'oro al giorno.

Nota: in altre parole abbiamo utilizzato l'aritmetica binaria.


-------------------------
Differenze tra let e letn
-------------------------

In Common Lisp abbiamo le primitive "let" e "let*", in newLISP abbiamo "let" e "letn".
La differenza tra "let" e "letn": associazione parallela rispetto all'associazione sequenziale.

Sequenziale. Significa che le associazioni vengono fatte una dopo l'altra e possono vedere le associazioni precedenti.

Parallelo. Significa che le associazioni prendono vita allo stesso tempo e non vedono le altre associazioni (no shadow).

Supponiamo di avere il seguente codice:

CommonLisp:

(print (let ((c 1))
         (let ((c 2)
               (a (+ c 1)))
           a)))

(print (let ((c 1))
         (let* ((c 2)
                (a (+ c 1)))
           a)))

newLISP:

(let ((c 1))
  (let ((c 2) (a (+ c 1)))
   a))
;-> 2

(let ((c 1))
  (letn ((c 2) (a (+ c 1)))
   a))
;-> 3

Nel primo esempio, l'associazione (bindings) di "a" si riferisce al valore esterno di "c" cioè 1).

Nel secondo esempio, dove letn consente alle associazioni di fare riferimento alle associazioni precedenti, il legame di "a" si riferisce al valore interno di c (cioè 2).

La funzione "let" può essere simulata con la funzione "lambda" in questo modo:

(let ((a1 b1) (a2 b2) ... (an bn))
  (some-code a1 a2 ... an))

è uguale a:

((lambda (a1 a2 ... an)
   (some-code a1 a2 ... an))
 b1 b2 ... bn)

Invece "letn" può essere simulata in un altro modo:

(letn ((a1 b1) (a2 b2) ... (an bn))
  (some-code a1 a2 ... an))

è uguale a:

((lambda (a1)
    ((lambda (a2)
       ...
       ((lambda (an)
          (some-code a1 a2 ... an))
        bn))
      b2))
   b1)

Quindi "let" è più semplice di "letn" (almeno per il compilatore/interprete).

"let" semplifica la comprensione del codice. Tutte le associazioni possono essere lette singolarmente senza la necessità di comprendere il flusso top-down/left-right degli "effetti" delle associazioni (rebindings). L'uso di "letn" segnala al programmatore (quello che legge il codice) che le associazioni non sono indipendenti, ma esiste un di flusso top/down che complica le cose.

Il Lisp ha la regola che i valori per le associazioni (binding) in "let" sono calcolati da sinistra a destra. Come vengono valutati gli argomenti di una chiamata di funzione, da sinistra a destra. Quindi, "let" è l'istruzione concettualmente più semplice e dovrebbe essere utilizzata per impostazione predefinita.

La differenza non è importante solo per il compilatore. Uso "let" e "letn" come suggerimento per me stesso di ciò che sta succedendo. Quando vedo "let" nel mio codice, so che le associazioni (binding) sono indipendenti e quando vedo "letn", so che le associazioni (binding) dipendono una dall'altra. Ma lo so solo perché mi assicuro di usare "let" e "letn" in modo coerente.


------------
Tecnica RAID
------------

RAID, acronimo di "Redundant Array of Independent Disks" ovvero insieme ridondante di dischi indipendenti, (originariamente "Redundant Array of Inexpensive Disks", insieme ridondante di dischi economici), è una tecnica di installazione in un computer di diversi dischi rigidi in modo che appaiano e siano utilizzabili come se fossero un unico volume di memorizzazione.
Il principio di base della tecnica RAID si basa sulla funzione XOR.

Tabella di verità XOR
Input A   Input B   Output
  0         0         0
  0         1         1
  1         0         1
  1         1         0

Proprietà dello XOR
Commutativa: A xor B = B xor A
L'ordine dei parametri non modifica il risultato

Associativa: A xor ( B xor C ) = ( A xor B ) xor C
Questo significa che le operazioni XOR possono essere concatenate e l'ordine non ha importanza.

Elemento identità: A xor 0 = A
Questo significa che lo xor di qualsiasi valore con zero rimane invariato.

Auto-inverso: A xor A = 0
Questo significa che qualsiasi valore XOR con se stesso produce zero.

Supponiamo di avere N dischi e di memorizzare su un altro disco (N+1) il valore XOR di tutti gli altri dischi:

D = D1 xor D2 xor … xor Dn

Questa viene chiamata "ridondanza": se accade un errore in un disco (per esempio D1), allora possiamo recuperare i dati utilizzando tutti gli altri dischi:

  D2 xor … xor Dn xor D
= D2 xor … xor Dn xor (D1 xor D2 xor … xor Dn)  (definizione di D)

= D1 xor (D2 xor D2) xor… xor (Dn xor Dn) (commutativa e associativa: arrangiando i termini)

= D1 xor 0 xor… xor 0 (auto-inverso)

= D1  (elemento identità)

Vediamo un esempio con delle liste che simulano i valori contenuti nei dischi:

(setq d1 '(1 1 3))
(setq d2 '(6 5 6))
(setq d3 '(7 8 8))

Calcoliamo i valori xor di tutti i dischi:

(apply ^ '(1 6 7))
;-> 0
(apply ^ '(1 5 8))
;-> 12
(apply ^ '(3 6 8))
;-> 13

In modo equivalente:
(setq d (map (fn (x) (apply ^ x)) (map list d1 d2 d3)))
;-> (0 12 13)

Supponiamo di perdere il valore "5" dalla lista d2, allora possiamo recuperarlo nel modo seguente:

d2(1) = (xor (d1(1) xor d3(1)) d(1)) = (xor (xor 1 8) 12) = 5

Verifichiamo:

(^ (^ 1 8) 12)
;-> 5

Nel caso (altamente improbabile) in cui due dischi si guastassero contemporaneamente, con questa tecnica non ci sarebbe modo di recuperare i dati.


----------
Crypto XOR
----------

La funzione XOR può essere usata per cifrare/decifrare un messaggio.

(define (cryptoXOR msg key)
  (local (k len-key out)
    (setq k 0)
    (setq len-key (length key))
    ;(dolist (el (explode msg)) ; non UTF-8
    (dolist (el (unpack (dup "s" (length msg)) msg)) ; UTF-8
      ;(println (^ (char el) (char (key k))) { } (char el) { } (char (key k)))
      (push (^ (char el) (char (key k))) out -1)
      (++ k)
      (setq k (% k len-key))
    )
    ;(println out)
    (join (map char out))
  ))

(cryptoXOR "messaggio cifrato" "chiave")
;-> "\014\r\026\018\023\002\004\001\006A\021\f\005\026\b\021\025"

(cryptoXOR "\014\r\026\018\023\002\004\001\006A\021\f\005\026\b\021\025" "chiave")
;-> "messaggio cifrato"

(cryptoXOR (cryptoXOR "domani" "key") "key")
;-> "domani"

(cryptoXOR (cryptoXOR "cryptomessage" "password") "password")
;-> cryptomessage

La forza della criptazione dipende dalla lunghezza della chiave, più è lunga la chiave e maggiore sarà la sicurezza.


--------------------
Lancio di una moneta
--------------------

Abbiamo una moneta con due facce: "testa" e "croce".
In teoria lanciando/girando la moneta n volte, dovremmo ottenere il 50% "testa" e il 50% "croce" (circa).
Purtoppo dopo 1000 prove la nostra moneta produce il seguente risultato: 750 volte "testa" e 250 volte "croce".
Come possiamo ottenere una probabilità equa (50% "testa" e 50% "croce") da questa moneta?

Possiamo utilizzare una tecnica indicata da vonNeumann:

Passo 1. Lanciare/girare la moneta due volte.
Passo 2. Se i due risultati sono diversi,
         prendere come evento il primo risultato:
         TC diventa l'evento "testa",
         CT diventa l'evento "croce".
         La procedura è terminata.
Passo 3. Se i due risultati sono gli stessi (TT o CC),
         scartare la prova e tornare al passo 1.

In questo modo i risultati TC e CT sono simmetrici e quindi hanno uguale probabilità.

Vediamo come funziona:
supponiamo che il risultato "testa" abbia il 75% di probabilità e "croce" abbia il 25% di probabilità.
Poichè ogni lancio di moneta è un evento indipendente possiamo calcolare direttamente la probabilità delle coppie:

 TC si verifica (0.75)*(0.25) = 0.1875
 CT si verifica (0.25)*(0.75) = 0.1875

Come si nota, i due eventi coppia sono ugualmente probabili e quindi le possibilità sono pari.

Vediamo di simulare la funzione di vonNeumann:

(define (faircoin)
  (local (a b res)
    (setq res nil)
    (while (= res nil)
      (setq a (rand 2))
      (setq b (rand 2))
      (if (!= a b)
          (setq res a))) res))

(faircoin)
;-> 0

Eseguiamo la funzione n volte:

(define (test n)
  (let ((t 0) (c 0))
    (dotimes (i n)
      (if (= (faircoin) 0)
          (++ t)
          (++ c)))
    (println "testa: " t { - } "croce: "c)))

(test 10000000)
;-> testa: 5001000 - croce: 4999000
(test 100000000)
;-> testa: 49999363 - croce: 50000637

Vediamo il risultato con una simulazione standard (usando direttamente la funzione "rand"):

(define (testreal n)
  (let ((t 0) (c 0))
    (dotimes (i n)
      (if (= (rand 2) 0)
          (++ t)
          (++ c)))
    (println "testa: " t { - } "croce: "c)))

(testreal 10000000)
;-> testa: 5001680 - croce: 4998320
(testreal 100000000)
;-> testa: 50001412 - croce: 49998588

Per vedere se la funzione "faircoin" restiutisce il risultato corretto proviamo a modificare la funzione assegnando a "testa" la probabilità del 75% e a "croce" la probabilità del 25%.

(define (faircoin)
  (local (a b res)
    (setq res nil)
    (while (= res nil)
      (setq a (rand 100))
      (if (> a 25)
          (setq a 0)
          (setq a 1)
      )
      (setq b (rand 100))
      (if (> b 25)
          (setq b 0)
          (setq b 1)
      )
      (if (!= a b)
          (setq res a))) res))

(faircoin)
;-> 0

Proviamo la nuova funzione con n lanci:

(test 10000000)
;-> testa: 4997544 - croce: 5002456
(test 100000000)
;-> testa: 50002280 - croce: 49997720

La procedura di vonNeumann produce risultati equi.

Nota: nella vita reale una moneta non è mai equa, questo è dovuto sia a motivi geometrici/fisici della moneta stessa, sia al modo con cui vengono eseguite le prove (lancio e cattura della moneta oppure rotazione della moneta su un piano). Quindi sarebbe meglio usare la procedura di vonNeumann o utilizzare un generatore di numeri casuali per ottenere una probabilità equa.

Nota: analizziamo il lancio e la cattura di una moneta. Si consideri una moneta, lanciata dalla posizione "testa" per un certo numero di volte, che gira testa-croce attraverso l'aria (con tempi diversi):

lancio 1: T C T C T C T C T C T C T C T C T C T C    ==> (10 T e 10 C)
lancio 2: T C T C T C T C T C T C T C T C T C T      ==> (10 T e 9 C)
lancio 3: T C T C T C T C T C T C                    ==> (6 T e 6 C)
lancio 4: T C T C T C T C T C T C T C T              ==> (8 T e 7 C)

Come si nota, se partiamo dalla posizione "testa" non possiamo mai ottenere un lancio in cui il numero delle croci è superiore al numero delle teste. Invece abbiamo dei lanci in cui il numero delle teste supera di una unità il numero delle croci. In altre parole, in un dato momento, o la moneta avrà trascorso lo stesso tempo negli stati di "testa" e "croce", oppure avrà trascorso più tempo nello stato di "testa". Nel complesso, è leggermente più probabile che la moneta mostri "testa" in un dato momento, incluso il momento in cui la moneta viene catturata. Questo indica che la probabilità dell'evento "testa" è maggiore (anche se di poco) del 50%. Vediamo una simulazione di questo processo:

(define (lancio n)
  (local (t c res)
    (setq t 0 c 0)
    (dotimes (x n)
      ; crea una lista di 0 e 1 alternati di lunghezza casuale (da 3 a 22)
      ; che inizia con 0 (testa).
      ; Restituisce una lista con il numero di 0 e di 1.
      ; inizia con testa 0
      (setq res (count '(0 1) (slice (flat (dup '(0 1) 11)) 0 (+ (rand 19) 3))))
      ; inizia con croce 1
      ;(setq res (count '(0 1) (slice (flat (dup '(1 0) 11)) 0 (+ (rand 19) 3))))
      (setq t (+ t (first res)))
      (setq c (+ c (last res)))
    )
    (println "testa: " t " - " (mul 100 (div t (add t c))))
    (println "croce: " c " - " (mul 100 (div c (add t c))))))

(lancio 100000)
;-> testa: 628056 - 52.19116884498278
;-> croce: 575320 - 47.80883115501722
(lancio 10000000)
;-> testa: 62623070 - 52.19285897839979
;-> croce: 57360911 - 47.80714102160021


------------
Area massima
------------

Data una corda di 4 metri di lunghezza, tagliandola in due possiamo costruire una circonferenza (con il primo pezzo) e un quadrato con il secondo pezzo. Determinare il taglio ottimo che massimizza la somma delle aree della circonferenza e del quadrato.

Risolviamo il problema con una simulazione.

(define (taglio step)
  (setq pi 3.1415926535)
  (setq corda 4)
  (for (i 0 4 step)
    (setq t1 i)
    (setq t2 (sub corda i))
    (setq l (div t1 4))
    (setq quad (mul l l))
    (setq r (div t2 (mul 2 pi)))
    (setq circle (mul r r pi))
    (println i ": t1=" t1 " t2=" t2 " area=" (add quad circle))
  )
)

(taglio 0.1)
;-> 0: t1=0 t2=4 area=1.273239544771555
;-> 0.1: t1=0.1 t2=3.9 area=1.210998342248459
;-> 0.2: t1=0.2 t2=3.8 area=1.151598689156328
;-> 0.3: t1=0.3 t2=3.7 area=1.095040585495162
;-> 0.4: t1=0.4 t2=3.6 area=1.041324031264959
;-> 0.5: t1=0.5 t2=3.5 area=0.9904490264657215
;-> 0.6: t1=0.6 t2=3.4 area=0.9424155710974482
;-> 0.7: t1=0.7 t2=3.3 area=0.8972236651601393
;-> 0.8: t1=0.8 t2=3.2 area=0.8548733086537949
;-> 0.9: t1=0.9 t2=3.1 area=0.815364501578415
;-> 1: t1=1 t2=3 area=0.7786972439339993
;-> 1.1: t1=1.1 t2=2.9 area=0.7448715357205482
;-> 1.2: t1=1.2 t2=2.8 area=0.7138873769380616
;-> 1.3: t1=1.3 t2=2.7 area=0.6857447675865397
;-> 1.4: t1=1.4 t2=2.6 area=0.6604437076659817
;-> 1.5: t1=1.5 t2=2.5 area=0.6379841971763884
;-> 1.6: t1=1.6 t2=2.4 area=0.6183662361177595
;-> 1.7: t1=1.7 t2=2.3 area=0.6015898244900951
;-> 1.8: t1=1.8 t2=2.2 area=0.5876549622933953
;-> 1.9: t1=1.9 t2=2.1 area=0.5765616495276595
;-> 2: t1=2 t2=2 area=0.5683098861928886
;-> 2.1: t1=2.1 t2=1.9 area=0.562899672289082
;-> 2.2: t1=2.2 t2=1.8 area=0.5603310078162398
;-> 2.3: t1=2.3 t2=1.7 area=0.560603892774362
;-> 2.4: t1=2.4 t2=1.6 area=0.5637183271634487
;-> 2.5: t1=2.5 t2=1.5 area=0.5696743109834999
;-> 2.6: t1=2.6 t2=1.4 area=0.5784718442345155
;-> 2.7: t1=2.7 t2=1.3 area=0.5901109269164955
;-> 2.8: t1=2.8 t2=1.2 area=0.60459155902944
;-> 2.9: t1=2.9 t2=1.1 area=0.6219137405733488
;-> 3: t1=3 t2=1 area=0.6420774715482222
;-> 3.1: t1=3.1 t2=0.8999999999999999 area=0.66508275195406
;-> 3.2: t1=3.2 t2=0.7999999999999998 area=0.6909295817908623
;-> 3.3: t1=3.3 t2=0.6999999999999997 area=0.719617961058629
;-> 3.4: t1=3.4 t2=0.5999999999999996 area=0.7511478897573601
;-> 3.5: t1=3.5 t2=0.5 area=0.7855193678870556
;-> 3.6: t1=3.6 t2=0.3999999999999999 area=0.8227323954477156
;-> 3.7: t1=3.7 t2=0.2999999999999998 area=0.8627869724393401
;-> 3.8: t1=3.8 t2=0.1999999999999997 area=0.905683098861929
;-> 3.9: t1=3.9 t2=0.09999999999999965 area=0.9514207747154824
;-> 4: t1=4 t2=0 area=1

Quindi conviene avere la maggior corda possibile per il cerchio.
Nota: fra tutte le curve chiuse nel piano di fissato perimetro, la circonferenza massimizza l'area della regione inclusa (problema isoperimetrico).


--------------
Sole o pioggia
--------------

In un certo posto il tempo è soleggiato o piovoso, niente in mezzo.
In una giornata di sole, ci sono le stesse possibilità che il giorno successivo pioverà o sarà soleggiato.
In una giornata piovosa, invece, c'è un 70 per cento di possibilità che il giorno successivo pioverà contro una probabilità del 30% che sarà soleggiato.
In media, quante volte piove in questo posto?

(define (test n)
  (local (prob_sole prob_pioggia day dole pioggia)
    ; 0=sole 1=pioggia
    (setq sole 0 pioggia 0)
    (setq day (rand 2))
    (if (= 0 day) (++ sole) (++ pioggia))
    (for (i 2 n)
      (cond ((= day 0) ; se il giorno prima c'era il sole
             (setq day (rand 2))
             (if (= 0 day) (++ sole) (++ pioggia))
            )
            ((= day 1) ; se il giorno prima c'era la pioggia
             (if (< (rand 100) 30)
                 ; se minore di 30 allora giorno di sole
                 (setq sole (+ sole 1) day 0)
                 ; altrimenti giorno di pioggia
                 (setq pioggia (+ pioggia 1) day 1)
             )
            )
      )
    )
    (println "sole: " sole)
    (println "pioggia: " pioggia)
    (println "totale: " (+ sole pioggia))
    (println "%pioggia = " (mul 100 (div pioggia (+ sole pioggia))))
  )
)

(test 10000000)
;-> sole: 3749166
;-> pioggia: 6250834
;-> totale: 10000000
;-> %pioggia = 62.50834

Quindi in quel posto piove il 62.5% dei giorni.


--------------
Roulette russa
--------------

Facciamo una partita alla roulette russa. Si tratta di un gioco d'azzardo che consiste nel posizionare un solo proiettile in una pistola, ruotare il tamburo senza guardare, puntarla verso la propria testa e premere il grilletto. Nel caso in cui il primo colpo non sia mortale, puoi decidere se sparare subito un secondo colpo oppure ruotare (rullare) il tamburo una seconda volta prima di sparare.
Dal punto di vista delle probabilità di sopravvivenza, cosa conviene scegliere?

Dal punto di vista matematico risulta:

% sopravvivenza con un rullaggio:
(setq v (div 4 6))
;-> 0.6666666666666666

% sopravvivenza con due rullaggi:
(setq v (mul (div 5 6) (div 5 6)))
;-> 0.6944444444444445

Cerchiamo di verificare questa soluzione con una simulazione.

(define (russa n)
  (local (gun vivo morto morto1 morto2)
    ; morto1 conta le morti al primo colpo
    ; morto2 conta le morti al secondo colpo
    ; test con un solo rullaggio (due colpi consecutivi)
    (setq vivo 0 morto 0 morto1 0 morto2 0)
    (for (i 1 n)
      (setq gun (rand 6))
      (if (> gun 1) ; se gun=0 o gun=1, allora morto
          (++ vivo)
          (if (= gun 0)
              (++ morto1)
              (++ morto2)
          )
      )
    )
    (println "Un rullaggio: vivo = " vivo " & morto1 = " morto1 " & morto2 = " morto2)
    (println "totale: " (+ vivo morto1 morto2))
    (println "%vivo: " (mul 100 (div vivo (add vivo morto1 morto2))))
    (setq vivo 0 morto 0 morto1 0 morto2 0)
    ; test con due rullaggi (un colpo dopo ogni rullaggio)
    (for (i 1 n)
      ; primo rullaggio e colpo
      (setq gun (rand 6))
      (if (= gun 0)
          (++ morto1)
          (begin ; se vivo allora
            ; secondo rullaggio e colpo
            (setq gun (rand 6))
            (if (= gun 0)
                (++ morto2)
                (++ vivo)
            )
         )
      )
    )
    (println "Due rullaggi: vivo = " vivo " & morto1 = " morto1 " & morto2 = " morto2)
    (println "totale: " (+ vivo morto1 morto2))
    (println "%vivo: " (mul 100 (div vivo (add vivo morto1 morto2))))
  )
)

(russa 10000000)
;-> Un rullaggio: vivo = 6669793 & morto1 = 1665755 & morto2 = 1664452
;-> totale: 10000000
;-> %vivo: 66.69793
;-> Due rullaggi: vivo = 6942370 & morto1 = 1666709 & morto2 = 1390921
;-> totale: 10000000
;-> %vivo: 69.4237

Quindi conviene scegliere di rullare il tamburo due volte.
La teoria della probabilità può salvarti la vita.


---------------------
Common LISP Quicksort
---------------------

La seguente funzione, scritta in Common LISP, implementa l'algoritmo di ordinamento Quicksort.
Vediamo come convertirla in newLISP.

(defun qsort (lst)
   (when lst
     (let* ((x  (car lst))
	          (xs (cdr lst))
	          (lt  (loop for y in xs when (< y x) collect y))
	          (gte (loop for y in xs when (>= y x) collect y)))
     (append (qsort lt) (list x) (qsort gte)))))

La funzione "defun" diventa "define".
La funzione "let*" diventa "letn".
Le funzioni "loop" e "collect" vengono sostituite con "dolist".

(define (qsort lst)
   (when lst
     (letn ((x (first lst))
	          (xs (rest lst))
            (lt '())
            (gte '()))
     (dolist (y xs) (if (< y x) (push y lt -1)))
     (dolist (y xs) (if (>= y x) (push y gte -1)))
     ;(println lt) ;(println gte)
     (append (qsort lt) (list x) (qsort gte))
   )))

(qsort (randomize (sequence 1 100)))
;-> (1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
;->  26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47
;->  48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69
;->  70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91
;->  92 93 94 95 96 97 98 99 100)

Proviamo la velocità:

(silent (setq lst (rand 10000 100000)))
(time (qsort lst))
;-> 374.831


------------------------------------------
Ambito dinamico e parametri delle funzioni
------------------------------------------

Vediamo alcuni esempi per capire meglio come funziona la "visibilità" delle variabili e dei parametri delle funzioni in newLISP (che utilizza l'ambito dinamico).
Un aspetto fondamentale è il seguente:
la funzione chiamata "vede" tutte le variabili locali della funzione chiamante (a meno che la funzione chiamata non abbia variabili locali con nomi/simboli uguali a quelli della funzione chiamante (shadowing)).
L'output degli esempi è autoesplicativo sul funzionamento della visibilità delle variabili.

Esempio 1
---------

(define (f1)
  (local (a b)
    (println "f1-pre: a=" a " e b=" b)
    (f2)
    (println "f1-post: a=" a " e b=" b)))

(define (f2)
  (println "f2-pre: a=" a " e b=" b)
  (setq a 10 b 20)
  (println "f2-post: a=" a " e b=" b)
  (println "f2-pre: c=" c " e d=" d)
  (f3)
  (println "f2-post: c=" c " e d=" d))

(define (f3)
  (local (c d)
    (println "f3-pre: a=" a " e b=" b)
    (println "f3-pre: c=" c " e d=" d)
    (setq c 30 d 40)
    (println "f3-post: c=" c " e d=" d)))

(f1)
;-> f1-pre: a=nil e b=nil
;-> f2-pre: a=nil e b=nil
;-> f2-post: a=10 e b=20
;-> f2-pre: c=nil e d=nil
;-> f3-pre: a=10 e b=20
;-> f3-pre: c=nil e d=nil
;-> f3-post: c=30 e d=40
;-> f2-post: c=nil e d=nil
;-> f1-post: a=10 e b=20

Esempio 2
---------

(define (f1)
  (local (a b)
    (println "f1-pre: a=" a " e b=" b)
    (f2)
    (println "f1-post: a=" a " e b=" b)))

(define (f2)
  (local (aa bb)
    (println "f2-pre: a=" a " e b=" b)
    (println "f2-pre: c=" c " e d=" d)
    (setq a 10 b 20)
    (f3 a b)
    (println "f2-post: a=" a " e b=" b)
    (println "f2-post: c=" c " e d=" d)
    (println "f2-post: x=" x " e y=" y)))

(define (f3 x y)
  (local (c d)
    (println "f3-pre: a=" a " e b=" b)
    (println "f3-pre: c=" c " e d=" d)
    (println "f3-pre: x=" x " e y=" y)
    (setq c 30 d 40)
    (setq x 88 y 99)
    (println "f3-post: a=" a " e b=" b)
    (println "f3-post: c=" c " e d=" d)
    (println "f3-post: x=" x " e y=" y)))

(f1)
;-> f1-pre: a=nil e b=nil
;-> f2-pre: a=nil e b=nil
;-> f2-pre: c=nil e d=nil
;-> f3-pre: a=10 e b=20
;-> f3-pre: c=nil e d=nil
;-> f3-pre: x=10 e y=20
;-> f3-post: a=10 e b=20
;-> f3-post: c=30 e d=40
;-> f3-post: x=88 e y=99
;-> f2-post: a=10 e b=20
;-> f2-post: c=nil e d=nil
;-> f2-post: x=nil e y=nil
;-> f1-post: a=10 e b=20

Esempio 3
---------

(define (f1 x y)
  (local (a b)
    (println "f1-pre: a=" a " e b=" b)
    (println "f1-pre: x=" x " e y=" y)
    (setq a x b y)
    (f2)
    (println "f1-post: a=" a " e b=" b)
    (println "f1-post: x=" x " e y=" y)))

(define (f2)
    (println "f2-pre: a=" a " e b=" b)
    (println "f2-pre: x=" x " e y=" y)
    (setq a 10 b 20)
    (setq x 11 y 22)
    (println "f2-post: a=" a " e b=" b)
    (println "f2-post: x=" x " e y=" y))

(f1 1 2)
;-> f1-pre: a=nil e b=nil
;-> f1-pre: x=1 e y=2
;-> f2-pre: a=1 e b=2
;-> f2-pre: x=1 e y=2
;-> f2-post: a=10 e b=20
;-> f2-post: x=11 e y=22
;-> f1-post: a=10 e b=20
;-> f1-post: x=11 e y=22

Esempio 4
---------
Shadowing delle variabili a e b

(define (f1)
  (local (a b)
    (println "f1-pre: a=" a " e b=" b)
    (setq a 1 b 2)
    (f2)
    (println "f1-post: a=" a " e b=" b)))

(define (f2)
  (local (a b)
    (println "f2-pre: a=" a " e b=" b)
    (setq a 10 b 20)
    (println "f2-post: a=" a " e b=" b)))

(f1)
;-> f1-pre: a=nil e b=nil
;-> f2-pre: a=nil e b=nil
;-> f2-post: a=10 e b=20
;-> f1-post: a=1 e b=2

Un ultimo esempio sulle variabili globali e locali:

(setq val 10)

(define (test a b)
  (let (val 20)
    (call-dc a b)))

(define (call-dc x y)
 (println x { } y)
 val)
    
(test 1 2)
;-> 1 2
;-> 20 ; usa il valore della variabile "val" definita in "test".

val
;-> 10 ; valore della variabili "val" globale.

(define (test1 a b)
    (call-dc a b))

(test1 1 2)
;-> 1 2
;-> 10 ; usa il valore della variabile "val" globale.

val
;-> 10


-------------
Torte e tagli
-------------

Un numero poligonale centrale designa il numero massimo di pezzi in cui può essere diviso una torta con n tagli. La formula generatrice è: n*(n + 1)/2 + 1.

Quando un cerchio viene tagliato n volte per produrre il numero massimo di pezzi, rappresentato come p = f(n), si deve considerare l'ennesimo taglio: il numero di pezzi prima dell'ultimo taglio è f(n - 1), mentre il numero di pezzi aggiunti dall'ultimo taglio è n.
Per ottenere il numero massimo di pezzi, l'ennesima linea di taglio deve attraversare tutte le altre linee di taglio precedenti all'interno del cerchio, ma non incrociare alcuna intersezione delle linee di taglio precedenti. Pertanto, l'ennesima linea stessa viene tagliata in n - 1 punti e in n segmenti di linea. Ogni segmento divide ogni pezzo del pancake ((n - 1) pezzi) in 2 parti, aggiungendo esattamente n al numero di pezzi. La nuova linea non può avere più segmenti poiché può attraversare ogni linea precedente solo una volta. Una linea di taglio può sempre attraversare tutte le linee di taglio precedenti, poiché ruotando il coltello di un piccolo angolo attorno a un punto che non è un'intersezione esistente, e se l'angolo è abbastanza piccolo, intersecheremo tutte le linee precedenti, inclusa l'ultima aggiunta.

Pertanto, il numero totale di pezzi dopo n tagli vale:

f(n) = n + f(n − 1)

Questa relazione di ricorrenza può essere risolta.

Se f(n − 1) si espande di un termine la relazione diventa:

f(n) = n + (n − 1) + f(n − 2)

L'espansione del termine f(n - 2) può continuare fino a quando l'ultimo termine non viene ridotto a f(0), quindi:

f(n) = n + (n − 1) + (n − 2) + ... + 1 + f(0)

Poichè f(0) = 1, perchè c'è un pezzo prima di eseguire qualsiasi taglio, questo può essere riscritto come:

f(n) = 1 + ( 1 + 2 + 3 + ... + n ) .

Questo può essere semplificato, utilizzando la formula per la somma di una progressione aritmetica:

f(n) = 1 + n*(n + 1)/2 = (n^2 + n + 2)/2

La funzione in newLISP è semplice:

(define (torta tagli) (/ (+ (* tagli tagli) tagli 2)2))

(torta 5)
;-> 16

(torta 12)
;-> 79


------------
Il ciclo for
------------

Vediamo la definizione della funzione "for" dal manuale di riferimento:

****************
>>>funzione FOR
****************
sintassi: (for (sym num-from num-to [num-step [exp-break]]) body)

Valuta ripetutamente le espressioni nel corpo (body) per un intervallo di valori specificato in num-from e num-to, inclusi. È possibile specificare una dimensione del passo con num-passo. Se non viene specificata alcuna dimensione del passo, si assume 1.

Facoltativamente, una condizione per l'uscita anticipata dal ciclo può essere definita in exp-break. Se l'espressione break restituisce un valore diverso da zero, il ciclo for restituisce il valore di exp-break. La condizione di rottura viene testata prima di valutare il corpo. Se viene definita una condizione di interruzione, è necessario definire anche num-step.

Il simbolo sym è locale in ambito dinamico rispetto all'espressione for. Assume ogni valore successivamente nell'intervallo specificato come valore intero se non viene specificata alcuna dimensione del passo o come valore in virgola mobile quando è presente una dimensione del passo. Dopo la valutazione dell'istruzione for sym assume il valore precedente.

(for (x 1 10 2) (println x))
;-> 1
;-> 3
;-> 5
;-> 7
;-> 9

(for (x 8 6 0,5) (println x))
;-> 8
;-> 7.5
;-> 7
;-> 6.5
;-> 6

(for (x 1100 2 (> (* x x) 30)) (println x))
;-> 1
;-> 3
;-> 5
;-> true

Il secondo esempio utilizza un intervallo di numeri dal più alto al più basso. Notare che la dimensione del passo è sempre un numero positivo. Nel terzo esempio, viene verificata una condizione di interruzione.

Usare la funzione "sequence" per creare una sequenza di numeri.

Sembra che il ciclo "for" di newLISP sia simile a quello di altri linguaggi (ad esempio il C), invece ci sono alcune importanti differenze. Vediamo alcuni esempi:

Esempio 1
---------
(setq i 10)
(for (i 1 3) (print i { }))
;-> 1 2 3 " "
(println i)
;-> 10

La variabile del ciclo "i" è locale alla funzione "for", quindi non possiamo usarla "fuori" della funzione a meno di utilizzare una seconda variabile:

(setq j 0)
(setq i 10)
(for (i 1 3) (setq j i) (print i { }))
;-> 1 2 3 " "
(setq i j)
;-> 3
(println i)
;-> 3

Esempio 2
---------
(for (i 1 5 1 (> i 2)) (print i { }))
;-> 1 2 true

Quando inseriamo una condizione di uscita (break) dobbiamo specificare anche il passo del ciclo. Inoltre il ciclo "for" restituisce true se la condizione di uscita viene verificata (altrimenti restituisce l'ultima espressione valutata).

(for (i 1 5 1 (> i 10)) (print i { }))
;-> 1 2 3 4 5 " "

Anche se la condizione di uscita viene verificata all'inizio del ciclo viene restituito true:

(for (i 1 5 1 (< i 3)) (print i { }))
;-> true

Esempio 3
---------
(for (i 5 1 1) (print i { }))
;-> 5 4 3 2 1 " "

Notare che il valore del passo vale 1 ed è sempre positivo. Sembra più logico scrivere (for i 5 1 -1), cioè partire dal numero cinque e arrivare al numero 1 utilizzando un passo uguale a -1, ma newLISP "ragiona" in un modo leggermente diverso: quello che è importante è la differenza tra il valore di arrivo e quello di partenza. Se la differenza è negativa, allora utilizza un passo negativo, altrimenti utilizza un passo positivo.
Nel nostro esempio abbiamo:

(arrivo - partenza) = (1 - 5) = -4, quindi newLISP utilizza un passo negativo (di valore 1)

Se specifichiamo un passo negativo, newLISP prende il valore assoluto e poi calcola la direzione del ciclo con il suo metodo:

(for (i 1 5 -1) (print i { }))
;-> 1 2 3 4 5 " "

Questo comporta che newLISP esegue sempre il corpo del ciclo (indipendentemente dal valore logico che si ottiene inizialmente confrontando il valore di partenza, quello di arrivo e il passo):

; partenza = arrivo
(for (i 1 1) (print i { }))
;-> 1 " "

; partenza > arrivo e passo positivo
; in altri linguaggi il corpo del ciclo non viene eseguito
; perchè non possiamo arrivare a 1 partendo da 3 con un passo positivo di valore 1
; invece newLISP...
(for (i 3 1 1) (print i { }))
;-> 3 2 1 " "
(for (i 3 1 -1) (print i { }))
;-> 3 2 1 " "

; partenza < arrivo e passo negativo
; in altri linguaggi il corpo del ciclo non viene eseguito
; perchè non possiamo arrivare a 3 partendo da 1 con un passo negativo di valore 1
; invece newLISP...
(for (i 1 3 -1) (print i { }))
;-> 1 2 3 " "
(for (i 1 3 1) (print i { }))
;-> 1 2 3 " "

Ricordare che il segno del passo non viene considerato da newLISP, quindi il corpo del ciclo "for" viene sempre eseguito (almeno una volta).


------------------------------------------------------------------
Perché uno specchio inverte destra e sinistra invece che su e giù?
------------------------------------------------------------------

GLi specchi non invertono sinistra e destra: questa è solo la nostra interpretazione di ciò che accade.
Il nostro riflesso nello specchio è in realtà invertito da davanti a dietro: se hai un neo sul lato sinistro del tuo viso, appare ancora sul lato sinistro del riflesso. Ma siamo abituati a vedere i volti di altre persone e istintivamente eseguiamo la rotazione mentale perché sappiamo che si sono girati di 180 gradi per fronteggiarci. L'immagine nello specchio viene riflessa, non ruotata, quindi quando la ruotiamo indietro nella nostra testa, appare invertita.
Ogni sezione dello specchio riflette semplicemente ciò che è direttamente di fronte ad esso. Quindi qualunque cosa sia alla mia destra mentre guardo nello specchio sarà alla mia destra nello specchio. Niente è stato invertito, è solo una riflessione, tutto qui.


--------------
Treni e mosche
--------------

Si racconta che sia stato chiesto a John von Neumann di risolvere un problema del seguente tipo:
Due treni sono diretti l'uno verso l'altro sullo stesso binario, ciascuno viaggiando a 60 km/ora. Quando sono a 2 km di distanza, una mosca parte dall'inizio del primo treno e viaggia a 90 km/ora fino alla parte anteriore dell'altro treno. Quindi torna al primo treno, e così via, avanti e indietro fino a che i due treni si scontrano tra loro. Quanto spazio ha coperto viaggia la mosca?

Esiste un modo rapido e un modo analitico per risolvere questo problema.

Il modo analitico è quello di calcolare la somma di una serie geometrica infinita.
La mosca completa la prima tappa del suo viaggio (viaggiando da un treno all'altro) in 4/5 di un minuto, poiché in questo tempo il treno in arrivo percorre 4/5 di km e la mosca vola per 6/5 di un km. Pertanto, dopo 4/5 di minuto, abbiamo una versione simile del problema originale, ma con i treni alla distanza di 2 - 2 x 4/5 = 2/5 km, o 1/5 della distanza originale, a parte. Questo schema continua, formando una serie geometrica infinita di distanze, la cui somma la distanza totale percorsa dalla mosca:

  6/5 * (1 + 1/5 + (1/5)^2 + (1/5)^3 + ...)

Dobbiamo trovare la somma delle serie geometriche infinite del tipo:

  S = 1 + r + r^2 + r^3 + ...

dove r è un numero reale con -1 < r < 1. (Abbiamo bisogno di questi limiti su r in modo che la serie
converga).
Moltiplicando per r, otteniamo:

  S*r =  r +  r^2 + r^3 + r^4 + ...

Sottraendo la seconda equazione dalla prima si ottiene:

  S - S*r = 1   ==>   S*(1 - r) = 1

e quindi:

  S = 1/(1 - r),

Ponendo r = 1/5, completiamo il nostro calcolo della distanza percorsa dalla mosca:

6/5 * 1/(1 - 1/5) = 3/2 km = 1.5 km

In newLISP possiamo calcolare una serie infinita nel modo seguente:

(define (sum r n)
  (let (s 1)
    (for (i 1 n)
      (setq s (add s (pow r i)))
    )
    s))

Oppure:

(define (sum r n)
  (add 1 (apply add (map (fn(x) (pow r x)) (sequence 1 n)))))

Proviamo il calcolo con 20 termini:

(sum .2 20)
;-> 1.249999999999998

Adesso moltiplichiamo per la costante 6/5 ed otteniamo la soluzione:

(mul (div 6 5) (sum .2 20))
;-> 1.499999999999997

In newLISP otteniamo una soluzione approssimata (dipende da quanti termini della serie calcoliamo).

Il modo più veloce di risolvere il problema è rendersi conto che i treni si scontrano dopo 1 minuto (dato che partono a 2 km di distanza e viaggiano alla velocità di 1 km al minuto). Poiché la mosca viaggia alla velocità di 1.5 km al minuto, allora in questo tempo (1 minuto) percorre 1.5 km.

La storia racconta che von Neumann rispose correttamente al problema... calcolando a mente il valore della serie infinita. E solo dopo si rese conto che esisteva un modo più semplice di ottenere la soluzione.


---------------------
Gestione degli errori
---------------------

Vediamo la definizione delle funzioni per la gestione degli errori dal manuale di riferimento.

************************
>>>funzione ERROR-EVENT
************************
sintassi: (error-event sym-event-handler | func-event-handler)
sintassi: (error-event nil)

sym-event-handler contiene una funzione utente per la gestione degli errori (error handler) . Quando si verifica un errore, il sistema esegue la funzione "reset" ed esegue la funzione utente per la gestione degli errori. Questa funzione può utilizzare la funzione predefinita "last-error" per recuperare il numero e il testo dell'errore. La funzione per la gestione degli errori può essere specificata come simbolo quotato o come funzione lambda

Per disabilitare "error-event" utilizare la seconda sintassi.

(define (my-handler)
  (print "error # " (first (last-error)) " has occurred\n") )

(error-event 'my-handler)  → my-handler

;; specify a function directly

(error-event my-handler)  → $error-event

(error-event
  (fn () (print "error # " (first (last-error)) " has occurred\n")))

(error-event exit)  → $error-event

Vedi anche la funzione "catch" che fornisce un modo diverso per gestire gli errori. Utilizzare "throw-error" per gestire gli errori dell'utente.

***********************
>>>funzione LAST-ERROR
***********************
sintassi: (last-error)
sintassi: (last-error int-error)

Riporta l'ultimo errore generato da newLISP a causa di errori di sintassi o esaurimento di alcune risorse. Per un riepilogo di tutti i possibili errori, vedere il capitolo Codici di errore in appendice del manuale di riferimento.

Se non si è verificato alcun errore dall'avvio della sessione newLISP, viene restituito nil.
Quando viene specificato int-error, viene restituito una lista contenente numero e testo dell'errore.

(last-error)  → nil

(abc)

ERR: invalid function: (abc)

(last-error) → (24 "ERR: invalid function: (abc)")

(last-error 24) → (24 "invalid function")
(last-error 1) → (1 "not enough memory")
(last-error 12345) → (12345 "Unknown error")

Per i numeri di errore fuori intervallo, viene fornita la stringa "Unknown error" per il testo dell'errore.

Gli errori possono essere intercettati da "error-event" e gestori di errori definiti dall'utente.

Vedere anche "net-error" per gli errori generati dalle condizioni di rete e "sys-error" per gli errori generati dal sistema operativo.

(last-error 1000)
;-> (1000 "Unknown error")
(last-error 0)
;-> nil

Lista degli errori
------------------

(define (get-errors)
  (let (err '())
    (for (i 1 100)
      (if (!= (list i "Unknown error") (last-error i))
          (push (last-error i) err -1)))
    (for (i 0 (- (length err) 1) 2)
      (println (err i) { } (err (+ i 1))))
  ))

(get-errors)
(1 "not enough memory")                (39 "regular expression")
(2 "environment stack overflow")       (40 "end of text [/text] tag")
(3 "call or result stack overflow")    (41 "mismatch in number of arguments")
(4 "problem accessing file")           (42 "problem in format string")
(5 "illegal token or expression")      (43 "data type and format don't match")
(6 "missing parenthesis")              (44 "invalid parameter")
(7 "string token too long")            (45 "invalid parameter: 0.0")
(8 "missing argument")                 (46 "invalid parameter: NaN")
(9 "number or string expected")        (47 "invalid UTF8 string")
(10 "value expected")                  (48 "illegal parameter type")
(11 "string expected")                 (49 "symbol not in MAIN context")
(12 "symbol expected")                 (50 "symbol not in current context")
(13 "context expected")                (51 "target cannot be MAIN")
(14 "symbol or context expected")      (52 "invalid list index")
(15 "list expected")                   (53 "array index out of bounds")
(16 "list or array expected")          (54 "invalid string index")
(17 "list or symbol expected")         (55 "nesting level to deep")
(18 "list or string expected")         (56 "list reference changed")
(19 "list or number expected")         (57 "invalid syntax")
(20 "array expected")                  (58 "user error")
(21 "array, list or string expected")  (59 "user reset -")
(22 "lambda expected")                 (60 "received SIGINT -")
(23 "lambda-macro expected")           (61 "function is not reentrant")
(24 "invalid function")                (62 "not allowed on local symbol")
(25 "invalid lambda expression")       (63 "no reference found")
(26 "invalid macro expression")        (64 "list is empty")
(27 "invalid let parameter list")      (65 "I/O error")
(28 "problem saving file")             (66 "no working directory found")
(29 "division by zero")                (67 "invalid PID")
(30 "matrix expected")                 (68 "cannot open socket pair")
(31 "wrong dimensions")                (69 "cannot fork process")
(32 "matrix is singular")              (70 "no comm channel found")
(33 "invalid option")                  (71 "ffi preparation failed")
(34 "throw without catch")             (72 "invalid ffi type")
(35 "problem loading library")         (73 "ffi struct expected")
(36 "import function not found")       (74 "bigint type not applicable")
(37 "symbol is protected")             (75 "not a number or infinite")
(38 "number out of range")             (76 "cannot convert NULL to string")

Definiamo una funzione utente per la gestione degli errori:

(define (error-handler)
  (print "Verificato errore # " (first (last-error)) "\n"))

Attiviamo la gestione degli errori da parte della funzione utente:

(error-event 'error-handler)

Proviamo:

(/ 10 0)
;-> Verificato errore # 29
(a 1)
;-> Verificato errore # 24

Disabilitiamo la gestione degli errori da parte della funzione utente:
(error-event nil)
;-> nil

La gestione degli errori è tornata al sistema:

(/ 20 0)
;-> ERR: division by zero in function /

Vediamo cosa accade quando si verifica un errore durante l'esecuzione di una funzione:

(define (error-handler)
  (print "Verificato errore # " (first (last-error)) "\n")
  (println a)
  (error-event nil))

(define (test)
  ; abilita la gestione degli errori
  ; da parte di una funzione utente
  (error-event 'error-handler)
  (setq a 10)
  ; questa istruzione genera un errore ==> esegue "error-handler" e poi esce
  (/ 10 0)
  ; questa istruzione non viene eseguita
  (println a))

(test)
;-> Verificato errore # 29
10

Adesso vediamo la definizione della funzione "reset".

******************
>>>funzione RESET
******************
sintassi: (reset)

"reset" torna al livello di valutazione superiore, disattiva la modalità di trace e passa al contesto/spazio dei nomi MAIN. "reset" ripristina l'ambiente delle variabili di primo livello utilizzando le variabili dell'ambiente salvate nello stack. Inoltre genera un errore "user-reset no error" che può essere segnalato con gestori di errori definiti dall'utente. Dalla versione 10.5.5 "reset" interrompe anche l'elaborazione dei parametri della riga di comando.
reset percorre l'intero spazio delle celle, operazione che potrebbe richiedere alcuni secondi in un sistema molto carico.
"reset" avviene automaticamente dopo una condizione di errore.

Per finire vediamo come gestire gli errori con la funzione "catch":

(define (check-division x y)
    (catch (/ x y) 'check-zero)
    (if (not (integer? check-zero))
        (setq check-zero "Division by zero."))
     check-zero
)

(println (check-division 10 4))
;-> 2
(println (check-division 4 0))
;-> Division by zero
(println (check-division 20 5))
;-> 4
(println (check-division 11 0))
;-> Division by zero


-------------------
Effetto percentuali
-------------------

Oscillazione delle Azioni
-------------------------
La banca ci comunica che oggi il valore delle nostre azioni è aumentato del 10%. Comunque ieri era diminuito del 10%, quindi siamo in pareggio... o no?
Purtroppo siamo in perdita, infatti, supponendo che il valore originale fosse 1000 euro, abbiamo:

ieri: val = 1000 - 10% = 1000 - 100 = 900
oggi: val = 900 + 10% = 900 + 90 = 990

Anche viceversa (prima guadagno e poi perdita) saremmo in perdita (della stessa quantità):

ieri: val = 1000 + 10% = 1000 + 100 = 1100
oggi: val = 1100 - 10% = 1100 - 110 = 990

Quindi quanto dovrebbe valere la percentuale (di oggi) per recuperare la perdita di ieri?

Poniamo:

f = p/100

ad esempio: p = 20%   ==>   f = 20/100 = 0.2

val = x      ==>  x + p     = x + x*f              = x*(1 + f)
val = 1000   ==>  val + 20% = 1000 + 1000*(20/100) = 1000 + 1000*0.2

Il valore originale vale:         x

Il valore dopo la perdita vale:   x*(1 + f1)

Il valore dopo il guadagno vale: (x*(1 + f1)) * (1 + f2)

Quindi deve risultare:

x = (x*(1 + f1)) - (x*(1 + f1)) * (1 + f2)
x = x + f1*x - (x + x*f1)*(1 + f2)
x = x + f1*x - (x + x*f2 + x*f1 + x*f1*f2)
x = x + f1*x - x - x*f2 - x*f1 - x*f1*f2
x = - x*f2 - x*f1*f2
x + x*f2 + x*f1*f2 = 0
x + f2*(x + x*f1) = 0   ==>   f2 = -x/(x + x*f1)

Con la formula di f2 possiamo scrivere la funzione:

(define (perc2 x perc1) (div x (add x (mul x (div perc1 100)))))

(perc2 1000 -10)
;-> 1.111111111111111
(mul 900 (perc2 1000 -10))
;-> 1000
Cioè, se perdiamo il 10%, poi dobbiamo guadagnare l'11.1% per ritornare allo stesso valore (1000).

(perc2 1000 10)
;-> 0.9090909090909091
(mul 1100 (perc2 1000 10))
;-> 1000
Cioè, se guadagniamo il 10%, poi dobbiamo perdere il 9.09% per ritornare allo stesso valore (1000).

Inversione delle percentuali
----------------------------
Il 36% di 63 vale 22.68. Quanto vale il 63% di 36?

Scriviamo la funzione e calcoliamo:

(define (perc p val)
  (mul p (div val 100)))

(perc 36 63)
;-> 22.68
(perc 63 36)
;-> 22.68

Facciamo un'altra prova:

(perc 21 77)
;-> 16.17
(perc 77 21)
;-> 16.17

Quindi: x% di y = y% di x

Cioè, (x/100)*y = (y/100)*x

Per dimostrarlo basta riscrivere l'ultima equazione in questo modo:

 (x*y/100) = (x*y/100)

che è chiaramente vera.

Potere di acquisto
------------------
Supponiamo di avere uno stipendio di 1000 euro.
Prima domanda: il datore di lavoro ci aumenta lo stipendio del 30. Di quanto è aumentato il nostro potere di acquisto?
Seconda domanda: tutte le merci diminuiscono di prezzo del 30%. Di quanto è aumentato il nostro potere di acquisto?

Per risolvere i due problemi supponiamo di investire tutto il nostro stipendio in oro che costa 20 euro al grammo.

Nel primo caso:
Con 1000 euro possiamo acquistare 1000/20 = 50 grammi di oro.
Con l'aumento abbiamo 1000 euro + 30% = 1300 euro e quindi possiamo acquistare 1300/20 = 65 grammi di oro.
Quindi il potere di acquisto è aumentato di 100*(65 - 50)/50 = 30%.

Nel secondo caso:
Come prima, con 1000 euro possiamo acquistare 1000/20 = 50 grammi di oro.
Con la diminuzione dei prezzi del 30% l'oro vale 20 - 30% = 20 - 6 = 14 euro, di conseguenza con 1000 euro possiamo comprare 1000/14 = 71.4286 grammi di oro.
Quindi il potere di acquisto è aumentato di 100*(71.4286 - 50)/50 = 42.8572%.

Dal nostro punto di vista, a parità di percentuale, è più conveniente che i prezzi diminuiscano.

Attenzione alle percentuali!

Nota: 0.12 è il 3% di 4 e .56 è il 7% di 8.


----------------------------------------------
Teorema di Euclide (infinità dei numeri primi)
----------------------------------------------

Teorema: Esistono infiniti numeri primi.
In altre parole, per quanto grande si scelga un numero naturale n, esiste sempre un numero primo maggiore di n.

Dimostrazione per assurdo
Si supponga che i numeri primi non siano infiniti, ma solo P=(p1,p2,... ,pn). pn sarebbe allora il più grande dei numeri primi.
Poniamo M = p1*p2*...*pn (prodotto degli n numeri primi).
Consideriamo il valore (M + 1) = (p1*p2*...*pn) + 1: è un numero primo o è un numero composto?

Per completare il ragionamento abbiamo bisogno del Teorema Fondamentale dell’Aritmetica:
un numero o è primo o è ottenuto univocamente dal prodotto di numeri primi (composto).

Inoltre possiamo notare che per ogni numero primo pi risulta che la divisione (M + 1)/pi ha sempre resto 1.

Adesso abbiamo due possibilità:
1) il numero (M + 1) è primo
Abbiamo però che (M + 1) > pn, ma ciò contraddice la nostra ipotesi che pn sia il massimo dei numeri primi. Ne consegue che, se (M + 1) è primo, allora pn non è il massimo dei numeri primi.

2) il numero (M + 1) è composto
Se (M + 1) è un numero composto, deve essere per forza divisibile per un divisore. Ma abbiamo visto che, per costruzione, (M + 1) non può essere diviso né da p1, né da p2, né da pn, perché la divisione di un numero così costruito per questi fattori da sempre resto 1.
Se (M + 1) è composto, allora deve esistere un altro numero primo pm che deve essere forzatamente maggiore di pm perché diverso da tutti gli altri primi (questo è dovuto al teorema fondamentale dell'aritmetica).
Ma se pm > pn allora vuol dire che pn non è il massimo dei numeri primi.

In entrambi i casi abbiamo una contraddizione e si può affermare che:
supponendo che i numeri primi siano finiti si ottiene sempre una contraddizione e di conseguenza i numeri primi devono essere necessariamente infiniti.


----------------------
Il programma più corto
----------------------

In newLISP il programma più corto che può essere eseguito nella REPL è il seguente:

;

Il carattere che rappresenta l'inizio di un commento.


------------------------
Frequenza cifre pi greco
------------------------

pi greco = (acos -1) = 3.141592653589793...

Pi greco è un numero con cifre casuali. Per verificare questa affermazione prendiamo n cifre del numero pi greco e calcoliamo la loro frequenza. I file di testo con milioni di cifre per pi greco sono disponibili al seguente indirizzo:

https://archive.org/details/Math_Constants

Per spezzare un file possiamo usare la seguente funzione:

(define (file-copy from-file to-file from-char to-char)
    (setq i 1)
    (set 'in-file (open from-file "read"))
    (set 'out-file (open to-file "write"))
    (while (and (set 'chr (read-char in-file)) (<= i to-char))
        (if (>= i from-char) (write-char out-file chr))
        (++ i))
    (close in-file)
    (close out-file)
    "finished")

Partendo da un file con 1 miliardo (1000 milioni) di cifre:

file con 1 milione di cifre (senza 3.):
(file-copy "pi_dec_1000m.txt" "pi_dec_1m.txt" 3 1000002)
;-> "finished"
file con 10 milioni di cifre (senza 3.):
(file-copy "pi_dec_1000m.txt" "pi_dec_10m.txt" 3 10000002)
;-> "finished"
file con 100 milioni di cifre (senza 3.):
(file-copy "pi_dec_1000m.txt" "pi_dec_100m.txt" 3 100000002)
;-> "finished"

Adesso scriviamo la funzione che calcola la frequenza delle cifre per un file:

(define (freq-file file)
  (local (data chr freq)
    (setq freq (array 10 '(0)))
    (setq data (open file "read"))
    (while (setq num (eval-string (char (read-char data))))
        (if (number? num) (++ (freq num)))
    )
    (close data)
    freq
  ))

Vediamo cosa succede:

(freq-file "pi_dec_1m.txt")
;-> (99959 99758 100026 100229 100230 100359 99548 99800 99985 100106)
(freq-file "pi_dec_10m.txt")
;-> (999440 999333 1000306 999964 1001093 1000466 999337 1000207 999814 1000040)
(freq-file "pi_dec_100m.txt")
;-> (9999922 10002475 10001092 9998442 10003863 9993478 9999417 9999610 10002180 9999521)

Sembra proprio che le cifre di pi greco siano casuali...

Provate a trovare una data nelle cifre di pi greco con la seguente funzione:

(define (pi-birthday num-date)
  (setq file (open "pi_dec_100m.txt" "r"))
  (setq idx (search file (string num-date)))
  (close file)
  idx)

Cerchiamo la data 21 settembre 1980:
(pi-birthday 19800921)
;-> 9165287

Cerchiamo il giorno dello sbarco sulla luna 21 luglio 1969:
(pi-birthday 19690721)
;-> 2035915


-------------------------
Conversione a big-integer
-------------------------

Per definire un numero big-integer occorre aggiungere il carattere "L" al numero:

(+ 10L 20L)
;-> 30L

Per convertire un numero intero in big-integer possiamo usare la funzione integrata "bigint":

(bigint 10)
;-> 10L

Oppure utilizzare la conversione implicita (il tipo del risultato dipende dal primo operando):

(+ 0L 10)
;-> 10L

(+ 0 10L)
;-> 10

(++ 9L)
;-> 10L

Se passiamo un numero superiore a int64 viene convertito in big-integer (anche se non specifichiamo la lettera finale "L":

(+ 12378461278940612789346127804678120463871246234612784612545 1)
;-> 12378461278940612789346127804678120463871246234612784612546L

(+ 12378461278940612789346127804678120463871246234612784612545L 1)
;-> 12378461278940612789346127804678120463871246234612784612546L

Ma non vale se il primo operando è un int64 (e il secondo è un big-integer):

(+ 1 12378461278940612789346127804678120463871246234612784612545)
;-> ERR: number out of range in function +

(+ 1 12378461278940612789346127804678120463871246234612784612545L)
;-> ERR: number out of range in function +

La funzione "gcd" supporta con i big-integer:

(gcd 12378461278940612789346127804678120463871246234612784612545L
     66432828761348769123496764312340293782893478962349320991193L)
;-> 3L

(gcd 12378461278940612789346127804678120463871246234612784612545
     66432828761348769123496764312340293782893478962349320991193)
;-> 3L

(gcd 134 321)
;-> 1

(gcd 134L 321L)
;-> 1L

Anche in questo caso se il primo operando è un int64 (e il secondo un big-integer) otteniamo un errore:

(gcd 134 66432828761348769123496764312340293782893478962349320991193)
;-> ERR: number out of range in function gcd


----------------------------------------------------------------
Congettura 8424432925592889329288197322308900672459420460792433L
----------------------------------------------------------------

Si congettura che i due numeri prodotti dalle equazioni n^17 + 9 e (n+1)^17 + 9 per un dato n siano sempre coprimi (cioè, il loro massimo comune divisore è 1).

Funzione che calcola la potenza intera di due numeri interi (biginteger):

(define (** x p)
  (let (y 1L)
    (dotimes (i p)
      (setq y (* y x)))))

Funzione che calcola i due numeri e il loro Massimo Comun Divisore (gcd):

(define (f n)
  (local (a b)
    (setq a (+ (** n 17) 9))
    (setq b (+ (** (+ n 1) 17) 9))
    ;(println a { - } b)
    (gcd a b)))

(define (test n)
  (for (i 1 n)
    (if (!= (f i) 1) (println i))))

(test 100)
;-> nil

(time (test 1000000))
;-> 35222.204

Proviamo ad usare un'altra versione della funzione che calcola la potenza di due numeri interi:

(define (ipow x n)
  (local (pot out)
    (if (zero? n)
        (setq out 1L)
        (begin
          (setq pot (ipow x (/ n 2)))
          (if (odd? n) (setq out (* x pot pot))
                       (setq out (* pot pot)))
        )
    )
    out))

(ipow (bigint 12) (bigint 101))
;-> 9938156942641746031009010831488421976193473742246733225
;-> 570422369239059031961454676453243399562296232626880512L

(define (g n)
  (local (a b)
    ;(bigint n)
    (setq a (+ (ipow (bigint n) 17L) 9L))
    (setq b (+ (ipow (+ 1L n) 17L) 9L))
    ;(setq a (+ (ipow n 17L) 9L))
    ;(setq b (+ (ipow (+ 1L n) 17L) 9L))
    ;(println a { - } b)
    (gcd a b)))

(g 25)
;-> 1L

(define (test1 n)
  (for (i 1 n)
    (if (!= (g i) 1) (println i))))

(test1 100)
;-> nil

(time (test1 1000000))
;-> 37550.083

Fino a n=1000000 i due numeri sono coprimi, ma, indipendentemente da quanto ottimizziamo le funzioni, non possiamo mai arrivare a calcolare se la congettura sia corretta o meno. Infatti il primo controesempio si ha per:

n = 8424432925592889329288197322308900672459420460792433

(f 8424432925592889329288197322308900672459420460792433L)
;-> 8936582237915716659950962253358945635793453256935559L
(g 8424432925592889329288197322308900672459420460792433L)
;-> 8936582237915716659950962253358945635793453256935559L

a = 54223994342646179058380356618237600945332452744447783811633226444
706840145560253543265726036832145128177789432208521052474357871396552
883725682145297321498918218354478800485735694975861256807297728953769
893103929230098025052894514403466394770904990028864878976324044044821
592051416751962701035874218121600183036261502732591815729434037884804
160927983508505810505709192305952680056837370387376148379793216718560
488169006176612685719519514795214718954001125189050831787603289426211
911180030081853896340397250694989280033195161440928768764775227010883
495154027281535795894248762159201471694414123617755674247339993539066
734119817112437829533591829524422255729623239462090029154069350527783
184704923865907347725268780279846639423625020376803594419176767107084
931496192777949752067359482586926753862402083283934355276863776930054
10063448224075882352899690251043898231682422328806149679482L

b = 54223994342646179058380356618237600945332452744447893232399225375
209266712078431719483738073648487224059383831697999678327408100141336
991025881588579477964498533991409989912763419887691604377050455544019
054574804855529430469982522730989408672965187161333391643781413916588
545511024186259721689804571708801881316258497013141186296413148273718
400779029194737615474809188738518912788375420535118546429527937700302
149462398156084100850976785997309801553853766736897061232608205624871
298724159587383286059335663902625524582680124910168097058456424147988
880721305500824538567368687499354308989937809076241065086298676278672
263416684098360012514500425402719785361771648158147911462496374525910
033905217420022640052099451351878592869628864404070519454212140328594
703336995154486215002765901658624392447143569841733943999245865859272
00563811508612111669423809712025508253890314787725191020553L

Vediamo la velocità della funzione quando usiamo i big-integer:

(define (testbig start end)
  (for (i start end)
    (if (!= (f i) 1) (println i))))

(testbig 8424432925592889329288197322308900672459420460792430L 8424432925592889329288197322308900672459420460792433L)
;-> ERR: number out of range in function for
;-> called from user function (testbig ...

La funzione "for" non supporta i big-integer come indice, allora usiamo la funzione "while":

(define (testbig start end)
  (while (< start end)
    (if (!= (f start) 1) (println start))
    (++ start)))

(testbig 8424432925592889329288197322308900672459420460792430L 8424432925592889329288197322308900672459420460792433L)
;-> 8424432925592889329288197322308900672459420460792433L

Vediamo quanto tempo occorre per calcolare 100000 di valori con i numeri big-integer:

(- 8424432925592889329288197322308900672459420460792433L 100000L)
;-> 8424432925592889329288197322308900672459420460692433L

(time (testbig 8424432925592889329288197322308900672459420460692433L 8424432925592889329288197322308900672459420460792433L))
;-> 37737.671

Quanto tempo ci vuole per arrivare a questo numero partendo da 1?

(* 37737L (/ 8424432925592889329288197322308900672459420460792433L 100000L))
;-> 3179128253130988646193487023519709846766011499254359L ;millisecondi

Trasformiamo i millisecondi in anni:

(define (ms2time ms)
  (letn ((mins (/ ms 1000 60))
        (secs (% (/ ms 1000) 60))
       ;(println (format "%d millisec = %d minuti e %d secondi." ms mins secs))
       ;(println mins secs))
        (hours (/ mins 60))
        (days (/ hours 24))
        (years (/ days 365)))
        years))

(ms2time 3179128253130988646193487023519709846766011499254359L)
;-> 100809495596492536979752886336875629336821L ;anni!!!

Ci vogliono 1.008094955964925e+041 anni.

L'età dell'universo è 13.8 miliardi di anni (1.38e+010)...

In realtà non hanno calcolato il numero, ma hanno costruito il problema in modo che la soluzione fosse quella desiderata. Nella teoria dei numeri, ci sono vari teoremi che definiscono come si relazioneranno due numeri e, se vengono usati in modo opportuno, è possibile creare problemi come questo.

Un altro esempio è il seguente:

(n^19 + 6) e (n+1)^16 + 9

n = 1578270389554680057141787800241971645032008710129107338825798

(define (f n)
  (local (a b)
    (setq a (+ (** n 19) 6))
    (setq b (+ (** (+ n 1) 19) 6))
    ;(println a { - } b)
    (gcd a b)))

(define (test n)
  (for (i 1 n)
    (if (!= (f i) 1) (println i))))

(test 100)
;-> nil

(time (test 1000000))
;-> 43908.677

(f 1578270389554680057141787800241971645032008710129107338825798L)
;-> 5299875888670549565548724808121659894902032916925752559262837L


-------------------
floor, ceil e fract
-------------------

Definizioni:

(floor x) = max (m ≤ x) dove m è intero
(ceil x) = min (n ≥ x) dove n è intero
(fract x) = x - (floor x)

Quindi risulta:

(x - 1) < m ≤ x ≤ n < (x + 1)

(x mod y) = x - y*(floor x/y)

|  x   | Floor | Ceiling | Fractional |
+------+-------+---------+------------+
|  2   |   2   |   2     |   0        |
|  2.4 |   2   |   3     |   0.4      |
|  2.9 |   2   |   3     |   0.9      |
| −2.7 |  −3   |  −2     |   0.3      |
| −2   |  −2   |  −2     |   0        |

La notazione matematica è la seguente:

(floor x) con trattino basso "˩"
(ceil x) con trattino basso "˥"
(fract x) con parentesi graffe "{}"

Vediamo alcuni esempi:
(ceil -10.3)
;-> -10
(ceil 10.3)
;-> 11
(ceil -10.6)
;-> -10
(ceil 10.6)
;-> 11
(floor -10.3)
;-> -11
(floor 10.3)
;-> 10
(floor -10.6)
;-> -11
(floor 10.6)
;-> 10


----------------
Multipli di nove
----------------

Un fatto noto nella teoria dei numeri è che se prendiamo un intero positivo e sottraiamo la somma delle sue cifre da quel numero, otteniamo un multiplo di 9.

(define (mul9 n)
  (- n (apply + (map int (explode (string n))))))

(mul9 12375621)
;-> 12375594

(% 12375594 9)
;-> 0

Verifichiamo il teorema:

(define (test num)
  (if (!= 0 (% (mul9 num) 9)) (println num)))

(test 100000)
;-> nil


---------------
fizzbuzz esteso
---------------

Problema:
Stampare i numeri da 1 a 100, tranne nei seguenti casi
1) se il numero è divisibile per 3, allora scrivi "fizz"
2) se il numero è divisibile per 5, scrivi invece "buzz"
3) se il numero è divisibile per 15, scrivi invece "fizzbuzz".

Questo problema, nato come un gioco per bambini, è diventato un test di base per la valutazione dei programmatori di computer.

Versione 1 (naif)
-----------------

(setq fb
'(1  2 fizz  4 buzz fizz  7  8 fizz buzz 11 fizz 13 14 fizzbuzz
 16 17 fizz 19 buzz fizz 22 23 fizz buzz 26 fizz 28 29 fizzbuzz
 31 32 fizz 34 buzz fizz 37 38 fizz buzz 41 fizz 43 44 fizzbuzz
 46 47 fizz 49 buzz fizz 52 53 fizz buzz 56 fizz 58 59 fizzbuzz
 61 62 fizz 64 buzz fizz 67 68 fizz buzz 71 fizz 73 74 fizzbuzz
 76 77 fizz 79 buzz fizz 82 83 fizz buzz 86 fizz 88 89 fizzbuzz
 91 92 fizz 94 buzz fizz 97 98 fizz buzz))

(define (fizzbuzz1)
  (dolist (num fb) (print num { })))

(fizzbuzz1)

Versione 2 (base)
-----------------

(define (fizzbuzz2)
  (for (num 1 100)
    (cond ((zero? (% num 15)) (print "fizzbuzz "))
          ((zero? (% num 5))  (print "buzz "))
          ((zero? (% num 3))  (print "fizz "))
          (true (print num { })))))

(fizzbuzz2)

Versione 3 (ciclica)
--------------------

(setq ciclo15 '(fizzbuzz 0 0 fizz 0 buzz fizz 0 0 fizz buzz 0 fizz 0 0))

(define (fizzbuzz3)
  (for (num 1 100)
    (if (zero? (ciclo15 (% num 15)))
        (print num { })
        (print (ciclo15 (% num 15)) { }))))

(fizzbuzz3)

Versione 4 (euclide)
--------------------

(define (fizzbuzz4)
  (local (alto basso)
    (for (num 1 100)
      (setq alto (max num 15))
      (setq basso (min num 15))
      (while (> (% alto basso) 0)
        (map set '(alto basso) (list (+ basso) (% alto basso))))
      ;(println basso)
      (cond ((= basso 15) (print "fizzbuzz "))
            ((= basso 5) (print "buzz "))
            ((= basso 3) (print "fizz "))
            ((= basso 1) (print num { }))
            (true (print "ERRORE "))
            ))))

(fizzbuzz4)

Versione 5 (trigonometria)
--------------------------

(define (fizzbuzz5)
  (local (f b)
    (for (num 1 100)
      (setq f (cos (div (mul num 2 PI) 3)))
      (setq b (cos (div (mul num 2 PI) 5)))
      (cond ((and (= f 1) (= b 1)) (print "fizzbuzz "))
            ((= b 1) (print "buzz "))
            ((= f 1) (print "fizz "))
            (true (print num { }))))))

(fizzbuzz5)

Versione 6 (moltiplicazione matrici)
------------------------------------

(define (fizzbuzz6)
  (local (a b ab val)
    (setq a '((1 0 0) (2 -2 0) (2 0 -2) (3 -3 -3)))
    (for (num 1 100)
      (setq b (list (list 1 (% num 3) (% num 5))))
      (setq ab (multiply a (transpose b)))
      (setq val (ref (apply max (flat ab)) (flat ab)))
      (cond ((= val '(3)) (print "fizzbuzz "))
            ((= val '(2)) (print "buzz "))
            ((= val '(1)) (print "fizz "))
            ((= val '(0)) (print num { }))
            (true (print "ERRORE "))))))

(fizzbuzz6)

Versione 7 (stringhe)
---------------------

(define (fizzbuzz7)
  (local (vec)
    (setq vec (array 101 '("")))
    (for (num 1 100)
      (if (zero? (% num 3)) (setf (vec num) (append (vec num) "fizz")))
      (if (zero? (% num 5)) (setf (vec num) (append (vec num) "buzz")))
      (if (and (!= (% num 3) 0) (!= (% num 5) 0) (setf (vec num) (string num))))
    )
    (for (i 1 100) (print (vec i) { }))))

(fizzbuzz7)

Tutte le versioni stampano il seguente risultato:
;-> 1 2 fizz 4 buzz fizz 7 8 fizz buzz 11 fizz 13 14 fizzbuzz
;-> 16 17 fizz 19 buzz fizz 22 23 fizz buzz 26 fizz 28 29 fizzbuzz
;-> 31 32 fizz 34 buzz fizz 37 38 fizz buzz 41 fizz 43 44 fizzbuzz
;-> 46 47 fizz 49 buzz fizz 52 53 fizz buzz 56 fizz 58 59 fizzbuzz
;-> 61 62 fizz 64 buzz fizz 67 68 fizz buzz 71 fizz 73 74 fizzbuzz
;-> 76 77 fizz 79 buzz fizz 82 83 fizz buzz 86 fizz 88 89 fizzbuzz
;-> 91 92 fizz 94 buzz fizz 97 98 fizz buzz


----------------------------------------------------
Conversione tra liste, stringhe, caratteri e simboli
----------------------------------------------------

Definiamo due funzioni che convertono una stringa in una lista di caratteri e viceversa.

Stringa --> lista di caratteri
------------------------------
(define (str-chars str) (explode str))

(str-chars "explode")
;-> ("e" "x" "p" "l" "o" "d" "e")
(str-chars "0123")
;-> ("0" "1" "2" "3")

Lista di caratteri --> stringa
------------------------------
(define (chars-str lst) (join lst))

(chars-str '("j" "o" "i" "n"))
;-> "join"
(chars-str '("0" "1" "2" "3"))
;-> "0123"

(str-chars (chars-str '("e" "x" "p" "l" "o" "d" "e")))
;-> ("e" "x" "p" "l" "o" "d" "e")
(chars-str (str-chars "explode"))
;-> "explode"

Adesso definiamo due funzioni che convertono una lista di simboli in una stringa.

Lista di simboli --> stringa
----------------------------
(define (lst-str lst merge)
  (if merge
      (join (map string lst))
      (join (map string lst) " ")))

Il parametro "merge" permette di riunire tutti gli elementi della lista in una stringa unica.

(lst-str '(a f 3 t h u))
;-> "a f 3 t h u"
(lst-str '(a f 3 t h u) true)
;-> "af3thu"
(lst-str '(af3thu))
;-> "af3thu"
(lst-str '(af3thu) true)
;-> "af3thu"

Stringa -> lista di simboli
(define (str-lst str merge)
  (if (or merge (find " " str))
      (map sym (parse str))
      (map sym (explode str))))

Il parametro "merge" permette di creare una lista con un unico simbolo (tutta la stringa).

(str-lst "af3thu")
;-> (a f 3 t h u)
(str-lst "af3thu" true)
;-> (af3thu)
(str-lst "a f 3 t h u"))
;-> (a f 3 t h u)
(str-lst "a f 3 t h u" true)
;-> (a f 3 t h u)

Nota: La funzione "sym" crea un simbolo anche per il carattere spazio " ".
Utilizzare il carattere " " come simbolo nei programmi è una delle strade per diventare matti.

(setq lista (map sym (explode "a b c")))
;-> (a   b   c)
(length lista)
;-> 5
(string (lista 1) (lista 2))
;-> " b"


---------------------
Divisori di un numero
---------------------

Abbiamo visto diverse funzioni che calcolano i divisori di un numero, la somma dei divisori o il numero dei divisori. Riportiamo le funzioni che consideriamo più veloci e i relativi algoritmi. Da notare che gli algoritmi usati non sono quelli migliori/ottimali, ma quelli che risultano più veloci all'interno di newLISP. In questo caso sfruttiamo il fatto che la funzione "factor" è integrata in newLISP, quindi è molto veloce.

Scomposizione in fattori primi di un numero:

num = p(1)^a(1) * p(2)^a(2) * ... * p(k)^a(k)

p(i) = numero primo
a(i) = esponente

numero dei divisori = (a(1) + 1) * (a(2) + 1) * ... * (a(k) + 1)

somma dei divisori = (1 + p(1) + p(1)^2 + ... + p(1)^a(1)) *
                     (1 + p(2) + p(2)^2 + ... + p(2)^a(2)) * ... *
                     (1 + p(k) + p(k)^2 + ... + p(k)^a(k))

I divisori possono essere generati ricorsivamente utilizzando tutti i primi p(i) e le loro occorrenze a(i). Ogni fattore primo p(i), può essere incluso x volte dove 0 ≤ x ≤ a(i).

Lista dei divisori
------------------

(define (divisors-aux cur-index cur-divisor)
  (cond ((= cur-index (length f))
         (push cur-divisor out -1)
        )
        (true
         (for (i 0 (f cur-index 1))
           (divisors-aux (+ cur-index 1) cur-divisor)
           (setq cur-divisor (* cur-divisor (f cur-index 0)))
         ))))

(define (divisors num)
  (local (f out)
    (cond ((= num 1) '(1))
          (true
           (setq f (factor-group num))
           (setq out '())
           (divisors-aux 0 1)
           (sort out)))))

(divisors 1)
;-> (1)
(divisors 360)
;-> (1 2 3 4 5 6 8 9 10 12 15 18 20 24 30 36 40 45 60 72 90 120 180 360)
(divisors 123456789)
;-> (1 3 9 3607 3803 10821 11409 32463 34227 13717421 41152263 123456789)

Numero di divisori
------------------

(define (divisors-count num)
  (if (= num 1) '1
      (begin
        (setq lst (factor-group num))
        (apply * (map (fn(x) (+ 1 (last x))) lst)))))

(divisors-count 1)
;-> 1
(divisors-count 360)
;-> 24
(divisors-count 123456789)
;-> 12

Somma dei divisori
------------------

(define (divisors-sum num)
  (local (sum out)
    (if (= num 1) '1
        (begin
          (setq out 1)
          (setq lst (factor-group num))
          (dolist (el lst)
            (setq sum 0)
            (for (i 0 (last el))
              (setq sum (+ sum (pow (first el) i)))
            )
            (setq out (* out sum)))))))

(divisors-sum 1)
;-> 1
(divisors-sum 360)
;-> 1170
(divisors-sum 123456789)
;-> 178422816


-------------------
Sequenza di Collatz
-------------------

Vediamo alcune funzioni per giocare con la sequenza di collatz:

Funzionale:

(define (collatzf n)
  (if (= n 1) '(1)
    (cons n (collatzf (if (even? n) (/ n 2) (+ 1 (* 3 n)))))))

(collatzf 50)
;-> (50 25 76 38 19 58 29 88 44 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1)

(time (collatzf 123456789) 1000)
;-> 106.748

(define (collatzf-length n)
  (if (= n 1) 1
    (+ 1 (collatzf-length (if (even? n) (/ n 2) (+ 1 (* 3 n)))))))

(collatzf-length 123456789)
;-> 178

(time (collatzf-length 123456789) 10000)
;-> 317.179

Iterativo:

(define (collatzi n)
  (let (out (list n))
    (while (!= n 1)
      (if (even? n)
          (setq n (/ n 2))
          (setq n (+ (* 3 n) 1))
      )
      (push n out -1)
    )
    out))

(collatzi 50)
;-> (50 25 76 38 19 58 29 88 44 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1)

(time (collatzi 123456789) 1000)
;-> 23.965

(define (collatzi-length n)
  (let (c 1)
    (while (!= n 1)
      (if (even? n)
          (setq n (/ n 2))
          (setq n (+ (* 3 n) 1))
      )
      (++ c)
    )
    c))

(collatzi-length 123456789)
;-> 178

(time (collatzi-length 123456789) 10000)
;-> 207.01

Le funzioni iterative sono più veloci di quelle funzionali.

Test di correttezza:

(for (i 1 10000) (if (!= (collatzf i) (collatzi i)) (println i)))
;-> nil
(for (i 1 10000) (if (!= (collatzf-length i) (collatzi-length i)) (println i)))
;-> nil


----------
Generatore
----------

Vediamo come possiamo creare un generatore di elementi di una lista. Quando gli elementi sono finiti il generatore produce nil.

(context 'list-gen)

(define (list-gen:init lst)
  (let (n (length lst))
    (setq
          list-gen:items (array n lst)
          list-gen:i 0
          list-gen:end n)))

(define (list-gen:next)
  (if (= list-gen:i list-gen:end)
      nil
      (begin (++ list-gen:i) (list-gen:items (- list-gen:i 1)))))

(context MAIN)
(list-gen:init (sequence 10 12))
;-> 3 ; numero di elementi della lista
(list-gen:next)
;-> 10
(list-gen:next)
;-> 11
(list-gen:next)
;-> 12
(list-gen:next)
;-> nil

Il numero di elementi della lista ci dice quante volte possiamo chiamare la funzione "list-gen:next" prima di ottenere nil.


------------------------
Multiplo con tutti 1 e 0
------------------------

Un teorema afferma che per ogni numero intero positivo N, esiste un multiplo di N che consiste solo di cifre 1 e 0.
Scrivere una funzione che dato un numero N calcola il multiplo di N che contiene solo cifre 1 e 0.

La soluzione più semplice è quella di moltiplicare ripetutamente il numero e verificare se il valore è costituito solo da 1 e 0.

Scriviamo una funzione che verifica se un numero è costituito solo da 1 e 0:

(define (check-num num)
  (let (out true)
    (while (and (!= num 0) out)
      (if (> (% num 10) 1) (setq out nil))
      (setq num (/ num 10))) out))

(check-num 123)
;-> nil
(check-num 1010)
;-> true
(check-num 10101011L)
;-> true

Adesso scriviamo la funzione che calcola il numero costituito solo da 1 e 0:

(define (uno-zero num iter)
  (catch
    (let (a (bigint num))
    (for (i 1 iter)
      (if (check-num (* a i)) (throw (list a i (* a i))))))))

(uno-zero 3 100)
;-> (3L 37 111L)
(uno-zero 12 1000)
;-> (12L 925 11100L)
(uno-zero 21 1000)
;-> (21L 481 10101L)
(uno-zero 12345 1000000)
;-> (12345L 891058 11000111010L)
(uno-zero 123456 10000000)
;-> nil

Come si nota, dobbiamo specificare il numero di moltiplicazioni (iterazioni) e quindi non sempre otteniamo un risultato. Inoltre dobbiamo utilizzare i big-integer. Proviamo con un ciclo infinito:

(define (uno-zero num)
  (catch
    (let ((a (bigint num)) (i 1))
    (while true
      (if (check-num (* a i)) (throw (list a i (* a i))))
      (++ i)))))

(uno-zero 3)
;-> (3L 37 111L)
(uno-zero 12)
;-> (12L 925 11100L)
(uno-zero 21)
;-> (21L 481 10101L)
(uno-zero 12345)
;-> (12345L 891058 11000111010L)

Putroppo (uno-zero 123456) non finisce in un tempo ragionevole...

Per trovare un'altro metodo facciamo il seguente ragionamento:
Consideriamo gli (N + 1) numeri interi 1, 11, 111, ... , 111...1, (N+1 1).
Quando vengono divisi per N, lasciano (N + 1) resti. Secondo il principio dei cassetti o della piccionaia (pigeonhole principle), due di questi resti sono uguali, quindi la differenza tra i due interi corrispondenti è un intero costituito solo da cifre 1 e 0 che è divisibile per N. Per inciso, questa è anche una dimostrazione del teorema.

Esempio 1:
N = 3
; lista di 3+1 numeri con tutti 1
(setq one '(1 11 111 1111))
; calcolo dei resti
(map (fn(x) (% x 3)) one)
;-> (1 2 0 1)
Abbiamo due resti uguale a 1, che corrispondono ai numeri 1 e 1111.
Calcoliamo la differenza tra questi due numeri:
(- 1111 1)
;-> 1110
Abbiamo ottenuto un numero "1110" composto solo da 1 e 0.
Dividiamo il numero per verificare la correttezza:
(div 1110 3)
;-> 370
Quindi il numero 3 moltiplicato per 370 genera il numero 1110 che è costituito solo da 1 e 0.

Esempio 2:
N=12
(setq one '(1 11 111 1111 11111 111111 1111111 11111111 111111111 1111111111 11111111111 111111111111 1111111111111))
(map (fn(x) (% x 12)) one)
;-> (1 11 3 7 11 3 7 11 3 7 11 3 7)
Prendiamo i due numeri che hanno resto 11 (il secondo e il quinto):
(- 11111 11)
;-> 11100
(div 11100 12)
;-> 925
Quindi il numero 12 moltiplicato per 925 genera il numero 111100 che è costituito solo da 1 e 0.

Quindi il nostro algoritmo sarà il seguente:

0. creare una hash-map (che conterrà elementi con chiave uguale al resto e valore uguale al relativo numero con tutti 1).
1. generare il prossimo numero con tutti 1 (numero one)
2. calcolare il resto della divisione tra il numero one e il numero dato
3. se il resto non esiste nella hash-map,
      allora inserirlo nella hash-map (resto one) e andare al passo 1
      altrimenti recuperare il numero nella hash-map che ha la chiave uguale a resto e sottrarlo al numero one attuale.
      Fine.

Scriviamo la funzione in forma estesa:

(define (uz num)
  (let ((out 0L) (val 1L) (dv 0) (primo 0) (secondo 0))
    (new Tree 'myHash)
    (myHash "1L" 1L)
    (for (i 1 num 1 (!= out 0))
      ;calcola il prossimo numero con tutti 1 (11, 111, 1111, ...)
      (setq val (+ (pow-i 10L i) val))
      ; calcola il resto della divisione tra il numero con tutti 1 e il numero dato
      (setq dv (% val num))
      ;(println "val: " val { } "dv: " dv)
      (cond ((= dv 0) (setq out val))
            (true
              ; se la chiave non esiste nella hashmap...
              (if (null? (myHash (string dv)))
                  (begin
                    ; allora inserisce la chiave (dv) con il valore (val)
                    ;(println "insert: " dv { } val)
                    (myHash (string dv) val)
                  )
                  ; altrimenti calcoliamo il risultato
                  (begin
                    ;(println "calcolo...")
                    ; prendo il primo valore con lo stesso resto dala hash map
                    (setq primo (myHash (string dv)))
                    ; prendo il secondo valore con lo stesso resto (ultimo valore)
                    (setq secondo val)
                    ;(println "primo: " primo { } "secondo: " secondo)
                    ; calcolo la differenza
                    (setq out (- secondo primo))
                    ;(println "out: " out)
                  )
              )
              ;(read-line)
            )
      )
    )
    ; elimina la hashmap
    (delete 'myHash)
    (list out (/ out num))))

(uz 3)
;-> (111L 37L)
(* 37 3)
;-> 111
(uz 12)
;-> (11100L 925L)
(uz 10)
;-> (10L 1L)
(uz 21)
;-> (111111L 5291L)
(uz 1234)
;-> (11111111111111111111111111111111111111111111111111111111111111111111111111111111111111110L
;->  9004141905276427156491986313704303979830722132180803169457950657302359085179182423915L)
(div 11111111111111111111111111111111111111111111111111111111111111111111111111111111111111110L
     9004141905276427156491986313704303979830722132180803169457950657302359085179182423915L)
;-> 1234

Le funzioni (uno-zero e uz) producono due risultati differenti, ma entrambi sono corretti (cioè sono multipli di N e contengono solo cifre 1 e 0). La seconda funzione produce numeri più grandi.

La funzione (uz 12345) produce un numero molto lungo:

(length (last (uz 12345)))
;-> 818

Riscriviamo la funzione in maniera più compatta:

(define (uz num)
  (let ((out 0L) (val 1L) (dv 0L))
    (new Tree 'myHash)
    (myHash "1L" 1L)
    (for (i 1 num 1 (!= out 0))
      ; calcola il prossimo numero con tutti 1 (11, 111, 1111, ...)
      (setq val (+ (pow-i 10L i) val))
      ; calcola il resto della divisione tra il numero con tutti 1 e il numero dato
      (setq dv (% val num))
      (cond ((= dv 0) (setq out val))
            (true
              ; se la chiave non esiste nella hashmap...
              (if (null? (myHash (string dv)))
                  ; allora inserisce la chiave (dv) con il valore (val)
                  (myHash (string dv) val)
                  ; altrimenti calcoliamo il risultato...
                  ; che è la differenza tra il valore attuale del numero one (val)
                  ; e il valore del numero one (nella hash-map) che ha lo stesso resto
                  ; del numero one attuale (myHash (string dv))
                  (setq out (- val (myHash (string dv))))
              )
            )
      )
    )
    ; elimina la hashmap
    (delete 'myHash)
    (list out (/ out num))))

(uz 3)
;-> (111L 37L)
(* 37 3)
;-> 111
(uz 10)
;-> (10L 1L)
(uz 123)
;-> (111111111111111L 903342366757L)
(uz 1234)
;-> (11111111111111111111111111111111111111111111111111111111111111111111111111111111111111110L
(11111111111111111111111111111111111111111111111111111111111111111111111111111111111111110L
 9004141905276427156491986313704303979830722132180803169457950657302359085179182423915L)
(div 11111111111111111111111111111111111111111111111111111111111111111111111111111111111111110L
 9004141905276427156491986313704303979830722132180803169457950657302359085179182423915L)
 ;-> 1234

Con questa ultima funzione possiamo usare come parametro dei numeri maggiori:

(length (last (uz 12345)))
;-> ;-> 818
(length (last (uz 123456)))
;-> 321

Ma anche in questo caso i numeri raggiungono presto dei valori praticamente intrattabili:

(time (println (length (last (uz 1234567)))))
;-> 34013      ; cifre del multiplo di 1234567 che contiene solo 1 e 0.
;-> 99618.592  ; circa 100 secondi

Comunque è interessante la dimostrazione del teorema.


---------------------------
Risolvere i sistemi lineari
---------------------------

Funzioni per la soluzione di un sistema lineare:
1) sislin-g (metodo di eliminazione di Gauss)
1) sislin-c (metodo di Cramer)

;; @syntax (sislin-g matrix terms)
;; @description Solve a linear system with Gauss's method (elimination with pivot and backwards substitution)
;; @param <matrix> matrix of the linear system
;; @param <terms> known terms
;; @return list of solutions (sol1 sol2...soln) (float) or nil
;; @example
;; (sislin-g '((2 1 1) (4 -1 1) (-1 1 2)) '(1 -5 5))   ==> (-1 2 1)
;; (sislin-g '((1 2 3) (-3 -2 3) (4 -5 2)) '(1 -1 1))  ==> (0.3620689655172414 0.1379310344827586 0.1206896551724138)
;; (sislin-g '((2 1 1) (4 -1 1) (4 2 2)) '(1 -5 5))    ==> nil
(define (sislin-g matrix terms)
  (local (n m p rowx amax xfac temp temp1 x)
    (setq rowx 0) ;conta il numero di scambio righe
    (setq n (length matrix))
    ;(setq x (dup '0 n))
    (setq x (array n (dup '0 n)))
    (for (k 0 (- n 2))
      (setq amax (abs (matrix k k)))
      (setq m k)
      ; trova la riga con il pivot più grande
      (for (i (+ k 1) (- n 1))
        (setq xfac (abs (matrix i k)))
        (if (> xfac amax) (setq amax xfac m i))
      )
      ; scambio delle righe
      (if (!= m k) (begin
          (++ rowx)
          (setq temp1 (terms k))
          (setq (terms k) (terms m))
          (setq (terms m) temp1)
          (for (j k (- n 1))
            (setq temp (matrix k j))
            (setq (matrix k j) (matrix m j))
            (setq (matrix m j) temp)
          ))
      )
      (for (i (+ k 1) (- n 1))
        (setq xfac (div (matrix i k) (matrix k k)))
        (for (j (+ k 1) (- n 1))
          (setq (matrix i j) (sub (matrix i j) (mul xfac (matrix k j))))
        )
        (setq (terms i) (sub (terms i) (mul xfac (terms k))))
      )
    )
    ; sostituzione all'indietro (backward sostitution)
    (for (j 0 (- n 1))
      (setq p (sub n j 1))
      (setq (x p) (terms p))
      (if (<= (+ p 1) (- n 1))
        (for (i (+ p 1) (- n 1))
          (setq (x p) (sub (x p) (mul (matrix p i) (x i))))
        )
      )
      (setq (x p) (div (x p) (matrix p p)))
    )
    (if (or (find true (map inf? x)) (find true (map NaN? x)))
        nil
        x)))

;; @syntax (sislin-c matrix terms)
;; @description Solve a linear system with Cramer's method (determinant)
;; @param <matrix> matrix of the linear system
;; @param <terms> known terms
;; @return list of solutions (sol1 sol2...soln) (float) or nil
;; @example
;; (sislin-c '((2 1 1) (4 -1 1) (-1 1 2)) '(1 -5 5))   ==> (-1 2 1)
;; (sislin-c '((1 2 3) (-3 -2 3) (4 -5 2)) '(1 -1 1))  ==> (0.3620689655172414 0.1379310344827586 0.1206896551724138)
;; (sislin-c '((2 1 1) (4 -1 1) (4 2 2)) '(1 -5 5))    ==> nil
(define (sislin-c matrix terms)
  (local (dim detm det-i sol copia)
    (setq dim (length matrix))
    (setq sol '())
    (setq copia matrix)
    (setq detm (det copia 0.0))
    ; la soluzione è indeterminata se il determinante vale zero.
    (if (= detm 0) (setq sol nil)
    ;(println detm)
      (for (i 0 (- dim 1))
        (for (j 0 (- dim 1))
          (setf (copia j i) (terms j))
        )
        ; 0.0 -> restituisce 0 (invece di nil),
        ; quando la matrix è singolare
        (setq det-i (det copia 0.0))
        (push (div det-i detm) sol -1)
        (setq copia matrix)
      )
    )
    sol))

Funzione per il controllo della soluzione del sistema:

(define (check-sislin matrix terms sol)
  (let (err '())
    (dolist (row matrix)
      (push (sub (terms $idx) (apply add (map mul row sol))) err -1))))

Come funziona? Sostituisce la soluzione alle incognite e calcola il valore di ogni equazione:

(sub (first '(1 -5 5)) (apply add (map mul '(2 1 1) '(-1 2 1))))
;-> 0
(sub (first (rest '(-1 -5 5))) (apply add (map mul '(4 -1 1) '(-1 2 1))))
;-> 0
(sub (last '(-1 -5 5)) (apply add (map mul '(-1 1 2) '(-1 2 1))))
;-> 0

(check-sislin '((2 1 1) (4 -1 1) (-1 1 2)) '(1 -5 5) '(-1 2 1))
;-> (0 0 0)

Funzione che elimina l'output automatico della REPL:

(define (noecho expr) (silent expr) (print "\r\n>"))

Sistema con 51 equazioni:

(setq m '())
(for (i 1 51)
  (push (map (fn(x) (if (zero? (rand 2)) (- x) (+ x))) (randomize (sequence 100 150))) m -1))
(length m)
;-> 51
(length (first m))
;-> 51

(setq t (map (fn(x) (if (zero? (rand 2)) (- x) (+ x))) (randomize (sequence 100 150))))
(length t)
;-> 51

(det m)
;-> -2.455307809771113e+138

(sislin-c m t)

(sislin-g m t)

Differenza tra le soluzioni:

(map sub (sislin-c m t) (sislin-c m t))
;-> (0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
;->  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)

Sistema con 200 incognite:

(setq m '())
(for (i 1 200)
  (push (map (fn(x) (if (zero? (rand 2)) (- x) (+ x))) (randomize (sequence 1000 1199))) m -1))
(length m)
;-> 200
(length (first m))
;-> 200

(setq t (map (fn(x) (if (zero? (rand 2)) (- x) (+ x))) (randomize (sequence 1000 1199))))
(length t)
;-> 200

(sislin-c m t)
;-> (-1.#IND -1.#IND -1.#IND -1.#IND -1.#IND -1.#IND -1.#IND
;->  ...
;->  -1.#IND -1.#IND -1.#IND -1.#IND -1.#IND -1.#IND -1.#IND)

Il metodo di Cramer fallisce perchè non riesce a calcolare il determinante (probabilmente perchè il numero è troppo grande):

(det m)
;-> -1.#INF

(sislin-g m t)
;-> (0.4363372503633707 -2.648733303674789 -3.608251827329319
;->  ...
;->  0.8024036199836556 1.712882404517861 -0.8461290786683825)

(time (sislin-g m t))
;-> 3328.499

Convertiamo la lista m in vettore:

(setq mvec (array 200 200 (flat m)))
(length mvec)
;-> 200
(length (first mvec))
;-> 200

(setq tvec (array 200 t))
(length tvec)
;-> 200

Con i vettori il calcolo è molto più veloce:

(time (sislin-g mvec tvec))
;-> 298.122

Sistema con 500 incognite:

(noecho
(setq m '())
(for (i 1 500)
  (push (map (fn(x) (if (zero? (rand 2)) (- x) (+ x))) (randomize (sequence 1 500))) m -1))
)
(length m)
;-> 500
(length (first m))
;-> 500

(noecho
(setq t (map (fn(x) (if (zero? (rand 2)) (- x) (+ x))) (randomize (sequence 1 500))))
(length t))
;-> 500

Convertiamo la lista m in vettore:

(noecho (setq mvec (array 500 500 (flat m))))
(length mvec)
;-> 500
(length (first mvec))
;-> 500

(setq tvec (array 500 t))
(length tvec)
;-> 500

(time (println (sislin-g mvec tvec)))
;-> 4437.562

Sistema con 1000 incognite:

(noecho
(setq m '())
(for (i 1 1000)
  (push (map (fn(x) (if (zero? (rand 2)) (- x) (+ x))) (randomize (sequence 1 1000))) m -1))
)
(length m)
;-> 1000
(length (first m))
;-> 1000

(setq t (map (fn(x) (if (zero? (rand 2)) (- x) (+ x))) (randomize (sequence 1 1000))))
(length t)
;-> 1000

Convertiamo la lista m in vettore:

(noecho (setq mvec (array 1000 1000 (flat m))))
(length mvec)
;-> 1000
(length (first mvec))
;-> 1000

(setq tvec (array 1000 t))
(length tvec)
;-> 1000

(time (println (sislin-g mvec tvec)))
;-> 35597.271

Occorrono quasi 36 secondi per risolvere un sistema di 1000 equazioni (non male).

Controllo soluzioni:

(silent (setq soluz (sislin-g mvec tvec)))
(setq errors (check-sislin mvec tvec soluz))

Calcolo errore massimo:

(apply max errors)
;-> 6.141362973721698e-009


-----------
Sudoku test
-----------

Vediamo alcuni puzzle sudoku considerati difficili da risolvere, prima però scriviamo la funzione per risolverli.

(define (sudoku board)
  (let (sol nil)
    (if (valid? board) (solveSudoku board)
        (setq sol '(nil)))
    sol))

(define (solveSudoku board)
(catch
  (local (i j row col is-empty solved)
    (setq row -1 col -1)
    (setq is-empty true)
    (setq i 0 j 0)
    (while (and is-empty (< i (length board)))
      (while (and is-empty (< j (length board)))
        (if (= (board i j) 0)
            ; Esistono ancora dei valori nulli nel puzzle
            (setq row i col j is-empty nil)
        )
        (++ j)
      )
      (setq j 0)
      (++ i)
    )
    (if is-empty (begin (setq sol board) (throw true)))
    ;else
    (for (num 1 (length board))
        (cond ((safe? board row col num)
                 (setf (board row col) num)
                 (if (solveSudoku board) (throw true))
                 (setf (board row col) 0)
              )
        )
    )
    nil)))

(define (valid? pos)
  (local (safe blk)
    (setq safe true)
    ; numeri compresi tra 0 (casella vuota) e 9
    (for (r 0 8)
      (for (c 0 8)
        (if (or (< (pos r c) 0) (> (pos r c) 9))
            (setq safe nil))))
    ; numero unico sulla riga (row-clash)
    (if safe (begin
      (for (r 0 8)
        (if (find 1 (count '(1 2 3 4 5 6 7 8 9) (pos r)) <)
          (setq safe nil)))))
    ; numero unico sulla colonna (row-clash)
    (if safe (begin
      (for (c 0 8)
        (if (find 1 (count '(1 2 3 4 5 6 7 8 9) ((transpose pos) c)) <)
          (setq safe nil)))))
    ; numero unico sui 9 blocchi 3x3 (block-clash)
    (if safe (begin
        (setq blk (list (pos 0 0) (pos 0 1) (pos 0 2) (pos 1 0) (pos 1 1) (pos 1 2) (pos 2 0) (pos 2 1) (pos 2 2)))
        (if (find 1 (count '(1 2 3 4 5 6 7 8 9) blk) <) (setq safe nil))))
    (if safe (begin
        (setq blk (list (pos 0 3) (pos 0 4) (pos 0 5) (pos 1 3) (pos 1 4) (pos 1 5) (pos 2 3) (pos 2 4) (pos 2 5)))
        (if (find 1 (count '(1 2 3 4 5 6 7 8 9) blk) <) (setq safe nil))))
    (if safe (begin
        (setq blk (list (pos 0 6) (pos 0 7) (pos 0 8) (pos 1 6) (pos 1 7) (pos 1 8) (pos 2 6) (pos 2 7) (pos 2 8)))
        (if (find 1 (count '(1 2 3 4 5 6 7 8 9) blk) <) (setq safe nil))))
    (if safe (begin
        (setq blk (list (pos 3 0) (pos 3 1) (pos 3 2) (pos 4 0) (pos 4 1) (pos 4 2) (pos 5 0) (pos 5 1) (pos 5 2)))
        (if (find 1 (count '(1 2 3 4 5 6 7 8 9) blk) <) (setq safe nil))))
    (if safe (begin
        (setq blk (list (pos 3 3) (pos 3 4) (pos 3 5) (pos 4 3) (pos 4 4) (pos 4 5) (pos 5 3) (pos 5 4) (pos 5 5)))
        (if (find 1 (count '(1 2 3 4 5 6 7 8 9) blk) <) (setq safe nil))))
    (if safe (begin
        (setq blk (list (pos 3 6) (pos 3 7) (pos 3 8) (pos 4 6) (pos 4 7) (pos 4 8) (pos 5 6) (pos 5 7) (pos 5 8)))
        (if (find 1 (count '(1 2 3 4 5 6 7 8 9) blk) <) (setq safe nil))))
    (if safe (begin
        (setq blk (list (pos 6 0) (pos 6 1) (pos 6 2) (pos 7 0) (pos 7 1) (pos 7 2) (pos 8 0) (pos 8 1) (pos 8 2)))
        (if (find 1 (count '(1 2 3 4 5 6 7 8 9) blk) <) (setq safe nil))))
    (if safe (begin
        (setq blk (list (pos 6 3) (pos 6 4) (pos 6 5) (pos 7 3) (pos 7 4) (pos 7 5) (pos 8 3) (pos 8 4) (pos 8 5)))
        (if (find 1 (count '(1 2 3 4 5 6 7 8 9) blk) <) (setq safe nil))))
    (if safe (begin
        (setq blk (list (pos 6 6) (pos 6 7) (pos 6 8) (pos 7 6) (pos 7 7) (pos 7 8) (pos 8 6) (pos 8 7) (pos 8 8)))
        (if (find 1 (count '(1 2 3 4 5 6 7 8 9) blk) <) (setq safe nil))))
    safe))

(define (safe? board row col num)
  (local (safe blk-row blk-col)
    (setq safe true)
    ; numero unico sulla riga (row-clash)
    (for (c 0 (- (length board) 1))
      ; Se il numero che stiamo provando
      ; è presente in quella riga
      ; restituire falso (nil)
      (if (= (board row c) num)
          (setq safe nil)
      )
    )
    (if safe (begin
    ; numero unico sulla colonna (column-clash)
    (for (r 0 (- (length board) 1))
      ; Se il numero che stiamo provando
      ; è presente in quella colonna
      ; restituire falso (nil)
      (if (= (board r col) num)
          (setq safe nil)
      )
    )))
    (if safe (begin
    ; numero unico in ogni blocco 3x3 (block-clash)
    (setq blk-row (- row (% row 3)))
    (setq blk-col (- col (% col 3)))
    (for (r blk-row (+ blk-row 2))
      (for (c blk-col (+ blk-col 2))
        (if (= (board r c) num)
            (setq safe nil)
        )
      )
    )))
    ; se non c'è conflitto, allora è sicuro
    safe))

Un sudoku vuoto...

(setq x
'((0 0 0 0 0 0 0 0 0)
  (0 0 0 0 0 0 0 0 0)
  (0 0 0 0 0 0 0 0 0)
  (0 0 0 0 0 0 0 0 0)
  (0 0 0 0 0 0 0 0 0)
  (0 0 0 0 0 0 0 0 0)
  (0 0 0 0 0 0 0 0 0)
  (0 0 0 0 0 0 0 0 0)
  (0 0 0 0 0 0 0 0 0)))

(time (println (sudoku x)))
;-> ((1 2 3 4 5 6 7 8 9)
;->  (4 5 6 7 8 9 1 2 3)
;->  (7 8 9 1 2 3 4 5 6)
;->  (2 1 4 3 6 5 8 9 7)
;->  (3 6 5 8 9 7 2 1 4)
;->  (8 9 7 2 1 4 3 6 5)
;->  (5 3 1 6 4 2 9 7 8)
;->  (6 4 2 9 7 8 5 3 1)
;->  (9 7 8 5 3 1 6 4 2))
;-> 13.968

I dieci sudoku più difficili:

(setq escargot
'((1 0 0 0 0 7 0 9 0)
  (0 3 0 0 2 0 0 0 8)
  (0 0 9 6 0 0 5 0 0)
  (0 0 5 3 0 0 9 0 0)
  (0 1 0 0 8 0 0 0 2)
  (6 0 0 0 0 4 0 0 0)
  (3 0 0 0 0 0 0 1 0)
  (0 4 0 0 0 0 0 0 7)
  (0 0 7 0 0 0 3 0 0)))

(time (println (sudoku escargot)))
;-> ((1 6 2 8 5 7 4 9 3)
;->  (5 3 4 1 2 9 6 7 8)
;->  (7 8 9 6 4 3 5 2 1)
;->  (4 7 5 3 1 2 9 8 6)
;->  (9 1 3 5 8 6 7 4 2)
;->  (6 2 8 7 9 4 1 3 5)
;->  (3 5 6 4 7 8 2 1 9)
;->  (2 4 1 9 3 5 8 6 7)
;->  (8 9 7 2 6 1 3 5 4))
;-> 211.984

(setq killer
'((0 0 0 0 0 0 0 7 0)
  (0 6 0 0 1 0 0 0 4)
  (0 0 3 4 0 0 2 0 0)
  (8 0 0 0 0 3 0 5 0)
  (0 0 2 9 0 0 7 0 0)
  (0 4 0 0 8 0 0 0 9)
  (0 2 0 0 6 0 0 0 7)
  (0 0 0 1 0 0 9 0 0)
  (7 0 0 0 0 8 0 6 0)))

(time (println (sudoku killer)))
;-> ((9 5 4 8 2 6 1 7 3)
;->  (2 6 8 3 1 7 5 9 4)
;->  (1 7 3 4 9 5 2 8 6)
;->  (8 1 9 7 4 3 6 5 2)
;->  (6 3 2 9 5 1 7 4 8)
;->  (5 4 7 6 8 2 3 1 9)
;->  (4 2 1 5 6 9 8 3 7)
;->  (3 8 6 1 7 4 9 2 5)
;->  (7 9 5 2 3 8 4 6 1))
;-> 2681.012

(setq diamond
'((1 0 0 5 0 0 4 0 0)
  (0 0 9 0 3 0 0 0 0)
  (0 7 0 0 0 8 0 0 5)
  (0 0 1 0 0 0 0 3 0)
  (8 0 0 6 0 0 5 0 0)
  (0 9 0 0 0 7 0 0 8)
  (0 0 4 0 2 0 0 1 0)
  (2 0 0 8 0 0 6 0 0)
  (0 0 0 0 0 1 0 0 2)))

(time (println (sudoku diamond)))
;-> ((1 2 8 5 7 6 4 9 3)
;->  (5 4 9 1 3 2 7 8 6)
;->  (3 7 6 9 4 8 1 2 5)
;->  (7 6 1 2 8 5 9 3 4)
;->  (8 3 2 6 9 4 5 7 1)
;->  (4 9 5 3 1 7 2 6 8)
;->  (6 5 4 7 2 3 8 1 9)
;->  (2 1 3 8 5 9 6 4 7)
;->  (9 8 7 4 6 1 3 5 2))
;-> 294.358

(setq wormhole
'((0 8 0 0 0 0 0 0 1)
  (0 0 7 0 0 4 0 2 0)
  (6 0 0 3 0 0 7 0 0)
  (0 0 2 0 0 9 0 0 0)
  (1 0 0 0 6 0 0 0 8)
  (0 3 0 4 0 0 0 0 0)
  (0 0 1 7 0 0 6 0 0)
  (0 9 0 0 0 8 0 0 5)
  (0 0 0 0 0 0 0 4 0)))

(time (println (sudoku wormhole)))
;-> ((9 8 4 2 7 6 3 5 1)
;->  (3 1 7 9 5 4 8 2 6)
;->  (6 2 5 3 8 1 7 9 4)
;->  (5 6 2 8 3 9 4 1 7)
;->  (1 4 9 5 6 7 2 3 8)
;->  (7 3 8 4 1 2 5 6 9)
;->  (4 5 1 7 9 3 6 8 2)
;->  (2 9 3 6 4 8 1 7 5)
;->  (8 7 6 1 2 5 9 4 3))
;-> 3833.182

(setq labyrinth
'((1 0 0 4 0 0 8 0 0)
  (0 4 0 0 3 0 0 0 9)
  (0 0 9 0 0 6 0 5 0)
  (0 5 0 3 0 0 0 0 0)
  (0 0 0 0 0 1 6 0 0)
  (0 0 0 0 7 0 0 0 2)
  (0 0 4 0 1 0 9 0 0)
  (7 0 0 8 0 0 0 0 4)
  (0 2 0 0 0 4 0 8 0)))

(time (println (sudoku labyrinth)))
;-> ((1 6 5 4 9 7 8 2 3)
;->  (2 4 7 5 3 8 1 6 9)
;->  (8 3 9 1 2 6 4 5 7)
;->  (6 5 1 3 4 2 7 9 8)
;->  (3 7 2 9 8 1 6 4 5)
;->  (4 9 8 6 7 5 3 1 2)
;->  (5 8 4 2 1 3 9 7 6)
;->  (7 1 6 8 5 9 2 3 4)
;->  (9 2 3 7 6 4 5 8 1))
;-> 1983.587

(setq circles
'((0 0 5 0 0 9 7 0 0)
  (0 6 0 0 0 0 0 2 0)
  (1 0 0 8 0 0 0 0 6)
  (0 1 0 7 0 0 0 0 4)
  (0 0 7 0 6 0 0 3 0)
  (6 0 0 0 0 3 2 0 0)
  (0 0 0 0 0 6 0 4 0)
  (0 9 0 0 5 0 1 0 0)
  (8 0 0 1 0 0 0 0 2)))

(time (println (sudoku circles)))
;-> ((4 8 5 6 2 9 7 1 3)
;->  (7 6 9 3 4 1 8 2 5)
;->  (1 3 2 8 7 5 4 9 6)
;->  (5 1 3 7 9 2 6 8 4)
;->  (9 2 7 4 6 8 5 3 1)
;->  (6 4 8 5 1 3 2 7 9)
;->  (2 5 1 9 8 6 3 4 7)
;->  (3 9 4 2 5 7 1 6 8)
;->  (8 7 6 1 3 4 9 5 2))
;-> 2424.274

(setq squadron
'((6 0 0 0 0 0 2 0 0)
  (0 9 0 0 0 1 0 0 5)
  (0 0 8 0 3 0 0 4 0)
  (0 0 0 0 0 2 0 0 1)
  (5 0 0 6 0 0 9 0 0)
  (0 0 7 0 9 0 0 0 0)
  (0 7 0 0 0 3 0 0 2)
  (0 0 0 4 0 0 5 0 0)
  (0 0 6 0 7 0 0 8 0)))

(time (println (sudoku squadron)))
;-> ((6 5 3 7 4 9 2 1 8)
;->  (7 9 4 8 2 1 6 3 5)
;->  (1 2 8 5 3 6 7 4 9)
;->  (4 6 9 3 5 2 8 7 1)
;->  (5 3 1 6 8 7 9 2 4)
;->  (2 8 7 1 9 4 3 5 6)
;->  (8 7 5 9 1 3 4 6 2)
;->  (3 1 2 4 6 8 5 9 7)
;->  (9 4 6 2 7 5 1 8 3))
;-> 2702.114

(setq honeypot
'((1 0 0 0 0 0 0 6 0)
  (0 0 0 1 0 0 0 0 3)
  (0 0 5 0 0 2 9 0 0)
  (0 0 9 0 0 1 0 0 0)
  (7 0 0 0 4 0 0 8 0)
  (0 3 0 5 0 0 0 0 2)
  (5 0 0 4 0 0 0 0 6)
  (0 0 8 0 6 0 0 7 0)
  (0 7 0 0 0 5 0 0 0)))

(time (println (sudoku honeypot)))
;-> ((1 8 2 3 9 4 5 6 7)
;->  (9 6 7 1 5 8 2 4 3)
;->  (3 4 5 6 7 2 9 1 8)
;->  (8 2 9 7 3 1 6 5 4)
;->  (7 5 6 2 4 9 3 8 1)
;->  (4 3 1 5 8 6 7 9 2)
;->  (5 9 3 4 1 7 8 2 6)
;->  (2 1 8 9 6 3 4 7 5)
;->  (6 7 4 8 2 5 1 3 9))
;-> 5773.664

(setq tweezers
'((1 0 0 0 0 0 0 6 0)
  (0 0 0 1 0 0 0 0 3)
  (0 0 5 0 0 2 9 0 0)
  (0 0 9 0 0 1 0 0 0)
  (7 0 0 0 4 0 0 8 0)
  (0 3 0 5 0 0 0 0 2)
  (5 0 0 4 0 0 0 0 6)
  (0 0 8 0 6 0 0 7 0)
  (0 7 0 0 0 5 0 0 0)))

(time (println (sudoku tweezers)))
;-> ((1 8 2 3 9 4 5 6 7)
;->  (9 6 7 1 5 8 2 4 3)
;->  (3 4 5 6 7 2 9 1 8)
;->  (8 2 9 7 3 1 6 5 4)
;->  (7 5 6 2 4 9 3 8 1)
;->  (4 3 1 5 8 6 7 9 2)
;->  (5 9 3 4 1 7 8 2 6)
;->  (2 1 8 9 6 3 4 7 5)
;->  (6 7 4 8 2 5 1 3 9))
;-> 5714.483

(setq brokenbrick
'((4 0 0 0 6 0 0 7 0)
  (0 0 0 0 0 0 6 0 0)
  (0 3 0 0 0 2 0 0 1)
  (7 0 0 0 0 8 5 0 0)
  (0 1 0 4 0 0 0 0 0)
  (0 2 0 9 5 0 0 0 0)
  (0 0 0 0 0 0 7 0 5)
  (0 0 9 1 0 0 0 3 0)
  (0 0 3 0 4 0 0 8 0)))

(time (println (sudoku brokenbrick)))
;-> 137.515

The World's Hardest Sudoku:

(setq world
'((8 0 0 0 0 0 0 0 0)
  (0 0 3 6 0 0 0 0 0)
  (0 7 0 0 9 0 2 0 0)
  (0 5 0 0 0 7 0 0 0)
  (0 0 0 0 4 5 7 0 0)
  (0 0 0 1 0 0 0 3 0)
  (0 0 1 0 0 0 0 6 8)
  (0 0 8 5 0 0 0 1 0)
  (0 9 0 0 0 0 4 0 0)))

(time (println (sudoku world)))
;-> ((8 1 2 7 5 3 6 4 9)
;->  (9 4 3 6 8 2 1 7 5)
;->  (6 7 5 4 9 1 2 8 3)
;->  (1 5 4 2 3 7 8 9 6)
;->  (3 6 9 8 4 5 7 2 1)
;->  (2 8 7 1 6 9 5 3 4)
;->  (5 2 1 9 7 4 3 6 8)
;->  (4 3 8 5 2 6 9 1 7)
;->  (7 9 6 3 1 8 4 5 2))
;-> 1122.131

In genere i puzzle più difficili per gli umani vengono risolti in breve tempo (pochi secondi) con la nostra funzione brute-force. Adesso vediamo un puzzle considerato difficile per il metodo brute-force:

(setq beast
'((0 0 0 0 0 0 0 0 0)
  (0 0 0 0 0 3 0 8 5)
  (0 0 1 0 2 0 0 0 0)
  (0 0 0 5 0 7 0 0 0)
  (0 0 4 0 0 0 1 0 0)
  (0 9 0 0 0 0 0 0 0)
  (5 0 0 0 0 0 0 7 3)
  (0 0 2 0 1 0 0 0 0)
  (0 0 0 0 4 0 0 0 9)))

(time (print (sudoku beast)))
;-> ((9 8 7 6 5 4 3 2 1)
;->  (2 4 6 1 7 3 9 8 5)
;->  (3 5 1 9 2 8 7 4 6)
;->  (1 2 8 5 3 7 6 9 4)
;->  (6 3 4 8 9 2 1 5 7)
;->  (7 9 5 4 6 1 8 3 2)
;->  (5 1 9 2 8 6 4 7 3)
;->  (4 7 2 3 1 9 5 6 8)
;->  (8 6 3 7 4 5 2 1 9))
;-> 1619210.766 ; 27 minuti
(div (div 1619210.766 1000) 60)
;-> 26.9868461

In effetti, ci sono voluti 27 minuti per risolverlo.

Un altro sudoku difficile con la tecnica brute-force:

(setq hell
'((9 0 0 8 0 0 0 0 0)
  (0 0 0 0 0 0 5 0 0)
  (0 0 0 0 0 0 0 0 0)
  (0 2 0 0 1 0 0 0 3)
  (0 1 0 0 0 0 0 6 0)
  (0 0 0 4 0 0 0 7 0)
  (7 0 8 6 0 0 0 0 0)
  (0 0 0 0 3 0 1 0 0)
  (4 0 0 0 0 0 2 0 0)))

(time (print (sudoku hell)))
((9 7 2 8 5 3 6 1 4)
 (1 4 6 2 7 9 5 3 8)
 (5 8 3 1 4 6 7 2 9)
 (6 2 4 7 1 8 9 5 3)
 (8 1 7 3 9 5 4 6 2)
 (3 5 9 4 6 2 8 7 1)
 (7 9 8 6 2 1 3 4 5)
 (2 6 5 9 3 4 1 8 7)
 (4 3 1 5 8 7 2 9 6))
;-> 54630842.335 ; 910 minuti (tutta la notte)
(div (div 54630842.335 1000) 60)
;-> 910.5140389166667


------------------
Integrali definiti
------------------

Gli integrali... proprio quelli delle superiori e (per qualcuno) dell'università. Vediamo alcuni metodi per calcolare l'integrale definito di una funzione nell'intervallo [a,b]. Ricordiamo che per calcolare l'integrale definito la funzione deve essere continua in tutto l'intervallo [a,b].

Metodo del trapezio
-------------------
La regola del trapezio approssima l'integrale, cioè l'area della regione piana compresa fra il grafico della funzione f(x) e l'asse delle ascisse, con l'area del trapezio di vertici (a,f(a)),(b,f(b)),(b,0),(a,0). Quindi si ottiene:

 b                   f(a) + f(b)
∫ f(x)dx ≈ (b - a)*---------------
a                         2

Questa approssimazione è accettabile se nell'intervallo di integrazione la funzione ha un andamento quasi sempre lineare. Se questo non accade si può suddividere l'intervallo complessivo [a,b] in un numero n di sottointervalli: in questo modo in ciascun sottointervallo accade (in genere) che la funzione ha un andamento quasi lineare. Quindi la regola del trapezio applicata a tutti i sottointervalli genera la seguente formula:


 b                      f(a) + f(b)                          (b - a)
∫ f(x)dx ≈ (b - a) * (--------------- + Sum[1..n-1] f(a + k*---------))
a                            2                                  n

Questo metodo è generalmente efficace, ma non approssima molto bene le funzioni che variano velocemente (es. e^x).
Maggiore è la pendenza della funzione, maggiore è l'errore che dobbiamo aspettarci dall'utilizzo del metodo trapezioale. Comunque possiamo sempre aumentare il numero di iterazioni per migliorare il risultato.

(define (trapezio func a b iter)
  (local (h s x)
    (setq h (div (sub b a) iter))
    (setq s (mul 0.5 (func a) (func b)))
    (for (i 1 (- iter 1))
      (setq x (add a (mul i h)))
      (setq s (add s (func x)))
    )
    (mul s h)))

Metodo di Romberg
-----------------
L'algoritmo di romberg è l'applicazione dell'interpolazione di Richardson a ciascuna iterazione delle approssimazioni trapezioali. Questo permette di ottenere un'interpolazione di ordine superiore e quindi un risultato più preciso.

(define (romberg func a b iter)
  (local (r h sum)
    (setq r (array (+ iter 1) (+ iter 1) '(0)))
    (setq h (sub b a))
    (setq (r 1 1) (mul (mul h 0.5) (add (func a) (func b))))
    (for (i 2 iter)
      (setq h (mul h 0.5))
      (setq sum 0)
      (for (k 1 (- (pow 2 (- i 1)) 1) 2)
        (setq sum (add sum (func (add a (mul k h)))))
      )
      (setq (r i 1) (add (mul 0.5 (r (- i 1) 1)) (mul sum h)))
      (for (j 2 i)
        (setq (r i j) (add (r i (- j 1))
                          (div (sub (r i (- j 1)) (r (- i 1) (- j 1)))
                                (sub (pow 4 (- j 1)) 1))))
      )
    )
    (r iter iter)))

Quadratura gaussiana
--------------------
Le formule gaussiane di quadratura a n punti sono formule di quadratura numerica con alto grado di precisione, utilizzate per l'approssimazione di un integrale definito della funzione f(x) conoscendo n+1 valori della funzione f nell'intervallo [a,b].

Quadratura gaussiana a 2 punti:

(define (gauss-quad2p func a b iter)
  (local (h x0 x1 x2 x3 sum)
    (setq h (div (sub b a) iter))
    (setq sum 0)
    (for (i 1 (- iter 1))
      (setq x0 (add a (mul i h)))
      (setq x1 (add x0 (mul 0.5 h (sub 1 (sqrt (div 3))))))
      (setq x2 (add x0 (mul 0.5 h (add 1 (sqrt (div 3))))))
      (setq sum (add sum (func x1) (func x2)))
    )
    (setq sum (mul sum 0.5 h))))

Quadratura gaussiana a 3 punti:

(define (gauss-quad3p func a b iter)
  (local (h x0 x1 x2 x3 sum)
    (setq h (div (sub b a) iter))
    (setq sum 0)
    (for (i 1 (- iter 1))
      (setq x0 (add a (mul i h)))
      (setq x1 (add x0 (mul 0.5 h (sub 1 (sqrt (div 3 5))))))
      (setq x2 (add x0 (mul 0.5 h)))
      (setq x3 (add x0 (mul 0.5 h (add 1 (sqrt (div 3 5))))))
      (setq sum (add sum
                     (mul (div 5 9) (func x1))
                     (mul (div 8 9) (func x2))
                     (mul (div 5 9) (func x3))))
    )
    (setq sum (mul sum 0.5 h))))

Proviamo a calcolare alcuni integrali:

(setq PI 3.1415926535897931)

(define (f x) (sin x))
(trapezio f 0 PI 10000)
;-> 1.999999983550661
(romberg f 0 PI 10)
;-> 2
(gauss-quad2p f 0 PI 100)
;-> 1.99950655991486
(gauss-quad3p f 0 PI 100)
;-> 1.999506560365733
Valore reale: 2

(define (f1 x) (div 4 (add 1 (mul x x))))
(trapezio f1 0 1 10000)
;-> 3.14169265192314
(romberg f1 0 1 10)
;-> 3.141592653589793
(gauss-quad2p f1 0 1 100000)
;-> 3.141552653589758
(gauss-quad3p f1 0 1 100000)
;-> 3.141552653589891
Valore reale: 3.1415926535897931 (pi greco)

(define (g x) (pow x 5))
(trapezio g 0 1 10000)
;-> 0.1666166708333333
(romberg g 0 1 10)
;-> 0.1666666666666667
(gauss-quad2p g 0 1 100)
;-> 0.166666666527625
(gauss-quad3p g 0 1 100)
;-> 0.1666666666665
Valore vero: 1.(6) (1.6666666...)

(define (g1 x) (pow x 2))
(trapezio g1 1 2 10000)
;-> 2.333283334999989
(romberg g1 1 2 10)
;-> 2.333333333333334
(gauss-quad2p g1 1 2 10000)
;-> 2.333233323333007
(gauss-quad3p g1 1 2 10000)
;-> 2.333233323333004
Valore vero: 2.(3)

(define (g2 x) (mul (cos x) (cos x)))
(trapezio g2 0 (mul 2 PI) 100000)
;-> 3.141561237663232
(romberg g2 0 (mul 2 PI) 10)
;-> 3.141592653589793
(gauss-quad2p g2 0 (mul 2 PI) 100000)
;-> 3.141529821736828
(gauss-quad3p g2 0 (mul 2 PI) 100000)
;-> 3.141529821736874
Valore vero: 3.1415926535897931 (pi greco)

(define (g3 x) (div (mul 4 x) (sub 2 (mul 8 (pow x 2)))))
(trapezio g3 3 5 100000)
;-> -0.259940049615719
(romberg g3 3 5 10)
;-> -0.259942947161294
(gauss-quad2p g3 3 5 100000)
;-> -0.2599395186019513
(gauss-quad3p g3 3 5 100000)
;-> -0.2599395186019479
Valore vero: -0.259942947161294
(div (sub (log 70) (log 198)) 4)
;-> -0.259942947161294

(define (g3 x) (div (mul 4 x) (sub 2 (mul 8 (pow x 2)))))
(trapezio g3 -1 1 100000)
;-> -1.#INF
(romberg g3 -1 1 10)
;-> -1.#IND
(gauss-quad2p g3 -1 1 100000)
;-> -1.333349378033419e-005
(gauss-quad3p g3 -1 1 100000)
;-> -1.333343700649166e-005
Valore vero: divergente per x = 1/2 e x = -1/2

(define (g4 x) (sin x))
(trapezio g4 0 PI 10000)
;-> 1.999999983550661
(romberg g4 0 PI 10)
;-> 2
(gauss-quad2p g4 0 PI 10000)
;-> 1.999999950651962
(gauss-quad3p g4 0 PI 10000)
;-> 1.999999950651979
Valore vero: 2

(define (g5 x) (div 4 (add 1 (mul x x))))
(trapezio g5 0 1 100000)
;-> 3.141602653573153
(romberg g5 0 1 10)
;-> 3.141592653589793
(gauss-quad2p g5 0 1 100000)
;-> 3.141552653589758
(gauss-quad3p g5 0 1 100000)
;-> 3.141552653589891
Valore vero: 3.1415926535897931 (pi greco)


---------------
Fattorizzazione
---------------

Per fattorizzare un numero intero abbiamo la funzione integrata "factor":

(factor 1372000)
;-> (2 2 2 2 2 5 5 5 7 7 7)

In cui compaiono tutti i fattori del numero. Se volessimo raggruppare i fattori in comune dobbiamo scrivere una funzione. Vediamo diversi metodi per trovare quello più veloce.

Funzione 1:

(define (factor-g1 num)
  (if (< num 2) nil
      (letn (fattori (factor num)
            unici (unique fattori))
            (transpose (list unici (count unici fattori))))))

(factor-g1 1372000)
;-> ((2 5) (5 3) (7 3))

Funzione 2:

(define (factor-g2 x)
  (letn (fattori (factor x)
         unici (unique fattori))
        (map list unici (count unici fattori))))

(factor-g2 1372000)
;-> ((2 5) (5 3) (7 3))

Funzione 3:

(define (factor-g3 num)
  (if (< num 2) nil
      (let (factorlist (factor num) factorlist-grouped '())
        (dolist (y (unique factorlist))
           (push (append (list y) (count (list y) factorlist)) factorlist-grouped -1))
        factorlist-grouped)))

(factor-g3 1372000)
;-> ((2 5) (5 3) (7 3))

Funzione 4:
il quarto metodo usa la tecnica Run Lenght Encode (infatti applicando l'algoritmo RLE al risultato della funzione "factor" si ottiene il risultato):

(define (factor-g4 num)
  (if (< num 2) nil
      (letn ((out '()) (lst (factor num)) (cur-val (first lst)) (cur-count 0))
        (dolist (el lst)
          (if (= el cur-val) (++ cur-count)
              (begin
                (push (list cur-val cur-count) out -1)
                (setq cur-count 1 cur-val el))))
        (push (list cur-val cur-count) out -1))))

(factor-g4 1372000)
;-> ((2 5) (5 3) (7 3))

Vediamo se le quattro funzioni producono gli stessi risultati:

(= (map factor-g1 (sequence 2 10000))
   (map factor-g2 (sequence 2 10000))
   (map factor-g3 (sequence 2 10000))
   (map factor-g4 (sequence 2 10000)))
;-> true

Vediamo i tempi di esecuzione:

(silent (setq seq (sequence 1e6 1e7)))
(time (map factor-g1 seq))
;-> 28214.053
(time (map factor-g2 seq))
;-> 28532.154
(time (map factor-g3 seq))
;-> 40389.041
(time (map factor-g4 seq))
;-> 23980.14

L'ultima funzione è quella più veloce.


--------------
"setq" o "set"
--------------

Notiamo che "setq" è più veloce di "set":

(time (setq a 10 b 20 c 30) 10000000)
;-> 382.001
(time (set 'a 10 'b 20 'c 30) 10000000)
;-> 479.744

(time (for (i 1 10000) (setq a 10)) 10000)
;-> 2287.881
(time (for (i 1 10000) (set 'd 10)) 10000)
;-> 2638.974

E possiamo sempre divertirci scrivendo:

(setq --> setq)
(--> a 3)
a
;-> 3


-------
Memfrob
-------

Memfrob è un algoritmo di crittografia leggero che funziona facendo lo xor tra il numero 42(10) = 00101010(2) con ogni carattere (byte) di input per creare un output crittografato. La decrittazione è simmetrica alla crittografia. Memfrob è più o meno equivalente a ROT13 nella sicurezza crittografica.

Codifica di un carattere:
(char (^ (char "a") 42))
;-> "K"

Decodifica del carattere:
(char (^ (char "K") 42))
;-> "a"

Le funzioni di codifica e decodifica di un carattere sono uguali:

(define (frob c) (char (^ (char c) 42)))

Scriviamo la funzione per criptare/decriptare una stringa:

(define (memfrob str) (join (map frob (explode str))))

(memfrob "pippo")
;-> "ZCZZE"

(memfrob "ZCZZE")
;-> "pippo"

(memfrob (memfrob "newLISP is fun"))
;-> "newLISP is fun"

Nota: il numero 42 ricorda il libro "Guida Galattica per Autostoppisti" di Douglas Adams.


----------------------
Generatore di sequenze
----------------------

Scriviamo un programma che genera la seguente sequenza:

1, 5, 10, 50, 100, 500, 1000, 5000, 10000

La sequenza si ottiene partendo da 1 e moltiplicando il numero alternativamente per 5 e per 2:

1
1*5    -> 5
5*2    -> 10
10*5   -> 50
50*2   -> 100
100*5  -> 500
500*2  -> 1000
...

Una possibile soluzione è la seguente:

(define (seq1 n)
  (local (out m1 m2 val flip)
    (setq out '(1))
    (setq val 1)
    (setq m1 5 m2 2)
    (setq flip nil)
    (while (<= (* val m2) n)
      (if flip
          (setq val (* val m2) flip nil)
          (setq val (* val m1) flip true)
      )
      (push val out -1)
    )
    out))

(seq1 50001)
;-> (1 5 10 50 100 500 1000 5000 10000 50000)

Possiamo scrivere una funzione più generale per generare questo tipo di sequenze utilizzando una lista circolare e parametrizzando l'operatore aritmetico. La lista circolare contiene i valori dei moltiplicatori e l'operatore aritmetico "+" oppure "*" viene passato come parametro alla funzione.

Funzioni per la gestione di una lista circolare:

; creiamo un contesto per la struttura
(context 'circ-list)
; inizializzazione della lista circolare
(define (circ-list:init lst)
  (let (n (length lst))
    (setq
          circ-list:items (array n lst)
          circ-list:i 0
          circ-list:end n)))
; valore elemento corrente della lista circolare (con avanzamento)
(define (circ-list:next)
  (cond ((= circ-list:i circ-list:end)
          (setq circ-list:i 0)
          (++ circ-list:i)
          (circ-list:items (- circ-list:i 1)))
        (true
          (++ circ-list:i)
          (circ-list:items (- circ-list:i 1)))))
; valore elemento corrente della lista circolare (senza avanzamento)
(define (circ-list:cur) (circ-list:items (- circ-list:i 1)))
; indice del prossimo elemento della lista circolare
(define (circ-list:index) circ-list:i)
; lunghezza della lista circolare
(define (circ-list:len) circ-list:end)
;valore della lista circolare
(define (circ-list:values) circ-list:items)
; ritorniamo al contesto principale
(context MAIN)

Adesso definiamo la nostra funzione per generare sequenze:

(define (sequenza start n val-lst op)
  (local (out val)
    ; inizializziamo la lista circolare
    (circ-list:init val-lst)
    (setq out (list start))
    (setq val start)
    (while (<= val n) ; calcola qualche elemento di troppo...
      (setq val ((eval op) val (circ-list:next)))
      (push val out -1)
    )
    ; ...elimina gli elementi di troppo.
    (filter (fn(x) (<= x n)) out)))

Verifichiamo la funzione con la sequenza iniziale:

(sequenza 1 100001 '(5 2) '*)
;-> (1 5 10 50 100 500 1000 5000 10000 50000 100000)

Adeesso possiamo generare altre sequenze:

(sequenza 1 10 '(2 1) '+)
;-> (1 3 4 6 7 9 10)
(sequenza 10 200 '(2 1) '*)
;-> (10 20 20 40 40 80 80 160 160)

Non possiamo utilizzare gli operatori aritmetici "-" e "/" perchè non permettono di definire un limite per n. Però possiamo definire un'altra funzione che genera una sequenza di n numeri (invece che fino al numero n).

(define (sequenza-n start num val-lst op)
  (local (out val)
    ; inizializziamo la lista circolare
    (circ-list:init val-lst)
    (setq out (list start))
    (setq val start)
    (for (i 2 num)
      (setq val ((eval op) val (circ-list:next)))
      (push val out -1)
    )
    out))

(sequenza-n 1 7 '(2 1) '+)
;-> (1 3 4 6 7 9 10)

(sequenza-n 10 9 '(2 1) '*)
;-> (10 20 20 40 40 80 80 160 160)

(sequenza-n 10 9 '(2 1) '-)
;-> (10 8 7 5 4 2 1 -1 -2)

(sequenza-n 1000 9 '(4 3) '/)
;-> (1000 250 83 20 6 1 0 0 0)

(sequenza-n 0 10 '(1 2 3) '+)
;-> (0 1 3 6 7 9 12 13 15 18)


-----------
Massimo gap
-----------

Data una lista non ordinata di interi positivi, trovare la differenza massima tra gli elementi successivi nella sua forma ordinata e gli indici dei relativi valori. Restituire la differenza massima, gli indici dei relativi valori e la lista ordinata.

Funzione che applica un operatore matematico ad ogni coppia di elementi di una lista:

(define (do-pair lst func rev)
  (if rev
      (map func (chop lst) (rest lst))
      (map func (rest lst) (chop lst))))

(do-pair '(1 4 5 10 12) -)
;-> (3 1 5 2)

Funzione che restituisce il valore massimo di una lista e il relativo indice:

(define (max-with-idx lst)
  (let ((m -1) (i nil))
    (dolist (el lst)
      (if (> el m) (setq m el i $idx))
    )
    (list m i)))

(max-with-idx '(3 1 5 2))
;-> (5 2)

Funzione che trova la soluzione finale:

(define (max-gap lst)
  (let (out (max-with-idx (do-pair (sort lst) -)))
    (list (push (+ (last out) 1) out -1) lst)))

(max-gap '(1 5 12 10 4))
;-> ((5 2 3) (1 4 5 10 12))


-------------------------
Simulazione di un cannone
-------------------------

Vediamo come simulare la traiettoria di una palla sparata da un cannone.
Impostiamo i parametri della simulazione 2D:

x     -> valore corrente della posizione della palla lungo direzione orizzontale
z     -> valore corrente della posizione della palla lungo direzione verticale
theta -> angolo del cannone (in gradi) con la direzione orizzontale (asse x)
vel   -> velocità della palla dove vel = |v| (magnitudine)
vx    -> velocità lungo l'asse x dove vx = |v|·cos(theta)
vz    -> velocità lungo l'asse z dove vz = |v|·sin(theta)
t     -> valore corrente del tempo
g     -> accelerazione di gravità dove  g = -9.81
dt    -> intervallo di tempo tra due posizioni
quota -> altezza del cannone

Inoltre la palla di cannone parte al tempo t = 0 con coordinate (x=0 z=0), ma possiamo specificare anche un'altezza di lancio (quota).

Rappresentiamo la traiettoria con un lista del tipo seguente:

((t0 x0 z0) (t1 x1 z1) ... (tn xn zn))

dove (ti xi zi) rappresenta la i-esima posizione della palla (al tempo ti nella posizione (xi zi)).
Da notare che zn deve risultare uguale (o poco minore) a zero.

Rappresentazione 2D:

   z
   |
   |  direzione di tiro del cannone
   |    /
   |   /
   |  /
   | /
   |/ theta = angolo del cannone con asse x
 0 +---------------------x
   0

Traiettoria del proiettile:

   z
   |              *
   |         *         *
   |      *               *
   |   *                     *
   | *                         *
 0 +--------------------------------x
   0

Per calcolare la simulazione utilizzeremo il metodo di Eulero che consiste nell'iniziare con un valore iniziale di una quantità (come la posizione) e un'equazione che descrive le sue derivate (come la velocità e l'accelerazione). Il calcolo delle derivate ci permette di aggiornare i valori passo per passo. Maggiori spiegazioni nei commenti della funzione.

(define (cannone vel theta quota dt g)
  (local (ts xs zs vx vz t x z)
    ; liste che contengono tutti i valori della traiettoria (x, z, t)
    (setq ts '() xs '() zs '())
    ; calcola la velocita iniziale x (converte theta in radianti)
    ; (vx = 0 quando theta = 90)
    (if (= theta 90)
        (setq vx 0)
        (setq vx (mul vel (cos (div (mul 3.1415926535897931 theta) 180))))
    )
    ; calcola la velocita iniziale z (converte theta in radianti)
    ; (vz = 0 quando theta = 0 o 180)
    (if (or (= theta 0) (= theta 180))
        (setq vz 0)
        (setq vz (mul vel (sin (div (mul 3.1415926535897931 theta) 180))))
    )
    ;(println "vx =" vx)
    ;(println "vz =" vz)
    ;(read-line)
    ; initializza tempo, posizione x, posizione z
    (setq t 0 x 0 z quota)
    (while (>= z 0)
      ; aggiorna il tempo
      (setq t (add t dt))
      ; aggiorna la velocita vz (la velocita vx non cambia)
      (setq vz (add vz (mul g dt)))
      ; aggiorna la posizione x
      (setq x (add x (mul vx dt)))
      ; aggiorna la posizione z
      (setq z (add z (mul vz dt)))
      ; inserisce i valori correnti nelle liste
      (push t ts -1)
      (push x xs -1)
      (push z zs -1)
    )
    (map list ts xs zs)))

Vediamo alcuni esempi riportando solo l'ultima riga della lista:

(cannone 20 30 0 0.01 -9.81)
;-> (2.030000000000001 35.16063139364815 -0.01258599999999832))

(cannone 20 45 0 0.01 -9.81)
;-> (2.879999999999983 40.72935059634507 -0.0959454036549173))

(cannone 20 60 0 0.01 -9.81)
;-> (3.529999999999969 35.30000000000023 -0.1524674928186893))

Spariamo all'indietro (theta = 135):

(cannone 20 135 0 0.01 -9.81)
;-> (2.879999999999983 -40.72935059634507 -0.09594540365491522))

Spariamo in verticale (theta = 90):

(cannone 20 90 0 0.01 -9.81)
;-> (4.069999999999958 0 -0.0504679999999175))

Spariamo in orizzontale (theta = 0):

(cannone 20 0 0 0.01 -9.81)
;-> ((0.01 0.2 -0.0009810000000000001))
In questo caso abbiamo un solo elemento nella lista.

Spariamo in orizzontale (theta = 180):

(cannone 20 180 0 0.01 -9.81)
;-> ((0.01 0.2 -0.0009810000000000001))
In questo caso abbiamo un solo elemento nella lista.

Per visualizzare la traiettoria utilizziamo il modulo "plot.lsp" che permette di creare alcuni tipi di grafici.
Questo modulo utilizza guiserver.jar che deve essere installato sulla cartella di newLISP.

Importiamo il modulo:

(module "plot.lsp")

Adesso scriviamo la funzione che visualizza la traiettoria del proiettile:

(define (plot-tra lst-txz theta)
  (local (xx zz)
    ; azzera parametri della funzione plot
    (plot:reset)
    ; opzionale title, sub-title, labels e legend, data min/max per Y
    (set 'plot:title "Simulazione cannone")
    (set 'plot:sub-title (string "Angolo = " theta))
    (set 'plot:unit-x "distanza")
    (set 'plot:unit-y "quota")
    ; crea il file dei dati (lista dei valori x e lista dei valori z)
    (setq xx '())
    (setq zz '())
    (dolist (el lst-txz)
      (push (first (rest el)) xx -1)
      (push (last el) zz -1 ))
    ; plot data
    (plot:XY xx zz)
    ; salva il plot su un file
    (plot:export (string "traiettoria-" theta ".png"))))

Proviamo a creare alcuni grafici:

(plot-tra (cannone 20 30 0 0.01 -9.81) 30)

(plot-tra (cannone 20 45 0 0.01 -9.81) 45)

(plot-tra (cannone 20 60 0 0.01 -9.81) 60)

Spariamo da una altezza di 10 metri:

(plot-tra (cannone 20 45 10 0.01 -9.81) 40)

Le immagini dei grafici si trovano nella cartella "data".

Per sparare dalla luna occorre cambiare il valore dell'accelerazione gravitazionale.


--------------------------------
Ottimizzare il taglio di un tubo
--------------------------------

Data un tubo di acciaio di una certa lunghezza e una lista di prezzi per ogni lunghezza, come dovremmo tagliare il tubo in modo da massimizzare il profitto (ogni taglio deve produrre due tubi con lunghezze intere). Ad esempio:

Lunghezza 1 2 3 4  5  6  7  8
Prezzo    1 5 8 9 10 17 18 20

con un tubo di lunghezza 4, il valore è 9. Se tagliamo il tubo in due abbiamo due tubi lunghi 1 che valgono 5+5 = 10.
Ma non siamo sicuri se quest'ultima sia la soluzione ottimale oppure no, perché non abbiamo visto tutti i valori possibili.
La tabella seguente elenca tutti i modi possibili di tagliare il tubo e il relativo valore ottenuto:

Lunghezza delle parti     Valore totale
4                         9
1, 3                      1 + 8 = 9
1, 1, 2                   1 + 1 + 5 = 7
1, 1, 1, 1                1 + 1 + 1 + 1 = 4
2, 2                      5 + 5 = 10

La prima soluzione utilizza la tecnica della ricorsione.
La soluzione ricorsiva si basa sul calcolo di tutte le possibili combinazioni e dei valori associati a ciascuna combinazione e restituisce il massimo di tutti questi valori.

La lista lst-val contiene il valore di ogni lunghezza.
La variabile len contierne la lunghezza totale del tubo.
Occorrono tanti valori di lst-val fino alla lunghezza len.

Versione ricorsiva:

(define (tubo-r lst-val len)
  (local (maxval)
  (cond ((<= len 0) 0)
        (true
          (setq maxval -99999999)
          (for (i 0 (- len 1))
            (setq maxval (max maxval (+ (lst-val i) (tubo-r lst-val (- len i 1)))))
          )))))

(tubo-r '(1 5 8 9) 4)
;-> 10 (un pezzo lungo 2 e un pezzo lungo 2 --> 5 + 5 = 10)
(tubo-r '(1 5) 2)
;-> 5 (un pezzo lungo 2 --> 5)
(tubo-r '(1 5 8 9 10 17 18 20) 8)
;-> 22 (un pezzo lungo 2 e un pezzo lungo 6 --> 5 + 17 = 22)

Questa funzione fornisce il risultato corretto, ma calcoliamo alcuni valori di maxval diverse volte. Questo comporta che occorre un tempo esponenziale per ottenere la soluzione.

Vediamo la velocità della funzione:

(time (tubo-r '(1 5 8 9 10 17 18 20) 8) 10000)
;-> 939.16

La seconda soluzione usa la tecnica memoization.
Con la memoization memorizziamo il risultato del sottoproblema quando viene calcolato la prima volta e quindi riutilizziamo questo risultato quando incontriamo lo stesso sottoproblema. Per memorizzare i risultati dei sottoproblemi utilizziamo una lista maxval di lunghezza len. L'indice i-esimo di questa lista contiene il maxval per un tubo di lunghezza i. Prima di calcolare il maxval per la lunghezza i, verrà verificato nella lista se il valore per i è già calcolato o meno. Se il valore esiste nella lista, allora viene restituito e non viene calcolato di nuovo.
La funzione restituisce il valore massimo e la lista maxval.

Versione memoization:

(define (tubo-aux lst-val len)
  (cond ((<= len 0) 0)
        ((!= (maxval (- len 1)) 0) (maxval (- len 1)))
        (true
          (setf (maxval (- len 1)) -99999999)
          (for (i 0 (- len 1))
            (setf (maxval (- len 1)) (max (maxval (- len 1)) (+ (lst-val i) (tubo-aux lst-val (- len i 1)))))
          )
          (maxval (- len 1)))))

(define (tubo-m lst-val len)
  (let (maxval (dup 0 len))
  (tubo-aux lst-val len)
  (list (maxval (- len 1)) maxval)))

(tubo-m '(1 5) 2)
;-> (5 (1 5)) (un pezzo lungo 2 --> 5)

(tubo-m '(1 5 8 9 10 17 18 20) 8)
;-> (22 (1 5 8 10 13 17 18 22)) (un pezzo lungo 2 e un pezzo lungo 6 --> 5 + 17 = 22)

Questa funzione impiega un tempo polinomiale per calcolare la soluzione, ma non è ancora ottimizzato perché utilizza la ricorsione.

Vediamo la velocità della funzione:

(time (tubo-m '(1 5 8 9 10 17 18 20) 8) 10000)
;-> 174.101

La seconda soluzione usa la tecnica chiamata programmazione dinamica.
In questo caso risolviamo il problema partendo da una lunghezza 0 e ci muoviamo in avanti fino alla lunghezza len.

Versione programmazione dinamica:

(define (tubo-dp lst-val len)
  (let (maxval (dup 0 (+ len 1)))
    (setf (maxval 0) 0)
    (for (i 1 len)
      (setf (maxval i) -99999999)
      (for (j 0 (- i 1))
        (setf (maxval i) (max (maxval i) (+ (lst-val j) (maxval (- i j 1)))))
      )
    )
    (list (maxval len) maxval)))

(tubo-dp '(1 5) 2)
;-> (5 (0 1 5))

(tubo-dp '(1 5 8 9 10 17 18 20) 8)
;-> (22 (0 1 5 8 10 13 17 18 22))

Nell'ultimo esempio abbiamo:

Lunghezza 1 2 3 4  5  6  7  8
Prezzo    1 5 8 9 10 17 17 20

Con la lista maxval che contiene i seguenti valori:

Lunghezza 0 1 2 3 4  5  6  7  8
Prezzo    0 1 5 8 10 13 17 18 22

Questa funzione ha una complessità O(n^2) ed è più veloce delle soluzioni ricorsive precedenti.

Vediamo la velocità della funzione:

(time (tubo-dp '(1 5 8 9 10 17 18 20) 8) 10000)
;-> 76.795


--------------------------------------
Generazione automatica di una hash-map
--------------------------------------

Per generare automaticamente una hash-map utilizziamo la funzione "uuid" che costruisce e ritorna un identificatore unico (stringa) chiamato UUID (Universally Unique IDentifier).

(uuid)
;-> "3FD45C9C-1313-4ACF-B720-C42CF6319E0C"

Purtroppo non è un simbolo legale per newLISP (perchè inizia con un numero):

(legal? (uuid))
;-> nil

Allora scriviamo una funzione per generare un simbolo univoco legale:

(define (gensym)
  (sym (string "g-" (uuid)))) ; 'g-*** è un simbolo legale

(gensym)
;-> g-7E31347F-6EEB-477E-BFF0-4868BE374F6B

Adesso possiamo generare una hash-map univoca ed associarla ad una variabile:

(setq hash (new Tree (gensym) true))

In questo modo possiamo usare tutte le operazioni delle hash-map utilizzando la variabile.

Inserimento di un valore 1 (value) associato ad una chiave K (key) -> (myHash "key" value):
(hash "K" 1)
;-> 1

Recuperiamo il valore tramite la chiave:
(hash "K")
;-> 1

Inserimento di un nuovo valore 2 (value) associato ad una chiave W (key) -> (hash "key" value):
(hash "W" 2)
;-> 2

Elenco di tutti gli elementi (chiave valore) della hashmap:
(hash)
;-> (("K" 1) ("W" 2))

Se una chiave non esiste, allora newLISP restituisce nil:
(hash "X")
;-> nil

Per eliminare un valore occorre assegnare il valore nil:
(hash "K" nil)
;-> nil
(hash)
;-> (("W" 2))

Aggiorniamo il valore associato ad una chiave esistente ($it = valore precedente):
(hash "W" (+ $it 3))
;-> 5
(hash)
;-> (("W" 5))

Eliminiamo la hash-map:
;(delete 'hash)
(delete (quote hash))
;-> true

Verifichiamo che la hash-map non esiste più:
(hash)
;-> ERR: invalid function : (hash)

=============================================================================

===============

 NOTE LIBERE 3

===============

---------------------------------
Generazione di un simbolo univoco
---------------------------------

Se abbiamo la necessità di generare un simbolo univoco utilizziamo la funzione "uuid" che costruisce e ritorna un identificatore unico (stringa) chiamato UUID (Universally Unique IDentifier).

(uuid)
;-> "3FD45C9C-1313-4ACF-B720-C42CF6319E0C"

Purtroppo non è un simbolo legale per newLISP (perchè inizia con un numero):

(legal? (uuid))
;-> nil

Allora scriviamo una funzione per generare un simbolo univoco legale:

(define (gensym)
  (sym (string "g-" (uuid)))) ; 'g-*** è un simbolo legale

(gensym)
;-> g-7E31347F-6EEB-477E-BFF0-4868BE374F6B
(gensym)
;-> g-4DE95DAB-4A11-431F-9EBE-D267E9646C4C
(gensym)
;-> g-5ECA1A6B-6E8B-4ADB-9189-D352CE488876

La funzione "gensym" genera sempre un simbolo univoco.


------------------------------
Compromessi tra tempo e spazio
------------------------------

Supponiamo di dover scrivere una funzione che verifica se ci sono duplicati in una lista.
Il primo metodo che viene in mente è quello di attraversare la lista con due cicli e verificare se i valori correnti sono uguali.

(define (dup1? lst)
  (let ((found nil) (idx1 -1) (idx2 -1))
    (dolist (el1 lst)
      (setq idx1 $idx)
      (dolist (el2 lst)
        (setq idx2 $idx) ;per semplicità
        (if (and (!= idx1 idx2) (= el1 el2))
            (setq found true))))
    found))

(dup1? '(1 2 3 4 5 6 7 8 9 10 11 1))
;-> true
(dup1? '(1 1 2 3 4 5 6 7 8 9 10 11))
;-> true
(dup1? '(1 2 3 4 5 6 7 8 9 10 11 12))
;-> nil

Il tempo di esecuzione non dipende dall'ordine dei valori nella lista.

(time (dup1? '(1 2 3 4 5 6 7 8 9 10 11 1)) 100000)
;-> 1458.268
(time (dup1? '(1 1 2 3 4 5 6 7 8 9 10 11)) 100000)
;-> 1444.711
(time (dup1? '(1 2 3 4 5 6 7 8 9 10 11 12)) 100000)
;-> 1443.694

Questa funzione ha complessità temporale O(n^2).
Possiamo migliorare la velocità della funzione uscendo dal ciclo quando incontriamo la prima coppia di valori uguali. Per fare questo aggiungiamo la condizione "found" ad ogni ciclo "dolist":

(define (dup2? lst)
  (let ((found nil) (idx1 -1) (idx2 -1))
    (dolist (el1 lst found) ;esce dal ciclo quando found diventa true
      (setq idx1 $idx)
      (dolist (el2 lst found) ;esce dal ciclo quando found diventa true
        (setq idx2 $idx) ;per semplicità
        (if (and (!= idx1 idx2) (= el1 el2))
            (setq found true))))
    found))

(dup2? '(1 2 3 4 5 6 7 8 9 10 11 1))
;-> true
(dup2? '(1 1 2 3 4 5 6 7 8 9 10 11))
;-> true
(dup2? '(1 2 3 4 5 6 7 8 9 10 11 12))
;-> nil

Questa funzione ha complessità temporale che varia a seconda che la lista contenga duplicati o meno. Quando ci sono duplicati ha complessità temporale O(n), viceversa, quando non ci sono duplicati ha complessità temporale O(n^2). Comunque la complessità temporale vale O(n^2), anche se la funzione è (in media) più veloce.

(time (dup2? '(1 2 3 4 5 6 7 8 9 10 11 1)) 100000)
;-> 147.633
(time (dup2? '(1 1 2 3 4 5 6 7 8 9 10 11)) 100000)
;-> 55.011 ; più veloce perchè il duplicato (1) si trova all'inizio della lista
(time (dup2? '(1 2 3 4 5 6 7 8 9 10 11 12)) 100000)
;-> 1507.185

Possiamo scrivere un'altra funzione che utilizza una hash-map:

(define (dup3? lst)
  (let ((found nil))
    (new Tree 'myHash)
    (dolist (el lst found)
      ; se l'elemento corrente non esiste nella hash-map...
      (if (nil? (myHash el))
          (myHash el el)    ; allora inseriscilo
          (setq found true) ; altrimenti è un duplicato
      )
    )
    (delete 'myHash) ; eliminiamo l'hash-map
    found))

(dup3? '(1 2 3 4 5 6 7 8 9 10 11 1))
;-> true
(dup3? '(1 1 2 3 4 5 6 7 8 9 10 11))
;-> true
(dup3? '(1 2 3 4 5 6 7 8 9 10 11 12))
;-> nil

Questa funzione ha complessità temporale O(n) poichè utilizza soltanto un ciclo (supponendo che le operazioni di "get" e "put" della hash-map siano O(1)).
Vediamo i tempi di esecuzione:

(time (dup3? '(1 2 3 4 5 6 7 8 9 10 11 1)) 100000)
;-> 1096.76
(time (dup3? '(1 1 2 3 4 5 6 7 8 9 10 11)) 100000)
;-> 675.509
(time (dup3? '(1 2 3 4 5 6 7 8 9 10 11 12)) 100000)
;-> 1121.185

Come mai i tempi di esecuzione sono sono superiori di quelli della funzione "dup2?" ?
Il problema si trova nell'operazione di cancellazione della hash-map che richiede tanto tempo. Possiamo evitare la cancellazione se generiamo ogni volta una hash-map diversa (vedi la sezione "Generazione automatica di una hash-map"):

Funzione per creare un simbolo legale in newLISP:

(define (gensym)
  (sym (string "g-" (uuid))))

(define (dup4? lst)
  (let ((found nil) (hm nil))
    ;(new Tree 'myHash)
    (setq hm (new Tree (gensym) true))
    (dolist (el lst found)
      ; se l'elemento corrente non esiste nella hash-map...
      (if (nil? (hm el))
          (hm el el)    ; allora inseriscilo
          (setq found true) ; altrimenti è un duplicato
      )
    )
    ;(delete 'myHash) ; non eliminiamo l'hash-map
    found))

(dup4? '(1 2 3 4 5 6 7 8 9 10 11 1))
;-> true
(dup4? '(1 1 2 3 4 5 6 7 8 9 10 11))
;-> true
(dup4? '(1 2 3 4 5 6 7 8 9 10 11 12))
;-> nil

Questa funzione, come la precedente, ha complessità temporale O(n), ma impiega funzioni primitive complesse (es. uuid) che rallentano l'esecuzione:

(time (dup4? '(1 2 3 4 5 6 7 8 9 10 11 1)) 100000)
;-> 730.16
(time (dup4? '(1 1 2 3 4 5 6 7 8 9 10 11)) 100000)
;-> 349.212
(time (dup4? '(1 2 3 4 5 6 7 8 9 10 11 12)) 100000)
;-> 803.067

Possiamo scrivere un'altra funzione utilizzando la funzione integrata "sort":

(define (dup5? lst)
  (let (found nil)
    (sort lst)
    (for (i 0 (- (length lst) 2))
      (if (= (lst i) (lst (+ i 1)))
          (setq found true)))
    found))

(dup5? '(1 2 3 4 5 6 7 8 9 10 11 1))
;-> true
(dup5? '(1 1 2 3 4 5 6 7 8 9 10 11))
;-> true
(dup5? '(1 2 3 4 5 6 7 8 9 10 11 12))
;-> nil

Questa funzione ha complessità temporale O(n*log(n)) in quanto l'operazione di sort ha complessità O(n*log(n)) (il ciclo for aumenta i tempi di esecuzione, ma non modifica la complessità):

(time (dup5? '(1 2 3 4 5 6 7 8 9 10 11 1)) 100000)
;-> 154.001
(time (dup5? '(1 1 2 3 4 5 6 7 8 9 10 11)) 100000)
;-> 156.054
(time (dup5? '(1 2 3 4 5 6 7 8 9 10 11 12)) 100000)
;-> 155.701

Infine, utilizziamo la funzione integrata "unique" per scrivere un'altra funzione:

(define (dup6? lst) (!= (unique lst) lst))

(dup6? '(1 2 3 4 5 6 7 8 9 10 11 1))
;-> true
(dup6? '(1 1 2 3 4 5 6 7 8 9 10 11))
;-> true
(dup6? '(1 2 3 4 5 6 7 8 9 10 11 12))
;-> nil

Per capire la complessità temporale di questa funzione occorrerebbe analizzare i sorgenti di newLISP, ma dovrebbe essere simile a O(n*log(n). Vediamo i tempi di esecuzione:

(time (dup6? '(1 2 3 4 5 6 7 8 9 10 11 1)) 100000)
;-> 96.755
(time (dup6? '(1 1 2 3 4 5 6 7 8 9 10 11)) 100000)
;-> 93.268
(time (dup6? '(1 2 3 4 5 6 7 8 9 10 11 12)) 100000)
;-> 96.36

Adesso vediamo la complessità spaziale delle funzioni, considerando lo spazio addizionale che viene richiesto.
Le funzioni "dup1?" e "dup2?" non richiedono spazio aggiuntivo in memoria, quindi la complessità spaziale vale O(1).
La funzione "dup3?" richiede una hash-map con n valori, quindi la complessità spaziale vale O(n).
La funzione "dup4?" richiede una hash-map con n valori per n volte (perchè ogni volta creiamo una hash-map diversa), quindi la complessità spaziale vale O(n^2).
Presumiamo che le funzioni "dup5?" e "dup6?" abbiano una complessità spaziale O(log(n)) (questa è la complessità spaziale dell'algoritmo di ordinamento Quicksort).

Ricapitoliamo le caratteristiche delle funzioni:

           Complessità   Tempi             Complessità
Funzione   temporale     di esecuzione     spaziale
 dup1?      O(n^2)        1458 1444 1443    O(1)
 dup2?      O(n^2)         147   55 1507    O(1)
 dup3?      O(n)          1096  675 1121    O(n)
 dup4?      O(n)           730  349  803    O(n^2)
 dup5?      O(n*log(n))    154  156  155    O(log(n))
 dup6?      O(n*log(n))     96   93   96    O(log(n))

Quindi per scrivere una funzione efficiente in termini di tempo di esecuzione l'algoritmo è molto importante, ma occorre preferire l'uso di funzioni integrate (se presenti). Un'altra considerazione fondamentale riguarda lo spazio di memoria utilizzato in quanto non sempre la funzione più veloce è anche quella che consuma meno spazio. La scelta della funzione finale dipende dall'analisi e dalla valutazione di queste caratteristiche.


----------------
Scambio di somme
----------------

Date due liste di numeri interi i cui relativi elementi sommano ad una certa cifra, determinare due numeri (ognuno in una lista) che scambiati tra loro producono somme uguali per le due liste. Esempio:

lista1: (5 3 2 9 1)  Somma = 5 + 3 + 2 + 9 + 1 = 20
lista2: (1 12 5)     Somma = 1 + 12 + 5 = 18

Scambiando il numero 2 della lista1 con il numero 1 della lista2 entrambe le liste sommano a 19.

Se non è possibile ottenere due liste con somme uguali allora la funzione deve restituire nil.

La soluzione più semplice è quella di utilizzare due cicli che attraversano le liste e verificare se scambiando gli elementi correnti si ottengono due somme uguali per le liste.

(define (scambio lst1 lst2)
  (local (out idx1 idx2 found)
    (setq out nil found nil)
    (dolist (el1 lst1 found)
      (setq idx1 $idx)
      (dolist (el2 lst2 found)
        (setq idx2 $idx)
        ; se scambiando questi valori le somme sono uguali...
        (if (= (+ (- (apply + lst1) el1) el2) (+ (- (apply + lst2) el2) el1))
            ; allora salviamo gli indici
            (setq out (list idx1 idx2) found true)
        )
      )
    )
    (if (nil? out) out
        (begin
        (swap (lst1 (first out)) (lst2 (last out)))
        (setq out (list out (apply + lst1) (apply + lst2)))))
    out))

(scambio lst1 lst2)
;-> ((2 0) 19 19)

(scambio '(1 -1 2 4) '(2 3 4 -1))
;-> ((0 0) 7 7)

(scambio '(1 -1 2 5) '(2 3 8 -1))
;-> nil

La complessità temporale vale O(n*m), dove n e m sono le lunghezze delle liste.

Per cercare un algoritmo migliore dobbiamo analizzare alcuni casi:

(setq lst1 '(5 3 3 7))  Somma = 18
(setq lst2 '(4 1 1 6))  Somma = 12
(scambio lst1 lst2)
;-> ((3 0) 15 15)
Scambiamo il 7 con il 4:
(setq lst1 '(5 3 3 4))  Somma = 15
(setq lst2 '(7 1 1 6))  Somma = 15

(setq lst1 '(1 2 3 4 5)) Somma = 15
(setq lst2 '(6 7 8))     Somma = 21
(scambio lst1 lst2)
;-> ((2 0) 18 18)
Scambiamo il 3 con il 6:
(setq lst1 '(1 2 6 4 5)) Somma = 18
(setq lst2 '(3 7 8))     Somma = 18

(setq lst1 '(10 15 20)) Somma = 45
(setq lst2 '(5 30))     Somma = 35
(scambio lst1 lst2)
;-> ((0 0) 40 40)
Scambiamo il 10 con il 5:
(setq lst1 '(5 15 20))  Somma = 40
(setq lst2 '(10 30))    Somma = 40

Possiamo notare queste caratteristiche:

1) per ottenere somme uguali, la lista con la somma più grande deve scambiare un numero maggiore con un numero minore della lista con la somma più piccola.

2) Lo scambio provoca una modifica delle somme della stessa quantità (dopo lo scambio la somma di una lista vale (somma-iniziale + x) e la somma dell'altra lista vale (somma_iniziale - x)

3) Dopo lo scambio le somme delle liste sono la media delle somme iniziali:
(somma = somma-iniziale-lista1 + somma-iniziale-lista2)/2
Poichè le liste contengono solo numeri interi, allora la differenza delle somme deve essere un numero pari (altrimenti la divisione per 2 produrrebbe un numero con la virgola).

Facciamo un esempio e applichiamo la terza caratteristica:

lst1 = (5 3 3 7)  Somma = 18
lst2 = (4 1 1 6)  Somma = 12

La media tra le due somme vale: (18 + 12)/2 = 15. In altre parole, la lista1 deve diminuire di 3 e la lista2 deve aumentare di 3. Questo accade quando la differenza tra l'elemento della lista1 e l'elemento della lista2 vale 3.
Anche in questo modo dobbiamo sempre utilizzare due cicli per attraversare le liste, notiamo una differenza: questa volta non dobbiamo verificare l'uguaglianza delle somme, ma verificare se esiste un numero predeterminato sulla lista2. Infatti, per esempio, quando abbiamo il numero 5 della lista1, allora dobbiamo cercare se esiste il numero (5 - 3) = 2 nella lista2.
Questo fatto ci permette di utilizzare una hash-map con i valori della lista2, dove la chiave è il numero e l'indice è l'indice del numero nella lista.

Funzione che copia una lista in una hash-map dove la chiave della hash-map è il valore dell'elemento della lista e l'indice della hash-map è l'indice dell'elemento della lista:

(define (list-hashmap lst hash)
  (dolist (el lst) (hash (string el) $idx)))

(new Tree 'myhash)
(setq lst '(10 15 20 35))

(list-hashmap lst myhash)
;-> 3
(myhash)
;-> (("10" 0) ("15" 1) ("20" 2) ("35" 3))

Oppure (più velocemente):

(myhash (map (fn(x) (list x $idx)) lst))

Esempio di ricerca di un valore:

(myhash "10")
;-> 0
(myhash 10)
;-> 0
(myhash "11")
;-> nil
(myhash 11)
;-> nil

Proviamo a scrivere la nuova funzione:

(define (scambio2 lst1 lst2)
  (local (out sum1 sum2 gap val found)
    (setq sum1 (apply + lst1))
    (setq sum2 (apply + lst2))
    (cond ((odd? (+ sum1 sum2)) (setq out nil))
          (true
            (new Tree 'myhash) ; crea hash-map
            (myhash (map (fn(x) (list x $idx)) lst2))     ; copia lista2 su hash-map
            ;(dolist (el lst2) (myhash (string el) $idx)) ; copia lista2 su hash-map
            ;(println (myhash))
            (setq gap (/ (- sum1 sum2) 2))
            (setq out nil found nil)
            (dolist (el1 lst1 found)
              ;(println "elemento: " el1 " --- cerco: " (- el1 gap))
              (setq val (myhash (string (- el1 gap))))
              ;(println "trovato: " val)
              (if val (setq out (list $idx val) found true))
            )
            (if (nil? out) out
                (begin
                (swap (lst1 (first out)) (lst2 (last out)))
                (setq out (list out (apply + lst1) (apply + lst2)))))
            (delete 'myhash)
          )
    )
    out))

(setq lst1 '(5 3 3 7))
(setq lst2 '(4 1 1 6))
(scambio2 lst1 lst2)
;-> ((3 0) 15 15)

(setq lst1 '(1 2 3 4 5))
(setq lst2 '(6 7 8))
(scambio2 lst1 lst2)
;-> ((2 0) 18 18)

(setq lst1 '(10 15 20))
(setq lst2 '(5 30))
(scambio2 lst1 lst2)
;-> ((0 0) 40 40)

Vediamo la velocità delle due funzioni:

(setq lst1 '(sequence 1 1000))

(apply + (sequence 1 1000))
;-> 500500

(apply + (sequence -110 1010))

(/ (- (apply + (sequence 1 1000)) (apply + (sequence -150 1010))) 2)

(setq lst1 (sequence 1 50))
(setq lst2 (sequence -50 71))

(time (scambio lst1 lst2) 10000)
;-> 1095.098
(time (scambio2 lst1 lst2) 10000)
;-> 767.13

Questa funzione ha complessità temporale O(n+m) ed è più veloce nonostante la necessità di copiare la lista sulla hash-map e di eliminare la hash-map.


---------------------------------
Evitare begin nella condizione if
---------------------------------

L'istruzione "if" ha la seguente sintassi:

(if (exp-condition)
    (expression-when-true)
    (expression-when-nil)
)

Se dobbiamo usare più di una espressione in (expression-when-true) oppure in (expression-when-nil) dobbiamo utilizzare la parola riservata "begin":

(if (exp-condition)
    (begin
      (expression1-when-true)
      (expression2-when-true)
      ...
      (expressionN-when-true)
    )
    (begin
      (expression1-when-nil)
      (expression2-when-nil)
      ...
      (expressionN-when-nil)
    )
)

In alcuni casi possiamo evitare l'uso di "begin".

Ad esempio se le espressioni sono limitate a pochi assegnamenti di variabili possiamo usare l'assegnamento multiplo di "setq":

(setq val1 10 val2 -3 val3 "a")

In questo modo "setq" racchiude tutte le assegnazioni in un'unica espressione che non necessita di "begin".

Oppure, se le espressioni che dobbiamo eseguire sono diverse tra loro, allora possiamo usare la funzione "let" o "letn":

(let ((a 10) (b 20) (c 30))
     (++ a)
     (if (> a b) (setq c (+ a b c)))
     ...
)

In questo modo "let" racchiude tutte le espressioni in un'unica espressione che non necessita di "begin".


----------------------------
Frazioni continue (funzioni)
----------------------------

Funzione che calcola i primi n termini della frazione continua di un numero:

(define (num2cf x n)
  (local (cf xi stop)
    (setq cf '())
    (setq stop nil)
    (for (k 0 (- n 1) 1 stop)
      (setq xi (floor x))
      (push xi cf -1)
      (if (zero? (sub x xi) )
          (setq stop true)
          (setq x (div 1 (sub x xi)))
      )
    )
    cf))

Facciamo alcune prove:

(num2cf (sqrt 2) 10)
;-> (1 2 2 2 2 2 2 2 2 2)

(setq PI 3.1415926535897931)
(num2cf PI 25)
;-> (3 7 15 1 292 1 1 1 2 1 3 1 14 3 3 23 1 1 7 4 35 1 1 1 2)

(num2cf 1.5 10)
;-> (1 2)
(num2cf 0.5 10)
;-> (0 2)
(num2cf 2 10)
;-> (2)

Il prossimo esempio produce un risutato errato a causa degli arrotondamenti dei numeri in virgola mobile:

(num2cf 3.245 10)
;-> (3 4 12 3 1 247777268231 4 1 2 1)

Funzione che calcola tutti i termini della frazione continua di una frazione:

(define (fract2cf a b)
  (local (fc r out)
    (setq out '())
    (while (!= 0 r)
      (setq r (% a b))
      (setq fc (/ a b))
      (push fc out -1)
      (setq a b)
      (setq b r)
    )
    out))

(fract2cf 3245 1000)
;-> '(3 4 12 4)

(fract2cf 31415926535897931 10000000000000000)
;-> (3 7 15 1 292 1 1 1 2 1 3 1 14 3 2 2 1 1 1 1 2 2 12 24 1 1 6 2 4 1 3 3)

Funzione che calcola il numero di una frazione continua:

(define (cf2num cf)
  (local (x)
    (cond ((= (length cf) 1) (setq x (first cf)))
          (true
           (setq x (cf -1))
           (for (k (- (length cf) 2) 0 -1)
             (setq x (add (cf k) (div 1 x)))
           )))
    x))

Facciamo alcune prove:

(cf2num '(1 2 2 2 2 2 2 2 2 2))
;-> 1.41421362489487
(sqrt 2)
;-> 1.414213562373095

(cf2num '(3 7 15 1 292 1 1 1 2 1 3 1 14 3 3 23 1 1 7 4 35 1 1 1 2))
;-> 3.141592653589793

(cf2num '(1 2))
;-> 1.5
(cf2num '(0 2))
;-> 0.5
(cf2num '(2))
;-> 2

(cf2num '(3 4 12 4))
;-> 3.245

Funzione che calcola i convergenti di una frazione continua:

(define (cf2conv cf)
  (local (p0 q0 p1 q1 p2 q2)
    (setq p0 1 q0 0)
    (setq p1 (cf 0) q1 1)
    (for (k 1 (- (length cf) 1))
      (setq p2 (+ (* (cf k) p1) p0))
      (setq q2 (+ (* (cf k) q1) q0))
      (println (list p2 q2 (div p2 q2)))
      (setq p0 p1 q0 q1 p1 p2 q1 q2)
    )
    (list p2 q2 (div p2 q2))))

(cf2conv '(2 1 2 1 1 4 1 1 6 1))
;-> (3 1 3)
;-> (8 3 2.666666666666667)
;-> (11 4 2.75)
;-> (19 7 2.714285714285714)
;-> (87 32 2.71875)
;-> (106 39 2.717948717948718)
;-> (193 71 2.71830985915493)
;-> (1264 465 2.718279569892473)
;-> (1457 536 2.718283582089552)
;-> (1457 536 2.718283582089552)

(cf2conv '(3 4 12 4))
;-> (13 4 3.25)
;-> (159 49 3.244897959183673)
;-> (649 200 3.245)

(cf2conv '(3 7 15 1 292 1 1 1 2 1 3 1 14 3 2 2 1 1 1 1 2 2 12 24 1 1 6 2 4 1 3 3))
;-> (22 7 3.142857142857143)
;-> (333 106 3.141509433962264)
;-> (355 113 3.141592920353983)
;-> (103993 33102 3.141592653011903)
;-> (104348 33215 3.141592653921421)
;-> (208341 66317 3.141592653467437)
;-> (312689 99532 3.141592653618937)
;-> (833719 265381 3.141592653581078)
;-> (1146408 364913 3.141592653591404)
;-> (4272943 1360120 3.141592653589389)
;-> (5419351 1725033 3.141592653589815)
;-> (80143857 25510582 3.141592653589793)
;-> (245850922 78256779 3.141592653589793)
;-> (571845701 182024140 3.141592653589793)
;-> (1389542324 442305059 3.141592653589793)
;-> (1961388025 624329199 3.141592653589793)
;-> (3350930349 1066634258 3.141592653589793)
;-> (5312318374 1690963457 3.141592653589793)
;-> (8663248723 2757597715 3.141592653589793)
;-> (22638815820 7206158887 3.141592653589793)
;-> (53940880363 17169915489 3.141592653589793)
;-> (669929380176 213245144755 3.141592653589793)
;-> (16132246004587 5135053389609 3.141592653589793)
;-> (16802175384763 5348298534364 3.141592653589793)
;-> (32934421389350 10483351923973 3.141592653589793)
;-> (214408703720863 68248410078202 3.141592653589793)
;-> (461751828831076 146980172080377 3.141592653589793)
;-> (2061416019045167 656169098399710 3.141592653589793)
;-> (2523167847876243 803149270480087 3.141592653589793)
;-> (9630919562673896 3065616909839971 3.141592653589793)
;-> (31415926535897931 10000000000000000 3.141592653589793)


---------------
Redditi e tasse
---------------

In genere le tasse sui redditi vengono definite per "scaglioni" (classe di reddito). Ad esempio in Italia valgono le seguenti classi:

fino a 15000 euro il 23%
(23% del reddito)

da 15001 fino a 28000 euro il 27%
(3450.00 + 27% sulla parte oltre i 15000 euro)

da 28.001 fino a 55.000 euro il 38%
(6960.00 + 38% sulla parte oltre i 28000 euro

da 55.001 fino a 75.000 euro il 41%
(17220.00 + 41% sulla parte oltre i 55000 euro)

oltre 75.000 euro il 43%
(25420.00 + 43% sulla parte oltre i 75000 euro

Esempio:
Reddito = 27000 euro
15000 * 23% = 3450
più il 27% sulla parte oltre i 15000 (27000 - 15000 = 12000) = 3240,
per un totale di (3450 + 3240 = 6690).

Scrivere una funzione che calcola le tasse da pagare dato un determinato reddito.

Questo problema permette una soluzione elegante utilizzando la ricorsione.

La tabella viene codificata nel modo seguente:

(setq tabella '((75000 0.43) (55000 0.41) (28000 0.38) (15000 0.27) (0 0.23)))

Definiamo alcune funzione tipiche del LISP:

(define car first)
;-> first@4071B9
(define cdr rest)
;-> rest@4072CA
(define (caar x)   (first (first x)))
(define (cadar x)  (first (rest (first x))))

Vediamo cosa estraggono dalla lista le funzioni "caar" e "cadar":

(caar tabella)
;-> 75000
(cadar tabella)
;-> 0.43

(define (tasse reddito tabella)
   (if (null? tabella) 0
     (add (mul (max (sub reddito (caar tabella)) 0) (cadar tabella))
               (tasse (min reddito (caar tabella)) (cdr tabella)))))

Da notare che la ricorsione viene applicata sommando le tasse e diminuendo la lunghezza della tabella ad ogni passo. Possiamo capire meglio il funzionamento se calcoliamo le seguenti espressioni (che rappresentano il primo passo della ricorsione):

(mul (max (sub 27000 (caar tabella)) 0) (cadar tabella))
;-> 0

(min 27000 (caar tabella))
;-> 27000

(cdr tabella)
;-> ((55000 0.41) (28000 0.38) (15000 0.27) (0 0.23))

Applichiamo la funzione all'esempio:

(tasse 27000 tabella)
;-> 6690

E verifichiamo altri casi:

(tasse 0)
;-> 0
(tasse 15000 tabella)
;-> 3450
(tasse 15001 tabella)
;-> 3450.27
(tasse 75000 tabella)
;-> 25420
(tasse 75001 tabella)
;-> 25420.43

Adesso vediamo come variano le tasse in funzione del reddito:

(define (curva tabella reddito step)
  (let (out '())
    (for (i step reddito step)
      (push (list i (tasse i tabella)) out -1))
    out))

(setq data (curva tabella 200000 1000))

Adesso scriviamo una funzione che crea un file grafico ("tasse.png") che visualizza relazione reddito/tasse:

(module "plot.lsp")

(define (plotXY lst)
  (local (xx zz)
    ; azzera parametri della funzione plot
    (plot:reset)
    ; opzionale title, sub-title, labels e legend, data min/max per Y
    (set 'plot:title "Tasse sul reddito")
    (set 'plot:sub-title "IRPEF 2020")
    (set 'plot:unit-x "reddito")
    (set 'plot:unit-y "tasse")
    ; crea il file dei dati
    ; lista dei valori x (reddito) e lista dei valori z (tasse)
    (setq xx '())
    (setq zz '())
    (dolist (el lst)
      (push (first el) xx -1)
      (push (last el) zz -1 ))
    ; plot data
    (plot:XY xx zz)
    ; salva il plot su un file
    (plot:export (string "tasse.png"))))

Creiamo il grafico:

(plotXY data)

Il grafico mostra che le tasse sono, grosso modo, direttamente proporzionali al reddito.

Potete trovare il file nella cartella "data".


----------------------------
Numero di eulero o di nepero
----------------------------
e = 2.7182818284590451

(exp 1)
;-> 2.718281828459045

Supponiamo di avere depositato un certo capitale C al tasso di interesse annuo di x per cento, cioè al tasso assoluto di r = x/100.

Dopo un anno il nostro capitale è diventato C(1) = C*(1+r). Dopo un altro anno: C(2) = C1*(1+r) = C*(1+r)^2, dopo tre anni C(3) = C*(1+r)^3 e dopo n anni C(n) = C*(1+r)^n. La crescita esponenziale è dovuta agli interessi maturati precedentemente che concorrono nel maturare altri interessi.

Supponiamo che dopo 6 mesi (1/2 anno) il capitale si sia rivalutato di r/2 (in realtà non è così perché altrimenti risulterebbe (dopo n anni): C(n) =C*(1+n*r) invece di C(n) = C*(1+r)^n).
Dopo un semestre il capitale sarà diventato C(1/2) = C*(1+r/2) e dopo un anno C1 = C*(1+r/2)^2 .

Per ogni quadrimestre (1/3 di anno) al tasso di r/3 avremmo C(1/3) = C*(1+r/3) e dopo un anno C(1) = C*(1+r/3)^3.

Se gli interessi maturassero ogni 1/n di anno al tasso di r/n dopo ogni m frazioni di anno avremmo C(m/n) = C(1+r/n)^m e dopo un anno C1 = C*(1+r/n)n.

Per una maturazione continua (interesse composto) basta passare al limite per n tendente all’infinito e dopo un anno avremmo un capitale di: C(1) = C*lim(1+r/n)^n.

Se poniamo r = 1 questo limite è proprio il numero di Eulero "e".

Calcoliamo questo limite (facendo assumere ad n valori sempre maggiori):

(define (limite n) (pow (add 1 (div n)) n))

(limite 1000)
;-> 2.71692393223552
(limite 10000)
;-> 2.718145926824356
(limite 100000)
;-> 2.718268237197528
(limite 1000000)
;-> 2.718280469156428

Vediamo la differenza con il numero "e":

(sub (exp 1) (limite 1000000))
;-> 1.359302617576219e-006

Invece, se r è diverso da 1 con il cambio di variabile m = n/r si ha:

lim(1+r/n)^n = lim(1+1/m)^(m*r) = (lim(1+1/m)^m)^r = e^r

Anche questa volta abbiamo ritrovato il numero di Eulero "e".

Quindi dopo un anno sarà C(1) = C*e^r e dopo t anni (con t non necessariamente intero): C(t) = C*e^(t*r).

Da notare che il numero "e" è scaturito naturalmente, non è stato introdotto artificiosamente.

Purtroppo le banche non concedono un tasso assoluto di interesse continuo.


---------------------
map e filter multiplo
---------------------

Qualche volta abbiamo la necessità di applicare la funzione "map" più volte su una stessa lista, ad esempio per applicare tre funzioni func1, func2 e func2 ad una lista lst dobbiamo scrivere:

(map func3 (map func2 (map func1 lst)))

Possiamo scrivere una funzione per utilizzare un'espressione più elegante:

(define (nmap lst)
  (let (res lst)
    ; per ogni predicato
    (dolist (func (args))
      ; applica il predicato agli elementi della lista
      (setq res (map func res)))))

Adesso il nostro esempio può essere scritto nel modo seguente:

(nmap lst func1 func2 func3)

Vediamo un esempio concreto:

(nmap '(-4 36 81 49) abs sqrt)
;-> (2 6 9 7)

Possiamo anche usare una funzione definita dall'utente:

(nmap (explode "newLISP") upper-case (fn(x) (char x)))
;-> (78 69 87 76 73 83 80)

Vediamo la differenza di velocità:

(setq lst (sequence -5000 5000))

(time (nmap lst abs sqrt) 1000)
;-> 1221.763

(time (map sqrt (map abs lst)) 1000)
;-> 607.408

Nota: il tempo di esecuzione della nostra funzione è il doppio di quello del metodo standard.

Possiamo utilizzare la stessa tecnica anche per la funzione "filter":

(define (nfilter lst)
  (let (res lst)
    ; per ogni predicato
    (dolist (func (args))
      ; applica il predicato agli elementi della lista
      (setq res (filter func res)))))

(setq lst '(1 2 3 4 a b c 5 6 7 8 9 ))

(filter odd? (filter integer? lst))
;-> (1 3 5 7 9)

(nfilter lst integer? odd?)
;-> (1 3 5 7 9)

Vediamo la velocità:

(setq lst (sequence 1 10000))
(time (nfilter lst integer? odd?) 1000)
;-> 1325.484

(time (filter odd? (filter integer? lst)) 1000)
;-> 967.444

Anche in questo caso possiamo anche usare una funzione definita dall'utente al posto del predicato.

Nota: i predicati vengono valutati da sinistra a destra, quindi nell'esempio la loro inversione provoca un errore perchè non possiamo applicare "odd?" all'elemento "a":

(nfilter lst odd? integer?)
;-> ERR: value expected in function odd? : a
;-> called from user function (nfilter lst odd? integer?)

La funzione "nfilter" applica i predicati in sequenza, cioè ogni elemento della lista deve rispettare tutti i predicati per essere selezionato (and):

  elemento selezionato se rispetta (func1 and func2 and ... and funcN)

Può risultare utile una funzione che seleziona un elemento anche se un solo predicato viene rispettato (or):

  elemento selezionato se rispetta (func1 or func2 or ... or funcN)

Vediamo come potrebbe essere implementata:

(define (nfilter-or lst)
  (let ((stop nil) (res '()))
    ; per ogni elemento della lista
    (dolist (el lst)
      ; per ogni predicato
      (setq stop nil)
      (dolist (func (args) stop)
        ; applica il predicato all'elemento
        ; se il risultato è vero (true)
        (if (func el)
          (begin
          ; allora lo inserisce nella lista res
          (push el res -1)
          ; e non occorre applicare
          ; gli altri predicati all'elemento corrente
          (setq stop true))
        )
      )
    )
    res))

(setq lst '(1 2 3 4 5 6 7 8 9))

(nfilter-or lst integer? odd?)
;-> (1 2 3 4 5 6 7 8 9)

Usiamo una funzione definita dall'utente:

(define (big5? x) (> x 5))

(nfilter-or lst big5? odd?)
;-> (1 3 5 6 7 8 9)

Vediamo la velocità:

(setq test (sequence 1 10000))
(time (nfilter-or test integer? odd?) 100)
;-> 221.408

Nota: Nel caso della funzione "nfilter-or" i predicati devono poter essere applicati a tutti gli elementi senza errore.

Vediamo un altro modo di implementare la funzione "nfilter-or":

(define (nfilter-or lst)
  (let ((bool '()) (res '()))
    ; per ogni predicato
    (dolist (func (args))
      ; applica il predicato a tutta la lista
      ; creando una lista di true e nil
      ; e la aggiunge alla lista bool
      ; es. bool = ((true nil) (true nil) (nil nil))
      (push (map func lst) bool -1)
    )
    ; per ogni elemento della trasposta di bool
    ; es. traposta bool = ((true true nil) (nil nil nil))
    (dolist (b (transpose bool))
      ; se "or" = true per elemento corrente
      (if (apply or b)
          ; inserisco il relativo elemento della lista lst
          ; nella lista risultato
          (push (lst $idx) res -1)
      )
    )
    res))

(setq lst '(abc 1 "a" 2 "b" 3 "c" lst))

(nfilter-or lst integer? string?)
;-> (1 "a" 2 "b" 3 "c")

Vediamo la velocità:

(setq test (sequence 1 10000))
(time (nfilter-or test integer? odd?) 100)
;-> 7057.166

L'ultima funzione è molto lenta perchè crea altre liste che vengono attraversate diverse volte.

Come al solito la cosa migliore da fare è utilizzare le primitive di newLISP:

Per "filter":

Con una funzione utente:
(setq lst (sequence -5000 5000))
(define (test? x) (or (integer? x) (odd? x)))
(time (filter test? lst) 1000)
;-> 1465.309

Direttamente:
(setq lst (sequence -5000 5000))
(time (filter odd? (filter integer? lst)) 1000)
;-> 913.119

Per "map":

Con una funzione utente:
(setq lst (sequence -5000 5000))
(define (func x) (sqrt (abs x)))
(time (map func lst) 1000)
;-> 850.763

Direttamente:
(setq lst (sequence -5000 5000))
(time (map sqrt (map abs lst)) 1000)
;-> 564.408


--------
Toziente
--------

La funzione φ (phi) di Eulero o funzione toziente, è una funzione definita, per ogni intero positivo n, come il numero degli interi compresi tra 1 e n che sono coprimi con n. Ad esempio, phi(8) = 4 poiché i numeri coprimi di 8 sono quattro: 1, 3, 5 e 7.

n = p1^a1 * p2^a2 *... * pk^ak

phi(n) = n* (1 - 1/p1)*(1 - 1/p2)*...*(1 - 1/pk)

Per calcolare il toziente di un numero scriviamo tre funzioni, due che utilizzano la primitiva di newLISP "factor" e una che calcola la fattorizzazione (quindi utilizzabile anche per i big-integer):

Funzione 1:

(define (toziente1 num)
    (if (= num 1) 1
    (round (mul num (apply mul (map (fn (x) (sub 1 (div 1 x))) (unique (factor num))))) 0)))

(toziente1 222)
;-> 72
(toziente1 123456)
;-> 41088
(toziente1 9223372036854775807)
;-> 7.713001620195509e+018

Funzione 2:

(define (toziente2 num)
  (if (= num 1) 1
    (let (res num)
      (dolist (f (unique (factor num)))
        (setq res (- res (/ res f))))
      res)))

(toziente2 222)
;-> 72
(toziente2 123456)
;-> 41088
(toziente2 9223372036854775807)
;-> 7713001620195508224

Funzione 3 (big-integer):

(define (toziente-i num)
  (if (= num 1) 1
    (let ((res num) (i 2L))
      (while (<= (* i i) num)
        (if (zero? (% num i))
            (begin
              (while (zero? (% num i))
                (setq num (/ num i))
              )
              (setq res (- res (/ res i))))
        )
        (++ i)
      )
      (if (> num 1)
        (setq res (- res (/ res num)))
      )
      res)))

(toziente-i 222)
;-> 72
(toziente-i 123456)
;-> 41088
(toziente-i 9223372036854775807)
;-> 7713001620195508224

Se passiamo un numero big-integer, allora la soluzione sarà un big-integer:

(toziente-i 9223372036854775808L)
;-> 4611686018427387904L

Verifichiamo che le funzioni producano lo stesso risultato:

(= (map toziente1 (sequence 1 1000)) (map toziente2 (sequence 1 1000)) (map toziente-i (sequence 1 1000)))
;-> true

Vediamo la velocità delle funzioni:

(setq lst (sequence 1 10000))
(time (map toziente1 lst) 100)
;-> 1401.418
(time (map toziente2 lst) 100)
;-> 1156.911
(time (map toziente-i lst) 100)
;-> 11216.188

Se abbiamo bisogno di tutti i totienti dei numeri compresi tra 1 e n, la fattorizzazione di tutti gli n numeri non è efficiente. Possiamo usare la stessa idea del crivello di Eratostene: troviamo tutti i numeri primi e per ciascuno aggiorniamo i risultati temporanei di tutti i numeri che sono divisibili per quel numero primo.

(array (+ 3 1) '(0))

(define (totients-to num)
  (let (phi (array (+ num 1) '(0)))
    (setf (phi 0) 0)
    (setf (phi 1) 1)
    (for (i 2 num)
      (setf (phi i) i)
    )
    (for (i 2 num)
      (if (= (phi i) i)
          (for (j i num i)
            (setf (phi j) (- (phi j) (/ (phi j) i)))
          )
      )
    )
    (slice phi 1 num)))

(totients-to 10)
;-> (1 1 2 2 4 2 6 4 6 4)

Verifichiamo il risultato:

(= (array-list (totients-to 10000)) (map toziente2 (sequence 1 10000)))
;-> true

Vediamo la differenza di velocità:

(time (totients-to 10000) 100)
;-> 349.067

(time (map toziente2 (sequence 1 10000)) 100)
;-> 1250.951

Per calcolare i tozienti dei numeri da 1 a n conviene utilizzare la funzione "totients-to".


--------------------------
Direct Acyclic Graph (DAG)
--------------------------

Un grafo aciclico diretto (Directed acyclic graph, DAG) è un grafo diretto che non ha cicli (circuiti), ovvero comunque scegliamo un vertice del grafo non possiamo tornare ad esso percorrendo gli archi del grafo. Un grafo diretto può dirsi aciclico (cioè è un DAG) se una visita in profondità non presenta archi all'indietro.

Un esempio di DAG è il seguente:

  +---------+-        +---------+        +---------+          +---------+
  |         |         |         |        |         |          |         |
  |    A    |-------->|    C    |------->|    D    |--------->|    E    |
  |         |   ----->|         |        |         |------    |         |
  +---------+   |     +---------+        +---------+     |    +---------+
                |         |                              |
  +---------+   |         |                              |    +---------+
  |         |   |         |                              |    |         |
  |    B    |----         |        +---------+           ---->|    F    |
  |         |             |        |         |                |         |
  +---------+             -------->|    G    |                +---------+
                                   |         |
                                   +---------+

A e B sono nodi iniziali. Ogni nodo ha proprietà, ogni vertice ha proprietà. E, G e F sono nodi finali.

Il codice seguente è stato scritto da rickyboy ed è anche un ottimo esempio di programmazione ad oggetti in newLISP (FOOP).

;;;
;;; Find dependencies ((grand)*parents) in a DAG.
;;;

(define (mappend) (apply append (apply map (args))))

(define (Class:Class) (cons (context) (args)))

The three principal types of objects we need are nodes, edges, and DAGs.

(new Class 'Node)
(new Class 'Edge)
(new Class 'DAG)

Naturally, DAGs will contain nodes and edges. Here is a helper function to create a DAG.
Besides nodes and edges, DAGS contain a "parents-alist", an adjacency list matching nodes (node names, actually) to a list of their parents (names).
The create function will compute the "parents-alist" for you, as a convenience.

;; Warning: no error checking is done, e.g. checking for no cycles.
(define (DAG:create nodes edges)
  "Create a DAG object from Nodes and Edges."
  (let ((simple-nodes (map (fn (n) (n 1)) nodes))
        (simple-edges (map (fn (e) (list (e 1) (e 2))) edges)))
    (DAG nodes
         edges
         ;; parents-alist: assocs look like (node (parent-node ...))
         (map (fn (sn)
                (list sn
                      (map first
                           (filter (fn (se) (= sn (last se)))
                                   simple-edges))))
              simple-nodes)
         ;; children-alist: assocs look like (node (child-node ...))
         (map (fn (sn)
                (list sn
                      (map last
                           (filter (fn (se) (= sn (first se)))
                                   simple-edges))))
              simple-nodes))))

Let's see it in action on our DAG:

(define my-dag
  (DAG:create (list (Node "A" 'happy)
                    (Node "B" 'sad)
                    (Node "C" 'happy)
                    (Node "D" 'indifferent)
                    (Node "E" 'surly)
                    (Node "F" 'happy)
                    (Node "G" 'sad))
              (list (Edge "A" "C" 3)
                    (Edge "B" "C" 4)
                    (Edge "C" "D" 8)
                    (Edge "C" "G" 1)
                    (Edge "D" "E" 4)
                    (Edge "D" "F" 9))))

Here's what it looks like:

my-dag
;-> (DAG ((Node "A" happy) (Node "B" sad) (Node "C" happy)
;->       (Node "D" indifferent) (Node  "E" surly)
;->       (Node "F" happy) (Node "G" sad))
;->      ((Edge "A" "C" 3) (Edge "B" "C" 4) (Edge "C" "D" 8)
;->       (Edge "C" "G" 1) (Edge "D" "E"  4) (Edge "D" "F" 9))
;->      (("A" ()) ("B" ()) ("C" ("A" "B")) ("D" ("C"))
;->       ("E" ("D")) ("F" ("D")) ("G" ("C"))))

Nodes and edges must contain properties. The convention I'm using here is that, when defining a Node, the first "slot" contains the name and the remaining "slots" contain any number of properties that you want to add. So, (Node "A" 'happy) is a node with the name "A" and one property value (namely, 'happy). The same idea applies to edges, except that the first 2 slots contain node names and the remaining slots can be properties. Hence, (Edge "A" "C" 3) is an edge starting from node "A", ending at node "C" and containing the property value 3 (which could be an edge weight/cost, for example). These are the properties.

Now, here are some accessor functions for DAGs:

(define (DAG:nodes) (self 1))
(define (DAG:edges) (self 2))
(define (DAG:parents node-name)
  (let ((parents-alist (self 3)))
    (if node-name
        (if (assoc node-name parents-alist) (last $it) '())
        parents-alist)))

;; Example usage:
;; (:parents my-dag) => (("A" ()) ("B" ()) ("C" ("A" "B")) ("D" ("C")) ("E" ("D")) ("F" ("D")) ("G" ("C")))
;; (:parents my-dag "C") => ("A" "B")
;; (:parents my-dag "B") => ()
;; (:parents my-dag "Does not exist") => ()

Here's a function to compute a node's children:

(define (DAG:children node-name)
  (let ((children-alist (self 4)))
    (if node-name
        (if (assoc node-name children-alist) (last $it) '())
        children-alist)))

;; Example usage:
;; (:children my-dag) => (("A" ("C")) ("B" ("C")) ("C" ("D" "G")) ("D" ("E" "F")) ("E" ()) ("F" ()) ("G" ()))
;; (:children my-dag "C") => ("D" "G")
;; (:children my-dag "B") => ("C")
;; (:children my-dag "E") => ()
;; (:children my-dag "Does not exist") => ()

Here's a function to compute a node's ancestors (i.e. parents, grandparents, ...):

(define (DAG:ancestors node-name)
  (let ((parents (:parents (self) node-name)))
    (and parents
         (append parents
                 (mappend (fn (p) (:ancestors (self) p))
                      parents)))))

;; Example usage:
;; (:ancestors my-dag "D") => ("C" "A" "B")

Here's a function to compute a node's descendants:

(define (DAG:descendants node-name)
  (let ((children (:children (self) node-name)))
    (and children
         (append children
                 (mappend (fn (p) (:descendants (self) p))
                          children)))))

;; Example usage:
;; (:descendants my-dag "C") => ("D" "G" "E" "F")

;; If you want to get a Node out of the DAG (e.g. in order the extract
;; its properties), then use the following function to get it by name.

(define (DAG:get-node node-name)
  (and (find (list 'Node node-name '*)
             (:nodes (self))
             match)
       $0))

;; Example usage:
;; (:get-node my-dag "G") => (Node "G" sad)
;; (:get-node my-dag "Does not exist") => nil

;; Same goes for getting an Edge, expect you provide a list of two
;; node names, e.g. '("A" "B").

(define (DAG:get-edge edge-name)
  (and (find (append '(Edge) edge-name '(*))
             (:edges (self))
             match)
       $0))

;; Example usage:
;; (:get-edge my-dag '("C" "D")) => (Edge "C" "D" 8)
;; (:get-edge my-dag '("Does" "Not Exist")) => nil

(define (find-all-dependencies dag node-name)
  (:ancestors dag node-name))

;; (find-all-dependencies my-dag "D") => ("C" "A" "B")

(define (get-all-dependencies dag node-name)
   (map (fn (name) (:get-node dag name))
        (:ancestors dag node-name)))

;; (get-all-dependencies my-dag "D") => ((Node "C" happy) (Node "A" happy) (Node "B" sad))


---------------
Corde e cerchio
---------------

Se una corda è selezionata a caso su un cerchio, qual è la probabilità che la sua lunghezza (l) superi il raggio (r) del cerchio?
"A caso" indica che i punti finali della corda sono distribuiti uniformemente sul cerchio.

La lunghezza di una corda AB vale:

corda = diametro * sin(alfa)

dove alfa è l'angolo che insiste sulla corda AB

0° <= alfa <= 180°

Se poniamo (corda = r) ==> r = 2 * r * sin(alfa) ==> sin(alfa) = 1/2 ==> asin(1/2) = 60°

Quindi la lunghezza della corda è pari al raggio r quando alfa = 60°.

Allora per alfa compreso tra 0° e 60°, la corda è minore del raggio,
       per alfa compreso tra 60° e 180°, la corda è maggiore del raggio.

Quindi la probabilità che la lunghezza della corda superi il raggio vele (180 - 60/180) = 2/3 = 0.666666...

Scriviamo una funzione che effettua la simulazione:

(setq PI 3.1415926535897931)

(define (corda step)
  (local (tot magg r alfa)
  (setq tot 0 magg 0 r 1)
  (for (alfa 0 (div PI 2) step)
    (if (> (mul 2 r (sin alfa)) r) (++ magg))
    (++ tot)
  )
  (div magg tot)))

(corda 0.01)
;-> 0.6645569620253164
(corda 0.001)
;-> 0.6664544875875239
(corda 0.0001)
;-> 0.6666666666666666


--------
Toziente
--------

La funzione φ (phi) di Eulero o funzione toziente, è una funzione definita, per ogni intero positivo n, come il numero degli interi compresi tra 1 e n che sono coprimi con n. Ad esempio, phi(8) = 4 poiché i numeri coprimi di 8 sono quattro: 1, 3, 5 e 7.

n = p1^a1 * p2^a2 *... * pk^ak

phi(n) = n* (1 - 1/p1)*(1 - 1/p2)*...*(1 - 1/pk)

Per calcolare il toziente di un numero scriviamo tre funzioni, due che utilizzano la primitiva di newLISP "factor" e una che calcola la fattorizzazione (quindi utilizzabile anche per i big-integer):

Funzione 1:

(define (toziente1 num)
    (if (= num 1) 1
    (round (mul num (apply mul (map (fn (x) (sub 1 (div 1 x))) (unique (factor num))))) 0)))

(toziente1 222)
;-> 72
(toziente1 123456)
;-> 41088
(toziente1 9223372036854775807)
;-> 7.713001620195509e+018

Funzione 2:

(define (toziente2 num)
  (if (= num 1) 1
    (let (res num)
      (dolist (f (unique (factor num)))
        (setq res (- res (/ res f))))
      res)))

(toziente2 222)
;-> 72
(toziente2 123456)
;-> 41088
(toziente2 9223372036854775807)
;-> 7713001620195508224

Funzione 3 (big-integer):

(define (toziente-i num)
  (if (= num 1) 1
    (let ((res num) (i 2L))
      (while (<= (* i i) num)
        (if (zero? (% num i))
            (begin
              (while (zero? (% num i))
                (setq num (/ num i))
              )
              (setq res (- res (/ res i))))
        )
        (++ i)
      )
      (if (> num 1)
        (setq res (- res (/ res num)))
      )
      res)))

(toziente-i 222)
;-> 72
(toziente-i 123456)
;-> 41088
(toziente-i 9223372036854775807)
;-> 7713001620195508224

Se passiamo un numero big-integer, allora la soluzione sarà un big-integer:

(toziente-i 9223372036854775808L)
;-> 4611686018427387904L

Verifichiamo che le funzioni producano lo stesso risultato:

(= (map toziente1 (sequence 1 1000)) (map toziente2 (sequence 1 1000)) (map toziente-i (sequence 1 1000)))
;-> true

Vediamo la velocità delle funzioni:

(setq lst (sequence 1 10000))
(time (map toziente1 lst) 100)
;-> 1401.418
(time (map toziente2 lst) 100)
;-> 1156.911
(time (map toziente-i lst) 100)
;-> 11216.188

Se abbiamo bisogno di tutti i totienti di tutti i numeri compresi tra 1 e n, la fattorizzazione di tutti gli n numeri non è efficiente. Possiamo usare la stessa idea del crivello di Eratostene: troviamo tutti i numeri primi e per ciascuno aggiorniamo i risultati temporanei di tutti i numeri che sono divisibili per quel numero primo.

(array (+ 3 1) '(0))

(define (totients-to num)
  (let (phi (array (+ num 1) '(0)))
    (setf (phi 0) 0)
    (setf (phi 1) 1)
    (for (i 2 num)
      (setf (phi i) i)
    )
    (for (i 2 num)
      (if (= (phi i) i)
          (for (j i num i)
            (setf (phi j) (- (phi j) (/ (phi j) i)))
          )
      )
    )
    (slice phi 1 num)))

(totients-to 10)
;-> (0 1 1 2 2 4 2 6 4 6 4)

Verifichiamo il risultato:

(= (array-list (totients-to 10000)) (map toziente2 (sequence 1 10000)))
;-> true

Vediamo la differenza di velocità:

(time (totients-to 10000) 100)
;-> 349.067

(time (map toziente2 (sequence 1 10000)) 100)
;-> 1250.951

Per calcolare i tozienti dei numeri da 1 a n conviene utilizzare la funzione "totients-to".


----------------
Numeri permutati
----------------

Scrivere una funzione che verifica se due numeri sono la permutazione uno dell'altro, cioè se i due numeri contengono le stesse identiche cifre.

Funzione che converte un intero in una lista:

(define (int-lst num)
  (let (out '())
    (while (!= num 0)
      (push (% num 10) out)
      (setq num (/ num 10))) out))

Prima funzione:

(define (perm1? n1 n2) (= (sort (int-lst n1)) (sort (int-lst n2))))

(perm1? 112233 123123)
;-> true
(perm1? 112233 223123)

Seconda funzione:
usiamo due vettori che vengono aggiornati (+ 1) con le cifre dei due numeri.
Al termine confrontiamo i due vettori.

(define (perm2? n1 n2)
  (if (!= (length n1) (length n2))
      nil
      (let (ar1 (array 10 '(0)) (ar2 (array 10 '(0))))
        (while (!= n1 0)
            (++ (ar1 (% n1 10)))
            (setq n1 (/ n1 10))
        )
        (while (!= n2 0)
            (++ (ar2 (% n2 10)))
            (setq n2 (/ n2 10))
        )
        (= ar1 ar2))))

(perm2? 112233 123123)
;-> true
(perm2? 112233 223123)
;-> nil

Terza funzione:
usiamo un vettore che viene aggiornato (+ 1 e -1) con le cifre dei due numeri.
Al termine verifichiamo se il vettore contiene tutti 0.

(define (perm3? n1 n2)
  (if (!= (length n1) (length n2))
      nil
      (let (ar (array 10 '(0)))
        (while (!= n1 0)
            (++ (ar (% n1 10)))
            (setq n1 (/ n1 10))
        )
        ;(println ar)
        (while (!= n2 0)
            (-- (ar (% n2 10)))
            (setq n2 (/ n2 10))
        )
        ;(println ar)
        (= (count '(0) (array-list ar)) '(10)))))

(perm3? 112233 123123)
;-> true
(perm3? 112233 223123)
;-> nil

Quarta funzione:
questa funzione è presa da un vecchio libro sul linguaggio C.

(define (perm4? n1 n2)
  (if (!= (length n1) (length n2))
      nil
      (let ((nn1 n1) (nn2 n2) (tot1 0) (tot2 0))
        (while (and (> nn1 0) (> nn2 0))
          (setq nn1 (/ nn1 10) nn2 (/ nn2 10)))
        (while (!= n1 0)
          (setq tot1 (+ tot1 (<< 1 (* (% n1 10) 6))))
          (setq tot2 (+ tot2 (<< 1 (* (% n2 10) 6))))
          (setq n1 (/ n1 10))
          (setq n2 (/ n2 10)))
        (= tot1 tot2))))

Nota: L'operazione di left-shift (x << y) è equivalente a moltiplicare x per 2^y (2 elevato alla potenza y).

(perm4? 112233 123123)
;-> true
(perm4? 112233 223123)
;-> nil

Vediamo la velocità delle funzioni:

(time (perm1? 9223372036854775807 7223372036854775809) 100000)
;-> 587.222
(time (perm2? 9223372036854775807 7223372036854775809) 100000)
;-> 557.205
(time (perm3? 9223372036854775807 7223372036854775809) 100000)
;-> 611.291
(time (perm4? 9223372036854775807 7223372036854775809) 100000)
;-> 945.856

Per i big-integer:

(time (perm1? 92233720368547758079223372036854775807L 72233720368547758097223372036854775809L) 100000)
;-> 4832.083
(time (perm2? 92233720368547758079223372036854775807L 72233720368547758097223372036854775809L) 100000)
;-> 4063.133
(time (perm3? 92233720368547758079223372036854775807L 72233720368547758097223372036854775809L) 100000)
;-> 4131.988


-------------
Numeri bouncy
-------------

Un numero "bouncy" (che rimbalza) è un numero intero positivo le cui cifre non sono in ordine strettamente crescente o strettamente decrescente. Ad esempio, 1235 è un numero crescente, 5321 è un numero decrescente e 2351 è un numero bouncy. Per definizione, tutti i numeri inferiori a 100 sono non-bouncy e 101 è il primo numero bouncy.

Scrivere una funzione che verifica se un numero è bouncy.

Funzione iterativa:

(define (bouncy1 num)
  (local (incr decr ultimo prossimo continua)
    (setq continua true)
    (setq incr nil decr nil)
    (setq ultimo (% num 10))
    (setq num (/ num 10))
    (while (and (> num 0) continua)
      (setq prossimo (% num 10))
      (setq num (/ num 10))
      (if (< prossimo ultimo)
          (setq incr true)
          (if (> prossimo ultimo)
              (setq decr true)))
      (setq ultimo prossimo)
      (if (and decr incr) (setq continua nil))
    )
    (and decr incr)))

(bouncy1 123456)
;-> nil
(bouncy1 123451)
;-> true
(bouncy1 123455)
;-> nil
(bouncy1 111111)
;-> nil
(bouncy1 211111)
;-> nil

Funzione funzionale:

(define (int-lst num)
  (let (out '())
    (while (!= num 0)
      (push (% num 10) out)
      (setq num (/ num 10))) out))

(define (bouncy2 num)
  (let (digits (int-lst num))
    (not (or (apply >= digits) (apply <= digits)))))

(bouncy2 123456)
;-> nil
(bouncy2 123451)
;-> true
(bouncy2 123455)
;-> nil
(bouncy2 111111)
;-> nil
(bouncy2 211111)
;-> nil

Vediamo se le due funzioni producono risultati uguali:

(= (map bouncy1 (sequence 1 10000)) (map bouncy2 (sequence 1 10000)))
;-> true

Vediamo la velocità delle funzioni:

(setq numeri (sequence 1 100000))
(time (map bouncy1 numeri) 10)
;-> 934.53
(time (map bouncy2 numeri) 10)
;-> 975.42


---------
docstring
---------

Una docstring è una stringa letterale specificata nel codice sorgente che viene utilizzata, come un commento, per documentare uno specifico segmento di codice.
newLISP supporta l'inserimento di una docstring nelle funzione, ma non ha alcun metodo per recuperarla. Possiamo scrivere una funzione che estrae la docstring, se presente, di una funzione. Sul forum di newLISP Nigel Brown e HPW hanno proposto la seguente funzione:

(define (doc f)
  "(doc f) - display function f's doc string, if present"
  (if (and (or (lambda? f) (macro? f)) (string? (nth 1 f)))
      (nth 1 f)
      nil))

Esempi:

(define (somma a b)
"(somma a b) - somma due numeri interi"
(+ a b))

(doc somma)
;-> "(somma a b) - somma due numeri interi"

(doc doc)
"(doc f) - display function f's doc string, if present"

In questo modo possiamo avere un help sulle funzioni scritte dall'utente.


--------------
Numeri sfenici
--------------

Sono chiamati “sfenici” (dal greco σφήν, cuneo) i numeri naturali che sono il prodotto di tre primi distinti.

I numeri sfenici minori di 500 sono:
 30, 42, 66, 70, 78, 102, 105, 110, 114, 130, 138, 154, 165, 170, 174, 182,
 186, 190, 195, 222, 230, 231, 238, 246, 255, 258, 266, 273, 282, 285, 286,
 290, 310, 318, 322, 345, 354, 357, 366, 370, 374, 385, 399, 402, 406, 410,
 418, 426, 429, 430, 434, 435, 438, 442, 455, 465, 470, 474, 483, 494, 498

Possiamo scrivere una funzione che verifica se un numero è sfenico:

(define (sfenico? num)
  (let (f (factor num))
    (and (= (length f) 3) (!= (f 0) (f 1) (f 2)))))

(sfenico? 30)
;-> true

(filter true? (map (fn(x) (if x $idx)) sf))
;-> (30 42 66 70 78 102 105 110 114 130 138 154 165 170 174 182 186 190 195 222 230 231
;->  238 246 255 258 266 273 282 285 286 290 310 318 322 345 354 357 366 370 374 385
;->  399 402 406 410 418 426 429 430 434 435 438 442 455 465 470 474 483 494 498 506
;->  518 530 534 555 561 574 582 590 595 598 602 606 609 610 615 618 627 638 642 645
;->  646 651 654 658 663 665 670 678 682 705 710 715 730 741 742 754 759 762 777 782
;->  786 790 795 805 806 814 822 826 830 834 854 861 874 885 890 894 897 902 903 906
;->  915 935 938 942 946 957 962 969 970 978 986 987 994)

Vediamo la velocità:

(time (map sfenico? (sequence 0 100000)))
;-> 44.88
(time (map sfenico? (sequence 0 1000000)))
;-> 794.902
(time (map sfenico? (sequence 0 10000000)))
;-> 17351.718


---------------------
Bilancia a due piatti
---------------------

Qual'è il minimo numero di pesi (masse campione) e il loro peso per pesare da 1 fino a n in una bilancia a due piatti?

La soluzione si trova nel sistema binario: occorre convertire il numero n in binario ed utilizzare come pesi i valori di tutte le potenze di 2 che si trovano nella conversione

Esempio per n = 10:

(bits 10)
;-> 1010

Ci servono quattro cifre (0 o 1) per rappresentare 10 in binario:

1*2^3 + 0*2^2 + 1*2^1 + 0*2^0 = 1*8 + 0*4 + 1*2 + 0*1 = 10

I quattro valori che ci servono sono tutte le potenze di 2 coinvolte:

2^0 = 1, 2^1 = 2, 2^2 = 4, 2^3 = 8

Quindi con quattro pesi di valore 1,2,4,8 possiamo pesare qualunque peso da 1 a 10.

Scriviamo una funzione:

(define (pesi? n)
  (let (out '())
    (for (i 0 (- (length (bits n)) 1))
      (push (pow 2 i) out -1))))

(pesi? 100)
;-> (1 2 4 8 16 32 64)

(pesi? 1000)
;-> (1 2 4 8 16 32 64 128 256 512)


-----------
Somma di 6s
-----------

Calcolare per n > 0 la somma della seguente espressione:

S(n) = 6 + 66 + 666 + ... 6(n volte)

Scriviamo una funzione:

(define (s6 n)
  (local (out)
    (setq out 0)
    (setq prev 0)
    (for (i 1 n)
      ; s(i) = s(n-1)*10 + 6
      (setq val (+ (* prev 10) 6))
      (setq out (+ out val))
      (setq prev val)
    )
    out))

Vediamo i risultati:

(map s6 (sequence 1 11))
;-> (6 72 738 7404 74070 740736 7407402 74074068
;->  740740734 7407407400 74074074066)

(+ 6 66 666 6666 66666 666666)
;-> 740736

Dal punto di vista matematico:

S(n) = 6 + 66 + 666 + ... + 6[n volte] =
     = (0+6) + (60+6) + (660 + 6) + ... + (666...60 + 6) =
     = 10 * (6 + 66 + 666 + ... + 6[n-1 volte]) + 6*n =
     = 10 * S(n-1) + 6n =
     = 10 * (S(n) - 6[n volte])

Risolvendo per S(n):

9*S(n) = 6[n volte]0 - 6*n
       = (2/3)*(9[n volte]0 - 9*n)
  S(n) = (2/3)*(1[n volte]0 - n)

Adesso poichè risulta:

1[n volte]0 = 10 + 10^2 +...+ 10^n = 10*(10^n - 1)/9

Possiamo scrivere:

S(n) = (2/3)*(10*(10^n - 1)/9 - n) =
     = (2/27) * (10^(n+1) - 10 - 9n)

Implementiamo una funzione:

(define (s6m n)
  (/ (* 2 (- (pow 10 (+ n 1)) 10 (* 9 n))) 27))

La divisione "/" per 27 viene applicata per ultima per evitare arrotondamenti.

(map s6m (sequence 1 11))
;-> (6 72 738 7404 74070 740736 7407402 74074068
;->  740740734 7407407400 74074074066)

Le due funzioni producono gli stessi risultati. Per usarle con n più grandi dovremmo usare i big-integer.

Vediamo la differenza di velocità:

(time (map s6 (sequence 1 11)) 100000)
;-> 961.145
(time (map s6m (sequence 1 11)) 100000)
;-> 300.694

La funzione "matematica" è tre volte più veloce (almeno per gli interi a 64 bit).


---------------
Serie ricorsiva
---------------

Una serie è definita in questo modo:

f[0](x) = 1/(1 - x)

f[n](x) = f0(f[n-1](x)) per n=1,2,3,4...

Calcolare f[1976](1976).

Proviamo a definire una funzione che calcola questa serie utilizzando la primitiva "series".

(series exp-start func num-count)

Partendo da "num-count" usa la funzione "func" per trasformare l'espressione precedente nell'espressione successiva "num-count" volte, in altre parole applica la funzione "func" al valore "exp-start" e il valore risultante viene passato di nuovo a "func" e cosi via per "num-count" volte. Restituisce una lista con tutti i valori calcolati.

Esempio:

(series 2 (fn(x) (div 1 x)) 4)
;-> (2 0.5 2 0.5)
primo valore = 2
secondo valore (fn 2) = 1/2 = 0.5
terzo valore (fn (fn 2)) = (fn 0.5) = 1/0.5 = 2
quarto valore (fn (fn (fn 2))) = (fn (fn 0.5)) = (fn 2) = 1/2 = 0.5

Più interessante utilizzare la funzione fn(x) = 1/(1+x) che genera numeri che si avvicinano al valore inverso del rapporto aureo:

(series 1 (fn (x) (div (add 1 x))) 20)
;-> (1 0.5 0.6666666 0.6 0.625 0.6153846 0.619047 0.6176470 0.6181818
;->  0.6179775 0.6180555 0.6180257 0.6180371 0.6180327 0.6180344
;->  0.6180338 0.6180340 0.6180339 0.6180339 0.6180339)

Scriviamo la nostra funzione e applichiamo la funzione "series" verificando i risultati:

(define (f0 x) (div 1 (- 1 x)))

(series (f0 1976) f0 1)
;-> -0.0005063291139240507
(f0 1976)
;-> -0.0005063291139240507

(series (f0 1976) f0 2)
;-> (-0.0005063291139240507 1)
(f0 (f0 1976))
;-> 1

(series (f0 1976) f0 3)
;-> (-0.0005063291139240507 1 1.#INF)
(f0 (f0 (f0 1976)))
;-> 1.#INF

Avendo raggiunto un numero infinito "1.#INF" non possiamo proseguire nel calcolo, cioè non possiamo scrivere:

(series (f0 1976) f0 1976)

per ottenere la soluzione corretta.

Proviamo a sviluppare la serie matematicamente usando l'espressione della funzione:

  f0(x) = 1/(1-x)

  f1(x) = f0(f0(x)) = 1/(1 - (1/(1-x))) = (1-x)/(-x)

  f2(x) = f0(f1(x)) = 1/(1 - (1-x)/(-x)) = x

  f3(x) = f0(f2(x)) = 1/(1-x) = f0(x)

Questo schema si ripete:

  f4(x) = f1(x)
  f5(x) = f2(x)
  f6(x) = f0(x)

Quindi:

  per (n+1) la serie vale f1(x)
  per (n+2) la serie vale f2(x)
  per (n+3) la serie vale f0(x)

con n = 0,1,2,3,4,...

Quindi per scrivere la soluzione prima definiamo le tre funzioni:

(define (f0 x) (div 1 (- 1 x)))
(define (f1 x) (div (- 1 x) (- x)))
(define (f2 x) x)

Adesso definiamo la nostra procedura utilizzando un vettore che contiene le tre funzioni che vengono chiamate in base al valore di n:

(define (f n x)
  (let (funcs (array 3 (list f0 f1 f2)))
    ((funcs (% n 3)) x)))

Proviamo a calcolare quanto richiesto:

(f 1976 1976)
;-> 1976


-----------------
Sei contro cinque
-----------------

Eva lancia 6 monete. Veronica lancia 5 monete.
Qual'è la probabilità che Eva ottenga più "teste" di Veronica?

Poniamo che 1 sia "testa" e 0 "croce".

(define (test iter)
  (let (e 0)
    (for (i 1 iter)
      (setq eva (rand 2 6))
      (setq Veronica (rand 2 5))
      (if (> (count '(1) eva) (count '(1) Veronica))
          (++ e))
      ;(println (count '(1) eva) { } (count '(1) Veronica) { } e)
      ;(read-line)
    )
    (list e iter (div e iter))))

(test 1000)
;-> (489 1000 0.489)
(test 10000)
;-> (5028 10000 0.5028)
(test 100000)
;-> (49865 100000 0.49865)
(test 1000000)
;-> (500251 1000000 0.500251)
(test 10000000)
;-> (5000474 10000000 0.5000474)

Come ci aspettavamo la simulazione mostra che Eva ha una probabilità leggermente maggiore del 50% (0.5) di ottenere più teste di Veronica, ma non possiamo essere molto precisi sul valore vero. Inoltre esistono anche le simulazioni con 1000 e 100000 lanci che mostrano una probabilità leggermente inferiore al 50% (0.489 e 0.49865).

Dal punto di vista matematico possiamo ragionare in modo generalizzato:

Eva lancia (n + 1) monete
Veronica lancia n monete

Ci possono essere due risultati (eventi):

1) Eva ottiene più teste di Veronica, oppure
2) Eva ottiene più croci di Veronica.

Questi risultati sono autoescludenti (non possono risultare contemporaneamente, o accade l'uno o accade l'altro) e la loro probabilità vale esattamente 1/2 per entrambi.

Quindi la probabilità che Eva ottenga più "teste" di Veronica è del 50%. Strano ma vero.

Possiamo anche dimostrarlo calcolando la probabilità reale con la formula:

          numero eventi favorevoli
P(Eva) = --------------------------
            numero totale eventi

Generiamo le combinazioni di Eva e quelle di Veronica:

(define (comb-rep k lst)
  (cond ((zero? k 0) '(()))
        ((null? lst) '())
        (true
         (append (map (lambda (x) (cons (first lst) x))
                      (comb-rep (- k 1) lst))
                 (comb-rep k (rest lst))))))

Per Eva:
(setq lst1 (comb-rep 6 '(1 0)))
;-> ((1 1 1 1 1 1) (1 1 1 1 1 0) (1 1 1 1 0 0) (1 1 1 0 0 0)
;->  (1 1 0 0 0 0) (1 0 0 0 0 0) (0 0 0 0 0 0))

Per Veronica:
(setq lst2 (comb-rep 5 '(1 0)))
;-> ((1 1 1 1 1) (1 1 1 1 0) (1 1 1 0 0) (1 1 0 0 0) (1 0 0 0 0) (0 0 0 0 0))

Il numero di eventi è dato dal numero di combinazioni di Eva moltiplicato il numero di combinazioni di Veronica (perchè ogni combinazione di Eva va confrontata con ogni combinazione di Veronica):

(setq num-eventi (* (length lst1) (length lst2)))
;-> 42

Adesso confrontiamo i 42 eventi e verifichiamo quale sia il risultato.
Per esempio, i primi due eventi sono:

(1 1 1 1 1 1) contro (1 1 1 1 1) ==> 6 per Eva e 5 per Veronica ==> vince Eva
(1 1 1 1 1 1) contro (1 1 1 1 0) ==> 6 per Eva e 4 per Veronica ==> vince Eva

Gli ultimi due eventi sono:

(0 0 0 0 0 0) contro (1 0 0 0 0) ==> 0 per Eva e 1 per Veronica ==> vince Veronica
(0 0 0 0 0 0) contro (0 0 0 0 0) ==> 0 per Eva e 0 per Veronica ==> vince Veronica

In codice:

(setq eva 0)
(setq eventi 0)
(dolist (el1 lst1)
  (dolist (el2 lst2)
    (if (> (first (count '(1) el1)) (first (count '(1) el2)))
        (++ eva)
    )
    (++ eventi)
  )
  (list eventi eva (div eva eventi)))
;-> (42 21 0.5)

Eva vince 21 eventi su 42, quindi la probabilità è del 50%.


------------------------------
Torneo ad eliminazione diretta
------------------------------

Un circolo di scacchi invita 32 giocatori di pari capacità a partecipare ad un torneo ad eliminazione diretta (chi vince va avanti, chi perde va fuori).
Qual'è la probabilità che due giocatori qualsiasi si scontrino durante il torneo?

Due giocatori, A e B, possono giocare insieme se:
1) si incontrano al primo turno, oppure
2) entrambi passano il primo turno e si incontrano al secondo turno, oppure
3) entrambi passano il secondo turno e si incontrano al terzo turno, oppure
x) entrambi passano il turno (x - 1) e si incontrano al turno x, oppure
N) giocano contro in finale

Questi eventi sono mutuamente esclusivi (se ne può verificare soltanto uno).

Quante partite giocano i due finalisti? Ad ogni turno si dimezzano i giocatori: 16, 8, 4, 2, 1. Quindi nel nostro caso i finalisti giocano 5 partite (32 = 2^5).

Si può dimostrare che la probabilità che due giocatori qualsiasi si scontrino vale:

P(n) = 1/2^(k-1), dove n = 2^k (con n giocatori).

Infatti, ci sono (2^n - 1) partite tra tutte le coppie e ci sono binom(2^n, 2) coppie di giocatori.

(define (chess n)
  (let (k (length (factor n)))
    (div (pow 2 (- k 1)))))

(chess 32)
;-> 0.0625

Vediamo come definire una simulazione:

(define (torneo players iter)
  (local (num k g p1 p2 lst1 lst2 conta stop turn out)
    (setq num players)
    (setq k (/ num 2))
    (setq p1 1)
    (setq p2 2)
    (setq lst1 (list p1 p2))
    (setq lst2 (list p2 p1))
    (setq conta 0)
    ; ciclo sul numero di simulazioni di un torneo
    (for (x 1 iter)
      ; lista giocatori (1..num)
      (setq g (sequence 1 num))
      (setq stop nil)
      ; ciclo sulle partite del torneo
      (for (i 1 (length (factor num)) 1 stop)
        ; divido i giocatori in coppie
        (setq turn (explode (randomize g) 2))
        ; se i giocatori si scontrano...
        (cond ((or (find lst1 turn) (find lst2 turn))
                ; allora aggiorno il contatore e
                ; termino la simulazione di questo torneo
                (++ conta)
                (setq stop true))
              ; se siamo arrivati alla finale
              ; termino la simulazione di questo torneo
              ; (non ci interessa il vincitore)
              ((= 1 (length turn))
               (setq stop true))
              (true
                ; altrimenti procedo con il prossimo turno del torneo
                (setq g '())
                ; ciclo sulla lista turn per determinare i vincitori
                ; (ognuno dei due giocatori di ogni coppia
                ; ha il 50% di probabilità di vincere)
                (dolist (el turn)
                  (if (zero? (rand 2))
                      (push (first el) g -1)
                      (push (last el) g -1))))
        )
      )
    )
    (div conta iter)))

Facciamo alcune prove:

(torneo 8 1000000)
;-> 0.249886
(chess 8)
;-> 0.25

(torneo 16 1000000)
;-> 0.124973124973125
(chess 16)
;-> 0.125

(torneo 32 1000000)
;-> 0.062574
(chess 32)
;-> 0.0625

(torneo 64 1000000)
;-> 0.03146
(chess 64)
;-> 0.03125


--------
Roulette
--------

Un giocatore ha a disposizione un certo capitale C e decide di giocare alla roulette con la strategia di
puntare sempre sul Rosso la metà del capitale posseduto in quel momento.
Dal punto di vista probabilistico, dopo n puntate il giocatore ha vinto, perso o pareggiato?

Quando vince il suo capitale diventa C*(3/2), mentre quando perde il capitale diventa C*(1/2). Dopo n puntate (con n numero pari) si avranno n/2 vittorie e n/2 sconfitte, cioè:

C(n) = C*(3/2)^(n/2) * C*(1/2)^(n/2) = C*(3/4)^(n/2)

Quindi il giocatore più gioca e più perde.

(define (cap c n) (mul c (pow (div 3 4) (/ n 2))))

Partendo con un capitale di 1000 otteniamo:

(cap 1000 10)
;-> 237.3046875
(cap 1000 20)
;-> 56.31351470947266
(cap 1000 30)
;-> 13.36346101015806

Quindi la strategia del giocatore lo porterà rapidamente in rovina.


-------------------------------
Daniel Dennet Quinian Crossword
-------------------------------

Questo non c'entra con la programmazione, ma è molto interessante: due cruciverba (crossword) che hanno soluzione doppia. Le definizioni sono in inglese perchè è impossibile tradurle mantenendo anche le doppie soluzioni. Di seguito sono riportate anche le soluzioni.

Crossword 3x3
-------------
Across
1. Suck the resources out of
2. Epoch
3. Sleep furniture

Down
1. Retentive membrane
2. Earlier
3. For some kids, a best friend

Solutions:

  W E D
  E R A
  B E D

  S A P
  A G E
  C O T


Crossword 4x4
-------------
Across
1. Dirty stuff
2. A great human need
3. To make smooth
4. Movie actor

Down
1. Vehicle dependent on H2O
2. We usually want this
3. Just above
4. U.S. state (abbrev.)

Solutions:

S L O P      S M O G
L O V E      L O V E
E V E N      E V E N
D E R N      D E R ?

S M U T
H O P E
I R O N
P E N N


----------------------------------------
Lista delle fattorizzazioni di un numero
----------------------------------------

Ogni numero intero ha una scomposizione primitiva e altre scomposizioni generate dalle combinazioni dei prodotti dei fattori della scomposizione primitiva.
Prendiamo per esempio il numero 24:

Scomposizione primitiva:
(factor 24)
;-> (2 2 2 3)

Le altre scomposizioni sono:
(2 * 2 * (2*3)) = (2 2 6)
(2 * (2*2) * 3) = (2 4 3)
(2 * (2*2*3))   = (12 2)
((2*2*2) * 3)   = (8 3)
((2*2) * (2*3)) = (4 6)

La seguente funzione calcola ricorsivamente tutte le fattorizzazioni di un numero:

(define (get-factorizations n)
  (let (afc '())
    (all-fact n '() n)))

(define (all-fact num parfac parval)
  (let ((newval parval) (i (- num 1)))
    (while (>= i 2)
      (cond ((zero? (% num i))
              (if (> newval 1) (setq newval i))
              (if (and (<= (/ num i) parval) (<= i parval) (>= (/ num i) i))
                  (begin
                    (push (append parfac (list i (/ num i))) afc -1)
                    (setq newval (/ num i))
                  )
              )
              (if (<= i parval)
                  (all-fact (/ num i) (append parfac (list i)) newval)
              )
            )
      )
      (-- i)
    )
    (sort (unique (map sort afc)))))

Facciamo alcune prove:

(get-factorizations 8)
;-> ((2 2 2) (2 4))
(get-factorizations 12)
;-> ((2 2 3) (2 6) (3 4))
(get-factorizations 24)
;-> ((2 2 2 3) (2 2 6) (2 3 4) (2 12) (3 8) (4 6))
(get-factorizations 280)
;-> ((2 2 2 5 7) (2 2 2 35) (2 2 5 14) (2 2 7 10) (2 2 70)
;->  (2 4 5 7) (2 4 35) (2 5 28) (2 7 20) (2 10 14) (2 140)
;->  (4 5 14) (4 7 10) (4 70) (5 7 8) (5 56) (7 40) (8 35)
;->  (10 28) (14 20))

Per i numeri primi non esiste alcuna fattorizzazione:

(get-factorizations 11)
;-> ()
(get-factorizations 577)
;-> ()

Comunque questa funzione è inutilizzabile per valori che hanno molti fattori nella loro scomposizione primitiva:

(factor 12000)
;-> (2 2 2 2 2 3 5 5 5)

(time (println (get-factorizations 12000)))
;->  ....
;->  (75 160)
;->  (80 150)
;->  (96 125)
;->  (100 120))
;-> 275880.184


-------------------------
Algoritmo di Bellman-Ford
-------------------------

L'algoritmo di Bellman–Ford trova i percorsi più brevi da un nodo iniziale a tutti nodi di un grafo. L'algoritmo può elaborare tutti i tipi di grafo, a condizione che il grafo non contenga un ciclo di lunghezza negativa. Se il grafo contiene un ciclo di lunghezza negativa, l'algoritmo può rilevarlo.
L'algoritmo tiene traccia delle distanze dal nodo di partenza a tutti i nodi del grafo. Inizialmente, la distanza dal nodo di partenza è 0 e la distanza da tutti gli altri nodi è infinita. L'algoritmo riduce le distanze trovando i archi che accorciano i percorsi fino a quando non è possibile ridurre alcuna distanza.

Vediamo come funziona utilizzando il seguente grafo:

        0        INF
      +---+  5  +---+
      | 0 |<--->| 1 |<---\
      +---+     +---+     \ 2
        |  \      |        \       INF
        |   \     |         \     +---+
      3 |    \7   | 3        |--->| 4 |
        |     \   |         /     +---+
        |      \  |        /
      +---+     +---+     / 2
      | 2 |<--->| 3 |<---/
      +---+  1  +---+
       INF       INF

Ad ogni nodo del grafico viene assegnata una distanza. Inizialmente, la distanza dal nodo iniziale è 0 e la distanza da tutti gli altri nodi è infinita (INF). L'algoritmo ricerca archi che riducono le distanze. Per primo cosa tutti gli archi del nodo 0 riducono le distanze:

        0         5
      +---+  5  +---+
      | 0 |<--->| 1 |<---\
      +---+     +---+     \ 2
        |  \      |        \       INF
        |   \     |         \     +---+
      3 |    \7   | 3        |--->| 4 |
        |     \   |         /     +---+
        |      \  |        /
      +---+     +---+     / 2
      | 2 |<--->| 3 |<---/
      +---+  1  +---+
        3         7

Dopo questo gli archi 1-->4 e 2-->3 riducono la distanza:

        0         5
      +---+  5  +---+
      | 0 |<--->| 1 |<---\
      +---+     +---+     \ 2
        |  \      |        \        7
        |   \     |         \     +---+
      3 |    \7   | 3        |--->| 4 |
        |     \   |         /     +---+
        |      \  |        /
      +---+     +---+     / 2
      | 2 |<--->| 3 |<---/
      +---+  1  +---+
        3         4

Infine l'arco 3-->4 riduce la distanza:

        0         5
      +---+  5  +---+
      | 0 |<--->| 1 |<---\
      +---+     +---+     \ 2
        |  \      |        \        6
        |   \     |         \     +---+
      3 |    \7   | 3        |--->| 4 |
        |     \   |         /     +---+
        |      \  |        /
      +---+     +---+     / 2
      | 2 |<--->| 3 |<---/
      +---+  1  +---+
        3         4

A questo punto non è possibile ridurre le distanze e abbiamo calcolato tutte le distanze minime dal nodo di partenza (0) a tutti gli altri nodi.

La seguente implementazione dell'algoritmo determina le distanze più brevi da un nodo iniziale a tutti i nodi del grafo. Il codice presuppone che il grafo sia memorizzato come una lista di archi che consiste in una lista della forma (a, b, w): questo significa che c'è un arco dal nodo a al nodo b con peso w.
L'algoritmo consiste di (n-1) cicli e ad ogni ciclo l'algoritmo attraversa tutti gli archi del grafo e cerca di ridurre le distanze. L'algoritmo costruisce una "lista delle distanze" che contiene i valori delle distanze dal nodo iniziale a tutti i nodi del grafo e una "lista di predecessori" che serve per ricostruire tutti i percorsi minimi dal nodo iniziale a tutti i nodi del grafo. La costante INF indica una distanza infinita.
La complessità temporale dell'algoritmo è O(nm), perché l'algoritmo consiste di n-1 cicli e itera su tutti gli archi per ogni ciclo. Se non ci sono cicli negativi nel grafo, tutte le distanze sono definitive dopo n-1 cicli, perché ogni percorso più breve può contenere al massimo n-1 archi.
In pratica, le distanze finali di solito possono essere trovate prima che si esauriscano tutti gli n-1 cicli, ertanto, un possibile modo per rendere l'algoritmo più efficiente è arrestare l'algoritmo se nessuna distanza può essere ridotta durante un ciclo.

(define (bf graph start num-nodi)
  (local (dist a b w)
    (setq maxval 999999)
    (setq dist (array num-nodi (list maxval)))
    (setq pred (array num-nodi '(nil)))
    (setf (dist start) 0)
    (for (i 1 (- num-nodi 1))
      (for (j 0 (- (length graph) 1))
        (setq a (graph j 0))
        (setq b (graph j 1))
        (setq w (graph j 2))
        ;(println a { } b { } w)
        ;(read-line)
        (if (!= (dist a) maxval)
            (if (> (dist b) (+ (dist a) w))
                (begin
                 (setf (dist b) (+ (dist a) w))
                 (setf (pred b) a)
                ))
        )
      )
    )
    ; cicli negativi?
    (for (j 0 (- (length graph) 1))
      (setq a (graph j 0))
      (setq b (graph j 1))
      (setq w (graph j 2))
      (if (and (!= (dist a) maxval) (< (+ (dist a) w) (dist b)))
          (println "ERRORE: ciclo negativo")
      )
    )
    ; Ricostruzione percorsi completi
    (for (nodo 0 (- num-nodi 1))
      (setq path '())
      (print "da: " start " a: " nodo " = ")
      (cond ((= start nodo)
             (setq path '(nil)))
             ;(println "nil"))
            (true
             (setq step (pred nodo))
             (until (= start step)
               (push step path -1)
               ;(print step { } )
               (setq step (pred step))
             )
             ; inverte percorso
             (reverse path)
             ; inserisce nodo iniziale
             (push start path)
             ; inserisce nodo finale
             (push nodo path -1)
             ;(println nodo)
            )
      )
      (println path)
    )
    (list dist pred)))

Proviamo con il grafo seguente (disegnatelo con carta e penna):

(setq graph '((0 1 50) (0 2 30) (0 3 10)
              (1 0 50) (1 5 40)
              (2 0 30) (2 1 10) (2 3 10) (2 4 10)
              (3 0 10) (3 2 10) (3 6 10)
              (4 2 10) (4 5 20)
              (5 1 40) (5 4 20)
              (6 5 80)))

(bf graph 0 7)
;-> da: 0 a: 0 = (nil)
;-> da: 0 a: 1 = (0 3 2 1)
;-> da: 0 a: 2 = (0 3 2)
;-> da: 0 a: 3 = (0 3)
;-> da: 0 a: 4 = (0 3 2 4)
;-> da: 0 a: 5 = (0 3 2 4 5)
;-> da: 0 a: 6 = (0 3 6)
;-> ((0 30 20 10 30 50 20) (nil 2 3 0 2 4 3))

(bf graph 1 7)
;-> da: 1 a: 0 = (1 0)
;-> da: 1 a: 1 = (nil)
;-> da: 1 a: 2 = (1 0 3 2)
;-> da: 1 a: 3 = (1 0 3)
;-> da: 1 a: 4 = (1 5 4)
;-> da: 1 a: 5 = (1 5)
;-> da: 1 a: 6 = (1 0 3 6)
;-> ((50 0 70 60 60 40 70) (1 nil 3 0 5 1 3))

(bf graph 4 7)
;-> da: 4 a: 0 = (4 2 3 0)
;-> da: 4 a: 1 = (4 2 1)
;-> da: 4 a: 2 = (4 2)
;-> da: 4 a: 3 = (4 2 3)
;-> da: 4 a: 4 = (nil)
;-> da: 4 a: 5 = (4 5)
;-> da: 4 a: 6 = (4 2 3 6)
;-> ((30 20 10 20 0 20 30) (3 2 4 2 nil 4 3))


----------------
Catene di Markov
----------------

Una catena di Markov è un processo casuale che consiste di stati e transizioni tra di loro. Per ogni stato, conosciamo le probabilità di spostarci in altri stati. Una catena di Markov può essere rappresentata come un grafico i cui nodi sono stati e gli archi sono transizioni. Ad esempio, consideriamo un problema in cui ci troviamo al piano 1 di un edificio di n piani. Ad ogni passo, ci spostiamo casualmente di un piano su o di un piano giù. Qual è la probabilità di trovarsi al piano m dopo k passi?
In questo problema, ogni piano dell'edificio corrisponde a uno stato in una catena di Markov.
Ad esempio, se n = 5, il grafico è il seguente:

      --> 1      --> 1/2    --> 1/2    --> 1/2
   +----------+ +--------+ +--------+ +---------+
   |          | |        | |        | |         |
  +---+      +---+      +---+      +---+      +---+
  | 1 | <--> | 2 | <--> | 3 | <--> | 4 | <--> | 5 |
  +---+      +---+      +---+      +---+      +---+
   |          | |        | |        | |         |
   +----------+ +--------+ +--------+ +---------+
      1/2 <--     1/2 <--    1/2 <--     1 <--

La distribuzione di probabilità di una catena di Markov è un vettore [p1, p2, ..., pn], dove pk è la probabilità che lo stato corrente sia k. La formula p1 + p2 + ... + pn = 1 vale sempre.
Nello scenario precedente, la distribuzione iniziale è (1 0 0 0 0), perché iniziamo sempre dal piano 1. La distribuzione successiva è [0,1,0,0,0], perché possiamo solo muoverci dal piano 1 al piano 2. Dopodiché, possiamo spostarci di un piano in alto o di un piano in basso, quindi la distribuzione successiva è (1/2 0 1/2 0 0) e così via.

Una catena Markov si basa sulla proprietà di Markov: la probabilità che un sistema casuale cambi da uno stato particolare al successivo stato di transizione dipende solo dallo stato e dal tempo presente ed è indipendente dagli stati precedenti. Il fatto che il probabile stato futuro di un processo casuale sia indipendente dalla sequenza di stati che esisteva prima di esso rende la catena di Markov un processo senza memoria che dipende solo dallo stato corrente della variabile.

Un modo efficiente per simulare il cammino in una catena di Markov è usare la programmazione dinamica. L'idea è di mantenere il vettore della distribuzione di probabilità e ad ogni passaggio esaminare tutte le possibilità su come possiamo muoverci. Usando questo metodo, possiamo simulare una camminata di m passi in tempo O(n^2*m).

Le transizioni di una catena di Markov possono anche essere rappresentate come una matrice di transizione che aggiorna la distribuzione di probabilità. Per l'esempio precedente, la matrice vale:

  0   1/2   0     0     0
  1   0     1/2   0     0
  0   1/2   0     1/2   0
  0   0     1/2   0     1
  0   0     0     1/2   0

Quando moltiplichiamo una distribuzione di probabilità per questa matrice, otteniamo la nuova distribuzione dopo aver fatto un passo. Ad esempio, possiamo passare dalla distribuzione (1 0 0 0 0) alla distribuzione (0 1 0 0 0) come segue:

  0   1/2   0     0     0
  1   0     1/2   0     0
  0   1/2   0     1/2   0
  0   0     1/2   0     1
  0   0     0     1/2   0

Calcolando le potenze della matrice in modo efficiente, possiamo calcolare la distribuzione dopo m passi in tempo O(n^3*log(m)).

In generale, i processi Markoviani (che generano le catene di Markov) sono caratterizzati dalle seguenti proprietà:

1) Rappresentano transizioni tra stati che avvengono in modo probabilistico.

2) Le probabilità di transizione non dipendono dal numero di transizioni effettuate (proprietà di omogeneità).

3) Le probabilità di transizione dipendono unicamente dallo stato attuale (proprietà memoryless, o di assenza di memoria).

Le catene di Markov sono uno strumento matematico essenziale che aiuta a semplificare la previsione dello stato futuro di processi stocastici complessi, infatti questo dipende esclusivamente dallo stato attuale del processo e vede il futuro come indipendente dal passato. Ad esempio vengono utilizzate per le previsioni del tempo, la predizione di parole digitate sul telefono, riconoscimento della scrittura, simulazione di ecosistemi, ecc.

Adesso vediamo una implementazione pratica delle catene di Markov.

Data una catena di Markov G, trovare la probabilità di raggiungere lo stato F all'istante t = T se partiamo dallo stato S all'istante t = 0.
Una catena di Markov è un processo casuale costituito da vari stati e dalle probabilità di spostarsi da uno stato all'altro. Possiamo rappresentarlo utilizzando un grafo orientato dove i nodi rappresentano gli stati e gli archi rappresentano la probabilità di andare da un nodo all'altro. Ci vuole una unità tempo per spostarsi da un nodo all'altro. La somma delle probabilità associate degli archi uscenti vale 1 per ogni nodo.

Consideriamo la catena di Markov (G) dell'immagine "markov.png".
Possiamo creare una matrice di adiacenza della catena di Markov per rappresentare le probabilità di transizioni tra gli stati.

La matrice di adiacenza per il nostro grafo vale:

      0      0.09   0      0      0     0
      0.23   0      0      0      0     0.62
      0      0.06   0      0      0     0
      0.77   0      0.63   0      0     0
      0      0      0      0.65   0     0.38
      0      0.85   0.37   0.35   1.0   0

Possiamo osservare che la distribuzione di probabilità al tempo t è data da P(t) = M * P(t - 1), e la distribuzione di probabilità iniziale P(0) è un vettore zero con l'elemento S-th che vale 1. Usando questi risultati, possiamo risolvere l'espressione ricorsiva per P(t). Ad esempio, se prendiamo S = 3, allora P(t) è dato da:

             | 0 |
             | 0 |
P(t) = M^t * | 1 |
             | 0 |
             | 0 |
             | 0 |

La complessità temporale di questo algoritmo vale O(N^3*log(T)) dove N è il numero di stati e T e il numero di transizioni (tempi).

Funzione per calcolare la potenza di una matrice:

(define (pow-matrix mtx p n)
  (let (out (array n n '(0)))
    (for (i 0 (- n 1))
      (setf (out i i) 1)
    )
    (while (> p 0)
      (if (odd? p) (setq out (multiply out mtx)))
      (setq mtx (multiply mtx mtx))
      (setq p (/ p 2))
    )
    out))

(setq m '((2 -2 9) (7 -4 4) (1 2 3)))
(pow-matrix m 2 3)
;-> ((-1 22 37) (-10 10 59) (19 -4 26))

(define (markov matrix num-stati stato-iniziale stato-finale tempo)
  (let (out (pow-matrix matrix tempo num-stati))
    (out (- stato-finale 1) (- stato-iniziale 1))))

Proviamo la funzione:

(setq matrix '((0      0.09   0      0      0     0   )
               (0.23   0      0      0      0     0.62)
               (0      0.06   0      0      0     0   )
               (0.77   0      0.63   0      0     0   )
               (0      0      0      0.65   0     0.38)
               (0      0.85   0.37   0.35   1.0   0   )))

(markov matrix 6 1 2 1)
;-> 0.23
Input:  stato-iniziale = 1, stato-finale = 2, tempo = 1
Output: 0.23
Partiamo dallo stato 1 per t = 0,
La probabilità di raggiungere lo stato 2 per t = 1 vale 0.23.

(markov matrix 6 4 2 100)
;-> 0.284991
Input : stato-iniziale = 4, stato-finale = 2, tempo = 100
Output : 0.284992
Partiamo dallo stato 4 per t = 0,
La probabilità di raggiungere lo stato 2 per t = 100 vale 0.284992.


----------------------
Contornare una matrice
----------------------

Data una matrice NxM contornare la matrice con k righe e colonne con un determinato valore.
Esempio:
          |1 1|
matrice = |1 1|
          |1 1|
k = 2

Valore: 0

        |0 0 0 0 0 0|
        |0 0 0 0 0 0|
        |0 0 1 1 0 0|
output: |0 0 1 1 0 0|
        |0 0 1 1 0 0|
        |0 0 0 0 0 0|
        |0 0 0 0 0 0|

Funzione che contorna una matrice:

(define (pad-matrix mtx pad val)
  (local (row col out)
    (setq out '())
    (if (array? mtx) (setq mtx (array-list mtx)))
    (setq row (+ (* 2 pad) (length mtx)))
    (setq col (+ (* 2 pad) (length (mtx 0))))
    ; aggiunge pad righe iniziali ad out
    (for (i 1 pad)
      (push (dup val col true) out -1)
    )
    ; aggiunge le righe centrali ad out
    (dolist (el mtx)
      (setq cur (append (dup val pad true) el (dup val pad true)))
      (push cur out -1)
    )
    ; aggiunge pad righe finali ad out
    (for (i 1 pad)
      (push (dup val col true) out -1)
    )
    out))

Funzione per stampare una matrice:

(define (print-matrix matrix)
  (local (row col nmax nmin digit fmtstr)
    (if (array? matrix) (setq matrix  (array-list matrix)))
    (setq row (length matrix))
    (setq col (length (first matrix)))
    (setq nmax (string (apply max (flat matrix))))
    (setq nmin (string (apply min (flat matrix))))
    (setq digit (add 1 (max (length nmax) (length nmin))))
    (setq fmtstr (append "%" (string digit) "d"))
    (for (i 0 (sub row 1))
      (for (j 0 (sub col 1))
        (print (format fmtstr (matrix i j)))
      )
      (println))
    '.))

(setq m '((1 1) (1 1) (1 1)))

(print-matrix (pad-matrix m 2 0))
;-> |0 0 0 0 0 0|
;-> |0 0 0 0 0 0|
;-> |0 0 1 1 0 0|
;-> |0 0 1 1 0 0|
;-> |0 0 1 1 0 0|
;-> |0 0 0 0 0 0|
;-> |0 0 0 0 0 0|

Il primo indice (0 0) del primo valore (1) della matrice "m" si trova all'indice (pad pad) della matrice "out" di output.

Esempio:
(setq b '((0)))
(for (i 1 9)
  (setq b (pad-matrix b 1 i))
)
(print-matrix b)
;-> 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9
;-> 9 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 9
;-> 9 8 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 8 9
;-> 9 8 7 6 6 6 6 6 6 6 6 6 6 6 6 6 7 8 9
;-> 9 8 7 6 5 5 5 5 5 5 5 5 5 5 5 6 7 8 9
;-> 9 8 7 6 5 4 4 4 4 4 4 4 4 4 5 6 7 8 9
;-> 9 8 7 6 5 4 3 3 3 3 3 3 3 4 5 6 7 8 9
;-> 9 8 7 6 5 4 3 2 2 2 2 2 3 4 5 6 7 8 9
;-> 9 8 7 6 5 4 3 2 1 1 1 2 3 4 5 6 7 8 9
;-> 9 8 7 6 5 4 3 2 1 0 1 2 3 4 5 6 7 8 9
;-> 9 8 7 6 5 4 3 2 1 1 1 2 3 4 5 6 7 8 9
;-> 9 8 7 6 5 4 3 2 2 2 2 2 3 4 5 6 7 8 9
;-> 9 8 7 6 5 4 3 3 3 3 3 3 3 4 5 6 7 8 9
;-> 9 8 7 6 5 4 4 4 4 4 4 4 4 4 5 6 7 8 9
;-> 9 8 7 6 5 5 5 5 5 5 5 5 5 5 5 6 7 8 9
;-> 9 8 7 6 6 6 6 6 6 6 6 6 6 6 6 6 7 8 9
;-> 9 8 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 8 9
;-> 9 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 9
;-> 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9

Esempio:
(setq b '((0)))
(for (i 1 42)
  (setq b (pad-matrix b 1 i))
)
(device (open "matrix42.txt" "write"))
(print-matrix b)
(close (device))

----------------------------------------------------
Stringa decimale infinita 12345678910111213141516...
----------------------------------------------------

La stringa decimale infinita viene creata unendo tutti i numeri naturali da 1 a infinito (∞):

"123456789101112131415161718192021222324252627282930..."

Poichè non è possibile memorizzarla interamente in una struttura dati, diventa interessante la soluzione di due problemi:

1) quale cifra si trova alla posizione K della stringa?
-------------------------------------------------------

Esempi:
K = 1     il primo carattere è "1"
K = 10      10-imo carattere è "1"
K = 11      11-imo carattere è "0"
K = 50      50-imo carattere è "3"
K = 190    190-imo carattere è "1"

Possiamo risolvere questo problema spezzando la stringa in base ai seguenti criteri:
 I primi 9 decimali hanno lunghezza 1, poi 90 numeri sono di lunghezza 2, poi 900 numeri sono di lunghezza 3 e così via, quindi possiamo saltare questi numeri in base al dato K e poi ricavare il carattere cercato.

La K-esima cifra sarà compresa tra 10^k e 10^(k + 1) per qualche k intero.
Se la risposta non è compresa tra 10^m e 10^(m + 1) per il valore di m che stiamo
attualmente verificando, aumentiamo m di 1 e sottraiamo la lunghezza dei numeri da 10^m a 10^(m + 1). Una volta trovata la potenza di 10 dove si trova il numero, tutti i numeri che dobbiamo controllare hanno "ordine" cifre, e possiamo usare la divisione intera per determinare il numero e poi estrarre il carattere con il modulo.

Funzione che calcola la potenza intera di un numero intero:

(define (** num power)
    (if (zero? power)
        1
    (let (out 1)
        (dotimes (i power)
            (setq out (* out num))))))

Funzione che trova la cifra alla posizione k della stringa:

(define (find-digit k)
  (local (ordine intervallo)
    (setq ordine 1L)
    (find-digit-aux k ordine)))

(define (find-digit-aux k ordine)
    (setq intervallo (* 9 ordine (** 10 (- ordine 1))))
    (if (> k intervallo)
        (begin
        (find-digit-aux (- k intervallo) (+ ordine 1)))
        ;else
        (begin
        (setq num (+ (** 10 (- ordine 1)) (/ (- k 1) ordine)))
        (setq numstr (string num))
        (numstr (% (- k 1) ordine)))
    ))

(find-digit 10)
;-> "1"
(find-digit 11)
;-> "0"
(find-digit 50)
;-> "3"
(find-digit 190)
;-> "1"
(find-digit 9)
;-> "9"
(find-digit 0)
;-> "0"
(find-digit 456)
;-> "8"
(find-digit 454)
;-> "1"
(find-digit 2000)
;-> "0"
(find-digit 2001)
;-> "3"
(find-digit 1234)
;-> "4"

Possiamo usare anche un metodo iterativo:

(define (find-cifra k)
  (local (lun conta num strnum)
    (setq lun 1 conta 9 num 1)
    (while (> k (* lun conta))
      (setq k (- k (* lun conta)))
      (++ lun)
      (setq conta (* conta 10))
      (setq num (* num 10))
    )
    (setq num (+ num (/ (- k 1) lun)))
    (setq strnum (string num))
    (int (strnum (% (- k 1) lun)))))

(find-cifra 10)
;-> "1"
(find-cifra 11)
;-> "0"
(find-cifra 50)
;-> "3"
(find-cifra 190)
;-> "1"
(find-cifra 9)
;-> "9"
(find-cifra 0)
;-> "0"
(find-cifra 456)
;-> "8"
(find-cifra 454)
;-> "1"
(find-cifra 2000)
;-> "0"
(find-cifra 2001)
;-> "3"
(find-cifra 1234)
;-> "8"

2) in quale posizione della stringa inizia un numero N?
-------------------------------------------------------

Utilizziamo la tecnica di "Window slicing": creiamo una stringa di numeri da 1 a x e cerchiamo al suo interno il numero N, se non lo troviamo costruiamo un'altra stringa lunga da x a (+ x x) aggiungendo all'inizio gli ultimi len(N) caratteri della stringa precedente (per verificare su il numero N si trova in una sovrapposizione di finestre) e verifichiamo se troviamo N, altrimenti continuiamo con una nuova stringa.

Funzione che genera la stringa da a a b:

(define (genera a b) (join (map string (sequence a b))))

(genera 1 20)
;-> "1234567891011121314151617181920"
(genera 20 40)
;-> "202122232425262728293031323334353637383940"

Funzione di ricerca del numero N nella stringa:

(define (find-str str)
  (setq pos 0)
  (setq lenstr (length str))
  (setq lenwin (max 50 lenstr))
  (setq num1 1)
  (setq num2 (+ num1 lenwin))
  (setq curstr (genera num1 num2))
  (setq indice (find str curstr))
  (until indice
    (setq pos (+ pos (length curstr) (- lenstr)))
    (setq num1 (+ num2 1))
    (setq num2 (+ num1 lenwin))
    (setq curstr (append (slice curstr (- lenstr)) (genera num1 num2)))
    (setq indice (find str curstr))
  )
  (+ pos indice))

(find-str "141")
;-> 17
(find "141" (genera 11 20))
;-> 17

(find-str "67")
;-> 5
(find "67" (genera 1 10))
;-> 5

(find-str "454")
;-> 79
(find "454" (genera 1 100))
;-> 79

(find-str "222")
;-> 33
(find "222" (genera 1 30))
;-> 33

(find-str "85")
;-> 106
(find "85" (genera 1 60))
;-> 106

(find-str "81")
;-> 26
(find "81" (genera 1 60))
;-> 26

(find-str "333")
;-> 55
(find "333" (genera 1 60))
;-> 55

(find-str "12345")
;-> 0

Potremmo usare questa funzione per generare una password, per esempio possiamo passare alla funzione una data speciale ed ottenere un numero che può essere usato come password:

(find-str "19700321")
;-> 12679113

Vediamo se la larghezza della finestra influenza la velocità della funzione:

(define (find-str str window)
  (setq pos 0)
  (setq lenstr (length str))
  (setq lenwin (max window lenstr))
  (setq num1 1)
  (setq num2 (+ num1 lenwin))
  (setq curstr (genera num1 num2))
  (setq indice (find str curstr))
  (until indice
    (setq pos (+ pos (length curstr) (- lenstr)))
    (setq num1 (+ num2 1))
    (setq num2 (+ num1 lenwin))
    (setq curstr (append (slice curstr (- lenstr)) (genera num1 num2)))
    (setq indice (find str curstr))
  )
  (+ pos indice))

(time (find-str "19700321" 10) 10)
;-> 7656.259

(time (find-str "19700321" 50) 10)
;-> 7642.337

(time (find-str "19700321" 255) 10)
;-> 7647.513

(time (find-str "19700321" 1000) 10)
;-> 7624.258

Sembra che la larghezza della finestra non influenzi la velocità della funzione.


-----------------
Numeri early-bird
-----------------

Consideriamo la stringa decimale infinita:

"123456789101112131415161718192021222324252627282930..."

La funzione "(find-cifra k)" trova la cifra che si trova alla posizione k della stringa, ma determina anche il numero corrente della stringa infinita.
Quindi la usiamo per scrivere la nuova funzione "(trova-num k)" che trova il numero corrente della stringa infinita all'indice k.

(define (trova-num k)
  (local (lun conta num strnum)
    (setq lun 1 conta 9 num 1)
    (while (> k (* lun conta))
      (setq k (- k (* lun conta)))
      (++ lun)
      (setq conta (* conta 10))
      (setq num (* num 10))
    )
    (setq num (+ num (/ (- k 1) lun)))
    (setq strnum (string num))
    (int (strnum (% (- k 1) lun)))
    num))

La funzione "(find-str str)" trova la posizione della stringa in cui inizia un numero (passato in formato stringa):

(define (genera a b) (join (map string (sequence a b))))

(define (find-str str)
  (setq pos 0)
  (setq lenstr (length str))
  (setq lenwin (max 50 lenstr))
  (setq num1 1)
  (setq num2 (+ num1 lenwin))
  (setq curstr (genera num1 num2))
  (setq indice (find str curstr))
  (until indice
    (setq pos (+ pos (length curstr) (- lenstr)))
    (setq num1 (+ num2 1))
    (setq num2 (+ num1 lenwin))
    (setq curstr (append (slice curstr (- lenstr)) (genera num1 num2)))
    (setq indice (find str curstr))
  )
  (+ pos indice))

Combinando queste due funzioni possiamo trovare i numeri early-bird.
Per capire cosa sono i numeri early-bird facciamo un esempio:

Vediamo a quale carattere della stringa infinita incontriamo il numero 141:

(find-str "141")
;-> 17

Il numero 141 si incontra al 17-esimo carattere della stringa infinita, infatti:

(genera 1 46)
                  ___
"1234567891011121314151617181920..."

Adesso vediamo quale numero inizia al carattere successivo:

(trova-num 18)
;-> 14

Al 18-esimo carattere inizia il numero 14.

Quindi il numero 141 compare quando inizia il numero 14 nella stringa infinita, cioè  compare prima di quando inizia il numero 141 nella stringa infinita.
Quindi 141 è un numero "early bird" (nato prima).

Possiamo scrivere una funzione che calcola tutti i numeri early-bird fino ad un determinato numero:

(define (early-bird num)
  (let (out '())
    (for (i 1 num)
      (if (< (trova-num (+ (find-str (string i)) 1)) i)
          (push i out -1)))
    out))

(early-bird 50)
;-> (12 21 23 31 32 34 41 42 43 45)

Proviamo la correttezza dei risultati confrontandoli con la sequenza OEIS A116700:

(setq A116700 '(12 21 23 31 32 34 41 42 43 45
      51 52 53 54 56 61 62 63 64 65 67 71 72
      73 74 75 76 78 81 82 83 84 85 86 87 89
      91 92 93 94 95 96 97 98 99 101 110 111
      112 121 122 123 131 132 141 142 151 152
      161 162 171))

(= (early-bird 171) A116700)
;-> true

Vediamo dove possiamo arrivare:

(time (println (length (early-bird 5000))))
;-> 2805
;-> 2694.607
(time (println (length (early-bird 10000))))
;-> 7571
;-> 7400.475
(time (println (length (early-bird 20000))))
;-> 10400
;-> 49163.784
(time (println (length (early-bird 40000))))
;-> 23214
;-> 183631.179


-------------------
Zero elevato a zero
-------------------

Quanto vale 0^0 ?

Proviamo a calcolarlo come limite:

limite(x^x)
 x->0

(define (lim x) (pow x x))

(for (i 1 0.1 -0.1) (println (round i -3) { } (round (lim i) -3)))
;-> 1 1
;-> 0.9 0.91
;-> 0.8 0.837
;-> 0.7 0.779
;-> 0.6 0.736
;-> 0.5 0.707
;-> 0.4 0.693
              <------- inversione di tendenza
;-> 0.3 0.697
;-> 0.2 0.725
;-> 0.1 0.794

(for (i 0.1 0.001 -0.005) (println (round i -5) { } (round (lim i) -5)))
;-> 0.1   0.79433
;-> 0.095 0.79962
;-> 0.090 0.80516
;-> 0.085 0.81096
;-> 0.080 0.81705
;-> 0.075 0.82344
;-> 0.070 0.83015
;-> 0.065 0.83722
;-> 0.060 0.84467
;-> 0.055 0.85255
;-> 0.050 0.86089
;-> 0.045 0.86975
;-> 0.040 0.87919
;-> 0.035 0.88929
;-> 0.030 0.90015
;-> 0.025 0.9119
;-> 0.020 0.92474
;-> 0.015 0.93895
;-> 0.010 0.95499
;-> 0.005 0.97386

Poichè il limite tende a 1, allora 0^0 = 1.

Per quale valore si inverte la tendenza (cioè si ha un minimo della funzione)?

La derivata di x^x vale: x^x*(1 + ln(x))

Il minimo si ha nel punto in cui la derivata vale 0:

  x^x*(1+ln(x)) = 0 quando (1 + ln(x)) = 0,

  cioè per x = e^(-1) = 1/e = 0.3678794411714423


------------------
Fattoriale di zero
------------------

Perchè 0! = 1 ?

Il fattoriale di un numero può essere scritto nel modo seguente:

     (x + 1)!
x! = --------
     (x + 1)

Adesso sostituiamo x con alcuni numeri:

3! = 4!/4 = 24/4 = 6
2! = 3!/3 = 6/3  = 2
1! = 2!/2 = 2/2  = 1
0! = 1!/1 = 1/1  = 1

Quindi 0! = 1.


--------------------------------------
Somma delle potenze dei primi n numeri
--------------------------------------

Per trovare la somma dei primi n numeri possiamo usare la formula seguente:

Sum[1..n] (i) = (n*(n+1))/2 = (n^2 + n)/2

(define (sumpot1 n)
  (/ (+ (** n 2) n) 2))

Vediamo come l'ha risolto Gauss a 8 anni (con n = 100):

Esempio: n = 10

1 + 10 = 11
2 +  9 = 11
3 +  8 = 11
4 +  7 = 11
5 +  6 = 11

(n + 1) = 11
n/2 = 5

11 * 5 = 55

Esempio: n = 5

1 + 5 = 6
2 + 4 = 6
3

(12 + 3) = 15

Funzione che calcola la potenza intera di un numero intero (big-integer):

(define (** num power)
    (let (out 1L)
        (dotimes (i power)
            (setq out (* out num)))))

Somma dei primi n quadrati (numeri piramidali)
----------------------------------------------
Sum[1..n] (i^2) = (2*n^3 + 3*n^2 + n)/6

(define (sumpot2 n)
  (/ (+ (* 2 (** n 3)) (* 3 (** n 2)) n) 6))

Assumendo che esista una formula per la somma dei quadrati, la pendenza di quella funzione deve essere quadratica, quindi la funzione che cerchiamo deve essere di terzo grado. Quindi sappiamo che la formula ha la seguente struttura:

   a*n^3 + b*n^2 + c*n + d*n

Con 4 equazioni questo problema è risolto (es. Poniamo n = 0, troviamo che d = 0. Con n = 1, n = 2 e n = 3 otteniamo un sistema lineare di equazioni che risolto produce a = 1/3 , b = 1/2 e c = 1/6).
Con lo stesso metodo possiamo calcolare le sommatorie delle potenze successive.

Somma dei primi n cubi
----------------------
Sum[1..n] (i^3) = (n^4 + 2*n^3 + n^2)/4

(define (sumpot3 n)
  (/ (+ (** n 4) (* 2L (** n 3)) (** n 2)) 4))

Somma delle prime quarte potenze
--------------------------------
Sum[1..n] (i^4) = (6*n^5 + 15*n^4 + 10*n^3 + n)/30

(define (sumpot4 n)
  (/ (+ (* 6L (** n 5)) (* 15L (** n 4)) (* 10L (** n 3)) (- n)) 30))

Somma delle prime quinte potenze
--------------------------------
Sum[1..n] (i^5) = (2*n^6 + 6*n^5 + 5*n^4 - n^2)/12

(define (sumpot5 n)
  (/ (+ (* 2L (** n 6)) (* 6L (** n 5)) (* 5L (** n 4)) (- (** n 2))) 12))

Somma delle prime seste potenze
-------------------------------
Sum[1..n] (i^6) = (6*n^7 + 21*n^6 + 21*n^5 - 7*n^3 + n)/42

(define (sumpot6 n)
  (/ (+ (* 6L (** n 7)) (* 21L (** n 6)) (* 21L (** n 5))
     (- (* 7L (** n 3))) n) 42))

Somma delle prime settime potenze
---------------------------------
Sum[1..n] (i^7) = (3*n^8 + 12*n^7 + 14*n^6 - 7*n^4 + 2*n^2)/24

(define (sumpot7 n)
  (/ (+ (* 3L (** n 8)) (* 12L (** n 7)) (* 14L (** n 6))
        (- (* 7L (** n 4))) (* 2L (** n 2))) 24))

Somma delle prime ottave potenze
--------------------------------
Sum[1..n] (i^8) = (10*n^9 + 45*n^8 + 60*n^7 - 42*n^5 + 20*n^3 - 3*n)/90

(define (sumpot8 n)
  (/ (+ (* 10L (** n 9)) (* 45L (** n 8)) (* 60L (** n 7))
        (* (- 42L) (** n 5)) (* 20L (** n 3)) (* (- 3L) n)) 90))

Somma delle prime none potenze
------------------------------
Sum[1..n] (i^9) = (2*n^10 + 10*n^9 + 15*n^8 - 14*n^6 + 10*n^4 - 3*n^2)/20

(define (sumpot9 n)
  (/ (+ (* 2L (** n 10)) (* 10L (** n 9)) (* 15L (** n 8))
        (* (- 14L) (** n 6)) (* 10L (** n 4)) (* (- 3L) (** n 2))) 20))

Somma delle prime decime potenze
--------------------------------
Sum[1..n] (i^10) = (6*n^11 + 33*n^10 + 55*n^9 - 66*n^7 + 66*n^5 - 33*n^3 + 5*n)/66

(define (sumpot10 n)
  (/ (+ (* 6L (** n 11)) (* 33L (** n 10)) (* 55L (** n 9)) (* (- 66L) (** n 7))
        (* 66L (** n 5)) (* (- 33L) (** n 3)) (* 5 n)) 66))

Per le verifiche possiamo usare la seguente funzione per il confronto dei risultati:

(define (somma pot num)
  (apply + (map (fn(x) (** x pot)) (sequence 1 num))))

Facciamo un test per i primi 100 numeri di tutte le formule:

(for (num 1 100)
  (if (!= (somma 2  num) (sumpot2  num)) (println "ERROR 2: "  num))
  (if (!= (somma 3  num) (sumpot3  num)) (println "ERROR 3: "  num))
  (if (!= (somma 4  num) (sumpot4  num)) (println "ERROR 4: "  num))
  (if (!= (somma 5  num) (sumpot5  num)) (println "ERROR 5: "  num))
  (if (!= (somma 6  num) (sumpot6  num)) (println "ERROR 6: "  num))
  (if (!= (somma 7  num) (sumpot7  num)) (println "ERROR 7: "  num))
  (if (!= (somma 8  num) (sumpot8  num)) (println "ERROR 8: "  num))
  (if (!= (somma 9  num) (sumpot9  num)) (println "ERROR 9: "  num))
  (if (!= (somma 10 num) (sumpot10 num)) (println "ERROR 10: " num))
)
;-> nil


-----------
Cercaparole
-----------

Il "Cercaparole" è un gioco che consiste nel cercare alcune parole inglobate in una matrice di caratteri. Per esempio,

Matrice di caratteri:

(setq matrice
'(("F" "A" "V" "J" "L" "Y" "O" "C" "A" "N" "O" "A" "C" "A" "R")
  ("O" "D" "O" "R" "O" "T" "E" "G" "V" "U" "X" "G" "A" "T" "B")
  ("A" "C" "Y" "L" "O" "G" "N" "L" "T" "F" "O" "R" "L" "A" "V")
  ("C" "O" "R" "U" "I" "I" "G" "E" "L" "L" "N" "G" "C" "C" "X")
  ("S" "R" "N" "A" "K" "M" "N" "I" "F" "O" "N" "Q" "I" "I" "G")
  ("E" "S" "N" "K" "L" "N" "P" "G" "N" "I" "V" "A" "O" "P" "F")
  ("P" "E" "E" "M" "I" "L" "B" "I" "H" "G" "T" "I" "R" "M" "R")
  ("O" "R" "T" "S" "E" "N" "A" "C" "A" "L" "L" "A" "P" "A" "E")
  ("T" "I" "O" "D" "U" "J" "T" "O" "E" "D" "A" "G" "A" "R" "C")
  ("Z" "C" "B" "G" "A" "E" "V" "T" "R" "F" "I" "G" "R" "R" "C")
  ("R" "S" "Y" "D" "R" "N" "I" "L" "X" "I" "X" "P" "O" "A" "E")
  ("F" "L" "Y" "T" "O" "C" "Z" "K" "C" "R" "T" "T" "Y" "Y" "T")
  ("C" "V" "S" "K" "A" "L" "L" "A" "B" "E" "S" "A" "B" "V" "T")
  ("P" "U" "G" "I" "L" "A" "T" "O" "Y" "E" "K" "C" "O" "H" "E")
  ("S" "J" "J" "G" "I" "N" "N" "A" "S" "T" "I" "C" "A" "Q" "O")))

Lista delle parole da cercare:

(setq lista-parole '("ARRAMPICATA" "ATLETICA" "BASEBALL"
                     "CALCIO" "CANOA" "CORSE" "DANZA"
                     "FRECCETTE" "GINNASTICA" "GOLF"
                     "HOCKEY" "JOGGING" "JUDO" "NUOTO"
                     "OLIMPIADI" "PALLACANESTRO"
                     "PESCA" "PUGILATO" "SCI" "STRETCHING"
                     "TENNIS" "TIRO" "ARCO"
                     "TREKKING" "VOLLEY" "YOGA"))

Le parole possono trovarsi in orizzontale o in verticale o in diagonale, inoltre possono essere scritte al contrario.

Funzione per contornare la matrice di caratteri con un carattere speciale che ci serve per delimitare la ricerca:

(define (pad-matrix mtx pad val)
  (local (row col out)
    (setq out '())
    (if (array? mtx) (setq mtx (array-list mtx)))
    (setq row (+ (* 2 pad) (length mtx)))
    (setq col (+ (* 2 pad) (length (mtx 0))))
    ; aggiunge pad righe iniziali ad out
    (for (i 1 pad)
      (push (dup val col true) out -1)
    )
    ; aggiunge le righe centrali ad out
    (dolist (el mtx)
      (setq cur (append (dup val pad true) el (dup val pad true)))
      (push cur out -1)
    )
    ; aggiunge pad righe finali ad out
    (for (i 1 pad)
      (push (dup val col true) out -1)
    )
    out))

Funzione che cerca tutte le parole:

(define (cercaparole matrice parole)
  (local (word matrix word-list row col err out)
    (setq matrix (pad-matrix matrice 1 "#"))
    (dolist (parola parole)
      (find-word parola)
    )
    (list out err)))

Funzione che cerca una parola:

(define (find-word word)
  (setq stop nil)
  (setq row (length matrix))
  (setq col (length (matrix 0)))
  (setq word-list (explode word))
  (for (i 0 (- row 1) 1 stop)
    (for (j 0 (- col 1) 1 stop)
      (cond ((find-nord)      (push (list word i j "N") out -1)  (setq stop true))
            ((find-sud)       (push (list word i j "S") out -1)  (setq stop true))
            ((find-est)       (push (list word i j "E") out -1)  (setq stop true))
            ((find-ovest)     (push (list word i j "O") out -1)  (setq stop true))
            ((find-nordest)   (push (list word i j "NE") out -1) (setq stop true))
            ((find-nordovest) (push (list word i j "NO") out -1) (setq stop true))
            ((find-sudest)    (push (list word i j "SE") out -1) (setq stop true))
            ((find-sudovest)  (push (list word i j "SO") out -1) (setq stop true))
      )
    )
  )
  (if (= stop nil) (push (list word -1) err -1)))

(define (find-nord)
(catch
  (let ((r i) (c j))
    (dolist (ch word-list)
      (cond ((= (matrix r c) "#") (throw nil))
            ((!= ch (matrix r c)) (throw nil))
            (true (-- r))
      )
    )
    true)))
(define (find-sud)
(catch
  (let ((r i) (c j))
    (dolist (ch word-list)
      (cond ((= (matrix r c) "#") (throw nil))
            ((!= ch (matrix r c)) (throw nil))
            (true (++ r))
      )
    )
    true)))
(define (find-est)
(catch
  (let ((r i) (c j))
    (dolist (ch word-list)
      (cond ((= (matrix r c) "#") (throw nil))
            ((!= ch (matrix r c)) (throw nil))
            (true (++ c))
      )
    )
    true)))
(define (find-ovest)
(catch
  (let ((r i) (c j))
    (dolist (ch word-list)
      (cond ((= (matrix r c) "#") (throw nil))
            ((!= ch (matrix r c)) (throw nil))
            (true (-- c))
      )
    )
    true)))
(define (find-nordest)
(catch
  (let ((r i) (c j))
    (dolist (ch word-list)
      (cond ((= (matrix r c) "#") (throw nil))
            ((!= ch (matrix r c)) (throw nil))
            (true (++ c) (-- r))
      )
    )
    true)))
(define (find-nordovest)
(catch
  (let ((r i) (c j))
    (dolist (ch word-list)
      (cond ((= (matrix r c) "#") (throw nil))
            ((!= ch (matrix r c)) (throw nil))
            (true (-- c) (-- r))
      )
    )
    true)))
(define (find-sudest)
(catch
  (let ((r i) (c j))
    (dolist (ch word-list)
      (cond ((= (matrix r c) "#") (throw nil))
            ((!= ch (matrix r c)) (throw nil))
            (true (++ c) (++ r))
      )
    )
    true)))
(define (find-sudovest)
(catch
  (let ((r i) (c j))
    (dolist (ch word-list)
      (cond ((= (matrix r c) "#") (throw nil))
            ((!= ch (matrix r c)) (throw nil))
            (true (-- c) (++ r))
      )
    )
    true)))

Il risultato è una lista con elementi del tipo:

a) ("parola" riga colonna direzione) per le parole trovate
b) ("parola" -1) per le parole non trovate

Proviamo la funzione con l'esempio riportato prima:

(cercaparole matrice lista-parole)
;-> ((("ARRAMPICATA" 11 14 "N") ("ATLETICA" 6 12 "SO")
;->   ("BASEBALL" 13 13 "O") ("CALCIO" 1 13 "S")
;->   ("CANOA" 1 8 "E") ("CORSE" 3 2 "S")
;->   ("DANZA" 9 4 "SE") ("FRECCETTE" 6 15 "S")
;->   ("GINNASTICA" 15 4 "E") ("GOLF" 2 12 "SO")
;->   ("HOCKEY" 14 14 "O") ("JOGGING" 1 4 "SE")
;->   ("JUDO" 9 6 "O") ("NUOTO" 5 3 "NE")
;->   ("OLIMPIADI" 2 3 "SE") ("PALLACANESTRO" 8 13 "O")
;->   ("PESCA" 7 1 "N") ("PUGILATO" 14 1 "E")
;->   ("SCI" 11 2 "N") ("STRETCHING" 13 3 "NE")
;->   ("TENNIS" 3 9 "SO") ("TIRO" 12 11 "NO")
;->   ("ARCO" 5 4 "NO") ("TREKKING" 9 1 "NE")
;->   ("VOLLEY" 6 11 "NO") ("YOGA" 12 14 "NO"))
;->   nil)

Proviamo la funzione con un cercaparole in inglese:

(setq matrice
      '(("R" "E" "S" "O" "C" "C" "C" "I" "N" "S" "T" "U" "H" "H" "N")
        ("F" "M" "F" "E" "H" "O" "A" "I" "R" "F" "M" "S" "D" "O" "T")
        ("R" "I" "O" "M" "C" "C" "U" "R" "L" "Y" "H" "A" "E" "S" "E")
        ("N" "T" "H" "I" "L" "I" "A" "R" "R" "R" "B" "C" "E" "G" "C")
        ("Y" "H" "S" "O" "A" "O" "P" "N" "G" "O" "A" "J" "T" "T" "U")
        ("P" "O" "T" "A" "T" "O" "E" "S" "I" "E" "T" "G" "I" "T" "T")
        ("F" "V" "Y" "O" "C" "A" "R" "O" "R" "P" "T" "P" "O" "R" "T")
        ("G" "P" "F" "R" "U" "E" "I" "R" "D" "M" "S" "T" "E" "S" "E")
        ("E" "T" "T" "C" "A" "U" "L" "I" "F" "L" "O" "W" "E" "R" "L")
        ("I" "S" "O" "E" "E" "M" "L" "T" "U" "A" "I" "O" "L" "T" "S")
        ("O" "I" "T" "A" "E" "G" "E" "T" "B" "A" "N" "E" "T" "S" "E")
        ("E" "T" "O" "O" "T" "O" "N" "S" "D" "I" "N" "D" "A" "E" "A")
        ("T" "N" "A" "L" "P" "G" "G" "E" "O" "N" "R" "L" "A" "H" "D")
        ("E" "T" "N" "E" "T" "U" "N" "N" "E" "R" "A" "H" "R" "F" "O")
        ("A" "E" "C" "E" "O" "S" "P" "F" "H" "D" "O" "N" "O" "M" "R")))

(setq lista-parole '("CAULIFLOWER" "CARROT" "COURGETTE" "BAD"
                     "EGGPLANT" "FENNEL" "GARLIC" "LETTUCE"
                     "PIETRA" "ONION" "POTATOES" "ROSEMARY"
                     "SALAD" "SPICES" "SPINACH"))

(cercaparole matrice lista-parole)
;-> ((("CAULIFLOWER" 9 4 "E") ("CARROT" 1 6 "SE")
;->   ("COURGETTE" 1 5 "SE") ("BAD" 4 11"NE")
;->   ("EGGPLANT" 13 8 "O") ("FENNEL" 15 8 "NE")
;->   ("GARLIC" 6 12 "NO") ("LETTUCE" 9 15 "N")
;->   ("ONION" 10 12 "SO") ("POTATOES" 6 1 "E")
;->   ("ROSEMARY" 14 10 "NO") ("SALAD" 11 14 "SO")
;->   ("SPICES" 6 8 "NO") ("SPINACH" 8 11 "NO"))
;->  (("PIETRA" -1)))


-------------------------
Generare frazioni proprie
-------------------------

Vediamo come generare tutte le frazioni proprie fino ad un certo denominatore.
Le frazioni proprie sono, per definizione, frazioni in cui il numeratore è minore (più piccolo) del denominatore (cioè sono frazioni con valore minore di 1).

Partiamo con la seguente funzione:

(define (genera n)
  (local (out)
    (setq out '())
    (for (a 1 n)
      (for (b (+ a 1) n)
        ;(println a "/" b)
        (push (list (string (div a b)) (string a "/" b)) out -1)
      )
    )
    ; gli ultimi due elementi non sono validi:
    ; n/n non è una frazione propria
    ; n/(n + 1) ha il denominatore maggiore di n
    (chop out 2)))

(genera 5)
;-> (("0.5" "1/2")
;->  ("0.3333333333333333" "1/3")
;->  ("0.25" "1/4")
;->  ("0.2" "1/5")
;->  ("0.6666666666666666" "2/3")
;->  ("0.5" "2/4")
;->  ("0.4" "2/5")
;->  ("0.75" "3/4")
;->  ("0.6" "3/5")
;->  ("0.8" "4/5"))

Ci sono elementi doppi ("0.5" "1/2") e ("0.5" "2/4") e la lista non è ordinata per valore della frazione.

Per eliminare gli elementi doppi inseriamo la lista in una hash-map. Quando assegniamo una lista ad una hash-map gli elementi multipli (con la stessa chiave) vengono presi solo una volta. In newLISP la hash-map inserisce gli elementi partendo dal fondo della lista (poi nella hash-map gli elementi sono ordinati in base alla chiave). Quindi quando incontra elementi multipli prende l'ultimo che compare nella lista (cioè il primo partendo dal fondo della lista). Quindi prima dobbiamo ordinare la lista in modo da mantenere la frazione che è ai minimi termini (cioè vogliamo mantenere la frazione 1/2 e non 2/4).

Generiamo e ordiniamo la lista in ordine decrescente:

(setq lst (sort (genera 5) >))
;-> (("0.8" "4/5")
;->  ("0.75" "3/4")
;->  ("0.6666666666666666" "2/3")
;->  ("0.6" "3/5")
;->  ("0.5" "2/4")
;->  ("0.5" "1/2")
;->  ("0.4" "2/5")
;->  ("0.3333333333333333" "1/3")
;->  ("0.25" "1/4")
;->  ("0.2" "1/5"))

E poi la inseriamo in una hash-map:

(new Tree 'hash)
(hash lst)
;-> hash

(hash)
;-> (("0.2" "1/5")
;->  ("0.25" "1/4")
;->  ("0.3333333333333333" "1/3")
;->  ("0.4" "2/5")
;->  ("0.5" "1/2")
;->  ("0.6" "3/5")
;->  ("0.6666666666666666" "2/3")
;->  ("0.75" "3/4")
;->  ("0.8" "4/5"))

Adesso copiamo la hash-map in una lista:

(setq lst (hash))
;-> (("0.2" "1/5")
;->  ("0.25" "1/4")
;->  ("0.3333333333333333" "1/3")
;->  ("0.4" "2/5")
;->  ("0.5" "1/2")
;->  ("0.6" "3/5")
;->  ("0.6666666666666666" "2/3")
;->  ("0.75" "3/4")
;->  ("0.8" "4/5"))

E cancelliamo la hash-map:

(delete 'hash)
;-> true

Adesso possiamo ricercare una frazione nella lista nel modo seguente:

(find "3/5" lst (fn(x y) (= x (last y))))
;-> 5

(lst 5)
;-> (0.6 "3/5")

Scriviamo la funzione finale:

(define (genera-frazioni-proprie n)
  (local (out)
    (setq out '())
    (for (a 1 n)
      (for (b (+ a 1) n)
        ;(println a "/" b)
        (push (list (string (div a b)) (string a "/" b)) out -1)
      )
    )
    ; gli ultimi due elementi non sono validi:
    ; n/n non è una frazione propria
    ; n/(n + 1) ha il denominatore maggiore di n
    (setq out (sort (chop out 2) >))
    (new Tree 'hash)
    (hash out)
    (setq out (hash))
    (delete 'hash)
    out))

(genera-frazioni-proprie 20)
;-> (("0.1" "1/10")
;->  ("0.1111111111111111" "1/9")
;->  ("0.125" "1/8")
;->  ("0.1428571428571429" "1/7")
;->  ("0.1666666666666667" "1/6")
;->  ("0.2" "1/5")
;->  ("0.2222222222222222" "2/9")
;->  ("0.25" "1/4")
;->  ("0.2857142857142857" "2/7")
;->  ("0.3" "3/10")
;->  ("0.3333333333333333" "1/3")
;->  ("0.375" "3/8")
;->  ("0.4" "2/5")
;->  ("0.4285714285714286" "3/7")
;->  ("0.4444444444444444" "4/9")
;->  ("0.5" "1/2")
;->  ("0.5555555555555556" "5/9")
;->  ("0.5714285714285714" "4/7")
;->  ("0.6" "3/5")
;->  ("0.625" "5/8")
;->  ("0.6666666666666666" "2/3")
;->  ("0.7" "7/10")
;->  ("0.7142857142857143" "5/7")
;->  ("0.75" "3/4")
;->  ("0.7777777777777778" "7/9")
;->  ("0.8" "4/5")
;->  ("0.8333333333333334" "5/6")
;->  ("0.8571428571428571" "6/7")
;->  ("0.875" "7/8")
;->  ("0.8888888888888888" "8/9")
;->  ("0.9" "9/10"))


-----------------
Somma di quadrati
-----------------

Dato un numero intero non negativo c, determinare se esistono due numeri interi a e b tali che a^2 + b^2 = c.

Per la teoria: "On numbers which are the sum of two squares" Leonhard Euler

Conviene cercare a^2 = c - b^2. Con un ciclo per "a" che va da 0 a int(sqrt c) inseriamo il valore a^2 in una hash-map e verifichiamo se nella hash-map esiste il valore b^2 = (c - a^2), in questo caso inseriamo la coppia di valori nella lista delle soluzioni.

(define (sommaquad c)
  (local (a b2 out)
    (setq out '())
    (new Tree 'hash)
    (for (a 0 (int (sqrt c)))
      (hash (string (* a a)) (* a a))
      (setq b2 (- c (* a a)))
      (if (hash (string b2))
          (push (list a (sqrt b2)) out -1)
      )
    )
    (delete 'hash)
    out))

(sommaquad 16)
;-> ((4 0))

(sommaquad 25)
;-> ((4 3) (5 0))

(sommaquad 50)
;-> ((5 5) (7 1))

Vediamo quanti numeri esistono fino a 10000 che hanno più di 5 scomposizioni come somma di quadrati:

(for (i 1 10000)
  (if (> (length (sommaquad i)) 5)
      (println i": " (sommaquad i))))

;-> 5525: ((55 50) (62 41) (70 25) (71 22) (73 14) (74 7))
;-> 9425: ((73 64) (80 55) (88 41) (92 31) (95 20) (97 4))

Scriviamo una funzione cha calcola il numero che ha più scomposizioni fino ad un determinato numero.

(define (sommaquad-max num)
  (local (a b2 tot max-tot out)
    (setq max-tot -1)
    (for (c 1 num)
        (setq tot 0)
        (new Tree 'hash)
        (for (a 0 (int (sqrt c)))
          (hash (string (* a a)) (* a a))
          (setq b2 (- c (* a a)))
          (if (hash (string b2)) (++ tot))
        )
        (delete 'hash)
        (if (> tot max-tot)
            (setq max-tot tot out c)
        )
    )
    (list out max-tot)))

Vediamo nei primi 10000 numeri:

(sommaquad-max 10000)
;-> (5525 6)
(time (sommaquad-max 10000))
;-> 842.939

Vediamo nei primi 100000 numeri:

(sommaquad-max 100000)
;-> (71825 9)
(time (sommaquad-max 100000))
;-> 26785.705
(sommaquad 71825)
;-> ((191 188) (208 169) (215 160) (236 127) (247 104)
;->  (257 76) (260 65) (265 40) (268 1))


-----------------------
Somma di cubi (Taxicab)
-----------------------

Dato un numero intero non negativo c, determinare se esistono due numeri interi a e b tali che a^3 + b^3 = c.
I numeri che si possono esprimere come somma di due cubi in più di un modo diverso vengono chiamati numeri Taxicab.

(define (sommacubi c)
  (local (a b3 out)
    (setq out '())
    (new Tree 'hash)
    (for (a 0 (int (pow c (div 3))))
      (hash (string (* a a a)) (* a a a))
      (setq b3 (- c (* a a a)))
      (if (hash (string b3))
          (push (list a (round (pow b3 (div 3)) -4)) out -1)
      )
    )
    (delete 'hash)
    out))

Proviamo con 1729, il numero di Ramanujan:

(sommacubi 1729)
;-> ((10 9) (12 1))

(+ (* 10 10 10) (* 9 9 9))
;-> 1729
(+ (* 12 12 12) (* 1 1 1))
;-> 1729

Vediamo quanti numeri esistono fino a 10000 che hanno più di una scomposizione come somma di cubi:

(for (i 1 10000)
  (if (> (length (sommacubi i)) 1)
      (println i": " (sommacubi i))))

;-> 1729: ((10 9) (12 1))
;-> 4104: ((15 9) (16 2))

Scriviamo una funzione cha calcola tutti i numeri Taxicab (con le relative scomposizioni) fino ad un determinato numero:

(define (taxicab num)
  (local (a b3 lst out)
    (setq out '())
    (for (c 1 num)
      (setq lst '())
      (new Tree 'hash)
      (for (a 0 (int (pow c (div 3))))
        (hash (string (* a a a)) (* a a a))
        (setq b3 (- c (* a a a)))
        (if (hash (string b3))
            (push (list a (round (pow b3 (div 3)) -4)) lst -1)
        )
      )
      (delete 'hash)
      (if (> (length lst) 1) (push (list c lst) out -1))
    )
    out))

(taxicab 10000)
;-> ((1729 ((10 9) (12 1))) (4104 ((15 9) (16 2))))

Vediamo quanti numeri taxicab ci sono fino a 100000:

(length (taxicab 100000))
;-> 10

Vediamo quali numeri taxicab ci sono fino a 1 milione:

(time (setq tx (taxicab 1000000)))
;-> 96643.946 ; 96 secondi

tx
;-> ((1729 ((10 9) (12 1)))
;->  (4104 ((15 9) (16 2)))
;->  (13832 ((20 18) (24 2)))
;->  (20683 ((24 19) (27 10)))
;->  (32832 ((30 18) (32 4)))
;->  (39312 ((33 15) (34 2)))
;->  (40033 ((33 16) (34 9)))
;->  (46683 ((30 27) (36 3)))
;->  (64232 ((36 26) (39 17)))
;->  (65728 ((33 31) (40 12)))
;->  (110656 ((40 36) (48 4)))
;->  (110808 ((45 27) (48 6)))
;->  (134379 ((43 38) (51 12)))
;->  (149389 ((50 29) (53 8)))
;->  (165464 ((48 38) (54 20)))
;->  (171288 ((54 24) (55 17)))
;->  (195841 ((57 22) (58 9)))
;->  (216027 ((59 22) (60 3)))
;->  (216125 ((50 45) (60 5)))
;->  (262656 ((60 36) (64 8)))
;->  (314496 ((66 30) (68 4)))
;->  (320264 ((66 32) (68 18)))
;->  (327763 ((58 51) (67 30)))
;->  (373464 ((60 54) (72 6)))
;->  (402597 ((61 56) (69 42)))
;->  (439101 ((69 48) (76 5)))
;->  (443889 ((73 38) (76 17)))
;->  (513000 ((75 45) (80 10)))
;->  (513856 ((72 52) (78 34)))
;->  (515375 ((71 54) (80 15)))
;->  (525824 ((66 62) (80 24)))
;->  (558441 ((72 57) (81 30)))
;->  (593047 ((70 63) (84 7)))
;->  (684019 ((75 64) (82 51)))
;->  (704977 ((86 41) (89 2)))
;->  (805688 ((92 30) (93 11)))
;->  (842751 ((84 63) (94 23)))
;->  (885248 ((80 72) (96 8)))
;->  (886464 ((90 54) (96 12)))
;->  (920673 ((96 33) (97 20)))
;->  (955016 ((89 63) (98 24)))
;->  (984067 ((92 59) (98 35)))
;->  (994688 ((92 60) (99 29))))

(length tx)
;-> 43


---------------------------
Somma numeri dispari (pari)
---------------------------

Dati due numeri a e b (con a < b) determinare la somma dei numeri dispari compresi nell'intervallo tra a e b (a e b inclusi, se sono dispari).

Vediamo la soluzione più semplice:

(define (sommadispari1 a b)
  (let (somma 0)
    ; per ogni numero tra a e b
    (for (i a b)
      ; se è dispari lo aggiungiamo ala somma
      (if (odd? i) (++ somma i))
    )
    somma))

(sommadispari1 1 10)
;-> 25
(sommadispari1 11 20)
;-> 75

La seconda soluzione utilizza il fatto che i numeri dispari distano di 2:

numero_dispari(n+1) = numero_dispari(n) + 2

(define (sommadispari2 a b)
  (let (somma 0)
    ; se a è pari, allora il primo
    ; numero dispari vale (a + 1)
    (if (even? a) (++ a))
    ; per ogni numero tra a e b con passo 2
    (for (i a b 2)
      ; aggiungiamo alla somma il numero
      (++ somma i)
    )
    somma))

(sommadispari2 1 10)
;-> 25
(sommadispari2 11 20)
;-> 75

Una versione simile alla precedente che usa le primitive di newLISP:

(define (sommadispari3 a b)
    ; se a è pari, allora il primo
    ; numero dispari vale (a + 1)
    (if (even? a) (++ a))
    ; se b è pari, allora l'ultimo
    ; numero dispari vale (b - 1)
    (if (even? b) (-- b))
    ; somma i valori della sequenza
    (apply + (sequence a b 2))
)

(sommadispari3 1 10)
;-> 25
(sommadispari3 11 20)
;-> 75

L'ultima soluzione utilizza il fatto che i numeri dispari sono in progressione aritmetica. Una progressione aritmetica è una successione di numeri tali che la differenza tra ciascun termine della successione e il suo precedente sia una costante. Tale costante viene detta ragione della progressione. Per esempio, la successione dei numeri dispari 3, 5, 7, 9, 11, ... è una progressione aritmetica di ragione 2.
La somma dei numeri di una progressione aritmetica finita si chiama serie aritmetica. La somma S dei primi n valori di una progressione aritmetica è uguale a:

            (a1 + an)
S(n) = n * -----------
                2
dove a1 è il primo termine della serie e an è l'n-esimo (ultimo) termine della serie.

(define (sommadispari4 a b)
  (let (n 0)
    ; se a è pari, allora il primo
    ; numero dispari vale (a + 1)
    (if (even? a) (++ a))
    ; se b è pari, allora l'ultimo
    ; numero dispari vale (b - 1)
    (if (even? b) (-- b))
    ; calcolo di n: numero dei valori dispari
    (setq n (/ (+ (- b a) 2) 2))
    ; calcoliamo la somma con la formula
    (/ (* n (+ a b)) 2)))

(sommadispari4 1 10)
;-> 25
(sommadispari4 11 20)
;-> 75

Test per verificare la correttezza:

(= (sommadispari1 2000 2345678)
   (sommadispari2 2000 2345678)
   (sommadispari3 2000 2345678)
   (sommadispari4 2000 2345678))
;-> true

Vediamo i tempi di esecuzione:

(time (sommadispari1 1234 123456789))
;-> 5062.233
(time (sommadispari1 1234 123456789) 10)
;-> 51041.947
(time (sommadispari2 1234 123456789))
;-> 2039.792
(time (sommadispari2 1234 123456789) 10)
;-> 20435.561
(time (sommadispari3 1234 123456789))
;-> 1938.445
(time (sommadispari3 1234 123456789) 10)
;-> 12659.818
(time (sommadispari4 1234 123456789))
;-> 0
(time (sommadispari4 1234 123456789) 10)
;-> 0
(time (sommadispari4 1234 123456789) 100000)
;-> 33.091

L'ultima funzione è la più veloce perchè non effettua alcun ciclo attraverso i numeri.

Possiamo anche scrivere una funzione che somma i numeri pari:

(define (sommapari a b)
  (let (n 0)
    ; se a è dispari, allora il primo
    ; numero pari vale (a + 1)
    (if (odd? a) (++ a))
    ; se b è dispari, allora l'ultimo
    ; numero pari vale (b - 1)
    (if (odd? b) (-- b))
    ; calcolo di n: numero dei valori pari
    (setq n (/ (+ (- b a) 2) 2))
    ; calcoliamo la somma con la formula
    (/ (* n (+ a b)) 2)))

(sommapari 3 9)
;-> 18
(sommapari 2 10)
;-> 30

Nota: la somma dei primi n numeri dispari è sempre un quadrato. Infatti la figura seguente mostra che:

1 + 3 =          4   (2 quadrati x 2 quadrati)
1 + 3 + 5 =      9   (3 quadrati x 3 quadrati)
1 + 3 + 5 + 7 = 16   (4 quadrati x 4 quadrati)
...

       +-----+-----+-----+-----+
       |  1  |  3  |  5  |  7  |
       |     |     |     |     |
       +-----+-----+-----+-----+
       |  3  |  3  |  5  |  7  |
       |     |     |     |     |
       +-----+-----+-----+-----+
       |  5  |  5  |  5  |  7  |
       |     |     |     |     |
       +-----+-----+-----+-----+
       |  7  |  7  |  7  |  7  |
       |     |     |     |     |
       +-----+-----+-----+-----+


------------
Cavo sospeso
------------

In molte applicazioni pratiche è necessario determinare il rapporto tra la lunghezza di un cavo appeso a due pali verticali, l'altezza dei pali e la minima distanza tra il cavo e il suolo (ad esempio nella posa di cavi elettrici o telefonici).

Per la teoria completa vedere il seguente articolo:
"The hanging cable problem for practical applications"
di Neil Chatterjee e Bogdan G. Nita

Un cavo perfettamente flessibile e inestensibile di densità e sezione trasversale uniformi appeso liberamente a due pali assume la forma di una catenaria. L'equazione di una catenaria in coordinate cartesiane è la seguente:

  y = a*cosh(x/a)

dove cosh è la funzione del coseno iperbolico.

Il fattore di scala "a" viene solitamente interpretato come il rapporto tra la componente orizzontale della tensione sul cavo e il peso del cavo per unità di lunghezza. Per un dato valore del parametro "a" la forma della catenaria è nota. Tuttavia nei problemi pratici "a" è sconosciuto e dipende dalla distanza tra i poli da cui pende il cavo.

Quando la catenaria è tangente all'asse x (il suolo) dobbiamo sottrarre "a" all'equazione sopra:

  y = a*cosh(x/a) - a

Primo caso: pali di altezza uguale
----------------------------------
Supponiamo che la lunghezza del cavo sia 120 m e i due pali hanno la stessa altezza di 50 m. Assumiamo anche che ogni polo si trovi alla distanza x dal punto medio che si presume sia l'asse y.
Calcolare la distanza tra i pali (2x) affinchè il cavo sia tangente al suolo.

                  asse y
                    |
     |.             |             .|
     | .            |            . |
     |  .           |        60 .  |
     |   .          |          .   | 50
     |     .        |        .     |
     |       .      |      .       |
     |           .  |  .           |
   -----------------|------------------ asse x

                  asse y
                    |
     |.             |             .|
     | .            |            . |
     |  .           |           .  |
     |   .          |        y .   | z
     |     .        |        .     |
     |       .      |      .       |
     |           .  |  .           |
   -----------------|------------------ asse x
                            x
La costante "a" vale:

       y² - z²
  a = ---------
         2z

La distanza 2x vale:

  2x = 2*a*ln(y/a + sqrt((y/a)² + 1))

Sostituendo il valore di "a" otteniamo:

       (y² - z²)ln(2*y*z/(y² - z²) + sqrt(4*y²*z²/(y^4 - 2*y²*z² + z^4) + 1))
 2x = ------------------------------------------------------------------------
                                       z

Secondo caso: pali di altezza diversa
-------------------------------------
Adesso esaminiamo un problema simile, ma con pali di diverse altezze. Supponiamo che la lunghezza del cavo sia 140 m e che i due poli abbiano altezze di 50 m e 70 m (vedi Figura 3). Determinare la distanza minima tra i due poli in modo che il cavo sia tangente al suolo.

     |.
     | .             asse y
     |  .              |
     |   .             |             .|
  70 |    .  y2        |        y1  . |
     |     .           |           .  |
     |      .          |          .   | 50
     |        .        |        .     |
     |          .      |      .       |
     |              .  |  .           |
   --------------------|------------------ asse x
            x2                 x1

     |.
     | .             asse y
     |  .              |
     |   .             |             .|
  z2 |    .  y2        |        y1  . |
     |     .           |           .  |
     |      .          |          .   | z1
     |        .        |        .     |
     |          .      |      .       |
     |              .  |  .           |
   --------------------|------------------ asse x
            x2                 x1

  y1 + y2 = 140

Questa volta "a" vale:

       (z1 + z2)*[y² - (z1 - z2)²] -2*y*sqrt(z1*z2*[y² (z1 - z2)²])
  a = --------------------------------------------------------------
                              2*(z1 - z2)²

  y1 = sqrt(z1² + 2*z1*a)

  y2 = sqrt(z2² + 2*z2*a)

             z1 + y1 + a
  x1 = a*ln(-------------)
                  a

             z2 + y2 + a
  x2 = a*ln(-------------)
                a


------------------
Numeri automorfici
------------------

In matematica si dice numero automorfo o anche intero automorfo un intero positivo che nelle notazioni decimali ha il quadrato che presenta nella sua parte finale il numero stesso.
Esempi: 5^2 = 25, 76^2 = 5776, 890625^2 = 793212890625.

(define (automorfico? num)
(catch
  (let (quadrato (* num num))
    ; confronto delle cifre
    (while (> num 0)
      ; se le cifre di num e le ultime di quadrato non sono uguali
      ; allora num non è automorfico
      (if (!= (% num 10) (% quadrato 10))
          (throw nil))
      (setq num (/ num 10))
      (setq quadrato (/ quadrato 10))
    )
    true)))

(automorfico? 890625)
;-> true

Vediamo i numeri automorfici fino a 100 milioni:

(for (i 0 1e8) (if (automorfico? (bigint i)) (print i { })))
;-> 0 1 5 6 25 76 376 625 9376 90625 109376
;-> 890625 2890625 7109376 12890625 87109376


-----------------
Numeri trimorfici
-----------------

Un numero è chiamato numero trimorfico se e solo se il suo cubo termina con le stesse cifre del numero stesso. In altre parole, è trimorfico se il numero appare alla fine del suo cubo.

Esempi di numeri trimorfici:

5 --> 5*5*5 = 125

24 --> 24*24*24 = 13824

(define (trimorfico? num)
(catch
  (let (cubo (* num num num))
    ; confronto delle cifre
    (while (> num 0)
      ; se le cifre di num e le ultime di cubo non sono uguali
      ; allora num non è trimorfico
      (if (!= (% num 10) (% cubo 10))
          (throw nil))
      (setq num (/ num 10))
      (setq cubo (/ cubo 10))
    )
    true)))

(trimorfico? 534857623847562384756238745623L)
;-> true

(trimorfico? 24)
;-> true

Vediamo i numeri trimorfici fino a 100 milioni:

(for (i 0 1e8) (if (trimorfico? (bigint i)) (print i { })))
;-> 0 1 4 5 6 9 24 25 49 51 75 76 99 125 249 251 375 376 499 501
;-> 624 625 749 751 875 999 1249 3751 4375 4999 5001 5625 6249
;-> 8751 9375 9376 9999 18751 31249 40625 49999 50001 59375
;-> 68751 81249 90624 90625 99999 109375 109376 218751 281249
;-> 390625 499999 500001 609375 718751 781249 890624 890625
;-> 999999 2109375 2890624 2890625 4218751 4999999 5000001 5781249
;-> 7109375 7109376 7890625 9218751 9999999 12890624 12890625
;-> 24218751 25781249 37109375 49999999 50000001 62890625 74218751
;-> 75781249 87109375 87109376 99999999


----------------------
Funzioni come Stringhe
----------------------

Nel paragrafo "Funzioni come liste" abbiamo visto che in newLISP le funzioni sono delle liste particolari che cominciano con la parola-chiave "lambda":

(define (test a b) (+ a b))
;-> (lambda (a b) (+ a b))

Verifichiamo che "test" sia una lista e vediamo come è composta:

(list? test)
;-> true

(length test)
;-> 2

Il primo elemento è la lista degli argomenti della funzione/lista:

(nth 0 test)
;-> (a b)

Il secondo elemento è il corpo della funzione/lista:

(nth 1 test)
(+ a b)

Adesso mostriamo brevemente che una funzione può essere trasformata in una stringa, la quale può essere modificata e poi riconvertita in una funzione.

Per esempio, prendiamo la nostra funzione "test" e applichiamola a due numeri:

(test 5 3)
;-> 8

Adesso assegniamo la funzione "test" ad una stringa:

(setq fs (string test))
;-> "(lambda (a b) (+ a b))"

Troviamo la posizione del segno "+" e sostituiamolo con il segno "-":

(find "+" fs)
;-> 15

(setf (fs 15) "-")
;-> "-"

La stringa "fs" è diventata:

(println fs)
;-> (lambda (a b) (- a b))

Adesso possiamo utilizzare la funzione primitiva "eval-string", che valuta l'espressione contenuta in una stringa, per convertire la stringa "fs" in una nuova funzione:

(setq test2 (eval-string fs))
;-> (lambda (a b) (- a b))

Proviamo la nuova funzione:

(test2 5 3)
;-> 2

Quindi è possibile convertire una funzione in una stringa e viceversa.


---------------------
Assegnazione multipla
---------------------

Qualche volta abbiamo bisogno di assegnare i valori di una lista di ritorno di una funzione a delle variabili. Ad esempio, la seguente funzione restituisce un punto e vogliamo assegnare i valori alle variabili a e b:

(define (midpoint p1 p2)
  (let ((x (div (add (p1 0) (p2 0)) 2))
        (y (div (add (p1 1) (p2 1)) 2)))
    (list x y)))

(midpoint '(2 2) '(3 3))
;-> (2.5 2.5)

Per assegnare i valori di ritorno della funzione alle variabili a e b possiamo scrivere:

(setq lst (midpoint '(2 2) '(3 3)))
(setq a (lst 0))
;-> 2.5
(setq b (lst 1))
;-> 2.5

Oppure possiamo scrivere:

(map set '(c d) (midpoint '(2 2) '(3 3)))
c
;-> 2.5
d
;-> 2.5

Possiamo scrivere una macro che ci semplifica il lavoro (simile alla macro psetq):

(define-macro (msetq)
    ; Assegna ad ogni variabile di (args 0)
    ; la relativa variabile ottenuta dalla
    ; valutazione della funzione in (args 1)
    ; (cioè dei valori della lista ritornata dalla funzione)
    (dolist (_el (eval (args 1)))
      (set (args 0 $idx) (eval _el))))

Questa macro prende due argomenti:
1) <lst-var> la lista delle variabili che devono essere associate
2) <func> la funzione da valutare

Esempio:

(msetq (x y) (midpoint '(2 2) '(3 3)))

Adesso le variabili x e y hanno il valore 2.5 e 2.5:

(list x y)
;-> (2.5 2.5)

Possiamo assegnare qualunque valore di ritorno alle variabili (anche una funzione):

(define (test a b f) (list a (sin b) f))

(msetq (x y z) (test 3 4 'add))
;-> add@40D926

(list x y z)
;-> (3 -0.7568024953079282 add@40D926)

Adesso "z" si comporta come la funzione "add":

(z 1 2)
;-> 3

Vediamo i tempi di esecuzione dei tre metodi:

(define (t)
  (setq lst (midpoint '(2 2) '(3 3)))
  (setq a (lst 0) b (lst 1)))

(time t 1e8)
;-> 312.193

(define (t1)
  (map set '(c d) (midpoint '(2 2) '(3 3))))

(time t1 1e8)
;-> 310.305

(define (t2)
  (msetq (x y) (midpoint '(2 2) '(3 3))))

(time t2 1e8)
;-> 310.174

I tempi di esecuzione sono equivalenti.


-----------------
Doppio fattoriale
-----------------

Il doppio fattoriale o semifattoriale di un numero n, indicato con n‼, è il prodotto di tutti gli interi da 1 a n che hanno la stessa parità (pari o dispari) di n (sequenze A000165 e A001147 nell'OEIS).
Il doppio fattoriale non deve essere confuso con la funzione fattoriale ripetuta due volte (sequenza A000197 nell'OEIS), che è scritta come (n!)! e non n!!.

Il doppio fattoriale di un numero n vale:

n!!(0) = 1

n!! = Prod[k=0..(ceil(n/2) - 1)] (n - 2*k)

Oppure separando il caso pari e dispari:

Numeri pari:

n!! = Prod[k=1..(n/2)] (2*k)

Numeri dispari:

n!! = Prod[k=1..(n+1)/2)] (2*k - 1)

La sequenza dei doppi fattoriali per i numeri pari n = 0, 2, 4, 6, 8, ... inizia come:

1, 2, 8, 48, 384, 3840, 46080, 645120, ... (sequenza A000165 nell'OEIS)

La sequenza dei doppi fattoriali per dispari n = 1, 3, 5, 7, 9, ... inizia come:

1, 3, 15, 105, 945, 10395, 135135, ... (sequenza A001147 nell'OEIS)

(define (double-fact num)
  (let (df 1)
    (cond ((zero? num) (setq df 1))
          ((= 1 num) (setq df 1))
          ((even? num)
           (for (k 1 (/ num 2))
             (setq df (* df 2 k))))
          ((odd? num)
           (for (k 1 (/ (+ num 1) 2))
             (setq df (* df (- (* 2 k) 1)))))
    )
    df))

Numeri pari:
(map double-fact (sequence 0 14 2))
;-> (1 2 8 48 384 3840 46080 645120)

Numeri dispari:
(map double-fact (sequence 1 13 2))
;-> (1 3 15 105 945 10395 135135)


--------------
0.999999999...
--------------

In matematica il numero N = 0.999999999... (che può essere scritto come 0.(9)) vale 1.

Dimostrazione

1 = 1/3 + 2/3 =
  = 0.333333333... + 0.666666666... =
  = 0.999999999...

In newLISP:

(add (div 1 3) (div 2 3))
;-> 1

Un altro metodo di dimostrazione:

Moltiplichiamo N = 0.999999999... per 10 e poi lo sottraiamo al risultato della moltiplicazione:

10 * 0.999999999... = 9.999999999...

10*N = 9.999999999... -
   N = 0.999999999... =
-----------------------
       9

Cioè, 10*N - N = 9 ==> N = 1


-----------------------
Quadrati magici curiosi
-----------------------

Il quadrato magico Apocalittico
-------------------------------
Tutti i numeri del seguente quadrato magico sono primi e la somma delle righe, delle colonne, delle diagonali e delle diagonali spezzate vale 666 (il numero della Bestia). Le diagonali spezzate (di lunghezza 6) sono quelle che si ottengono piegando il quadrato su se stesso lungo le diagonali.

    3  107    5  131  109  311
    7  331  193   11   83   41
  103   53   71   89  151  199
  113   61   97  197  167   31
  367   13  173   59   17   37
   73  101  127  179  139   47

Diagonali spezzate:

(113 + 13 + 127) + (131 83 199) = 666

(5 + 331 + 103) + (31 + 17 + 179) = 666

Scriviamo una funzione per verificare la proprietà della somma lungo le righe, le colonne e le diagonali:

(define (checksum qm n somma)
  (local (ok srow scol)
    (setq ok true)
    ; controllo diagonali
    (setq srow 0 scol 0)
    (for (i 0 (- n 1))
      (setq srow (add srow (qm i i)))
      (setq scol (add scol (qm i (sub n i 1))))
    )
    (if (or (!= srow somma) (!= scol somma))
        (setq ok nil))
    ;controllo righe e colonne
    (for (i 0 (- n 1) 1 ok)
      (setq srow 0 scol 0)
      (for (j 0 (- n 1) 1 ok )
        (setq srow (add srow (qm i j)))
        (setq scol (add scol (qm j i)))
      )
      (if (or (!= srow somma) (!= scol somma))
          (setq ok nil)
      )
    )
    ok))

Verifichiamo:

(setq a '((  3   107     5   131   109   311)
          (  7   331   193    11    83    41)
          (103    53    71    89   151   199)
          (113    61    97   197   167    31)
          (367    13   173    59    17    37)
          ( 73   101   127   179   139    47)))

(checksum a 6 666)
;-> true

Adesso verifichiamo se i numeri del quadrato sono tutti primi:

(define (primi lst)
  (let (out true)
    (dolist (el (flat lst))
      (if (> (length (factor el)) 1)
        (setq out nil)))
    out))

(primi a)
;-> true

Il quadrato magico Specchio
---------------------------
Nel quadrato magico seguente la somma di ogni riga, di ogni colonna e di ogni diagonale vale 242.

  96 64 37 45
  39 43 98 62
  84 76 25 57
  23 59 82 78

(setq s '((96 64 37 45)
          (39 43 98 62)
          (84 76 25 57)
          (23 59 82 78)))

Verifichiamo:

(checksum s 4 242)
;-> true

Invertiamo le cifre di ogni numero del quadrato:

(define (mirror qm)
  (let (out '())
    (dolist (el qm)
      (push (map (fn(x) (int (reverse (string x)))) el) out -1))
    out))

(setq s1 (mirror s))
;-> ((69 46 73 54) (93 34 89 26) (48 67 52 75) (32 95 28 87))

Otteniamo un altro quadrato magico con la stesso valore della somma:

  69 46 73 54
  93 34 89 26
  48 67 52 75
  32 95 28 87

Verifichiamo:

(checksum s1 4 242)
;-> true

Il quadrato magico Kurchan
--------------------------

Un altro incredibile quadrato magico è quello di Kurchan (scoperto da Rodolfo Marcelo Kurchan, di Buenos Aires, Argentina). Si pensa che sia il più piccolo quadrato magico non banale con 16 numeri interi pandigitali distinti con la più piccola somma magica pandigitale (Pandigitale significa che tutte e dieci le cifre sono utilizzato e 0 non è la cifra iniziale). La somma pandigitale è 4.129.607.358:

  1037956284 1026857394 1036847295 1027946385
  1036947285 1027846395 1037856294 1026957384
  1027856394 1036957284 1026947385 1037846295
  1026847395 1037946285 1027956384 1036857294

Vediamo se esiste un modo per ricavarlo.

Calcoliamo tutte le permutazioni (numeri) delle cifre (0 1 2 3 4 5 6 7 8 9):

(define (perm lst)
  (local (i indici out)
    (setq indici (dup 0 (length lst)))
    (setq i 0)
    ; aggiungiamo la lista iniziale alla soluzione
    (setq out (list lst))
    (while (< i (length lst))
      (if (< (indici i) i)
          (begin
            (if (zero? (% i 2))
              (swap (lst 0) (lst i))
              (swap (lst (indici i)) (lst i))
            )
            ;(println lst);
            (push lst out -1)
            (++ (indici i))
            (setq i 0)
          )
          (begin
            (setf (indici i) 0)
            (++ i)
          )
       )
    )
    out))

(silent (setq all (perm '(0 1 2 3 4 5 6 7 8 9))))

Prendiamo solo le permutazioni che passano il seguente filtro:

(define (filtro lst)
  (and (= (lst 0) 1)
       (= (lst 1) 0)
       (or (= (lst 2) 2) (= (lst 2) 3))
       (or (= (lst 3) 6) (= (lst 3) 7))
       (or (= (lst 4) 8) (= (lst 4) 9))
       (or (= (lst 5) 4) (= (lst 5) 5))
       (or (= (lst 6) 6) (= (lst 6) 7))
       (or (= (lst 7) 2) (= (lst 7) 3))
       (or (= (lst 8) 8) (= (lst 8) 9))
       (or (= (lst 9) 4) (= (lst 9) 5))))

(silent (setq nums (filter filtro all)))
(length nums)
;-> 16
(nums 10)
;-> (1 0 2 7 8 4 6 3 9 5)

Convertiamo gli elementi della lista delle permutazioni in una lista di numeri:

(define (lst-int lst)
  (let (num 0)
    (dolist (el lst) (setq num (+ el (* num 10))))))

(silent (setq numeri (map lst-int nums)))
(length numeri)
;-> 16
(nums 10)
;-> (1 0 2 7 8 4 6 3 9 5)
(numeri 10)
;-> 1027846395

In quanti modi possiamo disporre 16 numeri in una matrice 4x4?
Si tratta del numero di permutazioni, quindi vale: 16!

(define (fact-i num)
  (let (out 1L)
    (for (x 1L num)
      (setq out (* out x)))))

(fact-i 16)
;-> 20922789888000L

Non le possiamo calcolare tutte...

Allora ricaviamo il valore della somma del quadrato magico dividendo per 4 la somma di tutti i valori:

(setq kur '(1037956284
            1026857394
            1036847295
            1027946385
            1036947285
            1027846395
            1037856294
            1026957384
            1027856394
            1036957284
            1026947385
            1037846295
            1026847395
            1037946285
            1027956384
            1036857294))

(apply + kur)
;-> 16518429432

(setq somma (/ (apply + kur) 4))
;-> 4129607358 ; somma del quadrato magico

Quindi dobbiamo trovare 4 numeri che sommano al valore di "somma"

Una soluzione base per trovare tutte le combinazioni  di 4 elementi in una lista "lst" che hanno somma uguale a "sum":

(define (findsum4 lst sum)
  (local (len vet out)
    (setq len (length lst))
    (setq vet (array len lst))
    (setq out '())
    (for (i 0 (- len 4))
      (for (j (+ i 1) (- len 3))
        (for (k (+ j 1) (- len 2))
          (for (p (+ k 1) (- len 1))
            (if (= (+ (vet i) (vet j) (vet k) (vet p)) sum)
                (push (list (vet i) (vet j) (vet k) (vet p)) out -1))))))
    out))

(findsum4 '(10 2 3 4 5 9 7 8) 21)
;-> ((10 2 4 5) (2 3 9 7) (2 4 7 8) (3 4 5 9))

(setq quad (findsum4 kur somma))
(length quad)
;-> 52

52 quadruple di numeri da mettere in una matrice 4x4 con tutti i numeri diversi...

(binom 52 4)
;-> 270725L

Adesso possiamo calcolarle...

(define (comb k lst)
  (cond ((zero? k)   '(()))
        ((null? lst) '())
        (true
          (append (map (lambda (k-1) (cons (first lst) k-1))
                       (comb (- k 1) (rest lst)))
                  (comb k (rest lst))))))

(silent (setq matrici (comb 4 quad)))
(length matrici)
;-> 270725

Vediamo un elemento della lista "matrici" :

(matrici 0)
;-> ((1037956284 1026857394 1036847295 1027946385)
;->  (1037956284 1026857394 1036947285 1027846395)
;->  (1037956284 1026857394 1026947385 1037846295)
;->  (1037956284 1026857394 1026847395 1037946285))

Quindi dobbiamo controllare ogni elemento della lista "matrici" per verificare se è un quadrato magico.

(checksum (matrici 10) 4 somma)
;-> nil

La funzione "test" seleziona solo i qudrati magici:

(define (test)
  (local (out)
    (setq out '())
    (dolist (el matrici)
      (if (checksum el 4 somma)
          (begin
            (println el)
            (push el out -1)))
      (if (zero? (% $idx 10000)) (println $idx))
    )
    out))

(setq sol (test))
(length sol)
;-> 258

Vediamo una matrice:

(sol 10)
;-> ((1037956284 1026857394 1036847295 1027946385)
;->  (1026857394 1027846395 1036957284 1037946285)
;->  (1026857394 1037856294 1026947385 1037946285)
;->  (1026847395 1037946285 1027956384 1036857294))

Notiamo che ci sono numeri uguali, quindi il quadrato magico è triviale.

Eliminiamo tutte le matrici (quadrati magici) che hanno numeri uguali:

(define (unici lst)
  (= (unique (flat lst)) (flat lst)))

(setq qmagic (filter unici sol))
(length qmagic)
;-> 7

Vediamo se in questi 7 quadrati magici esiste quello di Kurchan:

(ref (explode kur 4) qmagic)
;-> (0)

Esiste e si trova all'indice 0:

(qmagic 0)
;-> ((1037956284 1026857394 1036847295 1027946385)
;->  (1036947285 1027846395 1037856294 1026957384)
;->  (1027856394 1036957284 1026947385 1037846295)
;->  (1026847395 1037946285 1027956384 1036857294))

Vediamone un altro:

(qmagic 1)
;-> ((1037956284 1026857394 1036947285 1027846395)
;->  (1036847295 1027946385 1037856294 1026957384)
;->  (1027856394 1036957284 1026847395 1037946285)
;->  (1026947385 1037846295 1027956384 1036857294))

Il quinto quadrato magico è la trasposta di quello di Kurchan:

(= (qmagic 0) (transpose (qmagic 4)))
;-> true

Adesso vediamo se esiste un quadrato magico simile con una somma pandigitale minore di quello di Kurchan.

Calcoliamo tutte le permutazioni (numeri) delle cifre (0 1 2 3 4 5 6 7 8 9):

(silent (setq all (perm '(0 1 2 3 4 5 6 7 8 9))))

Questa volta modifichiamo il filtro::

(define (filtro lst)
  (and (= (lst 0) 1)
       (= (lst 1) 0)
       (or (= (lst 2) 2) (= (lst 2) 3))
       (or (= (lst 3) 4) (= (lst 3) 5))
       (or (= (lst 4) 6) (= (lst 4) 7))
       (or (= (lst 5) 2) (= (lst 5) 3))
       (or (= (lst 6) 8) (= (lst 6) 9))
       (or (= (lst 7) 6) (= (lst 7) 7))
       (or (= (lst 8) 8) (= (lst 8) 9))
       (or (= (lst 9) 4) (= (lst 9) 5))))

(silent (setq nums (filter filtro all)))
(length nums)
;-> 16
(nums 10)
;-> (1 0 3 4 7 2 8 6 9 5)

Convertiamo gli elementi della lista delle permutazioni in una lista di numeri:

(silent (setq numeri (map lst-int nums)))
(length numeri)
;-> 16
(nums 10)
;-> (1 0 3 4 7 2 8 6 9 5)
(numeri 10)
;-> 1034728695

Ricaviamo il valore della somma del quadrato magico dividendo per 4 la somma di tutti i valori:

(setq somma (div (apply + numeri) 4))
;-> 4120736958

La somma è pentadigitale...andiamo avanti.

Quindi dobbiamo trovare 4 numeri che sommano al valore di "somma"

(findsum4 '(10 2 3 4 5 9 7 8) 21)
;-> ((10 2 4 5) (2 3 9 7) (2 4 7 8) (3 4 5 9))

(setq quad (findsum4 numeri somma))
(length quad)
;-> 52

52 quadruple di numeri da mettere in una matrice 4x4 con tutti i numeri diversi...

(binom 52 4)
;-> 270725L

Adesso possiamo calcolarle...

(silent (setq matrici (comb 4 quad)))
(length matrici)
;-> 270725

Vediamo un elemento della lista "matrici" :

(matrici 0)
;-> ((1035629784 1025639784 1034728695 1024738695)
;->  (1035629784 1035729684 1024638795 1024738695)
;->  (1035629784 1025739684 1034628795 1024738695)
;->  (1035629784 1025739684 1024638795 1034728695))

Quindi dobbiamo controllare ogni elemento della lista "matrici" per verificare se è un quadrato magico.

(checksum (matrici 10) 4 somma)
;-> nil

La funzione "test" seleziona solo i qudrati magici:

(define (test)
  (local (out)
    (setq out '())
    (dolist (el matrici)
      (if (checksum el 4 somma)
          (begin
            (println el)
            (push el out -1)))
      (if (zero? (% $idx 10000)) (println $idx))
    )
    out))

(setq sol (test))
(length sol)
;-> 1082

Vediamo una matrice:

(sol 10)
;-> ((1035629784 1035729684 1024638795 1024738695)
;->  (1035629784 1025738694 1034628795 1024739685)
;->  (1025639784 1035729684 1024638795 1034728695)
;->  (1025639784 1035728694 1024638795 1034729685))

Notiamo che ci sono numeri uguali, quindi il quadrato magico è triviale.

Eliminiamo tutte le matrici (quadrati magici) che hanno numeri uguali:

(define (unici lst)
  (= (unique (flat lst)) (flat lst)))

(setq qmagic (filter unici sol))
(length qmagic)
;-> 5

(qmagic 0)
;-> ((1035629784 1035728694 1024638795 1024739685)
;->  (1025639784 1025738694 1034628795 1034729685)
;->  (1035729684 1035628794 1024738695 1024639785)
;->  (1025739684 1025638794 1034728695 1034629785))

(checksum (qmagic 0) 4 somma)
;-> true

Verifichiamo che i numeri siano tutti diversi:

(= (unique (flat (qmagic 0))) (flat (qmagic 0)))

Probabilmente qualcuno di questi 5 quadrati magici sono trasposti e/o simmetrici tra loro, ma sicuramente almeno uno (qmagic 0) è un quadrato magico con una somma pandigitale (minore di quella del quadrato magico di Kurchan), tutti i numeri sono pandigitali e diversi tra loro. Quindi abbiamo trovato un quadrato magico con le stesse proprietà di quelle di Kurchan, ma con una somma minore.


--------------
Serie infinite
--------------

La serie di Grandi
------------------

SG = 1 - 1 + 1 - 1 + 1 - 1 + ...

Qual'è il valore della serie SG?

(1 - SG) = 1 - (1 - 1 + 1 - 1 + 1 - 1 + ...)

(1 - SG) = SG

1 = 2*SG  ==>  SG = 1/2

Nota: i metodi algebrici utilizzati non dovrebbero essere applicati a serie non convergenti, tuttavia la somma di Cesaro per questa serie vale 1/2. La somma di Cesaro è un'estensione del concetto classico di serie convergente basata sulle somme parziali.
Data una serie:

Sum[1..INF] a(n)

con somme parziali:

s(n) = a(1) + a(2) + ... + a(n)

la somma di Cesàro è il limite (quando esiste) della media aritmetica delle somme parziali:

        s(1) + s(2) + ... + s(n)
  lim  --------------------------
 n->INF            n

La serie dei numeri naturali alternati
--------------------------------------

SA = 1 - 2 + 3 - 4 + 5 - 6 + ...

Qual'è il valore della serie SA?

2*SA = 1 - 2 + 3 - 4 + 5 - 6 + ...
         + 1 - 2 + 3 - 4 + 5 - ...

2*SA = 1 - 1 + 1 - 1 + 1 - 1 + 1 = SG

2*SA = 1/2  ==>  SA = 1/4

La serie dei numeri naturali
----------------------------

SN = 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + ...

Qual'è il valore della serie SN?

(SN - SA) = 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + ...
         - (1 + 2 - 3 + 4 - 5 + 6 - 7 + 8 + ...)

(SN - SA) = 4 + 8 + 12 + 16 = 4*SN

(SN - 1/4) = 4*SN

-1/4 = 3*SN  ==> SN = -1/12

Nota: i procedimenti non sono matematicamente ortodossi, ma i risultati sono corretti (in un certo senso).


----------------
Il gioco del Pig
----------------

Ad ogni turno, ogni giocatore lancia ripetutamente un dado finché non esce un 1 oppure il giocatore decide di "passare".
Se il giocatore ottiene un 1, il punteggio del turno è nullo e passa la mano al prossimo giocatore.
se il giocatore ottine un altro numero (2..6), il numero viene aggiunto al punteggio del turno e il turno del giocatore continua.
Se un giocatore decide di "passare", il suo punteggio del turno viene aggiunto al suo punteggio totale, e diventa il turno del prossimo giocatore.
Vince il giocatore che arriva o supera 100 (poichè il turno deve terminare per tutti i giocatori, potrebbero esserci più giocatori che superano 100, allora il vincitore è quello con il punteggio più alto).

Scriviamo un programma per giocare contro il computer. La strategia del computer è la seguente:

0) se il punteggio dell'altro giocatore è maggiore o uguale a 100, allora lanciare i dadi per raggiungere tale punteggio.
1) se il punteggio del computer è maggiore o uguale a 71, allora lancia i dadi per provare a raggiungere 100.
2) altrimenti lancia i dadi per raggiungere il valore: 21 + int((Punti-Giocatore - Punti-Computer)/8)

Nota: se ci sono N giocatori possiamo applicare la strategia con una sola differenza: il punteggio da considerare per calcolare il valore da raggiungere ad ogni turno è quello massimo tra tutti gli altri giocatori.

(define (game-pig)
  (local (score1 score2 turn winner endgame)
    (setq winner -1)
    (setq endgame nil)
    (setq score1 0 score2 0)
    (setq turn 1)
    (do-until endgame
      (println "")
      (println "Turno: " turn)
      (println "Punteggio: UMANO    = " score1)
      (println "           COMPUTER = " score2)
      (println "")
      (human)
      (println "")
      (println "Premi Invio per la mossa del computer...")
      (read-line)
      (computer)
      (setq winner (checkwinner score1 score2))
      (cond ((= winner 1) (println "Fine del gioco l'umano vince: " score1 " - " score2))
            ((= winner 2) (println "Fine del gioco il computer vince: " score2 " - " score1))
            ((= winner 3) (println "Fine del gioco in pareggio: " score1 " - " score2))
      )
      (++ turn)
    )
  ))

(define (human)
  (local (t1 val input continua)
    (setq t1 0)
    (setq val 0)
    (setq continua true)
    (println "Mossa all'Umano: ")
    (println "1 (per lanciare i dadi)")
    (println "0 (per passare la mano)")
    (while continua
      (setq input (read-line))
      (cond ((= "1" input)
             (setq val (+ (rand 6) 1))
             (if (= val 1)
                 (setq t1 0 continua nil)
             ;else
                 (setq t1 (+ t1 val)))
            )
            ((= "0" input)
             (setq continua nil))
      )
      (println "Dado = " val)
      (println "Parziale = " t1)
    )
    (setq score1 (+ score1 t1))
    (println "Umano: Parziale = " t1)
    (println "       Totale = " score1)
  )
)

(define (computer)
  (local (t2 val goal continua)
    (cond ((>= score1 100) (setq goal score1))
          ((>= score2 71)  (setq goal (- 100 score2)))
          (true            (setq goal (+ 21 (int (div (- score1 score2) 8)))))
    )
    (println "goal: "goal)
    (setq continua true)
    (setq t2 0)
    (while (and (< t2 goal) continua)
      (setq val (+ (rand 6) 1))
      (if (= val 1)
          (setq t2 0 continua nil)
      ;else
          (setq t2 (+ t2 val))
      )
      (println "Dado = " val)
      (println "Parziale = " t2)
    )
    (setq score2 (+ score2 t2))
    (println "Computer: Parziale = " t2)
    (println "          Totale = " score2)
    ))

(define (checkwinner p1 p2)
  (let (out 0)
    (if (or (>= p1 100) (>= p2 100))
        (begin
          (cond ((> p1 p2) (setq out 1))
                ((> p2 p1) (setq out 2))
                ((= p1 p2) (setq out 3))
          )
          (setq endgame true))
    )
    out))


Proviamo a giocare:

(game-pig)

Turno: 1
Punteggio: UMANO    = 0
           COMPUTER = 0

Mossa all'Umano:
1 (per lanciare i dadi)
0 (per passare la mano)
1
Dado = 1
Parziale = 0
Umano: Parziale = 0
       Totale = 0

Premi Invio per la mossa del computer...

goal: 21
Dado = 4
Parziale = 4
Dado = 2
Parziale = 6
Dado = 5
Parziale = 11
Dado = 4
Parziale = 15
Dado = 3
Parziale = 18
Dado = 3
Parziale = 21
Computer: Parziale = 21
          Totale = 21

Turno: 2
Punteggio: UMANO    = 0
           COMPUTER = 21

Mossa all'Umano:
1 (per lanciare i dadi)
0 (per passare la mano)
...
...
...
Premi Invio per la mossa del computer...

goal: 5
Dado = 5
Parziale = 5
Computer: Parziale = 5
          Totale = 100
Fine del gioco il computer vince: 100 - 92


----------
Mandelbrot
----------

L'insieme di Mandelbrot o frattale di Mandelbrot è uno dei frattali più popolari ed definito come l'insieme dei numeri complessi c per i quali la successione definita da:

  z(0) = 0
  z(n+1) = z(n)^2 + c

è limitata. Nonostante la semplicità della definizione, l'insieme ha una forma complessa il cui contorno è un frattale. Solo con l'avvento del computer è stato possibile visualizzarlo.

Vediamo un modo spartano di visualizzare questo frattale in una pagina html con una funzione che utilizza l'aritmetica dei numeri complessi:

;;; This program requires v.10.2.0 (or later) of newLISP and
;;; will not run on the original FOOP as introduced in 10.0
; open html file
(device (open "mandelbrot.html" "write"))
(print "<!doctype html>\r\n\r\n")
(println [text]
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Mandelbrot Fractal</title>
  <meta name="description" content="Mandelbrot">
  <meta name="author" content="cameyo">
  <link rel="stylesheet" href="css/styles.css?v=1.0">
</head>
[/text])
(println " </CENTER> <br><center><h4>Mandelbrot Fractal</h4></center></html>")
(println "<CENTER>")
(set ' colors '(
  "800000" "800080" "8000FF" "808000" "808080" "8080FF" "80FF00" "80FF80"
  "80FFFF" "FF0000" "FF0080" "FF00FF" "FF8000" "FF8080" "FF80FF" "FFFF00"))
;; adapted from a program written by Michael Michaels and Cormullion
;; this is a FOOP (Functional Object Oriented Programming) application
; (define (Class:Class) (cons (context) (args))) ; predefined since version 10.0
(new Class 'Complex)
(define (Complex:rad)
  (sqrt (add (pow (self 1) ) (pow (self 2))))
)
(define (Complex:add b)
  (Complex (add (self 1) (b 1)) (add (self 2) (b 2)))
)
(define (Complex:mul b)
  (let (a-re (self 1) a-im (self 2) b-re (b 1) b-im (b 2))
    (Complex
      (sub (mul a-re b-re) (mul a-im b-im))
      (add (mul a-re b-im) (mul a-im b-re)) )
))
(define (draw)
  (print "<table bgcolor=#f0f0f0>\n")
  (for (y -1 1.1 0.08)
    (for (x -2 1 0.04)
      (set 'z (Complex x y) 'c 85 'a z )
      (while (and (< (abs (:rad (set 'z (:add (:mul z z) a)))) 2) (> (dec c) 32)) )
      (if (= c 32)
        (print "<td bgcolor=#000000>&nbsp;</td>")
        (print "<td bgcolor=#" (colors (% c  16)) ">&nbsp;</td>"))
    )
    (println "</tr>") )
  (println "</table>")
)
(draw)
(print " </CENTER> <br><center><h4>created with newLISP v." (sys-info -2) "</h4></center></html>")
; close file
(close (device))
;; eof

Adesso possiamo visualizzare la pagina nel browser predefinito:

(exec "mandelbrot.html")

Potete trovare il file "mandelbrot.html" nella cartella "data".


----------------
find per vettori
----------------

Per ricercare un elemento in una lista possiamo usare la funzione "find":

******************
>>> funzione FIND
******************
sintassi: (find exp-key list [func-compare | regex-option])
sintassi: (find str-key str-data [regex-option [int-offset]])

Trova un'espressione in una lista
Se il secondo argomento restituisce è una lista, allora find restituisce la posizione dell'indice (offset) dell'elemento derivato dalla valutazione di exp-key.

Facoltativamente, è possibile specificare un operatore o una funzione definita dall'utente in func-compare. Se exp-key è una stringa, è possibile specificare un'opzione di espressione regolare con il parametro regex-option.

Quando si utilizzano espressioni regolari o funtori di confronto, la variabile di sistema $0 è impostata sull'ultimo elemento trovato.

; find an expression in a list
(find '(1 2) '((1 4) 5 6 (1 2) (8 9)))  → 3

(find "world" '("hello" "world"))       → 1
(find "hi" '("hello" "world"))          → nil

(find "newlisp" '("Perl" "Python" "newLISP") 1)  → 2
; same with string option
(find "newlisp" '("Perl" "Python" "newLISP") "i")  → 2

; use the comparison functor
(find 3 '(8 4 3  7 2 6) >)  → 4
$0 → 2

(find "newlisp" '("Perl" "Python" "newLISP")
                 (fn (x y) (regex x y 1))) → 2
$0 → "newLISP"

(find 5 '((l 3) (k 5) (a 10) (z 22))
         (fn (x y) (= x (last y))))  → 1
$0 → (k 5)

(find '(a ?) '((l 3) (k 5) (a 10) (z 22)) match)  → 2
$0 → (a 10)

(find '(X X) '((a b) (c d) (e e) (f g)) unify)  → 2
$0 → (e e)

; define the comparison functor first for better readability
(define (has-it-as-last x y) (= x (last y)))

(find 22 '((l 3) (k 5) (a 10) (z 22)) has-it-as-last)  → 3
$0 → (z 22)

Nota: in questo caso tralasciamo la spiegazione dell'uso di find con le stringhe (vedi manuale).

Per esempio:

(setq a '(1 3 (2 3) 4 (3 5 (6))))
(find 4 a)
;-> 3
(a 3)
;-> 4

Possiamo trovare solo un elemento completo, cioè non possiamo trovare un elemento annidato (es. 5):
(find 5 a)
;-> nil

Per trovare gli elementi annidati occorre usare la funzione "ref" o "ref-all":

(ref 5 a)
;-> (4 1)
(a 4 1)
;-> 5

Nota: comunque se conosciamo la struttura della lista di ricerca possiamo utilizzare "find" con una funzione lambda, per esempio:

(setq lst '((1 2) (2 3) (4 5)))

Cerchiamo l'elemento il cui ultimo sottoelemento vale 5:

(find 5 lst (fn(x y) (= x ((last y)))))

In questo caso i parametri della funzione lambda sono associati come:
x --> 5
y --> lst

Cerchiamo l'elemento i cui sottoelementi sommano a 5:

(find 5 lst (fn(x y) (= x (+ (first y) (last y)))))
;-> 1

Purtroppo "find" non è applicabile ai vettori, quindi scriviamo una funzione che rimedia (almeno in parte) a questa mancanza:

(define (find-array el arr)
(catch
  (for (i 0 (- (length arr) 1))
    (if (= el (arr i)) (throw i)))))

(define (find-array el arr)
(let ((val nil) (stop nil))
  (for (i 0 (- (length arr) 1) 1 stop)
    (if (= el (arr i)) (setq val el stop true)))
  val))

(find-array 4 a)
;-> 3

(find-array '(2 3) a)
;-> 2

Vediamo un test di velocità tra "find" e "find-array":

(setq t (sequence 1 10000))
(time (find 5000 t) 10000)
;-> 259.333

(setq arr (array 10000 t))
(time (find-array 5000 arr) 10000)
;-> 3093.758

Possiamo usare questa funzione solo con vettori non troppo grandi.

Se invece abbiamo un vettore ordinato di numeri possiamo utilizzare la ricerca binaria per cercare un elemento.

Scriviamo la funzione di ricerca binaria (per vettori ordinati in modo crescente):

(define (bs num arr len)
(catch
  (local (basso alto indice)
    (setq basso 0) ; inizio lista
    (setq alto (- len 1)) ; fine lista
    (while (>= alto basso)
      (setq indice (>> (+ basso alto))) ; valore centrale indice
      (cond ((> (arr indice) num)
             (setq alto (- indice 1))) ; aggiorno l'indice "alto"
            ((< (arr indice) num)
             (setq basso (+ indice 1))) ; aggiorno l'indice "basso"
            (true (throw indice)) ; elemento trovato
      )
    )
    out)))

La funzione finale "find-array-bs":

(define (find-array-bs el arr) (bs el arr (length arr)))

(setq s (array 8 '(1 2 8 11 21 36 42 77)))

(find-array-bs 4 s)
;-> nil

(find-array-bs 42 s)
;-> 6

Vediamo i tempi di esecuzione:

(silent (setq arr (array 10000 (sequence 1 10000))))
(time (find-array-bs 5000 arr) 10000)
;-> 1432.697
(time (find-array-bs 2 arr) 10000)
;-> 1465.604


----------------
Variabili libere
----------------

Quando si scrivono le funzioni può capitare di dimenticarsi di dichiarare una o più variabili locali. In questo caso la variabile utilizzata mantiene il suo valore anche quando la funzione in cui è contenuta è terminata. Queste variabili possono causare errori nell'esecuzione del programma perchè sono "viste" da tutte le funzioni che vengono eseguite. Per semplicità chiamiamo "libere" queste variabili.

La seguente funzioni visualizza tutte le "variabili libere" che hanno un valore diverso da nil (non è possibile, tramite le primitive di newLISP, determinare se una variabile che vale nil sia libera o meno).

(define (free-vars _ctx)
  (local (_vars)
    (if (= _ctx nil) (setq _ctx (context)))
    (setq _vars '())
    (dolist (_el (symbols _ctx))
      (if (and (not (lambda? (eval _el)))
               (not (primitive? (eval _el)))
               (not (protected? _el))
               (not (global? _el))
               (not (= _el '_ctx))
               (not (= _el '_vars))
               (not (= _el '_el))
               (not (= _el '_v)))
          (push _el _vars -1))
    )
    (dolist (_v _vars)
      (if (eval _v)
        (println _v { } (eval _v))))))

Partiamo con una REPL nuova e, dopo aver valutato la funzione "free-vars", scriviamo la seguente funzione:

(define (test a b) (setq c (+ a b)))

In questa funzione la variabile "c" è libera:

(test 5 10)
;-> 15

Verifichiamo con la funzione "free-vars":

(free-vars)
;-> c 15

In questo modo possiamo correggere la dichiarazione delle variabili e ottenere un programma più stabile.

Per includere anche i contesti/hashmap possiamo usare la seguente funzione:

(define (free-vars _ctx)
  (local (_vars _lst-ctx)
    (if (= _ctx nil) (setq _ctx (context)))
    (setq _vars '())
    (setq _lst-ctx '())
    (dolist (_el (symbols _ctx))
      ;(if (= _el myHash) (println _el))
      (if (and (context? (eval _el))
               (not (= _el '_ctx))
               (not (= _el 'MAIN))
               (not (= _el 'Tree))
               (not (= _el 'Class)))
          (push (eval _el) _lst-ctx -1))
      (if (and (not (lambda? (eval _el)))
               (not (primitive? (eval _el)))
               (not (protected? _el))
               (not (global? _el))
               (not (= _el '_ctx))
               (not (= _el '_lst-ctx))
               (not (= _el '_vars))
               (not (= _el '_el))
               (not (= _el '_v)))
          (push _el _vars -1))
    )
    (dolist (_v _vars)
      (if (eval _v)
        (println _v { } (eval _v)))
    )
    (dolist (_v _lst-ctx)
      (if (eval _v)
        (println (eval _v) { } (eval-string (string "(" _v ")")))
      )
    )
    nil))


--------------
Debug spartano
--------------

Molte volte, prima di utilizzare il debugger di newLISP, utilizzo la vecchia scuola dei "println" per controllare i valori delle variabili durante l'esecuzione del programma. Il metodo è abbastanza tedioso soprattutto se dobbiamo controllare diverse variabili e se vogliamo che vengano visualizzate solo al verificarsi di certe condizioni.

La funzione "break" aiuta a semplificare questo problema utilizzando due parametri:
1) sym-lst: la lista dei simboli/variabili da visualizzare
2) cond-str: una espressione (stringa) newLISP che rappresenta una condizione (true o nil)

Quando la condizione "cond-str" viene valutata true, allora vengono stampati i simboli/variabili con i relativi valori contenuti nella lista "sym-lst". A questo punto l'utente può fare quattro scelte:
1) premere il tasto "Invio" per far continuare l'esecuzione della funzione chiamante.
2) inserire e valutare una espressione direttamente nella REPL.
3) disabilitare la funzione "break" inserendo nella REPL: (setq _BREAK nil)
4) premere "Ctrl+C" per interrompere l'esecuzione del programma.

Scriviamo la funzione e poi vediamo come si applica:

Abbiamo bisogno di una variabile globale _BREAK:

(global '_BREAK)
(setq _BREAK true)

(define (break sym-lst cond-str)
        ; se (_BREAK = true) e
        ; se la condizione "cond-str" viene valutata true
  (cond ((and _BREAK (eval-string cond-str))
          ; allora stampiamo tutti i simboli con i relativi valori
          ; contenuti nella lista sym-lst
          (dolist (el sym-lst)
            (print el " = " (eval el) "; ")
          )
          (println "")
          ; Aspetta un comando/espressione:
          ; 1) 'Invio' continua l'esecuzione della funzione chiamante
          ; 2) espressione da valutare
          ; 3) (setq _BREAK nil)
          ; 4) Ctrl+C
          (read-line)
          (while (> (length (current-line)) 0)
            (println (eval-string (current-line)))
            (read-line)
          ))))

Supponiamo di voler fare il debug della seguente funzione:

(define (prova a b)
  (let ((c 0) (d 0) (out '()))
    (for (i 1 20)
      (setq c (+ a c 10))
      (setq d (+ b d 3))
      (push c out -1)
      ;(break '(c d) "(or (> c 20) (> d 100))")
      (break '(out) "(or (> c 20) (> d 100))")
      ;(break '(out) "(> (length out) 5)")
      ;(break '(c d out) "true")
    )
    (+ c d)))

Abbiamo inserito quattro funzioni "break" e i quattro esempi seguenti si riferiscono ad una sola funzione di "break" attiva (ogni volta diversa).

Condizione: (break '(c d) "(or (> c 20) (> d 100))")
(prova 10 20)
;-> c = 40; d = 46;
out
;-> (20 40)
(setq c 20)
;-> 20
c
;-> 20
(+ a b)
;-> 30
"Invio"
;-> c = 60; d = 69;
"Invio"
;-> c = 80; d = 92;
"Invio"
;-> c = 100; d = 115;
...

Condizione: (break '(out) "(or (> c 20) (> d 100))")
(prova 10 20)
;-> out = (20 40);
c
;-> 40
d
;-> 46
"Invio"
;-> out = (20 40 60);
"Invio"
;-> out = (20 40 60 80);
(- c d)
;-> -12
(setq _BREAK nil)
;-> nil
"Invio"
860

Condizione: (break '(out) "(> (length out) 5)")
(setq _BREAK true)
(prova 10 20)
;-> out = (20 40 60 80 100 120);
(println c d)
;-> 120138
;-> 138
"Invio"
;-> out = (20 40 60 80 100 120 140);
"Invio"
;-> out = (20 40 60 80 100 120 140 160);
...

Se vogliamo che le variabili siano stampate sempre, allora basta assegnare "true" al parametro "cond-str":

Condizione: (break '(c d out) "true")
(prova 10 20)
;-> c = 20; d = 23; out = (20);
"Invio"
;-> c = 40; d = 46; out = (20 40);
"Invio"
;-> c = 60; d = 69; out = (20 40 60);
...

Nota: quando inseriamo le espressioni da valutare nella REPL è possibile inserire anche la funzione che è in esecuzione (es. (prova 3 4))


----------------------
Espressioni ABCDEFGHIJ
----------------------

Risolvere le seguenti espressioni in cui ogni lettera rappresenta una particolare cifra da 0 a 9:

  1) ABC + DEF = GHIJ
  2) (AB)^C = DEF + GHIJ
  3) (AB)^C = DEF * GHIJ
  4) (AB)^C = (DE)^F + GHIJ
  5) Trovare il numero ABCDEFGHIJ che ha le seguenti proprietà:
      A è divisibile per 1
      AB è divisibile per 2
      ABC è divisibile per 3
      ABCD è divisibile per 4
      ABCDE è divisibile per 5
      ABCDEF è divisibile per 6
      ABCDEFG è divisibile per 7
      ABCDEFGH è divisibile per 8
      ABCDEFGHI è divisibile per 9
      ABCDEFGHIJ è divisibile per 10

Funzione che calcola le permutazioni:

(define (perm lst)
  (local (i indici out)
    (setq indici (dup 0 (length lst)))
    (setq i 0)
    ; aggiungiamo la lista iniziale alla soluzione
    (setq out (list lst))
    (while (< i (length lst))
      (if (< (indici i) i)
          (begin
            (if (zero? (% i 2))
              (swap (lst 0) (lst i))
              (swap (lst (indici i)) (lst i))
            )
            (push lst out -1)
            (++ (indici i))
            (setq i 0)
          )
          (begin
            (setf (indici i) 0)
            (++ i)
          )
       )
    )
    out))

Creiamo le permutazioni delle 10 cifre:

(silent (setq nums (perm '("0" "1" "2" "3" "4" "5" "6" "7" "8" "9"))))

Equazione 1: ABC + DEF = GHIJ
-----------------------------

(define (solve1)
  (local (op1 op2 op3 out)
    ;(println "Calcolo permutazioni...")
    ;(setq nums (perm '("0" "1" "2" "3" "4" "5" "6" "7" "8" "9")))
    ;(println "Verifica equazione...")
    (dolist (k nums)
      ; costruzione operandi
      (setq op1 (int (join (slice k 0 3)) 0 10))
      (setq op2 (int (join (slice k 3 3)) 0 10))
      (setq op3 (int (join (slice k 6 4)) 0 10))
      (if (= (+ op1 op2) op3)
        (begin
          ;(println k)
          ;(println op1 "+" op2 " = " op3)
          (push (list op1 op2 op3) out -1)
        )
      )
      ;(if (zero? (% $idx 100000)) (println $idx)))
    )
    out))

(time (setq sol1 (solve1)))
;-> 17602.861
(length sol1)
;-> 432

sol1
;-> ((324 765 1089) (724 365 1089) (764 325 1089)
;->  (364 725 1089) (452 637 1089) (652 437 1089)
;->  ...
;->  (349 218 567) (139 428 567) (439 128 567))

Equazione2: (AB)^C = DEF + GHIJ
-------------------------------

(define (solve2)
  (local (op1 op2 op3 op4 out)
    ;(println "Calcolo permutazioni...")
    ;(setq nums (perm '("0" "1" "2" "3" "4" "5" "6" "7" "8" "9")))
    (println "Verifica equazione...")
    (dolist (k nums)
      ; C non può essere "0"
      (cond ((!= (k 2) "0")
             ; costruzione operandi
             (setq op1 (int (join (slice k 0 2)) 0 10))
             (setq op2 (int (k 2)))
             (setq op3 (int (join (slice k 3 3)) 0 10))
             (setq op4 (int (join (slice k 6 4)) 0 10))
             (if (= (pow op1 op2) (+ op3 op4))
               (begin
                 (println k)
                 (println op1 "^" op2 " = " op3 " + " op4)
                 (push (list op1 op2 op3 op4) out -1)
               )
             ))
             ;(if (zero? (% $idx 100000)) (println $idx)))
      )
    )
    out))

(time (setq sol2 (solve2)))
;-> Verifica equazione...
;-> ("0" "7" "4" "8" "6" "2" "1" "5" "3" "9")
;-> 7^4 = 862 + 1539
;-> ("0" "7" "4" "5" "6" "2" "1" "8" "3" "9")
;-> 7^4 = 562 + 1839
;-> ("0" "7" "4" "8" "3" "2" "1" "5" "6" "9")
;-> 7^4 = 832 + 1569
;-> ("0" "7" "4" "5" "3" "2" "1" "8" "6" "9")
;-> 7^4 = 532 + 1869
;-> ("1" "5" "3" "9" "6" "7" "2" "4" "0" "8")
;-> 15^3 = 967 + 2408
;-> ("1" "5" "3" "4" "6" "7" "2" "9" "0" "8")
;-> 15^3 = 467 + 2908
;-> ("1" "5" "3" "9" "0" "7" "2" "4" "6" "8")
;-> 15^3 = 907 + 2468
;-> ("1" "5" "3" "4" "0" "7" "2" "9" "6" "8")
;-> 15^3 = 407 + 2968
;-> ("0" "7" "4" "8" "6" "9" "1" "5" "3" "2")
;-> 7^4 = 869 + 1532
;-> ("0" "7" "4" "5" "6" "9" "1" "8" "3" "2")
;-> 7^4 = 569 + 1832
;-> ("0" "7" "4" "8" "3" "9" "1" "5" "6" "2")
;-> 7^4 = 839 + 1562
;-> ("0" "7" "4" "5" "3" "9" "1" "8" "6" "2")
;-> 7^4 = 539 + 1862
;-> ("1" "5" "3" "9" "0" "8" "2" "4" "6" "7")
;-> 15^3 = 908 + 2467
;-> ("1" "5" "3" "4" "0" "8" "2" "9" "6" "7")
;-> 15^3 = 408 + 2967
;-> ("1" "5" "3" "9" "6" "8" "2" "4" "0" "7")
;-> 15^3 = 968 + 2407
;-> ("1" "5" "3" "4" "6" "8" "2" "9" "0" "7")
;-> 15^3 = 468 + 2907
;-> ((7 4 862 1539) (7 4 562 1839) (7 4 832 1569) (7 4 532 1869)
;->  (15 3 967 2408) (15 3 467 2908) (15 3 907 2468) (15 3 407 2968)
;->  (7 4 869 1532) (7 4 569 1832) (7 4 839 1562) (7 4 539 1862)
;->  (15 3 908 2467) (15 3 408 2967) (15 3 968 2407) (15 3 468 2907))
;-> 18882.909

(length sol2)
;-> 16

Equazione 3: (AB)^C = DEF * GHIJ
--------------------------------

(define (solve3)
  (local (op1 op2 op3 op4 out)
    ;(println "Calcolo permutazioni...")
    ;(setq nums (perm '("0" "1" "2" "3" "4" "5" "6" "7" "8" "9")))
    (println "Verifica equazione...")
    (dolist (k nums)
      ; C non può essere "0"
      (cond ((!= (k 2) "0")
             ; costruzione operandi
             (setq op1 (int (join (slice k 0 2)) 0 10))
             (setq op2 (int (k 2)))
             (setq op3 (int (join (slice k 3 3)) 0 10))
             (setq op4 (int (join (slice k 6 4)) 0 10))
             (if (= (pow op1 op2) (* op3 op4))
               (begin
                 (println k)
                 (println op1 "^" op2 " = " op3 " * " op4)
                 (push (list op1 op2 op3 op4) out -1)
               )
             ))
             ;(if (zero? (% $idx 100000)) (println $idx)))
      )
    )
    out))

(time (setq sol3 (solve3)))
;-> Verifica equazione...
;-> ("8" "4" "3" "5" "7" "6" "1" "0" "2" "9")
;-> 84^3 = 576 * 1029
;-> ("4" "8" "3" "5" "7" "6" "0" "1" "9" "2")
;-> 48^3 = 576 * 192
;-> ("4" "8" "3" "1" "9" "2" "0" "5" "7" "6")
;-> 48^3 = 192 * 576
;-> 18747.064

(length sol3)
;-> 3

Equazione 4: (AB)^C = (DE)^F * GHIJ
-----------------------------------

(define (solve4)
  (local (op1 op2 op3 op4 op5 out)
    ;(println "Calcolo permutazioni...")
    ;(setq nums (perm '("0" "1" "2" "3" "4" "5" "6" "7" "8" "9")))
    (println "Verifica equazione...")
    (dolist (k nums)
      ; C e F non possono essere "0"
      (cond ((and (!= (k 2) "0") (!= (k 5) "0"))
             ; costruzione operandi
             (setq op1 (int (join (slice k 0 2)) 0 10))
             (setq op2 (int (k 2)))
             (setq op3 (int (join (slice k 3 2)) 0 10))
             (setq op4 (int (k 5)))
             (setq op5 (int (join (slice k 6 4)) 0 10))
             (if (= (pow op1 op2) (* (pow op3 op4) op5))
               (begin
                 (println k)
                 (println op1 "^" op2 " = (" op3 "^" op4 " * " op5)
                 (push (list op1 op2 op3 op4 op5) out -1)
               )
             ))
             ;(if (zero? (% $idx 100000)) (println $idx)))
      )
    )
    out))

(time (setq sol4 (solve4)))
;-> Verifica equazione...
;-> ("4" "2" "3" "9" "8" "1" "0" "7" "5" "6")
;-> 42^3 = (98^1 * 756
;-> ((42 3 98 1 756))
;-> 18911.696

(length sol4)
;-> 1

Equazione 5: ABCDEFGHIJ
-----------------------
Si tratta di un puzzle proposto da John Conway.
Trovare il numero ABCDEFGHIJ che ha le seguenti proprietà:

  A è divisibile per 1
  AB è divisibile per 2
  ABC è divisibile per 3
  ABCD è divisibile per 4
  ABCDE è divisibile per 5
  ABCDEF è divisibile per 6
  ABCDEFG è divisibile per 7
  ABCDEFGH è divisibile per 8
  ABCDEFGHI è divisibile per 9
  ABCDEFGHIJ è divisibile per 10

Il problema può essere risolto (non immediatamente) utilizzando le regole della divisibilità dei numeri. Invece qui lo risolveremo con una funzione brute-force:

(define (solve5)
  (local (co2 co3 co4 co5 co6 co7 co8 co9 co10 next)
    ;(println "Calcolo permutazioni...")
    ;(setq nums (perm '("0" "1" "2" "3" "4" "5" "6" "7" "8" "9")))
    ;(println "Verifica condizioni...")
    (dolist (k nums)
      (setq stop nil)
      ; A non può essere "0"
      (cond ((!= (k 0) "0")
             (setq found true)
             (for (i 2 10 1 stop)
                (setq val (int (join (slice k 0 i)) 0 10))
                (if (!= (% val i) 0)
                    (setq stop true found nil)
                )
             )
             (if found (println (int (join k)))))
      )
    )))

(time (println (solve5)))
;-> 3816547290
;-> 16091.888


----------------
Sequenza Juggler
----------------

La sequenza juggler (giocoliere) per un intero positivo a(1) = n è la sequenza di numeri prodotta dall'iterazione:

 a(k+1)= floor(a(k)^(1/2))   per a(k) pari
         floor(a(k)^(3/2))   per a(k) dispari

I termini di questa sequenza prima aumentano fino a un valore massimo e poi iniziano a diminuire. Sorprendentemente, tutti gli interi sembrano raggiungere alla fine 1, una congettura che vale almeno fino a 10^6.

Scriviamo la funzione di base:

(define (juggler num)
  (local (a b sqr out)
    (setq a num)
    ; primo termine della sequenza
    (setq out (list a))
    (while (!= a 1)
      (setq b 0)
      (setq sqr (sqrt a))
            ; precedente termine pari?
      (cond ((even? a)
            ; calcola il prossimo termine
            (setq b (int (floor sqr))))
            ; precedente termine dispari?
            ((odd? a)
             (setq b (int (floor (mul sqr sqr sqr)))))
            ; calcola il prossimo termine
      )
      ; inserisce il valore corrente della sequenza nella lista di output
      (push b out -1)
      ; il valore corrente diventa il valore precedente
      (setq a b)
    )
    out))

(juggler 10)
;-> (10 3 5 11 36 6 2 1)

I valori della sequenza posono raggiungere valori molto alti:

(juggler 37)
;-> (37 225 3375 196069 86818724 9317 899319 852846071
;->  24906114455136 4990602 2233 105519 34276462 5854 76 8 2 1)

Definiamo due sequenze:

A) I numeri di passi p(n) necessari per raggiungere 1 partendo da n (OEIS A007320).

B) Il valore massimo h(n) della sequenza partendo da n (OEIS A094716).

Modifichiamo la nostra funzione per calcolare i valori di queste sequenze. L'output sarà una lista con la seguente struttura:

(num num-step val-max)

(define (giocoliere num)
  (local (a b sqr max-val num-step)
    (setq a num)
    ; all'inizio il numero di passi vale 0
    (setq num-step 0)
    ; all'inizio il valore massimo della sequenza vale num, cioè a
    (setq max-val a)
    (while (!= a 1)
      (setq b 0)
      (setq sqr (sqrt a))
            ; precedente termine pari?
      (cond ((even? a)
            ; calcola il prossimo termine
            (setq b (int (floor sqr))))
            ; precedente termine dispari?
            ((odd? a)
             (setq b (int (floor (mul sqr sqr sqr)))))
            ; calcola il prossimo termine
      )
      ; verifica valore massimo
      (if (> b max-val) (setq max-val b))
      ; aumenta lunghezza di 1
      (++ num-step)
      ; il valore corrente diventa il valore precedente
      (setq a b)
    )
    (list num num-step max-val)))

(giocoliere 10)
;-> (10 8 36)

Adesso creiamo una funzione che calcola questi valori per tutti numeri fino a "limite":

(define (juggler-all limite)
  (let (out '())
    (for (i 1 limite)
      (push (giocoliere i) out -1))
    out))

(juggler-all 10)
;-> ((1 0 1) (2 1 2) (3 6 36) (4 2 4) (5 5 36)
;->  (6 2 6) (7 4 18) (8 2 8) (9 7 140) (10 7 36))

La sequenza del giocoliere che parte da a(0) = 48443 raggiunge un valore massimo in a(60) con 972463 cifre, prima di raggiungere 1 in a(157). Non siamo in grado di calcolarla correttamente perchè non usiamo i big-integer:

(juggler 48443)
;-> (48443 10662193 34815273349 6496130099313866 80598573
;->  723587455374 850639 784545138 28009 4687555 10148913818
;->  100741 31974914 5654 75 649 16533 2125824 1458 38 6 2 1)

(giocoliere 48443)
;-> (48443 22 6496130099313866)

Il risutato è errato.

Comunque in questo caso per poter utilizzare i numeri big-integer dovremmo avere anche la possibilità di definire la precisione dei calcoli in virgola mobile (infatti dobbiamo moltiplicare in virgola mobile la radice quadrata di un numero), altrimenti perderemmo cifre significative durante la conversione a big-integer.


----------------------
Limiti dei big-integer
----------------------

La classe BigInteger consente di creare e manipolare numeri interi di qualsiasi dimensione.

Qualsiasi dimensione? Esiste un limite (fisico o logico)?

Non ci sono limiti teorici. La classe BigInteger alloca la memoria necessaria per tutti i bit di dati che viene richiesto di contenere. Infatti una buona implementazione dei BigInteger utilizza internamente un vettori di interi dinamico per rappresentare i numeri che utilizza.

Tuttavia esistono alcuni limiti pratici dettati dalla memoria a disposizione. E ci sono ulteriori limiti tecnici, anche se è molto improbabile che il nostro programma ne sia influenzato: alcuni metodi presumono che i bit siano indirizzabili da indici interi, quindi le cose inizieranno a rompersi quando indirizziamo bit con indici del valore Integer.MAX_VALUE.

Ad esempio in java i BigInteger hanno la seguente definizione:

BigInteger:
  int bitCount +4 bytes
  int bitLength +4 bytes
  int firstNonzeroIntNum +4 bytes
  int lowestSetBit +4 bytes
  int signum +4 bytes
  int[] mag +?

Un vettore in Java può avere solo 2^32 elementi. Quindi se i bit del BigInteger sono memorizzati in un vettore di interi, allora può memorizzare al massimo 2^32 cifre, cioè un numero massimo pari a (2^32)^Integer.MAX_VALUE.

Nel linguaggio IDL la classe BigInteger memorizza un numero come un vettore di "cifre" intere a 32 bit senza segno con una radice, o base, di 4294967296 (2^32 - 1). La classe memorizza le cifre in ordine little-endian, con la cifra più significativa alla fine del vettore.

Nota: il valore massimo dei BigInteger può essere limitato da altre funzioni del linguaggio. Ad esempio, se esiste una funzione che trasforma il numero in una stringa, allora il valore massimo è limitato dalla lunghezza massima di una stringa che vale (2^31 - 1).


----------------------------------
Valutazione di espressioni infisse
----------------------------------

Per trasformare una espressione infissa in una prefissa bisogna invertire l'operatore con l'operando:
Per trasformare una semplice espressione infissa (es. (2 + 3)) in una espressione prefissa (es. (+ 2 3)) bisogna invertire l'operatore con l'operando:

(2 + 3) --> (+ 2 3)

(define (infix2prefix expr)
  (list (nth 1 expr) (nth 0 expr) (nth 2 expr)))

(infix2prefix '(2 + 3))
;-> (+ 2 3)

Comunque questa funzione non è in grado di tradurre correttamente espressioni annidate, ovvero espressioni in cui si trovano gli operandi essi stessi espressioni infisse. Per gestire correttamente questa situazione anche gli operandi devono essere trasformati in notazione prefissa. Questo viene fatto utilizzando la ricorsione che viene fermata quando l'argomento è un numero (che viene restituito come tale). Quindi la funzione diventa la seguente:

(define (infix-to-prefix expr)
  (cond ((number? expr) expr)
         (true (list (nth 1 expr)
               (infix-to-prefix (nth 0 expr))
               (infix-to-prefix (nth 2 expr))))))

(infix-to-prefix '(3 + 2))
;-> (+ 3 2)

(infix-to-prefix '((5.2 add 3.3) sub (4 div 2)))
;-> (sub (add 5.2 3.3) (div 4 2))

Questo convertitore infisso-prefisso gestisce solo espressioni aritmetiche binarie e richiede che tutte le espressioni siano completamente tra parentesi (questo elimina il calcolo sulla precedenza degli operatori). Comunque consente alle espressioni di essere annidate a una profondità arbitraria e gestisce tutti gli operatori aritmetici binari supportati da newLISP.

A questo punto definiamo una funzione che ci permette di valutare direttamente le espressioni infisse:

(define (infix expr)
  (eval (infix-to-prefix expr)))

(infix '((5 + 3) - (4 / 4)))
;-> 7

(infix '((5.2 add 3.3) sub (4 div 2)))
;-> 6.5

Nota: le espressioni devono essere inserite con le parentesi al posto giusto

(infix '((5.2 add 3.3 add 2)))
;-> ERR: invalid list index in function nth

(infix '((5.2 add 3.3) add 2))
;-> 10.5

A questo punto possiamo creare un mini-interprete che funziona in modo simile alla REPL di newLISP.

Per interagire con l'utente newLISP mette a disposizione la funzione "read-line" che resituisce la stringa inserita dall'utente. Quindi abbiamo bisogno di una funzione "reader" che converte questa stringa in una espressione newLISP.

(define (reader readstr readret)
   (cond
      ((float readstr)
       (if (find "." readstr)
         (setq readret (float readstr))
         (setq readret (integer readstr))))
      ((= (slice readstr 0 1)"(")
          (setq readret (eval-string (append "'" readstr))))
      (true
         (setq readret (sym readstr)))))

(reader "(2 + 3)" expr)
;-> (2 + 3)

(reader "((5.2 add 3.3) add 2)" expr)
;-> ((5.2 add 3.3) add 2)

Adesso scriviamo una semplice funzione che imposta il nostro ciclo REPL:

(define (calc-repl)
  (print "infix: ") ; Stampa il nostro prompt "infix: "
  (print (eval (infix (reader (read-line))))) ; READ-EVAL-PRINT
  (println "") ; Stampa un newline
  (calc-repl)) ; LOOP

Eseguiamo la nostra REPL di calcolo e valutiamo alcune espressioni:

(calc-repl)
;-> infix:
(2 + 3)
;-> 5
;-> infix:
((2.2 div 1.1) mul ((4 + 3) div 3.5))
;-> 4
;-> infix:
((2.2 div 1.1) mul 2.3)
;-> 4.6
;-> infix:

Premere Ctrl+C per uscire dalla REPL.


--------------------
Vincere 2 volte su 3
--------------------

Eva, Vero e Vale sono tre giocatrici di scacchi. Vero è più forte di Eva che, a sua volta, è più forte di Vale.
Un giorno Vale scommette una pizza con Eva se questa riesce a vincere 2 partite consecutive su 3 partite di scacchi contro Vero e Vale. Inoltre Vale permette a Eva di scegliere con chi giocare per prima. In altre parole la sfida (che consiste in tre partite) può avvenire in due modi diversi:

1) (Eva-Vale) (Eva-Vero) (Eva-Vale) oppure
2) (Eva-Vero) (Eva-Vale) (Eva-Vero)

Contro chi dovrebbe giocare Eva per prima per massimizzare le sue probabilità di vincere con entrambe le avversarie?

Per vincere la scommessa Eva deve sicuramente vincere la seconda partita (altrimenti non riuscirà mai a battere tutti e due gli avversari con tre partite, cioè non riesce a vincere due partite consecutive)

Supponiamo che la probabilità di Eva di battere Vero valga p1 con (p1 < 0.5) (cioè Vero è più forte di Eva) e la probabilità di Eva di battere Vale valga p2 (cioè Eva è più forte di Vale).
La probabilità di successo di Eva è data dalla somma delle probabilità di tutti gli eventi favorevoli.
Gli eventi favorevoli sono i tre seguenti:

1) Eva tutte e tre le partite:              --->  (p1) * (p2) * (1 - p1)
2) Eva vince la seconda e la terza partita: --->  (1 - p1) * (p2) * (p1)
3) Eva vince la prima e la seconda partita: ---=> (p1) * (p2) * (p1)

Quindi la probabilità totale di successo vale:

prob = g1 + g2 + g3

Possiamo scrivere una funzione che ci permette di calcolare questa probabilità al variare dei due modi di gioco.

(define (prob p1 p2)
  (local (g1 g2 g3)
    (setq g1 (mul p1 p2 (sub 1 p1)))
    (setq g2 (mul (sub 1 p1) p2 p1))
    (setq g3 (mul p1 p2 p1))
    ;(println g1 { } g2 { } g3 { -> } (add g1 g2 g3))
    (add g1 g2 g3)))

Adesso assegniamo i valori alle probabilità di vittoria per ogni singolo incontro:
poichè Vero è più forte di Eva, allora p1 deve essere minore di 0.5 (es. 0.4)
poichè Eva è più forte di Vale, allora p2 deve essere maggiore di 0.5 (es. 0.6)

Vediamo il risultato quando Eva gioca prima con Vale poi con Vero e infine con Vale:

(prob 0.6 0.4)
;-> 0.336

Vediamo il risultato quando Eva gioca prima con Vero e poi con Vale e infine con Vero:

(prob 0.4 0.6)
;-> 0.384

Cosa??? Questo risultato indica che per Eva la probabilità di vittoria della scommessa è maggiore se gioca due volte contro la giocatrice più forte (Vero). Il risultato è controintuitivo, ma è corretto al 100%.

Proviamo con altri valori di probabilità (0.8 e 0.2):

(prob 0.8 0.2)
;-> 0.192

(prob 0.2 0.8)
;-> 0.288

Proviamo a verificare il risultato matematico con una simulazione:

(define (simula p1 p2 iter)
  (local (g must tot)
    (setq tot 0)
    (for (i 1 iter)
      (setq must nil)
      (setq g 0)
      ; game 1
      (if (> (random) p1) (++ g))
      ; game 2
      (if (> (random) p2) (setq must true g (+ g 1)))
      ; game 3
      (if (> (random) p1) (++ g))
      ; obiettivo raggiunto?
      ; vinto due partite (di cui una è la seconda)?
      (if (and must (> g 1)) (++ tot))
    )
    (div tot iter)))

(simula 0.4 0.6 1e6)
;-> 0.336288
(simula 0.6 0.4 1e6)
;-> 0.383391

(simula 0.8 0.2 1e6)
;-> 0.288874
(simula 0.2 0.8 1e6)
;-> 0.192069

I risultati della simulazione confermano totalmente i risultati matematici.


----------------------
Investimenti in comune
----------------------

Due amici Tom e Jerry comprano insieme 3 villette al prezzo totale di 800.000 euro.
Tom investe 500.000 euro e Jerry 300.000. Dopo poco tempo decidono di tenersi una villetta ciascuno e di vendere la terza per la somma di 800.000 euro. Come devono essere ripartiti questi 800.000 euro tra Tom e Jerry?

La risposta ovvia è: 500.000 euro a Tom e 300.000 a Jerry. Ma è una risposta sbagliata!
Vediamo perchè:

Ogni villetta costa: (800000 / 3) = 266666.6666666667 euro

In totale Tom ha pagato 500000 euro e ha ricevuto una villetta da 266666.6666666667 euro.
Quindi Tom ha investito (500000 - 266666.6666666667) = 233333.3333333333 per la terza villetta.

In totale Jerry ha pagato 300000 euro e ha ricevuto una villetta da 266666.6666666667 euro.
Quindi Jerry ha investito (300000 - 266666.6666666667) = 33333.33333333331 per la terza villetta.

Il rapporto (266666.6666666667 / 33333.33333333331) vale 7, cioè Tom ha investito 7 volte il denaro di Jerry. Quindi la suddivisione degli 800.000 euro ricavati dalla vendita della terza villetta devono essere ripartiti in questo modo:
700.000 euro a Tom e 100.000 euro a Jerry.

Nota: la risposta ovvia (500.000 euro a Tom e 300.000 a Jerry) è sbagliata se tutto l'affare viene considerato come un investimento. Se invece consideriamo la differenza iniziale come un prestito senza interessi di Tom a Jerry, allora la risposta è corretta (infatti alla fine ognuno ha una villetta senza spendere nulla).


-----------------
Dadi intransitivi
-----------------

Un insieme di dadi è intransitivo (o non-transitivo) se contiene tre dadi, A, B e C, con la proprietà che A maggiore di B più della metà delle volte, B maggiore di C più della metà delle volte, C maggiore di A più della metà delle volte. In altre parole, una serie di dadi è intransitiva se la relazione binaria - X tira un numero maggiore di Y più della metà delle volte - sui suoi elementi non è transitiva.

Nota: Usando un tale insieme di dadi, si possono inventare giochi con risultati probabilistici inaspettati.

Esempio:
Consideriamo il seguente insieme di dadi

Il dado A ha i numeri: 2, 2, 4, 4, 9, 9.
Il dado B ha i numeri: 1, 1, 6, 6, 8, 8.
Il dado C ha i numeri: 3, 3, 5, 5, 7, 7.

La probabilità che A ottenga un numero maggiore di B, la probabilità che B ottenga un numero maggiore di C e la probabilità che C ottenga un numero maggiore di A vale 5/9, quindi questo insieme di dadi è intransitivo. In effetti, ha la proprietà ancora più forte che, per ogni dado, c'è un altro dado che tira un numero maggiore di quello più della metà delle volte.

Vediamo come calcolare questa probabilità (5/9):

(setq A '(2 2 4 4 9 9))
(setq B '(1 1 6 6 8 8))
(setq C '(3 3 5 5 7 7))

                numero eventi favorevoli
Probabilità = ----------------------------
                numero eventi possibili

Prodotto cartesiano tra due liste:

(define (prod-cart lst1 lst2)
  (let (out '())
    (if (or (null? lst1) (null? lst2))
        nil
        (dolist (el1 lst1)
          (dolist (el2 lst2)
            (push (list el1 el2) out -1))))))

Lista di tutti gli eventi possibili (ogni elemento della lista rappresenta un lancio e contiene i valori dei dadi A e B):

(setq eventi (prod-cart A B))
;-> ((2 1) (2 1) (2 6) (2 6) (2 8) (2 8) (2 1) (2 1) (2 6) (2 6) (2 8)
;->  (2 8) (4 1) (4 1) (4 6) (4 6) (4 8) (4 8) (4 1) (4 1) (4 6) (4 6)
;->  (4 8) (4 8) (9 1) (9 1) (9 6) (9 6) (9 8) (9 8) (9 1) (9 1) (9 6)
;->  (9 6) (9 8) (9 8))

Adesso calcoliamo gli eventi favorevoli a A, quelli favorevoli a B e quelli in parità:

(setq nA 0)
(setq nB 0)
(setq nAB 0)

(dolist (el eventi)
  (cond ((> (el 0) (el 1)) (++ nA))
        ((< (el 0) (el 1)) (++ nB))
        (true (++ nAB))))

(setq num (length eventi))
;-> 36

(list nA (div nA num) nB (div nB num) nAB (div nAB num))
;-> (20 0.5555555555555556 16 0.4444444444444444 0 0)

(div 5 9)
;-> 0.5555555555555556

Quindi A batte B con probabilità 0.5555... (cioè 5/9).

Scriviamo una funzione che calcola il tutto prendendo come parametri i valori di due dadi:

(define (lancio d1 d2)
  (local (eventi n1 n2 np len)
    (setq n1 0 n2 0 np 0)
    (setq eventi (prod-cart d1 d2))
    (dolist (el eventi)
      (cond ((> (el 0) (el 1)) (++ n1))
            ((< (el 0) (el 1)) (++ n2))
            (true (++ np))))
    (setq len (length eventi))
    (list n1 (div n1 num) n2 (div n2 num) np (div np num))))

Verifichiamo che i tre dadi siano intransitivi:

(lancio A B)
;-> (20 0.5555555555555556 16 0.4444444444444444 0 0)

(lancio B C)
;-> (20 0.5555555555555556 16 0.4444444444444444 0 0)

(lancio C A)
;-> (20 0.5555555555555556 16 0.4444444444444444 0 0)

Un altro insieme di dadi intransitivo è il seguente:

(setq A1 '(2 2 6 6 7 7))
(setq B1 '(1 1 5 5 9 9))
(setq C1 '(3 3 4 4 8 8))

(lancio A1 B1)
;-> (20 0.5555555555555556 16 0.4444444444444444 0 0)

(lancio B1 C1)
;-> (20 0.5555555555555556 16 0.4444444444444444 0 0)

(lancio C1 A1)
;-> (20 0.5555555555555556 16 0.4444444444444444 0 0)

Anche in questo caso la probabilità tra i dadi vale 5/9.

Comunque questi due insiemi non sono equivalenti. Infatti se lanciamo tutti i dadi di un insieme e calcoliamo le probabilità di vincita di ognuno dei dadi otteniamo valori diversi per i due insiemi.

Calcoliamo tutti gli eventi possibili per il lancio di tre dadi:

(setq ev1 (prod-cart A B))
(setq ev2 (prod-cart ev1 C))
(setq eventi (map (fn(x) (list (x 0 0) (x 0 1) (x 1))) ev2))
;-> ((2 1 3) (2 1 3) (2 1 5) (2 1 5) (2 1 7) (2 1 7) (2 1 3)
;->  (2 1 3) (2 1 5) (2 1 5) (2 1 7) (2 1 7) (2 6 3) (2 6 3)
;->  ...
;->  (9 6 7) (9 8 3) (9 8 3) (9 8 5) (9 8 5) (9 8 7) (9 8 7)
;->  (9 8 3) (9 8 3) (9 8 5) (9 8 5) (9 8 7) (9 8 7))

(length eventi)
;-> 216

Calcoliamo le probabilità di vittoria di ognuno dei tre dadi:

(setq evnum (length eventi))
(setq nABC (array 3 '(0)))
(dolist (el eventi)
  (setq valmax (apply max el))
  (++ (nABC (find valmax el))))
(println "A vince " (nABC 0) " volte su " evnum)
(println "B vince " (nABC 1) " volte su " evnum)
(println "C vince " (nABC 2) " volte su " evnum)
;-> A vince 80 volte su 216
;-> B vince 80 volte su 216
;-> C vince 56 volte su 216

Calcoliamo questi valori per il secondo insieme di dadi:

(setq ev1 (prod-cart A1 B1))
(setq ev2 (prod-cart ev1 C1))
(setq eventi (map (fn(x) (list (x 0 0) (x 0 1) (x 1))) ev2))
(setq evnum (length eventi))
(setq nABC (array 3 '(0)))
(dolist (el eventi)
  (setq valmax (apply max el))
  (++ (nABC (find valmax el))))
(println "A1 vince " (nABC 0) " volte su " evnum)
(println "B1 vince " (nABC 1) " volte su " evnum)
(println "C1 vince " (nABC 2) " volte su " evnum)
;-> A1 vince 64 volte su 216
;-> B1 vince 88 volte su 216
;-> C1 vince 64 volte su 216

Quindi i due insiemi di dadi non sono equivalenti.

Dado di Efron
-------------
I dadi di Efron sono un insieme di quattro dadi intransitivi inventati da Bradley Efron.
I quattro dadi A, B, C, D hanno i seguenti numeri sulle sei facce:

A: 4, 4, 4, 4, 0, 0
B: 3, 3, 3, 3, 3, 3
C: 6, 6, 2, 2, 2, 2
D: 5, 5, 5, 1, 1, 1

Ogni dado è battuto dal dado precedente nell'elenco, con una probabilità di 2/3:

P(A>B) = P(B>C) = P(C>D) = P(D>A) = 2/3


---------------------
Il prezzo di un libro
---------------------

Dal libro "The Moscow Puzzles" di Kordemsky.
Il prezzo di un libro è di 10 euro più la metà del suo prezzo di vendita.
Quanto costa il libro?

Questo piccolo puzzle lascia perplesse diverse persone. Alcuni rispondono dicendo che il libro costa 10 euro. Altri che il costo è di 15 euro. La soluzione corretta è che il libro costa 20 euro.
Infatti se poniamo x il costo del libro abbiamo la seguente equazione:

  x = 10 + x/2

da cui si ricava:

  x - x/2 = 10  -->  x/2 = 10  -->  x = 2*10 = 20


-----------------------------
La barca, l'uomo e il mattone
-----------------------------

Un uomo è su una barca a remi che galleggia in un lago.
C'è un mattone nella barca.
Per qualche ragione, l'uomo getta il mattone in acqua.
Il livello dell'acqua del lago rimane lo stesso, sale o scende a causa del fatto che l'uomo ha lanciato il mattone nel lago?

Quando il mattone è nella barca, la quantità di acqua spostata dal mattone è uguale al suo peso.
Quando il mattone viene gettato in mare, la quantità di acqua spostata dal mattone è uguale al suo volume.
Poiché il mattone affonda nell'acqua, sappiamo che il peso specifico del mattone è maggiore di quello dell'acqua. Quindi, il volume d'acqua equivalente alla massa del mattone è maggiore del volume del mattone. Pertanto, quando il mattone viene gettato in acqua, viene spostata meno acqua rispetto a quando il mattone era nella barca (per esempio, supponiamo che il mattone pesa 2 chilogrammi e ha un volume di 1 litro: allora quando il mattone giace all'interno della barca provoca lo spostamento di 2 chilogrammi, cioè di 2 litri di acqua. Invece quando il mattone viene gettato nel lago provoca lo spostamento del proprio volume, cioè di 1 litro d'acqua).
Quindi il livello dell'acqua diminuirà quando il mattone verrà gettato nel lago.


--------------------------------------------
Creare, modificare e restituire una funzione
--------------------------------------------

Crea una semplice funzione all'interno di un'altra funzione e la restituisce:

(define (make-add-one)
  (define (somma x) (+ 1 x))
  somma)

Eseguiamo la funzione:

(make-add-one)
;-> (lambda (x) (+ 1 x))

Adesso possiamo eseguire la funzione creata "somma":
(somma 2)
;-> 3
(somma 5)
;-> 6

Modifichiamo la funzione "somma":

somma
;-> (lambda (x) (+ 1 x))
(last somma)
;-> (+ 1 x)
(nth 1 somma)
;-> (+ 1 x)
(setf (nth 1 somma) '(+ 2 x))
;-> (+ 2 x)
somma
;-> (lambda (x) (+ 2 x))

Adesso la funzione "somma" aggiunge 2 invece di 1:

(somma 3)
;-> 5

Scriviamo una funzione che prende due parametri, il nome della funzione da creare e il parametro della funzione da creare.
Funzione per creare una funzione con nome e parametri:

(define (make-add name val)
  (let (f nil)
    (setq f (string "(define (" name " x) (+ " val " x))"))
    (setq name (eval-string f))
  name))

Creiamo una funzione "somma-10" con parametro 10:

(make-add "somma-10" 10)
(lambda (x) (+ 10 x))

Usiamo la funzione creata "somma-10":

(somma-10 3)
;-> 13

newbert ha proposto il segente metodo alternativo (more lisp-ish):

(define (make-adder x)
  (letex (y x)
    (fn (z) (+ y z))))

Proviamo:

(setq add2 (make-adder 2))
;-> (lambda (z) (+ 2 z))
add2
;-> (lambda (z) (+ 2 z))
(println (add2 4))
;-> 6

Con una macro possiamo anche passare il nome della funzione da creare:

(define-macro (make-adder)
  (local (name val)
    (bind (args) true)
    (set (expand name 'name) (expand (lambda (x) (+ val x)) 'val))))

Proviamo:

(make-adder (name 'add10) (val 10))
;-> (lambda (x) (+ 10 x))
add10
;-> (lambda (x) (+ 10 x))
(println (add10 3))
;-> 13


------------------------
Input utente multi-linea
------------------------

Con la funzione "read-line" possiamo ottenere una stringa di input dall'utente che termina quando premiamo "Invio" (una sola linea di testo). Se vogliamo ottenere una stringa che contiene più linee di testo possiamo usare la seguente funzione che utilizza la primitiva "read-char".

(define (multi-line endchar)
(catch
  (let (out "" ch "")
    (while (setf ch (read-char))
      (if (!= (char ch) endchar)
        (setf out (append out (char ch)))
        (throw out)))
    out)))

Questa funzione prende come parametro un carattere che identifica la fine della stringa e restituisce la stringa inserita (multi-linea):

(multi-line "~")
pippo pluto
topolino minnie
qui quo qua
~
;-> "pippo pluto\r\ntopolino minnie\r\nqui quo qua\r\n"


-----------------------
Distanza dell'orizzonte
-----------------------

La distanza "d" dell'orizzonte da un osservatore (assumendo nessuna rifrazione atmosferica) è data dalla formula:

d = sqrt(2*R*h)

dove:
R = raggio della Terra
h = altezza del punto di osservazione

Assumendo un raggio medio della Terra pari a R = 6.371 chilometri otteniamo:

d(km) ≈ 112.9*sqrt(h(km))

Oppure esprimendo l'altezza h in metri:

d(km) ≈ 3.57*sqrt(h(m))

(define (horizon h)
  (mul 3.57 (sqrt h)))

Vediamo il valore della distanza per una persona (2m), un palazzo di tre piani (10m), una collina (100m), Cingoli (650m) e l'Everest (8850m):

(define (test)
  (println "h(m)  d(km)")
  (dolist (el '(2 10 100 650 8850))
    (println (format "%4d %6.2f" el (horizon el)))))

(test)
;-> h(m)  d(km)
;->    2   5.05
;->   10  11.29
;->  100  35.70
;->  650  91.02
;-> 8850 335.85


-----------
Tic-Tac-Toe
-----------

Tic-Tac-Toe (conosciuto in Italia come "Tris") è un gioco che utilizza una griglia quadrata di 3×3 caselle.
A turno, i giocatori scelgono una casella vuota e vi disegnano il proprio simbolo (di solito un giocatore ha come simbolo il carattere "X" e l'avversario il carttere "O"). Vince il giocatore che riesce a disporre tre dei propri simboli in linea retta orizzontale, verticale o diagonale. Se la griglia viene riempita senza che nessuno dei giocatori sia riuscito a completare una linea retta di tre simboli, il gioco finisce in parità, cioè "patta".

Esempio di partita patta:

  ·---·---·---·
  | O | O | X |
  ·---·---·---·
  | X | X | O |
  ·---·---·---·
  | O | X | X |
  ·---·---·---·

Scriviamo un programma che permette di giocare a Tic-Tac-Toe a due giocatori umani.

Le mosse vengono inserite con un numero da 1 a 9 come nella seguente griglia:

  ·---·---·---·
  | 1 | 2 | 3 |
  ·---·---·---·
  | 4 | 5 | 6 |
  ·---·---·---·
  | 7 | 8 | 9 |
  ·---·---·---·

Funzione che controlla se esiste un vincitore nella griglia passata come parametro (restituisce "X" oppure "O" oppure " "):

(define (check-win b)
  (let (bt (transpose b))
          ; controllo vittoria sulle righe
    (cond ((and (!= " " (b 0 0)) (apply = (b 0))) (b 0 0))
          ((and (!= " " (b 1 0)) (apply = (b 1))) (b 1 0))
          ((and (!= " " (b 2 0)) (apply = (b 2))) (b 2 0))
          ; controllo vittoria sulle colonne
          ((and (!= " " (b 0 0)) (apply = (bt 0))) (b 0 0))
          ((and (!= " " (b 0 1)) (apply = (bt 1))) (b 0 1))
          ((and (!= " " (b 0 2)) (apply = (bt 2))) (b 0 2))
          ;controllo vittoria sulle diagonali
          ((and (!= " " (b 1 1)) (= (b 0 0) (b 1 1) (b 2 2))) (b 1 1))
          ((and (!= " " (b 1 1)) (= (b 0 2) (b 1 1) (b 2 0))) (b 1 1))
          (true " "))))

Funzione che stampa la griglia passata come parametro:

(define (show-board b)
  (println "  ·---·---·---·")
  (println "  | " (b 0 0) " | " (b 0 1) " | " (b 0 2) " |" )
  (println "  ·---·---·---·")
  (println "  | " (b 1 0) " | " (b 1 1) " | " (b 1 2) " |" )
  (println "  ·---·---·---·")
  (println "  | " (b 2 0) " | " (b 2 1) " | " (b 2 2) " |" )
  (println "  ·---·---·---·"))

Funzione che permette di effettuare una mossa da parte di un giocatore:

(define (make-move b p)
  (local (move ok r c grid-move)
    (setq grid-move '((1 (0 0)) (2 (0 1))  (3 (0 2))
                      (4 (1 0)) (5 (1 1))  (6 (1 2))
                      (7 (2 0)) (8 (2 1))  (9 (2 2))))
    (println "Muove: " p)
    (do-while ok
      (setq ok nil)
      (print "Scegliere una casella (1..9): ")
      (setq move (int (read-line)))
      (while (or (< move 1) (> move 9) (not (integer? move)))
          (print "Scegliere una casella (1..9): ")
          (setq move (int (read-line))))
      (setq r (first (lookup move grid-move)))
      (setq c (last (lookup move grid-move)))
      (if (= (b r c) " ")
          (setf (b r c) p)
          (setq ok true))
      (if ok (println "La casella " move " è occupata."))
    )
  b))

Funzione per la gestione completa di una partita di tic-tac-toe:

(define (tic-tac-toe)
  (local (ttt endgame curr-player num-move)
    (setq ttt (array 3 3 '(" ")))
    (setq endgame nil)
    (setq curr-player "X")
    (setq num-move 0)
    (while (not endgame)
      (show-board ttt)
      (setq ttt (make-move ttt curr-player))
      (++ num-move)
      ; controllo vittoria giocatore corrente
      (if (= (check-win ttt) curr-player)
          (begin
            (setq endgame true)
            (show-board ttt)
            (println "Partita terminata:")
            (println "Il giocatore " curr-player " ha vinto."))
          ;else
          ; controllo griglia piena
          (begin
            (if (= num-move 9)
                (begin
                  (setq endgame true)
                  (show-board ttt)
                  (println "Partita terminata: patta")))))
      ; Prossimo giocatore
      (if (not endgame)
          (if (= curr-player "X")
              (setq curr-player "O")
              (setq curr-player "X"))))))

Facciamo una partita:

(tic-tac-toe)
;->   ·---·---·---·
;->   |   |   |   |
;->   ·---·---·---·
;->   |   |   |   |
;->   ·---·---·---·
;->   |   |   |   |
;->   ·---·---·---·
;-> Muove: X
;-> Scegliere una casella (1..9): 5
;->   ·---·---·---·
;->   |   |   |   |
;->   ·---·---·---·
;->   |   | X |   |
;->   ·---·---·---·
;->   |   |   |   |
;->   ·---·---·---·
;-> Muove: O
;-> Scegliere una casella (1..9): 1
;->   ·---·---·---·
;->   | O |   |   |
;->   ·---·---·---·
;->   |   | X |   |
;->   ·---·---·---·
;->   |   |   |   |
;->   ·---·---·---·
;-> Muove: X
;-> Scegliere una casella (1..9): e
;-> Scegliere una casella (1..9): 3
;->   ·---·---·---·
;->   | O |   | X |
;->   ·---·---·---·
;->   |   | X |   |
;->   ·---·---·---·
;->   |   |   |   |
;->   ·---·---·---·
;-> Muove: O
;-> Scegliere una casella (1..9): 7
;->   ·---·---·---·
;->   | O |   | X |
;->   ·---·---·---·
;->   |   | X |   |
;->   ·---·---·---·
;->   | O |   |   |
;->   ·---·---·---·
;-> Muove: X
;-> Scegliere una casella (1..9): 4
;->   ·---·---·---·
;->   | O |   | X |
;->   ·---·---·---·
;->   | X | X |   |
;->   ·---·---·---·
;->   | O |   |   |
;->   ·---·---·---·
;-> Muove: O
;-> Scegliere una casella (1..9): 6
;->   ·---·---·---·
;->   | O |   | X |
;->   ·---·---·---·
;->   | X | X | O |
;->   ·---·---·---·
;->   | O |   |   |
;->   ·---·---·---·
;-> Muove: X
;-> Scegliere una casella (1..9): 9
;->   ·---·---·---·
;->   | O |   | X |
;->   ·---·---·---·
;->   | X | X | O |
;->   ·---·---·---·
;->   | O |   | X |
;->   ·---·---·---·
;-> Muove: O
;-> Scegliere una casella (1..9): 2
;->   ·---·---·---·
;->   | O | O | X |
;->   ·---·---·---·
;->   | X | X | O |
;->   ·---·---·---·
;->   | O |   | X |
;->   ·---·---·---·
;-> Muove: X
;-> Scegliere una casella (1..9): 8
;->   ·---·---·---·
;->   | O | O | X |
;->   ·---·---·---·
;->   | X | X | O |
;->   ·---·---·---·
;->   | O | X | X |
;->   ·---·---·---·
;-> Partita terminata: patta

Vediamo ora un altro programma che permette di giocare contro il computer. Non è imbattibile, ma è abbastanza forte.

#!/usr/bin/newlisp
#
# An unbeatable TicTacToe. A small study to do AI with newLisp.
#
# Board moves are:
#   1 2 3
#   4 5 6
#   7 8 9
#
# The strategy is twofold:
#	1) Determine priority of preferred moves on board
#	2) Think one move ahead to see if X can make 3-in-a-row
#
# Future improvements: think ahead more.
#
# Version 1.0
# - Initial release
# Version 1.1
# - Fixed bug with playing in corners
# - Code optimizations
#
# June 12, 2005 - PvE.
#
# Version 1.2
# - adapted to newLISP 10.7.5
# - better graphics
# - add main function
#
# May 10, 2021 - cameyo
#
#--------------------------------------------------- Interaction with user
#
# Function to print board on console
(define (print_board)
  (println "╔═══╦═══╦═══╗")
  (for (i 1 9)
		(if (or (= (board i) 'X) (= (board i) 'O))
          (print "║ " (board i) " ")
          (print "║   ")
    )
		(if (= (mod i 3) 0) (begin
      (println "║")
      (if (< i 8)
          (println "╠═══╬═══╬═══╣")
          (println "╚═══╩═══╩═══╝")
      )
    ))
  ))
#
# Function to print board on console
;(define (print_board)
;	(for (n 1 9)
;		(if (and (!= (board n) 'X) (!= (board n) 'O))
;			(print (string n) " ")
;			(print (string (board n)) " "))
;		(if (= (mod n 3) 0) (println))))
#
# Function to get input from user
(define (get_input)
	(print "Enter your move (1..9): ")
	(do-until (and (> input 48)(< input 58))(set 'input (read-key)))
	(println (- input 48)))
#
#--------------------------------------------------- End of game queries
#
# Function to find out if there is a winning position for col X/O
(define (has_won col)
	(catch (dolist (n won)
		(if (= (select board n) col) (throw true)))))
#
# Check if game is at end
(define (game_end)
	(if (has_won '(X X X))
		(begin (print_board)(println "---> X has won! <---") true)
		(if (has_won '(O O O))
			(begin (print_board) (println "---> O has won! <---") true)
			(if (= (find 0 board) nil)
				(begin (print_board) (println "---> Equal game! <---") true) nil))))
#
#--------------------------------------------------- Intelligence starts here
#
# Define preferred moves - sequences need improvement using some maths
(define (set_preferred)
	(catch (dolist (n split)
		(if (= (select board n) '(X X))
			(throw (case n
				((2 4) '(1 5 3 7 9 6 8))
				((2 6) '(3 5 1 7 9 4 8))
				((4 8) '(7 5 9 1 3 2 6))
				((6 8) '(9 5 7 1 3 2 4))
				((1 8) '(4 5 3 7 9 2 6))
				((1 6) '(2 5 3 7 9 4 6))
				((7 6) '(8 5 1 9 3 4 2))
				((7 2) '(4 5 1 9 3 8 2))
				((9 2) '(6 5 7 3 1 4 8))
				((9 4) '(8 5 7 3 1 4 6))
				((3 4) '(2 5 9 1 7 6 8))
				((3 8) '(6 5 9 1 7 2 8)))))
		'(5 1 3 7 9 2 4 6 8))))
#
# Function to play move N with color X/O if legal
(define (validate_input n col)
	(if (and (!= (board n) 'X)(!= (board n) 'O))
		(begin (setf (board n) col) true)))
#
# Think one move ahead by evaluating X
(define (eval_x)
	(set 'res nil)
	(for (l 1 9)
		(if (validate_input l 'X)
			(begin
				(if (has_won '(X X X))
					(begin (setq (board l) 0)
          ;(nth-set l board 0)
          (set 'res true)))
				(setq (board l) 0)))) res)
				;(nth-set l board 0)))) res)
#
# Try next move
(define (next_move)
	(catch (dolist (m (set_preferred))
		(if (validate_input m 'O)
			(if (has_won '(O O O))
				(throw)
				(if (eval_x)
					(setf (board m) 0)
					;(nth-set m board 0)
					(throw)))))))
#
#--------------------------------------------------- Main routine
(define (tic-tac-toe)
  # --- General setup
  # Define winning board positions
  (set 'won '((1 2 3)(4 5 6)(7 8 9)(1 4 7)(2 5 8)(3 6 9)(1 5 9)(3 5 7)))
  # Define split actions
  (set 'split '((2 4)(2 6)(4 8)(6 8)(1 8)(1 6)(7 6)(7 2)(9 2)(9 4)(3 4)(3 8)))
  # Setup board for X and O
  (set 'board '(N 0 0 0 0 0 0 0 0 0))
  # --- Main loop
  (while (not (game_end))
    # Print current situation
    (print_board)
    # Get move
    (while (not (validate_input (get_input) 'X)) (println "Try other move!"))
    # Play move
    (next_move)
  )
  'end)
#--------------------------------------------------- Run game
(tic-tac-toe)
;(exit)
;-> ╔═══╦═══╦═══╗
;-> ║ O ║ X ║ X ║
;-> ╠═══╬═══╬═══╣
;-> ║ X ║ O ║ O ║
;-> ╠═══╬═══╬═══╣
;-> ║ O ║ X ║ X ║
;-> ╚═══╩═══╩═══╝


----------------
Labirinti (Maze)
----------------

Un labirinto è un percorso o un insieme di percorsi, in genere con uno o più ingressi e con nessuna o più uscite.
Per risolvere un labirinto (maze) utilizzeremo due algoritmi.

Algoritmo Casuale del Topo
--------------------------
Questo primo algoritmo è un metodo banale che simula il comportamento di un topo (non intelligente). Si tratta semplicemente di procedere attraverso il labirinto in modo casuale cercando (prima o poi) di raggiungere l'uscita. Sebbene un tale metodo alla fine trova sempre la soluzione giusta, questo algoritmo può essere estremamente lento.

(define (solve-maze-A maze start-row start-col end-row end-col limite show)
  (local (matrix x y row col wall trovato solution-path e-row e-col num-passi out)
    ; lista soluzione percorso
    (setq out '())
    ; matrice labirinto
    (setq matrix maze)
    ; carattere che rappresenta il muro "0"
    (setq wall 0)
    ; righe della matrice
    (setq row (length matrix))
    ; colonne della matrice
    (setq col (length (first matrix)))
    ; matrice soluzione del labirinto
    (setq solution-path (array row col '(nil)))
    ; posizione iniziale: riga
    (setq x start-row)
    ; posizione iniziale: colonna
    (setq y start-col)
    ; posizione finale: riga
    (setq e-row end-row)
    ; posizione finale: colonna
    (setq e-col end-col)
    ; numero passi iniziale
    (setq num-passi 0)
    ; Ricerca random della soluzione
    (setq trovato nil)
    (while (and (not trovato) (< num-passi limite))
      (++ num-passi)
      (setf (solution-path x y) true)
      ;controllo se abbiamo raggiunto la fine e non è un muro
      (cond ((and (= x e-row) (= y e-col) (!= (matrix x y) wall))
             (setf (solution-path x y) true)
             (setq trovato true))
      )
      ; Movimento random
      (setq move (amb 1 2 3 4))
      (cond ((= move 1)
             (if (and (!= x 0) (!= (matrix (- x 1) y) wall)) (setq x (- x 1) y y)))
            ((= move 2)
             (if (and (!= x (- row 1)) (!= (matrix (+ x 1) y) wall)) (setq x (+ x 1) y y)))
            ((= move 3)
             (if (and (!= y 0) (!= (matrix x (- y 1)) wall)) (setq x x y (- y 1))))
            ((= move 4)
             (if (and (!= y (- col 1)) (!= (matrix x (+ y 1)) wall)) (setq x x y (+ y 1))))
      )
    )
    (cond ((< num-passi limite)
           ; Se show = true --> stampa la soluzione
           (if show (begin
               (show-aux solution-path)
               (println "Passi: " num-passi)))
           ; crea la lista con il percorso risolutivo
           (for (i 0 (- row 1))
             (for (j 0 (- col 1))
               (if (solution-path i j)
                   (push (list i j) out -1)))))
          (true
           (setq out nil)
           (println "Limite raggiunto."))
    )
    out))

(define (show-aux path)
  (local (row col)
    ; righe della matrice
    (setq row (length path))
    ; colonne della matrice
    (setq col (length (first path)))
    ; stampa
    (for (i 0 (- row 1))
      (for (j 0 (- col 1))
        ;(if (matrix i j) (print " ·") (print " 0"))
        ;(if (path i j) (print " ·") (print " " (matrix i j)))
        (if (path i j) (print " ■") (print " " (matrix i j)))
      )
      (println))))

Esempio 1:
; definizione labirinto (1 = libero, 0 = muro)
(setq righe 5)
(setq colonne 4)
(setq matrice (array righe colonne '(
  1 1 1 0
  0 0 1 1
  1 0 0 1
  0 0 0 1
  1 1 1 1)))

(solve-maze-A matrice 0 0 4 3 1000 true)
;->  ■ ■ ■ 0
;->  0 0 ■ ■
;->  1 0 0 ■
;->  0 0 0 ■
;->  1 1 1 ■
Passi: 16
;-> ((0 0) (0 1) (0 2) (1 2) (1 3) (2 3) (3 3) (4 3))
(solve-maze-A matrice 0 0 4 3 1000)
;-> ((0 0) (0 1) (0 2) (1 2) (1 3) (2 3) (3 3) (4 3))

Esempio 2:
; definizione labirinto
(setq righe 12)
(setq colonne 20)
(setq matrice (array righe colonne '(
 1 1 0 1 0 1 1 1 0 1 0 1 0 1 0 0 1 1 1 0
 0 1 1 1 0 0 1 1 1 1 1 0 0 1 1 1 1 1 0 0
 0 1 0 0 0 0 0 1 1 0 0 0 1 0 0 0 0 1 0 1
 0 1 1 1 1 1 0 0 0 1 1 1 1 0 0 0 1 0 1 0
 1 0 0 0 0 1 0 0 1 0 1 0 1 0 0 1 1 0 0 0
 1 0 0 0 0 1 1 1 1 0 1 0 1 0 0 1 1 0 0 0
 1 0 0 0 0 0 0 0 1 0 1 0 1 0 0 1 0 1 0 0
 1 0 0 0 0 0 0 0 1 1 1 0 1 0 0 1 1 1 0 0
 1 0 0 0 0 0 0 0 1 0 0 0 1 1 1 1 0 1 1 1
 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0 1 0 0 0 1
 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0 1 0 0 0 1
 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0 1 0 0 0 1)))

(solve-maze matrice 0 0 11 19 10000 true)
;-> ■ ■ 0 ■ 0 1 1 1 0 1 0 1 0 1 0 0 1 1 1 0
;-> 0 ■ ■ ■ 0 0 1 1 1 1 1 0 0 1 1 1 1 1 0 0
;-> 0 ■ 0 0 0 0 0 1 1 0 0 0 1 0 0 0 0 1 0 1
;-> 0 ■ ■ ■ ■ ■ 0 0 0 ■ ■ ■ ■ 0 0 0 ■ 0 1 0
;-> 1 0 0 0 0 ■ 0 0 ■ 0 ■ 0 ■ 0 0 ■ ■ 0 0 0
;-> 1 0 0 0 0 ■ ■ ■ ■ 0 ■ 0 ■ 0 0 ■ ■ 0 0 0
;-> 1 0 0 0 0 0 0 0 ■ 0 ■ 0 ■ 0 0 ■ 0 ■ 0 0
;-> 1 0 0 0 0 0 0 0 ■ ■ ■ 0 ■ 0 0 ■ ■ ■ 0 0
;-> 1 0 0 0 0 0 0 0 ■ 0 0 0 ■ ■ ■ ■ 0 ■ ■ ■
;-> 1 0 0 0 0 0 0 0 ■ 0 0 0 ■ 0 0 ■ 0 0 0 ■
;-> 1 0 0 0 0 0 0 0 ■ 0 0 0 ■ 0 0 ■ 0 0 0 ■
;-> 1 0 0 0 0 0 0 0 ■ 0 0 0 1 0 0 ■ 0 0 0 ■
;-> Passi: 3277
;-> ((0 0) (0 1) (0 3) (1 1) (1 2) (1 3) (2 1) (3 1) (3 2) (3 3) (3 4)
;->  (3 5) (3 9) (3 10) (3 11) (3 12) (3 16) (4 5) (4 8) (4 10) (4 12)
;->  (4 15) (4 16) (5 5) (5 6) (5 7) (5 8) (5 10) (5 12) (5 15) (5 16)
;->  (6 8) (6 10) (6 12) (6 15) (6 17) (7 8) (7 9) (7 10) (7 12) (7 15)
;->  (7 16) (7 17) (8 8) (8 12) (8 13) (8 14) (8 15) (8 17) (8 18)
;->  (8 19) (9 8) (9 12) (9 15) (9 19) (10 8) (10 12) (10 15) (10 19)
;->  (11 8) (11 15) (11 19))

Esempio 3:
; definizione labirinto
(setq righe 9)
(setq colonne 9)
(setq matrice (array righe colonne '(
 1 1 0 1 0 1 1 1 0
 0 1 1 1 0 0 1 1 1
 0 1 0 0 0 0 0 1 1
 0 1 1 1 1 1 0 0 0
 1 0 0 0 0 1 0 0 1
 1 0 0 0 0 1 0 1 1
 1 0 0 0 0 0 0 0 1
 1 0 0 0 0 0 0 0 1
 1 0 0 0 0 0 0 0 1)))

La seguente chiamata non ha soluzione:

(solve-maze-A matrice 0 0 8 8 100000 true)
;-> Limite raggiunto
;-> nil

(solve-maze-A matrice 0 0 5 5 10000 true)
;-> ■ ■ 0 ■ 0 1 1 1 0
;-> 0 ■ ■ ■ 0 0 1 1 1
;-> 0 ■ 0 0 0 0 0 1 1
;-> 0 ■ ■ ■ ■ ■ 0 0 0
;-> 1 0 0 0 0 ■ 0 0 1
;-> 1 0 0 0 0 ■ 0 1 1
;-> 1 0 0 0 0 0 0 0 1
;-> 1 0 0 0 0 0 0 0 1
;-> 1 0 0 0 0 0 0 0 1
;-> Passi: 331
;-> ((0 0) (0 1) (0 3) (1 1) (1 2) (1 3) (2 1) (3 1) (3 2)
;->  (3 3) (3 4) (3 5) (4 5) (5 5))

Esempio 4:
; definizione labirinto
(setq righe 9)
(setq colonne 9)
(setq matrice (array righe colonne '(
 1 1 0 1 0 1 1 0 1
 0 1 1 1 0 0 1 1 1
 0 1 0 0 0 0 0 1 0
 0 1 1 1 1 1 0 1 1
 1 0 0 0 0 1 0 0 1
 1 0 0 0 0 1 1 1 1
 1 1 1 1 1 0 1 0 1
 1 0 0 0 1 0 1 0 1
 1 0 0 0 1 1 1 0 1)))

(solve-maze-A matrice 8 0 0 8 10000 true)
;-> 1 1 0 1 0 1 1 0 ■
;-> 0 1 1 1 0 0 1 ■ ■
;-> 0 1 0 0 0 0 0 ■ 0
;-> 0 1 1 1 1 1 0 ■ ■
;-> ■ 0 0 0 0 ■ 0 0 ■
;-> ■ 0 0 0 0 ■ ■ ■ ■
;-> ■ ■ ■ ■ ■ 0 ■ 0 ■
;-> ■ 0 0 0 ■ 0 ■ 0 1
;-> ■ 0 0 0 ■ ■ ■ 0 1
;-> Passi: 1650
;-> ((0 8) (1 7) (1 8) (2 7) (3 7) (3 8) (4 0) (4 5) (4 8) (5 0) (5 5)
;->  (5 6) (5 7) (5 8) (6 0) (6 1) (6 2) (6 3) (6 4) (6 6) (6 8) (7 0)
;->  (7 4) (7 6) (8 0) (8 4) (8 5) (8 6))

Algoritmo ricorsivo
--------------------
Il secondo algoritmo trova la soluzione (se esiste) in modo ricorsivo. Si parte da un valore iniziale X e Y. Se i valori X e Y non sono su un muro, il metodo (funzione) richiama se stesso con tutti i valori X e Y adiacenti, assicurandosi di non aver utilizzato in precedenza quei valori X e Y. Se i valori X e Y sono quelli della posizione finale, salva tutte le istanze precedenti del metodo (risultati parziali) creando una matrice con il percorso risolutivo.
Questo algoritmo non garantisce che la soluzione trovata sia quella più breve.
Nota: In sostanza si tratta di una ricerca depth-first espressa in termini di celle della matrice.

(define (solve-maze maze start-row start-col end-row end-col show)
  (local (matrix row col wall visited solution-path s-row s-col e-row e-col out)
    ; lista soluzione percorso
    (setq out '())
    ; matrice labirinto
    (setq matrix maze)
    ; carattere che rappresenta il muro "0"
    (setq wall 0)
    ; righe della matrice
    (setq row (length matrix))
    ; colonne della matrice
    (setq col (length (first matrix)))
    ; matrice delle celle visitate
    (setq visited (array row col '(nil)))
    ; matrice soluzione del labirinto
    (setq solution-path (array row col '(nil)))
    ; posizione iniziale: riga
    (setq s-row start-row)
    ; posizione iniziale: colonna
    (setq s-col start-col)
    ; posizione finale: riga
    (setq e-row end-row)
    ; posizione finale: colonna
    (setq e-col end-col)
    ;
    ; funzione recursive solve
    ;
    (define (recursive-solve x y)
      (catch
        (local (return)
          ;controllo se abbiamo raggiunto la fine e non è un muro
          (if (and (= x e-row) (= y e-col) (!= (matrix x y) wall))
              (throw (setf (solution-path x y) true))
          )
          ; cella muro o cella visitata
          (if (or (= (matrix x y) wall) (= (visited x y) true)) (throw nil))
          ; imposta cella come visitata
          (setf (visited x y) true)
          ; controllo posizione riga 0
          (if (!= x 0)
              ; richiama la funzione una riga in basso
              (if (recursive-solve (- x 1) y)
                  (throw (setf (solution-path x y) true))
              )
          )
          ; controllo posizione riga (row - 1)
          (if (!= x (- row 1))
              ; richiama la funzione una riga in alto
              (if (recursive-solve (+ x 1) y)
                  (throw (setf (solution-path x y) true))
              )
          )
          ; controllo posizione colonna 0
          (if (!= y 0)
              ; richiama la funzione una colonna a sinistra
              (if (recursive-solve x (- y 1))
                  (throw (setf (solution-path x y) true))
              )
          )
          ; controllo posizione colonna (col - 1)
          (if (!= y (- col 1))
              ; richiama la funzione una colonna a destra
              (if (recursive-solve x (+ y 1))
                  (throw (setf (solution-path x y) true))
              )
          )
          return))
    ); recursive-solve
    ;
    ; Chiama la funzione ricorsiva di soluzione
    ; Se (recursive-solve s-row s-col) ritorna nil,
    ; allora il labirinto non ha soluzione.
    ; Altrimenti la matrice booleana "solution-path"
    ; contiene la soluzione (valori true).
    (if (recursive-solve s-row s-col)
        (begin
          ; Se show = true --> stampa la soluzione
          (if show (show-aux solution-path))
          ; crea la lista con il percorso risolutivo
          (for (i 0 (- row 1))
            (for (j 0 (- col 1))
              (if (solution-path i j)
                  (push (list i j) out -1)))))
    )
    out))

(define (show-aux path)
  (local (row col)
    ; righe della matrice
    (setq row (length path))
    ; colonne della matrice
    (setq col (length (first path)))
    ; stampa
    (for (i 0 (- row 1))
      (for (j 0 (- col 1))
        ;(if (matrix i j) (print " ·") (print " 0"))
        ;(if (path i j) (print " ·") (print " " (matrix i j)))
        (if (path i j) (print " ■") (print " " (matrix i j)))
      )
      (println))))

Esempio 1:
; definizione labirinto (1 = libero, 0 = muro)
(setq righe 5)
(setq colonne 4)
(setq matrice (array righe colonne '(
  1 1 1 0
  0 0 1 1
  1 0 0 1
  0 0 0 1
  1 1 1 1)))

(solve-maze matrice 0 0 4 3 true)
;->  ■ ■ ■ 0
;->  0 0 ■ ■
;->  1 0 0 ■
;->  0 0 0 ■
;->  1 1 1 ■
;-> ((0 0) (0 1) (0 2) (1 2) (1 3) (2 3) (3 3) (4 3))
(solve-maze matrice 0 0 4 3)
;-> ((0 0) (0 1) (0 2) (1 2) (1 3) (2 3) (3 3) (4 3))

Esempio 2:
; definizione labirinto
(setq righe 12)
(setq colonne 20)
(setq matrice (array righe colonne '(
 1 1 0 1 0 1 1 1 0 1 0 1 0 1 0 0 1 1 1 0
 0 1 1 1 0 0 1 1 1 1 1 0 0 1 1 1 1 1 0 0
 0 1 0 0 0 0 0 1 1 0 0 0 1 0 0 0 0 1 0 1
 0 1 1 1 1 1 0 0 0 1 1 1 1 0 0 0 1 0 1 0
 1 0 0 0 0 1 0 0 1 0 1 0 1 0 0 1 1 0 0 0
 1 0 0 0 0 1 1 1 1 0 1 0 1 0 0 1 1 0 0 0
 1 0 0 0 0 0 0 0 1 0 1 0 1 0 0 1 0 1 0 0
 1 0 0 0 0 0 0 0 1 1 1 0 1 0 0 1 1 1 0 0
 1 0 0 0 0 0 0 0 1 0 0 0 1 1 1 1 0 1 1 1
 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0 1 0 0 0 1
 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0 1 0 0 0 1
 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0 1 0 0 0 1)))

(solve-maze matrice 0 0 11 19 true)
;-> ■ ■ 0 1 0 1 1 1 0 1 0 1 0 1 0 0 1 1 1 0
;-> 0 ■ 1 1 0 0 1 1 1 1 1 0 0 1 1 1 1 1 0 0
;-> 0 ■ 0 0 0 0 0 1 1 0 0 0 1 0 0 0 0 1 0 1
;-> 0 ■ ■ ■ ■ ■ 0 0 0 1 ■ ■ ■ 0 0 0 1 0 1 0
;-> 1 0 0 0 0 ■ 0 0 1 0 ■ 0 ■ 0 0 1 1 0 0 0
;-> 1 0 0 0 0 ■ ■ ■ ■ 0 ■ 0 ■ 0 0 1 1 0 0 0
;-> 1 0 0 0 0 0 0 0 ■ 0 ■ 0 ■ 0 0 1 0 1 0 0
;-> 1 0 0 0 0 0 0 0 ■ ■ ■ 0 ■ 0 0 ■ ■ ■ 0 0
;-> 1 0 0 0 0 0 0 0 1 0 0 0 ■ ■ ■ ■ 0 ■ ■ ■
;-> 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0 1 0 0 0 ■
;-> 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0 1 0 0 0 ■
;-> 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0 1 0 0 0 ■
;-> ((0 0) (0 1) (1 1) (2 1) (3 1) (3 2) (3 3) (3 4) (3 5) (3 10) (3 11)
;->  (3 12) (4 5) (4 10) (4 12) (5 5) (5 6) (5 7) (5 8) (5 10) (5 12)
;->  (6 8) (6 10) (6 12) (7 8) (7 9) (7 10) (7 12) (7 15) (7 16) (7 17)
;->  (8 12) (8 13) (8 14) (8 15) (8 17) (8 18) (8 19) (9 19) (10 19)
;->  (11 19))

Esempio 3:
; definizione labirinto
(setq righe 9)
(setq colonne 9)
(setq matrice (array righe colonne '(
 1 1 0 1 0 1 1 1 0
 0 1 1 1 0 0 1 1 1
 0 1 0 0 0 0 0 1 1
 0 1 1 1 1 1 0 0 0
 1 0 0 0 0 1 0 0 1
 1 0 0 0 0 1 0 1 1
 1 0 0 0 0 0 0 0 1
 1 0 0 0 0 0 0 0 1
 1 0 0 0 0 0 0 0 1)))

(solve-maze matrice 0 0 8 8 true)
;-> ()
Nessuna soluzione.

(solve-maze matrice 0 0 5 5 true)
;-> ■ ■ 0 1 0 1 1 1 0
;-> 0 ■ 1 1 0 0 1 1 1
;-> 0 ■ 0 0 0 0 0 1 1
;-> 0 ■ ■ ■ ■ ■ 0 0 0
;-> 1 0 0 0 0 ■ 0 0 1
;-> 1 0 0 0 0 ■ 0 1 1
;-> 1 0 0 0 0 0 0 0 1
;-> 1 0 0 0 0 0 0 0 1
;-> 1 0 0 0 0 0 0 0 1
;-> ((0 0) (0 1) (1 1) (2 1) (3 1) (3 2) (3 3) (3 4) (3 5) (4 5) (5 5))

Esempio 4:
; definizione labirinto
(setq righe 9)
(setq colonne 9)
(setq matrice (array righe colonne '(
 1 1 0 1 0 1 1 0 1
 0 1 1 1 0 0 1 1 1
 0 1 0 0 0 0 0 1 0
 0 1 1 1 1 1 0 1 1
 1 0 0 0 0 1 0 0 1
 1 0 0 0 0 1 1 1 1
 1 1 1 1 1 0 1 0 1
 1 0 0 0 1 0 1 0 1
 1 0 0 0 1 1 1 0 1)))

(solve-maze matrice 8 0 0 8 true)
;-> 1 1 0 1 0 1 1 0 ■
;-> 0 1 1 1 0 0 1 ■ ■
;-> 0 1 0 0 0 0 0 ■ 0
;-> 0 1 1 1 1 1 0 ■ ■
;-> 1 0 0 0 0 1 0 0 ■
;-> 1 0 0 0 0 1 ■ ■ ■
;-> ■ ■ ■ ■ ■ 0 ■ 0 1
;-> ■ 0 0 0 ■ 0 ■ 0 1
;-> ■ 0 0 0 ■ ■ ■ 0 1
;-> ((0 8) (1 7) (1 8) (2 7) (3 7) (3 8) (4 8) (5 6) (5 7) (5 8) (6 0) (6 1)
;->  (6 2) (6 3) (6 4) (6 6) (7 0) (7 4) (7 6) (8 0) (8 4) (8 5) (8 6))


------------------
Progettare TinyURL
------------------

Problema:
Come progettare un servizio di semplificazione/accorciamento degli URL simile a TinyURL?

Nota: TinyURL è un servizio web di semplificazione URL in cui inserisci un URL come https://projecteuler.net/ e restituisce un URL breve come https://tinyurl.com/4j66fhmw.

L'identificatore (4j66fhmw) può essere qualsiasi stringa con 6 caratteri alfanumerici contenente 0-9, a-z, A-Z. Ogni URL abbreviato deve essere univoco (ovvero, non è possibile abbreviare due URL diversi con lo stesso URL). Di seguito sono riportate solo alcune domande per iniziare. Nel mondo reale, potrebbero esserci molti problemi e domande possibili.

Domande:
Quanti identificatori univoci possibili?
Potremmo rimanere senza URL univoci?
L'identificatore dovrebbe essere incrementato o no?
Quale è più facile da progettare? Pro e contro?
Mappatura di un identificatore a un URL e sua inversione: questo problema ti suona un campanello?
Come memorizzi gli URL? Un semplice database flat-file è sufficiente?
Qual è il collo di bottiglia del sistema? È oneroso in lettura o in scrittura?
Stimare il numero massimo di URL che una singola macchina può memorizzare.
Stimare il numero massimo di query al secondo (QPS) per la decodifica di un URL abbreviato in una singola macchina.
Come ridimensioneresti il ​​servizio? Ad esempio, un collegamento "virale" condiviso nei social media potrebbe comportare un picco di QPS in qualche momento.
Come potresti gestire la ridondanza? (Per esempio, se un server non funziona, come puoi assicurarti che il servizio rimanga ancora operativo?)
Conservare gli URL per sempre o eliminarli, pro e contro? Come si fa la potatura?
Quale API fornireste a uno sviluppatore di terze parti?
Se puoi abilitare la memorizzazione nella cache, cosa memorizzerai nella cache e qual è il tempo di scadenza?

Implementazione:
Scrivere i metodi di codifica e decodifica per il servizio TinyURL. Non ci sono restrizioni su come dovrebbe funzionare l'algoritmo di codifica/decodifica. Bisogna solo assicurarsi che un URL possa essere codificato in un tiny URL e che il tiny URL possa essere decodificato nell'URL originale.

Definiamo due hash-map:

; Long2Short
(new Tree 'LS)
; Short2Long
(new Tree 'SL)

Funzione di codifica della url in tiny-url:

(define (tiny-encode url)
  (local (continua out)
          ; se url esiste nella hash-map,
          ; allora restituisco il valore memorizzato
    (cond ((LS (string url))
           (setq out (LS (string url))))
          ; se url non esiste nella hash map
          ; allora genera una tiny-url valida
          (true
           (setq out "")
           (setq continua true)
           (while continua
             (setq out (make-random))
             ; se la stringa casuale non esiste nella hash-map,
             ; allora inserisco i valori nelle hash-map e
             ; termina il ciclo (continua = nil)
             ; altrimenti continua il ciclo
             ; per generare una nuova stringa casuale
             (if (nil? (SL out)) (begin
                 (SL out url)
                 (LS url out)
                 (setq continua nil)))
           )
          )
    )
    out))

Funzione che crea una stringa casuale di 6 caratteri:

(define (make-random)
  (local (str base)
    (setq base "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")
    (seed (time-of-day))
    (setq str "https://myURL.com/")
    (for (i 0 5)
      (extend str (base (rand 62)))
    )
    str))

(tiny-encode "www.google.com")
"https://myURL.com/UJFmVp"
(tiny-encode "www.pippo.com")
"https://myURL.com/cwpfzB"

Funzione di decodifica da tiny-url a url:

(define (tiny-decode tiny-url)
  (if (SL tiny-url)
      (SL tiny-url)
      nil))

(tiny-decode "https://myURL.com/UJFmVp")
;-> "www.google.com"

(tiny-decode "https://myURL.com/cwpfzB")
;-> "www.pippo.com"

(tiny-decode "https://myURL.com/123abc")
;-> nil


---------------------
Costante di Ramanujan
---------------------

e^(π*√163) = 262537412640768743.999999999999250072597198185688879353856337336990862707537410
(setq R 262537412640768743.999999999999250072597198185688879353856337336990862707537410)

(constant (global 'E)   2.7182818284590451)
(constant (global 'PI)  3.1415926535897931)
(setq rama (pow E (mul PI (sqrt 163))))
;-> 2.625374126407677e+017
(println (format "%36.18f" rama))
;-> 262537412640767710.000000000000000000

(sub R rama)
;-> 1024

(setq eulero (exp 1))
(setq pigreco (mul 2.0 (acos 0.0)))
(setq rama1 (pow eulero (mul pigreco (sqrt 163))))
;-> 2.625374126407677e+017
(println (format "%36.18f" rama1))
;-> 262537412640767710.000000000000000000

(sub R rama1)
;-> 1024

(= rama rama1)
;-> true

Avremmo bisogno di una libreria floating-point a multipla precisione...


-------------------------
Giustificazione del testo
-------------------------

Data una lista di parole e una lunghezza L, formattare il testo in modo che ogni riga contenga esattamente L caratteri e sia completamente giustificata (a sinistra e a destra). Le parole dovrebbero essere inserite con un approccio "avido" (greedy), cioè bisogna inseire quante più parole è possibile in ogni riga. Aggiungere spazi aggiuntivi, quando necessario, in modo che ogni riga abbia esattamente L caratteri.

Gli spazi aggiuntivi tra le parole dovrebbero essere distribuiti nel modo più uniforme possibile. Se il numero di spazi su una riga non si divide equamente tra le parole, agli slot vuoti a sinistra verranno assegnati più spazi rispetto agli slot a destra. L'ultima riga di testo e le righe con una sola parola, devono essere giustificate a sinistra e non bisogna inserire spazi aggiuntivi tra le parole.

L'algoritmo di soluzione è spiegato nei commenti della funzione.

(define (giustifica-testo parole L)
  (local (linee indice conta succ riga diff spazi resto continua)
    ; Output: linee di testo giustificate
    (setq linee '())
    ; Indice della parola corrente
    (setq indice 0)
    ; Ciclo per ogni parola
    (while (< indice (length parole))
      ; Numero di lettere della parola corrente (lunghezza)
      (setq conta (length (parole indice)))
      ; Indice della parola successiva
      (setq succ (+ indice 1))
      ; Ciclo per trovare le parole che entrano in una riga, cioè
      ; la somma della loro lunghezza è minore di L
      ; Valore boolean per terminare la ricerca
      (setq continua true)
      (while (and (< succ (length parole)) continua)
        ; Se superiamo la lunghezza massima di caratteri in una riga...
        (cond ((> (+ (length (parole succ)) conta 1) L)
               ; allora ci fermiamo
               (setq continua nil))
               (true
                ; altrimenti aumentiamo la quantità di caratteri
                ; e passiamo alla parola successiva
                (setq conta (+ conta (length (parole succ)) 1))
                (++ succ))
        )
      )
      ; Ora abbiamo le parole per ogni riga, quindi
      ; dobbiamo aggiungere gli spazi tra le parole.
      ; Ci sono due situazioni da considerare:
      ; 1) Se siamo sull'ultima riga, la riga non deve essere giustificata
      ;    e nessuno spazio aggiuntivo deve essere inserito tra le parole
      ; 2) Se il numero di spazi su una riga non si divide equamente,
      ;    gli spazi vuoti a sinistra saranno maggiori degli spazi a destra.
      ; Linea finale da aggiungere alla lista linee
      (setq riga "")
      ; Differenza del numero di parole
      ; tra la prima e l'ultima parola della riga
      (setq diff (- succ indice 1))
            ; Se siamo sull'ultima riga
            ; o se c'è una sola parola nella riga ...
      (cond ((or (= succ (length parole)) (= diff 0))
             ; Allora giustifichiamo a sinistra
             ; scorrendo le parole della riga
             ; (con gli indici "indice" e "succ")
             ; e aggiungendo uno spazio dopo ogni parola
             (for (i indice (- succ 1))
               (extend riga (parole i) " ")
             )
             ; Abbiamo aggiunto uno spazio extra alla fine
             ; quindi lo rimuoveremo utilizzando la funzione slice.
             (setq riga (slice riga 0 (- (length riga) 1)))
             ; Ora bisogna aggiungere spazi per riempire il resto della riga
             (for (i (length riga) (- L 1))
               (extend riga " ")
             )
            )
            ; Altrimenti trattiamo le altre righe che
            ; devono essere giustificate a destra e sinistra
            (true
              ; Numero di spazi già presenti nella riga
              ; (massimo dei caratteri meno
              ; il numero di caratteri delle parole,
              ; il tutto diviso per la differenza)
              (setq spazi (/ (- L conta) diff))
              ; Numero spazi da aggiungere: (L - count) % difference)
              (setq resto (% (- L conta) diff))
              ; Ciclo sulle parole della riga per aggiungerle
              ; (con gli indici "indice" e "succ")
              (for (i indice (- succ 1))
                (extend riga (parole i))
                ; Se non è l'ultima parola..
                (if (< i (- succ 1))
                    ; allora calcoliamo il numero degli spazi da aggiungere,
                    ; utilizzando la variabile resto,
                    ; e poi li aggiungiamo alla riga
                    (begin
                    (if (< (- i indice) resto)
                        (setq limit (+ spazi 1))
                        (setq limit spazi)
                    )
                    (for (j 0 limit)
                      (extend riga " ")
                    )
                ))
              )
            )
      )
      ; Aggiunge la linea corrente alla lista delle linee
      (push riga linee -1)
      ; L'indice corrente diventa l'indice
      ; dell'ultima parola della linea corrente
      (setq indice succ)
    )
    ; Output: lista di linee giustificate al centro
    linee))

(giustifica-testo '("Questo" "è" "un" "esempio" "di" "testo" "da" "giustificare.") 16)
;-> ("Questo    è   un" "esempio di testo" "da giustificare.  ")

(giustifica-testo '("Questo" "è" "un" "esempio" "di" "testo" "da" "giustificare.") 12)
;-> ("Questo  è un" "esempio   di" "testo     da" "giustificare.   ")


------------
Data e tempo
------------

newLISP mette a disposizione diverse funzioni per le date e il tempo.

La funzione "now" restituisce informazioni sulla data e l'ora correnti come una lista di numeri interi:

(now)
;-> (2021 4 12 14 37 28 909751 102 1 120 2)

Valore   Descrizione
------   -----------
  2021   Anno del calendario Gregoriano
     4   Mese (1–12)
    12   Giorno (1–31)
    14   Ora (0–23) UTC
    37   Minuti (0–59)
    28   Secondi  (0–59)
909751   Microsecondi (0–999999) OS-specifico, risoluzione in millisecondi
   102   Numero giorno dell'anno (1 Gen è 1)
     1   Numero giorno della settimana (1–7) inizianod da Lunedì
   120   Differenza di fuso orario in minuti a ovest del GMT (inclusa l'ora legale)
     2   Tipo di ora legale (0–6) su Linux/Unix o (0–2) su MS Windows

La funzione "time-of-day" restituisce il tempo trascorso dall'inizio del giorno corrente (in millisecondi).

(setq t (time-of-day))
;-> 59999105.675

La funzione "date" restituisce la data e l'ora correnti del fuso orario locale (stringa)

(date)
;-> "Mon Apr 12 16:42:32 2021"

Note: consultare il manuale per vedere le caratteristiche complete delle funzioni elencate sopra e le altre funzioni sulle date "date-value", "date-list" e "date-parse".

Ora del giorno (binaria)
------------------------
Per divertimento vediamo una funzione che restituisce l'ora in formato binario.

(setq data (parse (date) " "))
;-> ("Mon" "Apr" "12" "16:43:59" "2021")
(setq ora (parse (data 3) ":"))
;("16" "43" "59")
(setq lst (map (fn(x) (bits (int x 0 10))) ora))
;-> ("10000" "101011" "111011")

(define (b-time)
(local (data ora lst)
  (setq data (parse (date) " "))
  ;("Mon" "Apr" "12" "16:43:59" "2021")
  (setq ora (parse (data 3) ":"))
  ;("16" "43" "59")
  (setq lst (map (fn(x) (bits (int x 0 10))) ora))
  ;("10000" "101011" "111011")
  (println "     24 16  8  4  2  1")
  (println "     -----------------")
  (dolist (el lst)
    (setq b el)
    (if (< (length b) 6)
        (push (dup "0" (- 6 (length b))) b))
    ;("010000" "101011" "111011")
    (cond ((= $idx 0) (print "ore:"))
          ((= $idx 1) (print "min:"))
          ((= $idx 2) (print "sec:"))
    )
    (dostring (ch b) (print "  " (char ch)))
    (println {})
  )))

(b-time)
;->      24 16  8  4  2  1
;->      -----------------
;-> ore:  0  1  0  0  0  1
;-> min:  1  1  0  0  0  0
;-> sec:  0  1  0  1  1  1


-------------------------
Algoritmo di Gale-Shapley
-------------------------

Supponiamo che ci siano n donne e n uomini. Ogni uomo classifica le donne in ordine di preferenza, e le donne classificano gli uomini allo stesso modo.
Un matrimonio è una perfetta corrispondenza tra gli uomini e le donne in un grafo bipartito completo.
Un matrimonio viene chiamato stabile se non esiste un uomo i e una donna j tali che l'uomo preferisca j alla sua
attuale moglie e la donna preferisce i al suo attuale marito.
L'obiettivo è calcolare un matrimonio stabile dalle 2*n preferenze dichiarate.
La soluzione non è necessariamente unica.

L'algoritmo di Gale–Shapley (1962) risolve questo problema in tempo O(n^2), ma non è detto che la soluzione sia ottimale.
L'algoritmo inizia senza coppie sposate. Quindi, finché ci sono uomini single, l'algoritmo seleziona uno scapolo i e la donna j che piace di più all'uomo i trq quell donne che non sono state ancora considerate. L'algoritmo cerca quindi di sposare i con j. Il matrimonio avrà luogo se j è ancora single o se j è sposata con un uomo k, ma preferisce i a k. In questo caso, k viene "divorziato" e ritorna nel gruppo di uomini single.

Per la complessità, ogni coppia i, j è considerata al massimo una volta dall'algoritmo, e il lavoro da fare per ogni coppia richiede tempo costante. Per la validità è sufficiente osservare che man mano che l'algoritmo procede:
(1) una data donna è sposata con uomini che lei preferisce sempre di più,
(2) mentre un dato uomo è sposato con donne che preferisce sempre di meno
Per dimostrare la validità dell'algoritmo, supponiamo che alla fine esista un uomo sposato una donna j1 e una donna j sposata con un uomo i1 tali che i preferisce j a j1 e j preferisce i a i1. Per l'osservazione (2), ad un certo punto l'algoritmo ha esaminato la coppia i, j. Tuttavia, per (1), l'algoritmo non ha mai sposato i con j. Questo significa che quando è stata considerata la coppia (i, j) la donna j deve essere stata sposata con un uomo k che lei preferisce a i. Questo contraddice il fatto che lei possa essere sposata con un uomo che le piace meno di i.

Nell'implementazione seguente, gli uomini sono numerati da 0 a n−1, così come le donne. L'input è costituito da due array. L'array men contiene, per ogni uomo, la relativa lista di n donne preferite, in ordine decrescente. L'array women contiene, per ogni donna, la relativa lista di n uomini preferiti.
L'array women viene prima trasformato in un array che contiene per ogni donna j e uomo i il grado di preferenza che j ha per i. Ad esempio, se rank(j)(i) = 0, allora i è l'uomo preferito di j, e se rank(j)(i1) = 1, allora i1 è il secondo nella lista per j, ecc.
Infine, l'array link associa a ciascuna donna l'uomo con cui si trova attualmente sposata. La coda singles contiene gli uomini singoli e per ogni uomo i il valore cur-choices(i) indica l'indice della prossima donna nella sua lista di
preferenze.

L'algoritmo può essere applicato a qualunque situazione in cui occorra accoppiare due gruppi in base alle preferenze espresse dai singoli elementi di ogni gruppo. Per questo abbiamo generalizzato le variabili per non legare l'algoritmo solo alla soluzione dei "matrimoni stabili".

(define (couple prefs-a prefs-b)
  (local (len cur-choices links singles rank i j)
    (setq len (length prefs-a))
    (setq cur-choices (array len '(0)))
    (setq links (array len '(nil)))
    (setq rank (array len len '(0)))
    (for (j 0 (- len 1))
      (for (r 0 (- len 1))
        (setf (rank j (prefs-b j r)) r)
      )
    )
    (setq singles (sequence 0 (- len 1)))
    (while singles
      (setq i (pop singles))
      (setq j (prefs-a i (cur-choices i)))
      (++ (cur-choices i))
      (cond ((nil? (links j))
             (setf (links j) i))
            ((< (rank j (links j)) (rank j i))
             (push i singles -1))
            (true
              (push (links j) singles -1)
              (setf (links j) i))
      )
    )
    links))

Vediamo un esempio:

(setq m '((4 1 2 3 0) (1 4 0 2 3) (3 2 1 0 4) (0 1 2 3 4) (4 1 2 3 0)))
(setq w '((4 2 3 0 1) (0 1 2 4 3) (3 4 2 1 0) (4 1 0 3 2) (1 0 3 2 4)))
(couple m w)
;-> (3 1 4 2 0)

Interpretiamo il risultato considerando l'indice 0 come il primo elemento (sia per gli uomini che per le donne):

Woman  Man
-----  ---
W1     M4 (3)
W2     M2 (1)
W3     M5 (4)
W4     M3 (2)
W5     M1 (0)

Per ottenere tutti gli accoppiamenti della soluzione possiamo scrivere:

(sort (map (fn(x) (list $idx x)) (couple m w)))
;-> ((0 3) (1 1) (2 4) (3 2) (4 0))


----------------------------------
Il problema dello zaino (Knapsack)
----------------------------------

Dati n oggetti con pesi p(0),...,p(n−1) e valori v(0),...,v(n−1), e dato uno zaino con una capacità C, dove C è un numero intero, trovare un sottoinsieme degli oggetti con valore totale massimo, il cui peso totale non supera la capacità C.
Questo è un problema NP-Hard.

Per i in {0,...,n − 1} e c in {0,...,C}, assegnare Opt[i][c] come il valore più grande ottenibile tra oggetti con indice da 0 a i senza che il loro peso superi la capacità c. Per il caso base i = 0, abbiamo Opt[0][c] = 0 se (p(0) > c) altrimenti Opt[0][c] = v0.
Per valori maggiori di i, compaiono al massimo due scelte possibili per l'oggetto dell'indice i: possiamo prenderlo o possiamo lasciarlo.
Nel primo caso, la capacità disponibile viene ridotta di p(i). Abbiamo quindi la relazione:

                | opt[i-1][c- p(i)] + v(i) (nel caso in cui prendiamo l'oggetto e (p(i) >= c))
opt[i][c] = max |
                | opt[i-1][c]              (nel caso in cui lasciamo l'oggetto)

Questo è un algoritmo con complessità pseudo-polinomiale O(n*C), cioè un algoritmo che è polinomiale nel valore degli input ma non nella loro dimensione (inquesto caso, aumentando di poco la dimensione di C raddoppia il tempo di esecuzione).

Una matrice booleana Sel viene mantenuta in parallelo con la matrice di programmazione dinamica Opt. Questo ci permette di ricordare le scelte fatte che hanno portato ai valori memorizzati in Opt. Una volta che queste matrici sono state popolate seguendo la formula di ricorrenza sopra descritta, attraversando gli elementi in ordine inverso possiamo estrarre dalla matrice Sel l'insieme di elementi che fornisce il valore totale ottimale.

(define (knapsack p v cmax)
(local (n opt sel cap solution)
  (setq n (length p))
  (setq opt (array n (+ cmax 1) '(0)))
  (setq sel (array n (+ cmax 1) '(nil)))
  (for (cap (p 0) cmax)
    (setf (opt 0 cap) (v 0))
    (setf (sel 0 cap) true)
  )
  (for (i 1 (- n 1))
    (for (cap 0 cmax)
      (cond ((and (>= cap (p i))
                  (> (add (opt (- i 1) (- cap (p i))) (v i)) (opt (- i 1) cap)))
             (setf (opt i cap) (add (opt (- i 1) (- cap (p i))) (v i)))
             (setf (sel i cap) true))
             (true
              (setf (opt i cap) (opt (- i 1) cap))
              (setf (sel i cap) nil))
      )
    )
  )
  (setq cap cmax)
  (setq solution '())
  (for (i (- n 1) 0 -1)
    (if (sel i cap) (begin
        (push i solution)
        (setq cap (- cap (p i))))
    )
  )
  (list (opt (- n 1) cmax) solution)))

(setq p '(1 2 3 2 2))
(setq v '(8 4 0 5 3))
(knapsack p v 4)
;-> (13 (0 3))

(setq p '(10 20 30))
(setq v '(60 100 120))
(knapsack p v 50)
;-> (220 (1 2))

(setq p '(9.9 19.6 29.4))
(setq v '(59.3 99.8 118.5))
(knapsack p v 50)
;-> (218.3 (1 2))

(setq p '(3 4 5 9 4))
(setq v '(3 4 4 10 4))
(knapsack p v 11)
;-> (11 (0 1 4))

(setq p '(12 2 1 1 4))
(setq v '(4 2 1 2 10))
(knapsack p v 15)
;-> (15 (1 2 3 4))


-----------------
Validazione UTF-8
-----------------

Un carattere in UTF-8 può essere lungo da 1 a 4 byte ed è soggetto alle seguenti regole:
Per i caratteri di 1 byte, il primo bit è 0, seguito dal suo codice Unicode.
Per il carattere di n byte, i primi n bit sono tutti uno, il bit n + 1 è 0, seguito da n-1 byte con i 2 bit più significativi 10. Ecco come funziona la codifica UTF-8:

   Intervallo di numeri  |  Sequenza di Ottetti UTF-8
      dei caratteri      |        (binario)
      (esadecimale)      |
   ----------------------+----------------------------------------
   0000 0000-0000 007F   |  0xxxxxxx
   0000 0080-0000 07FF   |  110xxxxx 10xxxxxx
   0000 0800-0000 FFFF   |  1110xxxx 10xxxxxx 10xxxxxx
   0001 0000-0010 FFFF   |  11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

Dato un array di numeri interi che rappresentano i dati, restituire se si tratta di una codifica UTF-8 valida.

Nota: l'input è un array di numeri interi. Per memorizzare i dati vengono utilizzati solo gli 8 bit meno significativi di ciascun numero intero. Ciò significa che ogni numero intero rappresenta solo 1 byte di dati.

Esempio 1:
data = [197, 130, 1], che rappresenta la sequenza di ottetti: 11000101 10000010 00000001.
Restituisce: true
È una codifica utf-8 valida per un carattere di 2 byte seguito da un carattere di 1 byte.

Esempio 2:
data = [235, 140, 4], che rappresentava la sequenza di ottetti: 11101011 10001100 00000100.
Restituisce: nil
I primi 3 bit sono tutti 1 e il 4° bit è 0, questo significa che è un carattere di 3 byte.
Il byte successivo è un byte di continuazione che inizia con 10 ed è corretto.
Ma il secondo byte di continuazione non inizia con 10, quindi non è valido.

(define (utf8? data)
(catch
  (let ((conta 0) (out true))
    (for (i 0 (- (length data) 1))
      (if (zero? conta)
          (cond ((= (bits (>> (data i) 5)) "110")
                 (setq conta 1))
                ((= (bits (>> (data i) 4)) "111")
                 (setq conta 2))
                ((= (bits (>> (data i) 3)) "1111")
                 (setq conta 3))
                ((= (bits (>> (data i) 7)) "1")
                 (throw nil))
          )
          (begin ;else
          (if (!= (>> (data i) 6) 2)
              (throw nil)
          )
          (-- conta))
      )
    )
    (zero? conta))))

(utf8? '(197 130 1))
;-> true

(utf8? '(235 140 1))
;-> nil

Nota: L'algoritmo originale utilizza l'operatore bit-wise ">>>" (unsigned right bit-shift). newLISP non possiede questo operatore ed abbiamo utilizzato l'operatore ">>" (signed right bit-shift). Entrambi dividono il primo operando per 2 elevato al secondo operando.
La differenza tra ">>" e ">>>" appare solo quando si usano numeri negativi. L'operatore ">>" sposta un bit 1 nel bit più significativo se era un 1, invece ">>>" sposta in 0 a prescindere.


------------
Sudoku mania
------------

Un altro programma brute-force per risolvere il sudoku.

; controlla se un tentativo (numero) è valido in un box (3x3)
(define (check-box guess row col grid)
(catch
  (local (xb yb)
    (setq xb (* (/ col 3) 3))
    (setq yb (* (/ row 3) 3))
    (for (y 0 2)
      (for (x 0 2)
        (if (= guess (grid (+ yb y) (+ xb x)))
            (throw nil))))
    true)))
; controlla se un tentativo (numero) è valido in una riga
(define (check-row guess row col grid)
(catch
  (local (tmp)
    (for (x 0 8)
      (if (= guess (grid row x))
          (throw nil)))
    true)))
; controlla se un tentativo (numero) è valido in una colonna
(define (check-col guess row col grid)
(catch
  (local (tmp)
    (for (y 0 8)
      (if (= guess (grid y col))
          (throw nil)))
    true)))
; controlla se un tentativo (numero) è valido
(define (is-safe guess row col grid)
  (if (and (check-row guess row col grid)
           (check-col guess row col grid)
           (check-box guess row col grid))
      true
      nil))
; funzione ausiliaria che risolve il sudoku
(define (sudoku-aux)
(catch
  (local (tmp)
    (for (y 0 8)
      (for (x 0 8)
        (if (zero? (grid y x))
            (begin
              (for (num 1 9)
                (if (is-safe num y x grid)
                    (begin
                      (setf (grid y x) num)
                      (if (sudoku-aux) (throw true))
                      (setf (grid y x) 0)
                    )
                )
              )
              (throw nil)
            )
        )
      )
    )
    true)))
; Funzione principale
(define (sudoku matrix)
  (local (grid)
    (setq grid matrix)
    (if (sudoku-aux) grid nil)))

Vediamo alcuni esempi:

(setq s1 '((3 0 6 5 0 8 4 0 0)
           (5 2 0 0 0 0 0 0 0)
           (0 8 7 0 0 0 0 3 1)
           (0 0 3 0 1 0 0 8 0)
           (9 0 0 8 6 3 0 0 5)
           (0 5 0 0 9 0 6 0 0)
           (1 3 0 0 0 0 2 5 0)
           (0 0 0 0 0 0 0 7 4)
           (0 0 5 2 0 6 3 0 0)))

(sudoku s1)
;-> ((3 1 6 5 7 8 4 9 2)
;->  (5 2 9 1 3 4 7 6 8)
;->  (4 8 7 6 2 9 5 3 1)
;->  (2 6 3 4 1 5 9 8 7)
;->  (9 7 4 8 6 3 1 2 5)
;->  (8 5 1 7 9 2 6 4 3)
;->  (1 3 8 9 4 7 2 5 6)
;->  (6 9 2 3 5 1 8 7 4)
;->  (7 4 5 2 8 6 3 1 9))

(setq escargot
'((1 0 0 0 0 7 0 9 0)
  (0 3 0 0 2 0 0 0 8)
  (0 0 9 6 0 0 5 0 0)
  (0 0 5 3 0 0 9 0 0)
  (0 1 0 0 8 0 0 0 2)
  (6 0 0 0 0 4 0 0 0)
  (3 0 0 0 0 0 0 1 0)
  (0 4 0 0 0 0 0 0 7)
  (0 0 7 0 0 0 3 0 0)))

(time (println (sudoku escargot)))
;-> ((1 6 2 8 5 7 4 9 3)
;->  (5 3 4 1 2 9 6 7 8)
;->  (7 8 9 6 4 3 5 2 1)
;->  (4 7 5 3 1 2 9 8 6)
;->  (9 1 3 5 8 6 7 4 2)
;->  (6 2 8 7 9 4 1 3 5)
;->  (3 5 6 4 7 8 2 1 9)
;->  (2 4 1 9 3 5 8 6 7)
;->  (8 9 7 2 6 1 3 5 4))
;-> 333.887

(setq world
'((8 0 0 0 0 0 0 0 0)
  (0 0 3 6 0 0 0 0 0)
  (0 7 0 0 9 0 2 0 0)
  (0 5 0 0 0 7 0 0 0)
  (0 0 0 0 4 5 7 0 0)
  (0 0 0 1 0 0 0 3 0)
  (0 0 1 0 0 0 0 6 8)
  (0 0 8 5 0 0 0 1 0)
  (0 9 0 0 0 0 4 0 0)))

(time (println (sudoku world)))
;-> ((8 1 2 7 5 3 6 4 9)
;->  (9 4 3 6 8 2 1 7 5)
;->  (6 7 5 4 9 1 2 8 3)
;->  (1 5 4 2 3 7 8 9 6)
;->  (3 6 9 8 4 5 7 2 1)
;->  (2 8 7 1 6 9 5 3 4)
;->  (5 2 1 9 7 4 3 6 8)
;->  (4 3 8 5 2 6 9 1 7)
;->  (7 9 6 3 1 8 4 5 2))
;-> 1840.978

(setq tweezers
'((1 0 0 0 0 0 0 6 0)
  (0 0 0 1 0 0 0 0 3)
  (0 0 5 0 0 2 9 0 0)
  (0 0 9 0 0 1 0 0 0)
  (7 0 0 0 4 0 0 8 0)
  (0 3 0 5 0 0 0 0 2)
  (5 0 0 4 0 0 0 0 6)
  (0 0 8 0 6 0 0 7 0)
  (0 7 0 0 0 5 0 0 0)))

(time (println (sudoku tweezers)))
;-> ((1 8 2 3 9 4 5 6 7)
;->  (9 6 7 1 5 8 2 4 3)
;->  (3 4 5 6 7 2 9 1 8)
;->  (8 2 9 7 3 1 6 5 4)
;->  (7 5 6 2 4 9 3 8 1)
;->  (4 3 1 5 8 6 7 9 2)
;->  (5 9 3 4 1 7 8 2 6)
;->  (2 1 8 9 6 3 4 7 5)
;->  (6 7 4 8 2 5 1 3 9))
;-> 9305.376


---------------------------------------
Radici quadrate con il metodo di Newton
---------------------------------------

Dato un numero intero N e un livello di precisione P, trovare la radice quadrata di N con una precisione superiore a P utilizzando il metodo di Newton.

Esempi:

input: N = 16, P = 0.0000001
output: 4
4 ^ 2 = 16

input: N = 327, P = 0.0000001
output: 18.0831

Metodo di Newton
----------------
Dato un numero qualsiasi N la sua radice quadrata di N è data dalla formula:

radice = 0.5 * (X + (N / X)) dove X è un valore iniziale che può essere assunto come N o 1.

Nota: "radice" è la nuova X da utilizzare per il passo successivo.

Nella formula sopra, X è una qualsiasi radice quadrata presunta di N e "radice" è la radice quadrata corretta di N. La precisione è data dalla differenza assoluta tra X e "radice".

Algoritmo:

1) Assegnare X uguale a N.
2) Ciclo continuo per calcolare la radice ottenendo valori sempre più vicini al valore corretto della radice quadrata di N.
3) Verificare la differenza tra la X presunta e la radice calcolata:
   Se siamo superiori alla precisione richiesta,
    allora aggiornare la radice e continuare.
    altrimenti uscuamo dal ciclo.
4) Restituire il valore della radice.

Di seguito è riportata l'implementazione dell'approccio di cui sopra:
(define (square-root num prec)
(catch
  (local (x conta)
    (setq x num)
    (setq conta 0)
    (while true
      (++ conta)
      (setq radice (mul 0.5 (add x (div num x))))
      (if (< (abs (sub radice x)) prec)
          (throw radice)
      )
      ; aggiornamento valore radice
      (setq x radice)
    )
    nil)))

(square-root 16 0.001)
;-> 4.000000000000051

(square-root 16 0.0000001)
;-> 4

(square-root 1111 0.0000001)
;-> 33.33166662499792
(mul 33.33166662499792 33.33166662499792)
;-> 1111.000000000001


---------
Ippodromo
---------

Un semplice gioco per divertirsi con i bambini (e magari scommettere tra grandi).
La funzione "ippodromo" prende due parametri, il numero di cavalli che partecipano alla corsa (denominati "A", "B", "C", ecc.) e la lunghezza della pista.
Dalla posizione di partenza dobbiamo premere "invio" per far muovere casualmente uno dei cavalli...fino alla fine della corsa.

(define (ippodromo num-cavalli lunghezza)
  (local (cavalli testa mossa cav pos)
    ; inizializzazione dei numeri casuali
    (seed (time-of-day))
    ; crea una lista associativa (cavalli, posizione) di lunghezza num-cavalli
    ; (("A" 0) ("B" 0) ("C" 0) ("D" 0) ...)
    (setq cavalli '())
    (for (i 0 (- num-cavalli 1))
      (push (list (char (+ i 65)) 0) cavalli -1)
    )
    ; Inizia la corsa...
    ; stampa la posizione di partenza
    (println "Posizione di partenza")
    (println (dup "-" (+ lunghezza 1)))
    (for (i 0 (- num-cavalli 1))
      ; nome cavallo corrente
      (setq cav (char (+ 65 i)))
      ; posizione iniziale cavallo corrente
      (println cav (dup "∙" lunghezza))
    )
    (println (dup "-" (+ lunghezza 1)))
    ; posizione del cavallo in testa
    (setq testa 0)
    (while (< testa lunghezza)
      ; Premere invio per il prossimo passo
      (read-line)
      ; mossa (+1) casuale di uno dei cavalli
      (setq mossa (rand num-cavalli))
      ; aggiornamento posizione cavallo mosso
      (++ (lookup (char (+ 65 mossa)) cavalli))
      ; stampa corsa
      (for (i 0 (- num-cavalli 1))
        ; nome cavallo corrente
        (setq cav (char (+ 65 i)))
        ; posizione cavallo corrente
        (setq pos (lookup cav cavalli))
        ; stampa corsa cavallo corrente
        (println (dup " " pos) cav (dup "∙" (- lunghezza pos)))
        ;(println (dup " " pos) cav (dup "." (- lunghezza pos)))
      )
      (println { })
      (println (dup "-" (+ lunghezza 1)))
      ; calcolo della posizione del cavallo in testa
      (setq testa (apply max (map last cavalli)))
    )
    ; la corsa è finita...
    ; ordinamento della lista cavalli in base alla posizione
    (setq arrivo (sort cavalli (fn(x y) (>= (last x) (last y)))))
    ; stampa l'ordine di arrivo
    (println "Ordine di arrivo:")
    (for (i 0 (- num-cavalli 1))
      (println (+ i 1) "° " (arrivo i 0) " (" (arrivo i 1) ")")
    )
    '-----------------))

(ippodromo 2 5)
;-> Posizione di partenza
;-> ------
;-> A∙∙∙∙∙
;-> B∙∙∙∙∙
;-> ------
;->
;-> A∙∙∙∙∙
;->  B∙∙∙∙
;->
;-> ------
;->
;-> A∙∙∙∙∙
;->   B∙∙∙
;->
;-> ------
;->
;->  A∙∙∙∙
;->   B∙∙∙
;->
;-> ------
;->
;->  A∙∙∙∙
;->    B∙∙
;->
;-> ------
;->
;->  A∙∙∙∙
;->     B∙
;->
;-> ------
;->
;->  A∙∙∙∙
;->      B
;->
;-> ------
;-> Ordine di arrivo:
;-> 1° B (5)
;-> 2° A (1)
;-> -----------------

(ippodromo 10 70)
;-> Posizione di partenza
;-> -----------------------------------------------------------------------
;-> A∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙
;-> B∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙
;-> C∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙
;-> D∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙
;-> E∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙
;-> F∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙
;-> G∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙
;-> H∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙
;-> I∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙
;-> J∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙
;-> -----------------------------------------------------------------------
;->
...
;->
;-> -----------------------------------------------------------------------
;->                                                          A∙∙∙∙∙∙∙∙∙∙∙∙∙
;->                                                                  B∙∙∙∙∙
;->                                                    C∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙
;->                                                              D∙∙∙∙∙∙∙∙∙
;->                                                   E∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙
;->                                                                       F
;->                                               G∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙
;->                                         H∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙
;->                                                            I∙∙∙∙∙∙∙∙∙∙∙
;->                                                      J∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙
;-> -----------------------------------------------------------------------
;-> Ordine di arrivo:
;-> 1° F (70)
;-> 2° B (65)
;-> 3° D (61)
;-> 4° I (59)
;-> 5° A (57)
;-> 6° J (53)
;-> 7° C (51)
;-> 8° E (50)
;-> 9° G (46)
;-> 10° H (40)
;-> -----------------


------------------------------------------------
Parser di espressioni infisse-prefisse-postfisse
------------------------------------------------

Questa funzione è basata sul modulo "infix.lsp" che si trova nella distribuione di newLISP ed è stata scritta da Lutz Mueller.

La procedura analizza le espressioni infisse, prefisse o suffisse fornite nelle stringhe e restituisce espressioni newLISP, che possono essere valutate. inoltre cattura gli errori di sintassi.

;; @syntax (xlate <str-expression>)
;; @param <str-expression> The expression (infix, postfix, prefix) in a string
;; @return A newLISP expression or 'nil' on failure.
;; When 'nil' is returned then the error message is in 'result'.
;;
;; Note that the parser requires operators, variables and constants surrounded
;; by spaces except where parenthesis are used.
;;
;; @example
;; (xlate "3 + 4") => (add 3 4) ;; parses infix
;; (xlate "+ 3 4") => (add 3 4) ;; parses prefix s-expressions
;; (xlate "3 4 +") => (add 2 4) ;; parses postfix
;;
;; (xlate "3 + * 4") => "ERR: missing argument for +"
;;
;; (eval (xlate "3 + 4")) => 7
;;
;; (xlate "(3 + 4) * (5 - 2)")  => (mul (add 3 4) (sub 5 2))
;;
;; (xlate "(a + b) ^ 2 + (a - b) ^ 2") => (add (pow (add a b) 2) (pow (sub a b) 2))
;;
;; (xlate "x = (3 + sin(20)) * (5 - 2)")  => (setq x (mul (add 3 (sin 20)) (sub 5 2)))
;;
;; (xlate "x = (3 + sin(10 - 2)) * (5 - 2)")
;;         => (setq x (mul (add 3 (sin (sub 10 2))) (sub 5 2)))
;
; operator priority table
; (token operator arg-count priority)
(set 'operators '(
  ("=" setq 2 2)
  ("+" add 2 3)
  ("-" sub 2 3)
  ("*" mul 2 4)
  ("/" div 2 4)
  ("^" pow 2 5)
  ("abs" abs 1 9)
  ("acos" acos 1 9)
  ("asin" asin 1 9)
  ("atan" atan 1 9)
  ("sin" sin 1 9)
  ("sqrt" sqrt 1 9)
  ("tan" tan 1 9)
  ("cos" cos 1 9)
; add what else is needed
  ))
; Main function
(define (xlate str)
  (if (catch (infix-xlate str) 'result)
    result                     ; if starts with ERR: is error else result
    (append "ERR: " result)))  ; newLISP error has occurred
; Auxiliary function
(define (infix-xlate str)
  (set 'tokens (parse str))
  (set 'varstack '())
  (set 'opstack '())
  (dolist (tkn tokens)
  (case tkn
        ("(" (push tkn opstack))
        (")" (close-parenthesis))
        (true (if (assoc tkn operators)
                  (process-op tkn)
                  (push tkn varstack)))))
  (while (not (empty? opstack))
        (make-expression))
  (set 'result (first varstack))
  (if (or (> (length varstack) 1) (not (list? result)))
    (throw "ERR: wrong syntax")
    result))
; pop all operators and make expressions
; until an open parenthesis is found
(define (close-parenthesis)
 (while (not (= (first opstack) "("))
    (make-expression))
 (pop opstack))
; pop all operator, which have higher/equal priority
; and make expressions
(define (process-op tkn)
  (while (and opstack
              (<= (lookup tkn operators 3) (lookup (first opstack) operators 3)))
        (make-expression))
  (push tkn opstack))
; pops an operator from the opstack and makes/returns an
; newLISP expression
(define (make-expression)
  (set 'expression '())
  (if (empty? opstack)
        (throw "ERR: missing parenthesis"))
  (set 'ops (pop opstack))
  (set 'op (lookup ops operators 1))
  (set 'nops (lookup ops operators 2))
  (dotimes (n nops)
    (if (empty? varstack) (throw (append "ERR: missing argument for " ops)))
    (set 'vars (pop varstack))
    (if (atom? vars)
            (if (not (or (set 'var (float vars))
                         (and (legal? vars) (set 'var (sym vars))) ))
                (throw (append vars "ERR: is not a variable"))
                (push var expression))
            (push vars expression)))
  (push op expression)
  (push expression varstack))

Esempi:

Infissa -> Prefissa
(xlate "3 + 4")
;-> (add 3 4)

Prefiss -> Prefissa
(xlate "+ 3 4")
;-> (add 3 4)

Postfissa -> Prefissa
(xlate "3 4 +")
;-> (add 3 4)

(xlate "3 + * 4")
;-> "ERR: missing argument for +"

(eval (xlate "3 + 4"))
;-> 7

(xlate "(3 + 4) * (5 - 2)")
;-> (mul (add 3 4) (sub 5 2))

(xlate "(a + b) ^ 2 + (a - b) ^ 2")
;-> (add (pow (add a b) 2) (pow (sub a b) 2))

(xlate "x = (3 + sin(20)) * (5 - 2)")
;-> (setq x (mul (add 3 (sin 20)) (sub 5 2)))

(xlate "x = (3 + sin(10 - 2)) * (5 - 2)")
;-> (setq x (mul (add 3 (sin (sub 10 2))) (sub 5 2)))


-------------------
Derivate Simboliche
-------------------

Dal libro "Structure and Interpretation of Computer Programs" di Abelson e Sussman.
Capitolo 2 Building Abstractions with Data
Pararafo 2.3.2 Esempio: Derivata simbolica

https://mitpress.mit.edu/sites/default/files/sicp/full-text/sicp/book/node39.html

Nota: funzioni ausiliarie "car" e "cdr"
;(define (car x)    (first x))
;(define (cdr x)    (rest x))
(define car first)
(define cdr rest)
(define (caar x)   (first (first x)))
(define (cadr x)   (first (rest x)))
(define (cdar x)   (rest (first x)))
(define (cddr x)   (rest (rest x)))
(define (caaar x)  (first (first (first x))))
(define (caadr x)  (first (first (rest x))))
(define (cadar x)  (first (rest (first x))))
(define (caddr x)  (first (rest (rest x))))

Come illustrazione della manipolazione dei simboli e un'ulteriore illustrazione dell'astrazione dei dati, si consideri la progettazione di una procedura che esegue la differenziazione simbolica delle espressioni algebriche. Vorremmo che la procedura prendesse come argomenti un'espressione algebrica e una variabile e restituisse la derivata dell'espressione rispetto alla variabile. Ad esempio, se gli argomenti della procedura sono ax^2 + bx + c e x, la procedura dovrebbe restituire 2ax + b. La differenziazione simbolica ha un significato storico speciale in Lisp. È stato uno degli esempi motivanti alla base dello sviluppo di un linguaggio informatico per la manipolazione dei simboli. Inoltre, ha segnato l'inizio della linea di ricerca che ha portato allo sviluppo di potenti sistemi per il calcolo matematico simbolico, che sono attualmente utilizzati da un numero crescente di matematici applicati e fisici.

Nello sviluppo del programma di differenziazione simbolica, seguiremo la stessa strategia di astrazione dei dati che abbiamo seguito nello sviluppo del sistema numerico razionale della sezione 2.1.1. Cioè, definiremo prima un algoritmo di differenziazione che opera su oggetti astratti come "somme", "prodotti" e "variabili" senza preoccuparci di come questi devono essere rappresentati. Solo in seguito affronteremo il problema della rappresentazione.

Il programma di differenziazione con dati astratti
--------------------------------------------------
Per mantenere le cose semplici, prenderemo in considerazione un programma di differenziazione simbolica molto semplice che gestisce espressioni costruite utilizzando solo le operazioni di addizione e moltiplicazione con due argomenti. La differenziazione di tali espressioni può essere effettuata applicando le seguenti regole di riduzione:

   dc
  ---- = 0 per c costante o variabile diversa da x
   dx

   dx
  ---- = 1
   dx

   d(u + v)     du     dv
  ---------- = ---- + ----
      dx        dx     dx

   d(u * v)       dv       du
  ---------- = u*---- + v*----
      dx          dx       dx

Osserva che le ultime due regole sono di natura ricorsiva. Cioè, per ottenere la derivata di una somma troviamo prima le derivate dei termini e le sommiamo. Ciascuno dei termini può a sua volta essere un'espressione che deve essere scomposta. La scomposizione in pezzi sempre più piccoli produrrà alla fine pezzi che sono costanti o variabili, le cui derivate saranno 0 o 1.

Per incorporare queste regole in una procedura, dobbiamo affidarci ad una ipotesi di speranza, come abbiamo fatto nel progettare l'implementazione de numeri razionali. Se avessimo un mezzo per rappresentare espressioni algebriche, dovremmo essere in grado di dire se un'espressione è una somma, un prodotto, una costante o una variabile. Dovremmo essere in grado di estrarre le parti di un'espressione. Per una somma, ad esempio, vogliamo essere in grado di estrarre l'addendo (primo termine) e l'augendo (secondo termine). Dovremmo anche essere in grado di costruire espressioni dalle parti. Supponiamo di avere già procedure per implementare i seguenti selettori, costruttori e predicati:

  (variable? e)	"a" è una variabile?

  (same-variable? v1 v2)	v1 e v2 sono le stesse variabili?

  (sum? e) "e" è una somma?

  (addend e)	Addendo della somma "e"

  (augend e)	Augendo della somma "e"

  (make-sum a1 a2)	Costruisce la somma di "a1" e "a2"

  (product? e) "e" è un prodotto?

  (multiplier e)	Moltiplicatore del prodotto "e"

  (multiplicand e)	Moltiplicando del prodotto "e"

  (make-product m1 m2)	Costruisce il prodotto di "m1" e "m2"

Usando questi, e il predicato primitivo "number?", che identifica i numeri, possiamo esprimere le regole di differenziazione come la seguente procedura:

(define (deriv expr var)
  (cond ((number? expr) 0)
        ((variable? expr)
         (if (same-variable? expr var) 1 0))
        ((sum? expr)
         (make-sum (deriv (addend expr) var)
                   (deriv (augend expr) var)))
        ((product? expr)
         (make-sum
           (make-product (multiplier expr)
                         (deriv (multiplicand expr) var))
           (make-product (deriv (multiplier expr) var)
                         (multiplicand expr))))
        (true
         (println "Espressione sconosciuta:" expr))))

Questa procedura "deriv" incorpora l'algoritmo di differenziazione completo. Poiché è espresso in termini di dati astratti, funzionerà indipendentemente da come scegliamo di rappresentare le  espressioni algebriche, purché progettiamo un insieme appropriato di selettori e costruttori. Questo è il problema che dobbiamo affrontare dopo.

Rappresentare espressioni algebriche
------------------------------------
Possiamo immaginare molti modi per utilizzare la struttura a lista per rappresentare espressioni algebriche. Ad esempio, potremmo usare elenchi di simboli che rispecchiano la solita notazione algebrica, rappresentando ax + b come lista (a * x + b). Tuttavia, una scelta particolarmente semplice è quella di utilizzare la stessa notazione di prefisso tra parentesi che Lisp usa per le combinazioni, ovvero, rappresentare ax + b come (+ (* a x) b). Quindi la nostra rappresentazione dei dati per il problema di differenziazione è la seguente:

Le variabili sono simboli. Sono identificati dal predicato primitivo "symbol?":

(define (variable? x) (symbol? x))

Due variabili sono uguali se i simboli che le rappresentano sono uguali:

(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (= v1 v2)))

Le somme e i prodotti sono costruiti come liste:

(define (make-sum a1 a2) (list '+ a1 a2))

(define (make-product m1 m2) (list '* m1 m2))

Le sotto-espressioni devono essere liste con più di 2 elementi:

(define (pair? x) (and (list? x) (> (length x) 2)))

Una somma è una lista il cui primo elemento è il simbolo +:

(define (sum? x)
  (and (pair? x) (= (car x) '+)))

L'addendo è il secondo elemento della lista somma:

(define (addend s) (cadr s))

Il secondo addendo (augend) è il terzo elemento della lista della somma:

(define (augend s) (caddr s))

Un prodotto è una lista il cui primo elemento è il simbolo *:

(define (product? x)
  (and (pair? x) (= (car x) '*)))

Il moltiplicatore è il secondo elemento della lista prodotto:

(define (multiplier p) (cadr p))

Il moltiplicando è il terzo elemento della lista prodotto:

(define (multiplicand p) (caddr p))

Quindi, dobbiamo solo combinarli con l'algoritmo definito da "deriv" per avere un programma di differenziazione simbolica funzionante. Vediamo alcuni esempi del suo comportamento:

(deriv '(+ x 3) 'x)
;-> (+ 1 0)

(deriv '(* x y) 'x)
;-> (+ (* x 0) (* 1 y))

(deriv '(* (* x y) (+ x 3)) 'x)
;-> (+ (* (* x y) (+ 1 0)) (* (+ (* x 0) (* 1 y)) (+ x 3)))
(+ (* (* x y) (+ 1 0))
   (* (+ (* x 0) (* 1 y))
      (+  x 3)))

Il programma produce risposte corrette. Tuttavia, non sono semplificati. È vero che:

 d(x*y)
-------- = x*0 + 1*y
   dx

ma vorremmo che il programma sapesse che x * 0 = 0, 1 * y = y e 0 + y = y. La risposta per il secondo esempio avrebbe dovuto essere semplicemente y. Come mostra il terzo esempio, questo diventa un problema serio quando le espressioni sono complesse.

La nostra difficoltà è molto simile a quella che abbiamo incontrato con l'implementazione dei numeri razionali: non abbiamo ridotto le risposte alla forma più semplice. Per ottenere la riduzione dei numeri razionali, abbiamo dovuto modificare solo i costruttori ei selettori dell'implementazione. Possiamo adottare una strategia simile anche qui. Non cambieremo affatto "deriv". Invece, cambieremo "make-sum" in modo che se entrambi gli addendi sono numeri, "make-sum" li sommerà e restituirà la loro somma. Inoltre, se uno degli addendi è 0, "make-sum" restituirà l'altro addendo.

(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (true (list '+ a1 a2))))

Questa funzione utilizza la procedura "=number?", che controlla se un'espressione è uguale a un dato numero:

(define (=number? expr num)
  (and (number? expr) (= expr num)))

Allo stesso modo, cambieremo il "make-product" per incorporare le regole che 0 volte qualsiasi cosa è 0 e 1 volte qualsiasi cosa è la cosa stessa:

(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (true (list '* m1 m2))))

Ecco come funziona questa versione sui nostri tre esempi:

(deriv '(+ x 3) 'x)
;-> 1
(deriv '(* x y) 'x)
;-> y
(deriv '(* (* x y) (+ x 3)) 'x)
;-> (+ (* x y) (* y (+ x 3)))

Sebbene questo sia un bel miglioramento, il terzo esempio mostra che c'è ancora molta strada da fare prima di ottenere un programma che metta le espressioni in una forma che potremmo concordare sia "più semplice". Il problema della semplificazione algebrica è complesso perché, tra le altre ragioni, una forma che può essere più semplice per uno scopo potrebbe non esserlo per un altro.

--------------
Esercizio 2.56
--------------
Mostra come estendere il differenziatore di base per gestire più tipi di espressioni. Ad esempio, implementa la regola di differenziazione:

 d(u^n)               du
-------- = n*u^(n-1)*----
   dx                 dx

aggiungendo una nuova clausola al programma "deriv" e definendo opportune procedure di "esponentiation?", "base", "exponent" e "make-exponentiation". (Puoi usare il simbolo ** per denotare l'elevazione a potenza). Costruisci nelle regole che qualsiasi cosa elevata alla potenza 0 è 1 e qualsiasi cosa elevata alla potenza 1 è la cosa stessa.

--------------
Soluzione 2.56
--------------
Iniziamo con la funzione "make-exponentiation". Come le implementazioni di "make-sum" e "make-product", vogliamo inserire alcune regole che riducano l'espressione alla sua forma più semplice. Per gli esponenti e le basi possiamo definire le seguenti riduzioni:

  Qualunque cosa elevata alla potenza di 0 è 1.
  Qualunque cosa elevata alla potenza di 1 è se stessa.
  0 elevato alla potenza di qualsiasi cosa è 0.
  1 elevato alla potenza di qualsiasi cosa è 1.

Se sia la base che l'esponente sono numeri, l'esponente può calcolare e restituire l'esponente.
In ogni altro caso, costruiamo semplicemente la rappresentazione della lista appropriata e la restituiamo. Questo ci dà la seguente implementazione:

(define (make-exponentiation base exponent)
  (cond ((=number? exponent 0) 1)
        ((=number? exponent 1) base)
        ((=number? base 0) 0)
        ((=number? base 1) 1)
        ((and (number? base) (number? exponent)) (pow base exponent))
        (true (list '** base exponent))))

Facciamo alcuni test:

(= 1 (make-exponentiation 1 24))
(= 16 (make-exponentiation 2 4))
(= '(** a 3) (make-exponentiation 'a 3))
(= '(** 5 b) (make-exponentiation 5 'b))
(= '(** a b) (make-exponentiation 'a 'b))
(= 'a (make-exponentiation 'a 1))
(= 1 (make-exponentiation 'a 0))
(= 4 (make-exponentiation 4 1))
(= 1 (make-exponentiation 4 0))
(= 0 (make-exponentiation 0 2))
(= 0 (make-exponentiation 0 'x))
(= 1 (make-exponentiation 0 0))
(= 1 (make-exponentiation 2 0))
(= 1 (make-exponentiation 'x 0))
(= 2 (make-exponentiation 2 1))
(= 1234 (make-exponentiation 1234 1))
(= 'x (make-exponentiation 'x 1))
(= 8 (make-exponentiation 2 3))
(= '(** x 3) (make-exponentiation 'x 3))

I selettori e i predicati seguono quindi lo stesso modello degli equivalenti per somme e prodotti.

Selettore per la base:

(define (base e) (cadr e))

Selettore per l'esponente:

(define (exponent e) (caddr e))

Predicato di esponenziazione:

(define (exponentiation? x)
  (and (pair? x) (= (car x) '**)))

Facciamo alcuni test:

(= 2 (base '(** 2 3)))
(= 'x (base '(** x 3)))
(= 3 (exponent '(** 2 3)))
(= 'x (exponent '(** 2 x)))
(= true (exponentiation? (list '** 'x 2)))
(= true (exponentiation? '(** x 2)))

Tutto quello che dobbiamo fare ora è estendere "deriv", aggiungendo una clausola che utilizza la funzione "exponentiation?" per verificare se l'espressione è o meno un esponenziale e, in tal caso, applica la regola di differenziazione:

(define (deriv expr var)
  (cond ((number? expr) 0)
        ((variable? expr)
         (if (same-variable? expr var) 1 0))
        ((sum? expr)
         (make-sum (deriv (addend expr) var)
                   (deriv (augend expr) var)))
        ((product? expr)
         (make-sum
           (make-product (multiplier expr)
                         (deriv (multiplicand expr) var))
           (make-product (deriv (multiplier expr) var)
                         (multiplicand expr))))
        ((exponentiation? expr)
         (make-product
           (make-product (exponent expr)
                         (make-exponentiation (base expr)
                                              (make-sum (exponent expr) -1)))
           (deriv (base expr) var)))
        (true
         (println "Espressione sconosciuta:" expr))))

(= 1 (deriv '(+ x 4) 'x))
(= 'y (deriv '(+ (* x y) 4) 'x))
(= '(* 2 x) (deriv '(** x 2) 'x))
(= '(+ (* 3 (* 2 x)) 1) (deriv '(+ (* 3 (** x 2)) x) 'x))

(deriv (make-exponentiation 'a 5) 'a)
;-> (* 5 (** a 4))
(deriv (make-exponentiation 'a 'b) 'a)
;-> (* b (** a (+ b -1)))
(deriv (make-exponentiation 'a (make-sum 'a 'b)) 'a)
;-> (* (+ a b) (** a (+ (+ a b) -1)))

--------------
Esercizio 2.57
--------------
Estendi il programma di differenziazione per gestire somme e prodotti di numeri arbitrari di (due o più) termini. Quindi l'ultimo esempio sopra potrebbe essere espresso come:

(deriv '(* x y (+ x 3)) 'x)

Prova a farlo modificando solo la rappresentazione di somme e prodotti, senza modificare affatto la procedura "deriv". Ad esempio, l'addendo di una somma sarebbe il primo termine e l'augendo sarebbe la somma del resto dei termini.

--------------
Soluzione 2.57
--------------
Prima soluzione
---------------
Per risolvere questo problema è necessario cambiare le funzioni "make-sum" e "make-product" in modo che restituiscano rispettivamente la somma o il prodotto degli elementi rimanenti nella lista. Per fare questo scriviamo anche due funzioni ausiliarie "make-sum-list" e "make-product-list".

 (define (make-sum-list l)
   (if (= (length l) 2)
       (list '+ (car l) (cadr l))
       (make-sum (car l) (make-sum-list (cdr l)))))

 (define (make-sum a1 a2)
   (cond ((=number? a1 0) a2)
         ((=number? a2 0) a1)
         ((and (number? a1) (number? a2)) (+ a1 a2))
         (true (make-sum-list (list a1 a2)))))

 (define (make-product-list l)
   (if (= (length l) 2)
       (list '* (car l) (cadr l))
       (make-product (car l) (make-product-list (cdr l)))))

 (define (make-product m1 m2)
   (cond ((or (=number? m1 0) (=number? m2 0)) 0)
         ((=number? m1 1) m2)
         ((=number? m2 1) m1)
         ((and (number? m1) (number? m2)) (* m1 m2))
         (true (make-product-list (list m1 m2)))))

 (define (augend s)
   (let ((a (cddr s)))
     (if (= (length a) 1)
         (car a)
         (make-sum-list a))))

 (define (multiplicand p)
   (let ((m (cddr p)))
     (if (= (length m) 1)
         (car m)
         (make-product-list m))))

 ;; tests
 (deriv '(* (* x y) (+ x 3)) 'x)
 ;; (+ (* x y) (* y (+ x 3)))

 (deriv '(* x y (+ x 3)) 'x)
 ;; (+ (* x y) (* y (+ x 3)))

Seconda soluzione
-----------------
Un'altra soluzione è cambiare le funzioni "augend" e "multiplicand" in modo che restituiscano rispettivamente la somma o il prodotto degli elementi rimanenti nella lista. Mentre le funzioni "make-sum" e "make-product" rimangono invariate.

(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (true (list '+ a1 a2))))

(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (true (list '* m1 m2))))

(define (augend s)
  (accumulate make-sum 0 (cddr s)))

(define (multiplicand p)
  (accumulate make-product 1 (cddr  p)))

(define (accumulate op initial seq)
  (if (null? seq)
      initial
      (op (car seq)
          (accumulate op initial (cdr seq)))))

(deriv '(* (* x y) (+ x 3)) 'x)
;-> (+ (* x y) (* y (+ x 3)))

(deriv '(* x y (+ x 3)) 'x)
;-> (+ (* x y) (* y (+ x 3)))

La funzione "accumulate" applica ricorsivamente la funzione make per sommare tutte le voci in lista.

 (accumulate make-sum 0 (cddr s))

È analogo a:

 (accumulate +  0 (cddr s))

per dati simbolici. Usiamo (cddr s)) per ottenere il resto della lista che inizia con il terzo elemento.

--------------
Esercizio 2.58
--------------
Supponiamo di voler modificare il programma di differenziazione in modo che funzioni con la notazione matematica ordinaria, in cui + e * sono operatori infissi piuttosto che prefissi. Poiché il programma di differenziazione è definito in termini di dati astratti, possiamo modificarlo per lavorare con diverse rappresentazioni di espressioni unicamente cambiando i predicati, i selettori e i costruttori che definiscono la rappresentazione delle espressioni algebriche su cui il differenziatore deve operare.

a. Mostra come farlo per differenziare le espressioni algebriche presentate in forma infissa, come (x + (3 * (x + (y + 2)))). Per semplificare l'attività, supponiamo che + e * prendano sempre due argomenti e che le espressioni siano completamente tra parentesi.

b. Il problema diventa sostanzialmente più difficile se permettiamo la notazione algebrica standard, come (x + 3 * (x + y + 2)), che elimina le parentesi non necessarie e presume che la moltiplicazione venga eseguita prima dell'addizione. Potete progettare predicati, selettori e costruttori appropriati per questa notazione in modo tale che il nostro programma derivato funzioni ancora?

--------------
Soluzione 2.58
--------------
Per risolvere questo problema possiamo usare la funzione "xlate" che converte le expressioni infisse o postfisse in espressioni prefisse (La funzione "xlate" si trova nel paragrafo "Parser di espressioni infisse-prefisse-postfisse"). Quindi non dobbiamo fare alcuna modifica al programma di differenziazione. Per finire riportiamo come è stato modificato il programma con le soluzioni 2.56 e 2.57.
;
(define car first)
(define cdr rest)
(define (caar x)   (first (first x)))
(define (cadr x)   (first (rest x)))
(define (cdar x)   (rest (first x)))
(define (cddr x)   (rest (rest x)))
(define (caddr x)  (first (rest (rest x))))
;
(define (deriv expr var)
  (cond ((number? expr) 0)
        ((variable? expr)
         (if (same-variable? expr var) 1 0))
        ((sum? expr)
         (make-sum (deriv (addend expr) var)
                   (deriv (augend expr) var)))
        ((product? expr)
         (make-sum
           (make-product (multiplier expr)
                         (deriv (multiplicand expr) var))
           (make-product (deriv (multiplier expr) var)
                         (multiplicand expr))))
        ((exponentiation? expr)
         (make-product
           (make-product (exponent expr)
                         (make-exponentiation (base expr)
                                              (make-sum (exponent expr) -1)))
           (deriv (base expr) var)))
        (true
         (println "Espressione sconosciuta:" expr))))
;
(define (variable? x) (symbol? x))
;
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (= v1 v2)))
;
(define (make-sum a1 a2) (list '+ a1 a2))
;
(define (make-product m1 m2) (list '* m1 m2))
;
(define (pair? x) (and (list? x) (> (length x) 2)))
;
(define (=number? expr num)
  (and (number? expr) (= expr num)))
;
(define (sum? x)
  (and (pair? x) (= (car x) '+)))
;
(define (addend s) (cadr s))
;
;(define (augend s) (caddr s))
;
(define (product? x)
  (and (pair? x) (= (car x) '*)))
;
(define (multiplier p) (cadr p))
;
;(define (multiplicand p) (caddr p))
;
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (true (list '+ a1 a2))))
;
(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (true (list '* m1 m2))))
;
(define (make-exponentiation base exponent)
  (cond ((=number? exponent 0) 1)
        ((=number? exponent 1) base)
        ((=number? base 0) 0)
        ((=number? base 1) 1)
        ((and (number? base) (number? exponent)) (pow base exponent))
        (true (list '** base exponent))))
;
(define (augend s)
  (accumulate make-sum 0 (cddr s)))
;
(define (multiplicand p)
  (accumulate make-product 1 (cddr  p)))
;
(define (accumulate op initial seq)
  (if (null? seq)
      initial
      (op (car seq)
          (accumulate op initial (cdr seq)))))

Facciamo alcune prove:

(deriv '(+ x 3) 'x)
;-> 1
(deriv '(* x y) 'x)
;-> y
(deriv '(* (* x y) (+ x 3)) 'x)
;-> (+ (* x y) (* y (+ x 3)))
(deriv '(* (* x y) (+ x 3)) 'x)
;-> (+ (* x y) (* y (+ x 3)))
(deriv '(* x y (+ x 3)) 'x)
;-> (+ (* x y) (* y (+ x 3)))


----------------
Media geotmetica
----------------

La media geometrica aritmetica di due numeri reali positivi viene calcolata prendendo ripetutamente metà della loro somma e la radice quadrata del loro prodotto fino a quando i due numeri convergono.
Ad esempio, la media geometrica aritmetica di 24 e 6 è 13.458171..., che viene calcolata come segue:

0  24                            6
1  15                           12
2  13.5                         13.416407864998738175455042
3  13.458203932499369089227521  13.458139030990984877207090
4  13.458171481745176983217305  13.458171481706053858316334
5  13.458171481725615420766820  13.458171481725615420766806

La media geometrica aritmetica è stata inventata da Lagrange ed è usata oggi per calcolare varie funzioni trascendentali perché converge molto rapidamente.

La media geotmetica ("geothmetic meandian" proposta da Randall Munroe) di qualsiasi insieme di numeri positivi viene calcolata iterando tre sequenze - la media aritmetica, la media geometrica e la mediana - finché non convergono.
Ad esempio, la media geotmetica dell'insieme (1,1,2,3,5) è 2.089..., che viene calcolata come segue:

1  2.4               1.97435048583482  2
2  2.124783495278273 2.116192460544808 2
3  2.080325318607694 2.07953681947958  2.116192460544808
4  2.092018199544028 2.091948604915222 2.080325318607694
5  2.088097374355648 2.08809013312096  2.091948604915222
6  2.08937870413061  2.089377914218487 2.088097374355648
7  2.088951330901582 2.088951243615992 2.089377914218487
8  2.089093496245353 2.089093486565328 2.088951330901582
9  2.089046104570754 2.08904610349584  2.089093486565328
10 2.089061898210641 2.08906189809123  2.089046104570754
11 2.089056633624209 2.089056633610941 2.08906189809123
12 2.089058388442127 2.089058388440653 2.089056633624209
13 2.08905780350233  2.089057803502165 2.089058388440653

Scrivere due funzioni per il calcolo della media geometrica aritmetica e della media geotmetica.

Media geometrica aritmetica
---------------------------

(define (media-geom-arit a b)
  (let ((eps 1e-10) (n1 0) (n2 0))
    (while (> (abs (sub a b)) eps)
      (setq n1 (div (add a b) 2))
      (setq n2 (sqrt (mul a b)))
      (setq a n1 b n2)
    )
    a))

(media-geom-arit 6 24)
;-> 13.45817148174518

Media geotmetica
----------------

(define (media-arit lst)
  (div (apply add lst) (length lst)))

(media-arit (sequence 1 10))
;-> 5.5

(define (media-geom lst)
  (pow (apply mul lst) (div 1 (length lst))))

(media-geom (sequence 1 10))
;-> 4.528728688116765

Per calcolare la mediana di n valori:
1) ordiniamo gli n valori in ordine crescente
2) se il numero n è dispari, la mediana corrisponde al valore centrale che ha posizione (n+1)/2.
3) se il numero n è pari, la mediana è la media aritmetica dei due valori delle posizioni (n/2) e ((n/2)+1)
Nota: gli indici dell'algoritmo iniziano da 1.

(define (mediana lst)
  (let (len (length lst))
    (sort lst)
    (if (odd? len)
        (lst (/ len 2))
        (div (add (lst (- (/ len 2) 1)) (lst (/ len 2))) 2))))

(setq a '(1.98 2.01 1.97 1.96 2.06))
(mediana '(1.98 2.01 1.97 1.96 2.06))
;-> 1.98

(setq b '(0 5 1 2 7 0 3 4 6 5))
(mediana '(0 5 1 2 7 0 3 4 6 5))
;-> 3.5

Verifichiamo le funzioni con i valori dell'esempio sopra (1 1 2 3 5):

(setq t '(1 1 2 3 5))
(media-arit t)
;-> 2.4
(media-geom t)
;-> 1.97435048583482
(mediana t)
;-> 2

Adesso scriviamo la funzione cha calcola la media geotmetica di n numeri positivi:

(define (media-geotmetica lst)
  (local (eps media-g media-a media-n)
    (setq eps 1e-6)
    (sort lst)
    (while (> (abs (sub (lst -1) (lst 0))) eps)
      (setq media-a (media-arit lst))
      (setq media-g (media-geom lst))
      (setq media-n (mediana lst))
      ;(println media-a { } media-g { } media-n)
      ;(read-line)
      (setq lst (sort (list media-a media-g media-n)))
    )
    (lst 0)))

(media-geotmetica '(1 1 2 3 5))
;-> 2.089057803502165


------------------------------------
Verificare l'esistenza di un simbolo
------------------------------------

Per verificare l'esistenza di un simbolo nella tavola dei simboli dobbiamo utilizzare la funzione "sym".
newLISP crea un simbolo "appena lo vede". Per verificare questo comportamento partiamo con una REPL nuova ed entriamo in un nuovo contesto (che non ha simboli):

(context 'demo)
;-> demo>

(symbols)
;-> ()

Se scriviamo un nome qualunque sulla REPL viene creato un simbolo:

test
;-> nil

Verifichiamo:

(symbols)
;-> (test)

La generazione del simbolo avviene anche quando l'espressione è errata:

(+ test x)
;-> ERR: value expected in function + : nil

Nota: quando si genera un errore newLISP ritorna al contesto principale MAIN.

Ritorniamo al contesto "demo" e vediamo i simboli:

(context 'demo)
(symbols)
;-> (test x)

Come si vede è stato creato il simbolo x.

Questo significa che newLISP crea/valuta gli argomenti di ogni funzione prima di applicare la funzione. Quindi, se volessimo sapere se un simbolo esiste nel contesto corrente non possiamo applicare una funzione qualunque (esempio "find") perchè crerebbe il simbolo prima di verificarne l'esistenza e qualunque argomento passato risulta esistente nel contesto:

(find 'a (symbols))
;-> 0
(symbols)
;-> (a test x)

Ma allora, come possiamo conoscere se un simbolo esiste in un determinato contesto?
Come abbiamo detto sopra, occorre utilizzare la funzione "sym". Per esempio se volessimo sapere se il simbolo "var" esiste possiamo scrivere:

(sym "var" demo nil)
;-> nil
(symbols)
;-> (d test x)

Il simbolo "var" non esiste nel contesto demo (e non viene neanche creato).

Proviamo con un simbolo esistente:

(sym "a" demo nil)
;-> a

Il problema è risolto. Comunque se volessimo scrive una funzione dobbiamo tenere conto dei seguenti comportamenti:

(symbols)
;-> (a test x)

Non possiamo passare un simbolo quotato "sym":

(sym 'b demo nil)
;-> b
(symbols)
;-> (a b test x)

Non possiamo passare un simbolo (che viene valutato):

(sym c demo nil)
;-> ERR: number or string expected in function sym : c

Quando la REPL genera un errore ritorna al contesto MAIN.

(context 'demo)
(symbols)
;-> (a b c test x)

Dobbiamo sempre passare la stringa del simbolo:

(sym "d" demo nil)
;-> nil

(sym "a" demo nil)
;-> a

Vediamo se possiamo passare un simbolo convertito in stringa:

(string a)
;-> nil
(string 'a)
;-> "a"
(sym (string 'a) demo nil)
;-> a
(symbols)
;-> (a b c test x)

Ma questo non funziona per i simboli che non esistono perchè (string 'd) genera il simbolo d prima di essere valutato da "sym".

(sym (string 'd) demo nil)
;-> d
(symbols)
;-> (a b c d test x)

Quindi dobbiamo sempre passare una stringa alla funzione "sym".

Scriviamo una funzione:

(define (simbolo? simbolo contesto)
    (sym simbolo (context) nil))

(symbols)
;-> (a b c contesto d simbolo simbolo? test x)

(simbolo? "a")
;-> a
(simbolo? "e")
;-> nil
(symbols)
;-> (a b c contesto d simbolo simbolo? test x)

Anche in questo caso non possiamo applicare "string" al simbolo:

(simbolo? (string 'k))
;-> k
(symbols)
;-> (a b c contesto d k simbolo simbolo? test x)

Però possiamo passare un simbolo (a) che viene valutato in una stringa ("m"):

(setq a "m")
(simbolo? a nil)
;-> nil
(symbols)
;-> (a b c contesto d k simbolo simbolo? test x)

(setq a "k")
(simbolo? a nil)
;-> k
(symbols)
;-> (a b c contesto d k simbolo simbolo? test x)

Per maggiori informazioni sui simboli vedere il paragrafo "Gestione dei simboli".


--------------
Primi troncati
--------------

Il numero 739 è primo. Se togliamo l'ultima cifra otteniamo 73, che è primo. Se togliamo l'ultima cifra otteniamo 7, che è primo.
Determinare tutti i numeri primi fino a 1000 milioni che hanno questa proprietà.

Funzione per calcolare i primi:

(define (primes-to num)
  (cond ((= num 1) '())
        ((= num 2) '(2))
        (true
         (let (lst '(2))
          (setq arr (array (+ num 1)))
          (for (x 3 num 2)
                (when (not (arr x))
                  (push x lst -1)
                  (for (y (* x x) num (* 2 x) (> y num))
                      (setf (arr y) true)))) lst))))

Funzione che prepara i dati:

(define (prepare-data num)
  (println "Calcolo numeri primi...")
  (setq primi (primes-to num))
  (println "Creazione coppie...")
  (setq coppie (map (fn(x) (list (string x) x)) primi))
  (println "Creazione hash-map delle coppie...")
  (new Tree 'phash)
  (phash coppie)
  (println "data ok."))

Funzione che calcola i primi con la proprietà definita:

(define (primi-troncati)
  ;ciclo per ogni primo...
  (dolist (p primi)
    ; tronca il numero primo
    (setq tronc (/ p 10))
    ; finchè il numero troncato ha almeno due cifre ed è primo...
    (while (and (> (length tronc) 1) (phash (string tronc)))
      ; tronca il numero
      (setq tronc (/ tronc 10))
    )
    ; se il numero troncato ha una cifra ed è primo,
    ; allora il numero primo originale verifica la condizione
    ; e viene stampato
    (if (and (= (length tronc) 1) (phash (string tronc))) (print p { }))
  ))

Proviamo con i primi fino a 1000:

(prepare-data 1000)
;-> Calcolo numeri primi...
;-> Creazione coppie...
;-> Creazione hash-map delle coppie...
;-> data ok.
(primi-troncati)
;-> 23 29 31 37 53 59 71 73 79 233 239 293 311
;-> 313 317 373 379 593 599 719 733 739 797

Proviamo con i primi fino a 100 milioni:

(prepare-data 1e8)
;-> "data-ok"
(primi-troncati)
;-> 23 29 31 37 53 59 71 73 79 233 239 293 311 313 317 373 379 593
;-> 599 719 733 739 797 2333 2339 2393 2399 2939 3119 3137 3733 3739
;-> 3793 3797 5939 7193 7331 7333 7393 23333 23339 23399 23993 29399
;-> 31193 31379 37337 37339 37397 59393 59399 71933 73331 73939 233993
;-> 239933 293999 373379 373393 593933 593993 719333 739391 739393
;-> 739397 739399 2339933 2399333 2939999 3733799 5939333 7393913
;-> 7393931 7393933 23399339 29399999 37337999 59393339 73939133


-------------------------
Contenimento del quadrato
-------------------------

Dato un quadrato K, prendiamo due punti casuali, A e B, all'interno del quadrato. Qual'è la probabilità che il quadrato di diagonale AB sia contenuto nel quadrato K?

Il risultato matematico vale 2/3 (0.66666...). Vediamo come è possibile verificarlo con una simulazione.

Per effettuare la simulazione dobbiamo risolvere il seguente problema geometrico: date le coordinate della diagonale di un quadrato (punti A e B), determinare le altre due coordinate del quadrato (punti C e D). La soluzione è la seguente:

  Calcolare il punto medio M di AB
  delta-x = coordX(A) - coordX(M)
  delta-y = coordY(A) - coordY(M)
  coordX(C) = coordX(M) + delta-y
  coordY(C) = coordY(M) - delta-x
  coordX(D) = coordX(M) - delta-y
  coordY(D) = coordY(M) + delta-x

Per capire meglio le formule, potete vedere una costruzione geometrica interattiva aprendo il file "quadrato.html" che si trova nella cartella "data" (è possibile muovere i punti A e B per vedere come cambia la costruzione).

Nota: senza perdere in generalità supponiamo che il quadrato K sia di coordinate (0,0), (0,1), (1,1) e (1,0). In questo modo i punti A e B sono contenuti tra 0 e 1.

Scrivamo la funzione di simulazione:

(define (interno? x)
  (and (>= x 0) (< x 1)))

(define (quadrato iter)
  (local (xa ya xb yb mx my delta-x delta-y dentro)
    (for (i 1 iter)
      (setq xa (random))
      (setq ya (random))
      (setq xb (random))
      (setq yb (random))
      (setq mx (div (add xa xb) 2))
      (setq my (div (add ya yb) 2))
      (setq delta-x (sub xa mx))
      (setq delta-y (sub ya my))
      (setq xc (add mx delta-y))
      (setq yc (sub my delta-x))
      (setq xd (sub mx delta-y))
      (setq yd (add my delta-x))
      (if (and (interno? xc) (interno? yc) (interno? xd) (interno? yd))
          (++ dentro)
      )
    )
    (div dentro iter)))

Verifichiamo il risultato teorico:

(quadrato 1000)
;-> 0.644

Aumentiamo il numero di iterazioni della simulazione:

(quadrato 1e7)
;-> 0.6667395

=============================================================================

===============

 NOTE LIBERE 4

===============

------------------------
Una relazione tra π ed e
------------------------

Tra il numero pi greco (π = 3.1415926535897931) e il numero di Eulero (Nepero) (e = 2.7182818284590451) esiste la seguente relazione:

(π^4 + π^5)^(1/6) = 2.718281808611915 ≈ e = 2.7182818284590451

(setq e 2.7182818284590451)
(setq π 3.1415926535897931)
(setq x (pow (add (pow π 4) (pow π 5)) (div 6)))
;-> 2.718281808611915

Differenza tra il valore x e il numero di eulero "e":

(sub e x)
;-> 1.984713016156547e-008


--------------------------
Ricerca del numero diverso
--------------------------

Una lista contiene tutti numeri positivi uguali tranne uno. Determinare l'indice del numero diverso.

Le spiegazioni della seguente implementazione si trovano nei commenti.

(define (diverso1 lst)
(catch
  (local (a b ia ib na nb)
    ; ripetizioni del numero "a"
    (setq na -1)
    ; ripetizioni del numero "b"
    (setq nb 0)
    ; Il numero "a" è il primo elemento della lista
    (setq a (lst 0))
    ; Il numero "b" vale -1
    ; perchè non ancora assegnato
    (setq b -1)
    ; indice del numero "a"
    (setq ia 0)
    ; per ogni numero della lista...
    (dolist (el lst)
            ; se l'elemento corrente è uguale ad "a"...
      (cond ((= el a)
             ; allora aumento il numero delle ripetizioni di "a"
             (++ na))
            ; altrimenti
            (true
             ; se b=-1 allora assegno l'elemento corrente a "b"
             ; e l'indice corrente all'indice del numero b"
             (if (= b -1) (setq b el ib $idx))
             ; aumento il numero delle ripetizioni di "b"
             (++ nb))
      )
      ; se le ripetizioni di "a" sono maggiori di 1 e
      ; "b" non vale -1 (cioè "b" è stato trovato)
      ; allora restituisco l'indice di b
      (if (and (> na 1) (!= b -1)) (throw ib))
      ; se le ripetizioni di "b" sono maggiori di 1
      ; allora restituisco l'indice di a
      (if (> nb 1) (throw ia))
    ))))

Facciamo alcune prove:

(setq lst '(11 4 11 11 11 11))
(diverso1 lst)
;-> 1

(setq lst '(4 11 11 11 11 11))
(diverso1 lst)
;-> 0

(setq lst '(11 11 11 11 11 4))
(diverso1 lst)
;-> 5

(setq lst '(11 11 4 11 11 11))
(diverso1 lst)
;-> 2

Possiamo utilizzare anche altri metodi:

(define (diverso2 lst)
(catch
  (cond ((and (= (lst 0) (lst 1)) (!= (lst 0) (lst 2))) throw 2)
        ((and (= (lst 0) (lst 2)) (!= (lst 0) (lst 1))) throw 1)
        ((and (= (lst 1) (lst 2)) (!= (lst 0) (lst 1))) throw 0)
        (true
          (for (i 3 (- (length lst) 1))
            (if (!= (lst i) (lst (- i 1)))
                (throw i)
            )
          )
        )
  )))

Facciamo alcune prove:

(setq lst '(11 4 11 11 11 11))
(diverso2 lst)
;-> 1

(setq lst '(4 11 11 11 11 11))
(diverso2 lst)
;-> 0

(setq lst '(11 11 11 11 11 4))
(diverso2 lst)
;-> 5

(setq lst '(11 11 4 11 11 11))
(diverso2 lst)
;-> 2


--------------------------
Ricerca del numero singolo
--------------------------

In una lista di numeri interi positivi, un numero compare una sola volta, mentre gli altri numeri compaiono un numero pari di volte (2*k con k=1,2,3,...). Scrivere una funzione per trovare il numero singolo.

Possiamo usare la funzione "xor" che ha la seguente proprietà: (x xor x) = 0, lo "xor" con lo stesso numero produce 0. Infatti risulta:

(^ 5 5)
;-> 0
(^ 11 11)
;-> 0

Lo "xor" ha anche le seguenti proprietà:

  xor è commutativo: A xor B = B xor A
  xor è associativo: (A xor B) xor C = A xor (B xor C)
  xor con 0 non cambia il valore: A xor 0 = A
  xor lo stesso numero produce 0: A xor A = 0

Nota: Lo "xor" in newLISP si chiama "^".

Quindi applicando lo "xor" agli elementi della seguente lista:

(2 3 3 4 7 1 7 4 2)

possiamo scrivere:

(2 xor 2) xor (3 xor 3) xor (4 xor 4) xor (7 xor 7) xor 1 =
= (0 xor 0) xor (0 xor 0) xor 1 =
= (0 xor 0) xor 1 =
= 0 xor 1 = 1

Quindi la nostra funzione è molto semplice:

(define (singolo lst)
  (apply ^ lst))

(singolo '(2 3 3 4 7 1 7 4 2))
;-> 1

Nota: questa funzione è valida solo se un numero compare una sola volta, mentre gli altri numeri compaiono un numero pari di volte nella lista.

Se volessimo ottenere l'indice del numero singolo potremmo scrivere:

(define (singolo-index lst)
  (find (apply ^ lst) lst))

(singolo-index '(2 3 3 4 7 1 7 4 2))
;-> 5


-----------------------
Punti in un semicerchio
-----------------------

Scegliendo n punti a caso su una circonferenza, qual'è la probabilità che tutti i punti si trovino in un semicerchio?

Supponiamo che il punto "i" abbia angolo 0 (l'angolo è arbitrario in questo problema) - essenzialmente questo è l'evento in cui il punto "i" è il "primo" o "punto iniziale" nel semicerchio. Quindi vogliamo che tutti i punti siano nello stesso semicerchio, cioè che i punti rimanenti finiscano tutti nel semicerchio superiore.
Questo è come il lancio di moneta per ogni punto rimanente, quindi la probabilità che i restanti (n − 1) punti siano nel semicerchio in senso orario di un dato punto è pari a 1/2^(n−1). Ci sono n punti e l'evento che qualsiasi punto i sia il "punto iniziale" è disgiunto dall'evento che qualsiasi altro punto j sia il "punto iniziale" (ed esattamente uno di essi deve accadere affinché i punti si trovino a semicerchio), quindi la probabilità finale vale n/2^(n−1) (cioè possiamo semplicemente sommare la probabilità degli n eventi).

  P = n/2^(n−1)

Nota: se abbiamo 1 o 2 punti, la probabilità deve essere 1, il che è vero in entrambi i casi.

(define (semi n)
  (div n (pow 2 (- n 1))))

(semi 1)
;-> 1
(semi 2)
;-> 1
(semi 3)
;-> 0.75

Scriviamo una funzione che simula questo processo:

(define (simula n iter)
  (local (p diff conta)
    (setq p (array n '(0)))
    (setq conta 0)
    (for (i 1 iter)
      ; genera n punti/eventi random (0,1)
      (for (j 0 (- n 1))
        (setf (p j) (random))
      )
      (sort p)
      (setq k 0)
      (while (< k n)
        ; calcola distanza tra due punti
        (setq diff (sub (p k) (p (% (+ k 1) n))))
        ; verifica se i due punti si trovano
        ; nello stesso semicerchio (0, 0.5)
        (if (< diff 0) (inc diff))
        (if (< diff 0.5)
            (setq conta (+ conta 1) k n)
        )
        (++ k)
      )
    )
    (div conta iter)))

Proviamo la funzione:

(simula 1 10)
;-> 1
(simula 2 10)
;-> 1
(simula 3 1000)
;-> 0738
(simula 3 10000)
;-> 0.7473
(simula 3 1000000)
;-> 0.749872

Proviamo con 10 punti:

(semi 10)
;-> 0.01953125
(simula 10 1e6)
;-> 0.020556


-----------------------------
Coefficiente di Sorensen-Dice
-----------------------------

Il coefficiente Sorensen – Dice è una statistica utilizzata per misurare la somiglianza di due campioni ed è stato sviluppato indipendentemente da Dice nel 1945 e Sorensen nel 1948.
La formula originale di Sørensen doveva essere applicata a dati discreti. Dati due insiemi, X e Y, il coefficiente è definito come:

         2*|X ∩ Y|
  DSC = -----------
         |X| + |Y|

dove |X| e |Y| sono le cardinalità dei due liste (cioè il numero di elementi in ogni lista).
L'indice di Sorensen è uguale al doppio del numero di elementi comuni a entrambe le liste (intersezione) diviso per la somma del numero di elementi di ogni lista.

(define (sorensen lst1 lst2)
  (div (* 2 (length (intersect lst1 lst2)))
       (+ (length lst1) (length lst2))))

Due liste uguali producono un coefficiente pari a 1:

(setq lst1 '(1 2 3 4 5 6))
(setq lst2 '(1 2 3 4 5 6))
(sorensen lst1 lst2)
;-> 1

(sorensen (sequence 1 100) (sequence 100 199))
;-> 0.01
(sorensen (sequence 1 1000) (sequence 1000 1999))
;-> 0.001

Nota: il coefficiente non tiene conto della magnitude (valore) degli elementi.

Vediamo come varia il coefficiente al variare del numero di elementi distinti tra le due liste che hanno lo stesso numero di elementi:

(define (test-sorensen len)
  (local (lst1 lst2 fmt)
    (for (i 0 len)
      (setq lst1 (sequence 1 len))
      (setq lst2 (sequence (+ i 1) (+ len i)))
      (setq diversi (length (difference lst1 lst2)))
      (setq l1 (string (length (string lst1))))
      (setq l2 (string (length (string lst2))))
      (setq dd (string (+ 1 len (length (string lst1)) (- (length (string lst2))))))
      (println (format (string "%-" l1 "s " "%-" l2 "s " "%" dd "d %8.3f")
               (string lst1) (string lst2) diversi (sorensen lst1 lst2)))
    )))

(test-sorensen 5)
;-> (1 2 3 4 5) (1 2 3 4 5)      0    1.000
;-> (1 2 3 4 5) (2 3 4 5 6)      1    0.800
;-> (1 2 3 4 5) (3 4 5 6 7)      2    0.600
;-> (1 2 3 4 5) (4 5 6 7 8)      3    0.400
;-> (1 2 3 4 5) (5 6 7 8 9)      4    0.200
;-> (1 2 3 4 5) (6 7 8 9 10)     5    0.000

(test-sorensen 10)
;-> (1 2 3 4 5 6 7 8 9 10) (1 2 3 4 5 6 7 8 9 10)           0    1.000
;-> (1 2 3 4 5 6 7 8 9 10) (2 3 4 5 6 7 8 9 10 11)          1    0.900
;-> (1 2 3 4 5 6 7 8 9 10) (3 4 5 6 7 8 9 10 11 12)         2    0.800
;-> (1 2 3 4 5 6 7 8 9 10) (4 5 6 7 8 9 10 11 12 13)        3    0.700
;-> (1 2 3 4 5 6 7 8 9 10) (5 6 7 8 9 10 11 12 13 14)       4    0.600
;-> (1 2 3 4 5 6 7 8 9 10) (6 7 8 9 10 11 12 13 14 15)      5    0.500
;-> (1 2 3 4 5 6 7 8 9 10) (7 8 9 10 11 12 13 14 15 16)     6    0.400
;-> (1 2 3 4 5 6 7 8 9 10) (8 9 10 11 12 13 14 15 16 17)    7    0.300
;-> (1 2 3 4 5 6 7 8 9 10) (9 10 11 12 13 14 15 16 17 18)   8    0.200
;-> (1 2 3 4 5 6 7 8 9 10) (10 11 12 13 14 15 16 17 18 19)  9    0.100
;-> (1 2 3 4 5 6 7 8 9 10) (11 12 13 14 15 16 17 18 19 20) 10    0.000

Il coefficiente di Dice può essere utilizzato per misurare quanto siano simili due stringhe in termini di numero di bigrammi comuni (un bigramma è una coppia di lettere adiacenti nella stringa).
Il coefficiente per due stringhe x e y viene calcolato come segue:

        2*nt
  d = ---------
       nx + ny

dove: nt è il numero di bigrammi che si trovano in entrambe le stringhe,
      nx è il numero di bigrammi nella stringa x,
      ny è il numero di bigrammi nella stringa y.

Vediamo una semplice implementazione (non molto efficiente):

(define (bigrammi str)
  (let (lst-str (explode str))
    (map string (chop lst-str) (rest lst-str))))

(bigrammi "pippo")
;-> ("pi" "ip" "pp" "po")

(bigrammi "pappa")
;-> ("pa" "ap" "pp" "pa")

(define (sorensen-string str1 str2)
  (local (nx-lst ny-lst nt-lst)
    (setq bigram-x (bigrammi str1))
    (setq bigram-y (bigrammi str2))
    (setq nx (length bigram-x))
    (setq ny (length bigram-y))
    (setq nt (length (intersect bigram-x bigram-y)))
    (div (* 2 nt) (+ nx ny))))

Facciamo alcune prove:

(sorensen-string "pippo" "pappa")
;-> 0.25

(sorensen-string "gggg" "gg")
;-> 0.5

(sorensen-string "healed" "sealed")
;-> 0.8

(sorensen-string "algorithms are fun" "logarithms are not")
;-> 0.5882352941176471

(sorensen-string "Questa è una stringa" "e questa è un'altra stringa")
;-> 0.66666666666666

(sorensen-string "This is a string" "And this is another string")
;-> 0.55

Nota: questa implementazione tratta più occorrenze di un bigramma come uniche.
La correttezza di questo comportamento si nota quando si calcola il coefficiente per le stringhe "GG" e "GGGGGGGG", che ovviamente non deve essere 1.


----------------
Parole di Lyndon
----------------

Dato un intero n e una lista di caratteri S, generare tutte le parole di Lyndon di lunghezza n con i caratteri contenuti in S.

Una parola di Lyndon è una stringa che è strettamente inferiore a tutte le sue rotazioni in ordine lessicografico. Ad esempio, la stringa "012" è una parola di Lyndon poiché è inferiore alle rotazioni "120" e "201", ma "102" non è una parola di Lyndon in quanto è maggiore della sua rotazione "021".
Nota: "000" non è considerata una parola di Lyndon in quanto è uguale alla stringa ruotata.

Vediamo un paio di esempi:

Input: n = 2, S = ("0" "1" "2")
Output: "01" "02" "12"

Le altre possibili stringhe di lunghezza 2 sono "00", "11", "20", "21" e "22". Tutti queste sono maggiori o uguali a una delle loro rotazioni.

Input: n = 1, S = ("0" "1" "2")
Output: "0" "1" "2"

Esiste un algoritmo efficiente per generare parole di Lyndon (proposto da Jean-Pierre Duval) che può essere utilizzato per generare tutte le parole di Lyndon di lunghezza n con tempo proporzionale al numero di tali parole (vedi "Average cost of Duval’s algorithm for generating Lyndon words" di Berstel e Pocchiola)

L'algoritmo genera le parole di Lyndon in ordine lessicografico. Se w è una parola di Lyndon, la parola successiva si ottiene con i seguenti passaggi:

1) Ripetere w per formare una stringa v di lunghezza n, tale che v[i] = w[i mod |w|].
2) Affinchè l'ultimo carattere di v è l'ultimo nell'ordinamento di S, rimuoverlo.
3) Sostituire l'ultimo carattere di v con il suo successore nell'ordinamento di S.

Ad esempio, se n = 5, S = (a b c d) e w = "add", otteniamo v = "addad".
Poiché "d" è l'ultimo carattere nell'ordinamento ordinato di S, lo rimuoviamo per ottenere "adda" e quindi sostituire l'ultima "a" con il suo successore "b" per ottenere la parola di Lyndon "addb".

Vediamo una possibile implementazione:

(define (lyndon n str)
  (local (k w m out)
    (setq out '())
    (setq k (length str))
    (sort str)
    ; Lista per memorizzare gli indici dei caratteri
    (setq w '(-1))
    ; Ciclo finché w non è vuoto
    (while w
      ; Incrementa l'ultimo carattere
      (setf (w -1) (+ (w -1) 1))
      (setq m (length w))
      (if (= m n)
          ;(println (join (select str w)))
          (push (join (select str w)) out -1)
      )
      ; Ripete w per ottenere una stringa lunga n
      (while (< (length w) n)
        (push (w (- m)) w -1)
      )
      ; Rimuove l'ultimo carattere fintanto che è uguale al
      ; carattere più grande nella stringa
      (while (and w (= (w -1) (- k 1)))
        (setq w (chop w))
      )
    )
    out))

(lyndon 2 '("0" "1" "2"))
;-> ("01" "02" "12")

(lyndon 1 '("0" "1" "2"))
;-> ("0" "1" "2")

(lyndon 3 '("0" "1" "2"))
;-> ("001" "002" "011" "012" "021" "022" "112" "122")


-------------------------
Fattorizzazione di Lyndon
-------------------------

Una stringa è chiamata parola di Lyndon (o semplice), se è strettamente più piccola di uno qualsiasi dei suoi suffissi non banali. Esempi di stringhe semplici sono: a, b, ab, aab, abb, ababb, abcd. Si può dimostrare che una stringa è semplice, se e solo se è strettamente più piccola di tutte le sue rotazioni cicliche non banali.

Quindi, data stringa s la fattorizzazione di Lyndon della stringa s è una fattorizzazione s = w1w2… wk, dove tutte le stringhe wi sono semplici e sono in ordine non crescente w1≥w2≥ ... ≥w

Si può dimostrare che per ogni stringa tale fattorizzazione esiste ed è unica.

Algoritmo di Duval
------------------
L'algoritmo di Duval costruisce la fattorizzazione di Lyndon in tempo O (n) utilizzando la memoria aggiuntiva O (1).

Per prima cosa introduciamo un'altra nozione: una stringa t è chiamata pre-semplice, se ha la forma t = ww ... w (w), dove w è una stringa semplice e (w) è un prefisso di w (possibilmente vuoto). Anche una semplice stringa è pre-semplice.

L'algoritmo di Duval è greedy (avido). In qualsiasi momento durante la sua esecuzione, la stringa s sarà effettivamente divisa in tre stringhe s = s1s2s3, dove la fattorizzazione di Lyndon per s1 è già trovata e finalizzata, la stringa s2 è pre-semplice (e conosciamo la lunghezza della stringa semplice in esso), e s3 è completamente intatta. In ogni iterazione l'algoritmo Duval prende il primo carattere della stringa s3 e cerca di aggiungerlo alla stringa s2. Se s2 non è più pre-semplice, la fattorizzazione di Lyndon per una parte di s2 diventa nota e questa parte passa a s1.

Descriviamo l'algoritmo in modo più dettagliato. Il puntatore i punterà sempre all'inizio della stringa s2. Il ciclo esterno verrà eseguito fintanto che i < n. All'interno del ciclo utilizziamo due puntatori aggiuntivi, j che punta all'inizio di s3 e k che punta al carattere corrente che stiamo attualmente confrontando. Vogliamo aggiungere il carattere s[j] alla stringa s2, che richiede un confronto con il carattere s[k].
Possono esserci tre casi diversi:

  1) s[j] = s[k]: se è così, l'aggiunta del simbolo s[j] a s2 non viola la sua pre-semplicità. Quindi incrementiamo semplicemente i puntatori j e k.
  2) s[j] > s [k]: qui la stringa s2 + s[j] diventa semplice. Possiamo incrementare j e riportare k all'inizio di s2, in modo che il carattere successivo possa essere confrontato con l'inizio della parola semplice.
  3) s[j] < s[k]: la stringa s2 + s[j] non è più pre-semplice. Quindi divideremo la stringa pre-semplice s2 nelle sue stringhe semplici e il resto, possibilmente vuoto. La stringa semplice avrà la lunghezza j − k. Nella successiva iterazione si ricomincia con la restante s2.

Ecco una implementazione dell'algoritmo di Duval che restituisce la fattorizzazione di Lyndon di una stringa str:

(define (duval str)
  (local (len i j k out)
    (setq len (length str))
    (setq i 0)
    (setq out '())
    (while (< i len)
      (setq j (+ i 1))
      (setq k i)
      (while (and (< j len) (<= (str k) (str j)))
        (if (< (str k) (str j))
            (setq k i)
            (++ k)
        )
        (++ j)
      )
      (while (<= i k)
        (push (slice str i (- j k)) out -1)
        (setq i (+ i j (- k)))
      )
    )
    out))

(duval "345210012")
;-> ("345" "2" "1" "0012")

(duval "1821234")
;-> ("182" "1234")


----------------------
Rimozione dei multipli
----------------------

Dato un numero N e un insieme di numeri s = (s1 s2 ... sn} dove s1 < s2 < ... < sn < N, rimuovere tutti i multipli di (s1 s2 ... sn) dall'intervallo 1...N.
Per esempio, con n = 10 e lst = (2 4 5) si ottiene: (1 3 7 9).

È possibile risolverlo in tempo O(n*log(n)) e memoria extra O(n) usando qualcosa di simile al Crivello di Eratostene.

(define (delete-multiple n lst)
  (local (multipli out)
    (setq out '())
    (setq multipli (array (+ n 1) '(nil)))
    (dolist (el lst)
      (setq t el)
      (while (<= t n)
        (setf (multipli t) true)
        (setq t (+ t el))
      )
    )
    (for (i 1 n)
      (if (not (multipli i))
          (push i out -1)
      )
    )
    out))

(delete-multiple 10 '(2 4 5))
;-> (1 3 7 9)

(delete-multiple 100 '(2 3 4 5 6 7 8 9 10))
;-> (1 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)

Questa funzione utilizza O(n) di spazio per memorizzare la lista "multipli".

La complessità temporale è O(n*log(n)). Infatti, il ciclo while interno verrà eseguito N/s1 volte per il primo elemento in S, quindi N/s2 per il secondo e così via. Quindi dobbiamo stimare la grandezza di N/s1 + N/s2 + ... + N/sn.

  N/s1 + N/s2 + ... + N/sn =
= N * (1/s1 + 1/s2 + ... + 1/sn) <= N * (1/1 + 1/2 + .. . + 1/n).

L'ultima disuguaglianza è dovuta al fatto che s1 < s2 <... <sn, quindi il caso peggiore è quando assumono valori (1 2 ... n}.

Si può dimostrare che la serie armonica (1/1 + 1/2 + .. . + 1/n) è O(log(n)), quindi l'algoritmo è O(n*(log(n))).


-------------------
Rock Paper Scissors
-------------------

Rock paper scissors (noto anche come "morra cinese" è un gioco a mano giocato tra due persone, in cui ogni giocatore forma simultaneamente una delle tre forme con una mano tesa. Queste forme sono "rock/sasso" (un pugno chiuso), "paper/carta" (una mano piatta) e "scissors/forbici" (un pugno con l'indice e il medio estesi, formando una V). "scissors/forbici" è identico al segno V con due dita (che indica anche "vittoria" o "pace") tranne per il fatto che è puntato orizzontalmente invece di essere tenuto in posizione verticale in aria.

Si tratta di un gioco a somma zero ed ha solo due possibili esiti: un pareggio o una vittoria per un giocatore e una sconfitta per l'altro. Un giocatore che decide di giocare "rock" batterà un altro giocatore che ha scelto "scissors" ("il sasso schiaccia le forbici"), ma perderà contro chi ha giocato con "paper" ("la carta copre il sasso"). La forma "paper" perde contro le "forbici" ("le forbici tagliano la carta"). Se entrambi i giocatori scelgono la stessa forma, la partita è in parità. Il tipo di gioco ha avuto origine in Cina.

Questo gioco viene utilizzato anche come metodo di scelta equo tra due persone, simile al lancio di monete o al lancio di dadi. Tuttavia, a differenza dei metodi di selezione veramente casuali, il gioco Rock-Paper-Scissors può essere giocato con un certo grado di abilità riconoscendo e sfruttando il comportamento non casuale degli avversari.

Esistono diverse strategie di gioco (soprattutto per il computer), ma la casualità assoluta è il metodo migliore nel gioco tra umani (a meno che l'altro giocatore non sia estrememente prevedibile).

Scriviamo una funzione per giocare contro il computer:

(define (rps)
  (local (p1 p2 np1 np2 tot mosse link win)
    ; inizializza il generatore di numeri casuali
    (seed (time-of-day))
    ; mosse possibili
    (setq mosse '("R" "P" "S" "Q"))
    ; lista associativa
    (setq link '(("R" "Rock") ("P" "Paper") ("S" "Scissors")))
    (setq tot 0 np1 0 np2 0)
    (setq win "")
    (println "    ROCK, PAPER, SCISSORS")
    (println "-----------------------------")
    (println " - Type Q to quit the game - ")
    (println)
    ; ciclo continuo
    (while (!= win "end")
      (println "Turn: " (+ 1 tot))
      ; mossa del computer
      (setq p2 (first (select '("R" "P" "S") (rand 3))))
      ; mossa dell'utente
      (print "(R)ock, (P)aper, (S)cissors: ")
      (setq p1 (upper-case (read-line)))
      (while (not (find p1 mosse))
          (print "(R)ock, (P)aper, (S)cissors: ")
          (setq p1 (upper-case (read-line)))
      )
      ; aumenta il conto delle partite
      (++ tot)
      ; controllo vittoria
      (cond ((and (= p1 "R") (= p2 "R")) (setq win ""))
            ((and (= p1 "R") (= p2 "P")) (setq win "p2"))
            ((and (= p1 "R") (= p2 "S")) (setq win "p1"))
            ((and (= p1 "P") (= p2 "R")) (setq win "p1"))
            ((and (= p1 "P") (= p2 "P")) (setq win ""))
            ((and (= p1 "P") (= p2 "S")) (setq win "p2"))
            ((and (= p1 "S") (= p2 "R")) (setq win "p2"))
            ((and (= p1 "S") (= p2 "P")) (setq win "p1"))
            ((and (= p1 "S") (= p2 "S")) (setq win ""))
            ((= p1 "Q") (setq win "end"))
      )
      ; stampa risultato
      (cond ((= win "")
             (println (lookup p1 link) " vs " (lookup p2 link) ": Draw.")
             ( println "User: " np1 " - Computer: " np2))
            ((= win "p1")
             (++ np1)
             (println (lookup p1 link) " vs " (lookup p2 link) ": User wins.")
             (println "User: " np1 " - Computer: " np2))
            ((= win "p2")
             (++ np2)
             (println (lookup p1 link) " vs " (lookup p2 link) ": Computer wins.")
             (println "User: " np1 " - Computer: " np2))
            ((= win "end")
             (println "User: " np1 " - Computer: " np2)
             (println "End of game."))
      )
      (println)
    )))

Proviamo a fare una partita:

(rps)
;->     ROCK, PAPER, SCISSORS
;-> -----------------------------
;->  - Type Q to quit the game -
;->
;-> Turn: 1
;-> (R)ock, (P)aper, (S)cissors: w
;-> (R)ock, (P)aper, (S)cissors: w
;-> (R)ock, (P)aper, (S)cissors: 1
;-> (R)ock, (P)aper, (S)cissors: r
;-> Rock vs Scissors: User wins.
;-> User: 1 - Computer: 0
;->
;-> Turn: 2
;-> (R)ock, (P)aper, (S)cissors: p
;-> Paper vs Rock: User wins.
;-> User: 2 - Computer: 0
;->
;-> Turn: 3
;-> (R)ock, (P)aper, (S)cissors: s
;-> Scissors vs Scissors: Draw.
;-> User: 2 - Computer: 0
;->
;-> Turn: 4
;-> (R)ock, (P)aper, (S)cissors: q
;-> User: 2 - Computer: 0
;-> End of game.

Adesso simuliamo una partita di N turni tra due giocatori che fanno mosse casuali.

Prima di tutto scriviamo una funzione che restituisce il risultato di un turno:

(define (check-turn p1 p2)
  (cond ((and (= p1 "R") (= p2 "R")) 0)
        ((and (= p1 "R") (= p2 "P")) 2)
        ((and (= p1 "R") (= p2 "S")) 1)
        ((and (= p1 "P") (= p2 "R")) 1)
        ((and (= p1 "P") (= p2 "P")) 0)
        ((and (= p1 "P") (= p2 "S")) 2)
        ((and (= p1 "S") (= p2 "R")) 2)
        ((and (= p1 "S") (= p2 "P")) 1)
        ((and (= p1 "S") (= p2 "S")) 0)))

(check-turn "R" "R")
;-> 0
(check-turn "P" "R")
;-> 1
(check-turn "P" "S")
;-> 2

Poi scriviamo una funzione che genera una lista con un numero predefinito di mosse casuali:

(define (make-moves num)
  (select '("R" "P" "S") (rand 3 num)))

(make-moves 10)
;-> ("R" "S" "R" "S" "S" "S" "S" "P" "P" "R")

Infine scriviamo una funzione che gioca una partita con N turni:

(define (play-rps num)
  (local (lst1 lst2 turns result)
    (seed (time-of-day))
    (setq lst1 (select '("R" "P" "S") (rand 3 num)))
    (setq lst2 (select '("R" "P" "S") (rand 3 num)))
    (setq turns (map check-turn lst1 lst2))
    (setq result (count '(0 1 2) turns))
    (println "Draw: " (result 0))
    (println "Player1: " (result 1))
    (println "Player2: " (result 2))
    result))

Per esempio:

(setq lst1 '("P" "R" "S" "S" "P"))
(setq lst2 '("S" "R" "S" "R" "S"))

(play-rps 5)
;-> Draw: 2
;-> Player1: 0
;-> Player2: 3
;-> (2 0 3)

Simuliamo un paio di partite con 1 milione di turni:

(play-rps 1e6)
;-> Draw: 333509
;-> Player1: 333857
;-> Player2: 332634
;-> (333509 333857 332634)
(play-rps 1e6)
;-> Draw: 333756
;-> Player1: 332973
;-> Player2: 333271
;-> (333756 332973 333271)


----------------
TODO application
----------------

Una semplice applicazione TODO.

;-------------------------------------------------------------
;
; TODO
;
(define (todo file)
  (local (todo-filename todo-file todo-lines items funcs nitems)
    (println (format "\n%s\n%s\n%s\n" "============" "TODO Manager" "============"))
    ; voci del menu
    (setq items '("Elenco note" "Nuova nota" "Modifica nota" "Elimina nota" "Cerca... " "Ordina note" "Salva" "Esce"))
    ; funzioni del menu
    (setq funcs (list show-note new-note edit-note delete-note search-note sort-note save-note quit))
    ; numero di voci/funzioni del menu
    (setq nitems (length items))
    ; se il file non esiste, allora lo crea
    (if (not (file? file)) (close (open file "w")))
    ; nome del file di testo
    (setq todo-filename file)
    ; legge il file delle note
    ; (handle del file)
    (setq todo-file (read-file todo-filename))
    ; crea una lista con le linee del file
    (setq todo-lines (parse todo-file "\r\n"))
    ; elimina gli spazi (prima e dopo ogni linea)
    (setq todo-lines (map trim todo-lines))
    ; elimina le linee vuote
    (setq todo-lines (filter (fn(x) (not (empty? x))) todo-lines))
    ; mostra il menu
    (show-menu)))
;
; SHOW-MENU
;
(define (show-menu)
  (local (val num))
    ; visualizza le voci del menu
    (setq val nil)
    (println "MENU:")
    ; usa format %d (todo con più di 9 elementi)
    (dolist (el items) (println " " (+ $idx 1) ". " el))
    ; scelta della funzione...
    (while (not val)
      (print "Seleziona: ")
      (setq num (int (read-line) 0 10))
      (if (or (< num 1) (> num nitems))
          (println "Numero inesistente:" num)
          (setq val true)
      )
    )
    (println "")
    ; chiama la funzione selezionata
    ((funcs (- num 1))))
;
; RETURN-MENU
;
(define (return-menu)
  (println)
  (print "--- Premere Invio per tornare al menu ---")
  (read-line)
  (println "")
  (show-menu))
;
; SHOW-NOTE
;
(define (show-note)
  ; stampa tutte le linee
  (println "Elenco note:")
  (dolist (linea todo-lines)
    (println " - " linea)
  )
  (return-menu))
;
; NEW-NOTE
;
(define (new-note)
  (println "Nuova nota:")
  (print "> ")
  ; legge e inserisce la nuova nota nella lista
  (push (read-line) todo-lines -1)
  (println "Nota inserita.")
  (return-menu))
;
; EDIT-NOTE
;
(define (edit-note)
(catch
  (local (val num)
    (println "Modifica nota:")
    ; stampa tutte le note
    (dolist (linea todo-lines)
      (println (+ $idx 1) ": " linea)
    )
    ; input numero nota da eliminare
    (setq val nil)
    (while (not val)
      (print "Numero da modificare (-1 menu): ")
      (setq num (int (read-line) 0 10))
      ; esce dalla funzione senza nessuna modifica
      (cond ((= num -1) (throw (return-menu)))
            ((or (< num 1) (> num (length todo-lines)))
             (println "Numero errato:" num))
            (true
             (setq val true))
      )
    )
    ; stampa la nota selezionata
    ;(println "Nota in modifica:")
    ;(print (format "\n%s\r" (todo-lines (- num 1))))
    (println "Nota: " (todo-lines (- num 1)))
    (print "> ")
    ; legge e modifica la nota nella lista
    (replace (todo-lines (- num 1)) todo-lines (read-line))
    (println "Nota modificata.")
    (return-menu))))
;
; DELETE-NOTE
;
(define (delete-note)
(catch
  (local (val num)
    (println "Elimina nota:")
    ; stampa tutte le note
    (dolist (linea todo-lines)
      (println (+ $idx 1) ": " linea)
    )
    ; input numero nota da eliminare
    (setq val nil)
    (while (not val)
      (print "Numero da eliminare (-1 menu): ")
      (setq num (int (read-line) 0 10))
      ; esce dalla funzione senza nessuna modifica
      (cond ((= num -1) (throw (return-menu)))
            ((or (< num 1) (> num (length todo-lines)))
             (println "Numero errato:" num))
            (true
             (setq val true))
      )
    )
    ; elimina la nota dalla lista
    (println "Nota eliminata:")
    (println (pop todo-lines (- num 1)))
    (return-menu))))
;
; SEARCH-NOTE
;
(define (search-note)
  (local (str)
  (println "Cerca..."))
  (print "Testo da cercare: ")
  (setq str (read-line))
  (dolist (linea todo-lines)
    (if (find str linea) (println linea))
  )
  (return-menu))
;
; SORT-NOTE
;
(define (sort-note)
  (sort todo-lines)
  (println "Note ordinate.")
  (return-menu))
;
; SAVE-NOTE
;
(define (save-note)
  (local (text)
    ; crea testo con le linee
    (setq text "")
    (dolist (linee todo-lines)
      (extend text linee "\r\n")
    )
    ; salva il file
    (write-file todo-filename text)
    (println "Note salvate: " todo-filename)
    (return-menu)))
;
; QUIT
;
(define (quit)
  (local (text)
    ; crea testo con le linee
    (setq text "")
    (dolist (linee todo-lines)
      (extend text linee "\r\n")
    )
    ; salva il file
    (write-file todo-filename text)
    (println "Fine")))
;-------------------------------------------------------------
;eof

Vediamo come funziona:

(todo "todo-test.txt")
;-> ============
;-> TODO Manager
;-> ============
;->
;-> MENU:
;->  1. Elenco note
;->  2. Nuova nota
;->  3. Modifica nota
;->  4. Elimina nota
;->  5. Cerca...
;->  6. Ordina note
;->  7. Salva
;->  8. Esce
;-> Seleziona:

Per usare il programma possiamo salvarlo in un file (es. todo.lsp) e poi caricarlo con (load "todo.lsp").


---------------
Quine e Narciso
---------------

Un programma Quine non accetta input, ma produce in output una copia del proprio codice sorgente. Al contrario, Un "narcisista" (o programma Narciso) prende una stringa in input e produce in output "1" (true) se quella stringa corrisponde al proprio codice sorgente, oppure "0" (nil) se non corrisponde.

Un esempio di questo ultimo tipo di programma è il seguente:

(define (narciso) (and (= (slice (read-line) 18) (slice (string narciso) 11)) (= (slice (current-line) 0 18) "(define (narciso) ")))
;-> (lambda () (and (= (slice (read-line) 18) (slice (string narciso) 11)) (= (slice current-line 0 18) "(define (narciso) ")))

(narciso)
;(define (narciso) (and (= (slice (read-line) 18) (slice (string narciso) 11)) (= (slice (current-line) 0 18) "(define (narciso) ")))
;-> true

Come funziona?
La prima condizione: (= (slice (read-line) 18) (slice (string narciso) 11)) verifica che la stringa inserita corrisponda al corpo della funzione nella rappresentazione interna.
La seconda condizione: (= (slice (current-line) 0 18) "(define (narciso) ") verifica che i primi 18 caratteri della stringa inserita siano uguali a "(define (narciso) " (poichè nella rappresentazione interna la testa della funzione vale "(lambda () ").

In maniera analoga possiamo scrivere un programma Quine:

(define (quine) (print "(define (quine) ") (println (slice (string quine) 11)))
(quine)
;-> (define (quine) (print "(define (quine) ") (println (slice (string quine) 11)))


-----------------
Test di primalità
-----------------

In questo paragrafo vengono implementati gli algoritmi tratti dal libro "Primality Testing in Polynomial Time" di Martin Dietzfelbinger:

  - Algoritmo "Trial Division"
  - Algoritmo "Lehmann's Primality Test"
  - Algoritmo "Fast Modular Exponentiation"
  - Algoritmo "Perfect Power Test"
  - Algoritmo "Euclidean Algorithm"
  - Algoritmo "Extended Euclidean Algorithm"
  - Algoritmo "The Sieve of Eratosthenes"
  - Algoritmo "Fermat Test"

Funzioni ausiliarie
-------------------

"primo?" verifica se un numero è primo:

(define (primo? n)
   (if (< n 2) nil
       (= 1 (length (factor n)))))

"sign" assegna -1 oppure 0 oppure +1 in base al segno del numero:

(define (sign n)
  (cond ((> n 0) 1)
        ((< n 0) -1)
        (true 0)))

(sign -10)
;-> -1
(sign 3)
;-> 1
(sign 0)
;-> 0

"rand-int" genera un numero casuale intero x tale che 1 <= x <= n
(non funziona con i biginteger):

(define (rand-int n) (+ 1 (rand n)))

"rand-range" genera un numero casuale intero x tale che a <= n <= b:

(define (rand-range a b)
  (if (> a b) (swap a b))
  (+ a (rand (+ (- b a) 1)))
)

"powmod" calcola l'esponenziazione modulare veloce (b^e mod m):

(define (powmod b e m)
  (local (r)
    (cond ((= m 1) (setq r 0))
          (true
            (setq r 1L)
            (setq b (% b m))
            (while (> e 0)
              (if (= (% e 2) 1) (setq r (% (* r b) m)))
              (setq e (/ e 2))
              (setq b (% (* b b) m))
            )
          )
    )
    r))

(powmod 1024 313 42)
;-> 16L

"ipow" calcola la potenza di due numeri interi:

(define (ipow x n)
  (local (pot out)
    (if (zero? n)
        (setq out 1L)
        (begin
          (setq pot (ipow x (/ n 2)))
          (if (odd? n) (setq out (* x pot pot))
                       (setq out (* pot pot)))
        )
    )
    out))

(ipow -2 15)
;-> -32768
(ipow 11L 12L)
;-> 3138428376721L

"psetq" macro che permette l'assegnazione multipla:

(define-macro (psetq)
  (let ((_var '()) (_ex '()))
    (for (i 0 (- (length (args 1)) 1))
      (setq _ex (expand (args 1 i) (args 0 0)))
      (for (j 1 (- (length (args 0)) 1))
        (setq _ex (expand _ex (args 0 j)))
      )
      (push _ex _var -1)
    )
    (dolist (el _var)
      (set (args 0 $idx) (eval el))
    )))

(setq x 2 y 3)
(psetq (x y) ((+ 1 y) (+ 1 x)))
(list x y)
;-> (4 3)
---------------------------------------------------------------------

Algoritmi
---------

Algoritmo "Trial Division"
Input: integer n >= 2

(define (trial-div n)
  (catch
    (let (i 2L)
      (while (<= (* i i) n)
        (if (= zero? (% n i)) (throw nil))
        (++ i)
      )
      true)))

(trial-div 113)
;-> true

(= (map primo? (sequence 2 10000)) (map trial-div (sequence 2 10000)))
;-> true
---------------------------------------------------------------------

Algoritmo "Lehmann's Primality Test"
Input: odd integer n >= 3
       integer p >= 2

(define (lehmann n p)
  (catch
    (local (a b c)
      (if (= p nil) (setq p 20))
      (setq b (array (+ p 1) '(0)))
      (for (i 1 p)
        (setq a (rand-int (- n 1)))
        (setq c (powmod a (/ (- n 1) 2) n))
        (if (and (!= c 1) (!= c (- n 1)))
            (throw nil)
            (setq (b i) c)
        )
      )
      (for (i 1 p)
            (if (and (!= (b i) 1) (!= (b i) (- n 1)))
                (throw nil)
            )
      )
      true)))

(seed (time-of-day))

(lehmann 113)
;-> true

(= (map primo? (sequence 3 10001 2)) (map lehmann (sequence 3 10001 2)))
;-> true
---------------------------------------------------------------------

Algoritmo "Fast Modular Exponentiation"
Input: integer a, n e m >= 1

(define (fastmodexp a n m)
  (local (u s c)
    (setq u n)
    (setq s (% a m))
    (setq c 1L)
    (while (>= u 1)
      (if (odd? u) (setq c (% (* c s) m)))
      (setq s (* s (% s m)))
      (setq u (/ u 2))
    )
    c))

(fastmodexp 1024 313 42)
;-> 16L
(fastmodexp 1024 1024 77)
;-> 23L
(powmod 1024 1024 77)
;-> 23L
---------------------------------------------------------------------

Algoritmo "Perfect Power Test"
Input: integer n >= 2

(define (perfect-power-test n)
  (catch
    (local (a b c m)
      (setq b 2L)
      (while (<= (ipow 2L b) n)
        (setq a 1L)
        (setq c n)
        (while (>= (- c a) 2)
          (setq m (/ (+ a c) 2))
          ; "min" don't work with biginteger
          ;(setq p (min (ipow m b) (+ n 1)))
          (if (< (ipow m b) (+ n 1))
              (setq p (ipow m b))
              (setq p (+ n 1))
          )
          (if (= p n) (throw (list m b)))
          (if (< p n)
              (setq a m)
              (setq c m)
          )
        )
        (++ b)
      )
      nil)))

(perfect-power-test 2047)
;-> nil
(perfect-power-test 1024)
;-> (32L 2L)
(ipow 1194052296529L 2L)
;-> 1425760886846178945447841L
(perfect-power-test 1425760886846178945447841L)
;-> (1194052296529L 2L)
---------------------------------------------------------------------

Algoritmo "Euclidean Algorithm"
Input: integer n m

(define (euclidean n m)
  (local (a b ta tb)
    (setq n (abs n))
    (setq m (abs m))
    (if (>= n m)
        (setq a n b m)
        (setq a m b n)
    )
    (while (> b 0)
      ;(setq ta a)
      ;(setq tb b)
      ;(setq a tb)
      ;(setq b (% ta tb))
      (psetq (a b) (b (% a b)))
    )
    a))

(euclidean 4 31)
;-> 1
(euclidean 400 24)
;-> 8
(euclidean 400L 24L)
;-> 8L
---------------------------------------------------------------------

Algoritmo "Extended Euclidean Algorithm"
Input: integer n m

(define (extended-euclidean n m)
  (local (a b xa ya xb yb q)
    (if (> (abs n) (abs m))
        (begin (setq a (abs n))
               (setq b (abs m))
               (setq xa (sign n))
               (setq ya 0)
               (setq xb 0)
               (setq yb (sign m)))
        (begin (setq a (abs m))
               (setq b (abs n))
               (setq xa 0)
               (setq ya (sign m))
               (setq xb (sign n))
               (setq yb 0))
    )
    (while (> b 0)
      (setq q (/ a b))
      (psetq (a b) (b (- a (* q b))))
      (psetq (xa ya xb yb) (xb yb (- xa (* q xb)) (- ya (* q yb))))
    )
    (list a xa ya)
  )
)

(extended-euclidean 120 30)
;-> (30 0 1)
(extended-euclidean 120 23)
;-> (1 -9 47)
---------------------------------------------------------------------

Algoritmo "The Sieve of Eratosthenes"
Input: integer n >= 2

(define (eratosthenes n)
  (local (m i j)
    (setq m (array (+ n 1) '(0)))
    (setq j 2)
    (while (<= (* j j) n)
      (if (= (m j) 0)
        (begin (setq i (* j j))
               (while (<= i n)
                 (if (= (m i) 0) (setq (m i) j))
                 (setq i (+ i j))
               ))
      )
      (++ j)
    )
    (slice m 2 (- n 1))))

(eratosthenes 10)
;-> (0 0 2 0 2 0 2 3 2)
idx  2 3 4 5 6 7 8 9 10

Nota: i numeri primi sono gli indici per cui il valore vale 0 (il vettore parte dall'indice 2).
---------------------------------------------------------------------

Algoritmo "Fermat Test"
Input: odd integer n >= 3

(define (fermat-test n)
  (let (a (rand-range 2 (- n 2)))
    (if (!= (powmod a (- n 1) n) 1)
        nil
        true)))

(fermat-test 91)
;-> nil
(fermat-test 91)
;-> true ; output errato
(fermat-test 91)
;-> nil
(fermat-test 91)
;-> nil
(fermat-test 91)
;-> nil
---------------------------------------------------------------------

Algoritmo "Iterated Fermat Test"
Input: odd integer n >= 3
           integer p >= 1

(define (iterated-fermat-test n p)
  (catch
    (local (a)
      (if (= p nil) (setq p 20))
      (dotimes (x p)
        (setq a (rand-range 2 (- n 2)))
        (if (!= (powmod a (- n 1) n) 1)
            (throw nil))
      )
      true)))

(for (i 1 100000) (if (iterated-fermat-test 91 10) (println "error")))
;-> error
;-> error
;-> nil
(for (i 1 100000) (if (iterated-fermat-test 91 30) (println "error")))
;-> nil
---------------------------------------------------------------------

-----------------------------------
Passeggiata casuale lungo una linea
-----------------------------------

Supponiamo di avere un agente casuale che si muove lungo una linea (asse x) partendo dalla posizione 0. Ad ogni passo può spostarsi di un qualunque valore contenuto in una lista (es. (-1 +1)). Data una lista di posizioni, determinare (con una simulazione) dopo quanti passi l'agente si trova in quelle posizioni (positive o negative).
Per esempio,

Lista dei valori di un passo (testa o croce):
(setq passi '(-1 +1))

Lista delle posizioni:
(setq posizioni '(1000 2000 3000 4000 5000))

Scriviamo la funzione:

(define (random-walk steps positions)
  (local (x numsteps idx passo freq)
    ; inizializza il generatore di numeri casuali
    (seed (time-of-day))
    ; numero massimo dei passi
    (setq max-walks 1e8)
    ; posizione iniziale dell'agente
    (setq x 0)
    ; numero elementi della lista passi
    (setq numsteps (length steps))
    ; lista delle frequenze dei passi
    (setq freq (dup 0 numsteps))
    ; stampa intestazione
    (println "Passi        Posizione")
    ; ciclo fino a che la lista posizioni non è vuota
    ; oppure fino al nuimero massimo dei passi
    (for (i 1 max-walks 1 (empty? positions))
      ; seleziona indice del passo casuale
      (setq idx (rand numsteps))
      ; aggiorna la lista delle frequenze dei passi
      (++ (freq idx))
      ; seleziona valore del passo casuale
      (setq passo (steps idx))
      ; aggiorna posizione dell'agente
      (setq x (+ x passo))
      ; se siamo arrivati ad una posizione
      ; che si trova nella lista delle posizioni...
      ; (controlla anche il valore negativo)
      (if (find (abs x) positions)
          (begin
            ; stampa i risultati correnti
            (println (format "%-12d %-+10d" i x))
            ; elimina la posizione trovata dalla lista delle posizioni
            (pop positions (find (abs x) positions))
            ; stampa la percentuale delle frequenze dei passi
            (println (map (fn(x) (div x i)) freq))
          )))))

Nota: Il programma restituisce "true" se sono state trovate tutte le posizioni.

Facciamo alcune prove:

(setq passi '(-1 +1))
(setq posizioni '(1000 2000 3000 4000 5000))
(random-walk passi posizioni)
;-> Passi        Posizione
;-> 1960406      -1000
;-> (0.5002550492091944 0.4997449507908056)
;-> 5578618      +2000
;-> (0.4998207441341207 0.5001792558658793)
;-> 10919650     +3000
;-> (0.4998626329598476 0.5001373670401524)
;-> 21807322     +4000
;-> (0.4999082876842925 0.5000917123157076)
;-> 25400818     +5000
;-> (0.4999015779728039 0.5000984220271961)
;-> true

(setq passi '(-1 +1 -2 +2))
(setq posizioni '(3000 6000 9000))
(random-walk passi posizioni)
;-> Passi        Posizione
;-> 10998991     -3000
;-> (0.2497767295200078 0.2501136695175039 0.2502072235535059 0.2499023774089823)
;-> 14960430     -6000
;-> (0.2498848629350894 0.2501099901540263 0.2501591197579214 0.2498460271529629)
;-> 52664246     +9000
;-> (0.2498900487438859 0.2500522840486504 0.2500266689472778 0.2500309982601859)
;-> true

(setq passi '(-1 +1 -2 +2))
(setq posizioni '(100 200 500 1000 3000 5000 8000 10000 15000))
(random-walk passi posizioni)
;-> Passi        Posizione
;-> 3691         -100
;-> (0.2525060959089678 0.260633974532647 0.2522351666215118 0.2346247629368735)
;-> 5309         -200
;-> (0.2535317385571671 0.2569222075720475 0.2550386136748917 0.2345074401958938)
;-> 21737        -500
;-> (0.250126512398215 0.2463541427059852 0.2565671435800708 0.246952201315729)
;-> 382613       +1000
;-> (0.2497771900066124 0.2502946841848029 0.2494400347087004 0.2504880910998842)
;-> 10389970     -3000
;-> (0.2501266124926251 0.2501273824659744 0.2499453800155342 0.2498006250258663)
;-> 52122407     +5000
;-> (0.2501090749703865 0.2500241594752138 0.2498881718950547 0.249978593659345)
;-> 53204355     +8000
;-> (0.2501033608996858 0.2500143832210728 0.2498812926122307 0.2500009632670108)
;-> 59041077     +10000
;-> (0.250097910646176 0.2500267398577434 0.2498775386499132 0.2499978108461673)
;-> 65311093     +15000
;-> (0.2500656052410576 0.2500676569598981 0.2498764643243683 0.249990273474676)
;-> true


--------------------------------------
Serie di teste e croci (valore atteso)
--------------------------------------

In media (valore atteso), quante volte dobbiamo lanciare una moneta per ottenere una serie consecutiva di N risultati uguali (N teste consecutive oppure N croci consecutive)?

L'aspettativa matematica è un concetto importante nella teoria della probabilità. Matematicamente, per una variabile discreta X con funzione di probabilità P (X), il "valore atteso" E[X] è dato da Σ(xi * P(xi)) la somma ricorre su tutti i valori distinti xi che la variabile può assumere. Ad esempio, per un esperimento di lancio di dadi, l'insieme di risultati discreti è (1 2 3 4 5 6) e ciascuno di questo risultato ha la stessa probabilità 1/6. Quindi, il valore atteso di questo esperimento sarà 1/6 * (1 + 2 + 3 + 4 + 5 + 6) = 21/6 = 3.5. Per una variabile continua X con funzione di densità di probabilità P(x), il valore atteso E[X] è dato da ∫x*P(x)dx.

È importante capire che "valore atteso" non è uguale a "valore più probabile" - piuttosto, non è nemmeno necessario che sia uno dei valori probabili. Ad esempio, in un esperimento di lancio di dadi, il valore atteso, vale a dire 3.5, non è affatto uno dei possibili risultati.

La regola della "linearità dell'aspettativa" dice che E[x1+x2] = E[x1] + E[x2].

Prima di applicare la teoria al nostro caso, vediamo un problema più semplice: qual'è il numero previsto di lanci di monete per ottenere due teste consecutive?

Sia x il numero atteso di lanci di monete. L'analisi del caso procede come segue:
a. Se il primo lancio è croce, allora abbiamo sprecato un lancio. La probabilità di questo evento è 1/2 e il numero totale di lanci richiesti è x + 1
b. Se il primo lancio è testa e il secondo è croce, allora abbiamo sprecato due lanci. La probabilità di questo evento è 1/4 e il numero totale di lanci richiesti è x + 2
c. Se il primo lancio è testa e anche il secondo è testa, allora abbiamo finito. La probabilità di questo evento è 1/4 e il numero totale di lanci richiesti è 2.

Sommando tutti i termini, l'equazione che otteniamo è:

x = (1/2)*(x+1) + (1/4)*(x+2) + (1/4)*2 = 6

Pertanto, il numero previsto di lanci di monete (valore atteso) per ottenere due teste consecutive è 6.

Generalizzando: qual'è il numero previsto di lanci di monete per ottenere N teste consecutive, dato N?

Sia x il numero previsto di lanci di monete. Sulla base degli esercizi precedenti, possiamo concludere l'intera analisi del caso in due parti fondamentali:

a) Se otteniamo la prima, la seconda, la terza, ..., l'ennesima croce come prima croce nell'esperimento, allora dobbiamo ricominciare tutto da capo.
b) Altrimenti abbiamo finito.

Per il 1° lancio come croce, la parte dell'equazione è (1/2)*(x + 1)
Per il 2° lancio come croce, la parte dell'equazione è (1/4)*(x + 2)
...
Per il k-esimo lancio come croce, la parte dell'equazione è (1/(2^k))*(x + k)
...
Per l'ennesima croce, la parte dell'equazione è (1/(2^N))*(x + N)

La parte dell'equazione che corrisponde al caso (b) è (1/(2^N))*(N)

Sommando i termini:

x = (1/2)*(x+1) + (1/4)*(x+2) + ... + (1/(2^k))*(x+k) + .. + (1/(2^N))*(x+N) + (1/(2^N))*(N)

Risolvendo l'equazione si ottiene:

x = 2^(N+1) - 2 = 2*(2^n -1)

Poichè il nostro problema originale considera anche la probabilità di ottenere N croci consecutive (oltre a N teste consecutive), il valore atteso vale la metà del risultato precedente:

x = (2^n -1)

(define (atteso num) (- (pow 2 num) 1))

Scriviamo una funzione che simula questo processo:

(define (serie num iter)
  (local (conta num-lanci tot-lanci prec lancio found delta)
    ;numero totale dei lanci
    (setq tot-lanci 0)
    ; scostamento massimo: numero massimo di lanci
    ; per ottenere 5 valori consecutivi uguali
    (setq delta 0)
    (for (i 1 iter)
      ; azzera la lista contatore
      (setq conta '(0 0))
      ; primo lancio (0=croce, 1=testa)
      (setq prec (rand 2))
      (setq numlanci 1)
      ; mostra lancio
      ;(print prec)
      ; aggiorna la lista contatore
      (++ (conta prec))
      (setq found nil)
      ; cerca la serie consecutiva di num teste o croci
      (until found
        ; lancio moneta
        (setq lancio (rand 2))
        ; mostra lancio
        ;(print lancio)
        (++ numlanci)
        ; se il lancio attuale è uguale al precedente
        (cond ((= lancio prec)
               ; aggiorna la lista contatore
               (++ (conta prec)))
              ; altrimenti
              (true ; il lancio attuale è diverso dal precedente
               ; azzera il contatore
               (setq conta '(0 0))
               ; aggiorna il valore del lancio precedente
               (setq prec lancio)
               ; aggiorna la lista contatore
               (++ (conta prec)))
        )
        ; se abbiamo raggiunto num ripetizioni
        ; consecutive di croci o teste
        ; N teste oppure N croci
        (if (or (= (conta 0) num) (= (conta 1) num))
        ; N teste
        ;(if (= (conta 0) num)
            (begin
            (setq found true)
            ; aggiorna il numero totale dei lanci
            (setq tot-lanci (+ tot-lanci numlanci))
            ; aggiorna scostamento massimo
            (setq delta (max delta numlanci))
            ; mostra risultati intermedi
            ;(println)
            ;(println conta { } numlanci)
            ;(read-line)
            )
        )
      )
    )
    ; stampa lo scostamento massimo, cioè il massimo numero di lanci
    ; che è sato necessario per ottenere N eventi consecutivi uguali
    (println "Max lanci: " delta)
    (div tot-lanci iter)
  )
)

Proviamo la funzione di simulazione:

(serie 5 100000)
;-> Max lanci: 305
;-> 31.04894

Vediamo il valore matematico:
(atteso 5)
;-> 31

(serie 8 100000)
;-> Max lanci: 3354
;-> 254.9056
(atteso 8)
;-> 255

La simulazione conferma il risultato matematico.


--------------------------------------
Ricerca con caratteri jolly (wildcard)
--------------------------------------

Dato un testo e un modello (pattern) di caratteri jolly (wildcard), implementare l'algoritmo di corrispondenza del modello di caratteri jolly che rileva se il modello di caratteri jolly è abbinato al testo. La corrispondenza dovrebbe coprire l'intero testo (non il testo parziale).
Il motivo jolly può includere i caratteri "?" e "*":

"?" - corrisponde a qualsiasi singolo carattere

"*": Corrisponde a qualsiasi sequenza di caratteri (inclusa la sequenza vuota)

Per esempio,

Testo = "abbaino",
Modello = "*ba*ino" , output : true
Modello = "ab*?"    , output : true
Modello = "ba*a?"   , output : false
Modello = "abba?no" , output : true
Modello = "abba?o"  , output : false

Ogni occorrenza del carattere "?" nel modello di caratteri jolly può essere sostituito con qualsiasi altro carattere e ogni occorrenza di "*" con una sequenza di caratteri tale che il modello di caratteri jolly diventa identico alla stringa di input dopo la sostituzione.

Consideriamo qualsiasi carattere nel modello:

Caso 1: il carattere è "*"
Qui sorgono due sottocasi:
1) Possiamo ignorare il carattere "*" e passare al carattere successivo nel modello.
2) Il carattere "*" corrisponde a uno o più caratteri nel testo. Qui ci sposteremo al carattere successivo nel Testo.

Caso 2: il carattere è "?"
Possiamo ignorare il carattere corrente nel testo e passare al carattere successivo nel modello e nel Testo.

Caso 3: il carattere non è un carattere jolly
Se il carattere corrente in Testo corrisponde al carattere corrente in modello, ci spostiamo al carattere successivo in modello e in Testo.
Se non corrispondono, il motivo jolly e il testo non corrispondono.

Possiamo usare la programmazione dinamica per risolvere questo problema.

Sia DP[i][j] true se i primi i caratteri nel Testo dato corrispondono ai primi j caratteri del modello.

Inizializzazione della matrice DP:

; sia il Testo che il modello sono nil
DP[0][0] = true;

; il modello è nil
DP[i][0] = nil

; il Testo è nil
DP[0][j] = DP[0][j - 1] se modello[j – 1] è '*'

Relazione DP:

Se i caratteri correnti corrispondono, il risultato è lo stesso di risultato per le lunghezze meno uno.
I caratteri corrispondono in due casi:
a) Se il carattere del modello è "?" quindi corrisponde con qualsiasi carattere di testo.
b) Se i caratteri correnti nel modello e nel Testo corrispondono
if (modello[j – 1] == "?") || (modello[j – 1] == text[i - 1])
   DP[i][j] = DP[i-1][j-1]

Se incontriamo "*", sono possibili due scelte:
a) Ignoriamo il carattere "*" e passiamo al successivo
    carattere nel modello, ad esempio "*" indica una sequenza vuota.
b) Il carattere '*' corrisponde all'i-esimo carattere in ingresso
else if (modello[j – 1] == "*")
        DP[i][j] = DP[i][j-1] || DP[i-1][j]
else if (modello[j – 1] != text[i - 1])
        DP[i][j] = nil

Adesso possiamo scrivere la funzione:

(define (match? str modello)
  (local (n m dp)
    (setq n (length str))
    (setq m (length modello))
    ; matrice di lookup
    (setq dp (array (+ n 1) (+ m 1) '(nil)))
    ; un modello vuoto si abbina con la stringa vuota
    (setf (dp 0 0) true)
    ; solo "*" si abbina con la stringa vuota
    (for (j 1 m)
      (if (= (modello (- j 1)) "*")
          (setf (dp 0 j) (dp 0 (- j 1)))
      )
    )
    ; riempie la matrice in modo bottom-up
    (for (i 1 n)
      (for (j 1 m)
        (cond ((= (modello (- j 1)) "*")
               ; Due casi se vediamo un '*':
               ; a) Ignoriamo il carattere '*' 'e ci muoviamo
               ; al carattere successivo nel pattern,
               ; ad esempio, "*" indica una sequenza vuota
               ; b) Il carattere "*" si abbina con l'i-esimo
               ; carattere in input
               (setf (dp i j) (or (dp i (- j 1)) (dp (- i 1) j))))
              ((or (= (modello (- j 1)) "?") (= (modello (- j 1)) (str (- i 1))))
               ; I caratteri correnti sono considerati come
               ; abbinati in due casi:
               ; (a) il carattere corrente del pattern è "?"
               ; (b) i caratteri corrispondono effettivamente
               (setf (dp i j) (dp (- i 1) (- j 1))))
              (true
               ; i caratteri non si abbinano
               (setf (dp i j) nil))
        )
      )
    )
    (dp n m)))

Facciamo alcune prove:

(match? "baaabab" "*b???b*")
;-> true
(match? "abbaino" "*ba*ino")
;-> true
(match? "abbaino" "ab*?"   )
;-> true
(match? "abbaino" "ba*a?"  )
;-> nil
(match? "abbaino" "abba?no")
;-> true
(match? "abbaino" "abba?o" )
;-> nil


-------------------------
Funzioni logiche booleane
-------------------------

newLISP mette a disposizione tre funzioni "and", "or" e "not" per l'algebra booleana (AND, OR e NOT). Con queste funzioni possiamo creare tutte le altre funzioni necessarie (es. NAND, XOR, NOR, ecc.). Per esempio:

Funzione NAND
(define (nand a b) (not (and a b)))

Funzione NOR
(define (nor a b) (not (or a b)))

Funzione XOR
(define (xor a b) (if (nand a b) (or a b) nil))

Funzione XNOR
(define (xnor a b) (not (xor a b)))

Per ragioni di efficienza abbiamo utilizzato la funzione "nand" per definire "xor" e la funzione "xor" per definire "xnor", cioè abbiamo usato questo insieme di connettivi logici (not and or nand xor) per definire le funzioni che producono tutte le possibili tabelle di verità con due valori di ingresso (a b).

Completezza funzionale
----------------------
In logica, un insieme funzionalmente completo di connettivi logici o operatori booleani è quello che può essere utilizzato per esprimere tutte le possibili tabelle di verità combinando i membri dell'insieme in un'espressione booleana. Un noto insieme completo di connettivi è (AND NOT), oppure (OR NOT). Anche ciascuno degli insiemi singleton (NAND) e (NOR) è funzionalmente completo.
Questo vuol dire che l'insieme di operatori logici scelto è sufficiente per "esprimere tutte le possibili tabelle di verità". L'insieme di tutte le tabelle di verità indica tutti i possibili insiemi di 4 valori booleani che possono essere il risultato di un'operazione tra 2 valori booleani. Poiché ci sono 2 possibili valori per un booleano, ci sono 2^4 o 16 possibili tabelle di verità.

A B | 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
----+------------------------------------------------
T T | T  T  T  T  T  T  T  T  F  F  F  F  F  F  F  F
T F | T  T  T  T  F  F  F  F  T  T  T  T  F  F  F  F
F T | T  T  F  F  T  T  F  F  T  T  F  F  T  T  F  F
F F | T  F  T  F  T  F  T  F  T  F  T  F  T  F  T  F

Prendendo come esempio l'insieme (OR NOT), ecco una tabella di verità per i numeri (0-15) con la combinazione di OR e NOT che la producono e una descrizione.

Tabella |  Operazione                         | Descrizione
--------+----------------------------------+-------------
  0     | A or not A                          | TRUE
  1     | A or B                              | OR
  2     | A or not B                          | B IMPLICA A
  3     | A                                   | A
  4     | not A or B                          | A IMPLICA B
  5     | B                                   | B
  6     | not(not A or not B) or not(A or B)  | XNOR (equals)
  7     | not(not A or not B)                 | AND
  8     | not A or not B                      | NAND
  9     | not(A or not B) or not(not A or B)  | XOR
 10     | not B                               | NOT B
 11     | not(not A or B)                     | NOT A IMPLICA B
 12     | not A                               | NOT A
 13     | not(A or not B)                     | NOT B IMPLICA A
 14     | not(A or B)                         | NOR
 15     | not(A or not A)                     | FALSE

Nota: in elettronica si preferisce utilizzare la porta NAND perchè fa due cose (la porta AND solo una). Una porta NAND è una porta AND seguita da una porta NOT. Quell'inversione "extra" (in realtà è gratuita nella maggior parte delle implementazioni di circuiti) la rende molto più versatile di una semplice AND. Possiamo creare tutte le altre funzioni logiche usando solo la porta NAND grazie al Teorema di DeMorgan, quindi in pratica è tutto ciò di cui abbiamo bisogno.


----------------
Tavole di verità
----------------

Scrivere una funzione che prende un'espressione logica in ingresso e restituisce la tavola di verità dell'espressione. Gli operatori logici consentiti sono "and", "or" e "not".

Utilizziamo la funzione "xlate" che converte una espressione infissa in una espressione prefissa aggiungendo le seguenti funzioni logiche:

; Funzione NAND
(define (nand a b) (not (and a b)))
; Funzione NOR
(define (nor a b) (not (or a b)))
; Funzione XOR
(define (xor a b) (if (nand a b) (or a b) nil))
; Funzione XNOR
(define (xnor a b) (not (xor a b)))

Funzione "xlate"

; Main function
(define (xlate str)
(local (result operators)
  (if (catch (infix-xlate str) 'result)
    result                      ; if starts with ERR: is error else result
    (append "ERR: " result))))  ; newLISP error has occurred
; Auxiliary function
(define (infix-xlate str)
(local (tokens varstack opstack expression ops op nops var vars)
; operator priority table
; (token operator arg-count priority)
  (set 'operators '(
    ("=" setq 2 2)
    ("+" add 2 3)
    ("-" sub 2 3)
    ("*" mul 2 4)
    ("/" div 2 4)
    ("^" pow 2 5)
    ("abs" abs 1 9)
    ("acos" acos 1 9)
    ("asin" asin 1 9)
    ("atan" atan 1 9)
    ("sin" sin 1 9)
    ("sqrt" sqrt 1 9)
    ("tan" tan 1 9)
    ("cos" cos 1 9)
    ; added
    ("not" not 1 9)
    ("and" and 2 9)
    ("or" or 2 9)
    ("nand" nand 2 9)
    ("nor" nor 2 9)
    ("xor" xor 2 9)
    ("xnor" xnor 2 9)
  ; add what else is needed
  ))
  (set 'tokens (parse str))
  (set 'varstack '())
  (set 'opstack '())
  (dolist (tkn tokens)
  (case tkn
        ("(" (push tkn opstack))
        (")" (close-parenthesis))
        (true (if (assoc tkn operators)
                  (process-op tkn)
                  (push tkn varstack)))))
  (while (not (empty? opstack))
        (make-expression))
  (set 'result (first varstack))
  (if (or (> (length varstack) 1) (not (list? result)))
    (throw "ERR: wrong syntax")
    result)))
; pop all operators and make expressions
; until an open parenthesis is found
(define (close-parenthesis)
 (while (not (= (first opstack) "("))
    (make-expression))
 (pop opstack))
; pop all operator, which have higher/equal priority
; and make expressions
(define (process-op tkn)
  (while (and opstack
              (<= (lookup tkn operators 3) (lookup (first opstack) operators 3)))
        (make-expression))
  (push tkn opstack))
; pops an operator from the opstack and makes/returns an
; newLISP expression
(define (make-expression)
  (set 'expression '())
  (if (empty? opstack)
        (throw "ERR: missing parenthesis"))
  (set 'ops (pop opstack))
  (set 'op (lookup ops operators 1))
  (set 'nops (lookup ops operators 2))
  (dotimes (n nops)
    (if (empty? varstack) (throw (append "ERR: missing argument for " ops)))
    (set 'vars (pop varstack))
    (if (atom? vars)
            (if (not (or (set 'var (float vars))
                         (and (legal? vars) (set 'var (sym vars))) ))
                (throw (append vars "ERR: is not a variable"))
                (push var expression))
            (push vars expression)))
  (push op expression)
  (push expression varstack))

(xlate "((a and b) or (c and (d or e)))")
;-> (or (and a b) (and c (or d e)))

(setq a nil b nil c true d nil e true)
(eval (xlate "((a and b) or (c and (d or e)))"))
;-> true

(eval (xlate "(a nand b) or (c and e)"))
;-> true

Poi scriviamo una funzione che genera la tabella dei valori da assegnare alle variabili:

(define (make-values num-vars)
  (setq len num-vars)
  (setq num (pow 2 len))
  (setq out '())
  (for (i 0 (- num 1))
    (setq fmt (string "%0" len "s"))
    ;(println (format fmt (bits i)))
    (setq val (explode (format fmt (bits i))))
    (replace "1" val true)
    (replace "0" val nil)
    (push val out -1)
  )
  out)

(make-values 3)
;-> ((nil nil nil)
;->  (nil nil true)
;->  (nil true nil)
;->  (nil true true)
;->  (true nil nil)
;->  (true nil true)
;->  (true true nil)
;->  (true true true))

Inoltre abbiamo bisogno di una funzione che estrae le variabili dall'espressione di input:

(define (extract-symbols exp-str)
  (local (tmp)
       (setq tmp (unique (parse exp-str)))
       (setq tmp (difference tmp '("(" ")" "and" "or" "not" "nand" "nor" "xor" "xnor")))
       (map sym tmp)))

(extract-symbols "((a and b) or (c nand (d or e)))")
;-> (a b c d e)

(extract-symbols "(a xnor b) xor (c or a)")
;-> (a b c)

(define (truth-table exp-str)
  (local (vars num-vars values binds res)
    (setq vars (extract-symbols exp-str))
    (setq num-vars (length vars))
    (setq values (make-values num-vars))
    (println exp-str)
    (dolist (el vars)
      (print (format "%4s" (string el)))
    )
    (println (format "%5s" "out"))
    (dolist (val values)
      (setq binds (map set vars val))
      (dolist (el val)
        ; print "true "nil"
        ;(print (format "%5s" (string el)))
        ; print "1" "0"
        (if el
            (print (format "%4s" "1"))
            (print (format "%4s" "0"))
        )
      )
      ; print "true "nil"
      ;(println (format "%5s" (string (eval (xlate exp-str)))))
      ; print "1 "0"
      (setq res (eval (xlate exp-str)))
      (if res
          (println (format "%5s" "1"))
          (println (format "%5s" "0"))
      )
    )
    '----------))

Facciamo alcune prove:

(truth-table "(not (A and B))")
;-> (not (A and B))
;->    A   B  out
;->    0   0    1
;->    0   1    1
;->    1   0    1
;->    1   1    0
;-> ----------

(truth-table "(A nand B)")
;-> (A nand B)
;->    A   B  out
;->    0   0    1
;->    0   1    1
;->    1   0    1
;->    1   1    0

(truth-table "(a or (b and c))")
;-> (a or (b and c))
;->    a   b   c  out
;->    0   0   0    0
;->    0   0   1    0
;->    0   1   0    0
;->    0   1   1    1
;->    1   0   0    1
;->    1   0   1    1
;->    1   1   0    1
;->    1   1   1    1
;-> ----------

(truth-table "(a xnor b) xor (c or a)")
;-> (a xnor b) xor (c or a)
;->    a   b   c  out
;->    0   0   0    1
;->    0   0   1    0
;->    0   1   0    0
;->    0   1   1    1
;->    1   0   0    1
;->    1   0   1    1
;->    1   1   0    0
;->    1   1   1    0
;-> ----------

(truth-table "((a and b) or (c and (d or e)))")
;-> ((a and b) or (c and (d or e)))
;->    a   b   c   d   e  out
;->    0   0   0   0   0    0
;->    0   0   0   0   1    0
;->    0   0   0   1   0    0
;->    0   0   0   1   1    0
;->    0   0   1   0   0    0
;->    0   0   1   0   1    1
;->    0   0   1   1   0    1
;->    0   0   1   1   1    1
;->    0   1   0   0   0    0
;->    0   1   0   0   1    0
;->    0   1   0   1   0    0
;->    0   1   0   1   1    0
;->    0   1   1   0   0    0
;->    0   1   1   0   1    1
;->    0   1   1   1   0    1
;->    0   1   1   1   1    1
;->    1   0   0   0   0    0
;->    1   0   0   0   1    0
;->    1   0   0   1   0    0
;->    1   0   0   1   1    0
;->    1   0   1   0   0    0
;->    1   0   1   0   1    1
;->    1   0   1   1   0    1
;->    1   0   1   1   1    1
;->    1   1   0   0   0    1
;->    1   1   0   0   1    1
;->    1   1   0   1   0    1
;->    1   1   0   1   1    1
;->    1   1   1   0   0    1
;->    1   1   1   0   1    1
;->    1   1   1   1   0    1
;->    1   1   1   1   1    1
;-> ----------

Nota: l'espressione deve contenere solo variabili, gli operatori logici "and", "or", "not", "nand", "nor", "xor", "xnor" e i caratteri "(" ")".


-----------------
Numeri Brasiliani
-----------------

I numeri Brasiliani sono così chiamati come furono presentati formalmente per la prima volta durante le Olimpiadi IberoAmericane di matematica nel 1994 a Fortaleza, in Brasile.
I numeri Brasiliani sono definiti come tutti i numeri interi positivi in ​​cui ogni numero N ha almeno un numero naturale B dove 1<B<N-1 dove la rappresentazione di N in base B ha tutte le cifre uguali.

Per esempio:
1, 2 e 3 non possono essere brasiliani: non esiste una base B che soddisfi la condizione 1<B<N-1.
4 non è brasiliano: 4 in base 2 è 100. Le cifre non sono tutte uguali.
5 non è brasiliano: 5 in base 2 è 101, in base 3 è 12. Non c'è rappresentazione B in cui le cifre sono le stesse.
6 non è brasiliano: 6 in base 2 è 110, in base 3 è 20, in base 4 è 12. Non c'è rappresentazione B in cui le cifre sono le stesse.
7 è brasiliano: 7 in base 2 è 111. C'è almeno una rappresentazione B in cui le cifre sono tutte uguali.
8 è brasiliano: 8 in base 3 è 22. C'è almeno una rappresentazione B in cui le cifre sono tutte uguali.
e così via...

Tutti i numeri interi pari 2*P> = 8 sono brasiliani perché 2*P = 2*(P-1) + 2, che è 22 in base P-1 quando P-1>2. Ciò diventa vero quando P>=4.
Più comune: per tutti gli interi R e S, dove R>1 e anche S-1>R, allora R*S è brasiliano perché R*S = R*(S-1) + R, che è RR in base S-1.
Gli unici numeri problematici sono i quadrati dei numeri primi, dove R = S. Solo 11^2 è brasiliano in base 3.
Tutti i numeri interi primi, che sono brasiliani, possono avere solo la cifra 1. Altrimenti si potrebbe fattorizzare la cifra, quindi non può essere un numero primo. Principalmente in forma di 111 in base Integer(sqrt(numero primo)). Deve essere un conteggio dispari di 1 per rimanere dispari come i numeri primi > 2.

Funzione che verifica se le cifre di un numero in una base sono tutte uguali:

(define (same-digits num base)
(catch
  (let (f (% num base))
    (while (> (setq num (/ num base)) 0)
      (if (!= (% num base) f) (throw nil))
    )
    true)))

Funzione che verifica se un numero è brasiliano:

(define (brasiliano? num)
(catch
  (cond ((< num 7) nil)
        ((zero? (% num 2)) true)
        (true
          (for (b 2 (- num 2))
            (if (same-digits num b) (throw true))
          )
          nil))))

(brasiliano? 13)
;-> true

Funzone che calcola i primi N numeri brasiliani:

(define (brasiliani num)
  (local (k conta out)
    (setq out '())
    (setq conta 0)
    (setq k 1)
    (while (< conta num)
      (cond ((brasiliano? k)
             (push k out -1)
             (++ conta))
      )
      (++ k)
    )
    out))

(brasiliani 20)
;-> (7 8 10 12 13 14 15 16 18 20 21 22 24 26 27 28 30 31 32 33)

Funzione che calcola l'N-esimo numero brasiliano:

(define (brasiliano-indice idx)
  (local (k conta)
    (setq conta 0)
    (setq k 1)
    (while (!= conta idx)
      (if (brasiliano? k) (++ conta))
      (++ k)
    )
    (- k 1)))

(brasiliano-indice 20)
;-> 33

Vediamo quanto vale il 100.000-esimo numero brasiliano (e quanto tempo ci vuole a calcolarlo):

(time (println (brasiliano-indice 100000)))
;-> 110468
;-> 964206.462 ; 16 minuti


------------------------
Probabilità condizionata
------------------------

Si definisce "probabilità condizionata" di un evento A condizionata (subordinata) all'evento B e si indica con P(A|B), la probabilità che si verifichi A nell'ipotesi che B si sia già verificato.

Eventi dipendenti
-----------------
Si hanno eventi dipendenti se il verificarsi o meno dell'evento B altera la probabilità del verificarsi del successivo evento A.

Viene definita dalla relazione:

            P(A ∩ B)
  P(A|B) = ------------
              P(B)

e viceversa:

            P(A ∩ B)
  P(B|A) = ------------
              P(A)

dove:
- P(A) è la probabilità che si verifichi l'evento A.
- P(B) è la probabilità che si verifichi l'evento B.
- P(A|B) è la probabilità che si verifichi l'evento A dopo che si è verificato l'evento B.
- P(B|A) è la probabilità che si verifichi l'evento B dopo che si è verificato l'evento A.
- P(A ∩ B) è la probabilità che in un singolo tentativo si verifichino simultaneamente l'evento A e l'evento B.

Nel caso di eventi dipendenti tra loro, il teorema del prodotto (probabilità composta) vale:

  P(A ∩ B) = P(A)*P(B|A) = P(B)*P(A|B)

La probabilità dell'intersezione tra due eventi è uguale al prodotto delle probabilità di uno degli eventi per la probabilità condizionata dell'altro, purchè sia verificato il primo evento.

Eventi indipendenti
-------------------
Due eventi A e B si dicono indipendenti se il verificarsi dell'uno non influenza il verificarsi dell'altro.
Nel lancio di due dadi il risultato di uno non influenza il risultato dell'altro, però se si estraggono due carte
da un mazzo (senza reinserimento) la probabilità di avere una carta nera la seconda volta è legata al fatto di avere incontrato o no una carta nera la prima volta, quindi questi eventi sono dipendenti.

Se gli eventi A e B sono indipendenti fra loro risulta:

  P(A|B)=P(A) e P(B|A)=P(B)

Quindi le formule della probabilità condizionata diventano:

          P(A ∩ B)
  P(A) = ------------  ==>  P(A ∩ B) = P(A)*P(B)
            P(B)

          P(A ∩ B)
  P(B) = ------------  ==>  P(A ∩ B) = P(A)*P(B)
            P(A)

La probabilità che in un singolo tentativo si verifichino gli eventi indipendenti A e B è pari al prodotto delle singole probabilità.

Estendendo il teorema a tre eventi A, B e C abbiamo (ponendo D = A ∩ B):

  P(A ∩ B ∩ C) = P(D|C) = P(D) * P(C|D) = P(A ∩ B) * P(C|(A ∩ B)) =

               = P(A) * P(B|A) * P(C|(A ∩ B))

Il teorema del prodotto viene ulteriormente semplificato nel caso gli eventi siano "collettivamente indipendenti", cioè quando ogni evento risulta indipendente non solo dagli altri, ma anche da tutte le possibili intersezioni:

  P(A|C) = P(A)
  P(C|A) = P(C)
  P(B|C) = P(B)
  P(A|(B ∩ C)) = P(A)
  P(B|(A ∩ C)) = P(B)
  P(C|(A ∩ B)) = P(C)

in questo caso il teorema del prodotto vale (per tre eventi):

  P(A ∩ B ∩ C) = P(A)*P(B)*P(A)

La probabilità che in un singolo tentativo si verifichino gli eventi indipendenti A, B e C è pari al prodotto delle singole probabilità.

Generalizzando per n eventi indipendenti E1, E2, ... ,En:

  P(E1 ∩ E2 ∩ ... ∩ En) = P(E1) * P(E2) * ... * P(En)

La probabilità che in un singolo tentativo si verifichino tutti gli eventi indipendenti di un insieme è pari al prodotto delle singole probabilità.

Esempio eventi dipendenti
-------------------------
Il lancio di due dadi produce una somma di punti minore di 7, calcolare la probabilità che i due dadi abbiano lo stesso valore.

I due  eventi sono:

  A = somma dei punti minore di 7

  6 · · · · · ·
  5 ■ · · · · ·
  4 ■ ■ · · · ·
  3 ■ ■ ■ · · ·
  2 ■ ■ ■ ■ · ·
  1 ■ ■ ■ ■ ■
    1 2 3 4 5 6

  P(A) = 15/36

  B = dadi con lo stesso valore

  6 · · · · · ■
  5 · · · · ■ ·
  4 · · · ■ · ·
  3 · · ■ · · ·
  2 · ■ · · · ·
  1 ■ · · · · ·
    1 2 3 4 5 6

  P(B) = 6/36 = 1/6

Dai grafici si deduce che la probabilità che entrambi gli eventi si verifichino in un unico tentativo vale:

  6 · · · · · ·
  5 · · · · · ·
  4 · · · · · ·
  3 · · ■ · · ·
  2 · ■ · · · ·
  1 ■ · · · · ·
    1 2 3 4 5 6

  P(A ∩ B) = P(A) * P(B) = 3/36

Adesso per calcolare P(B|A), cioè la probabilità che i due dadi abbiano lo stesso valore sapendo che la somma è un numero minore di 7, utilizziamo la formula della probabilità condizionata:

            P(A ∩ B)         3/36
  P(B|A) = ------------ = --------- = 3/15 = 1/5
              P(A)          15/36

In questo caso il fatto che gli eventi sono dipendenti lo si può riconosce dal fatto che risulta P(B|A) ≠ P(B):

  P(B|A) = 1/5 ≠ (P|B) = 1/6


Esempio eventi indipendenti
---------------------------
Estraendo una carta da un mazzo napoletano di 40 carte si ottiene una figura (Fante, Cavallo, Re). Qual'è la probabilità che la carta sia del seme Bastoni o Coppe?

  A = estrazione figura (Fante o Cavallo o Re)

  Denari  · · · · · · · ■ ■ ■
  Spade   · · · · · · · ■ ■ ■
  Bastoni · · · · · · · ■ ■ ■
  Coppe   · · · · · · · ■ ■ ■
          A 2 3 4 5 6 7 F C R

  P(A) = 12/40 = 3/10

  B = estrazione carta Bastoni o Coppe

  Denari  · · · · · · · · · ·
  Spade   · · · · · · · · · ·
  Bastoni ■ ■ ■ ■ ■ ■ ■ ■ ■ ■
  Coppe   ■ ■ ■ ■ ■ ■ ■ ■ ■ ■
          A 2 3 4 5 6 7 F C R

  P(B) = 20/40 = 1/2

Dai grafici notiamo che se è stata già estratta una figura (A), la probabilità che si tratti di una carta Bastoni o Coppe (B) vale:

  P(B|A) = 6/12 = 1/2

Viceversa che se è stata già estratta una carta Bastoni o Coppe (B), la probabilità che si tratti di una figura (A) vale:

  P(A|B) = 6/20 = 3/10

L'intersezione dei due insiemi vale:

  P(A ∩ B) = 6/40 = 3/20

Applicando le formule della probabilità condizionata:

             P(A ∩ B)       60/40
  P(B|A) = ------------ = --------- = 6/12 = 1/2   ==> P(B|A) = P(B)
               P(A)         12/40

             P(A ∩ B)        6/20
  P(A|B) = ------------ = --------- = 6/20 = 3/10  ==> P(A|B) = P(A)
               P(B)         20/40


------------------
Teorema di Bayes 1
------------------

Un importante teorema della teoria della probabilità e della statistica è il teorema di Bayes che si basa sul concetto di probabilità condizionata. Viene impiegato per calcolare la probabilità della causa che, a priori, ha generato un dato evento verificato a posteriori.
Una prima formulazione del teorema di Bayes (o teorema della probabilità delle cause) si ricava dal principio della probabilità composta. Consideriamo uno spazio dei campioni costituito da n eventi mutuamente (reciprocamente) esclusivi: A1, A2,...An.

  +--------------+------+-------+-------------------+
  |              |      |       |                   |
  |  A1          |      |       |                   |
  |              |      |       |                   |
  |              |      |       |                   |
  |              |      |       |                   |
  |              |      |       |        +----------+
  +--------------+      |       |        |          |
  |                     |       |        |          |
  |  A2                 |       |   A4   |   A5     |
  |                     |  A3   |        |          |
  +---------------------+-------+--------+----------+


Ipotizziamo che questi eventi A1, A2,...An costituiscano una partizione dello spazio dei campioni. Questo significa che l'intersezione di due eventi qualsiasi è sempre nulla e l'unione di tutti gli eventi Ai costituisce lo spazio dei campioni (universo degli eventi).

  +--------------+------+--------+-------------------+
  |              |      |        |                   |
  |  A1          |      |        |                   |
  |      OOOOOOOOOOOOOOOOOOOOOOO |                   |
  |      O       |      |      O |                   |
  |      O  B∩A1 |      | B∩A3 O |                   |
  |      O       | B∩A2 |      O |        +----------+
  +------O-------+      |      O |        |          |
  |      OOOOOOOOOOOOOOOOOOOOOOO |        |          |
  |  A2                 |        |   A4   |   A5     |
  |                     |  A3    |        |          |
  +---------------------+------- +--------+----------+

Consideriamo ora un altro evento B dello stesso spazio dei campioni e supponiamo che siano note le probabilità P(Ai) e le probabilità condizionate P(B|Ai). In queste condizioni è possibile calcolare la probabilità:

  P(B) = P(A1)*P(B ∩ A1) + P(A2)*P(B ∩ A2) + ... + P(An)*P(B ∩ An)

dove quando B ∩ Ai = (), si ha P(B ∩ Ai) = 0

Per il teorema del prodotto risulta:

  P(B ∩ Ai) = P(Ai)*P(B|Ai)

e sostituendo nella formula per calcolare P(B):

  P(B) = P(A1)*P(B|A1) + P(A2)*P(B|A2) + ... + P(An)*P(B|An) =
         n
       = ∑ P(Ai)*P(B|Ai)
         i

Teorema della probabilità assoluta

  +--------------------------+
  |         n                |
  |  P(B) = ∑ P(Ai)*P(B|Ai)  |
  |         i                |
  +--------------------------+

Esempio
-------
Ci sono tre cassetti uguali contenenti:
- il primo 3 anelli d'argento (G) e 1 d'oro (O)
- il secondo 1 anello d'argento (G) e 3 d'oro (O)
- il terzo 2 anelli d'argento (G)
Aprendo un cassetto a caso e prendendo un anello a caso, qual'è la probabilità di prendere un anello d'oro?

     +------------------+
  A1 |  G G G        O  |
     +------------------+
  A2 |  G          O O  |
     +------------------+
  A3 |  G G             |
     +------------------+

Indichiamo con B l'evento di aver trovato un anello d'oro e con A1 A2 e A3 l'eventualità di aver aperto il primo, il secondo o il terzo cassetto.
Dato che i cassetti sono uguali possiamo assumere come probabilità :

  P(A1) = P(A2) = P(A3) = 1/3

Le probabilità valgono:

  P(B|A1) = 1/4 (il primo cassetto contiene 1 anello su 4)
  P(B|A2) = 2/3 (il primo cassetto contiene 2 anelli su 3)
  P(B|A2) = 0   (il primo cassetto contiene 0 anelli su 2)

Per il teorema della probabilità totale si ha

  P(B) = P(A1)*P(B|A1) + P(A2)*P(B|A2) + P(A3)*P(B|A3) =
       = 1/3*1/4 + 1/3*2/3 + 1/3*0 = 11/36

Quindi aprendo un cassetto a caso, la probabilità di prendere un anello d'oro vale 11/36.

Supponendo, ora, di sapere che l'evento B si è verificato calcoliamo la probabilità che si verifichi l'evento Ai. Dal teorema del prodotto si ha:

  P(Ai ∩ B) = P(Ai)*P(B|Ai) = P(B)*P(Ai|B)

da cui si ottiene:

              P(Ai ∩ B)       P(Ai)*P(B|Ai)
  P(Ai|B) = ------------- = -----------------
                P(B)              P(B)

Adesso sostituendo P(B) con il valore dato dalla formula della probabilità totale otteniamo la Formula di Bayes:

  Formula di Bayes
  +---------------------------------+
  |               P(Ai)*P(B|Ai)     |
  |  P(Ai|B) = -------------------  |
  |              ∑ P(Ai)*P(B|Ai)    |
  +---------------------------------+

Esempio
-------
Ci sono tre urne A1 A2 e A3 che contengono delle palline:
- A1: contiene 12 palline rosse e  8 verdi
- A2: contiene 10 palline rosse e 15 verdi
- A3: contiene  9 palline rosse e  6 verdi
Si lancia un dado e se il punto non è superiore a 3 si estrae una pallina dall'urna A1, se viene un numero superiore a 4 si estrae una pallina dall'urna A2 e se esce il numero 4 si estrae la pallina dall'urna A3.
Esce una pallina rossa: quale è la probabilità che essa sia stata estratta dall'urna A1?

Indichiamo con:
 R: pallina rossa
 V: pallina verde

Indichiamo con A1, A2 e A3 gli eventi
 A1: viene estratta una pallina dall'urna A1
 A2: viene estratta una pallina dall'urna A2
 A3: viene estratta una pallina dall'urna A3

Le probabilità di estrazione dai cassetti valgono:

  P(A1) =  3/6 = 1/2 probabilità che venga estratta una pallina dall'urna A1.
  P(A2) =  2/6 = 1/3 probabilità che venga estratta una pallina dall'urna A2.
  P(A3) =  1/6 probabilità che venga estratta una pallina dall'urna A3.

Per l'urna A1 abbiamo:

  P(R|A1) = 12/20 = 3/5 probabilità di estrarre una pallina rossa dall'urna A1.
  P(V|A1) = 8/20 = 2/5 probabilità di estrarre una pallina rossa dall'urna A1.

Per l'urna A2 abbiamo:

  P(R|A2) = 10/25 = 2/5 probabilità di estrarre una pallina rossa dall'urna A2.
  P(V|A2) = 15/25 = 3/5 probabilità di estrarre una pallina verde dall'urna A2.

Per l'urna A3 abbiamo:

  P(R|A3) = 9/15 = 3/5 probabilità di estrarre una pallina rossa dall'urna A3.
  P(V|A3) = 6/15 = 2/5 probabilità di estrarre una pallina verde dall'urna A3.

in base al grafico seguente:

     P(A1)=1/2
  +-------------A1--+------R-- P(R|A1) = 3/5
  |                 |
  |                 +------V-- P(V|A1) = 2/5
  |  P(A2)=1/3
  +-------------A2--+------R-- P(R|A2) = 2/5
  |                 |
  |                 +------V-- P(V|A2) = 3/5
  |  P(A3)=1/6
  +-------------A3--+------R-- P(R|A3) = 3/5
                    |
                    +------V-- P(V|A3) = 2/5

Quindi per la pallina rossa (R) avremo:

  ∑ P(Ai)*P(R|Ai) = P(A1)*P(R|A1) + P(A2)*P(R|A2) + P(A2)*P(R|A3) = 8/15

Adesso applicando il Teorema di Bayes otteniamo la probabilità che la pallina rossa sia stata estratta dall'urna A1:

               P(A1)*P(R|A1)        3/5 * 1/2
  P(A1|R) = ------------------- = ------------- = 9/16
              ∑ P(Ai)*P(R|Ai)         8/15


------------------
Teorema di Bayes 2
------------------

Il teorema di Bayes (conosciuto anche come formula di Bayes o teorema della probabilità delle cause), proposto da Thomas Bayes (1702-1761), deriva da due teoremi fondamentali delle probabilità: il teorema della probabilità composta e il teorema della probabilità assoluta. Viene impiegato per calcolare la probabilità di una causa che ha scatenato l'evento verificato.
Formalmente il teorema di Bayes è valido in tutte le interpretazioni della probabilità.

Considerando un insieme di alternative A1,A2, ..., An che partizionano lo spazio degli eventi S (ossia (Ai ∩ Aj)=() per ogni i≠j e Unione(Ai)=S) vale la seguente espressione per la probabilità condizionata:

              P(Ai)*P(E|Ai)         P(Ai)*P(E|Ai)
  P(Ai|E) = ------------------- = -------------------
                  P(E)             ∑ P(Aj)*P(E|Aj)

dove:

  P(A) è la probabilità a priori o probabilità marginale di A. "A priori" significa che non tiene conto di nessuna informazione riguardo E.
  P(A|E) è la probabilità condizionata di A, noto E. Viene anche chiamata probabilità a posteriori, visto che è derivata o dipende dallo specifico valore di E.
  P(E|A) è la probabilità condizionata di E, noto A.
  P(E) è la probabilità a priori di E, e funge da costante di normalizzazione.

Intuitivamente, il teorema descrive il modo in cui le opinioni nell'osservare A siano arricchite dall'aver osservato l'evento E.

Il teorema deriva dalla definizione di probabilità condizionata. La probabilità di un evento A, noto un evento B, risulta:

            P(A ∩ B)
  P(A|B)= ------------
              P(B)

In modo analogo, la probabilità di un evento B noto un evento A:

            P(A ∩ B)
  P(B|A)= ------------
              P(A)

Pertanto:

  P(A ∩ B) = P(B|A)*P(A)

Sostituendo nella prima uguaglianza, si trova il teorema di Bayes:

            P(A ∩ B)       P(B|A)*P(A)
  P(A|B)= ------------ = ---------------
              P(B)            P(B)

Esempio
-------
Si consideri una scuola che ha il 60% di studenti maschi e il 40% di studentesse femmine.
Le studentesse indossano in egual numero gonne o pantaloni mentre gli studenti indossano tutti quanti i pantaloni. Un osservatore, da lontano, nota un generico studente coi pantaloni. Qual è la probabilità che quello studente sia una femmina?

Il problema può essere risolto con il teorema di Bayes, ponendo l'evento A che lo studente osservato sia femmina, e l'evento B che lo studente osservato indossi i pantaloni. Per calcolare P(A|B), dovremo sapere:

P(A), ovvero la probabilità che lo studente sia femmina senza nessun'altra informazione. Dato che l'osservatore vede uno studente a caso, ciò significa che tutti gli studenti hanno la stessa probabilità di essere osservati. Essendo le studentesse il 40% del totale, la probabilità risulterà 2/5.

P(A'), ovvero la probabilità che lo studente sia maschio senza nessun'altra informazione. Essendo A' l'evento complementare di A, risulta 3/5.

P(B|A), ovvero la probabilità che uno studente femmina indossi i pantaloni (ossia la probabilità che, verificato l'evento che lo studente sia femmina, si verifichi l'evento che indossi i pantaloni). Poiché indossano gonne e pantaloni in egual numero, la probabilità sarà di 1/2.

P(B|A'), ovvero la probabilità che uno studente indossi i pantaloni, noto che lo studente è maschio. Tutti gli studenti maschi indossano i pantaloni, quindi vale 1.

P(B), ovvero la probabilità che uno studente qualsiasi (maschio o femmina) indossi i pantaloni. Poiché il numero di coloro che indossano i pantaloni è di 80 (60 maschi + 20 femmine) su 100 studenti fra maschi e femmine, la probabilità P(B) è di 80/100 = 4/5.

Adesso possiamo applicare il teorema:

          P(B|A)*P(A)       1/2 * 2/5
P(A|B)= --------------- = ------------- = 1/4
             P(B)              4/5

Quindi la probabilità che lo studente sia femmina vale 1/4, cioè il 25%.

Nota: in questo semplice esempio, la verifica dell'esattezza del risultato è immediata se consideriamo la definizione di "probabilità di un evento" = "numero dei casi favorevoli all'evento/numero dei casi possibili". Il numero dei casi possibili che lo studente/studentessa osservato indossi i pantaloni vale 80 (60 maschi + 20 femmine) mentre quello dei casi favorevoli (cioè le femmine che indossano pantaloni) è 20, quindi la probabilità che si tratti di una femmina è 20/80 cioè 1/4.

Sensibilità e Specificità
---------------------------
La "Sensibilità" e la "Specificità" sono misure statistiche delle prestazioni di un test di classificazione binario e furono introdotti dal biostatistico americano Jacob Yerushalmy nel 1947:

"Sensibilità" (tasso di veri positivi): misura la proporzione di positivi identificati correttamente (cioè la proporzione di coloro che hanno una condizione (affetta) che sono correttamente identificati come affetti dalla condizione).

"Specificità" (tasso veri negativi): misura la proporzione di negativi che sono correttamente identificati (cioè la proporzione di coloro che non hanno la condizione (non affetti) che sono correttamente identificati come non affetti dalla condizione).

I termini "vero positivo", "falso positivo", "vero negativo" e "falso negativo" si riferiscono al risultato di un test e alla correttezza della classificazione. Ad esempio, se la condizione è una malattia, "vero positivo" significa "correttamente diagnosticato come malato", "falso positivo" significa "erroneamente diagnosticato come malato", "vero negativo" significa "correttamente diagnosticato come non malato" e "falso negativo "significa" diagnosticato erroneamente come non malato".
Pertanto, se la sensibilità di un test è del 97% e la sua specificità è del 92%, il suo tasso di falsi negativi è del 3% e il suo tasso di falsi positivi è dell'8%.

In un test diagnostico, la sensibilità è una misura della capacità di un test di identificare i veri positivi.
La sensibilità può anche essere definita come il tasso di richiamo, il tasso di successo o il tasso di vero positivo. È la percentuale, o proporzione, di veri positivi su tutti i campioni che presentano la condizione (veri positivi e falsi negativi). La sensibilità di un test può aiutare a mostrare quanto bene può classificare i campioni che hanno la condizione.

In un test, la specificità è una misura della capacità di un test di identificare i veri negativi. La specificità viene anche definita selettività o tasso di veri negativi ed è la percentuale, o proporzione, dei veri negativi tra tutti i campioni che non presentano la condizione (veri negativi e falsi positivi).

In un test "buono" (uno che cerca di identificare con precisione le persone che hanno la condizione), i falsi positivi dovrebbero essere molto bassi. Cioè, le persone identificate come affette da una condizione dovrebbero avere molte probabilità di avere veramente la condizione. Questo perché le persone identificate come affette da una condizione (ma che non ce l'hanno, in verità) possono essere sottoposte a grande stress.

Per tutti i test, sia diagnostici che di screening, esiste un compromesso tra sensibilità e specificità. Sensibilità più elevate significheranno specificità inferiori e viceversa.

Esempio
-------
Supponiamo che un test per determinare se qualcuno ha usato cannabis sia "Sensibile" al 90%, il che significa che il Tasso di Veri Positivi (TPR) = 0,90. Pertanto porta al 90% di risultati positivi veri (corretta identificazione del consumo di droga) per i consumatori di cannabis.

Il test è anche "Specifico" all'80%, il che significa che il "Tasso di Veri Negativi" (TNR) = 0,80. Pertanto il test identifica correttamente l'80% di risultati negativi veri (corretta identificazione di non utilizzo) per i non-drogati, ma genera anche il 20% di falsi positivi, o Tasso di Falsi Positivi (FPR) = 0,20, per i non-drogati.

Assumendo una "Prevalenza" dello 0,05, ovvero il 5% delle persone usa cannabis, qual è la probabilità che una persona a caso che risulta positiva al test sia davvero un consumatore di cannabis?

Il "Valore Predittivo Positivo" (PPV) di un test è il rapporto tra il numero di persone che sono effettivamente positive e il numero di persone risultate positive e può essere calcolato da un campione come:

  PPV = Veri_positivi / Testati_positivi

Se si conoscono "Sensibilità", "Specificità" e "Prevalenza", il PPV può essere calcolato utilizzando il teorema di Bayes.

Poniamo che P(Consumatore|Positivo) = P(C|P) significa "la probabilità che qualcuno sia un consumatore di cannabis dato che risulta positivo al test " (che è ciò che si intende per PPV). Inoltre P(Positivo|Non-consumatore) = P(P|N) è "la probabilità che qualcuno risulti positivo non essendo consumatore di cannabis".
Allora possiamo scrivere:

             P(P|C)*P(C)             P(P|C)*P(C)
  P(C|P) = --------------- = ----------------------------- =
                P(P)           P(P|C)*P(C) + P(P|N)*P(N)

                 0.9 * 0.05
         = ----------------------- = 0.19148... (19.1%)
             0.9*0.05 + 0.2*0.95

Il fatto che P(P) = P(P|U)*P(U) + P(P|N)*P(N) è un'applicazione diretta della Legge della Probabilità Totale. In questo caso, dice che la probabilità che qualcuno sia positivo è la probabilità che un consumatore sia positivo, moltiplicata per la probabilità di essere un consumatore, più la probabilità che un non consumatore risulti positivo, moltiplicata per la probabilità di essere un non consumatore .

Questo è vero perché le classificazioni consumatore e non consumatore formano una partizione di un insieme, cioè l'insieme di persone che fanno il test antidroga. Ciò combinato con la definizione di probabilità condizionale risulta nella dichiarazione di cui sopra.

Anche se qualcuno risulta positivo, la probabilità che sia un consumatore di cannabis è solo del 19%, perché in questo gruppo solo il 5% delle persone sono consumatori, la maggior parte dei positivi sono falsi positivi provenienti dal restante 95%.

Se sono state testate 1.000 persone:
- 950 sono non consumatori e 190 di loro danno un falso positivo (0,20 × 950)
- 50 di loro sono consumatori e 45 di loro danno un vero positivo (0,90 × 50)

Le 1.000 persone quindi producono 235 test positivi, di cui solo 45 sono veri consumatori di droghe, circa il 19%.

In definitiva abbiamo:

1) Consumatori e Positivi: 45 su 50
2) Non consumatori e Positivi: 190 su 950
3) Non consumatori e negativi: 750 su 950
4) Consumatori e negativi: 5 su 50


---------------------
Probabilità bayesiane
---------------------

In newLISP, due funzioni, "bayes-train" e "bayes-query", lavorano insieme per fornire un modo semplice per calcolare le probabilità bayesiane per insiemi di dati.
Vediamo come utilizzare le due funzioni per prevedere la probabilità che un breve testo sia stato scritto da uno di due autori.
Prima di tutto, scegliamo i testi "The Sign of Four" di Conan Doyle e "The Picture of Dorian Gray" di Oscar Wilde e poi generiamo il relativo set di dati per ciascuno.

(silent
(setq doyle-data
  (parse (lower-case
         (read-file "sign-of-four.txt")) {\W} 0)))

Il parametro {\W} indica a regex di prendere solo le parole (Words).

Vediamo come è strutturato il set di dati:

(length doyle-data)
;-> 59456
(slice doyle-data 100 20)
;-> ("some" "little" "time" "his" "eyes" "rested"
;->  "thoughtfully" "" "upon" "the" "sinewy" "forearm"
;->  "and" "wrist" "all" "dotted" "and" "scarred" "with" "")

(silent
(setq wilde-data
  (parse (lower-case
         (read-file "dorian-grey.txt")) {\W} 0)))

(length wilde-data)
;-> 110762
(slice wilde-data 100 20)
;-> ("are" "corrupt" "without" "" "being" "charming"
;->  "" "" "this" "is" "a" "fault" "" "" "" ""
;->  "those" "who" "find" "beautiful")

La funzione "bayes-train" può ora scansionare queste due liste di dati e memorizzare le frequenze delle parole in un nuovo contesto, che chiameremo Lessico:

(bayes-train doyle-data wilde-data 'Lessico)
;-> (59456 110762)

Questo contesto ora contiene un elenco di parole che ricorrono nei testi e le frequenze di ciascuna. Ad esempio:

Lessico:_always
;-> (21 110)

cioè la parola "always" appare 21 volte nel testo di Doyle e 110 volte in quello di Wilde.

Possiamo salvare il contesto "Lessico" in un file:

(save "lessico.lsp" 'Lessico)
;-> true

Per essere pronto ad essere caricato quando è necessario con:

(load "lessico.lsp")
;-> MAIN

Adesso possiamo usare la funzione "bayes-query" per analizzare una lista di parole contro quelle del contesto "Lessico" e restituire due valori: la probabilità delle parole di appartenere alla prima lista di parole (doyle-data) o alla seconda lista di parole (wilde-data).

Vediamo tre domande:

1) Parole da analizzare: "the latest vegetable alkaloid" prese dal libro di Conan Doyle "A Study in Scarlet".

(setq frase1
  (bayes-query (parse (lower-case
                "the latest vegetable alkaloid") {\W} 0)
               'Lessico))
;-> (0.9888389301533436 0.01116106984665644)

Questo significa che la frase è attribuita a Doyle al 97.3% e al 2.7% a Wilde.

2) Parole da analizzare: "after breakfast he flung himself down on a divan and lit a cigarette" prese dal libro di Oscar Wilde "Lord Arthur Savile's Crime".

(setq frase2
  (bayes-query (parse (lower-case
                "after breakfast he flung himself down on a divan and lit a cigarette" ){\W} 0)
               'Lessico))
;-> (0.02500058589218207 0.9749994141078178)

Questo significa che la frase è attribuita a Doyle al 2.5% e al 97.5% a Wilde.

3) Parole da analizzare: "observations of threadbare morality to listen to" prese dal libro di Jane Austin "Pride and Prejudice" .

(setq frase3
  (bayes-query (parse (lower-case
                "observations of threadbare morality to listen to" ) {\W} 0)
               'Lessico))
;-> (0.5 0.5)

Questo significa che la frase è attribuita a Doyle al 50% e al 50% a Wilde, cioè non è in grado di decidere a quale dei due appartenga la frase (stesse probabilità).


Proviamo a togliere tutte le parole vuote da entrambi i set di dati e vedere se otteniamo risultati diversi:

Eliminiamo il contesto di training precedente:

(delete 'Lessico)

Togliamo le parole vuote "":

(silent (setq d-data (clean null? doyle-data)))
(length d-data)
;-> 43814
(silent (setq w-data (clean null? wilde-data)))
(length w-data)
;-> 80416

Creazione del contesto di training:

(bayes-train d-data w-data 'Lessico)
;-> (43814 80416)

Esecuzione delle tre domande:

(setq frase1
  (bayes-query (parse (lower-case
                "the latest vegetable alkaloid") {\W} 0)
               'Lessico))
;-> (0.988422932469966 0.01157706753003401)

(setq frase2
  (bayes-query (parse (lower-case
                "after breakfast he flung himself down on a divan and lit a cigarette" ){\W} 0)
               'Lessico))
;-> (0.02340957380124487 0.9765904261987551)

(setq frase3
  (bayes-query (parse (lower-case
                "observations of threadbare morality to listen to" ) {\W} 0)
               'Lessico))
;-> (0.5 0.5)

I risultati sono sostanzialmente gli stessi.


----
Dadi
----

I dadi comuni sono piccoli cubi, il più delle volte 16mm (0,63 pollici) di diametro, le cui facce sono numerate da uno a sei, di solito con punti rotondi chiamati pips (anche se occasionalmente si vede l'uso di numeri arabi).

I dadi sono misurati in millimetri (mm) da un lato all'altro e, sebbene le dimensioni dei dadi possano variare da 5mm fino a 100mm o più, ci sono alcune dimensioni dei dadi considerate "standard": 5mm, 12mm, 16mm, 19mm, 25mm e 50mm.

Un pollice equivale a 25.4 millimetri, quindi un dado da 16mm ha una dimensione di circa 2/3 di pollice e un dado da 19mm è di circa 3/4 di pollice.

I valori dei numeri dei lati opposti di un dado moderno sommano a sette, richiedendo che le facce 1, 2 e 3 condividano un vertice. Le facce di un dado possono essere posizionate in senso orario o antiorario attorno a questo vertice. Se le facce 1, 2 e 3 girano in senso antiorario, il dado viene chiamato "destrorso". Se quelle facce girano in senso orario, il dado viene chiamato "mancino".
I dadi occidentali sono normalmente destrorsi, mentre i dadi cinesi sono normalmente mancini.

Senso anti-orario (destrorso "right-handed"):

  +---+
  | 3 |
  +---+---+---+---+
  | 6 | 5 | 1 | 2 |
  +---+---+---+---+
  | 4 |
  +---+

Senso orario (mancino "left-handed"):

  +---+
  | 4 |
  +---+---+---+---+
  | 6 | 5 | 1 | 2 |
  +---+---+---+---+
  | 3 |
  +---+

Nota: vengono scambiate le posizioni del 3 e del 4.

I dadi comunemente disponibili favoriscono alcuni numeri più di altri perché alcuni lati sono più leggeri dei lati opposti a causa del diverso numero di "pin" e anche perché ci sono altre imprecisioni nel processo di produzione. Questo fatto diventerà evidente solo dopo un numero considerevolmente alto di lanci. Se questo è un problema, allora possiamo prendere i dadi di precisione utilizzati nei casinò "casino dice".

I dadi del casinò sono chiamati dadi perfetti o di precisione a causa del modo in cui sono fatti. Sono il più vicino possibile ad essere veri cubi perfetti, misurati entro una frazione di millimetro, fabbricati in modo che ogni dado abbia la stessa possibilità di atterrare su una qualsiasi delle sue sei facce.
Questi dadi vengono realizzati a mano in acetato di cellulosa con una tolleranza di 0.0005 di pollice. I punti vengono forati e riempiti con materiale di peso uguale a quello rimosso. Di solito i lati sono a filo e i bordi affilati. Sono prevalentemente rossi trasparenti ma possono essere disponibili in altri colori come il verde, il viola o il blu. Alcuni dadi da casinò possono avere una finitura levigata che li renderà traslucidi e non completamente trasparenti. I punti sono generalmente solidi ed è possibile trovare un numero di disegni diversi, comunque si ritiene che tutti i dadi da casinò dovrebbero essere "destrorsi" e avere la stessa disposizione convenzionale di facce e pin.

Vediamo come simulare il lancio di dadi.

Funzione che ritorna l'opposto del numero di un dado a sei facce:

(define (dado-opposto num) (- 7 num))

Scriviamo una funzione che simula il lancio di N dadi ognuno con F facce:

(rand 6 10)
;-> (4 1 4 2 5 4 0 2 3 2)

(define (dado num-dadi num-facce)
  (+ num-dadi (apply + (rand num-facce num-dadi))))

Scriviamo una funzione che calcola la probabilità di ogni numero generato dalla funzione "dado" con parametri predefiniti:

(define (test-dado num-dadi num-facce iter)
  (local (out max-val)
    ; valore massimo
    (setq max-val (* num-dadi num-facce))
    ; vettore delle frequenze
    (setq out (array (+ max-val 1) '(0)))
    ; ciclo di simulazione
    (for (i 1 iter)
      ; aumenta la frequenza del numero uscito
      (++ (out (dado num-dadi num-facce)))
    )
    ; calcola la percentuale di ogni frequenza
    (map (fn(x) (round (div x iter) -4)) (slice out 1))))

Facciamo alcune prove:

Un dado da 6:
(test-dado 1 6 100000)
;-> (0.1653 0.1679 0.1662 0.1672 0.1679 0.1655)
I numeri 1..6 sono tutti equiprobabili.

Due dadi da 12:
(test-dado 2 6 100000)
;-> (0 0.0273 0.056 0.0833 0.1111 0.1388 0.1672 0.1401 0.1103 0.0827 0.0552 0.028)
Il numero 7 è più probabile in 1..12.
Il numero 1 non è possibile (percentuale = 0).

Tre dadi da 6:
(test-dado 3 6 1000000)
;-> (0 0 0.0049 0.0139 0.0286 0.0467 0.0695 0.0946 0.1162 0.1248
;->  0.1251 0.1162 0.0964 0.0702 0.0463 0.0278 0.0139 0.0048)

Tre dadi da 6 (più iterazioni):
(test-dado 3 6 1e8)
;-> (0 0 0.0046 0.0139 0.0278 0.0463 0.0695 0.0973 0.1157 0.125
;->  0.125 0.1158 0.0972 0.0694 0.0463 0.0278 0.0139 0.0046)
I numero 10 e 11 sono più probabili in 1..18.
I numeri 1 e 2 non sono possibili (percentuale = 0).


----------------
replace multiplo
----------------

La funzione "replace" permette di sostituire in una lista ogni occorrenza di un elemento con un altro elemento. Se abbiamo bisogno di effettuare diverse sostituzioni dobbiamo applicare tante volte la funzione "replace". Per esempio:

(setq lst '(1 3 5 4 3 1 5 5 7 1 2))
(replace 1 lst 'a)
;-> (a 3 5 4 3 a 5 5 7 a 2)
(replace 2 lst 'b)
;-> (a 3 5 4 3 a 5 5 7 a b)
(replace 3 lst 'c)
;-> (a c 5 4 c a 5 5 7 a b)

Comunque possiamo usare anche il metodo seguente:

(setq lst '(1 3 5 4 3 1 5 5 7 1 2))
(setq sost '((1 a) (2 b) (3 c)))
(dolist (s sost)
    (replace (first s) lst (last s)))
;-> (a c 5 4 c a 5 5 7 a b)

Questo metodo permette di tenere insieme le coppie da sostituire nel caso ci sia una lunga lista di modifiche.

Possiamo convertire il metodo in una macro igienica:

(define-macro (replace-all)
    (dolist (r (eval (args 0)))
      (replace (first r) (eval (args 1)) (last r))))

(setq lst '(1 3 5 4 3 1 5 5 7 1 2))
;-> (1 3 5 4 3 1 5 5 7 1 2)
(replace-all sost lst)
;-> (a c 5 4 c a 5 5 7 a b)

La macro può essere applicata anche alle stringhe:

(setq str "newlisp è difficile")
(setq sost '(("newlisp" "newLISP") ("difficile" "divertente")))
(replace-all sost str)
;-> "newLISP è divertente"


----------------
ASCII Mandelbrot
----------------

Ecco una versione base per stampare sul terminale il frattale di Mandelbrot.

Prima di tutto ci servono alcune funzioni per calcolare i numeri complessi:

; Estrae la parte reale di un numero complesso
(define (real num) (first num))
; Estrae la parte immaginaria di un numero complesso
(define (imag num) (last num))
; Calcola il modulo di un numero complesso
(define (modulo num)
  (sqrt (add (mul (real num) (real num)) (mul (imag num) (imag num)))))
; Calcola la somma di due numeri complessi
(define (cx-add num1 num2)
  (list (add (real num1) (real num2)) (add (imag num1) (imag num2))))
; Calcola la moltiplicazione di due numeri complessi
(define (cx-mul num1 num2)
  (list (sub (mul (real num1) (real num2)) (mul (imag num1) (imag num2)))
        (add (mul (imag num1) (real num2)) (mul (real num1) (imag num2)))))

Poi scriviamo una funzione per calcolare il frattale di Mandelbrot:

(define (mandelbrot)
  (local (x y z)
    (for (y -1.2 1.2 0.05)
      (for (x -2.05 0.55 0.03)
        (setq z '(0 0))
        (dotimes (i 100)
          (setq z (cx-add (cx-mul z z) (list x y)))
        )
        (if (< (modulo z) 2)
            (print "#")
            (print ".")
        )
      )
      (println))))

Proviamo:

(mandelbrot)
..............................................................................
...........................................................##.................
........................................................######................
........................................................#######...............
.........................................................######...............
.....................................................#.#.###..#.#.............
..............................................##....################..........
.............................................###.######################.###...
..............................................############################....
...........................................###############################....
...........................................################################...
........................................#####################################.
.........................................###################################..
.........................##.####.#......####################################..
.........................###########....####################################..
.......................###############.######################################.
.......................###############.#####################################..
...................##.#####################################################...
.#.###...#..############################################################......
...................##.#####################################################...
.......................###############.#####################################..
.......................###############.######################################.
.........................###########....####################################..
.........................##.####.#......####################################..
.........................................###################################..
........................................#####################################.
...........................................################################...
...........................................###############################....
..............................................############################....
.............................................###.######################.###...
..............................................##....################..........
.....................................................#.#.###..#.#.............
.........................................................######...............
........................................................#######...............
........................................................######................
...........................................................##.................
..............................................................................


-------
Yahtzee
-------
Yahtzee è un gioco di strategia che si svolge con 5 dadi. Si gioca da soli cercando di fare il punteggio migliore o contro uno o più avversari.

Sono previste diverse combinazioni che ogni giocatore deve realizzare lanciando i dadi. Ottenuta la combinazione il giocatore guadagna il punteggio previsto per la combinazione. Una combinazione non può essere ripetuta quindi il gioco termina dopo 13 turni di lancio dei dadi, anche quando non sono state realizzate tutte le combinazioni.

Ad ogni turno il giocatore può lanciare i dadi tre volte. Al primo lancio il giocatore lancia tutti i dadi, mentre nei successivi due lanci il giocatore può scegliere di trattenere uno o più dadi favorevoli ad ottenere la combinazione cercata. Il giocatore può anche scegliere di non trattenere alcun dado o di non utilizzare successivi lanci, nel caso ad esempio si sia già realizzata una combinazione utile. Al termine dei tre lanci il giocatore deve segnare obbligatoriamente un punteggio in una delle caselle del segnapunti non ancora utilizzata. Se alla fine del turno di gioco non viene realizzata una delle possibili combinazioni ancora "libera" sul tabellone, il giocatore deve segnare "0" (zero) in una delle caselle ancora a sua disposizione.

Vince il giocatore che ha totalizzato il maggior numero di punti.

Le combinazioni valide sono le seguenti:

  Dadi uguali con 1 (punteggio dato dalla somma dei dadi con 1):
  si ottiene quando almeno un dado è 1. Il punteggio è la somma dei dadi che riportano 1. Ad esempio: 1-3-4-6-1 vale 2.

  Dadi uguali con 2 (punteggio dato dalla somma dei dadi con 2):
  si ottiene quando almeno un dado è 2. Il punteggio è la somma dei dadi che riportano 2. Ad esempio: 2-1-2-2-5 vale 6.

  Dadi uguali con 3 (punteggio dato dalla somma dei dadi con 3):
  si ottiene quando almeno un dado è 3. Il punteggio è la somma dei dadi che riportano 3. Ad esempio: 3-1-3-4-3 vale 9.

  Dadi uguali con 4 (punteggio dato dalla somma dei dadi con 4):
  si ottiene quando almeno un dado è 4. Il punteggio è la somma dei dadi che riportano 4. Ad esempio: 4-1-2-2-1 vale 4.

  Dadi uguali con 5 (punteggio dato dalla somma dei dadi con 5):
  si ottiene quando almeno un dado è 5. Il punteggio è la somma dei dadi che riportano 5. Ad esempio: 5-1-5-5-2 vale 15.

  Dadi uguali con 6 (punteggio dato dalla somma dei dadi con 6):
  si ottiene quando almeno un dado è 6. Il punteggio è la somma dei dadi che riportano 6. Ad esempio: 6-3-2-6-1 vale 12,

  Bonus (35 punti):
  si ottiene quando la somma dei punteggi per le 6 combinazioni precedenti supera o raggiunge 63.

  Piccola Scala (30 punti):
  quando 4 dadi sono ordinati in modo crescente (1-2-3-4 o 2-3-4-5 o 3-4-5-6)

  Grande Scala (40 punti):
  quando 5 dadi sono ordinati in modo crescente (1-2-3-4-5 o 2-3-4-5-6)

  Tris (punteggio dato dalla somma di tutti i dadi):
  quando 3 dei cinque dadi sono uguali. Ad esempio 3-3-3-5-2 vale 16.

  Poker (punteggio dato dalla somma di tutti i dadi):
  quando 4 dei 5 dadi sono uguali. Ad esempio 5-5-5-5-1 vale 21.

  Full (25 punti):
  quando ci sono 3 dadi di un tipo e due di un altro. Ad esempio 4-4-4-1-1.

  Yahtzee (50 punti):
  quando si ottengono 5 dadi uguali. Ad esempio 1-1-1-1-1 o 4-4-4-4-4. Se Yahtzee viene ripetuto può essere inserito solo in un'altra combinazione libera con il relativo punteggio.

  Chance (punteggio dato dalla somma dei 5 dadi):
  qualsiasi combinazione ottenuta. Questa è una possibilità da sfruttare quando non si riesce a realizzare nessuna delle combinazioni precedenti o la combinazione realizzata è già stata utilizzata precedentemente. Anche questa combinazione può essere utilizzata una sola volta.

Nota: alcune combinazioni offrono al giocatore la possibilità di scegliere in quale categoria classificarle. Ad esempio, un Full potrebbe essere segnato nelle categorie Full, Tris o Chance.

Scriviamo una funzione che calcola i valori di tutte le combinazioni per un determinato lancio:

;----------------------------------------------
(define (chance? lst)
  (apply + lst))
(chance? '(1 2 4 6 5))
;-> 18
;----------------------------------------------
(define (yahtzee? lst)
  (if (apply = lst) 50 0))
(yahtzee? '(1 1 1 1 1))
;-> 50
(yahtzee? '(1 2 1 1 1))
;-> 0
;----------------------------------------------
(define (poker? lst)
  (if (or (>= (first (count '(1) lst)) 4)
          (>= (first (count '(2) lst)) 4)
          (>= (first (count '(3) lst)) 4)
          (>= (first (count '(4) lst)) 4)
          (>= (first (count '(5) lst)) 4)
          (>= (first (count '(6) lst)) 4))
      (apply + lst)
      0))
(poker? '(1 2 2 2 2))
;-> 9
(poker? '(1 2 2 2 1))
;-> 0
(poker? '(3 4 3 3 3))
;-> 16
(poker? '(1 1 1 1 1))
;-> 5
;----------------------------------------------
(define (tris? lst)
  (if (or (>= (first  (count '(1) lst)) 3)
          (>= (first  (count '(2) lst)) 3)
          (>= (first  (count '(3) lst)) 3)
          (>= (first  (count '(4) lst)) 3)
          (>= (first  (count '(5) lst)) 3)
          (>= (first  (count '(6) lst)) 3))
      (apply + lst)
      0))
(tris? '(4 4 1 1 4))
;-> 14
(tris? '(1 2 2 2 2))
;-> 9
(tris? '(1 2 2 5 1))
;-> 0
(tris? '(3 4 3 3 3))
;-> 16
;----------------------------------------------
(define (full? lst)
  (let (tmp (sort (copy lst)))
    (if (or (and (= (tmp 0) (tmp 1)) (= (tmp 2) (tmp 3) (tmp 4)) (!= (tmp 0) (tmp 4)))
            (and (= (tmp 0) (tmp 1) (tmp 2)) (= (tmp 3) (tmp 4)) (!= (tmp 0) (tmp 4))))
        25
        0)))
(full? '(1 2 1 2 1))
;-> 25
(full? '(1 1 1 1 1))
;-> 0
(full? '(2 3 2 3 1))
;-> 0
(full? '(2 3 2 3 2))
;-> 25
;----------------------------------------------
(define (scala-piccola? lst)
  (let (tmp (sort (copy lst)))
    (if (or (= (count '(1 2 3 4) tmp) '(1 1 1 1))
            (= (count '(2 3 4 5) tmp) '(1 1 1 1))
            (= (count '(3 4 5 6) tmp) '(1 1 1 1)))
        30
        0)))
(scala-piccola? '(1 3 2 4 6))
;-> 30
(scala-piccola? '(1 3 2 4 5))
;-> 30
(scala-piccola? '(6 3 2 4 5))
;-> 30
(scala-piccola? '(1 5 5 3 2))
;-> 0
;----------------------------------------------
;(define (scala-grande? lst)
;  (let (tmp (sort (copy lst)))
;    (if (and (apply < tmp) ; lista strettamente crescente?
;            (= (- (tmp 4) (tmp 0)) 4)) ; differenza primo e ultimo elemento
;        40
;        0)))
;
(define (scala-grande? lst)
  (let (tmp (sort (copy lst)))
    (if (or (= tmp '(1 2 3 4 5)) (= tmp '(2 3 4 5 6)))
        40
        0)))
(scala-grande? '(1 2 3 4 5))
;-> 40
(scala-grande? '(1 5 3 2 4))
;-> 40
(scala-grande? '(2 4 3 6 5))
;-> 40
(scala-grande? '(2 2 3 6 5))
;-> 0
(scala-grande? '(1 3 4 5 6))
;-> 0
(scala-grande? '(2 3 4 5 6))
;-> 40
;----------------------------------------------
(define (dadi? x lst)
  (mul x (first (count (list x) lst))))
(dadi? 1 '(1 2 3 4 1))
;-> 2
(dadi? 2 '(1 2 3 2 3))
;-> 4
(dadi? 5 '(1 2 5 5 5))
;-> 15
(dadi? 3 '(1 2 5 5 5))
;-> 0
;----------------------------------------------
(define (yahtzee lst totale)
  (local (bonus)
    (if (nil? totale)
        (setq bonus 0)
        (setq bonus totale)
    )
    (if (>= (+ (dadi? 1 lst) bonus) 63)
        (println (format "%-10s%3d%-5s%2d" "Dadi 1" (dadi? 1 lst) "  Bonus: " 35))
        (println (format "%-10s%3d" "Dadi 1: " (dadi? 1 lst))))
    (if (>= (+ (dadi? 2 lst) bonus) 63)
        (println (format "%-10s%3d%-5s%2d" "Dadi 2" (dadi? 2 lst) "  Bonus: " 35))
        (println (format "%-10s%3d" "Dadi 2: " (dadi? 2 lst))))
    (if (>= (+ (dadi? 3 lst) bonus) 63)
        (println (format "%-10s%3d%-5s%2d" "Dadi 3" (dadi? 3 lst) "  Bonus: " 35))
        (println (format "%-10s%3d" "Dadi 3: " (dadi? 3 lst))))
    (if (>= (+ (dadi? 4 lst) bonus) 63)
        (println (format "%-10s%3d%-5s%2d" "Dadi 4" (dadi? 4 lst) "  Bonus: " 35))
        (println (format "%-10s%3d" "Dadi 4: " (dadi? 4 lst))))
    (if (>= (+ (dadi? 5 lst) bonus) 63)
        (println (format "%-10s%3d%-5s%2d" "Dadi 5" (dadi? 5 lst) "  Bonus: " 35))
        (println (format "%-10s%3d" "Dadi 5: " (dadi? 5 lst))))
    (if (>= (+ (dadi? 6 lst) bonus) 63)
        (println (format "%-10s%3d%-5s%2d" "Dadi 6" (dadi? 6 lst) "  Bonus: " 35))
        (println (format "%-10s%3d" "Dadi 6: " (dadi? 6 lst))))
    (println (format "%-10s%3d" "Tris: " (tris? lst)))
    (println (format "%-10s%3d" "Poker: " (poker? lst)))
    (println (format "%-10s%3d" "Full: " (full? lst)))
    (println (format "%-10s%3d" "Scaletta: " (scala-piccola? lst)))
    (println (format "%-10s%3d" "Scala: " (scala-grande? lst)))
    (println (format "%-10s%3d" "Yahtzee: " (yahtzee? lst)))
    (println (format "%-10s%3d" "Chance: " (chance? lst)))
  ))

(yahtzee '(1 1 2 2 2) 62)
;-> Dadi 1      2  Bonus: 35
;-> Dadi 2      6  Bonus: 35
;-> Dadi 3:     0
;-> Dadi 4:     0
;-> Dadi 5:     0
;-> Dadi 6:     0
;-> Tris:       8
;-> Poker:      0
;-> Full:      25
;-> Scaletta:   0
;-> Scala:      0
;-> Yahtzee:    0
;-> Chance:     8
(yahtzee '(1 2 3 4 5))
;-> Dadi 1:     1
;-> Dadi 2:     2
;-> Dadi 3:     3
;-> Dadi 4:     4
;-> Dadi 5:     5
;-> Dadi 6:     0
;-> Tris:       0
;-> Poker:      0
;-> Full:       0
;-> Scaletta:  30
;-> Scala:     40
;-> Yahtzee:    0
;-> Chance:    15


------------
Gioco del 15
------------

Il gioco del quindici è un puzzle creato nel 1874 da Noyes Palmer Chapman e reso noto nel 1880 da Samuel Loyd. Il gioco consiste di una tabellina di forma quadrata, solitamente di plastica, divisa in quattro righe e quattro colonne (quindi 16 posizioni), su cui sono posizionate 15 tessere quadrate, numerate progressivamente a partire da 1 fino a 15. Le tessere possono scorrere in orizzontale o verticale, ma il loro spostamento è limitato dall'esistenza di un singolo spazio vuoto. Lo scopo del gioco è riordinare le tessere dopo averle "mescolate" in modo casuale (la posizione da raggiungere è quella con il numero 1 in alto a sinistra e gli altri numeri a seguire da sinistra a destra e dall'alto in basso, fino al 15 seguito dalla casella vuota).

Posizione finale (soluzione) del gioco del 15

  ╔════╦════╦════╦════╗
  ║  1 ║  2 ║  3 ║  4 ║
  ╠════╬════╬════╬════╣
  ║  5 ║  6 ║  7 ║  8 ║
  ╠════╬════╬════╬════╣
  ║  9 ║ 10 ║ 11 ║ 12 ║
  ╠════╬════╬════╬════╣
  ║ 13 ║ 14 ║ 15 ║    ║
  ╚════╩════╩════╩════╝

Il compito è scrivere un programma per giocare al gioco del 15 sul terminale.

Rappresentiamo una posizione del puzzle con una lista dove lo spazio vuoto vale 0 (zero):

(setq pos '((10 2 6 4) (15 0 7 8) (9 1 11 13) (12 14 5 3)))
(setq sol '((1 2 3 4) (5 6 7 8) (9 10 11 12) (13 14 15 0)))

Prima di tutto scriviamo una funzione che stampa il puzzle:

;(define (print-puzzle grid)
;  (println "+----+----+----+----+")
;  (for (i 0 3)
;    (for (j 0 3)
;      (if (zero? (grid i j))
;          (print "|    ")
;          (print (format "|%3d " (grid i j))))
;    )
;    (println "|")
;    (println "+----+----+----+----+")
;  ))

(define (print-puzzle grid)
  (println "╔════╦════╦════╦════╗")
  (for (i 0 3)
    (for (j 0 3)
      (if (zero? (grid i j))
          (print "║    ")
          (print (format "║%3d " (grid i j))))
    )
    (println "║")
    (if (< i 3)
        (println "╠════╬════╬════╬════╣")
        (println "╚════╩════╩════╩════╝")
    )
  ))

(print-puzzle pos)
;-> ╔════╦════╦════╦════╗
;-> ║ 10 ║  2 ║  6 ║  4 ║
;-> ╠════╬════╬════╬════╣
;-> ║ 15 ║    ║  7 ║  8 ║
;-> ╠════╬════╬════╬════╣
;-> ║  9 ║  1 ║ 11 ║ 13 ║
;-> ╠════╬════╬════╬════╣
;-> ║ 12 ║ 14 ║  5 ║  3 ║
;-> ╚════╩════╩════╩════╝

Poi ci serve una funzione che restituisce le mosse valide partendo da una posizione del puzzle:

Indici della griglia:

  +----+----+----+----+
  | 00 | 01 | 02 | 03 |
  +----+----+----+----+
  | 10 | 11 | 12 | 13 |
  +----+----+----+----+
  | 20 | 21 | 22 | 23 |
  +----+----+----+----+
  | 30 | 31 | 32 | 33 |
  +----+----+----+----+

(define (valid-moves grid)
  ; hard-coded valid moves
  ; based on position of "0"
  (case (ref 0 grid)
    ((0 0) '((0 1) (1 0)))
    ((0 1) '((0 0) (0 2) (1 1)))
    ((0 2) '((0 1) (0 3) (1 2)))
    ((0 3) '((0 2) (1 3)))
    ((1 0) '((0 0) (1 1) (2 0)))
    ((1 1) '((0 1) (1 0) (1 2) (2 1)))
    ((1 2) '((0 2) (1 1) (1 3) (2 2)))
    ((1 3) '((0 3) (1 2) (2 3)))
    ((2 0) '((1 0) (2 1) (3 0)))
    ((2 1) '((1 1) (2 0) (2 2) (3 1)))
    ((2 2) '((1 2) (2 1) (2 3) (3 2)))
    ((2 3) '((1 3) (2 2) (3 3)))
    ((3 0) '((2 0) (3 1)))
    ((3 1) '((2 1) (3 0) (3 2)))
    ((3 2) '((2 2) (3 1) (3 3)))
    ((3 3) '((2 3) (3 2)))
    (true nil)))

(setq g '((1 2 3 4) (5 6 7 8) (9 10 11 12) (13 14 15 0)))
(valid-moves g)
;-> ((2 3) (3 2))

Adesso abbiamo bisogno di una funzione per verificare se una posizione è la soluzione del puzzle (cioè se il puzzle è stato risolto):

(define (endgame? grid)
  (= grid '((1 2 3 4) (5 6 7 8) (9 10 11 12) (13 14 15 0))))

Adesso possiamo scrivere la funzione che accetta l'input di una mossa da parte dell'utente:

(define (read-move grid)
  (local (move pos valid row col ok)
    (setq ok nil)
    ; fino a che la mossa non è valida...
    (until ok
      (print "(" num-mosse ") - Numero (1..15): ")
      (setq move (int (read-line)))
      ; accetta solo numeri da 1 a 15
      (while (or (< move 1) (> move 15) (not (integer? move)))
          (print "(" num-mosse ") - Numero (1..15): ")
          (setq move (int (read-line)))
      )
      ; controlla validità mossa
      (setq pos (ref move grid))
      (setq valid (valid-moves grid))
      (if (find pos valid)
          (setq ok true)
          (println "Errore: numero fisso")
      )
    )
    pos))

(print-puzzle pos)
;-> ╔════╦════╦════╦════╗
;-> ║ 10 ║  2 ║  6 ║  4 ║
;-> ╠════╬════╬════╬════╣
;-> ║ 15 ║    ║  7 ║  8 ║
;-> ╠════╬════╬════╬════╣
;-> ║  9 ║  1 ║ 11 ║ 13 ║
;-> ╠════╬════╬════╬════╣
;-> ║ 12 ║ 14 ║  5 ║  3 ║
;-> ╚════╩════╩════╩════╝
(read-move pos)
;-> (0) - Numero (1..15): 10
;-> Errore: numero fisso
;-> (0) - Numero (1..15): 2
;-> (0 1)

Prima di scrivere la parte del programma che gestisce tutto il gioco, dobbiamo creare una posizione di partenza per il puzzle. La prima idea è quella di generare una lista/matrice 4x4 con numeri da 0 a 15 posizionati in modo casuale. Per esempio:

(define (crea-puzzle)
  (explode (randomize '(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15)) 4))

(print-puzzle (crea-puzzle))
;-> ╔════╦════╦════╦════╗
;-> ║  6 ║ 13 ║ 11 ║  7 ║
;-> ╠════╬════╬════╬════╣
;-> ║  4 ║  1 ║  2 ║ 14 ║
;-> ╠════╬════╬════╬════╣
;-> ║  9 ║ 10 ║ 15 ║  5 ║
;-> ╠════╬════╬════╬════╣
;-> ║ 12 ║    ║  8 ║  3 ║
;-> ╚════╩════╩════╩════╝

Purtroppo non è così semplice perchè il problema è che non tutte le posizioni casuali di partenza sono risolvibili (tralasciamo la dimostrazione matematica). Comunque esiste un algoritmo che permette di determinare se una posizione è risolvibile o meno.

In generale, per una data griglia di dimensione N, un puzzle (N*N - 1) è risolvibile o meno in base alle seguenti regole:

a) Se N è dispari, l'istanza del puzzle è risolvibile se il numero di inversioni è pari nello stato iniziale di input.

b) Se N è pari, l'istanza del puzzle è risolvibile se
  1) lo spazio vuoto (zero) è su una riga pari contando dal basso (penultima, quarto-ultima, ecc.) e il numero di inversioni è dispari
  oppure
  2) lo spazio vuoto si trova su una riga dispari contando dal basso (ultima, terzultima, quintultima, ecc.) e il numero di inversioni è pari

Per tutti gli altri casi, l'istanza del puzzle non è risolvibile.

Cos'è un'inversione?
Se assumiamo che le tessere (numeri) siano scritte in una singola riga (1D Array) invece di essere distribuite in N-file (2D Array), allora una coppia di tessere (a, b) formano un'inversione se a appare prima di b, ma a > b.

Per esempio considerando le tessere scritte in questo modo:

2 1 3 4 5 6 7 8 9 10 11 12 13 14 15 X

allora formano solo una (1) inversione, ovvero (2, 1).

Scriviamo una funzione che calcola il numero di inversioni per una posizione del puzzle:

(define (inversion grid)
  (local (lst inver)
    (setq lst (flat grid))
    ; tolgo lo zero
    (pop lst (ref 0 lst))
    (setq inver 0)
    (for (i 0 (- (length lst) 2))
      (for (j (+ i 1) (- (length lst) 1))
        (if (and (< i j) (> (lst i) (lst j)))
            (++ inver)
        )
      )
    )
    inver))

(inversion '(2 1 3 4 5 6 7 8 9 10 11 12 13 14 15 0))
;-> 1
(inversion '((13 2 10 3) (1 12 8 4) (5 0 9 6) (15 14 11 7)))
;-> 41
(inversion '((6 13 7 10) (8 9 11 0) (15 2 12 5) (14 3 1 4)))
;-> 62
(inversion '((3 9 1 15) (14 11 4 6) (13 0 10 12) (2 7 8 5)))
;-> 56

Adesso scriviamo una funzione che verifica se una posizione del puzzle è risolvibile:

(define (solvable grid)
  (local (zero zero-row zero-col)
    (setq zero (ref 0 grid))
    (setq zero-row (first zero))
    (setq zero-col (last zero))
    (setq inver (inversion grid))
    (if (or (and (even? zero-row) (odd? inver))
            (and (odd? zero-row) (even? inver)))
        true
        nil
    )))

(solvable '((1 2 3 4) (5 6 7 8) (9 10 11 12) (13 14 15 0)))
;-> true
(solvable '((13 2 10 3) (1 12 8 4) (5 0 9 6) (15 14 11 7)))
;-> true
(solvable '((6 13 7 10) (8 9 11 0) (15 2 12 5) (14 3 1 4)))
;-> true
(solvable '((3 9 1 15) (14 11 4 6) (13 0 10 12) (2 7 8 5)))
;-> nil

Adesso possiamo scrivere la funzione che crea un puzzle valido:

(define (crea-puzzle)
  (local (grid lst ok)
    (setq ok nil)
    (setq lst '(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15))
    (until ok
      (setq grid (explode (randomize lst) 4))
      (if (solvable grid)
        (setq ok true)
      )
    )
    grid))

Proviamo a generare un paio di puzzle:

(crea-puzzle)
;-> ((12 0 2 14) (15 5 4 1) (3 9 13 11) (6 8 10 7))
(print-puzzle (crea-puzzle))
;-> ╔════╦════╦════╦════╗
;-> ║  9 ║ 11 ║  2 ║ 15 ║
;-> ╠════╬════╬════╬════╣
;-> ║  8 ║ 12 ║  4 ║ 14 ║
;-> ╠════╬════╬════╬════╣
;-> ║  7 ║  5 ║ 10 ║    ║
;-> ╠════╬════╬════╬════╣
;-> ║  1 ║  3 ║ 13 ║  6 ║
;-> ╚════╩════╩════╩════╝

Un altro metodo di creare una posizione iniziale per il puzzle è il seguente:
1) partendo dalla posizione di soluzione del puzzle
2) generare un predefinito numero di mosse casuali valide

In questo modo la posizione finale è sicuramente risolvibile.

(define (create-puzzle level)
  (local (grid iter valid mossa mossa-row mossa-col zero zero-row zero-col)
    (seed (time-of-day))
    ; posizione iniziale (puzzle risolto)
    (setq grid '((1 2 3 4) (5 6 7 8) (9 10 11 12) (13 14 15 0)))
    ; numero di iterazioni (mosse casuali)
    (setq iter (* level 10))
    (for (i 0 iter)
      ; trova mosse valide
      (setq valid (valid-moves grid))
      (setq mossa (valid (rand (length valid))))
      (setq mossa-row (first mossa))
      (setq mossa-col (last mossa))
      ; trova posizione dello zero
      (setq zero (ref 0 grid))
      (setq zero-row (first zero))
      (setq zero-col (last zero))
      ; effettua la mossa (scambia le due posizioni)
      (swap (grid zero-row zero-col) (grid mossa-row mossa-col))
    )
    grid))

Con questo metodo possiamo gestire (più o meno) la complessità del puzzle generato, infatti maggiore è il numero dei passi effettuati e più difficile (lunga) sarà la soluzione (generalmente).

Puzzle semplicissimo:

(print-puzzle (create-puzzle 0))
;-> ╔════╦════╦════╦════╗
;-> ║  1 ║  2 ║  3 ║  4 ║
;-> ╠════╬════╬════╬════╣
;-> ║  5 ║  6 ║  7 ║  8 ║
;-> ╠════╬════╬════╬════╣
;-> ║  9 ║ 10 ║ 11 ║ 12 ║
;-> ╠════╬════╬════╬════╣
;-> ║ 13 ║ 14 ║    ║ 15 ║
;-> ╚════╩════╩════╩════╝

Puzzle più complicato
(print-puzzle (create-puzzle 1000))
;-> ╔════╦════╦════╦════╗
;-> ║  9 ║    ║ 11 ║ 10 ║
;-> ╠════╬════╬════╬════╣
;-> ║ 15 ║ 13 ║  3 ║  6 ║
;-> ╠════╬════╬════╬════╣
;-> ║  4 ║ 14 ║  8 ║ 12 ║
;-> ╠════╬════╬════╬════╣
;-> ║  5 ║  2 ║  7 ║  1 ║
;-> ╚════╩════╩════╩════╝

Verifichiamo che i puzzle creati da quest'ultima funzione siano risolvibili:

(solvable (create-puzzle 100))
;-> true
(solvable (create-puzzle 200))
;-> true

Finalmente siamo arrivati ad implementare la funzione finale che gestisce tutto il gioco:

(define (puzzle15 level)
  (local (griglia num-mosse mossa mossa-row mossa-col zero zero-row zero-col end-game)
    (setq end-game nil)
    (setq num-mosse 0)
    ;(setq griglia '((10 2 6 4) (15 0 7 8) (9 1 11 13) (12 14 5 3)))
    (setq griglia (create-puzzle level))
    ;(setq griglia '((1 2 3 4) (5 6 7 8) (9 10 11 12) (13 14 0 15)))
    (println "Puzzle 15")
    (until end-game
      (print-puzzle griglia)
      ; input mossa
      (setq mossa (read-move griglia))
      (println { })
      ; aggiorna numero mosse
      (++ num-mosse)
      ; aggiornamento della griglia (applica mossa)
      (setq mossa-row (first mossa))
      (setq mossa-col (last mossa))
      (setq zero (ref 0 griglia))
      (setq zero-row (first zero))
      (setq zero-col (last zero))
      (swap (griglia zero-row zero-col) (griglia mossa-row mossa-col))
      ; controllo puzzle risolto
      (cond ((endgame? griglia)
              (print-puzzle griglia)
              (println "(" num-mosse ") - Bravo!!!")
              (setq end-game true))
      )
     )))

Iniziamo una partita:

(puzzle15 100)
Puzzle 15
;-> ╔════╦════╦════╦════╗
;-> ║ 10 ║ 12 ║  5 ║  8 ║
;-> ╠════╬════╬════╬════╣
;-> ║  9 ║  3 ║  7 ║  4 ║
;-> ╠════╬════╬════╬════╣
;-> ║ 13 ║    ║  6 ║ 14 ║
;-> ╠════╬════╬════╬════╣
;-> ║  1 ║  2 ║ 15 ║ 11 ║
;-> ╚════╩════╩════╩════╝
;-> (0) - Numero (1..15): 13
;->
;-> ╔════╦════╦════╦════╗
;-> ║ 10 ║ 12 ║  5 ║  8 ║
;-> ╠════╬════╬════╬════╣
;-> ║  9 ║  3 ║  7 ║  4 ║
;-> ╠════╬════╬════╬════╣
;-> ║    ║ 13 ║  6 ║ 14 ║
;-> ╠════╬════╬════╬════╣
;-> ║  1 ║  2 ║ 15 ║ 11 ║
;-> ╚════╩════╩════╩════╝
;-> (1) - Numero (1..15):


-----------
Numeri rari
-----------

I numeri rari sono quei numeri che quando aggiunti o sottratti al suo rovescio danno un quadrato perfetto. In altre parole, i numeri rari sono numeri interi positivi n dove:

  - n è espresso in base dieci
  - r è il contrario di n (cifre decimali)
  - n deve essere non palindromo (n ≠ r)
  - (n + r) è la somma
  - (n-r) è la differenza e deve essere positiva
  - la somma e la differenza devono essere quadrati perfetti

Sequenza OEIS: A035519
65, 621770, 281089082, 2022652202, 2042832002, 868591084757, 872546974178,
872568754178, 6979302951885, 20313693904202, 20313839704202, 20331657922202,
20331875722202, 20333875702202, ...

Funzione che verifica se un numero è un quadrato perfetto:

(define (square? num)
  (local (a)
    (setq a num)
    (while (> (* a a) num)
      (setq a (/ (+ a (/ num a)) 2))
    )
    (= (* a a) num)))

Non utilizziamo i big-integer, quindi possiamo arrivare a trovare solo i primi cinque numeri rari (limite dovuto alla funzione "square?"):

(setq MAX-INT 9223372036854775807)
(> MAX-INT (* 1e10 1e10))
;-> true

Funzione che verifica se un numero è un numero raro:

(define (rare? num)
  (local (rev sum diff)
    (setq rev (int (reverse (string num)) 0 10))
    (setq sum (+ num rev))
    (setq diff (- num rev))
    (cond ((< diff 0) nil)
          ((= num rev) nil)
          ((and (square? diff) (square? sum)) true)
          (true nil))))

(rare? 65)
;-> true

Funzione che calcola i numeri rari fino ad un dato numero:

(define (rare-to num)
  (for (i 10 num)
    (if (rare? i) (println i))))

(time (rare-to 1e6))
;-> 65
;-> 621770
;-> 1809.423

Però questo algoritmo è molto lento:

(time (rare-to 1e8))
;-> 65
;-> 621770
;-> 156984.385

(time (rare-to 1e9))
;-> 65
;-> 621770
;-> 281089082
;-> 2296520.643 ; circa 38 minuti

Proprietà dei numeri rari
-------------------------
Dato un numero ABCD...MNPQ con qualunque numero di cifre:

1) Il valore di A può essere solo 2,4,6,8 (i numeri rari non possono iniziare con una cifra dispari).

2) Se A = 2 allora risulta Q = 2 e B = P.
Se A = 4 allora Q = 0 e B - P = cifra pari positiva o negativa, cioè -8, -6, -4, -2, 0, 2, 4, 6, 8.
Se A = 6 allora Q = 0 o 5 e B - P = cifra dispari positiva o negativa cioè -9, -7, -5, -3, -1, 1, 3, 5, 7, 9.
Se A = 8 allora Q = 2, 3, 7 o 8: se Q = 2 allora B + P = 9, se Q = 3 allora B - P = 7 per B>P e B - P = -3 per B<P e B non può mai essere uguale a P, se Q = 7 allora B + P = 11 per B>1 e B + P = 1 per B<1, se Q = 8 allora B = P.
È chiaro dalla (1) e (2) sopra che se la prima e l'ultima cifra sono uguali, possono essere 2 o 8 e anche la seconda cifra B e P dovranno essere uguali. Anche la differenza tra la prima e l'ultima cifra, ad esempio A-Q di qualsiasi numero raro, può essere solo 0, 1, 4, 5 o 6. Il valore di Q non può mai essere 1, 4, 6, 9.

3) la radice digitale può avere solo i valori 2, 5, 8 o 9.

Le proprietà di cui sopra possono essere riassunte nella seguente forma tabellare:

 +---+-------+------------------------+
 | A |   Q   | B e P                  |
 +---+-------+------------------------+
 | 2 |   2   | B = P                  |
 +---+-------+------------------------+
 | 4 |   0   | |B - P| = pari         |
 +---+-------+------------------------+
 | 6 | 0 o 5 | |B - P| = dispari      |
 +---+-------+------------------------+
 | 8 |   2   | B + P = 9              |
 +---+-------+------------------------+
 | 8 |   3   | B - P = 7 o P - B = 3  |
 +---+-------+------------------------+
 | 8 |   7   | B + P = 11 o B + P = 1 |
 +---+-------+------------------------+
 | 8 |   8   | B = P                  |
 +---+-------+------------------------+

(define (prop num)
  (local (ns A B P Q)
    (setq ns (string num))
    (setq A (int (ns 0)))
    (setq B (int (ns 1)))
    (setq P (int (ns -2)))
    (setq Q (int (ns -1)))
    (cond ((odd? A) nil)
          ((= A 2) (and (= Q 2) (= B P)))
          ((= A 4) (and (= Q 0) (even? (abs (- B P)))))
          ((= A 6) (and (or (= Q 0) (= Q 5)) (odd? (abs (- B P)))))
          ((= A 8) (cond ((= Q 2) (= (+ P B) 9))
                         ((= Q 3) (or (= (- B P) 7) (= (- P B) 3)))
                         ((= Q 7) (or (= (+ B P) 11) (= (+ P B) 1)))
                         ((= Q 8) (= B P))
                         (true nil)
                   )
          )
     )
   ))

Proviamo la funzione sui numeri della sequenza OEIS:

(setq rare '(621770 281089082 2022652202 2042832002 868591084757 872546974178
872568754178 6979302951885 20313693904202 20313839704202 20331657922202
20331875722202 20333875702202))

(map prop rare)
;-> (true true true true true true true true true true true true true)

La funzione "rare?" diventa:

(define (rare? num)
  (if (prop num)
      (local (rev sum diff)
        (setq rev (int (reverse (string num)) 0 10))
        (setq sum (+ num rev))
        (setq diff (- num rev))
        (cond ((< diff 0) nil)
              ((= num rev) nil)
              ((and (square? diff) (square? sum)) true)
              (true nil)
        )
      )
      nil))

(time (rare-to 1e6))
;-> 65
;-> 621770
;-> 1575.227

(time (rare-to 1e8))
;-> 65
;-> 621770
;-> 163324.193

(time (rare-to 1e9))
;-> 65
;-> 621770
;-> 281089082
;-> 1582493.526 ; circa 26 minuti

Vediamo perchè questo algoritmo non è applicabile per grandi numeri (> 1e10).
Un ciclo "for" pulito (senza nessuna istruzione all'interno) fino a 1e10 ha la seguente durata:

(define (test-for n) (for (i 1 n)))
(time (test-for 1e10))
;-> 75291.609 ; 75 secondi

Se all'interno del ciclo inseriamo una sola operazione di addizione, allora il tempo di esecuzione diventa:

(define (test-for2 n) (for (i 1 n) (++ k)))
(time (test-for2 1e10))
;-> 280509.596 ; 280 secondi (4 minuti e 40 secondi)

Il tempo di esecuzione è troppo grande per poter processare qualcosa all'interno del ciclo.
Quindi questo approccio non è applicabile per calcolare i numeri rari con più di 10 cifre.


-------------
Patience Sort
-------------

L'ordinamento della pazienza (patience sort) è un algoritmo di ordinamento che prende il nome da una variante semplificata del gioco di carte della pazienza. Una variante dell'algoritmo calcola in modo efficiente la lunghezza e i valori della più lunga sottosequenza crescente in una data lista.

Il gioco inizia con un mazzo di carte mescolato. Le carte vengono distribuite una alla volta in una sequenza di pile sul tavolo, secondo le seguenti regole:

Inizialmente, non ci sono pile. La prima carta estratta forma una nuova pila composta dalla singola carta.
Ogni carta successiva viene posizionata sulla pila esistente più a sinistra la cui prima carta ha un valore maggiore o uguale al valore della nuova carta, o alla destra di tutte le pile esistenti, formando così una nuova pila.
Quando non ci sono più carte da distribuire, il gioco finisce.

Questo gioco di carte viene trasformato in un algoritmo di ordinamento a due fasi nel modo seguente:
Data una lista di n elementi da un dominio totalmente ordinato, considerare questa lista come una raccolta di carte e simulare il gioco di smistamento della pazienza. Quando il gioco è finito, recuperare la sequenza ordinata raccogliendo ripetutamente la carta minima visibile. In altre parole, eseguire una fusione k-way delle pile, ciascuna delle quali è ordinata internamente.

Algoritmo per trovare la sottosequenza crescente più lunga
Innanzitutto, eseguire l'algoritmo di ordinamento come descritto sopra. Il numero di pile è la lunghezza della sottosequenza più lunga. Ogni volta che una carta viene posizionata in cima a una pila, mettere un puntatore (indietro) sulla carta in cima alla pila precedente (che, per ipotesi, ha un valore inferiore a quello della nuova carta). Alla fine, seguire tutti i puntatori creati dalla prima carta nell'ultima pila per recuperare una sottosequenza decrescente della lunghezza più lunga. Il suo inverso è la sottosequenza crescente più lunga.

Vediamo un'implementazione dell'ordinamento della pazienza:

(define (patience lst)
  (local (pile i j minimo curr-riga len stop out)
  (setq len (length lst))
  (setq conta (array len '(0)))
  (setq pile (array len len '(0)))
  (setq out (array len '(nil)))
  (setq stop nil)
  (for (i 0 (- len 1))
    (setq stop nil)
    (for (j 0 (- len 1) 1 stop)
      (if (or (zero? (conta j)) (and (> (conta j) 0) (>= (pile j (- (conta j) 1)) (lst i))))
        (begin
          (setf (pile j (conta j)) (lst i))
          (++ (conta j))
          ;(println i { } j)
          (setq stop true)
        )
      )
    )
  )
  (setq minimo (pile 0 (- (conta 0) 1)))
  (setq curr-riga 0)
  (for (i 0 (- len 1))
    (for (j 0 (- len 1))
      (if (and (> (conta j) 0) (< (pile j (- (conta j) 1)) minimo))
        (begin
          (setq minimo (pile j (- (conta j) 1)))
          (setq curr-riga j)
        )
      )
    )
    (setf (out i) minimo)
    (-- (conta curr-riga))
    (setq stop nil)
    (for (j 0 (- len 1) 1 stop)
      (if (> (conta j) 0)
        (begin
          (setq minimo (pile j (- (conta j) 1)))
          (setq curr-riga j)
          (setq stop true)
        )
      )
    )
  )
  out))

(patience '(2 4 3 7 9 4 1 3 6 3 2))
;-> (1 2 2 3 3 3 4 4 6 7 9)

(patience (randomize (sequence -10 10)))
;-> (-10 -9 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9 10)


------------------
Lista degli indici
------------------

Supponiamo di avere una lista annidata e di voler conoscere la struttura della lista. Possiamo scrivere una funzione che elenca tutte le sotto-liste e i relativi elementi:

(define (elements-aux lst)
  (if (null? lst)
      '()
      (cond ((atom? lst)
             (push lst out -1))
            ((list? lst)
             (push lst out -1)
             (println $idx)
             (elements-aux (first lst))
             (elements-aux (rest lst)))
      )
  )
)

(define (elements lst)
  (let (out '())
    (dolist (el lst)
      (elements-aux el)
    )
    out))

(setq a '((1 2) ((2 (3)) (4 4)) (((7)))))

(elements a)
;-> ((1 2)
;->  1
;->  (2)
;->  2
;->  ((2 (3)) (4 4))
;->  (2 (3))
;->  2
;->  ((3))
;->  (3)
;->  3
;->  ((4 4))
;->  (4 4)
;->  4
;->  (4)
;->  4
;->  (((7)))
;->  ((7))
;->  (7)
;->  7)

Però quello che ci interessa non sono i valori, ma tutti gli indici della lista. Allora ho chiesto un aiuto al forum di newLISP (vedi il thread in fondo a questo articolo) e ho ottenuto la seguente funzione che genera la lista di tutti gli indici degli elementi di una lista data:

(define (index-list lst)
  (local (mylist mv)
    (setq mylist '())
    (define (h-index-list lst agg)
      (dolist (x lst)
        (setq mv (append agg (list $idx)))
        (push mv mylist -1)
        (if (list? x)
          (h-index-list x mv)))
      mylist)
  (h-index-list lst '())))

(setq lst '(1 2 3 4 5))
(setq i (index-list lst))
;-> ((0) (1) (2) (3) (4))
(lst (i 0))
;-> 1

(setq a '((1 2) ((2 (3)) (4 4)) (((7)))))
(setq i (index-list a))
;-> ((0) (0 0) (0 1) (1) (1 0) (1 0 0) (1 0 1) (1 0 1 0)
;->  (1 1) (1 1 0) (1 1 1) (2) (2 0) (2 0 0) (2 0 0 0))

Con questa lista di indici possiamo elencare tutti i valori delle sotto-liste e degli elementi della lista originale:

(dolist (el i) (println el { - } (a el)))
;-> (0) - (1 2)
;-> (0 0) - 1
;-> (0 1) - 2
;-> (1) - ((2 (3)) (4 4))
;-> (1 0) - (2 (3))
;-> (1 0 0) - 2
;-> (1 0 1) - (3)
;-> (1 0 1 0) - 3
;-> (1 1) - (4 4)
;-> (1 1 0) - 4
;-> (1 1 1) - 4
;-> (2) - (((7)))
;-> (2 0) - ((7))
;-> (2 0 0) - (7)
;-> (2 0 0 0) - 7
;-> (1 2)
;-> 1
;-> 2
;-> ((2 (3)) (4 4))
;-> (2 (3))
;-> 2
;-> (3)
;-> 3
;-> (4 4)
;-> 4
;-> 4
;-> (((7)))
;-> ((7))
;-> (7)
;-> 7

Quando creiamo una struttura dati con le liste creiamo spesso una struttura annidata, ad esempio supponiamo di voler memorizzare in una lista la seguente struttura-dati (uno studente e l'elenco degli esami superati):

Studente
--------
Identificativo: (nome cognome matricola)
Esami: (materia (voto-orale voto-scritto) professore)

Una lista che rappresenta la struttura sopra può essere la seguente:

alunno = ((nome cognome matricola) ((materia (voto-orale voto-scritto) professore)))

Per esempio:

(setq a1 '((mario rossi 7112) ((matematica (6 6) A) (storia (7 8) B) (scienze (5 5) A))))
;-> ((mario rossi 7112) ((matematica (6 6) A) (storia (7 8) B) (scienze (5 5) A)))

Adesso possiamo visualizzare le associazioni tra indici della lista e valori corrispondenti:

(setq i (index-list a1))
(dolist (el i) (println el { - } (a1 el)))
;-> (0) - (mario rossi 7112)
;-> (0 0) - mario
;-> (0 1) - rossi
;-> (0 2) - 7112
;-> (1) - ((matematica (6 6) A) (storia (7 8) B) (scienze (5 5) A))
;-> (1 0) - (matematica (6 6) A)
;-> (1 0 0) - matematica
;-> (1 0 1) - (6 6)
;-> (1 0 1 0) - 6
;-> (1 0 1 1) - 6
;-> (1 0 2) - A
;-> (1 1) - (storia (7 8) B)
;-> (1 1 0) - storia
;-> (1 1 1) - (7 8)
;-> (1 1 1 0) - 7
;-> (1 1 1 1) - 8
;-> (1 1 2) - B
;-> (1 2) - (scienze (5 5) A)
;-> (1 2 0) - scienze
;-> (1 2 1) - (5 5)
;-> (1 2 1 0) - 5
;-> (1 2 1 1) - 5
;-> (1 2 2) - A

In questo modo è molto più semplice gestire gli accessi alla nostra lista/struttura.

Ecco il thread originale del forum di newLISP:

List of indexes
---------------
Post by cameyo » Wed May 12, 2021 1:36 pm

How to create a list of indexes of all the elements of original list?
Example:
(setq lst '(1 (2 (3 4)) (5 6)))
(lst 0)
;-> 1
(lst 1)
;-> (2 (3 4))
(lst 1 0)
;-> 2
(lst 1 1)
;-> (3 4)
(lst 1 1 0)
;-> 3
(lst 1 1 1)
;-> 4
(lst 2)
;-> (5 6)
(lst 2 0)
;-> 5
(lst 2 1)
;-> 6

List of indexes:
((0) (1) (1 0) (1 1) (1 1 0) (1 1 1) (2) (2 0) (2 1))
or
(0 1 (1 0) (1 1) (1 1 0) (1 1 1) 2 (2 0) (2 1))
------------------------------------------------------------
Re: List of indexes
Post by fdb » Wed May 12, 2021 7:04 pm

Something like below? (not very elegant, I know)

(define (index-list lst)
  (setq mylist '())
  (define (h-index-list lst agg)
    (dolist (x lst)
      (setq mv (append agg (list $idx)))
      (push mv mylist -1)
      (if (list? x)
        (h-index-list x mv)))
    mylist)
  (h-index-list lst '()))
------------------------------------------------------------
Re: List of indexes
Post by rickyboy » Wed May 12, 2021 8:12 pm

Here's a version that uses recursive calls in a classic way (think, SICP) where even the loop is handled by recursive call. (Nota bene: This is not a good newLISP implementation because newLISP doesn't turn tail calls into loops. fdb's implementation is the better one for newLISP.)

(define (get-indices L (child 0) (parents '()) (result '()))
  (if (empty? L)
      result
      (list? (L 0))
      (get-indices (1 L) (+ 1 child) parents
                   (append (snoc result (snoc parents child))
                           (get-indices (L 0) 0 (snoc parents child))))
      (get-indices (1 L) (+ 1 child) parents
                   (snoc result (snoc parents child)))))

You will need this utility function, snoc, which acts like cons but does the reverse (it says it in the name lol :) : it takes the element argument and puts it at the end of the list. (Note also that the arguments are reversed as compared with cons.)

(define (snoc xs x) (push x xs -1))

(λx. x x) (λx. x x)
------------------------------------------------------------
Re: List of indexes
Post by rickyboy » Wed May 12, 2021 8:13 pm

You could also "factor out" the repeated code, but it may not make the code more readable.

(define (get-indices L (child 0) (parents '()) (result '()))
  (if (empty? L)
      result
      (get-indices (1 L) (+ 1 child) parents
        (append
          (snoc result (snoc parents child))
          (if (list? (L 0))
              (get-indices (L 0) 0 (snoc parents child))
              '())))))

(λx. x x) (λx. x x)
------------------------------------------------------------
Re: List of indexes
Post by cameyo » Wed May 12, 2021 8:38 pm

Thank you guys
Very nice solutions
------------------------------------------------------------


------------------
Buche sulle strada
------------------

Una macchina può riparare con una sezione tutte le buche lungo una strada fino a 3 unità di lunghezza. Un'unità di strada sarà rappresentata da un punto in una stringa. Ad esempio, "..." è una sezione di 3 unità di strada di lunghezza. Le buche sono contrassegnate con una "X" sulla strada e contano come 1 unità di lunghezza. Scrivere una funzione che, data una strada di lunghezza N, restituisce il minor numero possibile di sezioni che la macchina deve effettuare per riparare tutta la strada. Ecco alcuni esempi:

  strada       sezioni minime necessarie
  .X.          1
  .X ... X     2
  XXX.XXXX     3
  .X.XX.XX.X   3

(define (asfalta str)
  (local (idx len out)
    (setq out 0)
    (setq idx 0)
    (setq len (length str))
    (while (> len idx)
      (cond ((= (str idx) ".")
             (++ idx))
            ((= (str idx) "X")
             (setq idx (+ idx 3))
             (++ out))
      )
    )
    out))

(asfalta "...X..XX")
;-> 2
(asfalta "...X..X.X")
;-> 2
(asfalta "...X..X.X.")
;-> 2
(asfalta "...X..X..X.")
;-> 3
(asfalta "...X..X..X..")
;-> 3
(asfalta "...X..X..X...")
;-> 3
(asfalta "...X..X...X.")
;-> 3
(asfalta "...X..X...X..")
;-> 3
(asfalta "...X..X...X.")
;-> 3
(asfalta "...X..X...X")
;-> 3
(asfalta "XX.XX.XX.X")
;-> 4


----------------------
Storia delle variabili
----------------------

Qualche volta abbiamo bisogno di conoscere la storia di una o più variabili durante o dopo l'esecuzione di un programma. La soluzione seguente è valida solo per variabili di tipo numerico (ed è non molto elegante).

Per definire la variabile da storicizzare usiamo la funzione "storia":

(define (storia var-str val)
  (set (sym var-str) val)
  (set (sym (extend var-str "@")) (list val))
  val
)

Questa funzione prende il nome della variabile (passata come stringa) e il valore iniziale della variabile. Per esempio:

(storia "a" 1)
;-> 1

La funzione definisce anche una variabile globale di tipo lista denominata var-str"@" che contiene i valori sorici della variabile var-str:

a@
;-> (1)

Per aggiornare la variabile nel programma dobbiamo usare una funzione specifica "aggiorna"

(define (aggiorna var-str val)
  (local (expr log-var)
    (setq expr (string "(setq " var-str " " val")"))
    (eval-string expr)
    (setq log-var (string var-str "@"))
    (setq expr (string "(push " val " " log-var " -1)"))
    (eval-string expr)
    val
  ))

Anche questa funzione prende il nome della variabile (passata come stringa) e il valore da assegnare lla variabile. Per esempio:

(aggiorna "a" (add a 18 2))
;-> 21
a@
;-> (1 21)
(aggiorna "a" (add a a 2))
;-> 44
a@
;-> (1 21 44)

Nota: la lista a@ (var-str"@") è una variabile/simbolo globale.

L'implementazione può essere migliorata con delle macro per permettere la storicizzazione anche di stringhe e liste. Inoltre dovrebbe essere creato un contesto apposito, ma per le mie necessità è sufficiente.


----------------
Numeri di Chowla
----------------

Il numero di Chowla di un intero positivo n è definito come la somma dei divisori di n escludendo l'unità (1) e n.
La sequenza prende il nome dala matematico indiano Sarvadaman Chowla (1907-1995).

Sequenza OEIS A048050:
0, 0, 0, 2, 0, 5, 0, 6, 3, 7, 0, 15, 0, 9, 8, 14, 0, 20, 0, 21, 10, 13, 0, ...

Funzione che calcola la fattorizzazione di un numero:

(define (factor-group num)
  (if (= num 1) '((1 1))
    (letn (fattori (factor num)
          unici (unique fattori))
      (transpose (list unici (count unici fattori))))))

Funzione che calcola la somma dei divisori di un numero:

(define (divisors-sum num)
  (local (sum out)
    (if (= num 1) '1
        (begin
          (setq out 1)
          (setq lst (factor-group num))
          (dolist (el lst)
            (setq sum 0)
            (for (i 0 (last el))
              (setq sum (+ sum (pow (first el) i)))
            )
            (setq out (* out sum)))))))

Funzione che calcola il numero di Chowla per un dato numero:

(define (chowla num)
  (if (= num 1)
      0
      (- (divisors-sum num) num 1)))

Vediamo se otteniamo la stessa sequenza OEIS:

(map chowla (sequence 1 20))
;-> (0 0 0 2 0 5 0 6 3 7 0 15 0 9 8 14 0 20 0 21)


------------------
Secondi -> periodo
------------------

Scrivere una funzione che accetta in ingresso un numero intero positivo che rappresenta una durata in secondi e   restituisce una stringa che mostra la stessa durata scomposta in settimane, giorni, ore, minuti e secondi.
Per esempio:

  Secondi     Output
  7259        2h 59s
  86400       1d
  6000000     9wk 6d 10h 40m

Devono essere utilizzate le seguenti cinque unità:

  Unità              Codice    Conversione
  week (settimana)    w        1 week = 7 days
  day (giorno)        d        1 day = 24 hours
  hour (ora)          h        1 hour = 60 minutes
  minute (minuto)     m        1 minutes = 60 secondi
  second (secondo)    s        1 secondo = 1 secondo

Tuttavia, includere nell'output solo quantità con valori diversi da zero (ad esempio, restituire "1d" e non "0wk 1d, 0h 0m 0s").

Utilizziamo la seguente lista per memorizzare i codici e l'espressione di conversione:

(setq conv '(("w" (* 7 24 60 60 1))
             ("d"   (* 24 60 60 1))
             ("h"      (* 60 60 1))
             ("m"         (* 60 1))
             ("s"               1)))

La funzione è la seguente:

(define (periodo sec)
  (local (name expr val)
    (dolist (el conv)
      (setq name (el 0))
      (setq expr (eval (el 1)))
      ; valore della corrente unità
      (setq val (/ sec expr))
      ; numero di secondi rimasti
      ; (resto della divisione)
      (setq sec (% sec expr))
      (if (> val 0)
        (print val name " ")
      )
    )
    (println)))

Verifichiamo i risultati deglki esempi:

(periodo 7259)
;-> 2h 59s
(periodo 86400)
;-> 1d
(periodo 6000000)
;-> 9wk 6d 10h 40m
(periodo 12000)
;-> 3h 20m

Adesso scriviamo una funzione che converte i millisecondi in un periodo (può servire per convertire l'output della funzione "time"). Utilizziamo i seguenti valori di conversione (senza week):

(setq conv '(("d"   (* 24 60 60 1000))
             ("h"      (* 60 60 1000))
             ("m"         (* 60 1000))
             ("s"         (*  1 1000))
             ("ms"                 1)))

(define (period msec show)
  (local (conv unit expr val out)
    (setq conv '(("d" 86400000) ("h" 3600000) ("m" 60000) ("s" 1000) ("ms" 1)))
    (setq out '())
    (setq msec (int msec))
    (dolist (el conv)
      (setq unit (el 0))
      (setq expr (el 1))
      (setq val (/ msec expr))
      ; numero di millisecondi rimasti
      ; (resto della divisione)
      (setq msec (% msec expr))
      (push val out -1)
      (if (and (> val 0) show)
        (print val unit " ")
      )
    )
    (if show (println))
    out))

(period 1000 true)
;-> 1s
;-> (0 0 0 1 0)
(period 1184567 true)
;-> 19m 44s 567ms
;-> (0 0 19 44 567)
(period 163458000)
;-> (1 21 24 18 0)


-----------------------------------------------------
Partizione di una lista in due parti con somme uguali
-----------------------------------------------------

Determinare se è possibile partizionare una lista in due sotto-liste in modo che la somma di ogni sotto-lista sia la stessa. Per esempio, la lista di numeri A = (7 5 6 11 3 4) può essere divisa in due sotto-liste con la stessa somma (18) in due modi diversi:

a) (5 6 7) e (11 3 4)

b) (3 4 5 6) e (11 7)

Supponendo che la somma di tutti gli elementi della lista sia S, ciò implica che le due sotto-liste devono avere una somma uguale a S/2. Quidi se la somma di tutti gli elementi della lista è dispari, allora non è possibile suddividere la lista in due parti con somma uguale.

Se la somma degli elementi è pari, allora possiamo utilizzare due metodi per provare a suddividere la lista: brute-force e programmazione dinamica.

Metodo Brute-force
------------------
Questo è un metodo ricorsivo in cui consideriamo ogni possibile sottoinsieme della lista e controlliamo se la sua somma è uguale o meno alla somma totale S/2, eliminando l'ultimo elemento della lista ad ogni turno.
L'algoritmo è il seguente:
  1) Per ogni ricorsione del metodo, dividi il problema in due sottoproblemi in modo che:
    1.1) Creare un nuovo sottoinsieme della lista includendo l'ultimo elemento della lista se il suo valore non supera S/2 e ripetere il passaggio ricorsivo 1 di nuovo per il nuovo sottoinsieme.
    1.2) Creare un nuovo sottoinsieme della lista escludendo l'ultimo elemento della lista e ripetire il passaggio ricorsivo 2 di nuovo per il nuovo sottoinsieme.
    1.3) Se la somma di uno qualsiasi dei sottoinsiemi precedenti è uguale a S/2, restiture true altrimenti restituire nil (false).
  2) Se uno qualsiasi dei problemi di cui sopra restituisce true, restituire true, altrimenti restituire nil.

Implementazione metodo brute force:

(define (partition? lst)
  (let (sum (apply + lst))
    (cond ((odd? sum) nil)
          (true (subset lst (length lst) (/ sum 2))))))

(define (subset lst len sum)
  (catch
  (local (tmp)
    (if (zero? sum) (throw true))
    (if (and (zero? len) (!= sum 0)) (throw nil))
    (if (> (lst (- len 1)) sum)
        (throw (subset lst (- len 1) sum))
    )
    (or (subset lst (- len 1) sum) (subset lst (- len 1) (- sum (lst (- len 1))))))))

(partition? '(7 5 6 11 3 4))
;-> true
(partition? '(1 2 3 4 6 12))
;-> true
(partition? '(3 1 4 4))
;-> nil
(partition? '(6 4 3 2 3))
;-> true
(partition? '(6 -4 -3 2 3))
;-> true

La complessità temporale del caso peggiore vale O(2^n), dove n è il numero totale di elementi della lista.
La complessità spaziale vale O(n), che viene utilizzata per memorizzare lo stack della ricorsione.

Programmazione dinamica
-----------------------
Utilizzando la programmazione dinamica memorizziamo le valutazioni di ogni passaggio ricorsivo e riutilizziamo questi  valori qualora dovessimo ricalcolarli di nuovo nei passaggi futuri.

  Chi non ricorda il passato è condannato a ripeterlo.
  - Programmazione dinamica

In questo caso, creiamo una lista bidimensionale di elementi booleani che rappresentano vero (true) o falso (nil) a seconda che si possa creare un sottoinsieme avente somma uguale alla riga e con gli elementi di questo sottoinsieme rappresentati nella colonna. Decidiamo se aggiungere o meno un elemento nel sottoinsieme a seconda che il suo valore sia minore o meno della somma. Riempiamo la lista in modo bottom-up fino a raggiungere l'ultimo elemento dell'array, che sarà la risposta finale.

L'algoritmo è il seguente:
1) Per ogni elemento i nell'array e il valore di somma s (incrementato fino a raggiungere il valore S / 2),
  1.1) Controllare se il sottoinsieme con somma uguale a s può essere formato escludendo l'elemento i.
  1.2) Verificare la condizione che il valore dell'elemento sia inferiore a s,
      1.2.1) Se la condizione di cui sopra è vera, controlla se il sottoinsieme con somma uguale a s può essere formato includendo l'elemento i.
  1.3) Se una qualsiasi delle condizioni di cui sopra è vera, allora memorizzare vero (true) nel valore della lista in i-esima riga e s-esima colonna, cioè possiamo formare il sottoinsieme di elementi con somma uguale a s.

(define (partition? lst)
  (local (sum len dp)
    (setq len (length lst))
    (setq sum (apply + lst))
    (cond ((odd? sum) nil)
          (true
           (let (s (/ sum 2))
            (setq dp (array (+ len 1) (+ s 1) '(nil)))
            (for (i 0 len)
              (setf (dp i 0) true)
            )
            (for (i 1 len)
              (for (j 1 s)
                (setf (dp i j) (dp (- i 1) j))
                (if (>= j (lst (- i 1)))
                    (setf (dp i j) (or (dp i j) (dp (- i 1) (- j (lst (- i 1))))))
                )
              )
            )
            (dp len s))
          ))))

(partition? '(7 5 6 11 3 4))
;-> true
(partition? '(1 2 3 4 6 12))
;-> true
(partition? '(3 1 4 4))
;-> nil
(partition? '(6 4 3 2 3))
;-> true

La complessità temporale del caso peggiore vale O(n*s), dove n è il numero totale di elementi della lista e s è il valore della somma di tutti gli elementi della lista.
La complessità spaziale vale O(n*s), che viene utilizzata per memorizzare la matrice di tutti i sottoinsiemi con le relative somme.

Nota: l'algoritmo che usa la programmazione dinamica è molto più veloce dell'algoritmo brute-force, ma non funziona con liste che hanno numeri negativi. Per esempio:

(partition? '(6 -4 -3 2 3))
;-> ERR: array index out of bounds : 5

Nota: il problema della partizione è indicato come un problema NP-completo in informatica e la soluzione di cui sopra è una soluzione di programmazione dinamica in tempo pseudo-polinomiale. Viene anche definito "il problema difficile più semplice".


-------------------
Numeri di Zumkeller
-------------------
I numeri Zumkeller sono l'insieme di numeri i cui divisori possono essere partizionati in due insiemi disgiunti che si sommano allo stesso valore. Ogni somma deve contenere valori di divisori che non sono nell'altra somma e tutti i divisori devono essere nell'una o nell'altra. Non ci sono restrizioni sul modo in cui i divisori devono essere partizionati, solo che le somme delle due partizione devono essere sono uguali.
Per esempio:
6 è un numero Zumkeller: i divisori (1 2 3 6) possono essere partizionati in due gruppi (1 2 3) e (6) che sommano entrambi a 6.
10 non è un numero Zumkeller: i divisori (1 2 5 10) non possono essere suddivisi in due gruppi in alcun modo che sommino entrambi allo stesso valore.
12 è un numero Zumkeller: i divisori (1 2 3 4 6 12) possono essere partizionati in due gruppi (1 3 4 6) e (2 12) che sommano entrambi a 14.

I numeri pari di Zumkeller sono comuni mentre i numeri dispari di Zumkeller lo sono molto meno. Per valori inferiori a  un milione (10^6), c'è almeno un numero Zumkeller ogni 12 numeri interi consecutivi e la stragrande maggioranza di essi è pari.

Sequenza OEIS A083207:
  6, 12, 20, 24, 28, 30, 40, 42, 48, 54, 56, 60, 66, 70, 78, 80, 84,
  88, 90, 96, 102, 104, 108, 112, 114, 120, 126, 132, 138, 140, 150,
  156, 160, 168, 174, 176, 180, 186, 192, 198, 204, 208, 210, 216,
  220, 222, 224, 228, 234, 240, 246, 252, 258, 260, 264, 270, 272, ...

Funzione che calcola tutti i divisori di un numero:

(define (divisors num)
  (local (f out)
    (cond ((= num 1) '(1))
          (true
           (setq f (factor-group num))
           (setq out '())
           (divisors-aux 0 1)
           (sort out)))))
; funzione ausiliaria
(define (divisors-aux cur-index cur-divisor)
  (cond ((= cur-index (length f))
         (push cur-divisor out -1)
        )
        (true
         (for (i 0 (f cur-index 1))
           (divisors-aux (+ cur-index 1) cur-divisor)
           (setq cur-divisor (* cur-divisor (f cur-index 0)))
         ))))

Funzione che fattorizza un numero:

(define (factor-group num)
  (if (= num 1) '((1 1))
    (letn (fattori (factor num)
          unici (unique fattori))
      (transpose (list unici (count unici fattori))))))

Funzione che verifica se una lista può essere partizionata in due sotto-liste con somma uguale:

(define (partition? lst)
  (local (sum len dp)
    (setq len (length lst))
    (setq sum (apply + lst))
    (cond ((odd? sum) nil)
          (true
           (let (s (/ sum 2))
            (setq dp (array (+ len 1) (+ s 1) '(nil)))
            (for (i 0 len)
              (setf (dp i 0) true)
            )
            (for (i 1 len)
              (for (j 1 s)
                (setf (dp i j) (dp (- i 1) j))
                (if (>= j (lst (- i 1)))
                    (setf (dp i j) (or (dp i j) (dp (- i 1) (- j (lst (- i 1))))))
                )
              )
            )
            (dp len s))
          ))))

Funzione che verifica se un dato numero è un numero di Zumkeller:

(define (zumkeller? num)
  (local (divs sum abund)
    (setq divs (divisors num))
    (setq sum (apply + divs))
    (cond ((odd? sum) nil)
          ((odd? num)
           (setq abund (- sum (* 2 num)))
           ; se num è dispari usiamo l'ottimizzazione 'abundant odd number'
           (and (> abund 0) (even? abund)))
          ; se num e sum sono pari, allora verifichiamo la partizione
          (true (partition? divs))
    )))

(zumkeller? 30)
;-> true

Funzione che calcola i numeri di Zumkeller fino ad dato numero:

(define (zumkeller-to num)
  (let (out '())
    (for (i 1 num)
      (if (zumkeller? i)
          (push i out -1)))
    out))

(zumkeller-to 200)
;-> (6 12 20 24 28 30 40 42 48 54 56 60 66 70 78 80
;->  84 88 90 96 102 104 108 112 114 120 126 132 138
;->  140 150 156 160 168 174 176 180 186 192 198)

Calcoliamo i tempi di esecuzione:

(time (zumkeller-to 1000))
;-> 919.568
(time (zumkeller-to 2000))
;-> 4234.699
(time (zumkeller-to 10000))
;-> 137405.41

La funzione non è molto veloce.

Proviamo a vedere come varia la frequenza dei numeri di Zumkeller pari e dispari al crescere di n.

(define (zumkeller-freq num)
  (local (np nd)
    (setq np 0 nd 0)
    (for (i 1 num)
      (if (zumkeller? i)
          (if (odd? i)
              (++ nd)
              (++ np)
          )
      )
    )
    (println (format "%s%6d %5.2f%s %5.2f%s"
    "   pari:" np (mul 100 (div np num)) "%" (mul 100 (div np (+ np nd))) "%"))
    (println (format "%s%6d %5.2f%s %5.2f%s"
    "dispari:" nd (mul 100 (div nd num)) "%" (mul 100 (div nd (+ np nd))) "%"))))

(zumkeller-freq 1000)
;->    pari:   223 22.30% 99.55%
;-> dispari:     1  0.10%  0.45%
(zumkeller-freq 10000)
;->    pari:  2271 22.71% 99.00%
;-> dispari:    23  0.23%  1.00%
(zumkeller-freq 100000)  ; ci vuole molto tempo...
;->    pari: 22843 22.84% 99.10%
;-> dispari:   208  0.21%  0.90%

Vediamo i primi n numeri di Zumkeller dispari che non terminano con 5:

(define (zumkeller-odd num)
  (local (nd)
    (setq nd 0)
    (setq i 1)
    (while (< nd num)
      (if (!= (% i 10) 5)
          (if (zumkeller? i)
              (println (++ nd) { - } i)))
      (++ i 2))))

(zumkeller-odd 100)
;-> 1 - 81081
;-> 2 - 153153
;-> 3 - 171171
;-> 4 - 189189
;-> 5 - 207207
;-> 6 - 223839
;-> 7 - 243243
;-> 8 - 261261
;-> 9 - 279279
;-> 10 - 297297
;-> 11 - 351351
;-> 12 - 459459
;-> ...
;-> 96 - 2963961
;-> 97 - 2980593
;-> 98 - 2999997
;-> 99 - 3054051
;-> 100 - 3072069


------------------
Numeri di Leonardo
------------------

I numeri Leonardo (serie di Leonardo) sono una sequenza di numeri definita da:

  L(0) = 1
  L(1) = 1
  L(n) = L(n-1) + L(n-2) + 1

  dove il + 1 sarà qui noto come il numero di aggiunta.

I numeri di Leonardo sono legati ai numeri di Fibonacci tramite la seguente relazione:

  L(n) = 2 * Fib(n + 1) - 1

I primi numeri di Leonardo (sequenza OEIS A001595) sono i seguenti:

 1 1 3 5 9 15 25 41 67 109 177 287 465 753 1219 1973 3193 5167 8361 ···

Scriviamo una funzione iterativa:

(define (leonardo L0 L1 sum num)
  (local (out tmp)
    (setq out (list L0 L1))
    (for (i 3 num)
      (push (+ L0 L1 sum) out -1)
      (setq tmp L0)
      (setq L0 L1)
      (setq L1 (+ L1 tmp sum))
    )
    out))

(leonardo 1 1 1 20)
;-> (1 1 3 5 9 15 25 41 67 109 177 287 465 753 1219 1973 3193 5167 8361 13529)

Se poniamo L0 = 1, L1 = 1 e sum = 0, allora otteniamo la sequenza di Fibonacci:

(leonardo 0 1 0 20)
;-> (0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181)


-------------------
Frequenza caratteri
-------------------

Aprire un file di testo e contare le occorrenze di ogni lettera.
Contare solo i caratteri ASCII da 32 a 126.

(define (freq-chars nomefile)
  (local (file fr out)
    (setq fr (array 127 '(0)))
    (setq file (open nomefile "read"))
    (while (setq line (read-line file))
      (dostring (ch line)
        ; solo caratteri ASCII (32-126)
        (if (and (>= ch 32) (<= ch 126))
            (++ (fr ch))
        )
      )
    )
    (close file)
    (setq tot (apply + (array-list fr)))
    (println "File: " nomefile)
    (println "Caratteri ASCII: " tot)
    (for (i 32 126)
      (println (format "%s%s%6d%s%5.2f"
                (char i) " - " (fr i) " - " (mul 100 (div (fr i) tot))))
    )
    ))

(freq-chars "newLISP-Note.lsp")
;-> File: newLISP-Note.lsp
;-> Caratteri ASCII: 3229530
;->   - 704059 - 21.80
;-> ! -    715 -  0.02
;-> " -  27572 -  0.85
;-> # -   1297 -  0.04
;-> $ -    527 -  0.02
;-> % -   1337 -  0.04
;-> & -     99 -  0.00
;-> ' -   9170 -  0.28
;-> ( -  96370 -  2.98
;-> ) -  96977 -  3.00
;-> * -   9263 -  0.29
;-> + -   9387 -  0.29
;-> , -  11284 -  0.35
;-> - - 104385 -  3.23
;-> . -  20989 -  0.65
;-> / -   3470 -  0.11
;-> 0 -  44895 -  1.39
;-> 1 -  49245 -  1.52
;-> 2 -  32763 -  1.01
;-> 3 -  23072 -  0.71
;-> 4 -  18349 -  0.57
;-> 5 -  17760 -  0.55
;-> 6 -  15716 -  0.49
;-> 7 -  14520 -  0.45
;-> 8 -  14380 -  0.45
;-> 9 -  16949 -  0.52
;-> : -   9331 -  0.29
;-> ; -  18388 -  0.57
;-> < -   1583 -  0.05
;-> = -  33884 -  1.05
;-> > -  14902 -  0.46
;-> ? -   2671 -  0.08
;-> @ -    234 -  0.01
;-> A -   5516 -  0.17
;-> B -   2827 -  0.09
;-> C -   4489 -  0.14
;-> D -   2802 -  0.09
;-> E -   3595 -  0.11
;-> F -   2358 -  0.07
;-> G -   1224 -  0.04
;-> H -    994 -  0.03
;-> I -   6139 -  0.19
;-> J -    366 -  0.01
;-> K -    512 -  0.02
;-> L -   7557 -  0.23
;-> M -   2586 -  0.08
;-> N -   3564 -  0.11
;-> O -   3135 -  0.10
;-> P -   5643 -  0.17
;-> Q -   1718 -  0.05
;-> R -   2576 -  0.08
;-> S -   5568 -  0.17
;-> T -   2950 -  0.09
;-> U -   1509 -  0.05
;-> V -   1277 -  0.04
;-> W -    611 -  0.02
;-> X -    994 -  0.03
;-> Y -    452 -  0.01
;-> Z -    491 -  0.02
;-> [ -   1353 -  0.04
;-> \ -    924 -  0.03
;-> ] -   1350 -  0.04
;-> ^ -   1167 -  0.04
;-> _ -   1297 -  0.04
;-> ` -     10 -  0.00
;-> a - 147948 -  4.58
;-> b -  20117 -  0.62
;-> c -  61092 -  1.89
;-> d -  62168 -  1.92
;-> e - 202033 -  6.26
;-> f -  31728 -  0.98
;-> g -  26543 -  0.82
;-> h -  18604 -  0.58
;-> i - 176672 -  5.47
;-> j -   1644 -  0.05
;-> k -   4222 -  0.13
;-> l - 104036 -  3.22
;-> m -  59301 -  1.84
;-> n - 131782 -  4.08
;-> o - 139597 -  4.32
;-> p -  50090 -  1.55
;-> q -  14166 -  0.44
;-> r - 109208 -  3.38
;-> s - 100981 -  3.13
;-> t - 127276 -  3.94
;-> u -  62764 -  1.94
;-> v -  22856 -  0.71
;-> w -   6012 -  0.19
;-> x -  11657 -  0.36
;-> y -   8256 -  0.26
;-> z -  19150 -  0.59
;-> { -    677 -  0.02
;-> | -   5120 -  0.16
;-> } -    684 -  0.02
;-> ~ -     49 -  0.00

Da notare che il 3% dei caratteri sono "(" e ")"... sicuramente è un testo che parla di LISP.


----------------
Frequenza parole
----------------

Aprire un file di testo e contare le occorrenze e la frequenza di ogni parola.

Funzione che calcola il numero e la frequenza degli elementi della lista data:

(define (calc-freq lst)
  (local (tot palo conta out)
    ; numero totale degli elementi della lista
    (setq tot (length lst))
    ; (println tot)
    (cond ((= lst '()) '())
          (true
           (setq out '())
           (setq palo (first lst))
           (setq conta 0)
           (dolist (el lst)
              ; se l'elemento è uguale al precedente aumentiamo il suo conteggio
              (if (= el palo) (++ conta)
                  ; altrimenti costruiamo la coppia (conta el) e la aggiungiamo al risultato
                  (begin (push (list conta palo (mul 100 (div conta tot))) out -1)
                         (setq conta 1)
                         (setq palo el)
                  )
              )
           )
           ; aggiungiamo l'ultima tripla di valori
           ;(extend out (list(list conta palo (mul 100 (div conta tot)))))
           (push (list conta palo (mul 100 (div conta tot))) out -1)
          )
    )
    out))

Funzione che calcola il numero e la frequenza delle parole di un file:

(define (freq-words nomefile)
  (local (data)
    ; importa tutte le parole del file in una lista
    (setq data (parse (lower-case (read-file nomefile)) {\W} 0))
    ; toglie le parole nulle ""
    (setq data (clean null? data))
    ; ordina le parole della lista
    (sort data)
    ; calcola il numero e la frequenza delle parole
    (calc-freq data)))

Proviamo la funzione con il romanzo di Conan Doyle "The Sign of Four":

(silent (setq wf (freq-words "sign-of-four.txt")))

Vediamo le prime 10 parole (ordine alfabetico):

(slice wf 0 10)
;-> ((1 "1857" 0.002282375496416671)
;->  (1 "1871" 0.002282375496416671)
;->  (2 "1878" 0.004564750992833341)
;->  (3 "1882" 0.006847126489250011)
;->  (1 "221b" 0.002282375496416671)
;->  (1 "28th" 0.002282375496416671)
;->  (3 "3" 0.006847126489250011)
;->  (1 "340" 0.002282375496416671)
;->  (2 "34th" 0.004564750992833341)
;->  (1 "37" 0.002282375496416671))

Vediamo le ultime 10 parole (ordine alfabetico):

(slice wf -10 10)
;-> ((2 "yonder" 0.004564750992833341)
;->  (543 "you" 1.239329894554252)
;->  (19 "young" 0.04336513443191674)
;->  (107 "your" 0.2442141781165838)
;->  (7 "yours" 0.0159766284749167)
;->  (9 "yourself" 0.02054137946775004)
;->  (2 "yourselves" 0.004564750992833341)
;->  (3 "youth" 0.006847126489250011)
;->  (1 "zigzag" 0.002282375496416671)
;->  (2 "zum" 0.004564750992833341))

Vediamo le 10 parole più frequenti:

(silent (sort wf >))
(slice wf 0 10)
;-> ((2341 "the" 5.343041037111425)
;->  (1237 "i" 2.823298489067422)
;->  (1187 "and" 2.709179714246588)
;->  (1122 "of" 2.560825306979504)
;->  (1095 "a" 2.499201168576254)
;->  (1093 "to" 2.494636417583421)
;->  (697 "it" 1.590815721002419)
;->  (681 "in" 1.554297713059753)
;->  (645 "he" 1.472132195188753)
;->  (631 "that" 1.440178938238919))

Nota: la lista delle frequenze delle parole può servire anche per trovare le parole con errori di ortografia.


------------
Magic 8-Ball
------------

La Magic 8-Ball è una sfera di plastica, simile alla palla da biliardo numero otto, che viene utilizzata per predire il futuro o per chiedere consigli. È stata inventata nel 1950 da Albert Carter e Abe Bookman ed è attualmente prodotta da Mattel. L'utente fa una domanda del tipo si/no alla palla, quindi la gira per rivelare la risposta che compare in una finestra sulla palla. Una Magic 8 Ball standard ha 20 possibili risposte, di cui: 10 risposte affermative, 5 risposte evasive e 5 risposte negative.

Versione inglese:

Affirmative
-----------
- It is Certain.
- It is decidedly so.
- Without a doubt.
- Yes definitely.
- You may rely on it.
- As I see it, yes.
- Most likely.
- Outlook good.
- Yes.
- Signs point to yes.

Non-committal
-------------
- Reply hazy, try again.
- Ask again later.
- Better not tell you now.
- Cannot predict now.
- Concentrate and ask again.

Negative
--------
- Don't count on it.
- My reply is no.
- My sources say no.
- Outlook not so good.
- Very doubtful.

(define (eight-ball)
(catch
  (local (responses question)
    (setq responses
         '("It is certain" "It is decidedly so" "Without a doubt"
           "Yes definitely" "You may rely on it" "As I see it, yes"
           "Most likely" "Outlook good" "Yes" "Signs point to yes"
           "Reply hazy try again" "Ask again later"
           "Better not tell you now" "Cannot predict now"
           "Concentrate and ask again" "Don't count on it"
           "My reply is no" "My sources say no" "Outlook not so good"
           "Very doubtful"))
    (while true
      (println "\nWhat do you want to know?")
      (setq question (read-line))
      (if (= question "exit") (throw 'good-luck))
      (sleep 1000)
      (println (responses (rand 20)))
    ))))

(eight-ball)

;-> What do you want to know?
;-> I'm the best?
;-> Ask again later

;-> What do you want to know?
;-> newLISP?
;-> Yes definitely

;-> What do you want to know?
;-> exit
;-> good-luck

Versione italiana:

Affermative
-----------
- È certo.
- È decisamente così.
- Senza dubbio
- Si, assolutamente
- Puoi contarci.
- Per come la vedo io, sì.
- Molto probabile
- Buone prospettive.
- Si.
- I segni indicano sì.

Evasive
-------
- Risposta confusa, riprova.
- Chiedilo di nuovo più tardi.
- Meglio non dirtelo ora.
- Non posso prevedere adesso.
- Concentrati e chiedi di nuovo.

Negative
--------
- Non contarci.
- La mia risposta è no.
- Le mie fonti dicono di no.
- Prospettive non così buone.
- Molto dubbioso.

(define (otto)
(catch
  (local (responses question)
    (setq responses
        '("È certo" "È decisamente così" "Senza dubbi" "Si, assolutamente"
          "Puoi contarci" "Per come la vedo io, sì" "Molto probabile"
          "Buone prospettive" "Si" "I segni indicano sì"
          "Risposta confusa, riprova" "Chiedilo di nuovo più tardi"
          "Meglio non dirtelo ora" "Non posso prevedere adesso"
          "Concentrati e chiedi di nuovo" "Non contarci"
          "La mia risposta è no" "Le mie fonti dicono di no"
          "Prospettive non così buone" "Molto dubbioso"))
    (while true
      (println "\nChe cosa vuoi sapere?")
      (setq question (read-line))
      (if (= question "esci") (throw 'buona-fortuna))
      (sleep 1000)
      (println (responses (rand 20)))
    ))))

(otto)

;-> Che cosa vuoi sapere?
;-> Torino salvo?
;-> Molto probabile

;-> Che cosa vuoi sapere?
;-> Tanti soldi?
;-> Concentrati e chiedi di nuovo

;-> Che cosa vuoi sapere?
;-> esci
;-> buona-fortuna


-------
I Ching
-------

Scriviamo un programma per generare casualmente uno dei 64 esagrammi degli "I Ching". Per informazioni dettagliate consultare:

"I Ching. Il libro dei mutamenti." a cura di Richard Wilhelm, Traduzione di Veneziani e Ferrara. Editore Adelphi, 1995

Un esagramma è un simbolo costituito da sei linee sovrapposte. Le linee possono essere di 4 tipi:

  1) linea (yin) spezzata mobile:   ■■■■■  ■■■■■∙
  2) linea (yang) intera fissa:     ■■■■■■■■■■■■
  3) linea (yin) spezzata fissa:    ■■■■■  ■■■■■
  4) linea (yang) intera mobile:    ■■■■■■■■■■■■∙

Le linee intere sono linee yang, le linee spezzate sono linee yin. Ciascuna di queste linee può presentarsi sotto due forme: fissa e mobile.

L'esagramma viene costruito generando casualmente sei linee partendo dal basso e proseguendo verso l'alto (cioè la prima linea è quella più in basso, mentre la sesta e ultima linea è quella più in alto). Il numero di esagrammi è pari a 2^6 = 64.

Esempio di esagramma:

  6   ■■■■■  ■■■■■∙
  5   ■■■■■■■■■■■■
  4   ■■■■■  ■■■■■
  3   ■■■■■■■■■■■■∙
  2   ■■■■■■■■■■■■
  1   ■■■■■■■■■■■■

Tradizionalmente la generazione casuale dell'esagramma utilizza due metodi che hanno lo scopo di generare una serie di sei numeri compresi tra 6 e 9 (oppure 1 e 4), che vengono trasformati nelle sei linee dell'esagramma. Adesso possono presentarsi due casi:

1) Se l'esagramma ottenuto non contiene linee mobili, si ricerca semplicemente l'esagramma nel testo dell'I Ching e il responso dell'oracolo sarà dato dal testo generale che accompagna l'esagramma.

2) Se l'esagramma ottenuto contiene linee mobili, esso muterà in un secondo esagramma che viene ricavato dal primo ribaltando le linee mobili nel loro opposto, e cioè:
- la linea (yin) spezzata mobile ■■■■■  ■■■■■∙ diventerà una linea (yang) intera fissa ■■■■■■■■■■■■
- la linea (yang) fissa mobile ■■■■■■■■■■■■∙ diventerà una linea (yin) spezzata fissa ■■■■■  ■■■■■
In questo caso, il responso dell'oracolo sarà dato:
a) dal testo generale del primo esagramma ottenuto (che viene cercato nel testo dell'I CHING senza considerare le linee mobili, cioè come se fosse composto solo da linee fisse)
b) dal testo delle specifiche linee mobili del primo esagramma (contate sempre dal basso verso l'alto)
c) dal testo generale del secondo esagramma ottenuto.

In generale, possiamo dire che il primo esagramma rappresenta la situazione attuale o di partenza, le sue linee mobili rappresentano i mutamenti che si verificheranno entro breve tempo, mentre il secondo esagramma rappresenta il risultato finale (spiegazioni più dettagliate sul modo di interpretare l'oracolo nei vari casi si possono trovare nel libro citato sopra).

I due metodi per generare l'esagramma sono:
1) il metodo delle monete
2) il metodo degli steli di millefoglie

Da un punto di vista del calcolo delle probabilità i due metodi non sono uguali poichè assegnano probabilità differenti al processo di estrazione delle linee. I due metodi non differiscono tanto per il carattere, "Yin" (spezzata) o "Yang" (fissa), delle linee risultanti, quanto piuttosto per il tipo di linea, fissa o mobile. La tabella seguente mostra i valori di probabilità associata ad ogni evento dei due metodi:

  Probabilità delle linee   Monete      Steli
  -----------------------------------------------
  1) linea spezzata mobile    1/8     4/64 = 1/16
  2) linea intera fissa       3/8    20/64 = 5/16
  3) linea spezzata fissa     3/8    28/64 = 7/16
  4) linea intera mobile      1/8    12/64 = 3/16

Il nostro programma genera i due esagrammi (e i relativi numeri) che dovranno essere sottoposti ad interpretazione utilizzandon il libro citato sopra.

Per la rappresentazione degli esagrammi utilizziamo la seguente lista:

(setq lsm "■■■■■  ■■■■■∙") ; yin mobile  -  spezzata mobile
(setq lif "■■■■■■■■■■■■")  ; yang fissa  -  intera fissa
(setq lsf "■■■■■  ■■■■■")  ; yin fissa   -  spezzata fissa
(setq lim "■■■■■■■■■■■■∙") ; yang mobile -  intera mobile

(setq linee '("" "■■■■■  ■■■■■∙" "■■■■■■■■■■■■" "■■■■■  ■■■■■" "■■■■■■■■■■■■∙"))
(setq linee '("" lsm lif lsf lim))

Gli indici e i valori della lista sono:

  1 = "■■■■■  ■■■■■∙"  ;spezzata mobile
  2 = "■■■■■■■■■■■■ "  ;intera fissa
  3 = "■■■■■  ■■■■■ "  ;spezzata fissa
  4 = "■■■■■■■■■■■■∙"  ;intera mobile

Funzione che genera una linea con il metodo della monete (genera un numero da 1 a 4):

(define (linea-monete)
  (let (val (rand 8))
    (cond ((zero? val) 1)
          ((and (>= val 1) (<= val 3)) 2)
          ((and (>= val 4) (<= val 6)) 3)
          ((= val 7) 4))))

(linea-monete)
;-> 3

Controllo correttezza:
(setq f (array 5 '(0)))
(for (i 1 1000000)
  (++ (f (linea-monete))))
f
;-> (0 124759 375367 375260 124614)
(div 3 8)
;-> 0.375
(div 8)
;-> 0.125

Funzione che genera una linea con il metodo degli steli di millefoglie (genera un numero da 1 a 4):

(define (linea-steli)
  (let (val (rand 64))
    (cond ((and (>= val 0) (<= val 3)) 1)
          ((and (>= val 4) (<= val 23)) 2)
          ((and (>= val 24) (<= val 51)) 3)
          ((and (>= val 52) (<= val 63)) 4))))

(linea-steli)
;-> 3

Controllo correttezza:
(setq f (array 5 '(0)))
(for (i 1 1000000)
  (++ (f (linea-steli))))
f
;-> (0 62625 312456 437907 187012)
(div 4 64)
;-> 0.0625
(div 20 64)
;-> 0.3125
(div 28 64)
;-> 0.4375
(div 12 64)
;-> 0.1875

Funzione che genera i due esagrammi che ha come parametro il metodo da utilizzare per generare casualmente le linee (1=monete (default) 2=steli):

(define (ching metodo)
  (local (esagrammi linee linea esa-A esa-AA esa-B num-AA num-B)
    ; metodo da utilizzare (monete = 1 oppure steli = 2)
    (if (and (!= metodo 1) (!= metodo 2)) (setq metodo 1))
    ; rappresentazione dei 64 esagrammi (1..64)
    (setq esagrammi '((0)
        (2 2 2 2 2 2) (3 3 3 3 3 3) (3 2 3 3 3 2) (2 3 3 3 2 3) (3 2 3 2 2 2)
        (2 2 2 3 2 3) (3 3 3 3 2 3) (3 2 3 3 3 3) (2 2 3 2 2 2) (2 2 2 3 2 2)
        (3 3 3 2 2 2) (2 2 2 3 3 3) (2 2 2 2 3 2) (2 3 2 2 2 2) (3 3 3 2 3 3)
        (3 3 2 3 3 3) (3 2 2 3 3 2) (2 3 3 2 2 3) (3 3 3 3 2 2) (2 2 3 3 3 3)
        (2 3 2 3 3 2) (2 3 3 2 3 2) (2 3 3 3 3 3) (3 3 3 3 3 2) (2 2 2 3 3 2)
        (2 3 3 2 2 2) (2 3 3 3 3 2) (3 2 2 2 2 3) (3 2 3 3 2 3) (2 3 2 2 3 2)
        (3 2 2 2 3 3) (3 3 2 2 2 3) (2 2 2 2 3 3) (3 3 2 2 2 2) (2 3 2 3 3 3)
        (3 3 3 2 3 2) (2 2 3 2 3 2) (2 3 2 3 2 2) (3 2 3 2 3 3) (3 3 2 3 2 3)
        (2 3 3 3 2 2) (2 2 3 3 3 2) (3 2 2 2 2 2) (2 2 2 2 2 3) (3 2 2 3 3 3)
        (3 3 3 2 2 3) (3 2 2 3 2 3) (3 2 3 2 2 3) (3 2 2 2 3 2) (2 3 2 2 2 3)
        (3 3 2 3 3 2) (2 3 3 2 3 3) (2 2 3 2 3 3) (3 3 2 3 2 2) (3 3 2 2 3 2)
        (2 3 2 2 3 3) (2 2 3 2 2 3) (3 2 2 3 2 2) (2 2 3 3 2 3) (3 2 3 3 2 2)
        (2 2 3 3 2 2) (3 3 2 2 3 3) (3 2 3 2 3 2) (2 3 2 3 2 3)))
    ; lista dei tipi di linee
    (setq linee '("" "■■■■■  ■■■■■∙" "■■■■■■■■■■■■" "■■■■■  ■■■■■" "■■■■■■■■■■■■∙"))
    ; inizializza il generatore di numeri casuali
    (seed (time-of-day))
    (setq esa-A '())
    (setq esa-B '())
    ; Crea esagrammi A e B
    ; la prima linea è quella più in basso
    ; (l'ultima nelle liste esa-A e esa-B)
    ; la sesta (ultima) linea è quella più in alto
    ; (la prima nelle liste esa-A e esa-B)
    (for (i 1 6)
      (if (= metodo 1)
          (setq linea (linea-monete))
          (setq linea (linea-steli))
      )
      ; esagramma A
      (push linea esa-A)
      ; esagramma B
      (cond ((= linea 1) (push 2 esa-B) (push 3 esa-AA))
            ((= linea 2) (push 2 esa-B) (push 2 esa-AA))
            ((= linea 3) (push 3 esa-B) (push 3 esa-AA))
            ((= linea 4) (push 3 esa-B) (push 2 esa-AA))
      )
    )
    ; Cerca i numeri degli esagrammi AA e B
    (setq num-AA (find esa-AA esagrammi))
    (setq num-B (find esa-B esagrammi))
    ; Stampa degli esagrammi
    (print (format "  %-20d%-20d\n" num-AA num-B))
    (for (i 0 5)
      (print (format "  %-20s%-20s\n" (linee (esa-A i)) (linee (esa-B i))))
    )
  'i-ching))

Proviamo a generare un paio di esagrammi:

(ching 2)
;-> 10                  61
;-> ■■■■■■■■■■■■        ■■■■■■■■■■■■
;-> ■■■■■■■■■■■■        ■■■■■■■■■■■■
;-> ■■■■■■■■■■■■∙       ■■■■■  ■■■■■
;-> ■■■■■  ■■■■■        ■■■■■  ■■■■■
;-> ■■■■■■■■■■■■        ■■■■■■■■■■■■
;-> ■■■■■■■■■■■■        ■■■■■■■■■■■■

(ching)
;-> 20                  33
;-> ■■■■■■■■■■■■        ■■■■■■■■■■■■
;-> ■■■■■■■■■■■■        ■■■■■■■■■■■■
;-> ■■■■■  ■■■■■∙       ■■■■■■■■■■■■
;-> ■■■■■  ■■■■■∙       ■■■■■■■■■■■■
;-> ■■■■■  ■■■■■        ■■■■■  ■■■■■
;-> ■■■■■  ■■■■■        ■■■■■  ■■■■■


------------
Problema ABC
------------

Data una raccolta di blocchi ABC (simili a quelli che avevamo da bambini). Ci sono venti blocchi con due lettere su ogni blocco. Un alfabeto completo è garantito su tutti i lati dei blocchi.
La raccolta di blocchi è la seguente:

 (B O) (X K) (D Q) (C P) (N A) (G T) (R E) (T G) (Q D) (F S)
 (J W) (H U) (V I) (A N) (O B) (E R) (F S) (L Y) (P C) (Z M)

Scrivire una funzione che accetta una parola (stringa) e determina se la parola può essere scritta con la raccolta di blocchi data. L'unica regola è che una volta che una lettera su un blocco viene utilizzata, quel blocco non può essere riutilizzato.

(setq blocks '(("B" "O") ("X" "K") ("D" "Q") ("C" "P")
               ("N" "A") ("G" "T") ("R" "E") ("T" "G")
               ("Q" "D") ("F" "S") ("J" "W") ("H" "U")
               ("V" "I") ("A" "N") ("O" "B") ("E" "R")
               ("F" "S") ("L" "Y") ("P" "C") ("Z" "M")))

Nota: la descrizione del problema implica (e l'analisi dei blocchi lo conferma) che se una lettera, X, appare su più di un blocco, la lettera abbinata sarà la stessa su tutti i blocchi. Questo rende il problema abbastanza semplice.

(define (possible? word)
(catch
  (local (chars len)
    (setq chars (explode word))
    (setq len (length chars))
    (setq copia blocks)
    (dolist (ch chars)
      (setq idx (ref ch copia))
      (cond ((nil? idx) (throw nil))
            (true
             (pop copia (first idx)))
      )
    )
    true)))

(possible? "A")
;-> true
(possible? "BARK")
;-> true
(possible? "BOOK")
;-> nil
(possible? "TREAT")
: true
(possible? "COMMON")
;-> nil
(possible? "SQUAD")
;-> true
(possible? "CONFUSE")
;-> true


------------------------------------------------
Compressione/Decompressione intervallo di valori
------------------------------------------------

Un formato per esprimere un elenco ordinato di numeri interi consiste nell'utilizzare una lista di elementi che possono contenere un valore o un intervallo (coppia di valori). La coppia di valori ha come valori l'inizio dell'intervallo e la fine dell'intervallo). Per esempio:

Numeri ordinati = 1 2 3 5 7 8 9 11
Lista = ((1 3) (5) (7 9) 11))

La funzione che effettua la compressione consiste in un ciclo che percorre i valori e crea gli intervalli:

(define (compress-range lst)
  (local (out cur)
    (setq out '())
    (setq i 0)
    (while (< i (length lst))
      (setq idx i)
      ; valore inizio intervallo
      (setq a (lst i))
      ; valore fine intervallo
      (setq b (lst i))
      ; finchè il valore successivo è uguale
      ; al valore corrente + 1,
      ; allora aggiorna la fine dell'intervallo
      (while (and (< idx (- (length lst) 1)) (= (+ (lst idx) 1) (lst (+ idx 1))))
        (setq b (lst (+ idx 1)))
        (++ idx)
      )
      ; i valori i e i+1 differiscono...
      ; se primo e ultimo valore sono uguali
      (if (= a b)
          ; inserisce solo un valore
          (push (list a) out -1)
          ;else
          ; invece se l'intervallo vale 2
          ; inserisce due valori
          (if (= (+ a 1) b)
              (begin
                (push (list a) out -1)
                (push (list b) out -1)
              )
              ;else
              ; intervallo > 2
              ; inserisce l'intervallo
              (push (list a b) out -1)
          )
      )
      ; aggiorna indice i
      (setq i (++ idx))
    )
    out))

(compress-range (sequence 1 10))
;-> ((1 10))

(compress-range '(-5 -3 -2 -1 0 1 2 4 6 7 8 11 12 14 15 16 17 18 19 21))
;-> ((-5) (-3 2) (4) (6 8) (11) (12) (14 19) (21))

(compress-range '(0 1 2 4 6 7 8 11 12 14 15 16 17 18 19 20 21 22
                  23 24 25 27 28 29 30 31 32 33 35 36 37 38 39))
;-> ((0 2) (4) (6 8) (11) (12) (14 25) (27 33) (35 39))

In questo caso la sintassi dell'intervallo viene utilizzato solo per ogni intervallo che si espande a più di due valori. Comunque preferisco che l'intervallo valga anche per soli due numeri vicini (es. (11 12) invece che (11) (12)).

(define (compress-range lst)
  (local (out cur)
    (setq out '())
    (setq i 0)
    (while (< i (length lst))
      (setq idx i)
      (setq a (lst i))
      (setq b (lst i))
      (while (and (< idx (- (length lst) 1)) (= (+ (lst idx) 1) (lst (+ idx 1))))
        (setq b (lst (+ idx 1)))
        (++ idx)
      )
      (if (= a b)
          (push (list a) out -1)
      ;else
          (push (list a b) out -1)
      )
      (setq i (++ idx))
    )
    out))

(compress-range (sequence 1 10))
;-> ((1 10))

(compress-range '(0 1 2 4 6 7 8 11 12 14 15 16 17 18 19 20 21 22
                  23 24 25 27 28 29 30 31 32 33 35 36 37 38 39))
;-> ((0 2) (4) (6 8) (11 12) (14 25) (27 33) (35 39))

(compress-range '(-5 -3 -2 -1 0 1 2 4 6 7 8 11 12 14 15 16 17 18 19 21))
;-> ((-5) (-3 2) (4) (6 8) (11 12) (14 19) (21))

Adesso scriviamo la funzione che effettua la decompressione di una lista compressa.

(define (decompress-range lst)
  (local (out)
    (setq out '())
    (dolist (val lst)
      ; se la sottolista è composta da un solo elemento
      (if (= (length val) 1)
          ; allora aggiunge l'elemento alla lista di output
          (push (val 0) out -1)
          ; altrimenti aggiunge tutti i valori del range
          ; definito dai due elementi della sottolista
          (for (i (val 0) (val 1))
            (push i out -1)
          )
      )
    )
    out))

(decompress-range '((1 10)))
;-> (1 2 3 4 5 6 7 8 9 10)

(decompress-range '((0 2) (4) (6 8) (11 12) (14 25) (27 33) (35 39)))
;-> (0 1 2 4 6 7 8 11 12 14 15 16 17 18 19 20 21 22
;->  23 24 25 27 28 29 30 31 32 33 35 36 37 38 39)

(decompress-range (compress-range (extend (sequence 1 5) (sequence 8 12))))
;-> (1 2 3 4 5 8 9 10 11 12)

La funzione di decompressione funziona per entrambe le funzioni di compressione:

(decompress-range '((-3 -1) (2) (3)))
;-> (-3 -2 -1 2 3)


----------------
Plot di funzioni
----------------

Scrivere un programma che stampa una funzione matematica al terminale. I parametri del programma sono:
1) funzione da plottare
2) valore x minimo
3) valore x massimo

Funzione che normalizza una lista di valori:

(define (normalize lst-num val-min val-max)
  (local (hi lo k out)
    (setq out '())
    (setq hi (apply max lst-num))
    (setq lo (apply min lst-num))
    (setq k (div (sub val-max val-min) (sub hi lo)))
    (dolist (val lst-num)
      (push (add val-min (mul (sub val lo) k)) out -1))
    out))

Funzione che stampa la funzione matematica:

(define (plot-function func a b asse-x asse-y)
  (local (xx yy step matrix)
    ; lista per valori x
    (setq xx '())
    ; lista per valori y
    (setq yy '())
    ; numero passi
    (setq step (div (sub b a) asse-x))
    ; calcola valori x,y della funzione
    (for (val a b step)
      (push val xx -1)
      (push (func val) yy -1)
    )
    (setq y-min (apply min yy))
    (setq y-max (apply max yy))
    ; calcola valori normalizzati asse x
    (setq xx (normalize xx 0 asse-x))
    (setq xx (map round xx))
    (setq xx (map int xx))
    ; calcola valori normalizzati asse x
    (setq yy (normalize yy 0 asse-y))
    (setq yy (map round yy))
    (setq yy (map int yy))
    ; crea matrice di stampa
    ; (inserisce "■" nella matrice alle coordinate x y)
    (setq matrix (array (+ asse-y 2) (+ asse-x 2) '(" ")))
    (for (i 0 (- (length xx) 1))
      (setf (matrix (yy i) (xx i)) "■")
    )
    ; stampa valori reali min e max
    (println "x min = " a {  -  } "x max = " b)
    (println "y min = " y-min {  -  } "y max = " y-max)
    ; stampa matrice (funzione)
    ; (alla matrice vengono invertite le righe)
    (dolist (el (reverse (array-list matrix)))
      (println (join el))
    )
  'end))

Vediamo la funzione seno (sin):

(plot-function sin -6.3 6.3 75 20)
;-> x min = -6.3  -  x max = 6.3
;-> y min = -0.9996824042410868  -  y max = 0.9996824042410868
;->
;->         ■■■■                                 ■■■■
;->        ■    ■                               ■    ■■
;->       ■      ■                             ■       ■
;->      ■        ■                           ■
;->     ■          ■                         ■          ■
;->    ■            ■                                    ■
;->                                         ■             ■
;->   ■              ■
;->  ■                                     ■               ■
;->                   ■                   ■
;-> ■                  ■                                    ■                  ■
;->                                      ■                   ■
;->                     ■               ■                                     ■
;->                                                           ■              ■
;->                      ■             ■
;->                       ■                                    ■            ■
;->                        ■          ■                         ■          ■
;->                                  ■                           ■        ■
;->                         ■       ■                             ■      ■
;->                          ■■    ■                               ■    ■
;->                            ■■■■                                 ■■■■

Vediamo una parabola:

(define (g x) (mul x x))

(plot-function g -5 5 60 25)
;-> x min = -5  -  x max = 5
;-> y min = 0  -  y max = 25
;->
;-> ■                                                           ■
;->
;->  ■                                                         ■
;->   ■                                                       ■
;->
;->    ■                                                     ■
;->     ■                                                   ■
;->
;->      ■                                                 ■
;->       ■                                               ■
;->        ■                                             ■
;->
;->         ■                                           ■
;->          ■                                         ■
;->           ■                                       ■
;->            ■                                     ■
;->             ■                                   ■
;->              ■                                 ■
;->               ■                               ■
;->                ■                             ■
;->                 ■■                         ■■
;->                   ■                       ■
;->                    ■■                   ■■
;->                      ■■               ■■
;->                        ■■■         ■■■
;->                           ■■■■■■■■■


Vediamo una funzione polinomiale fratta:

         x^3 + x^2 - 5x
f(x) = ------------------
            x^2 + 1

(define (f x)
  (div (add (mul x x x) (mul x x) (mul -5 x))
       (add (mul x x) 1)))

(plot-function f -4 4 75 20)
;-> x min = -4  -  x max = 4
;-> y min = -1.791478768959859  -  y max = 3.529411764705882
;->
;->                                                                            ■
;->                                                                          ■■
;->                                                                        ■■
;->                                                                      ■■
;->                            ■■■■■                                    ■
;->                          ■■     ■                                 ■■
;->                        ■■        ■                              ■■
;->                      ■■           ■                            ■
;->                     ■              ■                         ■■
;->                   ■■                                        ■
;->                 ■■                  ■                     ■■
;->                ■                                         ■
;->              ■■                      ■                  ■
;->            ■■                                         ■■
;->           ■                           ■              ■
;->         ■■                                          ■
;->       ■■                               ■           ■
;->     ■■                                           ■■
;->   ■■                                    ■       ■
;-> ■■                                       ■    ■■
;->                                           ■■■■

Provare: (plot-function tan -1 1 25 30)

Vedi anche "Grafico di coppie di coordinate" per una versione migliore della funzione "plot".


====================
Spirale di Archimede
====================

Una spirale di Archimede può essere descritta dall'equazione:

r = a + b * theta

dove a e b sono numeri reali.

Disegnare una spirale di Archimede.

(define (spiral)
  (local (xx yy h w a b m r k step matrix)
    (setq xx '() yy '())
    (setq asse-x 60 asse-y 30)
    (setq x-max 0 y-max 0)
    (setq h 96 w 144 a 1 b 1)
    (setq m (mul 8 3.1415926))
    (setq step 0.1)
    (setq matrix (array (+ asse-y 2) (+ asse-x 2) '(" ")))
    (for (t step m)
      (setq r (add a (mul b t)))
      (setq x (add (mul r (cos t)) w))
      (setq y (add (mul r (sin t)) h))
      (push x xx -1)
      (push y yy -1)
    )
    (setq xx (normalize xx 0 asse-x))
    (setq xx (map round xx))
    (setq xx (map int xx))
    ; calcola valori normalizzati asse x
    (setq yy (normalize yy 0 asse-y))
    (setq yy (map round yy))
    (setq yy (map int yy))
    ; Costruisce matrice di stampa
    ; (inserisce un numero crescente nella matrice alle coordinate x y)
    (setq k 1)
    (for (i 0 (- (length xx) 1))
      (setf (matrix (yy i) (xx i)) (string k))
      (++ k)
    )
    ; stampa matrice (funzione)
    ; (alla matrice vengono invertite le righe)
    (dolist (el (reverse (array-list matrix)))
      (println (join el))
    )))

(spiral)
;->
;->                                        21
;->              22
;->
;->                                15
;->
;->
;->              16
;->                            9
;->
;->
;->                                     8       14
;->                  10
;->                            3                         20
;->                        4      2
;-> 23                             1
;->                                      7
;->                         5                                   26
;->         17
;->                  11            6
;->                                           13
;->
;->
;->                             12
;->
;->                                             19
;->
;->                       18
;->
;->              24
;->
;->                                          25


===============
Misure angolari
===============

Gli angoli geometrici vengono misurati utilizzando diverse unità di misura.

Le unità che consideriamo sono le seguenti:

 - grado (degree)
 - gradiante (gradian)
 - mil (mil)
 - radiante (radian)

Le scale tra queste unità angolari sono le seguenti:

  Un giro completo vale 360 gradi (360°).
  - 1 grado è 1/360 di giro
  - 1 gradian è 1/400 di giro
  - 1 mil è 1/6400 di giro
  - 1 radiante è 1/2 * π di giro (o 0,5 / π} di giro)

Oppure, in un altro modo, in un giro completo:
  - ci sono 360 gradi
  - ci sono 400 gradians
  - ci sono 6.400 mil
  - ci sono 2 * π radianti (approssimativamente pari a 6,283 ...)

Un mil è approssimativamente uguale a un milliradiante (che è 1/1000 di radiante).

Scrivere le funzioni di conversione tra tutte le unità di misura.

(setq pi 3.1415926535897931)
;
(define (DegToDeg a) (mod a 360))
(define (GradToGrad a) (mod a 400))
(define (MilToMil a) (mod a 6400))
(define (RadToRad a) (mod a (mul 2 pi)))
;
(define (DegToGrad a) (GradToGrad (mul (div a 360) 400)))
(define (DegToRad a) (RadToRad (mul (div a 360) (mul 2 pi))))
(define (DegToMil a) (MilToMil (mul (div a 360) 6400)))
;
(define (GradToDeg a) (DegToDeg (mul (div a 400) 360)))
(define (GradToRad a) (RadToRad (mul (div a 400) (mul 2 pi))))
(define (GradToMil a) (MilToMil (mul (div a 400) 6400)))
;
(define (MilToDeg a) (DegToDeg (mul (div a 6400) 360)))
(define (MilToGrad a) (GradToGrad (mul (div a 6400) 400)))
(define (MilToRad a) (RadToRad (mul (div a 6400) (mul 2 pi))))
;
(define (RadToDeg a) (DegToDeg (mul (div a (mul 2 pi)) 360)))
(define (RadToGrad a) (GradToGrad (mul (div a (mul 2 pi)) 400)))
(define (RadToMil a) (MilToMil (mul (div a (mul 2 pi)) 6400)))

Funzione che converte un angolo nelle altre unità angolari:

(define (convert-angle a unit)
  (local (out)
    (cond ((= unit "deg")
           (setq grad (DegToGrad a))
           (setq rad (DegToRad a))
           (setq mil (DegToMil a))
           (println a " gradi =")
           (print (format "%7.5f %s\n%7.5f %s\n%7.5f %s\n"
                   grad "grad" rad "rad" mil "mil")))
          ((= unit "grad")
           (setq deg (GradToDeg a))
           (setq rad (GradToRad a))
           (setq mil (GradToMil a))
           (println a " gradianti =")
           (print (format "%7.5f %s\n%7.5f %s\n%7.5f %s\n"
                   deg "deg" rad "rad" mil "mil")))
          ((= unit "rad")
           (setq grad (RadToGrad a))
           (setq deg (RadToDeg a))
           (setq mil (RadToMil a))
           (println a " radianti =")
           (print (format "%7.5f %s\n%7.5f %s\n%7.5f %s\n"
                   grad "grad" deg "deg" mil "mil")))
          ((= unit "mil")
           (setq grad (MilToGrad a))
           (setq deg (MilToDeg a))
           (setq rad (MilToRad a))
           (println a " mil =")
           (print (format "%7.5f %s\n%7.5f %s\n%7.5f %s\n"
                   grad "grad" deg "deg" rad "rad")))
    )
    'end))

(convert-angle 1 "mil")
;-> 1 mil =
;-> 0.06250 grad
;-> 0.05625 deg
;-> 0.00098 rad

(convert-angle 360 "deg")
;-> 360 gradi =
;-> 0.00000 grad
;-> 0.00000 rad
;-> 0.00000 mil


-------------------
Numero di settimane
-------------------

Determinare se un determinato anno ha 52 o 53 settimane.

L'agoritmo per risolvere il problema è il seguente:

p(y) = (y + floor(y/4) - floor(y/100) + floor(y/400)) mod 7

               | 1, if (p(y) = 4 or p(y-1) = 3
week(y) = 52 + |
               | 0, altrimenti

Maggiori informazioni:

Gent, Robert H. "The Mathematics of the ISO 8601 Calendar".
https://webspace.science.uu.nl/~gent0113/calendar/isocalendar.htm

Vediamo l'implementazione delle funzioni:

(define (p y)
  (% (+ y (/ y 4) (- (/ y 100)) (/ y 400)) 7))

(define (weeks year)
  (if (or (= (p year) 4) (= (p (- year 1)) 3))
      53
      52))

(map weeks (sequence 2000 2100 10))
;-> (52 52 53 52 52 52 53 52 52 52 52)

Tutti gli anni con 53 settimane dal 2020 al 2100:

(for (i 2020 2100) (if (= (weeks i) 53) (print i { })))
;-> 2020 2026 2032 2037 2043 2048 2054 2060
;-> 2065 2071 2076 2082 2088 2093 2099


---------------
Il gioco del 21
---------------

21 è un gioco tra due giocatori che si svolge scegliendo un numero (1, 2 o 3) da aggiungere al totale parziale (che parte da 0).

I giocatori si alternano fornendo un numero da aggiungere al totale parziale.

La partita viene vinta dal giocatore il cui numero scelto fa sì che il totale parziale raggiunga esattamente 21.

Scrivere un programma per giocare contro il computer.

Funzione che gestisce il gioco:

(define (game21 player)
  (local (turn totale val)
    (println "21 GAME")
    (setq totale 0)
    (if (or (nil? player) (= player 0))
        (setq turn "Human")
        (setq turn "Computer")
    )
    (while (< totale 21)
      (if (= turn "Human")
          (setq val (human-move))
          ; else
          (setq val (computer-move totale))
      )
      (setq totale (+ totale val))
      (println turn {: } val)
      (println "Totale = " totale)
      (if (< totale 21)
          (if (= turn "Human")
              (setq turn "Computer")
              (setq turn "Human"))
      )
    )
    (println turn " wins!!!")
  'end))

Nota: per calcolare la mossa del computer basta notare che per vincere bisogna raggiungere i valori 5, 9, 13, e 17. In altre parole, bisogna calcolare (totale % 4) e questo rappresenta l'indice della lista di mosse codificate/precalcolate (1 1 3 2).

Funzione che calcola la mossa del computer:

(define (computer-move totale)
  (let (coded '(1 1 3 2))
       (coded (% totale 4))))

Funzione che accetta l'inserimento di un numero (1, 2 o 3) da parte dell'utente:

(define (human-move)
	(print "Numero (1,2,3): ")
	(do-until (and (> input 48)(< input 52)) (setq input (read-key)))
	(println (- input 48)))

Parametri della funzione "game21":

(game21 0) o (game21) --> Inizia a giocare: Human
(game21 1) --> Inizia a giocare: Computer

Facciamo una partita:

(game21 1)
;-> Numero (1,2,3): 3
;-> Human: 3
;-> Totale = 3
;-> Computer: 2
;-> Totale = 5
;-> Numero (1,2,3): 2
;-> Human: 2
;-> Totale = 7
;-> Computer: 2
;-> Totale = 9
;-> Numero (1,2,3): 1
;-> Human: 1
;-> Totale = 10
;-> Computer: 3
;-> Totale = 13
;-> Numero (1,2,3): 3
;-> Human: 3
;-> Totale = 16
;-> Computer: 1
;-> Totale = 17
;-> Numero (1,2,3): 2
;-> Human: 2
;-> Totale = 19
;-> Computer: 2
;-> Totale = 21
;-> Computer wins!!!


------------------------------------
Fattoriale sinistro (Left factorial)
------------------------------------

Il fattoriale di sinistra del numero intero N è definito come segue:

  !N = Sum[k=0, n-1] k!
  !0 = 0

Sequenza OEIS A003422:
  0, 1, 2, 4, 10, 34, 154, 874, 5914, 46234, 409114, 4037914, 43954714,
  522956314, 6749977114, 93928268314, 1401602636314, 22324392524314,
  378011820620314, 6780385526348314, 128425485935180314,
  2561327494111820314, 53652269665821260314, ...

Scrivere una funzione che calcola il fattoriale di sinistra di un numero N.

Funzione che calcola il fattoriale di un numero:

(define (fact num)
  (if (zero? num)
      1
      (let (out 1L)
        (for (x 1L num)
          (setq out (* out x))))))

(fact 0)
;-> 1

Funzione che calcola il fattoriale sinistro di un numero:

(define (fact-left num)
  (if (zero? num)
      0L
      (let (sum 0L)
        (for (i 0 (- num 1))
          (setq sum (+ sum (fact i)))))))

(fact-left 0)
;-> 0L
(fact-left 12)
;-> 43954714L

Vediamo i fattoriali sinistri dei primi 22 numeri (0..21):

(map fact-left (sequence 0 21))
;-> (0L 1L 2L 4L 10L 34L 154L 874L 5914L 46234L 409114L 4037914L
;->  43954714L 522956314L 6749977114L 93928268314L 1401602636314L
;->  22324392524314L 378011820620314L 6780385526348314L
;->  128425485935180314L 2561327494111820314L)

(length (fact-left 1000))
;-> 2565

La funzione produce risultati corretti, ma possiamo renderla più veloce evitando di calcolare ripetutamente il fattoriale. Infatti, basta notare che fact(n) = n*fact(n-1). Allora la funzione può essere riscritta nel modo seguente:

(define (fact-left2 num)
  (if (zero? num)
      0L
      (let (sum 1L fact 1L)
        (for (i 1 (- num 1))
          (setq fact (* fact i))
          (setq sum (+ sum fact))))))

(fact-left2 12)
;-> 43954714L

(map fact-left2 (sequence 0 21))
;-> (0L 1L 2L 4L 10L 34L 154L 874L 5914L 46234L 409114L 4037914L
;->  43954714L 522956314L 6749977114L 93928268314L 1401602636314L
;->  22324392524314L 378011820620314L 6780385526348314L
;->  128425485935180314L 2561327494111820314L)

(length (fact-left2 1000))
;-> 2565

Vediamo la differenza di velocità:

(time (println (length (fact-left 1000))))
;-> 2565
;-> 185.804
(time (println (length (fact-left2 1000))))
;-> 2565
;-> 6.013

La seconda funzione è 30 volte più veloce della prima.

Calcoliamo quante cifre ha il fattoriale sinistro di 10000:

(length (fact-left2 10000))
;-> 35656


-------------------
Numeri primi lunghi
-------------------

I numeri primi lunghi sono numeri primi i cui reciproci (in decimali) hanno una lunghezza del periodo inferiore di uno al numero primo.

Esempio
7 è il primo numero primo lungo, il reciproco di sette è 1/7, che è uguale alla frazione decimale ripetuta 0,142857(142857)...
La lunghezza della parte ripetuta della frazione decimale è sei, (la parte tra parentesi) che è uno in meno del numero primo 7.
Quindi 7 è un numero primo lungo.

Nota: Il 2 non viene considerato un numero primo lungo.

Sequenza OEIS: A001913
  7, 17, 19, 23, 29, 47, 59, 61, 97, 109, 113, 131, 149, 167, 179, 181,
  193, 223, 229, 233, 257, 263, 269, 313, 337, 367, 379, 383, 389, 419,
  433, 461, 487, 491, 499, 503, 509, 541, ...

Funzione che verifica se un numero è primo:

(define (prime? num)
   (if (< num 2) nil
       (= 1 (length (factor num)))))

Funzione che genera tutti i numeri primi minori o uguali a un dato numero:

(define (primes-to num)
  (cond ((= num 1) '())
        ((= num 2) '(2))
        (true
         (let (lst '(2))
          (setq arr (array (+ num 1)))
          (for (x 3 num 2)
                (when (not (arr x))
                  (push x lst -1)
                  (for (y (* x x) num (* 2 x) (> y num))
                      (setf (arr y) true)))) lst))))

(primes-to 50)
;-> (2 3 5 7 11 13 17 19 23 29 31 37 41 43 47)

Funzione che calcola il periodo del reciproco di un numero intero positivo:

(define (find-period num)
    (setq r 1)
    (setq rr 0)
    (setq period 0)
    (for (i 1 (+ num 1))
      (setq r (% (* r 10) num))
    )
    (setq rr r)
    (do-while (!= r rr)
      (setq r (% (* r 10) num))
      (++ period)
    )
    period)

(find-period 7)
;-> 6

(map find-period (sequence 1 10))
;-> (1 1 1 1 1 1 6 1 1 1)

Funzione che verifica se un numero è un primo lungo:

(define (long-prime? num)
  (and (> num 2) (prime? num) (= (find-period num) (- num 1))))

(long-prime? 2)
;-> nil
(long-prime? 499)
;-> true

Funzione che restituisce tutti i numeri primi lunghi fino ad un determinato numero:

(define (long-primes-to num)
  ; elimina il numero 2 dalla lista dei primi
  (let (primi (slice (primes-to num) 1))
    (filter long-p? primi)))

(define (long-p? primo) (= (find-period primo) (- primo 1)))

(long-primes-to 500)
;-> (7 17 19 23 29 47 59 61 97 109 113 131 149 167 179 181
;->  193 223 229 233 257 263 269 313 337 367 379 383 389 419
;->  433 461 487 491 499)

Funzione che calcola il numero di primi lunghi fino ad un determinato numero:

(define (long-primes-to-count num)
  (let ((primi (slice (primes-to num) 1)) (out 0))
    (dolist (p primi)
      (if (long-p? p) (++ out))
    )
    out))

(long-primes-to-count 500)
;-> 35

(time (println (long-primes-to-count 100000)))
;-> 3617
;-> 59944.711 ; 1 minuto

Vediamo quanti primi lunghi ci sono fino a 1 milione:

(time (println (long-primes-to-count 1000000)))
;-> 29500
;-> 5022833.606 ; quasi 84 minuti


----------
Numeri Tau
----------

Un numero Tau è un numero intero positivo divisibile per il numero dei suoi divisori.

Sequenza OEIS A033950:
  1, 2, 8, 9, 12, 18, 24, 36, 40, 56, 60, 72, 80, 84, 88, 96, 104,
  108, 128, 132, 136, 152, 156, 180, 184, 204, 225, 228, 232, 240,
  248, 252, 276, 288, 296, 328, 344, 348, 360, 372, 376, 384, 396,
  424, 441, 444, 448, 450, 468, 472, 480, 488, 492, 504, ...

Funzione che fattorizza un numero intero:

(define (factor-group num)
  (if (= num 1) '((1 1))
    (letn (fattori (factor num)
          unici (unique fattori))
      (transpose (list unici (count unici fattori))))))

(factor-group 36)
;-> ((2 2) (3 2))

Funzione che conta il numero di divisori di un numero intero:

(define (divisors-count num)
  (if (= num 1)
      1
      (let (lst (factor-group num))
        (apply * (map (fn(x) (+ 1 (last x))) lst)))))

(divisors-count 36)
;-> 9

Funzione che verifica se un numero è Tau:

(define (tau? num)
  (zero? (% num (divisors-count num))))

(tau? 8)
;-> true

Funzione che calcola i numeri Tau fino ad un dato numero:

(define (tau-to num)
  (let (out '())
    (for (i 1 num)
      (if (tau? i)
        (push i out -1)))
    out))

Calcoliamo i numeri Tau fino a 500:

(tau-to 500)
;-> (1 2 8 9 12 18 24 36 40 56 60 72 80 84 88 96 104 108 128 132 136
;->  152 156 180 184 204 225 228 232 240 248 252 276 288 296 328 344
;->  348 360 372 376 384 396 424 441 444 448 450 468 472 480 488 492)


--------------------
Sequenza Yellowstone
--------------------

La sequenza di Yellowstone, chiamata anche permutazione di Yellowstone, è definita nel modo seguente

  Per n <= 3: a(n) = n
  Per n > 3:  a(n) = il numero più piccolo non già in sequenza tale che a(n) sia primo relativamente ad a(n-1) e non è relativamente primo ad a(n-2)

Esempio:
a(4) vale 4 perché 4 è il numero più piccolo che segue 1, 2, 3 nella sequenza che è relativamente primo rispetto al numero prima di esso (3), e non è relativamente primo rispetto al numero due posti prima di esso (2).

La sequenza è una permutazione dei numeri naturali.

Sequenza OEIS A098550:
  1, 2, 3, 4, 9, 8, 15, 14, 5, 6, 25, 12, 35, 16, 7, 10, 21, 20, 27, 22,
  39, 11, 13, 33, 26, 45, 28, 51, 32, 17, 18, 85, 24, 55, 34, 65, 36,
  91, 30, 49, 38, 63, 19, 42, 95, 44, 57, 40, 69, 50, 23, 48, 115, 52,
  75, 46, 81, 56, 87, 62, 29, 31, 58, 93, 64, 99, 68, 77, 54, 119, 60, ...

Un altro metodo di definire la sequenza è il seguente:

  Per n <= 3: a(n) = n
  Per n > 3: gcd(a(n), a(n-1)) = 1 e gcd(a(n), a(n-2)) > 1.

Scrivere una funzione che calcola i primi n numeri di yellowstone.
Scrivere una funzione che plotta il grafico dei primi n numeri di yellowstone (con asse-x = n e asse-y = a(n)).

Funzione che calcola la sequenza di Yellowstone:

(define (yellowstone limite)
  (local (ys i j cur-val)
    ; vettore per i valori della sequenza
    (setq ys (array (+ limite 1) '()))
    (setq (ys 0) 0)
    (setq (ys 1) 1)
    (setq (ys 2) 2)
    (setq (ys 3) 3)
    ; ciclo fino
    (for (i 4 limite)
      (setq cur-val 3)
      (setq continua true)
      ; ricerca i-esimo valore
      (while continua
        ; cur-val è il valore di prova per i-esimo valore
        (++ cur-val)
        ; se cur-val non soddisfa le condizioni continuiamo con il ciclo while
        ; per provare cur-val = cur-val + 1
        (cond ((or (= (gcd cur-val (ys (- i 2))) 1) (> (gcd cur-val (ys (- i 1))) 1))
                nil)
              (true
                ; altrimenti cerchiamo se esiste cur-val nella sequenza
                (setq trovato nil)
                (for (j 1 (- i 1) 1 trovato)
                  (if (= (ys j) cur-val) (setq trovato true))
                )
                ; Se cur-val viene trovato, allora non può essere
                ; inserito nella sequenza e continuiamo
                ; con cur-val = cur-val + 1 (ciclo while)
                ; Se cur-val non viene trovato, allora viene inserito nella sequenza
                ; e passiamo al prossimo valore (i = i + 1) (ciclo for)
                (if (not trovato) (begin
                    (setq (ys i) cur-val)
                    (setq continua nil))
                ))
         )
       )
     )
     ;(array-list(slice ys 1))))
     ys))

(yellowstone 30)
;-> (0 1 2 3 4 9 8 15 14 5 6 25 12 35 16 7 10 21
;->  20 27 22 39 11 13 33 26 45 28 51 32 17)

La funzione è abbastanza lenta. Un miglioramento potrebbe essere quella di inserire i valori della sequenza in una hash-map invece che in un vettore, in questo modo la ricerca dei valori nella sequenza sarebbe molto più veloce.

(time (yellowstone 1000))
;-> 2178.186
(time (yellowstone 2000))
;-> 16728.302
(time (yellowstone 4000))
;-> 133255.977
(time (yellowstone 10000))
;-> 2097865.029 ; 35 minuti

Funzione che stampa il grafico della sequenza:

(define (plot-ys limite)
  (local (ys max-row max-col matrix)
    ; calcolo valori della sequenza
    (setq ys (yellowstone limite))
    ; creazione matrice di caratteri (stampa)
    (setq max-row (+ (apply max ys) 2))
    (setq max-col (+ limite 2))
    ;(setq matrix (array (+ limite 2) (+ limite 2) '(" ")))
    (setq matrix (array max-row max-col '(" ")))
    ; inserimento "punti" nella matrice
    ; y = riga della matrice
    ; x = colonna della matrice
    (for (i 0 (- (length ys) 1))
      (setf (matrix (ys i) i) "■")
    )
    ; stampa matrice
    ; (alla matrice vengono invertite le righe)
    (dolist (el (reverse (array-list matrix)))
      (println (join el))
    )))

(plot-ys 30)
;->                            ■
;->
;->
;->
;->
;->
;->                          ■
;->
;->
;->
;->
;->
;->                     ■
;->
;->
;->
;->             ■
;->
;->                        ■
;->                             ■
;->
;->
;->
;->                           ■
;->                   ■
;->                         ■
;->           ■
;->
;->
;->                    ■
;->                 ■
;->                  ■
;->
;->
;->                              ■
;->              ■
;->       ■
;->        ■
;->                       ■
;->            ■
;->                      ■
;->                ■
;->     ■
;->      ■
;->               ■
;->          ■
;->         ■
;->    ■
;->   ■
;->  ■
;-> ■

La sequenza viene chiamata Yellowstone perchè il suo grafico assomiglia al getto di un geyser del parco Yellowstone.


----------------
Distanza di Jaro
----------------

La distanza Jaro è una misura della somiglianza tra due stringhe.
Maggiore è la distanza Jaro per due stringhe, più simili sono le stringhe.
Il punteggio è normalizzato in modo tale che 0 equivale a nessuna somiglianza e 1 è una corrispondenza esatta (le stringhe sono uguali).

La distanza di Jaro dj per due stringhe s1 e s2 vale:

        | 0, se m = 0
  dj =  |
        | 1/3 * (m/|s1| + m/|s2| + (m-t)/m), in tutti gli altri casi

dove:

  m = numero di caratteri corrispondenti
  t = metà del numero di trasposizioni

Due caratteri rispettivamente da s1 e s2 sono considerati corrispondenti solo se sono uguali e non più lontani di floor(max(|s1|,|s2|)/2) - 1.
Ogni carattere di s1 viene confrontato con tutti i suoi caratteri corrispondenti in s2.
Il numero di caratteri corrispondenti (ma con l'ordine di sequenza diverso) diviso per 2 definisce il numero di trasposizioni.

For example, in comparing CRATE with TRACE, only 'R' 'A' 'E' are the matching characters, i.e. m=3. Although 'C', 'T' appear in both strings, they are farther apart than 1 (the result of floor(5/2) - 1). Therefore, t=0 . In DwAyNE versus DuANE the matching letters are already in the same order D-A-N-E, so no transpositions are needed.

Ad esempio, confrontando CRATE con TRACE, solo 'R' 'A' 'E' sono i caratteri corrispondenti, ovvero m = 3. Sebbene 'C', 'T' compaiano in entrambe le stringhe, sono più distanti di 1 (il risultato di floor (5/2) - 1), quindi t = 0. In DwAyNE contro DuANE le lettere corrispondenti sono già nello stesso ordine D-A-N-E, quindi non sono necessarie trasposizioni.

(define (jaro s t)
  (if (and (zero? (length s)) (zero? (length t)))
      1
  (local (len-s len-t)
    (if (> (length s) (length t))
        (swap s t)
    )
    (setq len-s (length s))
    (setq len-t (length t))
    (setq match-dist (- (/ (max len-s len-t) 2) 1))
    (setq s-match (array len-s '(nil)))
    (setq t-match (array len-t '(nil)))
    (setq matches 0)
    (setq transp 0)
    (for (i 0 (- len-s 1))
      (setq start (max 0 (- i match-dist)))
      (setq end (min (+ i match-dist 1) len-t))
      (setq stop nil)
      (for (j start (- end 1) 1 stop)
        (cond ((t-match j) nil)
              ((!= (s i) (t j)) nil)
              (true
                (setf (s-match i) true)
                (setf (t-match j) true)
                (++ matches)
                (setq stop true))
        )
      )
    )
    (cond ((zero? matches) 0)
          (true
            (setq k 0)
            (for (i 0 (- len-s 1))
              (cond ((not (s-match i)) nil)
                    (true
                      (while (not (t-match k))
                        (++ k)
                      )
                      (if (!= (s i) (t k))
                        (++ transp)
                      )
                      (++ k))
              )
            )
            (div (add (div matches len-s)
                      (div matches len-t)
                      (div (sub matches (div transp 2)) matches))
                 3))
    ))))

(jaro "giovanna" "goivanna")
;-> 0.9583333333333334
(jaro "fantastic" "bombastic")
;-> 0.6370370370370371
(jaro "abc" "abc")
;-> 1
(jaro "abc" "ABC")
;-> 0
(jaro "abc" "abcd")
;-> 0.9166666666666666
(jaro "abc" "abcde")
;-> 0.8666666666666667
(jaro "abc" "abcdef")
;-> 0.8333333333333334
(jaro "grattacielo" "palazzo")
;-> 0.5670995670995671
(jaro "newlisp" "abcdefghijklmnopqrstuvwxyz")
;-> 0.4917582417582418
(jaro "common lisp" "abcdefghijklmnopqrstuvwxyz")
;-> 0.532488344988345


-------------------------------------
Pietre e gioielli (Stones and Jewels)
-------------------------------------

Data una stringa in cui i caratteri rappresentano "gioielli" e una stringa in cui i caratteri rappresentano le "pietre". Determinare quante "pietre" sono "gioielli".
I caratteri dei "gioielli" sono tutti diversi.
I caratteri delle "pietre" possono essere uguali.
I caratteri sono solo le lettere dell'alfabeto (minuscole e maiuscole)
I caratteri minuscoli sono diversi da quelli maiuscoli.

In altre parole, vogliamo sapere quanti "gioielli" ci sono nelle "pietre".

(define (pietre-gioielli p g)
  (apply + (count (explode g) (explode p))))

(pietre-gioielli "aAAbbbb" "aA")
;-> 3

(pietre-gioielli "fkjhQD" "aDf")
;-> 2

(pietre-gioielli "fkjhQD" "adF")
;-> 0

--------------
Numeri super-d
--------------

Un numero super-d è un numero intero decimale positivo (in base dieci) n tale che d × nᵈ ha almeno d cifre consecutive d dove

   2 ≤ d ≤ 9

Ad esempio, 753 è un numero super-3 perché 3 × 753³ = 1280873331.

Funzione cha calcola la potenza intera di un numero intero:

(define (pow-i num power)
  (local (pot out)
    (if (zero? power)
        (setq out 1L)
        (begin
          (setq pot (pow-i num (/ power 2)))
          (if (odd? power)
              (setq out (* num pot pot))
              (setq out (* pot pot)))
        )
    )
    out))

Altra funzione cha calcola la potenza intera di un numero intero:

(define (** num power)
    (let (out 1L)
        (dotimes (i power)
            (setq out (* out num)))))

Funzione che calcola i numeri super-d fino ad un dato numero:

(define (super-d d limite)
  (local (test tot num val out)
    (setq test (dup (string d) d))
    (setq tot 0)
    (setq num 0)
    (while (< tot limite)
      (++ num)
      (setq val (* (bigint d) (** num d)))
      ;(setq val (* (bigint d) (pow-i (bigint num) d)))
      (if (find test (string val))
        (begin
          (++ tot)
          (push num out -1)
        )
      )
    )
    out))

Calcoliamo i primi 10 numeri super-d per d da 2 a 9:

(super-d 2 10)
;-> (19 31 69 81 105 106 107 119 127 131)
(super-d 3 10)
;-> (261 462 471 481 558 753 1036 1046 1471 1645)
(super-d 4 10)
;-> (1168 4972 7423 7752 8431 10267 11317 11487 11549 11680)
(super-d 5 10)
;-> (4602 5517 7539 12955 14555 20137 20379 26629 32767 35689)
(time (println (super-d 6 10)))
;-> (27257 272570 302693 323576 364509 502785 513675 537771 676657 678146)
;-> 1609.883
(time (println (super-d 7 10)))
;-> (140997 490996 1184321 1259609 1409970 1783166 1886654 1977538 2457756 2714763)
;-> 7234.281
(time (println (super-d 8 10)))
;-> (185423 641519 1551728 1854230 6415190 12043464 12147605 15517280 16561735 18542300)
;-> 55858.5 ; quasi 56 secondi
(time (println (super-d 9 10)))
;-> (17546133 32613656 93568867 107225764 109255734 113315082
;->  121251742 175461330 180917907 182557181)
;-> 600068.062 ; 10 minuti


----------------------
Algoritmo di Bresenham
----------------------

L'algoritmo di Bresenham è un algoritmo per disegnare linee in una griglia bidimensionale (raster) conoscendo il punto di inizio e di fine della linea. Questo algoritmo è uno dei primi ad essere stato introdotto nel campo della computer grafica e viene comunemente usato per disegnare linee primitive in un'immagine bitmap (es. lo schermo di un computer), poiché utilizza solo addizione, sottrazione e shift di interi. È un algoritmo di errore incrementale che non supporta l'antialiasing, ma è molto veloce. Per un metodo che supporta l'antialiasing vedi l'algoritmo di Wu.

Per informazioni dettagliate vedere:
"Michael Abrash's Graphics Programming Black Book Special Edition"
http://www.phatcode.net/res/224/files/html/index.html

(define (bresenham x0 y0 x1 y1)
  (local (dx dy err x y sx sy out)
    (setq out '())
    (setq dx (abs (- x1 x0)))
    (setq dy (abs (- y1 y0)))
    (set 'x x0 'y y0)
    (if (> x0 x1)
        (setq sx -1)
        (setq sx 1)
    )
    (if (> y0 y1)
        (setq sy -1)
        (setq sy 1)
    )
    (cond ((> dx dy)
            (setq err (div dx 2))
            (while (!= x x1)
              (push (list x y) out -1)
              (setq err (sub err dy))
              (if (< err 0)
                  (set 'y (add y sy) 'err (add err dx))
              )
              (setq x (add x sx))
            ))
          (true
            (setq err (div dy 2))
            (while (!= y y1)
              (push (list x y) out -1)
              (setq err (sub err dx))
              (if (< err 0)
                  (set 'x (add x sx) 'err (add err dy))
              )
              (setq y (add y sy))
            ))
    )
    (push (list x y) out -1)
    out))

(bresenham 1 1 10 6)
;-> ((1 1) (2 2) (3 2) (4 3) (5 3) (6 4) (7 4) (8 5) (9 5) (10 6))

Con la funzione "plot" (vedi il capitolo "Funzioni varie"):
(plot (bresenham 1 1 10 6) 9 5)
;-> x: 1.000        10.000
;-> y: 1.000        6.000
;->
;->           ■
;->         ■■
;->       ■■
;->     ■■
;->   ■■
;->  ■

(bresenham -4 5 10 -12)
;-> ((-4 5) (-3 4) (-2 3) (-2 2) (-1 1) (0 0) (1 -1) (2 -2) (3 -3) (3 -4) (4 -5) (5 -6)
;->  (6 -7) (7 -8) (8 -9) (8 -10) (9 -11) (10 -12))

(plot (bresenham -4 5 10 -12) 14 17)
;-> x: -4.000       10.000
;-> y: -12.000      5.000
;->      ·
;->  ■   ·
;->   ■  ·
;->    ■ ·
;->    ■ ·
;->     ■·
;->  ····O···········
;->      ·■
;->      · ■
;->      ·  ■
;->      ·  ■
;->      ·   ■
;->      ·    ■
;->      ·     ■
;->      ·      ■
;->      ·       ■
;->      ·       ■
;->      ·        ■
;->      ·         ■


------------------------------------------
Associare gli elementi di una lista ogni k
------------------------------------------

Definire una funzione che prende una lista e associa tutti gli elementi ogni k in sottoliste. Restituire la lista delle sottoliste.

(define (glue-k lst k precise)
  (transpose (explode lst k precise)))

(setq lst (sequence 1 16))
(glue-k lst 3)
;-> ((1 4 7 10 13 16) (2 5 8 11 14 nil) (3 6 9 12 15 nil))
(glue-k lst 3 true)
;-> ((1 4 7 10 13) (2 5 8 11 14) (3 6 9 12 15))

(setq lst '(1 1 1 2 2 2 3 3 3 4 4 4))
(glue-k lst 3)
;-> ((1 2 3 4) (1 2 3 4) (1 2 3 4))

(setq lst '(1 1 1 2 2 2 3 3 3))
(glue-k lst 3)
;-> ((1 2 3) (1 2 3) (1 2 3))

(setq lst (sequence 1 8))
(glue-k lst 7)
;-> ((1 8) (2 nil) (3 nil) (4 nil) (5 nil) (6 nil) (7 nil))
(glue-k lst 7 true)
;-> ((1) (2) (3) (4) (5) (6) (7))
(glue-k lst 8)
;-> ((1) (2) (3) (4) (5) (6) (7) (8))
(glue-k lst 8 true)
;-> ((1) (2) (3) (4) (5) (6) (7) (8))
(glue-k lst 9)
;-> ((1) (2) (3) (4) (5) (6) (7) (8))
(glue-k lst 9 true)
;-> ERR: matrix expected : ()

(setq lst '(a b c d e f g h))
(glue-k lst (/ (length lst) 2))
;-> ((a e) (b f) (c g) (d h))
(setq lst '(a b c d e f g h i))
(glue-k lst (/ (length lst) 2))
;-> ((a e i) (b f nil) (c g nil) (d h nil))
(glue-k lst (/ (length lst) 2) true)
;-> ((a e) (b f) (c g) (d h))


-------------------------------
Somma delle potenze delle cifre
-------------------------------

Data un numero intero n con cifre decimali abc...d scrivere una funzione che calcola:

  a(n) = a^a + b^b +...+ d^d

Sequenza OEIS A045503: If decimal expansion of n is ab...d, a(n) = a^a + b^b +...+ d^d.

(define (A045503 num)
  (if (zero? num) 1
    (let ((out 0) (power '(1 1 4 27 256 3125 46656 823543 16777216 387420489)))
      (while (!= num 0)
        (setq out (+ out (power (% num 10))))
        (setq num (/ num 10)))
      out)))

(map A045503 (sequence 0 20))
;-> (1 1 4 27 256 3125 46656 823543 16777216 387420489 2 2
;->  5 28 257 3126 46657 823544 16777217 387420490 5)

Invece di sommare ogni volta, alterniamo l'addizione e la sottrazione:

  a(n) = a^a - b^b +...-+ d^d

Sequenza OEIS A344658: If decimal expansion of n is abc...d, a(n) = a^a - b^b + c^c -...-+ d^d.
Author: Massimo Corinaldesi, May 26 2021

(define (A344658 n)
  (if (zero? n) 1
    (local (sign out power)
      (setq power '(1 1 4 27 256 3125 46656 823543 16777216 387420489))
      (setq out 0)
      (if (odd? (length n))
          (setq sign 1)
          (setq sign -1))
      (while (!= n 0)
        (setq out (+ out (* sign (power (% n 10)))))
        (setq sign (* sign -1))
        (setq n (/ n 10)))
      out)))

(map A344658 (sequence 0 20))
;-> (1 1 4 27 256 3125 46656 823543 16777216 387420489 0 0
;->  -3 -26 -255 -3124 -46655 -823542 -16777215 -387420488 3)


------------------
Bruchi saltellanti
------------------

Date N foglie numerate da 1 a N. Un bruco salta di foglia in foglia in multipli di Aj (Aj, 2Aj, 3Aj).
L'indice j è specifico per il bruco. Ogni volta che un bruco raggiunge una foglia, la mangia un pò. Determinare quante foglie, da 1 a N, sono rimaste non mangiate dopo che tutti i bruchi K hanno raggiunto la fine. Ogni bruco ha il proprio fattore di salto indicato da Aj, e ogni bruco inizia a contare il primo salto dalla foglia numero 1.

(define (bruchi numleaf jump)
  (local (leaf goodleaf out)
    (setq out '())
    (setq leaf (sequence 0 numleaf))
    ; vettore di foglie sane
    (setq goodleaf (array (+ numleaf 1) '(1)))
    ; per ogni foglia...
    (for (i 1 numleaf)
      ; per ogni salto dei bruchi...
      (dolist (br jump)
        ; se il numero della foglia è multiplo del salto
        (if (zero? (% (leaf i) br))
            ; allora la foglia viene "mangiata" un pò
            ; (poniamo il relativo indice della lista goodleaf a 0)
            (setf (goodleaf i) 0)
        )
      )
    )
    ; costruzione della lista risultato
    ; ricerca dei numeri delle foglie sane
    (for (i 1 numleaf)
      (if (= (goodleaf i) 1) (push i out -1))
    )
    out))

(bruchi 10 '(2 3 5))
;-> (1 7)

(bruchi 100 '(1))
;-> '()

(bruchi 50 '(2 3 4 5 7))
;-> (1 11 13 17 19 23 29 31 37 41 43 47)


---------------
Buste matrioska
---------------

Dato un numero di buste con larghezze e altezze date come una coppia di numeri interi (w, h). Una busta può entrare in un'altra se e solo se sia la larghezza che l'altezza di una busta sono maggiori della larghezza e dell'altezza dell'altra busta.
Qual è il numero massimo di buste che inserire una dentro l'altra come una bambola russa (matrioska)?

Possiamo ordinare le buste per altezza in ordine crescente e larghezza in ordine decrescente. Quindi per i valori della larghezza trovare la sottosequenza crescente più lunga. Questo problema viene quindi convertito nel problema di trovare la sottosequenza crescente più lunga.

Ordinamento standard:

(setq m '((3 8) (4 6) (2 11) (2 10) (2 12) (20 3) (10 1)))

(sort (copy m))
;-> ((2 10) (2 11) (2 12) (3 8) (4 6) (10 1) (20 3))

Ordinamento con una funzione di comparazione (ascendente in x e discendente in y (per valori uguali di x)):

(define (cmp x y)
  (if (= (first x) (first y))
      (> (last x) (last y))
      (< (first x) (first y))))

(setq m '((3 8) (4 6) (2 11) (2 10) (2 12) (20 3) (10 1)))

(sort m cmp)
;-> ((2 12) (2 11) (2 10) (3 8) (4 6) (10 1) (20 3))

Funzione che calcola la lunghezza della sottosequenza crescente più lunga:

(define (lis lst)
  (local (len vet out)
    (setq out 1)
    (setq len (length lst))
    (setq vet (array len '(1)))
    (for (i 0 (- len 1))
      (setq j 0)
      (while (< j i)
        (if (> (lst i) (lst j))
            (setf (vet i) (max (vet i) (+ (vet j) 1)))
        )
        (++ j)
      )
      (setq out (max (vet i) out))
    )
    out))

Funzione che calcola la soluzione:

(define (matrioska dolls)
  (local (lst height)
    (sort dolls cmp)
    (setq height (map last dolls))
    (lis height)))

(matrioska '((6 4) (6 7) (1 8) (2 3) (5 2) (5 4)))
;-> 3


-----------
ASCII Julia
-----------

Ecco una versione base per stampare sul terminale l'insieme di Julia.

Prima di tutto ci servono alcune funzioni per calcolare i numeri complessi:

; Estrae la parte reale di un numero complesso
(define (real num) (first num))
; Estrae la parte immaginaria di un numero complesso
(define (imag num) (last num))
; Calcola il modulo di un numero complesso
(define (modulo num)
  (sqrt (add (mul (real num) (real num)) (mul (imag num) (imag num)))))
; Calcola la somma di due numeri complessi
(define (cx-add num1 num2)
  (list (add (real num1) (real num2)) (add (imag num1) (imag num2))))
; Calcola la moltiplicazione di due numeri complessi
(define (cx-mul num1 num2)
  (list (sub (mul (real num1) (real num2)) (mul (imag num1) (imag num2)))
        (add (mul (imag num1) (real num2)) (mul (real num1) (imag num2)))))

Poi scriviamo una funzione per calcolare l'insieme di Julia:

(define (julia width height)
  (local (c z limite i)
    (setq limite 40)
    (setq c '(-0.8 0.156))
    (for (y 1 height)
      (for (x 1 width)
        (setq i limite)
        (setq z (list (div (mul 3 (sub x (div width 2))) width)
                      (div (mul 2 (sub y (div height 2))) height)))
        (while (and (< (modulo z) 2) (> i 0))
          (setq z (cx-add (cx-mul z z) c))
          (-- i)
        )
        (if (> i 0)
            (print " ")
            (print "#")
        )
      )
      (println))))

(julia 61 24)
;->                                     #
;->                                   ####
;->                                  ## ##
;->                              # ###     ####
;->                            ######### ##########        ### #
;->             ###   #        ######################   #########
;->             #  ### ##       #############        #   ##### ## #  ##
;->           ######### ####     ##########      ### #    ### #  ### ## ##
;->    # ###  ######        ##     ########     ##        ######  ### #
;-> ## ## ###  # ###    # ###      ##########     #### #########
;->    ##  # ## #####   #        #############       ## ###  #
;->          #########   ######################        #   ###
;->           # ###        ########## #########
;->                            ####     ### #
;->                                 ## ##
;->                                 ####
;->                                  #

(julia 141 50)
;->                                                                        ##
;->                                                                      ##
;->                                                                     #######
;->                                                                      ########
;->                                                                        #   ##
;->                                                                 # ###  ##  #
;->                                                         #      #####   ####       ##     ##
;->                                                          #    ######         ##########   #
;->                                                               ########     ##########    #
;->                                                          ##   ###### ########################                       ###
;->                                                          ################ ################### ##             ## # ### #
;->                                                        #  #####################################             #  ###  ##
;->                          # #                           ############################# ###########          # ######    ###
;->                          #   #       ##                  ########################### #    ########       ################# #
;->                          # #    ####                    #####################  ###             ####      #####################
;->                        ###    ############             ######################  # #               ###     ################ ###     # # #
;->                        ###  # #################         ######################                    ##      ########### #      ##  ######
;->                      ###########################           ####################           ######  ##       ##########     ### #   ###   # ##
;->                     ################ ##      ######          #################           ######## ##       #  ######     ## ##   ####     ###
;->         #  #         ########### #             ####         #############   ####        ###  #######       ###########    ##    ######
;->        ##########    ############                ##           #  ##########  #           ##                ############    ##########
;->       ######    ##    ###########       #######  ###        ####   #############         ####             # ###########         #  #
;-> ##     ####   ## ##     ######  #       ## ########           #################          ######      ## ################
;-> ## #   ###   # ###     ##########       ##  ######           ####################           ###########################
;->      ######  ##      # ###########      ##                    ######################         ################# #  ###
;->      # # #     ### ################     ###               # #  ######################             ############    ###
;->               #####################      ####             ###  #####################                    ####    # #
;->                 # #################       ########    # ###########################                  ##       #   #
;->                    ###    ###### #          ########### #############################                           # #
;->                       ##  ###  #             #####################################  #
;->                      # ### # ##             ## ################### ################
;->                      ###                       ######################## ######   ##
;->                                                   #    ##########     ########
;->                                                  #   ##########         ######    #
;->                                                  ##     ##       ####   #####      #
;->                                                                 #  ##  ### #
;->                                                                ##   #
;->                                                                ########
;->                                                                  #######
;->                                                                      ##
;->                                                                    ##

Nota: Quest'ultimo grafico dell'insieme è largo circa 155 caratteri, quindi per vederlo correttamente occorre visualizzarlo con righe maggiori di 155 caratteri.


-----------------------
Dado da 7 con dado da 5
-----------------------

Dato un generatore di uguale probabilità di uno degli interi da 1 a 5 come dado5, creare dado7 che genera un intero pseudo-casuale da 1 a 7 con uguale probabilità usando solo dadi5 come fonte di numeri casuali e controllare la distribuzione dei risultati per almeno un milione di lanci.

Algoritmo:
Lanciare 5 volte "dadi5", se il numero ottenuto è maggiore di 21, allora ripetere i 5 lanci di "dado5", altrimenti dividere le 21 combinazioni in 7 gruppi da tre e restituire l'indice del gruppo a cui appartiene il numero.

(define (dado5) (+ (rand 5) 1))
(dado5)
;-> 2

(define (dado7)
  ; genera un numero casuale da 0 a 24 con uquali probabilità
  (let (val (+ (* 5 (dado5)) (dado5) -6))
    ; se val < 21, allora prendiamo come risultato (val % 7) + 1
    ; altrimenti scartiamo il valore (val) e
    ; generiamo un nuovo valore rilanciando la funzione "dado7"
    (if (< val 21)
      (+ 1 (% val 7))
      (dado7))))

(dado7)
;-> 4

Controlliamo la distribuzione dei valori (1..7):

(define (check-dado7 limite)
  (let (freq (array 8 '(0)))
    (for (i 1 limite)
      (++ (freq (dado7))))
    (println (slice freq 1))
    (println (slice (map (fn(x) (div x limite)) freq) 1))))

(check-dado7 1e6)
;-> (142884 143126 142924 142771 142699 142583 143013)
;-> (0.142884 0.143126 0.142924 0.142771 0.142699 0.142583 0.143013)
(apply + '(142884 143126 142924 142771 142699 142583 143013))
;-> 1000000
(apply add '(0.142884 0.143126 0.142924 0.142771 0.142699 0.142583 0.143013))
;-> 1

(check-dado7 1e8)
;-> (14281766 14288029 14287001 14284639 14290141 14281342 14287082)
;-> (0.14281766 0.14288029 0.14287001 0.14284639 0.14290141 0.14281342 0.14287082)
(apply add '(0.14281766 0.14288029 0.14287001 0.14284639 0.14290141 0.14281342 0.14287082))
;-> 1
(apply + '(14281766 14288029 14287001 14284639 14290141 14281342 14287082))
;-> 100000000

Controlliamo anche la distribuzione del numero "val" in "dado7" (0..24):

(define (check-val limite)
  (let (freq (array 25 '(0)))
    (for (i 1 limite)
      (++ (freq (+ (* 5 (dado5)) (dado5) -6))))
    (println (slice freq 1))
    (println (slice (map (fn(x) (div x limite)) freq) 1))))

(check-val 1e6)
;-> (39900 39858 40061 39717 40064 39781 40031
;->  40248 40064 39950 39879 40036 40012 39988
;->  40246 40072 40045 39940 39958 40145 39985
;->  39825 40107 39754)
;-> (0.0399 0.039858 0.040061 0.039717 0.040064 0.039781 0.040031
;->  0.040248 0.040064 0.03995 0.039879 0.040036 0.040012 0.039988
;->  0.040246 0.040072 0.040045 0.03994 0.039958 0.040145 0.039985
;->  0.039825 0.040107 0.039754)

(check-val 1e8)
;-> (4001367 4001057 4001661 3999623 4000304 4002462 3999824
;->  3996966 3999206 4000869 3998084 4000704 4000113 4001563
;->  4000824 4001220 3995496 3999672 4000310 4002547 4000921
;->  3999067 3999375 3998509)
;-> (0.04001367 0.04001057 0.04001661 0.03999623 0.04000304 0.04002462 0.03999824
;->  0.03996966 0.03999206 0.04000869 0.03998084 0.04000704 0.04000113 0.04001563
;->  0.04000824 0.0400122 0.03995496 0.03999672 0.0400031 0.04002547 0.04000921
;->  0.03999067 0.03999375 0.03998509)


-----------------
42 in newLISP e C
-----------------

Dialogo dal libro "Guida galattica per autostoppisti" di Douglas Adams:

"What do you get if you multiply six by nine?"

"Six by nine. Forty two."

"That's it. That's all there is."

"I always thought something was fundamentally wrong with the universe"

In italiano:

"Cosa ottieni se moltiplichi sei per nove?"

"Sei per nove. Quarantadue."

"Questo è tutto. Questo è tutto quello che c'è."

"Ho sempre pensato che ci fosse qualcosa di fondamentalmente sbagliato nell'universo"

Vediamo come può risultare 6 * 9 = 42.

In newLISP possiamo notare che:

   6(b13) × 9(b13) = 42(b13)

dove (b13) indica base 13

(define (n42 a b)
  (let (n (* a b)) (string (/ n 13) (% n 13))))

(n42 6 9)
;-> "42"

In C possiamo utilizzare il preprocessore dei #define:

#include <stdio.h>
#define sei  1+5
#define nove 8+1
int main()
{
  printf("Cosa ottieni se moltiplichi sei per nove?\n");
  printf("%i x %i = %i\n", sei, nove, sei*nove);
}

;-> Cosa ottieni se moltiplichi sei per nove?
;-> 6 x 9 = 42

Nota: sei*nove ==> (1 + 5 * 8 + 1)


------------------------
Uguaglianza approssimata
------------------------

A volte, quando si verifica la correttezza di una soluzione numerica, la differenza nei calcoli in virgola mobile tra le diverse implementazioni dei linguaggi diventa significativa.

Ad esempio, una differenza tra i calcoli in virgola mobile a 32 bit e 64 bit può apparire intorno all'ottava cifra significativa nell'aritmetica in base 10.

Creare una funzione che restituisce true se due numeri in virgola mobile sono "approssimativamente" uguali, cioè uguali a meno di un certo valore (errore assoluto).

(define (abs-err x y) (abs (sub x y)))

(define (approx-equals x y abs-err-max)
  (< (abs-err x y) abs-err-max))

(approx-equals 0.03781234001 0.03781234002 1e-8)
;-> true
(approx-equals 0.03781234001 0.03781234002 1e-12)
;-> nil
(approx-equals 100000000000000.01 100000000000000.011 1e-8)
;-> true
(approx-equals 100000000000000.01 100000000000000.011 1e-1)
;-> true
(sub 100000000000000.01 100000000000000.011)
;-> 0
(approx-equals 100.01 100.011 1e-8)
;-> nil
(approx-equals 100.01 100.011 1e-1)
;-> true
(sub 100.01 100.011)
;-> -0.000999999999990564

Da notare che con numeri grandi il valore di abs-err-max perde di significato.

Another way to measure the difference between a floating-point number and the real number it is approximating is relative error, which is simply the difference between the two numbers divided by the real number. For example the relative error committed when approximating 3.14159 by 3.14 × 100 is .00159/3.14159  .0005.

(define (rel-err x y)
  (div (abs-err x y) x))

(rel-err 0.03781234001 0.03781234002)
;-> 2.644639507832383e-010
(rel-err 100000000000000.01 100000000000000.011)
;-> 0
(rel-err 100.01 100.011)
;-> 9.999000099895649e-006

Nota: sulle operazioni in floating-point bisogna assolutamente leggere:
"What Every Computer Scientist Should Know About Floating-Point Arithmetic" di David Goldberg, 1991


----------
Primi sexy
----------

I primi sexy sono numeri primi che differiscono l'uno dall'altro di sei. Ad esempio, i numeri 5 e 11 sono entrambi numeri primi sexy, perché 11 - 6 = 5. Il termine "primi sexy" è un gioco di parole che deriva dal fatto che in latino la parola "sex" significa "sei".

Coppie prime sexy: sono gruppi di due numeri primi che differiscono di 6. Esempi: (5 11), (7 13), (11 17)
Sequenze: OEIS:A023201 e OEIS:A046117

Triple di primi sexy: sono gruppi di tre numeri primi in cui ciascuno differisce dal successivo di 6. Esempi: (5 11 17), (7 13 19), (17 23 29)
Sequenze: OEIS:A046118, OEIS:A046119 e OEIS:A046120

Quadruple di prime sexy: sono gruppi di quattro numeri primi in cui ciascuno differisce dal successivo di 6. Esempio: (5 11 17 23), (11 17 23 29)
Sequenze: OEIS:A023271, OEIS:A046122, OEIS:A046123 e OEIS:A046124

Quintuple di primi sexy: sono gruppi di cinque numeri primi in cui ciascuno differisce dal successivo di 6. In una progressione aritmetica di cinque termini con differenza comune 6, uno dei termini deve essere divisibile per 5, perché 5 e 6 sono relativamente primi. Quindi l'unica quintupla di primi sexy possibile vale (5 11 17 23 29).

Funzione che verifica se un numero è primo:

(define (prime? num)
   (if (< num 2) nil
       (= 1 (length (factor num)))))

Funzione che calcola tutte le coppie di primi sexy fino a un determinato numero:

(define (sexy-pairs-to num)
  (let (out '())
    (for (i 2 (- num 6))
      (if (and (prime? i) (prime? (+ i 6)))
          (push (list i (+ i 6)) out -1)
      )
    )
    out))

(sexy-to 100)
;-> ((5 11) (7 13) (11 17) (13 19) (17 23) (23 29) (31 37) (37 43) (41 47) (47 53) (53 59)
;->  (61 67) (67 73) (73 79) (83 89))

(length (sexy-to 1e6))
;-> 16386

Funzione che restituisce il numero di tutte le coppie, le triple, le quadruple e le quintuple di numeri primi sexy fino a un determinato numero:

(define (sexy-all-to-count num)
  (local (p2 p3 p4 p5)
    (for (i 2 (- num 6))
      (if (and (prime? i) (prime? (+ i 6))) (begin
          (++ p2)
          (if (prime? (+ i 12)) (begin
              (++ p3)
              (if (prime? (+ i 18)) (begin
                  (++ p4)
                  (if (prime? (+ i 24))
                      (++ p5)))))))))
    (list p2 p3 p4 p5)))

Calcoliamo fino a 1000:

(sexy-all-to-count 1000)
;-> (74 28 7 1)
74 coppie, 28 triple, 7 quadruple e 1 quintupla.

Calcoliamo fino a 1 milione:

(sexy-all-to-count 1e6)
;-> (16386 2900 325 1)

Vediamo i tempi di esecuzione:

(time (sexy-all-to-count 1e6))
;-> 871.882
(time (sexy-all-to-count 1e7))
;-> 18786.703

Funzione che restituisce tutte le coppie, le triple, le quadruple e le quintuple di numeri primi sexy fino a un determinato numero:

(define (sexy-all-to num)
  (local (arr)
    (setq arr (array 4 '(())))
    (for (i 2 (- num 6))
      (if (and (prime? i) (prime? (+ i 6))) (begin
          (push (list i (+ i 6)) (arr 0) -1)
          (if (prime? (+ i 12)) (begin
              (push (list i (+ i 6) (+ i 12)) (arr 1) -1)
              (if (prime? (+ i 18)) (begin
                  (push (list i (+ i 6) (+ i 12) (+ i 18)) (arr 2) -1)
                  (if (prime? (+ i 24))
                      (push (list i (+ i 6) (+ i 12) (+ i 18) (+ i 24)) (arr 3) -1)))))))))
    arr))

Calcoliamo fino a 1000:

(setq sp (sexy-all-to 1000))
(length (sp 0))
;-> 74
(length (sp 1))
;-> 28
(length (sp 2))
;-> 7
(length (sp 3))
;-> 1
(sp 3)
;-> ((5 11 17 23 29))
(sp 2)
;-> ((5 11 17 23) (11 17 23 29) (41 47 53 59) (61 67 73 79)
;->  (251 257 263 269) (601 607 613 619) (641 647 653 659))
((sp 2) 0)
;-> (5 11 17 23)

Calcoliamo fino a 1 milione:

(silent (setq sp (sexy-all-to 1e6)))
(length (sp 0))
;-> 16386
(length (sp 1))
;-> 2900
(length (sp 2))
;-> 325
(length (sp 3))
;-> 1
((sp 2) 324)
;-> (997091 997097 997103 997109)

Vediamo i tempi di esecuzione:

(time (sexy-all-to 1e6))
;-> 872.753

(time (sexy-all-to 1e7))
;-> 18895.465

Possiamo scrivere un'altra funzione che utilizza una hash-map per contenere i numeri primi.

Funzione che calcola i primi fino ad un determinato numero e li mette in una hash-map (che verrà definita nella funzione successiva):

(define (primes-to-h num)
;(new Tree 'primih)
  (cond ((= num 1) (primih))
        ((= num 2) (primih "2" "2") (primih))
        (true
         (let (arr (array (+ num 1)))
          (primih "2" "2")
          (for (x 3 num 2)
                (when (not (arr x))
                  (primih x x)
                  (for (y (* x x) num (* 2 x) (> y num))
                      (setf (arr y) true)))) (primih)))))

Test con hash-map "primih" definita dentro la funzione (bisogna togliere il commento alla riga (new Tree 'primih)):

(length (primes-to-h 10000000))
;-> 664579
(delete 'primih)
(time (primes-to-h 1e6))
;-> 195.527
(delete 'primih)
(time (primes-to-h 1e7))
;-> 2046.079
(delete 'primih)

Funzione che restituisce il numero di tutte le coppie, le triple, le quadruple e le quintuple di numeri primi sexy fino a un determinato numero:

(define (sexy-all-to-count2 num)
  (local (p2 p3 p4 p5)
    (new Tree 'primih)
    (primes-to-h num)
    (dolist (p (primih))
      (if (primih (+ (int (p 1)) 6)) (begin
          (++ p2)
          (if (primih (+ (int (p 1)) 12)) (begin
              (++ p3)
              (if (primih (+ (int (p 1)) 18)) (begin
                  (++ p4)
                  (if (primih (+ (int (p 1)) 24))
                      (++ p5)))))))))
    (delete 'primih)
    (list p2 p3 p4 p5)))

Calcoliamo fino a 1000:

(sexy-all-to-count2 1000)
;-> (74 28 7 1)

Calcoliamo fino a 1 milione:

(sexy-all-to-count2 1e6)
;-> (16386 2900 325 1)

Vediamo i tempi di esecuzione:

(time (sexy-all-to-count2 1e6))
;-> 260.973

(time (sexy-all-to-count2 1e7))
;-> 2779.626

(time (sexy-all-to-count2 1e8))
;-> 30688.684

La funzione che utilizza la hash-map è molto più veloce (quasi 7 volte più veloce).


-----------------
Tavola pitagorica
-----------------

Scrivere una funzione che stampa la tavola pitagorica (Tavola/tabella delle moltiplicazioni) fino a un determinato numero.

(define (pitagorica num)
    (print "\n    ·")
    (for (i 1 num)
      (print (format "%4d" i))
    )
    (println (format "\n%s" (dup "·" (* (+ num 2) 4))))
    (for (i 1 num)
      (print (format "%3d%s" i " ·"))
      (for (j 1 num)
        (print (format "%4d" (* i j)))
      )
      (println "\n    ·")
    )
    'end)

(pitagorica 12)
;->
;->     ·   1   2   3   4   5   6   7   8   9  10  11  12
;-> ························································
;->   1 ·   1   2   3   4   5   6   7   8   9  10  11  12
;->     ·
;->   2 ·   2   4   6   8  10  12  14  16  18  20  22  24
;->     ·
;->   3 ·   3   6   9  12  15  18  21  24  27  30  33  36
;->     ·
;->   4 ·   4   8  12  16  20  24  28  32  36  40  44  48
;->     ·
;->   5 ·   5  10  15  20  25  30  35  40  45  50  55  60
;->     ·
;->   6 ·   6  12  18  24  30  36  42  48  54  60  66  72
;->     ·
;->   7 ·   7  14  21  28  35  42  49  56  63  70  77  84
;->     ·
;->   8 ·   8  16  24  32  40  48  56  64  72  80  88  96
;->     ·
;->   9 ·   9  18  27  36  45  54  63  72  81  90  99 108
;->     ·
;->  10 ·  10  20  30  40  50  60  70  80  90 100 110 120
;->     ·
;->  11 ·  11  22  33  44  55  66  77  88  99 110 121 132
;->     ·
;->  12 ·  12  24  36  48  60  72  84  96 108 120 132 144
;->     ·


----------------------------------------------------------------------
Sottostringa più piccola che contiene tutti i caratteri di una stringa
----------------------------------------------------------------------

Data una stringa, trovare la sottostringa più piccola con tutti i caratteri distinti della stringa data.
Per esempio:

Stringa = "aabcbcdbca"
Soluzione = "dbca"
Dell'insieme delle possibili sottostringhe 'dbca' è la sottostringa più corta con tutti i caratteri distinti della stringa data.

Stringa = "aaab"
Soluzione = "ab"
Dell'insieme delle possibili sottostringhe 'ab' è la sottostringa più corta con tutti i caratteri distinti della stringa data.

Utilizziamo la tecnica sliding window (finestra scorrevole) per arrivare alla soluzione. Questa tecnica mostra come un ciclo for annidato in alcuni problemi può essere convertito in un singolo ciclo for e quindi riducendo la complessità temporale.

Metodo: Fondamentalmente manteniamo una finestra di caratteri utilizzando due puntatori, uno di inizio e uno di fine. Questi puntatori di inizio e fine possono essere utilizzati rispettivamente per ridurre e aumentare le dimensioni della finestra. Ogni volta che la finestra contiene tutti i caratteri di una determinata stringa, la finestra viene ridotta dal lato sinistro per rimuovere i caratteri extra e quindi la sua lunghezza viene confrontata con la finestra più piccola trovata finora.
Se nella finestra presente non è possibile eliminare più caratteri allora iniziamo ad aumentare la dimensione della finestra utilizzando la fine fino a quando tutti i caratteri distinti presenti nella stringa sono presenti anche nella finestra. Infine, troviamo la dimensione minima di ogni finestra.

  1. Mantenere un vettore (visited) del massimo di caratteri possibili (256 caratteri) e non appena ne troviamo uno nella stringa, contrassegnare quell'indice nell'array (questo per contare tutti i caratteri distinti nella stringa).
  2. Prendere due puntatori inizio e fine che segneranno l'inizio e la fine della finestra.
  3. Prendere un contatore=0 che verrà utilizzato per contare i caratteri distinti nella finestra.
  4. Adesso iniziare a leggere i caratteri della stringa data e se ci imbattiamo in un carattere non ancora visitato incrementare il contatore di 1.
  5. Se il contatore è uguale al numero totale di caratteri distinti, provare a ridurre la finestra.
  6. Per restringere la finestra:
      a. Se la frequenza del carattere all'inizio del puntatore è maggiore di 1, incrementare il puntatore poiché è ridondante.
      b. Ora confrontare la lunghezza della finestra attuale con la lunghezza minima della finestra.

(define (find-substr str)
  (local (len-str curr-count start start-index dist-count visited idx conta min-len len-window)
    (setq len-str (length str))
    ; conta tutti i caratteri distinti
    (setq dist-count 0)
    (setq visited (array 256 '(nil)))
    (for (i 0 (- len-str 1))
      (setq idx (char (str i)))
      (if (nil? (visited idx))
        (begin
          (setq idx (char (str i)))
          (setf (visited idx) true)
          (++ dist-count)
        )
      )
    )
    ; Fondamentalmente manteniamo una finestra di caratteri
    ; che contiene tutti i caratteri della stringa data.
    (setq start 0 start-index -1 min-len 999999)
    (setq conta 0)
    (setq curr-count (array 256 '(0)))
    (for (j 0 (- len-str 1))
      ; Conta l'occorrenza dei caratteri di stringa
      (setq idx (char (str j)))
      (++ (curr-count idx))
      ; Se qualsiasi carattere distinto corrisponde, quindi aumentare il conteggio
      (if (= (curr-count idx) 1)
          (++ conta)
      )
      ; se tutti i caratteri sono abbinati
      (if (= conta dist-count) (begin
          ; Provare a ridurre a icona la finestra, ad esempio controllare se
          ; qualsiasi carattere si verifica un numero di volte maggiore
          ; rispetto al numero delle sue occorrenze nel modello, se sì
          ; allora rimuoverlo dall'inizio e rimuovere anche
          ; i caratteri inutili
          (setq idx (char (str start)))
          (while (> (curr-count idx) 1)
            (if (> (curr-count idx) 1)
                (-- (curr-count idx))
            )
            (++ start)
            (setq idx (char (str start)))
          )
          ; Aggiorna le dimensioni della finestra
          (setq len-window (+ j 1 (- start)))
          (if (> min-len len-window) (begin
              (setq min-len len-window)
              (setq start-index start))
          )
      ))
    )
    ; Restituisce la sottostringa a partire da start_index e di lunghezza min_len
    (slice str start-index min-len)))

(find-substr "aabcbcdbca")
;-> "dbca"
(find-substr "aaab")
;-> "ab"
(find-substr "supercalifragilisticexpialidocious")
;-> "fragilisticexpialidociou"

Nota:
"Supercalifragilisticexpialidocious" è una canzone scritta dai fratelli Richard Sherman e Robert Sherman, che fa parte della colonna sonora di Mary Poppins, film Disney del 1964.
Nella versione originale la parola ha un significato ben preciso, che si evince scomponendola: Super (sopra) – cali (bellezza) – fragilistic (delicato) – expiali (fare ammenda) – docious (istruibile). Quindi il significato delle sue parti sarebbe “fare ammenda per la possibilità di insegnare attraverso la delicata bellezza”.
La versione italiana "Supercalifragilistichespiralidoso" è cantata da Tina Centi, Rita Pavone e Nancy Cuomo.


------------------------
Algoritmo Floyd-Warshall
------------------------

L'algoritmo di Floyd-Warshall viene utilizzato per trovare i percorsi più brevi tra tutte le coppie di vertici di un grafo orientato con pesi degli archi positivi o negativi. Supponiamo che il grafo non ha cicli, archi paralleli o cicli negativi.

Ciclo (Loop):
Nella teoria dei grafi, un ciclo (loop o self-loop o buckle) è un arco che collega un vertice (nodo) a se stesso. Un grafo semplice non contiene cicli

Archi Paralleli (Parallel Edge):
Gli archi paralleli (parallel edge o multi-edge) sono, in un grafo non orientato, due o più archi incidenti agli stessi due vertici, o in un grafo orientato, due o più archi con la stessa direzione incidenti a due stessi vertici. Un grafo semplice non ha archi paralleli.

Cicli Negativi (Negative cycle):
Se un grafo contiene un "ciclo negativo" (cioè un ciclo i cui archi si sommano a un valore negativo) che è raggiungibile dalla sorgente, allora non esiste un percorso più economico: qualsiasi percorso che ha un punto sul ciclo negativo può essere reso più economico da un altro giro intorno al ciclo negativo.

Scrivere una funzione che implementa questo algoritmo (vedi wikipedia per maggiori informazioni).

Grafo di esempio:

        {1}
        · \
     4 /   \ -2
      /  3  ·
    {2}----·{3}
      ·     /
    -1 \   / 2
        \ ·
        {4}

  Vertici: (1 2 3 4)
  Archi: (1 3) dist -2
         (2 1) dist 4
         (2 3) dist 3
         (3 4) dist 2
         (4 2) dist -1

Rappresentiamo questo grafo come una lista di archi adiacenti:

  Lista archi adiacenti: (v1 v2 val)
  v1 = nodo di partenza
  v2 = nodo di arrivo
  val = peso dell'arco

(setq grafo '((1 3 -2) (2 1 4) (2 3 3) (3 4 2) (4 2 -1)))

Scriviamo la funzione:

(define (floyd-warshall graph num-vertex)
  (local (num-edge dist next u v coppia coppia-dist vertex out)
    (setq out '())
    (setq num-edge (length graph))
    (setq dist (array num-vertex num-vertex '(999999)))
    (for (i 0 (- num-edge 1))
      (setf (dist (- (graph i 0) 1) (- (graph i 1) 1)) (graph i 2))
    )
    (setq next (array num-vertex num-vertex '(999999)))
    (for (i 0 (- (length next) 1))
      (for (j 0 (- (length next) 1))
        (if (!= i j)
            (setf (next i j) (+ j 1))
        )
      )
    )
    (for (k 0 (- num-vertex 1))
      (for (i 0 (- num-vertex 1))
        (for (j 0 (- num-vertex 1))
          (if (< (+ (dist i k) (dist k j)) (dist i j))
            (begin
              (setf (dist i j) (+ (dist i k) (dist k j)))
              (setf (next i j) (next i k))
            )
          )
        )
      )
    )
    ; ricostruisce i percorsi minimi (soluzioni)
    (for (i 0 (- (length next) 1))
      (for (j 0 (- (length next) 1))
        (if (!= i j)
          (begin
            (setq u (+ i 1))
            (setq v (+ j 1))
            (setq coppia (list u v))
            (setq coppia-dist (dist i j))
            (setq vertex '())
            (push u vertex -1)
            (do-while (!= u v)
              (setq u (next (- u 1) (- v 1)))
              (push u vertex -1)
            )
            (push (list coppia coppia-dist vertex) out -1)
          )
        )
      )
    )
    out))

Proviamo con il grafo di esempio:
(setq grafo '((1 3 -2) (2 1 4) (2 3 3) (3 4 2) (4 2 -1)))

(setq sol (floyd-warshall grafo 4))
;-> (((1 2) -1 (1 3 4 2))
;->  ((1 3) -2 (1 3))
;->  ((1 4)  0 (1 3 4))
;->  ((2 1)  4 (2 1))
;->  ((2 3)  2 (2 1 3))
;->  ((2 4)  4 (2 1 3 4))
;->  ((3 1)  5 (3 4 2 1))
;->  ((3 2)  1 (3 4 2))
;->  ((3 4)  2 (3 4))
;->  ((4 1)  3 (4 2 1))
;->  ((4 2) -1 (4 2))
;->  ((4 3)  1 (4 2 1 3)))

Definiamo una funzione che estrae il percorso minimo tra due vertici:

(define (path v1 v2 sol)
  (let (idx (first (ref (list v1 v2) sol)))
    (println "Da " v1 " a " v2)
    (println "Distanza minima: " (sol idx 1))
    (println "Percorso: " (sol idx 2))))

(path 3 1 sol)
;-> Da 3 a 1
;-> Distanza minima: 5
;-> Percorso: (3 4 2 1)

Proviamo con un altro grafo (da disegnare con carta e penna):

(setq graph '((1 2 50) (1 3 30) (1 4 10)
              (2 1 50) (2 6 40)
              (3 1 30) (3 2 10) (3 4 10) (3 5 10)
              (4 1 10) (4 3 10) (4 7 10)
              (5 3 10) (5 4 20)
              (6 2 40) (6 5 20)
              (7 6 80)))

(setq sol (floyd-warshall graph 7))
;-> (((1 2) 30 (1 4 3 2))
;->  ((1 3) 20 (1 4 3))
;->  ((1 4) 10 (1 4))
;->  ((1 5) 30 (1 4 3 5))
;->  ((1 6) 70 (1 4 3 2 6))
;->  ((1 7) 20 (1 4 7))
;->  ((2 1) 50 (2 1))
;->  ((2 3) 70 (2 1 4 3))
;->  ((2 4) 60 (2 1 4))
;->  ((2 5) 60 (2 6 5))
;->  ((2 6) 40 (2 6))
;->  ((2 7) 70 (2 1 4 7))
;->  ((3 1) 20 (3 4 1))
;->  ((3 2) 10 (3 2))
;->  ((3 4) 10 (3 4))
;->  ((3 5) 10 (3 5))
;->  ((3 6) 50 (3 2 6))
;->  ((3 7) 20 (3 4 7))
;->  ((4 1) 10 (4 1))
;->  ((4 2) 20 (4 3 2))
;->  ((4 3) 10 (4 3))
;->  ((4 5) 20 (4 3 5))
;->  ((4 6) 60 (4 3 2 6))
;->  ((4 7) 10 (4 7))
;->  ((5 1) 30 (5 4 1))
;->  ((5 2) 20 (5 3 2))
;->  ((5 3) 10 (5 3))
;->  ((5 4) 20 (5 4))
;->  ((5 6) 60 (5 3 2 6))
;->  ((5 7) 30 (5 4 7))
;->  ((6 1) 50 (6 5 4 1))
;->  ((6 2) 40 (6 2))
;->  ((6 3) 30 (6 5 3))
;->  ((6 4) 40 (6 5 4))
;->  ((6 5) 20 (6 5))
;->  ((6 7) 50 (6 5 4 7))
;->  ((7 1) 130 (7 6 5 4 1))
;->  ((7 2) 120 (7 6 2))
;->  ((7 3) 110 (7 6 5 3))
;->  ((7 4) 120 (7 6 5 4))
;->  ((7 5) 100 (7 6 5))
;->  ((7 6) 80 (7 6)))

(path 7 1 sol)
;-> Da 7 a 1
;-> Distanza minima: 130
;-> Percorso: (7 6 5 4 1)


-----------------
Triangoli casuali
-----------------

Dati tre punti casuali nel piano cartesiano xy, determinare se possono formare un triangolo.
Questo è semplice: tre punti su un piano determinano sempre un triangolo, tranne quando sono tutti e tre allineati.

Dati tre segmenti di lunghezza casuale, determinare se possono formare un triangolo.

Poniamo che a, b e c siano le lunghezze di tre segmenti, allora questi possono formare un triangolo se risultano vere tutte le seguenti condizioni:

  1. a + b > c
  2. a + c > b
  3. b + c > a

Quindi possiamo scrivere la seguente funzione:

(define (tri1? a b c)
  (if (or (<= (add a b) c) (<= (add a c) b) (<= (add b c) a))
      nil
      true))

(tri1? 7 10 5)
;-> true
(tri1? 1 1 1)
;-> true
(tri1? 1 1 2)
;-> nil
(tri1? 1 2 4)
;-> nil

Nota: usiamo l'operatore "or" perchè valuta true al primo valore true dell'espressione.

Analogamente possiamo osservare che se la somma dei tre segmenti è maggiore del doppio del lato maggiore, allora è possibile formare un triangolo (cioè se c'è un lato più lungo della somma degli altri due):

(define (tri2? a b c)
  (> (add a b c) (mul 2 (max a b c))))

(tri2? 7 10 5)
;-> true
(tri2? 1 1 1)
;-> true
(tri2? 1 1 2)
;-> nil
(tri2? 1 2 4)
;-> nil

Vediamo la frequenza dei segmenti che possono formare un triangolo.

Funzione per generare un numero float in un intervallo chiuso:

(define (rnd-range min-val max-val)
  (add min-val (mul (random) (sub max-val min-val))))

; Funzione per generare un numero float normalizzato (distribuzione uniforme):
;(define (rnd-range min-val max-val)
;  (mul (random) (sub max-val min-val)))

La seguente chiamata può generare anche 10 o 20:

(rnd-range 10 20)
;-> 18.88943144016846

(for (i 1 100000) (if (= (rnd-range 10 20) 10) (println "10")))

Adesso definiamo una funzione che crea, per un determinato numero di volte, tre segmenti casuali e controlla se possono formare un triangolo :

(define (test-triangle min-d max-d iter)
  (local (tri a b c)
    (seed (time-of-day))
    (setq tri 0)
    (for (i 1 iter)
      (setq a (rnd-range min-d max-d))
      (setq b (rnd-range min-d max-d))
      (setq c (rnd-range min-d max-d))
      (if (tri1? a b c)
          (++ tri)
      )
    )
    (println tri { } (- iter tri))))

(test-triangle 10 20 1e6)
;-> 1000000 0 ; perchè la somma di due lati qualunque è sempre maggiore del terzo.

(test-triangle 100 200 1e6)
;-> 1000000 0 ; perchè la somma di due lati qualunque è sempre maggiore del terzo.

(test-triangle 10 60 1e6)
;-> 743012 256988

Il numero di triangoli possibili diminuisce con l'aumentare della lunghezza dei lati:

(test-triangle 10 110 1e6)
;-> 635927 364073
(test-triangle 10 1010 1e6)
;-> 514827 485173
(test-triangle 10 10010 1e6)
;-> 502024 497976
(test-triangle 10 100010 1e6)
;-> 500194 499806
(test-triangle 10 1000010 1e6)
;-> 499571 500429
(test-triangle 10 10000010 1e6)
;-> 499791 500209
(test-triangle 10 100000010 1e6)
;-> 500058 499942

Ma non scende mai sotto il 50%.

Infatti se utilizziamo un intervallo normalizzato otteniamo il 50%:

(test-triangle 0 1 1e6)
;-> 500054 499946
(test-triangle 0 1000 1e6)
;-> 500018 499982

Dal punto di vista matematico, siano a,b,c i tre numeri. La probabilità che c > a+b è data da:

 1     c    (c-b)
 ∫dc * ∫db * ∫da = 1/6
 0     0     0

Una qualsiasi delle tre variabili potrebbe essere la più grande, quindi moltiplichiamo per 3 e otteniamo 1/2.

Geometricamente, supponiamo che il più grande dei tre sia a. Quindi gli altri due devono trovarsi nel quadrato di area a^2. In quel quadrato, la diagonale nord-ovest-sudest è la linea dove gli altri due si sommano ad a. Al di sotto di quella linea, gli altri due sommano a meno di a. Chiaramente quella linea taglia il quadrato a metà. Quindi, per ogni a, la probabilità è 1/2.


----------------------
Triangoli e bastoncini
----------------------

Abbiamo un bastoncino di una lunghezza unitaria. Due punti sul bastoncino vengono selezionati casualmente (uniformemente lungo la lunghezza del bastoncino) e indipendentemente. Quindi rompiamo il bastoncino in questi due punti in modo da ottenere tre pezzi dal bastoncino. Qual è la probabilità che questi tre pezzi formino un triangolo?

Poniamo che a, b e c siano le lunghezze dei tre segmenti del bastoncino, allora questi possono formare un triangolo se risultano vere tutte le seguenti condizioni:

  1. a + b > c
  2. a + c > b
  3. b + c > a

Quindi possiamo scrivere la seguente funzione:

(define (tri? a b c)
  (if (or (<= (add a b) c) (<= (add a c) b) (<= (add b c) a))
      nil
      true))

Nota: usiamo l'operatore "or" perchè valuta true al primo valore true dell'espressione.

(tri? 7 10 5)
;-> true
(tri? 1 1 1)
;-> true
(tri? 1 1 2)
;-> nil
(tri? 1 2 4)
;-> nil

(define (dist2d x1 y1 x2 y2)
"Calculate 2D Cartesian distance of two points P1 = (x1 y1) and P2 = (x2 y2)"
  (sqrt (add (mul (sub x1 x2) (sub x1 x2))
             (mul (sub y1 y2) (sub y1 y2)))))

Scriviamo la funzione di simulazione:

(define (bastoncino iter)
  (local (tri a b c)
    (seed (time-of-day))
    (setq tri 0)
    (for (i 1 iter)
      (setq t1 (random))
      (setq t2 (random))
      (if (> t1 t2) (swap t1 t2))
      (setq a t1)
      (setq b (sub t2 t1))
      (setq c (sub 1 t2))
      (if (tri? a b c)
          (++ tri)
      )
    )
    (println tri { } (- iter tri))))

(bastoncino 1000)
;-> 247 753
(bastoncino 10000)
;-> 2582 7418
(bastoncino 1e6)
;-> 250813 749187
(time (println (bastoncino 1e8)))
;-> 25001002 74998998
;-> 50731.957

Quindi la probabilità che si formi un triangolo vale il 25% (1/4).

Dal punto di vista matematico, poniamo l'origine sull'estremità sinistra del bastone. Sia X la lunghezza dall'origine al primo punto selezionato. Sia Y la lunghezza dall'origine al secondo punto selezionato.
Nota che quando X=Y, abbiamo solo due pezzi e non possono formare un triangolo, quindi assumiamo X≠Y.
Assumiamo innanzitutto che X<Y. Quindi, dopo aver rotto il bastone, abbiamo tre pezzi di lunghezza X, Y−X e 1−Y, rispettivamente.

                   Y
    -----|---------|-------
    0    X                1

    -----  ---------  -------
      X     (Y - X)   (1 - Y)

Consideriamo ora le condizioni per cui tre segmenti di lunghezza a, b e c formino un triangolo in generale:

  a + b > c
  b + c > a
  c + a > b

e sostituiamo a,b e c con i parametri dei tre segmenti:

        X + (Y - X) > (1 -Y)
  (Y - X) + (1 - Y) > X
        (1 - Y) + X > (Y - X)

e semplificando otteniamo:

  Y > 1/2
  X < 1/2
  Y < X + 1/2

In alternativa, possiamo trovare la probabilità per il caso X > Y come segue. Per argomento di simmetria, dobbiamo semplicemente scambiare X e Y e ottenere le condizioni:

  X > 1/2
  Y < 1/2
  X < Y + 1/2

La soluzione di questi due sistemi di disuguaglianze viene rappresentata nella figura "bastoncino.png" presente nella cartella "data".

Poichè la funzione di densità congiunta di X e Y è distribuita uniformemente sul quadrato unitario, la probabilità che tre pezzi formino un triangolo sotto l'assunzione X < Y è data dall'area grigia della regione triangolare contrassegnata con A, che vale 1/8.
Per simmetria, il caso X > Y dà la stessa probabilità (1/8) raffigurata dalla regione triangolare B. Quindi, la probabilità totale vale:

  P(T | X > Y) + P(T | Y > X) = 1/8 + 1/8  = 1/4


----------------------------------------------------------
Generazione di una lista di numeri casuali che sommano a 1
----------------------------------------------------------

Per generare una lista di numeri casuali che sommano a 1 possiamo generare una lista di numeri casuali tra 0 e 1 e poi dividerli per la loro somma.

(define (rnd-list-one num)
  (let (tmp (random 0 1 num))
    (setq sum (apply add tmp))
    (map (fn(x) (div x sum)) tmp)))

(rnd-list-one 10)
;-> (0.1265890983499499 0.1624363272236493 0.06672036222734991
;->  0.03061191170708346 0.09963428969480603 0.09536222734990639
;->  0.04756410814576168 0.06689995210936479 0.139606643737211
;->  0.1645750794549175)

Verifichiamo che la somma valga sempre 1 (o 0.9999999999999999):

(dotimes (x 9) (println (apply add (rnd-list-one 10))))
;-> 1
;-> 1
;-> 0.9999999999999999
;-> 1
;-> 0.9999999999999998
;-> 1
;-> 1
;-> 0.9999999999999999
;-> 0.9999999999999999
;-> 0.9999999999999999

Nota:
(add 0.9999999999999999 1)
;-> 2

Purtroppo questo metodo non produce una distribuzione uniforme dei valori (perchè una distribuzione uniforme non è più tale dopo un'operazione di scala).

Invece, il seguente algoritmo dovrebbe produrre una distribuzione uniforme di N numeri casuali che sommano a 1.

1. Creare una lista di N - 1 numeri casuali tra 0 e 1
2. Aggiungere alla lista 0 e 1 (ottenendo una lista di N + 1 numeri)
3. Ordinare la lista
4. Calcolare le differenze delle coppie di elementi(cioè, calcolare le N differenze num(i) - num(i-1)) ottenendo un totale di N numeri).

(define (rnd-list num)
  (let (tmp (random 0 1 (- num 1)))
    (push 0 tmp)
    (push 1 tmp -1)
    (sort tmp)
    ; crea una lista con le differenze
    ; delle coppie di elementi el(i) - el(i-1)
    (map sub (rest tmp) (chop tmp))))

(setq a (rnd-list 5))
;-> (0.174108096560564 0.5363933225501267 0.03610339671010465 0.1123386333811457 0.141056550798059)

(apply add a)
;-> 1

Possiamo estrapolare la funzione alla generazione di numeri interi con somma predefinita:

(for (i 1 100000) (if (= 100 (rand 100)) (println "0")))

(define (rnd-int-list num sum)
  (let (tmp (rand sum (- num 1)))
    (push 0 tmp)
    (push sum tmp -1)
    (sort tmp)
    (println tmp)
    ; crea una lista con le differenze
    ; delle coppie di elementi el(i) - el(i-1)
    (map sub (rest tmp) (chop tmp))))

(setq b (rnd-int-list 5 100))
;-> (14 24 31 10 21)
(apply + b)
;-> 100
(setq b (rnd-int-list 100 1000))
;-> (10 1 4 6 1 40 6 31 2 1 0 14 2 12 14 1 4 2 10 6 9 8 9 27 6
;->  9 7 20 1 27 1 6 7 5 4 33 2 6 14 19 14 9 17 2 5 21 15 1 8
;->  42 17 15 15 8 9 9 2 18 2 4 5 8 2 2 7 12 26 21 1 7 4 40 5
;->  14 7 23 7 17 0 2 1 21 3 1 5 16 1 3 5 20 29 15 3 0 8 10 4 5 7 13)
(apply + b)
;-> 1000


---------------
Numeri disarium
---------------

Sono quei numeri tali che la somma delle sue cifre elevate alle potenze consecutive (1,2,3,...) è uguale al numero stesso.
La potenza vale 1 partendo dalla cifra più significativa (quella più a sinistra del numero).

Sequenza OEIS A032799:
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 89, 135, 175, 518, 598,
  1306, 1676, 2427, 2646798, 12157692622039623539, ...

Funzione che verifica se un numero è disarium:

(define (disarium? num)
  (if (zero? num) 0
      (local (sum numero p)
        (setq numero num)
        (setq sum 0)
        (setq len (length num))
        (setq p len)
        (while (and (!= num 0) (<= sum numero))
        ;(while (!= num 0)
          (setq sum (+ sum (pow (% num 10) p)))
          (-- p)
          (setq num (/ num 10))
        )
        (= sum numero))))

(disarium? 89)
;-> true
(disarium? 17557)

(apply + (list (pow 7 1) (pow 5 2) (pow 5 3) (pow 7 4) (pow 1 5)))

Funzione che calcola i numeri disarium fino ad un determinato limite:

(define (disarium-to limite)
  (let (out '())
    (for (i 0 limite)
      (if (disarium? i) (push i out -1)))
    out))

(disarium-to 10000)
;-> (0 1 2 3 4 5 6 7 8 9 89 135
;->  175 518 598 1306 1676 2427)

(time (println (disarium-to 1e7)))
;-> (0 1 2 3 4 5 6 7 8 9 89 135 175 518 598 1306 1676 2427 2646798)
;-> 19445.957 ; 20 secondi circa

Il numero successivo, 12157692622039623539, non è calcolabile con questa funzione. Però possiamo verificare che sia effettivamente un numero disarium:

(disarium? 12157692622039623539)
;-> ERR: number out of range in function <=
;-> called from user function (disarium? 12157692622039623539L)

Oops, il numero è maggiore di MAX-INT = 9223372036854775807, quindi dobbiamo usare i big-integer:

(define (** num power)
    (let (out 1L)
        (dotimes (i power)
            (setq out (* out num)))))

(define (disarium-big? num)
  (if (zero? num) 0L
      (local (sum numero)
        (setq numero num)
        (setq sum 0L)
        (setq len (length num))
        (while (and (!= num 0) (<= sum numero))
          (setq sum (+ sum (** (% num 10) len)))
          (-- len)
          (setq num (/ num 10))
        )
        (= sum numero))))

(disarium-big? 2427)
;-> true
(disarium-big? 12157692622039623539)
;-> true

Cambiamo anche la funzione che calcola i numeri disarium fino ad un determinato limite per gestire i big-integer:

(define (disarium-big-to limite)
  (let (out '())
    (for (i 0 limite)
      (if (disarium-big? i) (push i out -1)))
    out))

(disarium-big-to 10000)
;-> (0 1 2 3 4 5 6 7 8 9 89 135
;->  175 518 598 1306 1676 2427)

(time (println (disarium-big-to 1e7)))
;-> (0 1 2 3 4 5 6 7 8 9 89 135 175 518 598 1306 1676 2427 2646798)
;-> 223413.805

Chiaramente neanche con questa funzione possiamo calcolare il valore 12157692622039623539 (o quello successivo).


--------------
Numeri promici
--------------

Un numero si dice promico (pronico) se è il prodotto di due numeri interi consecutivi.
Ad esempio, se consideriamo il numero 72, è il prodotto di due interi consecutivi 8 e 9. Pertanto, 72 è un numero promico.
Ora, se consideriamo il numero 16, è il prodotto di 2 e 8 o 4 e 4 ma nessuno è gli interi consecutivi. Pertanto, 16 non è un numero promico.

Sequenza OEIS A002378:
  0, 2, 6, 12, 20, 30, 42, 56, 72, 90, 110, 132, 156, 182, 210, 240, 272,
  306, 342, 380, 420, 462, 506, 552, 600, 650, 702, 756, 812, 870, 930,
  992, 1056, 1122, 1190, 1260, 1332, 1406, 1482, 1560, 1640, 1722, 1806,
  1892, 1980, 2070, 2162, 2256, 2352, 2450, 2550, ...

Algoritmo:
Eseguire un ciclo da 1 a metà del numero e se il numero è il prodotto di due numeri consecutivi qualsiasi, il numero è un numero promico, altrimenti no.

(define (promico? num)
  (let (out nil)
    (for (i 1 (/ num 2) 1 out)
      (if (= num (* i (+ i 1)))
          (setq out true))
    )
  out))

(promico? 0)
;-> true
(promico? 72)
;-> true
(promico? 30)
;-> true
(promico? 100)
;-> nil

Per trovare tutti i numeri promici fino ad un certo limite la funzione è la seguente:

(define (promici-to limite)
  (let ((prom 0) (i 0) (out '()))
    (while (< prom limite)
      (push prom out -1)
      (++ i)
      (setq prom (* i (+ i 1)))
    )
    out))

(promici-to 2600)
;-> (0 2 6 12 20 30 42 56 72 90 110 132 156 182 210 240 272
;->  306 342 380 420 462 506 552 600 650 702 756 812 870 930
;->  992 1056 1122 1190 1260 1332 1406 1482 1560 1640 1722
;->  1806 1892 1980 2070 2162 2256 2352 2450 2550)


----------------
Formula di Erone
----------------

La formula di Erone permette di calcolare l'area di un triangolo di cui sono note le misure dei lati.
Indichiamo co n a,b,c i lati di untriangolo qualsiasi e sia sp il suo semiperimetro:

  sp = (a + b + c)/2

La formula di Erone stabilisce che l'area del triangolo è pari alla radice quadrata del semiperimetro per la differenza tra il semiperimetro e il primo lato, moltiplicato per la differenza tra il semiperimetro e il secondo lato, moltiplicato per la differenza tra il semiperimetro e il terzo lato.

  Area = sqrt(sp*(sp - a)*(sp - b)*(sp - c))

La funzione è la seguente:

(define (erone a b c)
  (let (sp (div (add a b c) 2))
    (sqrt (mul sp (sub sp a) (sub sp b) (sub sp c)))))

(erone 15 20 25)
;-> 150

Nota: l'altezza di un triangolo conoscendo i lati a,b,c vale:

                  (a^2 + c^2 - b^2)^2
  h = sqrt(a^2 - ---------------------)
                        4*c^2


---------------------------------------------------------
Tre funzioni per calcolare la potenza di un numero intero
---------------------------------------------------------

Funzione 1:

(define (** num power)
    (let (out 1L)
        (dotimes (i power)
            (setq out (* out num)))))

Funzione 2:

(define (power b e)
  (local (tmp out)
    (setq out 1L)
    (setq tmp b)
    (while (> e 0)
      (if (= (% e 2) 1)
          (setq out (* out tmp))
      )
      (setq tmp (* tmp tmp))
      (setq e (/ e 2))
    )
    out))

Funzione 3:

(define (pow-i num power)
  (local (pot out)
    (if (zero? power)
        (setq out 1L)
        (begin
          (setq pot (pow-i num (/ power 2)))
          (if (odd? power)
              (setq out (* num pot pot))
              (setq out (* pot pot)))
        )
    )
    out))

(= (power 12345L 1234L) (pow-i 12345L 1234L))
;-> true

(= (** 12345L 1234L) (pow-i 12345L 1234L))
;-> true

Vediamo i tempi di esecuzione:

Valori grandi:
(time (** 12345L 123L) 100000)
;-> 2035.584
(time (power 12345L 123L) 100000)
;-> 930.511
(time (pow-i 12345L 123L) 100000)
;-> 732.511

Valori piccoli:
(time (** 123L 12L) 100000)
;-> 162.583
(time (power 123L 12L) 100000)
;-> 326.134
(time (pow-i 123L 12L) 100000)
;-> 304.169

Il risultati sono contrastanti: la funzione 1 è la più veloce per valori piccoli, mentre la funzione 3 è la più veloce per valori grandi.


----------------
Numeri Armstrong
----------------

I numeri Armstrong (PlusPerfect o narcisistici) sono numeri con m cifre che sono uguali alla somma di ogni cifra elevata a m.
Sequenza OEIS A005188:
  1, 2, 3, 4, 5, 6, 7, 8, 9, 153, 370, 371, 407, 1634, 8208, 9474,
  54748, 92727, 93084, 548834, 1741725, 4210818, 9800817, 9926315,
  24678050, 24678051, 88593477, 146511208, 472335975, 534494836,
  912985153, 4679307774, 32164049650, 32164049651

Funzione 1 che calcola la potenza di un numero intero:

(define (pow-i num power)
  (local (pot out)
    (if (zero? power)
        (setq out 1L)
        (begin
          (setq pot (pow-i num (/ power 2)))
          (if (odd? power)
              (setq out (* num pot pot))
              (setq out (* pot pot)))
        )
    )
    out))

Funzione 2 che calcola la potenza di un numero intero:

(define (** num power)
    (let (out 1L)
        (dotimes (i power)
            (setq out (* out num)))))

Funzione che verifica se un numero è Armstrong:

(define (armstrong? num)
  (local (p digit sum tmp)
    (setq p (length num))
    (setq tmp num)
    (setq sum 0)
    (while (!= 0 tmp)
      (setq digit (% tmp 10))
      ; time 1: pow-i
      (setq sum (+ sum (pow-i digit p)))
      ; time 2: **
      ;(setq sum (+ sum (** digit p)))
      (setq tmp (/ tmp 10))
    )
    (= sum num)))

(armstrong? 4)
;-> true

Funzione che calcola i numeri Armstrong fino ad un determinato limite:

(define (armstrong-to limit)
  (local (out)
    (for (i 1 limit)
      (if (armstrong? i)
        (push i out -1)))
    out))

; time 1: pow-i
(time (println (armstrong-to 1e6)))
;-> (1 2 3 4 5 6 7 8 9 153 370 371 407 1634
;->  8208 9474 54748 92727 93084 548834)
;-> 8710.681
(time (println (armstrong-to 1e7)))
;-> (1 2 3 4 5 6 7 8 9 153 370 371 407 1634 8208 9474 54748
;->  92727 93084 548834 1741725 4210818 9800817 9926315)
;-> 101966.673

; time 2: **
(time (println (armstrong-to 1e6)))
;-> (1 2 3 4 5 6 7 8 9 153 370 371 407 1634
;->  8208 9474 54748 92727 93084 548834)
;-> 8282.203
(time (println (armstrong-to 1e7)))
;-> (1 2 3 4 5 6 7 8 9 153 370 371 407 1634 8208 9474 54748
;->  92727 93084 548834 1741725 4210818 9800817 9926315)
;-> 108572.944

I numeri Armstrong vengono utilizzati nella sicurezza sulla trasmissione di dati. Il primo passo consiste nell'assegnare un colore univoco a ciascun destinatario (receiver). Ogni colore è rappresentato con un insieme di tre valori. Ad esempio il colore rosso viola è rappresentato in formato RGB come (238, 58,140). Poi si assegna una serie di tre valori chiave a ciascun destinatario. Il mittente (sender) è a conoscenza del destinatario richiesto a cui devono essere inviati i dati. Quindi il colore univoco del destinatario viene utilizzato come password. Il set di tre valori chiave viene aggiunto ai valori del colore originale e crittografato dal lato del mittente. Questo colore crittografato funge effettivamente da password. I dati effettivi vengono crittografati utilizzando i numeri Armstrong.


---------------------------------------------------------------------
Evoluzione dell'algoritmo per la moltiplicazione di due numeri interi
---------------------------------------------------------------------

L'algoritmo standard per la moltiplicazione di interi è quello scolastico con riporto ed ha una complessità temporale O(N^2). Solo nel 1960 è stato sviluppato un nuovo algoritmo (karatsuba) con tempo O(N^1.58) e nel 1970 è stato dimostrato che l'agoritmo più veloce possibile ha complessità O(N*logN).

Ci sono voluti più di 60 anni per passare da O(N^2) a O(N*logN), ma è stato un viaggio interessante. Questo è un momento importante perché si tratta di uno dei pochi argomenti fondamentali che l'uomo sia riuscito a capire ed ottimizzare al limite.

Nel 1971 è stato sviluppato l'algoritmo di Schonhage Strassen che funziona con tempo O(N*logN*loglogN) e ha mantenuto il record per 36 anni prima di essere battuto dall'algoritmo di Furer nel 2007. Da allora, i progressi sono stati costanti e un algoritmo con tempo O(N*logN), scoperto nel marzo 2019, è la possibile fine di questa ricerca umana.

La tabella seguente gli algoritmi che hanno definito questa era:

Algoritmo                  Complessità               Anno    Note
-------------------------- ------------------------------------------------
School Multiplication      O(N^2)                    100 AC  -
Russian Peasant Method     O(N^2 * logN)             1000    -
Karatsuba                  O(N^1.58)                 1960    -
Toom Cook multiplication   O(N^1.46)                 1963    -
Schonhage Strassen         O(N * logN * loglogN)     1971    FFT
Furer                      O(N * logN * 2^O(log*N))  2007    -
DKSS                       O(N * logN * 2^O(log*N))  2008    Modulare
Harvey, Hoeven, Lecerf     O(N * logN * 2^3 log*N)   2015    Primi Mersenne
Covanov and Thomé          O(N * logN * 2^2 log*N)   2015    Primi Fermat
Harvey and van der Hoeven  O(N * logN)               2019    Fine (!?)

Nota: la complessità temporale considera la moltiplicazione di due numeri di N cifre.

Approcci di base O(N^2)
-----------------------
La moltiplicazione intera inizia con l'approccio di base insegnato a scuola che ha una complessità temporale di O(N^2). Sebbene ci sia voluto un tempo significativo per migliorare la complessità del tempo, questo non ci ha impedito di apportare miglioramenti su questo.

Un miglioramento è stato ridurre la moltiplicazione a N addizioni poiché nei sistemi informatici l'addizione è molto più veloce. Questo potrebbe non essere vero nei sistemi moderni poiché entrano in scena diverse ottimizzazioni.

Un altro approccio era effettuare la moltiplicazione in potenze di due (algoritmo del contadino russo). Sebbene questo aumenti la complessità temporale, le prestazioni reali sono buone poiché la moltiplicazione per 2 viene eseguita utilizzando un'operazione di spostamento a sinistra che richiede un tempo costante O(1).

Ci sono molte altre varianti, ma il vero progresso è stato fatto a partire dagli anni '60 quando sono stati scoperti diversi ottimi algoritmi.

Anni '60: da O(N^2) a O(N^1.58) a O(N^1.46)
-------------------------------------------
Tutto è iniziato con l'algoritmo Karatsuba che è stato il primo algoritmo a dimostrare che la moltiplicazione intera può essere eseguita più velocemente di O(N^2). Era un momento in cui gli scienziati erano bloccati in questo problema.

L'algoritmo è stato scoperto nel 1960 da Anatoly Karatsuba. È basato su un approccio divide et impera e ha una complessità temporale di O(N^1.58).

I progressi successivi furono fatti rapidamente e nel 1963 Toom Cook formulò un algoritmo cha ha una complessità temporale di O(N^1.46).

Le notizie dei progressi si diffusero velocemente anche in quei giorni senza internet e questo campo era di nuovo in attiva ricerca. Ci sono voluti circa altri 7 anni per scoprire un nuovo algoritmo che avrà un enorme impatto per decenni.

Anni '70s: l'inizio di una nuova sfida
--------------------------------------
L'algoritmo di Schonhage Strassen è uno dei più grandi progressi compiuti nella moltiplicazione dei numeri interi. È stato formulato nel 1971 ed è rimasto il più importante algoritmo di moltiplicazione di numeri interi per oltre 36 anni.

Ha una complessità temporale di O(N*logN*loglogN) e utilizza l'idea della Fast Fourier Transform.

Sebbene questo fosse un passo importante, ci sono voluti diversi anni per migliorarlo. Questo ha dato la sensazione che il dominio stesse diventando troppo complicato da affrontare ma, come sappiamo, alla fine ce l'abbiamo fatta.

2007: la svolta
---------------
L'algoritmo di Furer è stato un importante passo avanti in quanto dal 1971 al 2007 non sono stati compiuti progressi fondamentali. Comunque ha dimostrato che sono possibili ulteriori progressi. Inoltre ha migliorato la complessità temporale a O(N*logN*2^O(logN)).

Ha migliorato la parte loglogN dell'algoritmo Schonhage Strassen che è vero per grandi numeri come 2^2^64.

Nonostante ciò, rimane di interesse teorico solo a causa di diverse sfide importanti per il suo utilizzo in applicazioni pratiche. Ciò ha aperto un nuovo interesse per il problema e negli anni successivi sono state proposte diverse ottimizzazioni, ma nessuna lo ha reso adatto all'uso pratico. Quindi, l'algoritmo di Schonhage Strassen ha continuato ad essere utilizzato in tutti gli usi pratici.

Ulteriori miglioramenti fino a O(N*logN)
-----------------------------------
Dal 2007 sono stati apportati diversi miglioramenti agli algoritmi di Furer.

L'algoritmo DKSS è stato un approccio notevole in quanto ha raggiunto la stessa complessità temporale dell'algoritmo di Furer. Si basa sull'aritmetica modulare ed è più semplice. È uscito nel 2008 e ha una complessità temporale di O(N*logN*2^O(logN)). Questo è più veloce dell'algoritmo Schonhage Strassen per i numeri maggiori di 10^10^4796.

Nel 2015, Harvey, Hoeven e Lecerf hanno inventato un algoritmo con una costante limitata migliore rispetto all'algoritmo di Furer. Si basava sui numeri primi di Mersenne e aveva una complessità temporale di O(N*logN*2^(3*logN)) dove la costante è 3 mentre nell'algoritmo di Furer non è limitata e può essere più grande come 8.

Presto, Covanov e Thomé nello stesso anno 2015, hanno inventato un altro algoritmo basato su Fermat Primes e hanno migliorato il fattore costante a 2. La complessità temporale è migliorata a O(N*logN*2^(2^logN)).

Nonostante questi miglioramenti, gli algoritmi non erano adatti all'uso pratico e venivano apportati miglioramenti minimi. Per una nota positiva, abbiamo diversi algoritmi con diverse idee di base.

I maggiori progressi sono stati compiuti nel marzo 2019 da Harvey e van der Hoeven. Hanno proposto un algoritmo con complessità temporale di O(N logN). Questo è significativo in quanto nel 1971 Volker Strassen dimostrò che la migliore complessità possibile per la moltiplicazione intera dovrebbe essere O(N*logN) e quindi siamo arrivati ​​alla fine. Comunque questo risultato è in corso di verifica.


--------------------
Indice di equilibrio
--------------------

Data una lista trovare, se esiste, un indice tale che la somma della sottolista a sinistra dell'indice è uguale alla somma della sottolista a  destra dell'indice: tale indice viene chiamato "Indice di equilibrio". In formula:

  A(0) + A(1) + … + A(i-1) = A(i+1) + A(i+2) + … + A(n-1), dove 0 < i < n-1

Per esempio:
lista = (3 4 1 5 2 6)
indice di equilibrio: 3

Infatti, lista(3) = 5, (3 + 4 + 1) = (2 + 6)

Metodo brute-force, confrontiamo le somme destre e sinistre per ogni indice:

(define (eq-idx1 lst)
(catch
  (local (lsum rsum)
    (dolist (el lst)
      (setq lsum (- (apply + (slice lst 0 (+ $idx 1))) el))
      (setq rsum (- (apply + (slice lst $idx)) el))
      ;(println lsum { } rsum)
      (if (= lsum rsum) (throw $idx))
    )
    nil)))

(eq-idx1 '(3 4 1 5 2 6))
;-> 3
(eq-idx1 '(5 7 4 5 8 8))
;-> 3
(eq-idx1 '(1 2 3 4 5 10))
;-> 4
(eq-idx1 '(1 2 5 4 5 6))
;-> nil

Questo algoritmo impiega O(n) tempo per attraversare ogni indice e O(n) tempo per calcolare la somma delle sottoliste per ogni indice, quindi la complessità temporale totale è O(n^2).
Poichè non utilizziamo spazio extra, la complessità spaziale è costante O(1).

Metodo con lista dei suffissi e dei prefissi:

Passo 1: attraversare la lista da sinistra a destra e calcolare e memorizzare la somma cumulativa in corrispondenza di ogni elemento in una lista. Questo lista è la somma dei prefissi.
Passo 2: l'ultimo elemento in questa lista di prefissi è la somma di tutti gli elementi della lista.
Passo 3: prendere una nuova lista e assegnare questa somma al suo primo elemento. Ad ogni elemento, sottrai il valore dell'elemento dal valore calcolato in precedenza e memorizzalo nella lista. Questa lista sè la somma dei suffissi.
Passo 4: confrontare le due liste e trovare, se esiste, l'indice in cui entrambe le liste hanno elementi identici e stampare questo indice.

Per esempio:
lista: 1 6 2 7
lista somma prefisso: 1 7 9 16
lista somma suffisso: 16 15 9 7
All'indice 2 entrambe le liste hanno lo stesso elemento (9), quindi 2 è l'indice di equilibrio.

(define (eq-idx2 lst)
(catch
  (local (len pref-sum suff-sum)
    (setq len (length lst))
    ; calcola lista dei prefissi
    (setq pref-sum (array len '(0)))
    (setf (pref-sum 0) (lst 0))
    (for (i 1 (- len 1))
      (setf (pref-sum i) (+ (pref-sum (- i 1)) (lst i)))
    )
    ; calcola lista dei suffissi
    (setq suff-sum (array len '(0)))
    (setf (suff-sum 0) (pref-sum (- len 1)))
    (for (i 1 (- len 1))
      (setf (suff-sum i) (- (suff-sum (- i 1)) (lst (- i 1))))
    )
    ;(println pref-sum { } suff-sum)
    (for (i 1 (- len 2))
      (if (= (pref-sum i) (suff-sum i))
          (throw i)
      )
    )
    nil)))

(eq-idx2 '(1 6 2 7))
;-> 2
(eq-idx2 '(3 4 1 5 2 6))
;-> 3
(eq-idx2 '(5 7 4 5 8 8))
;-> 3
(eq-idx2 '(1 2 3 4 5 10))
;-> 4
(eq-idx2 '(1 2 5 4 5 6))
;-> nil

Questo algoritmo impiega O(n) tempo per creare la lista somma dei prefissi, O(n) tempo per formare la lista delle somme dei suffissi e O(n) tempo per trovare l'indice con elementi identici nelle due liste. Quindi la complessità temporale totale vale O(n).
Poiché abbiamo creato altre due liste, ciascuno di dimensione n, la complessità spaziale vale O(n).
Potremmo migliorare quest'ultimo algoritmo evitando di calcolare la lista dei suffissi, infatti risulta:

  suff-sum(i) = pref-sum(N) - pref-sum(i)

Questo perchè:

  pref-sum(N) = a1 + a2 + ... + aN

  pref-sum(i) = a1 + a2 + ... + ai

Quindi, pref-sum(N) - pref-sum(i) = a(i+1) + ... + aN

Di conseguenza, suff-sum(i) = pref-sum(N) - pref-sum(i).

Per calcolare i tempi di esecuzione generiamo due liste con 100 e 1000 numeri casuali da 0 10 e troviamone due che hanno un indice di equilibrio:

(for (i 1 1000)
  (setq test (rand 10 100))
  (if (eq-idx2 test)
      (setq a test)))
(eq-idx1 a)
;-> 47
(eq-idx2 a)
;-> 47

(for (i 1 1000)
  (setq test (rand 10 1000))
  (if (eq-idx2 test)
      (setq b test)))
(eq-idx1 b)
;-> 486
(eq-idx2 b)
;-> 488

Adesso vediamo la differenza di velocità tra le due funzioni:

(time (eq-idx1 a) 10000)
;-> 1008.312
(time (eq-idx2 a) 10000)
;-> 398.961

(time (eq-idx1 b) 10000)
;-> 97280.153
(time (eq-idx2 b) 10000)
;-> 13656.492


------------------------------------------------
Numero soluzioni equazione lineare a k variabili
------------------------------------------------

Trovare il numero di soluzioni non negative di un'equazione lineare con k variabili a coefficienti interi positivi:

  a1*x1 + a2*x2 + ...  + an*xn = c

Per esempio, consideriamo l'equazione lineare in due variabili 3a1 + a2 = 9. Le soluzioni non negative (a1 a2) di questa equazione sono: (0 9), (1 6), (2 3) e (3 0). Quindi l'equazione ha 4 soluzioni non negative.

Esempio:
Input:  coeff = (1 3 5 7), c = 8
Output: 6 (numero totale di soluzioni)

L'input sopra rappresenta l'equazione a + 3b + 5c + 7d = 8 che ha le seguenti 6 soluzioni positive intere:

  ( a = 1, b = 0, c = 0, d = 1 )
  ( a = 0, b = 1, c = 1, d = 0 )
  ( a = 2, b = 2, c = 0, d = 0 )
  ( a = 3, b = 0, c = 1, d = 0 )
  ( a = 5, b = 1, c = 0, d = 0 )
  ( a = 8, b = 0, c = 0, d = 0 )

Esempio:
Input:  coeff = (1 2 3), c = 4
Output: 4 (numero totale di soluzioni)

L'input sopra rappresenta l'equazione x + 2y + 3z = 4 che ha le seguenti 4 soluzioni positive intere:

  ( x = 1, y = 0, z = 1 )
  ( x = 0, y = 2, z = 0 )
  ( x = 2, y = 1, z = 0 )
  ( x = 4, y = 0, z = 0 )

Il problema è simile a quello di trovare il numero totale di modi per ottenere un certo valore con un insieme di monete diverse. In questo caso i coefficienti dell'equazione possono essere considerati come i valori delle monete e il termine noto "c" dell'equazione rappresenta il valore da ottenere.
La definizione ricorsiva del problema è la seguente:

  count-sol(coeff, k, c) = count-sol(coeff, k, c - coeff(k)) + count-sol(coeff, k - 1, c)

Cioè, per ogni coefficiente di ogni variabile:
  - Includere il coefficiente corrente coeff(k) nella soluzione e ricorrere con il valore rimanente c - coeff(k) .
  - Escludere il coefficiente corrente coeff(k) dalla soluzione e ricorrere ai coefficienti rimanenti k-1 .
Infine, restituire i modi totali includendo o escludendo il coefficiente corrente.
I casi base della ricorsione sono:
1) quando viene trovata la soluzione (cioè, c diventa 0), oppure
2) la soluzione non esiste (quando non sono rimasti coefficienti, o c diventa negativo).

(define (count-sol coeff k c)
  (local (include exclude)
         ; se c = 0, allora abbiamo trovato una soluzione
  (cond ((= c 0) 1)
         ; se c diventa negativo o non ci sono più coefficienti
         ; allora restituisce 0
        ((or (< c 0) (< k 0)) 0)
        (true
          ; altrimenti
          ; Caso 1. Includere il coeff corrente "coeff[k]" nella soluzione e
          ;         ricorsione con il valore rimanente "c - coeff[k]"
          (setq include (count-sol coeff k (- c (coeff k))))
          ; Caso 2. Escludere il coeff corrente "coeff[k]" dalla soluzione e
          ;         ricorsione con il valore rimanente "k - 1"
          (setq exclude (count-sol coeff (- k 1) c))
          ; restituire i modi totali includendo o escludendo il coefficiente corrente
          (+ include exclude)))))

(define (solutions coeff k c)
    (count-sol coeff (- k 1) c))

(solutions '(1 2 3) 3 4)
;-> 4
(solutions '(1 3 5 7) 4 8)
;-> 6

Questo algoritmo ha complssità temporale esponenziale ed utilizza parecchio spazio nello stack per le chiamate ricorsive.

Possiamo scrivere una versione bottom-up utilizzando la tecnica di memoizzazione:

(define (conta-sol coeff k c)
  (let (dp (array (+ c 1) '(0)))
    (setf (dp 0) 1)
    (for (i 0 (- k 1))
      (for (j (coeff i) c)
        (setf (dp j) (+ (dp j) (dp (- j (coeff i)))))
      )
    )
    (dp c)))

(conta-sol '(1 2 3) 3 4)
;-> 4

(conta-sol '(1 3 5 7) 4 8)
;-> 6


--------------
Internet-point
--------------

Un internet-point possiede N computer. I clienti sono rappresentati da una stringa di caratteri. Ogni carattere è ripetuto due volte: la prima occorrenza rappresenta l'ingresso nel locale, la seconda occorrenza rappresenta l'uscita dal locale.
Le regole di utilizzo di un computer sono le seguenti:
1) quando arriva un cliente, se è libero un computer, allora lo occupa, altrimenti si mette in attesa.
2) quando si libera un computer, se esistono clienti in attesa, allora il primo della lista occupa un computer.
3) i clienti possono lasciare il locale anche senza aver utilizzato un computer.

Determinare il numero di clienti che hanno utilizzato un computer e il numero di quelli che non lo hanno utilizzato.

Esempio:
stringa: "ABCDDBAC"
computer: 2
sequenza clienti: A B C D D B A C
Cliente A -> entra e prende computer
Cliente B -> entra e prende computer
Cliente C -> entra e attende
Cliente D -> entra e attende
Cliente D -> esce dal locale
Cliente B -> lascia computer ==> C prende computer (era in attesa)
Cliente A -> lascia computer (attesa è vuota)
Cliente C -> lascia computer

Clienti computer: 3 (A B C)
Clienti no-computer: 1 (D)

Esempio:
stringa: "ABCDBACD"
computer: 2
sequenza clienti: A B C D B A C D
Cliente A -> entra e prende computer
Cliente B -> entra e prende computer
Cliente C -> entra e attende
Cliente D -> entra e attende
Cliente B -> lascia computer ==> C prende computer (era in attesa)
Cliente A -> lascia computer ==> D prende computer (era in attesa)
Cliente C -> lascia computer ==> (nessuno in attesa)
Cliente D -> lascia computer ==> (nessuno in attesa)

Clienti computer: 4 (A B C D)
Clienti no-computer: 0

La spiegazione del metodo di soluzione si trova nei commenti alla funzione.

(define (fila seq computer)
  (local (liberi serv noserv clienti attesa fatti)
  (setq liberi computer)
  (setq serv 0) ; numero clienti serviti
  (setq noserv 0) ; numero clienti non serviti
  (setq attesa '()) ; lista clienti in attesa
  (setq fatti '()) ; lista clienti fatti
  (setq clienti (explode seq)) ; sequenza temporale dei clienti
  ; per ogni elemento nella sequenza (azione del cliente)
  (dolist (cl clienti)
    ; cliente nella lista attesa?
    (setq a (find cl attesa))
    ; cliente nella lista fatti?
    (setq f (find cl fatti))
    ; controllo della tipologia del cliente...
    ; 1) Cliente nuovo, oppure
    ; 2) Cliente che esce dal locale (dalla lista di attesa), oppure
    ; 3) Cliente che esce dal locale (dalla lista di fatti)
    (cond ((and (nil? a) (nil? f)) ; Se è un cliente nuovo
           (if (> liberi 0) ; se ci sono computer liberi
            (begin
               (-- liberi) ; prende un computer
               (push cl fatti) ; cliente nella lista fatti
            )
            (begin ; altrimenti
               (push cl attesa -1) ; cliente in attesa
            )))
          ((not (nil? f)) ; Se il cliente esce dal locale servito
           (print cl { })
           (++ serv)      ; aumenta clienti serviti
           (++ liberi)    ; libera un computer
           (pop fatti f)  ; esce dalla lista di fatti
           (if (> (length attesa) 0) ; se ci sono clienti in attesa
            (begin
               ; prendo il primo cliente in attesa
               ; e lo inserisco nella lista fatti
               (push (pop attesa) fatti)
               (-- liberi) ; occupa un computer
            )))
          ((not (nil? a)) ; Se il cliente esce dal locale non servito
           (++ noserv)     ; aumenta clienti non serviti
           (pop attesa a)) ; esce dalla lista di attesa
    )
  )
  (list serv noserv)))

Facciamo alcune prove:

(fila "ABCDDBAC" 2)
;-> B A C (3 1)
(fila "ABCDBACD" 2)
;-> B A C D (4 0)
(fila "ABCDDCEFFEBGAG" 2)
;-> B A G (3 4)
(fila "ABCDDCEFFBEGAG" 2)
;-> B E A G (4 3)
(fila "ABCDDCEFBEGAFG" 2)
;-> B E A F G (5 2)
(fila "ABCBDAEDFCFGEG" 2)
;-> B A D C F E G (7 0)

=============================================================================

===============

 NOTE LIBERE 5

===============

-------------------
Spostamento di zeri
-------------------

Data una lista di numeri interi, scrivere una funzione che sposta gli tutti gli zeri all'inizio o alla fine della lista. L'ordine degli elementi diversi da 0 deve rimanere lo stesso. Per esempio:

Input:
lista = (1 0 5 -4 0 3 0 4 -2 -1)

Output:
zeri all'inizio = (0 0 0 1 5 -4 3 4 -2 -1)
zeri alla fine  = (1 5 -4 3 4 -2 -1 0 0 0)

Un metodo per risolvere il problema è il seguente (zeri alla fine):
1) Per ogni elemento:
  se il numero corrente è diverso da zero,
  allora mettere il numero nella posizione disponibile nella lista.
2) Riempire tutti gli indici rimanenti con 0.

La seguente funzione utilizza questo metodo:

(define (move0 lst)
  ; "idx" memorizza l'indice della posizione disponibile
  (let ((idx 0) (len (length lst)))
    (for (i 0 (- len 1))
      ; se il numero corrente è diverso da zero,
      ; allora mette il numero nella posizione libera
      (if (!= (lst i) 0)
        (begin
          (setf (lst idx) (lst i))
          ; aggiorna posizione libera
          (++ idx)
        )
      )
    )
    ; sposta gli zeri (0) in fondo alla lista (gli indici rimanenti)
    (for (i idx (- len 1))
      (setf (lst i) 0)
    )
    lst))

(setq a '(1 0 5 -4 0 3 0 4 -2 -1))
(move0 a)
;-> (1 5 -4 3 4 -2 -1 0 0 0)

Per scrivere la funzione che mette gli zeri all'inizio è sufficiente cominciare il ciclo "for" dalla fine della lista e modificare l'inserimento di zeri al termine del ciclo.

La seguente funzione utilizza "dolist" invece del ciclo "for":

(define (move-0 lst)
  ; "idx" memorizza l'indice della posizione disponibile
  (let ((idx 0) (len (length lst)))
    (dolist (el lst)
      ; se il numero corrente è diverso da zero,
      ; allora mette il numero nella posizione libera
      (if (!= el 0)
        (begin
          (setf (lst idx) el)
          ; aggiorna posizione libera
          (++ idx)
        )
      )
    )
    ; sposta gli zeri (0) in fondo alla lista (gli indici rimanenti)
    (for (i idx (- len 1))
      (setf (lst i) 0)
    )
    lst))

(move-0 a)
;-> (1 5 -4 3 4 -2 -1 0 0 0)

Adesso scriviamo una funzione che risolve lo stesso problema utilizzando le funzioni primitive "clean" e "filter":

(define (move-zero lst pos)
  (cond ((= pos 1) ; 1 ==> zeri alla fine
         (append (clean zero? lst) (filter zero? lst)))
        ((= pos 0) ; 0 ==> zeri all'inizio
         (append (filter zero? lst) (clean zero? lst)))
        (true ; default ==> zeri alla fine
         (append (clean zero? lst) (filter zero? lst)))))

(setq a '(1 0 5 -4 0 3 0 4 -2 -1))
; zeri all'inizio (pos = 0)
(move-zero a 0)
;-> (0 0 0 1 5 -4 3 4 -2 -1)
; zeri alla fine (pos = 1)
(move-zero a 1)
;-> (1 5 -4 3 4 -2 -1 0 0 0)
; zeri alla fine (default)
(move-zero a)
;-> (1 5 -4 3 4 -2 -1 0 0 0)

Vediamo i tempi di esecuzione delle tre funzioni:

(setq nums (rand 10 1000))
(time (move0 nums) 1000)
;-> 1552.321
(time (move-0 nums) 1000)
;-> 604.397
(time (move-zero nums) 1000)
;-> 103.849

(silent (setq nums (rand 10 10000)))
(time (move0 nums) 1000)
;-> 219458.513 ; ciclo "for" molto lento con liste con numero elementi > 1000
(time (move-0 nums) 1000)
;-> 74461.084  ; ciclo "dolist" più veloce sulle liste
(time (move-zero nums) 1000)
;-> 1042.734   ; le primitive newLISP vincono nettamente

Per velocizzare il calcolo le funzioni "move0" e "move-0" possono utilizzare anche dei vettori:

(silent (setq vec (array (length nums) nums)))
(time (move0 vec) 1000)
;-> 1368.295 ; ciclo "for" veloce con vettori
(time (move-0 vec) 1000)
;-> 1225.153 ; ciclo "dolist" veloce anche con vettori

Con l'uso dei vettori otteniamo quasi la stessa velocità della funzione "move-zero". Quindi, utilizzando i vettori i cicli "for" e "dolist" hanno velocità simili, mentre con le liste il ciclo "dolist" è molto più veloce del ciclo "for".

Un altro metodo per risolvere il problema è quello di utilizzare la logica del quicksort. L'idea è di usare 0 come elemento pivot e poi fare un ciclo per leggere tutti gli elementi e scambiare ogni elemento non pivot con la prima occorrenza del pivot.

La seguente funzione implementa questo metodo:

(define (zeri lst)
  (let (idx 0)
    ; se l'elemento è diverso da zero,
    ; allora l'elemento viene posizionato prima del pivot
    ; e "idx" viene incrementato
    (for (i 0 (- (length lst) 1))
      (if (!= (lst i) 0) ; 0 è il pivot
        (begin
          (swap (lst i) (lst idx))
          (++ idx)
        )
      )
    )
    lst))

(setq a '(1 0 5 -4 0 3 0 4 -2 -1))
(zeri a)
;-> (1 5 -4 3 4 -2 -1 0 0 0)

Vediamo la velocità di questa ultima funzione utilizzando un vettore:

(time (zeri vec) 1000)
;-> 1280.851


-----------------------
Quadratura approssimata
-----------------------

La funzione f(x) = x * ceil(x) viene chiamata "quadratura approssimata" ed è studiata nell'articolo "Approximate Squaring" di Lagarias e Sloane.
Consideriamo la frazione x = n/d quando n > d > 1. Prendiamo 8/7 come esempio e cominciamo a calcolare la funzione:

1) f(8/7) = 8/7 * (ceil 8/7) = 8/7 * 2 = 16/7, adesso applichiamo di nuovo la funzione:

2) f(16/7) = 16/7 * (ceil 16/7) = 16/7 * 3 = 48/7, adesso applichiamo di nuovo la funzione:

3) f(48/7) = 48/7 * (ceil 48/7) = 48/7 * 7 = 48 , adesso abbiamo raggiunto un numero intero e il ciclo è finito.

Il numero di passaggi dipende dalla frazioni iniziale e il suo comportamento è abbastanza caotico. Per esempio, con 6/5 si arriva in 18 passi ad un numero di 57735 cifre prima di raggiungere un numero intero, con 200/199 si arriva ad un numero di 10^435 cifre. È congetturato, ma non dimostrato, che iterando la quadratura approssimata si ottenga sempre un numero intero.
La seguente tabella mostra alcune frazioni di esempio con i relativi risultati:

  Frazione  Passi  Numero
  --------  -----  ------
  3/2       1      3
  5/2       2      60
  7/2       1      14
  9/2       3      268065
  11/2      1      33
  13/2      2      2093
  15/2      1      60
  17/2      4      1204154941925628
  19/2      1      95

Scrivere un programma che calcola il numero di passaggi per raggiungere un numero intero partendo da una frazione x = n/d con n > d > 1.

La funzione che calcola la squadratura approssimata è la seguente:

(define (approx n d)
  (div (* n (ceil (div n d))) d))

Purtroppo le funzioni "div" e "ceil" non possono essere utilizzate con i big-integer, allora simuliamo la funzione "ceil" nel modo seguente:
  se (% n d) = 0, allora (ceil (div n d)) = (/ n d)
              altrimenti (ceil (div n d)) = (+ (/ n d) 1)

Scriviamo la funzione:

(define (itera n d)
  (let (passi 0L)
    ; fintanto che n/d non è un numero intero...
    (do-until (zero? (% n d))
      (++ passi)
      ; calcola il nuovo numeratore
      (if (zero? (% n d))
        ;(setq n (* n (int (ceil (div n d)))))
        (setq n (* n (/ n d)))
        (setq n (* n (+ 1L (/ n d))))
      ))
    (list passi (/ n d))))

(itera 8L 7L)
;-> (3L 48L)
(itera 3 2)
;-> (1L 3)
(itera 9 2)
;-> (3L 268065)
(itera 17L 2L)
;-> (4L 1204154941925628L)
(itera 10L 6L)
;-> (6L 1484710602474311520L)

Vediamo il numero da 57735 cifre:

(length (last (itera 6L 5L)))
;-> 57735

La seguente espressione "crasha" newLISP...perchè  un numero di 10^435 cifre dove lo mette?

(length (last (itera 200L 199L)))
;->  puff


-----------------------------------------
Introduzione alla programmazione dinamica
-----------------------------------------

"Dynamic Programming is not about filling in tables, but writing smart recursions." – Jeff Erickson.

La programmazione dinamica è un metodo per risolvere un problema complesso scomponendolo in un insieme di sottoproblemi più semplici, e poi risolvendo ciascuno di questi sottoproblemi una sola volta e memorizzando le loro soluzioni in una utilizzando una struttura di dati (lista, vettore, hash, ecc.). Ogni soluzione del sottoproblema è indicizzata in qualche modo, in genere in base ai valori dei parametri di input, per facilitarne la ricerca. Quindi, la prossima volta che si verifica lo stesso sottoproblema, invece di ricalcolare la sua soluzione, si utilizza la soluzione calcolata in precedenza, risparmiando così tempo di calcolo. Questa tecnica di memorizzazione delle soluzioni ai sottoproblemi invece di ricalcolarli è chiamata memoizzazione.

Ecco una brillante metafora per spiegare ad un principiante il concetto alla base della programmazione dinamica:

https://www.quora.com/How-should-I-explain-dynamic-programming-to-a-4-year-old/answer/Jonathan-Paulson

  *writes down "1+1+1+1+1+1+1+1 =" on a sheet of paper*
  "What's that equal to?"
  *counting* "Eight!"
  *writes down another "1+" on the left*
  "What about that?"
  *quickly* "Nine!"
  "How'd you know it was nine so fast?"
  "You just added one more."
  "So you didn't need to recount because you remembered there were eight! Dynamic Programming is just a fancy way to say 'remembering stuff to save time later'"

Ci sono due attributi chiave che un problema deve avere affinché la programmazione dinamica sia applicabile: una sottostruttura ottimale e sovrapposizione dei sottoproblemi.

1. Sottostruttura ottimale
La programmazione dinamica semplifica un problema complicato suddividendolo in sottoproblemi più semplici in modo ricorsivo. Un problema che può essere risolto in modo ottimale suddividendolo in sottoproblemi e quindi trovando ricorsivamente le soluzioni ottimali dei sottoproblemi si dice che abbia una sottostruttura ottimale. In altre parole, la soluzione di un dato problema di ottimizzazione può essere ottenuta dalla combinazione delle soluzioni ottime dei suoi sottoproblemi (le soluzioni dei sottoproblemi sono indipendenti tra di loro).

Ad esempio, il cammino minimo p da un vertice u a un vertice v in un dato grafo mostra una sottostruttura ottimale: prendiamo qualsiasi vertice intermedio w su questo cammino minimo p. Se p è veramente il cammino minimo, allora può essere suddiviso in sottopercorsi p1 da u a w e p2 da w a v tali che questi, a loro volta, siano effettivamente i cammini più brevi tra i vertici corrispondenti.

2. Sovrapposizione dei sottoproblemi
Si dice che un problema ha sottoproblemi sovrapposti se il problema può essere suddiviso in sottoproblemi e ogni sottoproblema viene ripetuto più volte, o un algoritmo ricorsivo per il problema risolve ripetutamente lo stesso sottoproblema invece di generare sempre nuovi sottoproblemi.

Ad esempio, il problema del calcolo della sequenza di Fibonacci mostra sottoproblemi sovrapposti. Il problema del calcolo dell'n-esimo numero di Fibonacci F(n) può essere scomposto nei sottoproblemi del calcolo di F(n-1) e F(n-2) e quindi sommando i due. Il sottoproblema del calcolo di F(n-1) può essere esso stesso scomposto in un sottoproblema che coinvolge il calcolo di F(n-2). Pertanto, il calcolo di F(n-2) viene riutilizzato e la sequenza di Fibonacci mostra quindi sottoproblemi sovrapposti. La programmazione dinamica tiene conto di questo fatto e risolve ogni sottoproblema una sola volta. Ciò può essere ottenuto in uno dei due modi seguenti:

Approccio top-down (dall'alto verso il basso) (Memoizzazione): questa è la ricaduta diretta della formulazione ricorsiva di qualsiasi problema. Se la soluzione a qualsiasi problema può essere formulata ricorsivamente utilizzando la soluzione ai suoi sottoproblemi e se i suoi sottoproblemi si sovrappongono, si può facilmente utilizzare la memoizzazione oppure memorizzare le soluzioni dei sottoproblemi in una tabella. Ogni volta che tentiamo di risolvere un nuovo sottoproblema, prima controlliamo la tabella per vedere se è già stato risolto. Se il sottoproblema è già risolto, usiamo direttamente la sua soluzione, altrimenti, risolviamo il sottoproblema e aggiungiamo la sua soluzione alla tabella.

Approccio bottom-up (dal basso verso l'alto) (Tabella): una volta che formuliamo la soluzione a un problema in modo ricorsivo in termini di sottoproblemi, possiamo provare a riformulare il problema in modo dal basso verso l'alto: proviamo a risolvere prima i sottoproblemi e usiamo le loro soluzioni per costruire verso l'alto e arrivare alle soluzioni dei sottoproblemi più grandi. Questo viene solitamente fatto anche in forma tabellare generando in modo iterativo soluzioni a sottoproblemi sempre più grandi utilizzando le soluzioni dei sottoproblemi più piccoli. Ad esempio, se conosciamo già i valori di F(i-1) e F(i-2), possiamo calcolare direttamente il valore di F(i).
Quando un problema può essere risolto combinando soluzioni ottimali con sottoproblemi non sovrapposti, allora la strategia si chiama "Divide et impera". Questo è il motivo per cui il MergeSort e il QuickSort non sono classificati come problemi di programmazione dinamica.

Consideriamo un'implementazione ricorsiva di una funzione che trova l'ennesimo numero della sequenza di Fibonacci:

(define (fib num)
  (if (<= num 1)
      num
      (+ (fib (- num 1)) (fib (- num 2)))))

(fib 5)
;-> 5

Quando chiamiamo (fib 5) (per esempio) produciamo un albero di chiamate che chiama la funzione sullo stesso valore molte volte:

                                   (fib 5)
                                   .     .
                                .           .
                             .                 .
                          .                       .
                       .                             .
                    (fib 4)                        (fib 3)
                  .        .                         .  .
                .            .                      .    .
              .                .                   .      .
          (fib 3)            (fib 2)            (fib 2) (fib 1)
            / \                / \                / \
           /   \              /   \              /   \
          /     \            /     \            /     \
      (fib 2) (fib 1)    (fib 1) (fib 0)    (fib 1) (fib 0)
        / \
       /   \
      /     \
  (fib 1) (fib 0)

In particolare, (fib 3) è stato calcolato due volte e (fib 2) è stato calcolato tre volte. Con numeri più grandi vengono ricalcolati molti più sottoproblemi, portando questo algoritmo ad una complessità temporale esponenziale.

Ora supponiamo di avere una struttura per memorizzare i risultati intermedi di fib e modifichiamo la nostra funzione per usarlo e aggiornarlo. La funzione risultante viene eseguita in tempo O(n) anziché in tempo esponenziale (ma richiede uno spazio O(n)).

Di seguito è riportata l'implementazione basata su questo metodo:

; lista associativa per memorizzare i risultati parziali
(setq memo '())

(define (fib-memo num)
  (local (val)
    (cond ((<= num 1)
            num)
          ; se il numero di Fibonacci relativo a num non è stato calcolato
          ((nil? (lookup num memo))
            ; allora lo calcola...
            (setq val (+ (fib-memo (- num 1)) (fib-memo (- num 2))))
            ; e poi mette il risultato
            ; (num fib(num)) nella lista associativa memo
            (push (list num val) memo -1)))
    (lookup num memo)))

(fib-memo 5)
;-> 5

Da notare che avremmo potuto usare un'altra struttura dati per memorizzare i valori invece di una lista associativa (vettore, hash-map, ecc.).

Questa tecnica di memorizzazione dei valori già calcolati è chiamata memoizzazione e questo è l'approccio top-down poiché prima suddividiamo il problema in sottoproblemi e poi calcoliamo e memorizziamo i valori.

Nell'approccio bottom-up, calcoliamo prima i valori più piccoli di fib, quindi costruiamo da essi valori più grandi. Anche questo metodo utilizza un tempo O(n) poiché contiene un ciclo che si ripete n-1 volte, ma richiede solo uno spazio costante O(1) costante, in contrasto con l'approccio top-down, che richiede spazio O(n) per memorizzare tutti i risultati. In questo caso la tabella di memorizzazione è costituita solo da tre valori: il valore corrente di fib, il valore precedente e il valore successivo.

Di seguito è riportato il programma che utilizza questo metodo (tabella):

(define (fib-tab num)
  (local (new-fib prev-fib curr-fib)
    (cond ((<= num 1) num)
          (true
           (setq prev-fib 0)
           (setq curr-fib 1)
           (for (i 1 (- num 1))
              (setq new-fib (+ prev-fib curr-fib))
              (setq prev-fib curr-fib)
              (setq curr-fib new-fib))))
    curr-fib))

(fib-tab 5)
;-> 5

In entrambe le ultime due funzioni, la chiamata a (fib 5) calcola (fib 2) solo una volta e poi il valore viene usato per calcolare sia (fib 4) che (fib 3), invece di essere ricalcolato nuovamente ogni volta che deve essere valutato.


--------------------------------------------------------------------
Programmazione dinamica: il gioco delle pentole d'oro (pots of gold)
--------------------------------------------------------------------

Ci sono due giocatori, A e B, e delle pentole disposte in fila ciascuna contenente alcune monete d'oro. I giocatori possono vedere quante monete ci sono in ogni pentola. A turni alternati ogni giocatore può scegliere una pentola da una delle estremità della linea. Alla fine il vincitore è il giocatore che ha un numero maggiore di monete. Per esempio, la seguente lista rappresenta una linea di 8 pentole ognuna contenente un numero di monete (valore dell'elemento):

(setq pentole '(3 4 1 6 7 4 8 9))

L'obiettivo del nostro problema è "massimizzare" il numero di monete raccolte da A, supponendo che B giochi "in modo ottimale" e che A inizi il gioco.

Vediamo un paio di esempi:

Pentole              A    B
4, 6, 2, 3           3
4, 6, 2                   4
6, 2                 6
2                         2
                    --------
totale monete        9    6

Pentole              A    B
6, 1, 4, 9, 8, 5     6
1, 4, 9, 8, 5             5
1, 4, 9, 8           8
1, 4, 9                   9
1, 4                 4
1                         1
                    --------
totale monete       18   15

L'idea è quella di trovare una strategia ottimale che faccia vincere il giocatore A, sapendo che l'avversario sta giocando in modo ottimale. Il giocatore ha due scelte per coin[i..j], dove i e j indicano rispettivamente la parte anteriore e quella posteriore della linea di pentole.

1. Se il giocatore sceglie la pentola anteriore i, l'avversario può scegliere tra [i+1, j].
       Se l'avversario sceglie la pentola anteriore i+1, ricorsione per [i+2, j].
       Se l'avversario sceglie la pentola posteriore j, ricorsione per [i+1, j-1].

2. Se il giocatore sceglie la pentola posteriore j, l'avversario può scegliere tra [i, j-1].
       Se l'avversario sceglie la pentola anteriore i, ricorsione per [i+1, j-1].
       Se l'avversario sceglie la pentola posteriore j-1, ricorsione per [i, j-2].

Poiché l'avversario sta giocando in modo ottimale, cercherà di ridurre al minimo i punti del giocatore, cioè l'avversario farà una scelta che lascerà al giocatore il minimo di monete. Quindi, possiamo definire ricorsivamente il problema nel modo seguente:

                 | coin[i]                            (se i = j)
 optimal(i, j) = | max(coin[i], coin[j])              (se i + 1 = j)
                 | max(coin[i] + min(optimal(coin, i + 2, j),
                           optimal(coin, i + 1, j – 1)),
                           coin[j] + min(optimal(coin, i + 1, j – 1),
                           optimal(coin, i, j – 2)))

Quindi la funzione che implementa la strategia ottimale è la seguente:

(define (optimal pentole i j)
  ; caso base: una pentola rimasta, solo una scelta possibile
  (cond ((= i j)
        (pentole i))
        ; se rimangono solo due pentole,
        ; scegliere quella con il massimo numero di monete
        ((= (+ i 1) j)
          (max (pentole i) (pentole j)))
        (true
          (local (inizio fine)
          ; Se il giocatore sceglie la pentola anteriore i,
          ; l'avversario può scegliere tra [i+1, j].
          ; 1. Se l'avversario sceglie la pentola anteriore i+1,
          ;    ricorsione per [i+2, j].
          ; 2. Se l'avversario sceglie la pentola posteriore j,
          ;    ricorsione per [i+1, j-1].
          (setq inizio (+ (pentole i) (min (optimal pentole (+ i 2) j)
                                           (optimal pentole (+ i 1) (- j 1)))))
          ; Se il giocatore sceglie la pentola posteriore j,
          ; l'avversario può scegliere tra [i, j-1].
          ; 1. Se l'avversario sceglie la pentola anteriore i,
          ;    ricorsione per [i+1, j-1].
          ; 2. Se l'avversario sceglie la pentola posteriore j-1,
          ;  ricorsione per [i, j-2].
          (setq fine (+ (pentole j) (min (optimal pentole (+ i 1) (- j 1))
                                         (optimal pentole i (- j 2)))))
          (max inizio fine)))))

Funzione main:

(define (pots-gold pots)
  (local (i j)
    (setq i 0)
    (setq j (- (length pots) 1))
    (optimal pots i j)))

(pots-gold '(4 6 2 3))
;-> 9
(pots-gold '(6 1 4 9 8 5))
;-> 18
(setq pentole '(3 4 1 6 7 4 8 9))
(pots-gold pentole)
;-> 23

La complessità temporale della soluzione di cui sopra è esponenziale e occupa spazio nello stack di chiamate.

Il problema ha una sottostruttura ottimale, quindi può essere suddiviso in sottoproblemi più piccoli, che possono essere ulteriormente suddivisi in sottoproblemi ancora più piccoli e così via. Il problema mostra anche sottoproblemi sovrapposti, quindi finiremo per risolvere lo stesso sottoproblema più e più volte. Abbiamo visto che i problemi con sottostruttura ottimale e sottoproblemi sovrapposti possono essere risolti mediante la programmazione dinamica, in cui le soluzioni dei sottoproblemi vengono memorizzate piuttosto che calcolate di nuovo.

Vediamo la versione top-down:

(define (optimal-td pentole i j)
  (local (inizio fine)
  ; caso base: una pentola rimasta, solo una scelta possibile
  (cond ((= i j)
         (pentole i))
        ; se rimangono solo due pentole,
        ; scegliere quella con il massimo numero di monete
        ((= (+ i 1) j)
         (max (pentole i) (pentole j)))
        ; valore non calcolato?
        ((zero? (memo i j))
         (setq inizio (+ (pentole i) (min (optimal-td pentole (+ i 2) j)
                                          (optimal-td pentole (+ i 1) (- j 1)))))
         (setq fine (+ (pentole j) (min (optimal-td pentole (+ i 1) (- j 1))
                                        (optimal-td pentole i (- j 2)))))
         (setf (memo i j) (max inizio fine)))
         (true
          (memo i j)))))

(define (pots-gold-td pots)
  (local (memo i j)
    (setq memo (array (length pots) (length pots) '(0)))
    (setq i 0)
    (setq j (- (length pots) 1))
    (optimal-td pots i j)))

(pots-gold-td '(4 6 2 3))
;-> 9
(pots-gold-td '(6 1 4 9 8 5))
;-> 18
(setq pentole '(3 4 1 6 7 4 8 9))
(pots-gold-td pentole)
;-> 23

La complessità temporale di questa soluzione è O(n^2) e richiede O(n^2) spazio extra, dove n è il numero totale di pentole.

Vediamo la versione bottom-up:

(define (calc T i j)
  (if (<= i j)
      (T i j)
      0))

(define (optimal-bu pentole)
  (local (len dp j inizio fine)
    (setq len (length pentole))
    (cond ((= len 1) (pentole 0))
          ((= len 2) (max (pentole 0) (pentole 1)))
          (true
           ; matrice 2D dinamica per memorizzare
           ; le soluzioni dei sottoproblemi
           (setq dp (array len len '(0)))
           (for (iter 0 (- len 1))
              (setq i 0)
              (for (j iter (- len 1))
                (setq inizio (+ (pentole i) (min (calc dp (+ i 2) j)
                                                 (calc dp (+ i 1) (- j 1)))))
                (setq fine (+ (pentole j) (min (calc dp (+ i 1) (- j 1))
                                              (calc dp i (- j 2)))))
                (setf (dp i j) (max inizio fine))
                (++ i)
              )
           )
           ;(println dp)
           (dp 0 (- len 1))))))

(define (pots-gold-bu pots)
    (optimal-bu pots))

(pots-gold-bu '(4 6 2 3))
;-> 9
(pots-gold-bu '(6 1 4 9 8 5))
;-> 18
(setq pentole '(3 4 1 6 7 4 8 9))
(pots-gold-bu pentole)
;-> 23

La complessità temporale di questa soluzione è O(n^2) e richiede O(n) spazio extra, dove n è il numero totale di pentole.

Nota: questo algoritmo non assicura che il giocatore A vinca sempre. La vittoria di A dipende dalla casualità della distribuzione delle pentole, questo algoritmo massimizza il valore che A può ottenere, ma non è detto che il valore di B sia inferiore. Per convincersi è sufficiente considerare la seguente distribuzione di pentole: (1 3 1). Qualunque scelta faccia A, il massimo che può ottenere è 2, mentre B può ottenere 3:

(pots-gold-bu '(1 3 1))
;-> 2

In altre parole, questo algoritmo trova il comportamento ottimale per il giocatore A, ma non è in grado di definire una strategia vincente.

Nota: per definire una strategia vincente (se la distribuzione iniziale lo consente) occorre usare un algoritmo che considera l'intero albero delle possibili mosse (infatti è necessario ricorrere più in profondità per ottenere la soluzione ottimale anziché limitarsi a raggiungere il massimo alla mossa successiva).

Nota: per rendere più equo il gioco il numero di pentole dovrebbe essere pari, altrimenti il primo giocatore A sceglierebbe una pentola in più del giocatore B.

Comunque se il numero di pentole è dispari, allora il giocatore B è in grado di selezionare una determinata pentola.
Per esempio, nella distribuzione (1 2 6 2 101 6 8) il giocatore B sarà sempre in grado di scegliere la pentola con 101 monete (e vincere il gioco):
(pots-gold-bu '(1 2 6 2 101 6 8))
;-> 18

Invece se il numero di pentole è pari, allora il giocatore A è in grado di selezionare una determinata pentola.
Per esempio, nella distribuzione (1 2 6 2 101 6) il giocatore A sarà sempre in grado di scegliere la pentola con 101 monete (e vincere il gioco):
(pots-gold-bu '(1 2 6 2 101 6))
;-> 108

Per maggiori informazioni consultare l'articolo "An Optimal Algorithm for Calculating the Profit in the Coins in a Row Game" di Tomasz Idziaszek.

Quante partite diverse possono essere giocate con una fila di n pentole?

Una partita può essere considerata una sequenza di catture a Sinistra o a Destra della linea, cioè una partita con quattro pentole può essere rappresentata dalla lista (s s d d): A prende a Sinistra, B prende a Sinistra, A prende a destra e, infine, B prende a destra.
Comunque la lista (s s d d) è equivalente alla lista (s s d s), perchè l'ultima pentola si trova indifferentemente a Sinistra e a Destra.
Quindi il numero di partite è dato da tutte le permutazioni con ripetizione di s e d di lunghezza (n - 1):

(define (perm-rep k lst)
  (if (zero? k) '(())
      (flat (map (lambda (p) (map (lambda (e) (cons e p)) lst))
                         (perm-rep (- k 1) lst)) 1)))

Queste sono tutte le possibili partite con una linea di 2 pentole (s=sinistra, d=destra)
(perm-rep 1 '(s d))
;-> ((s) (d))

Queste sono tutte le possibili partite con una linea di 4 pentole (s=sinistra, d=destra)
(perm-rep 3 '(s d))
;-> ((s s s) (d s s) (s d s) (d d s) (s s d) (d s d) (s d d) (d d d))

Queste sono tutte le possibili partite con una linea di 5 pentole (s=sinistra, d=destra)
(perm-rep 4 '(s d))
;-> ((s s s s) (d s s s) (s d s s) (d d s s) (s s d s) (d s d s) (s d d s)
;->  (d d d s) (s s s d) (d s s d) (s d s d) (d d s d) (s s d d) (d s d d)
;->  (s d d d) (d d d d))

Quindi la funzione che calcola il numero di partite con n pentole è la seguente:

(define (game-pots num)
  (length (perm-rep (- num 1) '(s d))))

Oppure più semplicemente,

  numero partite = elementi^scelte

dove "elementi" è il numero di cose tra cui scegliere (s e d), e ne scegliamo "scelte" (num-1), la ripetizione è consentita e l'ordine è importante.

(define (game-pots num)
  (pow 2 (- num 1)))

(game-pots 10)
;-> 512

Scriviamo una funzione che data una linea di pentole calcola il risultato di tutte le partite possibili:

(define (all-game lst)
  (local (len perm tmp val aa bb tot-a tot-b tot-ab)
    ;tot-a:  vittoria giocatore A
    ;tot-b:  vittoria giocatore B
    ;tot-ab: pareggio
    (setq tot-a 0 tot-b 0 tot-ab 0)
    (setq len (length lst))
    (setq perm (perm-rep (- len 1) '(s d)))
    ; per ogni permutazione
    (dolist (p perm)
      (setq tmp lst)
      (setq aa 0 bb 0)
      ; per ogni elemento di una permutazione (partita)
      (dolist (el p)
        ; calcola il valore preso (a sinistra o a destra)
        (if (= el 's)
          (setq val (pop tmp 0))
          (setq val (pop tmp -1))
        )
        ; aumenta il punteggio del relativo giocatore
        (if (even? $idx)
            (setq aa (+ aa val))
            (setq bb (+ bb val))
        )
      )
      ; assegna l'ultimo valore della lista
      ; ad uno dei due giocatori
      (if (odd? len)
          (setq aa (+ aa (last tmp)))
          (setq bb (+ bb (last tmp)))
      )
      ;(println lst { } p { } aa { } bb)
      ; aumenta numero vittorie al vincitore corrente
      (cond ((= aa bb) (++ tot-ab))
            ((> aa bb) (++ tot-a))
            (true (++ tot-b)))
    )
    (list tot-a tot-b tot-ab)
  )
)

(all-game '(1 2 3 4 5 6 7))
;-> (45 12 7)

(all-game '(1 3 1))
;-> (2 2 0)

(all-game '(3 9 5 7 1 6 4 8 1 9 8 7))
;-> (914 995 139)


---------------------------------------------
Somma delle cifre in posizioni pari e dispari
---------------------------------------------

Scrivere una funzione che calcola tutti i numeri fino ad un dato limite che hanno la seguente proprietà:

la somma delle cifre in posizione pari è uguale alla somma delle cifre in posizione dispari

Prendiamo per esempio il numero 7523351:

somma delle cifre con indice pari: 5 + 3 + 5 = 13
somma delle cifre con indice dispari: 7 + 2 + 3 + 1 = 13

Quindi il numero 7523351 soddisfa la condizione.

Sequenza OEIS A135499: 11, 22, 33, 44, 55, 66, 77, 88, 99, 110, 121, 132,
 143, 154, 165, 176, 187, 198, 220, 231, 242, 253, 264, 275, 286, 297, 330,
 341, 352, 363, 374, 385, 396, 440, 451, 462, 473, 484, 495, 550, 561, 572,
 583, 594, 660, 671, 682, 693, 770, 781, 792, 880, 891, 990, ...

Funzione che verifica se un numero soddisfa la condizione:

(define (equal-sum? num)
  (if (zero? num) nil
      (local (odd-sum even-sum len)
        (setq odd-sum 0 even-sum 0)
        (setq len (length num))
        (while (!= num 0)
          (if (odd? len)
              (setq odd-sum (+ odd-sum (% num 10)))
              (setq even-sum (+ even-sum (% num 10)))
          )
          (setq num (/ num 10))
          (-- len)
        )
        (= odd-sum even-sum))))

(equal-sum? 0)
;-> nil
(equal-sum? 7523351)
;-> true
(equal-sum? 11165)
;-> true
(equal-sum? 11111)
;-> nil

Funzione che calcola tutti i numeri che verificano la condizione fino ad un dato limite:

(define (equal-sum limite)
  (let (out '())
    (for (i 1 limite)
      (if (equal-sum? i)
          (push i out -1)))
    out))

(equal-sum 1e3)
;-> (11 22 33 44 55 66 77 88 99 110 121 132 143 154 165 176 187 198 220 231
;->  242 253 264 275 286 297 330 341 352 363 374 385 396 440 451 462 473 484
;->  495 550 561 572 583 594 660 671 682 693 770 781 792 880 891 990)

(time (println (length (equal-sum 1e8))))
;-> 4816029
;-> 186272.126 ; 3 minuti e 6 secondi


-------------------------------------
Ordinare una lista con un'altra lista
-------------------------------------

Supponiamo di avere una lista di numeri e una seconda lista di indici o di posizioni. Per esempio,

lista di numeri:
(setq nums '(3 5 2 8 6 4))

lista di posizioni:
(setq pos '(3 2 1 4 5 0))

lista di indici:
(setq idx '(3 2 1 4 5 0))

Primo problema
Ordinare la lista di numeri in accordo con la lista di posizioni. In questo caso l'elemento i-esimo della lista "nums" deve essere posizionato/spostato all'indice ord(i), cioè nums(i) = nums(ord(i)).

(define (order1 lst pos)
  (local (len out)
    (setq len (length lst))
    (setq out (array len '(0)))
    (for (i 0 (- len 1))
      (setf (out (pos i)) (lst i))
    )
    out))

(order1 '(1 2 3 4 5) '(3 2 4 1 0))
;-> (5 4 2 1 3)

(order1 nums pos)
;-> (4 2 5 3 8 6)

Secondo problema
Ordinare la lista di numeri in accordo agli indici della lista di indici. In questo caso l'elemento i-esimo della lista "idx" rappresenta l'indice del numero che va posizionato/spostato alla posizione i-esima, cioè nums(idx(i)) = nums(i)

(define (order2 lst idx)
  (local (len out)
    (setq len (length lst))
    (setq out (array len '(0)))
    (for (i 0 (- len 1))
      (setf (out i) (lst (idx i)))
    )
    out))

(order2 '(1 2 3 4 5) '(3 2 4 1 0))
;-> (4 3 5 2 1)

(order2 nums idx)
;-> (8 2 5 6 4 3)

Nota: newLISP ha la funzione primitiva "select" che produce lo stesso risultato di "order2":

(select '(1 2 3 4 5) '(3 2 4 1 0))
;-> (4 3 5 2 1)
(select nums idx)
;-> (8 2 5 6 4 3)


--------------------
Test di Lucas-Lehmer
--------------------

Il test di Lucas-Lehmer è una verifica della primalità dei primi di Mersenne.
Per p numero primo, detto M(p) = 2^p - 1 il p-esimo numero di Mersenne, esso è primo se e solo se divide L(p-1), dove L(n) è l'n-esimo termine della successione definita ricorsivamente come:

  L(n+1) = L(n)^2 - 2, con L(1) = 4

Il test è stato sviluppato da Lucas nel 1870 e semplificato da Lehmer nel 1930.

La seguente funzione calcola i numeri primi di mersenne fino a un dato indice. Il secondo numero di Mersenne, M2, è primo, ma la funzione seguente calcola solo da M3 fino all'indice dato.

Nota: M2 è l'unico numero di Mersenne con indice pari (perchè l'indice è un numero primo).

(define (lucas-lehmer limite)
  (local (s n i expo)
    (println "M2 primo.")
    (setq n 1L)
    (for (expo 2 limite)
      (if (= expo 2)
          (setq s 0L)
          (setq s 4L))
      ; evita l'utilizzo della funzione pow
      (setq n (- (* (+ n 1) 2) 1))
      (for (i 1 (- expo 2))
        (setq s (% (- (* s s) 2) n)))
      (if (zero? s)
          (println "M" expo " primo.")))))

(lucas-lehmer 1000)
;-> M2 primo.
;-> M3 primo.
;-> M5 primo.
;-> M7 primo.
;-> M13 primo.
;-> M17 primo.
;-> M19 primo.
;-> M31 primo.
;-> M61 primo.
;-> M89 primo.
;-> M107 primo.
;-> M127 primo.
;-> M521 primo.
;-> M607 primo.

(time (lucas-lehmer 2300))
;-> M2 primo.
;-> M3 primo.
;-> M5 primo.
;-> M7 primo.
;-> M13 primo.
;-> M17 primo.
;-> M19 primo.
;-> M31 primo.
;-> M61 primo.
;-> M89 primo.
;-> M107 primo.
;-> M127 primo.
;-> M521 primo.
;-> M607 primo.
;-> M1279 primo.
;-> M2203 primo.
;-> M2281 primo.
;-> 89791.177 ; 90 secondi


-------------
0,1,2 con 0,1
-------------

Scrivere un algoritmo per generare 0, 1 e 2 con uguale probabilità utilizzando una funzione che produce 0 o 1 con il 50% di probabilità.

Supponiamo che la funzione specificata sia rnd(), che genera 0 o 1 con una probabilità del 50%. Quindi, se effettuiamo due chiamate diverse alla funzione rnd() e memorizziamo il risultato in due variabili, a e b, la loro somma a+b può essere uno qualsiasi di {0, 1, 2}. Qui, la probabilità di ottenere 0 e 2 è del 25% ciascuno e la probabilità di ottenere 1 è del 50%.
Ora il problema si riduce alla diminuzione della probabilità di ottenere 1 dal 50% al 25%. Possiamo farlo facilmente forzando la nostra funzione a non generare mai né (a = 1, b = 0) oppure (a = 0, b = 1), il che fa sì che la somma sia uguale a 1.

(define (rnd012)
  (local (a b)
    (setq a (rand 2))
    (setq b (rand 2))
    (if (and (= a 1) (= b 0))
        (rnd012)
        (+ a b))))

(rnd012)
;-> 0
(rnd012)
;-> 2

(define (test iter)
  (let (freq '(0 0 0))
    (for (i 1 iter)
      (++ (freq (rnd012))))
    (map (fn(x) (div x iter)) freq)))

Calcoliamo le frequenze:

(test 1e5)
;-> (0.33403 0.33284 0.33313)
(test 1e8)
;-> (0.33333341 0.33337291 0.33329368)


------------------------------------
Angolo delle lancette di un'orologio
------------------------------------

Data l'ora in formato ore:minuti, calcolare l'angolo minore tra la lancetta delle ore e quella dei minuti in un orologio analogico.
Per esempio:

Ora:  5:30
Angolo: 15°

Ora:  9:10
Angolo: 145°

Ora:  12:55
Angolo: 57°

La lancetta delle ore di un orologio analogico a 12 ore ruota di 360° in 12 ore e la lancetta dei minuti ruota di 360° in 60 minuti. Quindi, possiamo calcolare l'angolo in gradi della lancetta delle ore e della lancetta dei minuti separatamente e poi restituire la loro differenza utilizzando la seguente formula:

  Gradi(ore) = ore*(360/12) + (minuti*360)/(12*60)

  Gradi(minuti) = minuti*(360/60)

dove: 0 <= ore <= 23 e 0 <= minuti <= 59

L'angolo deve essere in gradi e misurato in senso orario dalla posizione delle ore 12 dell'orologio. Se l'angolo è maggiore di 180°, allora prendere la sua differenza con 360.

(define (angolo ore minuti)
  (local (angle-ore angle-minuti)
    (setq angle-ore (+ (/ (* ore 360) 12) (/ (* minuti 360) (* 12 60))))
    (setq angle-minuti (/ (* minuti 360) 60))
    (setq diff (abs (- angle-ore angle-minuti)))
    (if (> diff 180)
        (- 360 diff)
        diff)))

(angolo 5 30)
;-> 15
(angolo 9 10)
;-> 145
(angolo 12 55)
;-> 57
(angolo 1 30)
;-> 135


----------
Data e ora
----------

Scrivere una funzione che stampa la data e l'ora corrente aggiornate in tempo reale (al secondo).

newLISP ha la funzione "now" che restituisce una lista con le informazioni che ci servono (vedere il manuale per maggiori informazioni).

(define (clock)
  (local (year month day hour minute second
          days-name months-name erase actual val)
    (setq days-name '("0" "lunedì" "martedì" "mercoledì" "giovedì" "venerdì" "sabato" "domenica"))
    (setq months-name '("gennaio" "febbraio" "marzo" "aprile" "maggio" "giugno" "luglio"
                      "agosto" "settembre" "ottobre" "novembre" "dicembre"))
    (setq erase (dup " " 70))
    (setq actual (slice (now) 0 6))
    (setq val '())
    ; infinite loop (break with CTRL-C)
    (while true
             ; update only when change year or
             ; month or day or hour or minute or second
      (cond ((!= actual (slice val 0 6))
             (setq val (now))
             (setq actual (slice val 0 6))
             (setq year (string (val 0)))
             (setq month (months-name (val 1)))
             (setq day (string (val 2)))
             (setq hour (string (val 3)))
             (setq minute (string (val 4)))
             (setq second (string (val 5)))
             (setq day-name (days-name (val 8)))
             (setq printed (string " " day-name ", " day " " month " " year ", " hour ":" minute ":" second))
             ; erase output line (print blank chars)
             (print (dup " " (length printed)) " \r")
             ; print informations
             (print printed "\r"))
            (true
             ; update clock values
             (setq val (now)))))))

(clock)
;->  lunedì, 28 luglio 2021, 16:49:28

Nota: premere CTRL-C per terminare il programma.


------------------------
Corda intorno alla Terra
------------------------

Supponiamo di avere una corda che circonda una Terra perfettamente sferica che ha una circonferenza pari a 40000 km. La corda viene allungata di 1 metro e posta come una circonferenza a distanza costante dalla Terra.
Quanto è distante la nuova circonferenza dalla Terra?
Di quanto bisogna allungare la corda per fare una circonferenza che si trovi a 1 metro di distanza dalla Terra?

La prima circonferenza C vale:

  C = 2*π*R

La seconda circonferenza C + L vale:

  C + L = 2*π*R1

dove R e R1 sono i raggi delle due circonferenze e L è la lunghezza della corda aggiunta.

La differenza (R1 - R) vale:

            C + L       C        C + L - C       L
  R1 - R = ------- - ------- = ------------- = -----
             2*π       2*π          2*π         2*π

Quindi la distanza dalla Terra dipende solo da quanto viene allungata la corda e non dipende dal valore della circonferenza.

(define (diff L)
  (div L (mul 2 3.1415926535897931)))

(diff 1)
;-> 0.1591549430918954

La nuova circonferenza è distante 15.9 cm dalla Terra.

(diff 5)
;-> 0.7957747154594768

Per la seconda domanda, se R - R1 = 1, allora deve risultare L = 2*π.


-------
Eredità
-------

Autore: Richard A. Proctor (1886)

Uno sceicco lascia in eredità 35 cammelli ai suoi tre figli.
L'eredità dovrà essere divisa nel modo seguente:
1/2 al figlio maggiore, 1/3 al secondogenito e 1/9 al terzo figlio, senza uccidere animali. Il notaio dovrà ricevere un cammello come ricompensa per il suo lavoro. Come dividere i cammelli?

Nota: 1/2 + 1/3 + 1/9 = 17/18 = 34/36

Il notaio presta un cammello e, dei 36 cammelli totali, il primo figlio ne prende 18 (la metà), il secondo 12 (la terza parte) ed il terzo 4 (la nona parte). In totale i cammelli "spartiti" sono 34. I due cammelli rimasti vengono presi dal notaio (uno già gli apparteneva) che quindi ottiene un cammello come ricompensa.
Da notare che tutti i figli hanno avuto di più della parte stabilita nel testamento.


-----------------
Sequenza di Farey
-----------------

La sequenza di Farey F(n) per ogni intero positivo n è l'insieme dei numeri razionali a/b irriducibili (ridotti ai minimi termini) con 0<=a<=b<=n e (a,b)=1 disposti in ordine crescente.

Un termine a/b può essere valutato ricorsivamente utilizzando i due termini precedenti. Di seguito è riportata la formula per calcolare a(n+2)/b(n+2) da a(n+1)/b(n+1) e a(n)/b(n):

a(n+2) = floor((b(n) + n)/b(n+1))*a(n+1) - a(n)
b(n+2) = floor((b(n) + n)/b(n+1))*b(n+1) - b(n)

(define (farey num)
  (local (a b a1 b1 a2 b2 out)
    (setq out '())
    (setq a1 0 b1 1 a2 1 b2 num)
    ; il primo termine vale 0/1
    (push (list 0 1) out)
    ; il secondo termine vale 1/num
    (push (list 1 num) out -1)
    ; inizializzazione dei valori nuovo termine
    (setq a 0 b 0)
    ; ciclo fino a che b = 1
    (while (!= b 1)
      ; relazione per trovare il termine corrente
      (setq a (- (* (floor (div (add b1 num) b2)) a2) a1))
      (setq b (- (* (floor (div (add b1 num) b2)) b2) b1))
      ; inserimento del termine corrente
      (push (list a b) out -1)
      ; aggiornamento valori per la prossima iterazione
      (setq a1 a2)
      (setq a2 a)
      (setq b1 b2)
      (setq b2 b)
    )
    ; funzione di comparazione per l'ordinamento (sort)
    (define (cmp x y) (< (div (first x) (last x)) (div (first y) (last y))))
    ; ordina la lista (crescente)
    (sort out cmp)))

(farey 7)
;-> ((0 1) (1 7) (1 6) (1 5) (1 4) (2 7) (1 3) (2 5) (3 7) (1 2)
;->  (4 7) (3 5) (2 3) (5 7) (3 4) (4 5) (5 6) (6 7) (1 1))

(length (farey 100))
;-> 3045
(length (farey 1000))
;-> 304193

Il numero N di frazioni contenute nella sequenza di Farey di un numero n vale:

          n
  N = 1 + ∑ totient(k)
         k=1

Funzione che calcola il toziente di eulero di un dato numero:

(define (totient num)
  (if (= num 1) 1
    (let (res num)
      (dolist (f (unique (factor num)))
        (setq res (- res (/ res f))))
      res)))

Funzione che calcola la lunghezza della sequenza di Farey di un dato numero:

(define (farey-len num)
  (let (out 1)
    (for (k 1 num)
      (setq out (+ out (totient k)))
    )
    out))

(farey-len 100)
;-> 3045

(farey-len 1000)
;-> 304193

              3*n²
Nota: N(n) ≈ ------
               π²

(define (farey-len2 num)
  (div (mul 3 num num) (mul 3.1415926535897931 3.1415926535897931)))

(farey-len2 1000)
;-> 303963.5509270133

(farey-len 100000)
;-> 3039650755
(farey-len2 100000)
;-> 3039635509.270134


---------------------
Distanza di Chebyshev
---------------------

La distanza di Chebyshev (o della scacchiera o di Lagrange), è il valore tale per cui la distanza tra due vettori è il valore massimo della loro differenza lungo gli assi:

  d(p,q) = max[(|p(i) - q(i)|)]

Nella geometria piana (2D), dati due punti P(x1,y1) e Q(x2,y2) la loro distanza di Chebyshev vale:

  d(P,Q) = max(|x2 - x1|,|y2 - y1|)

Nota: In due dimensioni, la distanza di Chebyshev è equivalente ad una rotazione ed una riscalatura della distanza di Manhattan.

Scriviamo una funzione che calcola la distanza di Chebyshev:

(define (dist-chebyshev x1 y1 x2 y2)
  (max (abs (sub x2 x1)) (abs (sub y2 y1))))

(dist-chebyshev 1 3 3 6)
;-> 3

In N dimensioni i due punti hanno le seguenti coordinate:

  P = (p1, p2, ..., pN)
  Q = (q1, q2, ..., qN)

E la distanza di Chebyshev tra i due punti P e Q vale:

  d(P,Q) = max(|pi - qi|), dove 1<=i<=N

Quindi la funzione generica per calcolare la distanza di Chebyshev tra due punti diventa:

(define (dist-cheby P Q)
  (apply max (map (fn(x y) (abs (sub x y))) P Q)))

(dist-cheby '(1 2 3 4) '(4 7 8 2))
;-> 5

(dist-cheby '(1 3) '(3 6))
;-> 3


----------
Anti-primi
----------

Gli anti-primi (o numeri altamente composti) sono i numeri naturali con più fattori di quelli più piccoli di se stesso. In altre parole, i numeri altamente composti sono quei numeri n dove d(n), il numero di divisori di n, aumenta a record (cioè è maggiore del precedente).

Sequenza OEIS A002182:
  1, 2, 4, 6, 12, 24, 36, 48, 60, 120, 180, 240, 360, 720, 840, 1260,
  1680, 2520, 5040, 7560, 10080, 15120, 20160, 25200, 27720, 45360,
  50400, 55440, 83160, 110880, 166320, 221760, 277200, 332640, 498960,
  554400, 665280, 720720, 1081080, 1441440, 2162160, ...

Funzione che fattorizza un numero:

(define (factor-group num)
  (if (< num 2) nil
      (letn ((out '()) (lst (factor num)) (cur-val (first lst)) (cur-count 0))
        (dolist (el lst)
          (if (= el cur-val) (++ cur-count)
              (begin
                (push (list cur-val cur-count) out -1)
                (setq cur-count 1 cur-val el))))
        (push (list cur-val cur-count) out -1))))

Funzione che conta i divisori di un numero:

(define (divisors-count num)
  (if (= num 1)
      1
      (let (lst (factor-group num))
        (apply * (map (fn(x) (+ 1 (last x))) lst)))))

Funzione che calcola gli anti-primi fino ad un dato limite:

(define (anti-primes limit)
  (local (out best)
    (setq out '())
    (setq best 0)
    (for (i 1 limit)
      (setq val (divisors-count i))
      (if (> val best) (begin
          (setq best val)
          (push (list i val) out -1))
      )
    )
    out))

(anti-primes 1000)
;-> ((1 1) (2 2) (4 3) (6 4) (12 6) (24 8) (36 9) (48 10) (60 12)
;->  (120 16) (180 18) (240 20) (360 24) (720 30) (840 32))

(map first (anti-primes 10000))
;-> (1 2 4 6 12 24 36 48 60 120 180 240 360 720 840 1260 1680 2520 5040 7560)

Possiamo calcolare anche i numeri altamente composti il cui anche il numero di divisori è un numero altamente composto.

Sequenza OEIS A189394:
  1, 2, 6, 12, 60, 360, 1260, 2520, 5040, 55440, 277200, 720720, 3603600,
  61261200, 2205403200, 293318625600, 6746328388800, 195643523275200, ...

(define (anti2-primes limit)
  (local (out best)
    (setq out '())
    (setq best 0)
    (for (i 1 limit)
      (setq val (divisors-count (divisors-count i)))
      (if (> val best) (begin
          (setq best val)
          (push (list i val) out -1))
      )
    )
    out))

(anti2-primes 10000)
;-> ((1 1) (2 2) (6 3) (12 4) (60 6) (360 8) (1260 9) (2520 10) (5040 12))
(map first (anti2-primes 1e6))
;-> (1 2 6 12 60 360 1260 2520 5040 55440 277200 720720)

(time (println (map first (anti2-primes 1e8))))
;-> (1 2 6 12 60 360 1260 2520 5040 55440 277200 720720 3603600 61261200)
;-> 683129.503


---------------------------
Numeri altamente abbondanti
---------------------------

I numeri altamente abbondanti sono quei numeri k tali che sigma(k) > sigma(m) per ogni m < k, dove sigma(k) è la somma dei divisori di k.

Sequenza OEIS A002093:
  1, 2, 3, 4, 6, 8, 10, 12, 16, 18, 20, 24, 30, 36, 42, 48, 60, 72, 84,
  90, 96, 108, 120, 144, 168, 180, 210, 216, 240, 288, 300, 336, 360,
  420, 480, 504, 540, 600, 630, 660, 720, 840, 960, 1008, 1080, 1200,
  1260, 1440, 1560, 1620, 1680, 1800, 1920, 1980, 2100, ...

Funzione che fattorizza un numero:

(define (factor-group num)
  (if (< num 2) nil
      (letn ((out '()) (lst (factor num)) (cur-val (first lst)) (cur-count 0))
        (dolist (el lst)
          (if (= el cur-val) (++ cur-count)
              (begin
                (push (list cur-val cur-count) out -1)
                (setq cur-count 1 cur-val el))))
        (push (list cur-val cur-count) out -1))))

Funzione che somma tutti i divisori di un numero:

(define (divisors-sum num)
  (local (sum out)
    (if (= num 1)
        1
        (begin
          (setq out 1)
          (setq lst (factor-group num))
          (dolist (el lst)
            (setq sum 0)
            (for (i 0 (last el))
              (setq sum (+ sum (pow (first el) i)))
            )
            (setq out (* out sum)))))))

Funzione che calcola i numeri altamente abbondanti fino ad un dato limite:

(define (high-abundant limit)
  (local (out best)
    (setq out '())
    (setq best 0)
    (for (i 1 limit)
      (setq val (divisors-sum i))
      (if (> val best) (begin
          (setq best val)
          (push (list i val) out -1))
      )
    )
    out))

(high-abundant 100)
;-> ((1 1) (2 3) (3 4) (4 7) (6 12) (8 15) (10 18) (12 28) (16 31) (18 39)
;->  (20 42) (24 60) (30 72) (36 91) (42 96) (48 124) (60 168) (72 195)
;->  (84 224) (90 234) (96 252))

(map first (high-abundant 1e3))
;-> (1 2 3 4 6 8 10 12 16 18 20 24 30 36 42 48 60 72 84 90 96
;->  108 120 144 168 180 210 216 240 288 300 336 360 420 480
;->  504 540 600 630 660 720 840 960)


-------------------------------
Creazione dinamica di variabili
-------------------------------

Scrivere una funzione che permette di creare dinamicamente una variabile.

La seguente funzione prende due parametri, il nome (stringa) della variabile da creare e il valore della varibile:

(define (create-var name-var value-var)
  (local (var)
    (setq var name-var)
    (set (sym var) value-var)
    (sym var)))

(create-var "pluto" '(10 20 30))
;-> pluto
pluto
;-> '(10 20 30)
(list? pluto)
;-> true

Possiamo anche creare una variabile definita dall'utente:

(define (make-var)
  (local (var)
    (print "Nome della variabile: ")
    (setq var (read-line))
    ; crea il simbolo/variabile inserito dall'utente come stringa
    (set (sym var) '())
    (println "Variabile " var " creata.")
    (println "Valore della variabile: " (eval (sym var)))
    (print "Nuovo valore della variabile: ")
    ;(set (sym var) (sym (read-line))) ; no list, only a symbol !!!
    ; eval-string valuta la stringa inserita dall'utente
    (set (sym var) (eval-string (read-line)))
    (println (sym var) " = " (eval (sym var)))
  ))

(make-var)
;-> Nome della variabile:
pippo
;-> Variabile pippo creata.
;-> Valore della variabile: ()
;-> Nuovo valore della variabile:
'(10 20 30)
;-> pippo = (10 20 30)
pippo
;-> (10 20 30)
(list? pippo)
;-> true


-----------------
La funzione curry
-----------------

Prima di tutto vediamo la definizione del manuale:

******************
>>>funzione CURRY
******************
sintassi: (curry func exp)

Trasforma "func" da una funzione f(x, y) che prende due argomenti, in una funzione fx(y) che prende un singolo argomento. "curry" funziona come una macro, nel senso che non valuta i suoi argomenti. Questi ultimi vengono valutati durante l'applicazione della funzione "func".

Vediamo alcuni esempi:

(set 'f (curry + 10))
;-> (lambda ($x) (+ 10 $x))

(f 7)
;-> 17

(filter (curry match '(a *)) '((a 10) (b 5) (a 3) (c 8) (a 9)))
;-> ((a 10) (a 3) (a 9))

(clean (curry match '(a *)) '((a 10) (b 5) (a 3) (c 8) (a 9)))
;-> ((b 5) (c 8))

(map (curry list 'x) (sequence 1 5))
;-> ((x 1) (x 2) (x 3) (x 4) (x 5))

"curry" può essere usato con tutte le funzioni che prendono due argomenti.

Vediamo come usare "curry" insieme alla funzione "map".

(map (curry list 1) '(a b c))
;-> ((1 a) (1 b) (1 c))

In pratica "curry" crea una funzione anonima:
(curry list 1)
;-> (lambda ($x) (list 1 $x))

Ecco altri esempi:

(curry * 2)
;-> (lambda ($x) (* 2 $x))
(curry + 3)
;-> (lambda ($x) (+ 3 $x))
((curry + 3) 10)
;-> 13

Possiamo assegnare un nome alla funzione creata da "curry":

(define add3 (curry + 3))
;-> (lambda ($x) (+ 3 $x))
(add3 10)
;-> 13

Possiamo utilizzare "map" con una funzione che riceve più di un argomento (ad esempio la funzione "pow") in questo modo:

(map pow '(2 1) '(3 4))
;-> (8 1)

dove: 8 = 2^3, 1 = 1^4

Ma se la lista degli argomenti si trova all'interno di un'altra lista, allora otteniamo un errore:

(setq lst '((2 1) (3 4)))
(map pow lst)
;-> ERR: value expected in function pow : '(2 1)

Utilizziamo la funzione "curry" per risolvere questo problema:

(map (curry apply pow) lst)
;-> (2 81)

dove: 2 = 2^1, 81 = 3^4

Ok, non è il risultato che volevamo, ma se trasponiamo la lista degli argomenti:

(transpose lst)
;-> ((2 3) (1 4))

Quindi possiamo scrivere:

(map (curry apply pow) (transpose lst))
;-> (8 1)

Che è equivalente a:

(map (lambda(x) (apply pow x)) (transpose lst))
;-> (8 1)

Possiamo anche utilizzare una funzione definita dall'utente:

(define (mypow lst)
  (if (null? lst) '()
      (cons (pow (nth '(0 0) lst) (nth '(0 1) lst)) (mypow (rest lst)))
  )
)

(setq lst '((2 1) (3 4)))
(mypow (transpose lst))
;-> (8 1)

Un altro esempio con la funzione "max":

(map max '(3 5) '(2 7))
;-> (3 7)

(map (curry apply max) '((3 5) (2 7)))
;-> (5 7)

(map (curry apply max) (transpose '((3 5) (2 7))))
;-> (3 7)

Definiamo una macro che si comporta come la funzione predefinita "curry":

(define-macro (curry1 f)
  (append (lambda (z)) (list (cons f (append (args) '(z))))))

(curry1 + 10)
;-> (lambda (z) (+ 10 z))
((curry1 + 10) 20)
;-> 30

(map (curry1 list 1) '(a b c))
;-> ((1 a) (1 b) (1 c))

(map (curry1 list 'x) '(a b c))
;-> ((x a) (x b) (x c))

Ecco un'altra soluzione che utilizza "expand", ma è più lenta:

(define-macro (curry2 f)
   (letex (body (cons f (append (args) '(z))))
      (lambda (z) body)))

(curry2 + 10)
;-> (lambda (z) (+ 10 z))
((curry2 + 10) 20)
;-> 30

(map (curry2 list 1) '(a b c))
;-> ((1 a) (1 b) (1 c))

(map (curry2 list 'x) '(a b c))
;-> ((x a) (x b) (x c))

Vediamo perchè una funzione (invece di una macro) non si comporta correttamente:

(define (curry3 f)
  (append (lambda (z)) (list (cons f (append (args) '(z))))))

(curry3 + 1)
;-> (lambda (z) (+@41493E 1 z))

Se quotiamo la funzione otteniamo:

(curry3 '+ 1)
;-> (lambda (z) (+ 1 z))

La seguente chiamata si comporta correttamente:

(map (curry3 list 1) '(a b c))
;-> ((1 a) (1 b) (1 c))

Ma la seguente non genera il risultato corretto:

(map (curry3 list 'x) '(a b c))
;-> ((nil a) (nil b) (nil c))

perchè il simbolo "x" viene valutato a nil, invece la macro non valuta il simbolo "x".


-------------------
Algoritmo evolutivo
-------------------

Data una stringa (target) scrivere un algoritmo che genera una stringa (current) uguale in modo evolutivo.

Un algoritmo può essere il seguente:

1) generare la stringa "current" con tutti spazi vuoti lunga come la stringa "target"
2) se target=current, allora abbiamo ottenuto la soluzione.
   altrimenti,
    Calcolare la 'distanza' tra la stringa "target" e la stringa "current" (quanti caratteri sono differenti?).
    Modificare in modo casuale/evolutivo i caratteri della stringa "current" che sono diversi da quelli della stringa "target".
    Andare al passo 2.

Vediamo il procedimento:

La stringa da ottenere:

(setq target "NEWLISP IS FUN")

La stringa iniziale (tutti spazi):

(setq current (dup " " (length target)))

Funzione che genera un carattere maiuscolo casuale:

(define (rnd-char) (char (+ (rand 26) 65)))

Funzione che genera una lista con tutti gli indici dei caratteri che sono differenti tra la stringa str1 e la stringa str2:

(define (fitness str1 str2)
  (let (out '())
    (for (i 0 (- (length str1) 1))
      (if (!= (str1 i) (str2 i))
        ;(push (list i (str1 i)) out -1)
        (push i out -1)
      )
    )
    out))

(setq change (fitness target current))
;-> (0 1 2 3 4 5 6 8 9 11 12 13)

Funzione che aggiorna casualmente tutti i caratteri della stringa current che sono differenti tra la stringa target e la stringa current:

(define (update current change)
  (for (i 0 (- (length change)))
    (setf (current (change i)) (rnd-char))
  )
  current)

(setq current (update current change))
;-> "EELVYHN PK KWT"

Adesso possiamo scrivere la funzione "evolutiva":

(define (evolutionary target)
  (local (current change counter)
    (setq counter 1)
    (setq current (dup " " (length target)))
    (while (!= target current)
      (setq change (fitness target current))
      (setq current (update current change))
      (println counter {: } target { - } current)
      (++ counter)
    )))

(evolutionary "NEWLISP IS FUN")
;-> 1: NEWLISP IS FUN - ZTJQPIA BU PQA
;-> 2: NEWLISP IS FUN - LNHQYPN DO MVZ
;-> 3: NEWLISP IS FUN - GKQWVTU MT EMW
;-> 4: NEWLISP IS FUN - SEGBWIY TY VAQ
;-> 5: NEWLISP IS FUN - MEWVNQZ NA KRO
;-> 6: NEWLISP IS FUN - IEWZYQA KC XRD
;-> ...
;-> 49: NEWLISP IS FUN - NEWLISP ES FUN
;-> 50: NEWLISP IS FUN - NEWLISP RS FUN
;-> 51: NEWLISP IS FUN - NEWLISP GS FUN
;-> 52: NEWLISP IS FUN - NEWLISP TS FUN
;-> 53: NEWLISP IS FUN - NEWLISP IS FUN

A dire il vero, questo algoritmo non è "evolutivo" nel senso stretto del significato: non esiste una popolazione e le mutazioni avvengono solo nei caratteri errati.

L'algoritmo generale (Weasel algorithm) è stato proposto da Richard Dawkins utilizzando la seguente frase di 28 caratteri:

  "METHINKS IT IS LIKE A WEASEL"

1. Iniziare con una stringa casuale di 28 caratteri.
2. Fare 100 copie della stringa (riproduzione).
3. Per ogni carattere in ciascuna delle 100 copie, con una probabilità del 5%, sostituire (mutare) il carattere con un nuovo carattere casuale.
4. Confrontare ogni nuova stringa con la stringa di destinazione "METHINKS IT IS LIKE A WEASEL" e assegnare a ciascuna un punteggio che rappresenta l'adattamento evolutivo (il numero di lettere nella stringa che sono corrette e nella posizione corretta).
5. Se una delle nuove stringhe ha un punteggio perfetto (28), abbiamo finito. Altrimenti, prendere la stringa con il punteggio più alto e andare al passo 2.

Un "carattere" è una qualsiasi lettera maiuscola o uno spazio. Il numero di copie per generazione e la possibilità di mutazione per lettera non sono specificati nel libro di Dawkins. Inoltre, 100 copie e un tasso di mutazione del 5% sono solo numeri di esempio. Le lettere corrette non sono "bloccate". Ogni lettera corretta può diventare errata nelle generazioni successive. I termini del programma e l'esistenza della frase target indicano tuttavia che tali 'mutazioni negative' verranno rapidamente corrette.

Vediamo come implementare l'algoritmo Weasel.

(setq target  "METHINKS IT IS LIKE A WEASEL")
(setq current "DFGCBVHJUIDGC VHAQ JKLOPQB Q")

Funzione che genera un carattere maiuscolo casuale o uno spazio:

(define (rnd-char-space)
  (let (ch (char (+ (rand 27) 65)))
    (if (= ch "[")
        " "
        ch)))

(rnd-char-space)
;-> "W"

Funzione che confronta la similitudine di due strignhe (numero di caratteri uguali nella stessa posizione):

(define (check-evolution str1 str2)
  (let (same 0)
    (for (i 0 (- (length str1) 1))
      (if (= (str1 i) (str2 i))
        (++ same)
      )
    )
    same))

(check-evolution target current)
;-> 1

Funzione che modifica una popolazione:

(define (evolve mutation)
  (for (m 0 (- (length mutation) 1))
    (for (i 0 (- (length (mutation m)) 1))
       (if (> change (rand 100)) (begin
           (setf ((mutation m) i) (rnd-char-space))
       ))
    )
  )
  mutation)

Funzione che calcola la mutazione più adatta (stringa più vicina al target):

(define (best-fit mutation)
  (local (score out val-max)
    (setq out -1)
    (setq val-max -1)
    (setq score '())
    ;(dolist (m mutation)
    ;  (push (check-evolution target m) score -1)
    ;)
    (setq score (map (curry check-evolution target) mutation))
    (dolist (s score)
      (if (> s val-max)
        (setq val-max s out $idx)
      )
    )
    out))

Funzione finale dell'algoritmo di Weasel:

(define (evolution target start population change)
(catch
  (local (mutation current generation)
    (setq current start)
    (setq generation 0)
    (while true
      ; creazione della mutazione
      (setq mutation (dup current population true))
      (setq mutation (evolve mutation))
      ; calcolo mutazione più adatta
      (setq current (mutation (best-fit mutation)))
      (++ generation)
      (println current)
      ; target raggiunto?
      (if (= current target) (throw generation))
    ))))

Facciamo alcune prove:

(setq target  "METHINKS IT IS LIKE A WEASEL")
(setq current "DFGCBVHJUIDGC VHAQ JKLOPQB Q")
(evolution target current 100 5)
;-> QFXCBVHJ IDGC VHGQ JKLOPQB Q
;-> QFXCBMHJ IDQC VHGQ JKLOPQB L
;-> MFXCBMHJ IDQC VHGQ JKLOPQB L
;-> MFTCBMHJ IDQC VHGQ JKLOPQB L
;-> ...
;-> METHINKS IT IS LIKE A WEASKL
;-> METHINKS IT IS LIKE A WEASKL
;-> METHINKS IT IS LIKE A WEASKL
;-> METHINKS IT IS LIKE A WEASKL
;-> METHINKS IT IS LIKE A WEASEL
;-> 111

(setq target  "METHINKS IT IS LIKE A WEASEL")
(setq current "DFGCBVHJUIDGC VHAQ JKLOPQB Q")
(evolution target current 1000 10)
;-> ...
;-> 45

(setq target  "EVA VINCE A BRISCOLA MA PERDE A TRESSETTE")
(setq current "                                         ")
(evolution target current 1000 5)
;->        D       S    T                 T
;->   A    M      WS    T                 T
;->   A    M     NWS    T      D          T
;->   A    M     WWS    T   P  D          T
;->  VA    MK    WWS  E T   P  D          T
;->  VA    ML    WWS  E     P  D         WT
;-> EVA    ML    WIS  E     P  D      J  WT
;-> EVA    ML    WIS  E   B P  D      J  WT E
;-> ...
;-> EVA VINCE A BRIS OLA MA PERDE A TRESSETTE
;-> EVA VINCE A BRIS OLA MA PERDE A TRESSETTE
;-> EVA VINCE A BRISCOLA MA PERDE A TRESSETTE
;-> 89

La convergenza dell'algoritmo dipende molto dai parametri "population" e "change".


------------------
Nome del programma
------------------

newLISP ha una funzione per gestire il nome del programma e i suoi parametri: "main-args"
Vediamo la definizione del manuale:

sintassi: (main-args)
sintassi: (main-args int-index)
main-args returns a list with several string members, one for program invocation and one for each of the command-line arguments.
restituisce una lista con diversi elementi stringa, uno per l'invocazione del programma e uno per ciascuno degli argomenti della riga di comando.

newlisp 1 2 3

(main-args)
;-> ("newlisp" "1" "2" "3")

Dopo che "newlisp 1 2 3" è stato eseguito al prompt dei comandi, main-args restituisce un elenco contenente il nome del programma invocante e tre argomenti della riga di comando.

Facoltativamente, main-args può prendere un int-index come indice nella lista. Nota che un indice fuori dall'intervallo farà sì che venga restituito nil, non l'ultimo elemento dell'elenco come nell'indicizzazione standard delle liste.

newlisp a b c

(main-args 0)
;-> "newlisp"
(main-args -1)
;-> "c"
(main-args 2)
;-> "b"
(main-args 10)
;-> nil

Nota che quando newLISP viene eseguito da uno script, main-args restituisce anche il nome dello script come secondo argomento:

# script to show the effect of 'main-args' in script file
(print (main-args) "\n")
(exit)
# end of script file

;; eseguire lo script dalla shell del sistema operativo

script 1 2 3

("newlisp" "script" "1" "2" "3")

Try executing this script with different command-line parameters.

newLISP has a function, (main-args int) for this.

Per ottenere il nome del programma/script possiamo usare il seguente script:

(let ((program (main-args 1)))
  (println (format "Program: %s" program))
  (exit))


------------------
loop e recur macro
------------------

Le macro "loop" e "recur" (scritte da ClaudeM) facilitano l'utilizzo di una programmazione simile al linguaggio Scheme in quanto newLISP non supporta l'ottimizzazione della ricorsione in coda (Tail Code Optimization).
Queste macro sono molto eleganti anche se sono meno efficienti della tecnica di "trampolining" o delle tecniche iterative.

; looking at options to simulate TCO (Tail Code Optimization)
; I come from Scheme and I like simple recursion
; maybe like Clojure, which makes it explixit with loop & recur
;
; Use a pair of macros. The process is as follows:
;   - use a loop (otherwise infinite)
;   - there must be two args: let-list and body
;   - define local variables with initial values
;   - execute the body, must have an exit test and recur
;   - recur macro
;     - in tail position - how would I check for this?
;     - take new values for local variables (positional)
;     - loop back; if not in tail position, problems may occur
(define-macro (loop)
  (letn (loop-recur-let-list (args 0)
         loop-recur-body (args 1)
         loop-recur-let-list-length (length loop-recur-let-list)
         loop-recur-var-names '()
         loop-recur-variables '()
         loop-recur-done nil)
    ;
    ; let-list could be a list of pairs or a list of two-item lists
    ; convert pairs to a list of lists
    ;
;   (println "loop-recur-let-list : " loop-recur-let-list)
;   (println "loop-recur-body : " loop-recur-body)
;   (println " - - - - - - - -")
    (if (not (list? (loop-recur-let-list 0)))
      (begin
        (if (not (even? loop-recur-let-list-length))
            (begin
              ;;(println "The loop's let list must contain an even number of items.")
              ;;(println "  (loop " loop-recur-let-list " ...)")
              (exit 1)))
        ;
        ; loop over pairs and convert
        ;
        (letn (loop-recur-old-let-list loop-recur-let-list)
          (setq loop-recur-let-list '())
          (for (i 0 (- loop-recur-let-list-length 1) 2)
            (push (list (nth i loop-recur-old-let-list)
                        (nth (+ i 1) loop-recur-old-let-list))
                  loop-recur-let-list
                  -1)))))
    ;
    ; process loop-recur-let-list: extract variable names and initial values
    ; so I can redefine at each iteration
    ; build loop-recur-var-names and initial loop-recur-variables
    ;
    (dolist (i loop-recur-let-list)
      (push (first i) loop-recur-var-names -1)
      (push (nth 1 i) loop-recur-variables -1))
    ;;(println "loop-recur-var-names : " loop-recur-var-names)
    ;;(println "loop-recur-variables : " loop-recur-variables)
    ;
    ; loop variables are defined and given initial values
    ;
    (until loop-recur-done
      ; define variables, made fresh each iteration
      (setq loop-recur-let-list
            (map list loop-recur-var-names loop-recur-variables))
      ;;(println "loop-recur-let-list : " loop-recur-let-list)
      (letex (loop-recur-let-list-expanded loop-recur-let-list)
        (let loop-recur-let-list-expanded
          (setq loop-recur-done true)  ; if recur is not used, the loop should end
          (eval loop-recur-body))))))  ; evaluate the body, it should call recur
;
; build a new loop-recur-let-list
;
(define-macro (recur)
  (begin
    (setq loop-recur-variables
          (map eval (args)))
;   (println "recur: new variables are " loop-recur-variables)
    (setq loop-recur-done nil)))
;
; quick test
;
(define (factorial n)
  (loop (i 1
         prod 1L)
      (if (> i n)
        prod
        (recur (+ 1 i) (* prod i)))))

(factorial 5)
;-> loop-recur-var-names : (i prod)
;-> loop-recur-variables : (1 1L)
;-> loop-recur-let-list : ((i 1) (prod 1L))
;-> loop-recur-let-list : ((i 2) (prod 1L))
;-> loop-recur-let-list : ((i 3) (prod 2L))
;-> loop-recur-let-list : ((i 4) (prod 6L))
;-> loop-recur-let-list : ((i 5) (prod 24L))
;-> loop-recur-let-list : ((i 6) (prod 120L))
;-> 120L

Vediamo la diffferenza di velocità con una versione iterativa del fattoriale:

(define (fact num)
  (if (zero? num)
      1
      (let (out 1L)
        (for (x 1L num)
          (setq out (* out x))))))

(= (fact 200) (factorial 200))
;-> true

(time (factorial 200) 1000)
;-> 281.456

(time (fact 200) 1000)
;-> 31.178

La versione iterativa è 9 volte più veloce.


---------------------------
Breve introduzione ai grafi
---------------------------

A) Cosa è un Grafo?
-------------------

Un grafo è una coppia ordinata G = (V, E) che comprende un insieme V di vertici o nodi e un insieme di coppie di vertici da V, noti come archi (edges) di un grafo. Ad esempio, per il grafo sottostante.

  V = { 1, 2, 3, 4, 5, 6 }
  E = { (1, 4), (1, 6), (2, 6), (4, 5), (5, 6) }

  ╔═══╗           ╔═══╗
  ║ 6 ║-----------║ 2 ║
  ╚═══╝           ╚═══╝
    |  \
    |   \
    |    \
    |     ╔═══╗           ╔═══╗
    |     ║ 1 ║           ║ 3 ║
    |     ╚═══╝           ╚═══╝
    |          \
    |           \
    |            \
  ╔═══╗           ╔═══╗
  ║ 5 ║-----------║ 4 ║
  ╚═══╝           ╚═══╝

B) Tipi di grafi
----------------

1. Grafo non orientato (Undirected graph)
-----------------------------------------
Un grafo non orientato (grafo) è un grafo in cui gli archi non hanno orientamento. L'arco (x, y) è identico all'arco (y, x), cioè non sono coppie ordinate. Il numero massimo di archi possibili in un grafo non orientato senza cicli (loop) è n*(n-1)/2.

Esempio di grafo non orientato

  ╔═══╗           ╔═══╗
  ║ 6 ║-----------║ 2 ║
  ╚═══╝           ╚═══╝
    |  \
    |   \
    |    \
    |     ╔═══╗           ╔═══╗
    |     ║ 1 ║-----------║ 3 ║
    |     ╚═══╝           ╚═══╝
    |          \         /
    |           \       /
    |            \     /
  ╔═══╗           ╔═══╗
  ║ 5 ║-----------║ 4 ║
  ╚═══╝           ╚═══╝

2. Grafo orientato (Direct graph)
-------------------------------
Un grafo orientato (digrafo) è un grafo in cui gli archi sono orientati, ovvero l'arco (x, y) non è identico all'arco (y, x).

Esempio di grafo orientato (Il carattere "■" rappresenta la fine dell'arco)

          ╔═══╗
          ║ 2 ║
          ╚═══╝
        ■
       /
      /
  ╔═══╗           ╔═══╗
  ║ 1 ║■---------■║ 3 ║
  ╚═══╝           ╚═══╝
       \         ■
        \       /
         ■     /
          ╔═══╗
          ║ 4 ║
          ╚═══╝

3. Grafo aciclico diretto (Directed Acyclic Graph - DAG)
----------------------------------------------------------
Un grafo aciclico diretto (DAG) è un grafo orientato che non contiene cicli.

Esempio di DAG

          ╔═══╗
          ║ 2 ║
          ╚═══╝
        ■
       /
      /
  ╔═══╗           ╔═══╗
  ║ 1 ║■----------║ 3 ║
  ╚═══╝           ╚═══╝
       \         ■
        \       /
         ■     /
          ╔═══╗
          ║ 4 ║
          ╚═══╝

4. Multi grafo
--------------
Un multigrafo è un grafo non orientato in cui sono consentiti più archi (e talvolta cicli/loop). Gli archi multipli sono due o più archi che collegano gli stessi due vertici. Un ciclo è un arco (diretto o non orientato) che collega un vertice a se stesso (può essere consentito o meno)

5. Grafo semplice
-----------------
Un grafo semplice è un grafo non orientato in cui non sono consentiti sia gli archi multipli che i cicli/loop rispetto a un multigrafo. In un grafo semplice con n vertici, il grado di ogni vertice è al massimo n-1.

Esempi di archi multipli

  ╔═══╗----------■╔═══╗           ╔═══╗-----------╔═══╗
  ║ 1 ║           ║ 2 ║           ║ 1 ║           ║ 2 ║
  ╚═══╝■----------╚═══╝           ╚═══╝-----------╚═══╝

Esempio di ciclo/loop

  ╔═══╗------+
  ║ 1 ║      |
  ╚═══╝------+

6. Grafo pesato e non pesato
------------------------------------
Un grafo pesato associa un valore (peso) a ogni arco del grafo. Possiamo anche usare le parole costo o lunghezza invece di peso.

Un grafo non pesato non ha alcun valore (peso) associato a ogni arco del grafo. In altre parole, un grafo pesato è un grafo pesato con tutti i pesi degli archi pari a 1. Se non diversamente specificato, si presume che tutti i grafi non siano ponderati per impostazione predefinita.

Esempio di grafo diretto pesato

          ╔═══╗
          ║ 2 ║
          ╚═══╝
        ■
    10 /
      /
  ╔═══╗     3     ╔═══╗
  ║ 1 ║■----------║ 3 ║
  ╚═══╝           ╚═══╝
       \         ■
      8 \       / 4
         ■     /
          ╔═══╗
          ║ 4 ║
          ╚═══╝

7. Grafo completo
-----------------
Un grafo completo è quello in cui ogni due vertici sono adiacenti: tutti i bordi che possono esistere sono presenti.

8. Grafo connesso
-----------------
Un grafo connesso ha un percorso tra ogni coppia di vertici. In altre parole, non ci sono vertici irraggiungibili. Un grafo disconnesso è un grafo non connesso.

C) Termini comunemente usati per i Grafi
----------------------------------------

Un "arco (edge)" è (insieme ai "vertici (vertices") una delle due unità di base da cui sono costruiti i grafi. Ogni arco ha due vertici a cui è attaccato, chiamati i suoi "punti finali (endpoints)".

Due vertici sono chiamati "adiacenti (adjacent)" se sono punti finali dello stesso arco.

Gli "archi in uscita (outgoing edges)" di un vertice sono archi diretti di cui il vertice è l'origine.

Gli "archi in entrata (ingoing edges)" di un vertice sono archi diretti di cui il vertice è la destinazione.

Il "grado (degree)" di un vertice in un grafo è il numero totale di archi incidenti su di esso.

In un grafo orientato, il "grado esterno (out-degree)" di un vertice è il numero totale di archi uscenti e il "grado interno (in-degree)" è il numero totale di archi entranti.

Un vertice con zero di grado è chiamato "vertice sorgente (source vertex)", mentre un vertice con zero di grado esterno è chiamato "vertice sink (sink vertex)".

Un "vertice isolato (isolated vertex)" è un vertice con grado zero, che non è un punto finale di un arco.

"Percorso (path)" è una sequenza di vertici e archi alternati in modo tale che ogni arco colleghi ogni vertice successivo.

"Ciclo (cycle)" è un percorso che inizia e finisce nello stesso vertice.

"Percorso semplice (simple path)" è un percorso con vertici distinti.

Un grafo è "fortemente connesso (strongly connected)" se contiene un cammino orientato da u a v e un cammino orientato da v a u per ogni coppia di vertici u, v.

Un grafo orientato è detto "debolmente connesso (weakly connected)" se la sostituzione di tutti i suoi archi orientati con archi non orientati produce un grafo connesso (non orientato). I vertici in un grafo debolmente connesso hanno un grado esterno o un grado interno di almeno 1.

"Componente connesso (connected component)" è il sottografo connesso massimale di un grafo non connesso.

Un "ponte (bridge)" è un arco la cui rimozione disconnetterebbe il grafo.

"Foresta (forest)" è un grafo senza cicli.

"Albero (tree)" è un grafo connesso senza cicli. Se rimuoviamo tutti i cicli da DAG (grafo aciclico diretto), diventa un albero e se rimuoviamo qualsiasi arco in un albero, diventa una foresta.

"Albero di copertura (spanning tree)" di un grafo non orientato è un sottografo che è un albero che include tutti i vertici del grafo.

D) Relazione tra numero di archi e vertici
------------------------------------------

Per un grafo semplice con m bordi e n vertici, se il grafo è

diretto, allora m = n*(n-1)

non orientato, allora m = n*(n-1)/2

connesso, allora m = n-1

un albero, allora m = n-1

una foresta, allora m = n-1

completo, allora m = n*(n-1)/2

Pertanto, O(m) può variare tra O(1) e O(n^2), a seconda di quanto è denso il grafo.

E) Rappresentazione dei grafi
-----------------------------

1. Rappresentazione con matrice di adiacenza
--------------------------------------------
Una matrice di adiacenza è una matrice quadrata utilizzata per rappresentare un grafo finito. Gli elementi della matrice indicano se le coppie di vertici sono adiacenti o meno nel grafo.
Definizione:
Per un semplice grafo non pesato con insieme di vertici V, la matrice di adiacenza è un quadrato |V| × |V| matrice A tale che il suo elemento:

A(i j) = 1, quando c'è un arco dal vertice i al vertice j, e
A(i j) = 0, quando non c'è un arco.

Ogni riga nella matrice rappresenta i vertici di origine e ogni colonna rappresenta i vertici di destinazione. Gli elementi diagonali della matrice sono tutti zero poiché i bordi da un vertice a se stesso, cioè i cicli non sono consentiti nei grafi semplici. Se il grafo non è orientato, la matrice di adiacenza sarà simmetrica. Inoltre, per un grafo ponderato, Aij può rappresentare i pesi degli archi.

Esempio di matrice di adiacenza di un grafo orientato

          ╔═══╗
          ║ 0 ║
          ╚═══╝             ╔═══╗
        ■      \            ║ 4 ║
       /        \           ╚═══╝             |0 1 0 0 0 0|
      /          ■            ■               |0 0 1 0 0 0|
  ╔═══╗           ╔═══╗       |               |1 1 0 0 0 0|
  ║ 2 ║■---------■║ 1 ║       |               |0 0 1 0 0 0|
  ╚═══╝           ╚═══╝       |               |0 0 0 0 0 1|
       ■                      ■               |0 0 0 0 1 0|
        \                   ╔═══╗
         \                  ║ 5 ║
          ╔═══╗             ╚═══╝
          ║ 3 ║
          ╚═══╝

Una matrice di adiacenza mantiene un valore (1/0/arco-peso) per ogni coppia di vertici, indipendentemente dal fatto che l'arco esista o meno, quindi richiede n^2 spazi. Può essere utilizzata in modo efficiente solo quando il grafo è denso.

2. Rappresentazione con una lista delle adiacenze
-------------------------------------------------
Una rappresentazione del grafo con una lista delle adiacenze associa ciascun vertice nel grafo alla raccolta dei suoi vertici o archi vicini, ovvero ogni vertice memorizza un elenco di vertici adiacenti. Esistono molte varianti della rappresentazione con una lista delle adiacenze a seconda dell'implementazione. Questa struttura dati consente la memorizzazione di dati aggiuntivi sui vertici ed è molto efficiente quando il grafo contiene solo pochi archi (cioè il grafo è rado (sparse)).

Esempio di lista delle adiacenze di un grafo orientato

          ╔═══╗
          ║ 0 ║
          ╚═══╝             ╔═══╗
        ■      \            ║ 4 ║
       /        \           ╚═══╝
      /          ■            ■
  ╔═══╗           ╔═══╗       |
  ║ 2 ║■---------■║ 1 ║       |
  ╚═══╝           ╚═══╝       |
       ■                      ■
        \                   ╔═══╗
         \                  ║ 5 ║
          ╔═══╗             ╚═══╝
          ║ 3 ║
          ╚═══╝

lista = ((0 (1)) (1 (2)) (2 (0 1)) (3 (2)) (4 (5)) (5 (4)))


---------------------------
Lanciare N volte una moneta
---------------------------

Lanciando una moneta equa N volte, qual'è la probabilità che gli ultimi due risultati siano uguali?

Se la moneta è equa, cioè i suoi risultati hanno una distribuzione uniforme, allora i lanci da i a (N-2) non hanno importanza. Dobbiamo considerare solo gli ultimi due lanci e possiamo farlo in due modi.

1) Teorema della probabilità composta, la probabilità che due eventi indipendenti accadano insieme è pari al prodotto delle probabilità dei singoli eventi:

  P(2T) = P(T) * P(T) = 1/2 * 1/2 = 1/4 = 25%

La probabilità che due risultati siano due Teste vale il prodotto delle singole probabilità.
Poichè anche due croci sono risultati uguali dobbiamo aggiungere anche questo caso alla probabilità totale:

  P(2C) = P(C) * P(C) = 1/2 * 1/2 = 1/4 = 25%

Quindi la probabilità totale vale:

  P(2uguali) = P(2C) + P(2B) = 1/4 + 1/4 = 1/2 = 50%

2) Teorema fondamentale della probabilità, la brobabilità di un evento è data dal rapporto tra casi favorevoli e casi possibili:

           numero casi favorevoli
  P(E) = --------------------------
           numero casi possibili

Nel nostro caso abbiamo:
casi possibili  = 4: (T T), (T C), (C T), (C C) = 4
casi favorevoli = 2: (T T) (C C)

  P(2uguali) = 2/4 = 1/2 = 50%

Per gli scettici come me scriviamo una funzione:

(define (flip-coin num)
  (local (val a b)
    (for (i 1 num)
      (setq val (rand 2))
      (cond ((= i (- num 1)) (setq a val))
            ((= i (- num 2)) (setq b val))
      )
    )
    (= a b)))

(for (i 1 10) (print (flip-coin 10) { }))
;-> nil true nil nil true nil true true nil nil

(define (test-coin num iter)
  (let (out 0)
    (for (i 1 iter)
      (if (flip-coin num) (++ out))
    )
    (div out iter)))

(test-coin 10 10000)
;-> 0.5011
(test-coin 100 100000)
;-> 0.50122
(test-coin 100 1000000)
;-> 0.499789


-----------------------------------------------
Problema dei fiammiferi di Banach con N scatole
-----------------------------------------------

Una persona ha N scatole di fiammiferi nello zaino ognuna contenente M fiammiferi. Ogni volta che ha bisogno di un fiammifero lo prende da una delle N scatole (cioè, ha la stessa probabilità di scegliere una delle N scatole). Ad un certo punto (N-1) scatole saranno diventate vuote: in media, quanti fiammiferi ci sono nell'unica scatola rimasta?
Una scatola è considerata vuota quando viene selezionata e contiene 0 fiammiferi.
Ci sono due modi di simulare il problema a seconda del seguente comportamento:
1) le scatole vuote non vengono gettate e quindi possono essere riselezionate
2) le scatole vuote vengono gettate e quindi non possono essere riselezionate

Vediamo di scrivere un programma che simula il primo caso:

(setq n 5 m 10)

Funzione che verifica se esistono fiammiferi da estrarre dalle scatole:

(define (exist-fiam fiam)
  (let (conta 0)
    (dolist (f fiam)
      ; scatola vuota = -1
      (if (= f -1)
          (++ conta)))
    ; se tutti gli elementi (tranne uno) valgono -1,
    ; allora non esistono fiammiferi da estrarre
    (!= conta (- (length fiam) 1))))

(exist-fiam '(-1 3 -1 -1 -1))
;-> nil
(exist-fiam '(-1 3 0 -1 -1))
;-> true
(exist-fiam '(-1 20 20 20 20 20 20 20 20 20 20))
;-> true
(exist-fiam '(-1 2))
;-> nil
(exist-fiam '(2))
;-> nil

Funzione che effettua una simulazione completa del processo di estrazione e calcola quanti fiammiferi rimangono nell'ultima scatola (quando le altre sono tutte vuote):

(define (banach1 n m)
  (local (fiam box-num)
    ; lista delle scatole
    ; vettore di n+1 elementi tutti con valore m
    (setq fiam (array (+ n 1) (list m)))
    ; (fiam 0) = -1
    (setf (fiam 0) -1)
    ; affinchè esistono fiammiferi da estrarre..
    (while (exist-fiam fiam)
       ; seleziona una scatola
      (setq box-num (+ (rand n) 1))
      ; se la scatola scelta non è vuota (-1)
      (if (!= (fiam box-num) -1)
          ; toglie un fiammifero dalla scatola
          (-- (fiam box-num))
      )
      ;(println fiam)
      ;(read-line)
    )
    ; cerca valore non uguale a -1
    ; nella lista/vettore delle scatole
    (catch
      (dolist (f fiam)
        (if (!= f -1) (throw f))
      ))))

(for (i 1 10) (print (banach1 5 10) { }))
;-> 3 1 1 1 2 0 2 1 1 0

Funzione che esegue la simulazione un determinato numero di volte e restituisce una lista con le frequenze dei fiammiferi rimasti:

(define (banach1-test n m iter)
  (local (out)
    (setq out (array (+ m 1) '(0)))
    (for (i 1 iter)
      (++ (out (banach1 n m)))
    )
    out))

(setq sol (banach1-test 5 10 10000))
;-> (3184 2409 1871 1199 708 388 149 69 18 5 0)

Quindi, 3233 volte sono rimasti 0 fiammiferi, 2443 volte è rimasto 1 fiammifero, 1870 volte sono rimasti 2 fiammiferi, ... e 0 volte sono rimasti 10 fiammiferi.

Vediamo le percentuali di frequenza:

(map (fn(x) (mul 100 (div x (apply + sol)))) sol)
;-> (31.84 24.09 18.71 11.99 7.08
;->  3.88 1.49 0.69 0.18 0.05 0)

Aumentiamo il numero di simulazioni:

(setq sol (banach1-test 5 10 1e6))
;-> (315275 248335 180842 120336 71935 37678 17220 6297 1711 334 37)
(map (fn(x) (mul 100 (div x (apply + sol)))) sol)
;-> (31.5275 24.8335 18.0842
;->  12.0336 7.1935 3.7678
;->  1.722 0.6297 0.1711
;->  0.0334 0.0037)

(setq sol (banach1-test 5 10 1e7))
;-> (3146012 2488151 1814325 1205730 718858
;->  375560 168454 61827 17359 3412 312)
(map (fn(x) (mul 100 (div x (apply + sol)))) sol)
;-> (31.46012 24.88151 18.14325
;->  12.0573 7.18858 3.7556
;->  1.68454 0.61827 0.17359
;->  0.03412 0.00312)

Adesso vediamo di simulare il secondo caso:

(define (banach2 n m)
  (local (fiam box-num b)
    ; lista delle scatole
    ; vettore di n+1 elementi tutti con valore m
    (setq fiam (array (+ n 1) (list m)))
    (setf (fiam 0) -1)
    ; lista delle scatole
    (setq box-num (sequence 1 n))
    ; affinchè ci sono almeno due scatole...
    (while (> (length box-num) 1)
      ; seleziona una scatola
      ; (un numero casuale da 1 al numero delle scatole)
      (setq b (first (select box-num (rand (length box-num)))))
      ; se il valore della scatola è zero,
      ; (non ci sono più fiammiferi)
      (if (= (fiam b) 0)
          ; allora rimuove la scatola
          (pop box-num (find b box-num))
          ; altrimenti toglie un fiammifero dalla scatola
          (-- (fiam b))
      )
    )
    ; il risultato è il numero di fiammiferi
    ; della scatola rimasta
    (fiam (first box-num))
    ))

(for (i 1 10) (print (banach2 5 10) { }))
;-> 0 2 2 0 0 1 3 0 5 0

Funzione che esegue la simulazione un determinato numero di volte e restituisce una lista con le frequenze dei fiammiferi rimasti:

(define (banach2-test n m iter)
  (local (out)
    (setq out (array (+ m 1) '(0)))
    (for (i 1 iter)
      (++ (out (banach2 n m)))
    )
    out))

Facciamo alcune prove:

(setq sol (banach2-test 5 10 10000))
;-> (3129 2553 1783 1218 718 362 158 61 13 4 1)
(map (fn(x) (mul 100 (div x (apply + sol)))) sol)
;-> (31.29 25.53 17.83 12.18 7.18 3.62 1.58 0.61 0.13 0.04 0.01)

(setq sol (banach2-test 5 10 1e6))
;-> (314822 248776 180943 121049 71350
;->  37623 16971 6254 1810 369 33)
(map (fn(x) (mul 100 (div x (apply + sol)))) sol)
;-> (31.4822 24.8776 18.0943 12.1049 7.135
;->  3.7623 1.6971 0.6254 0.181 0.0369 0.0033)

(setq sol (banach2-test 5 10 1e7))
;-> (3145292 2489280 1814241 1205993 718267
;->  376016 168057 61812 17443 3292 307)
(map (fn(x) (mul 100 (div x (apply + sol)))) sol)
;-> (31.45292 24.8928 18.14241 12.05993 7.182667
;->  3.76016 1.68057 0.61812 0.17443 0.03292 0.00307)

I due casi ottengono lo stesso risultato nelle simulazioni:

(map sub
 '(31.46012 24.88151 18.14325 12.0573 7.18858
   3.7556 1.68454 0.61827 0.17359 0.03412 0.00312)
 '(31.45292 24.8928 18.14241 12.05993 7.182667
   3.76016 1.68057 0.61812 0.17443 0.03292 0.00307))
;-> (0.007200000000000983 -0.01129000000000247 0.0008399999999966212
;->  -0.00262999999999991 0.005912999999999613 -0.00456000000000012
;->  0.003970000000000029 0.0001499999999999835 -0.0008400000000000074
;->  0.0012 5.000000000000013e-005)

Verifichiamo che questa funzione sia congruente con i risultati ottenuti nel paragrafo "Problema dei fiammiferi di Banach" con due scatole:

  (8.8874 8.9236 8.756500000000001 8.5153 8.262600000000001
  7.7165 7.2776 6.6639 6.0641 5.3545 4.7031 4.0201 3.3735
  2.7765 2.2529 1.7751 1.3587 1.0171 0.7549 0.5440999999999999
  0.3697 0.2397 0.1619 0.1025 0.05860000000000001 0.0335 0.0198
  0.0086 0.0043 0.0021 0.0006000000000000001 0.0004 9.999999999999999e-005
  9.999999999999999e-005 9.999999999999999e-005 0 0 0 0 0 0)

(setq sol (banach2-test 2 40 1e6))
;-> (88666 88925 87689 85645 82462 78072 73074 67090
;->  60151 53463 46363 40217 33591 27990 22455 17826
;->  13485 10417 7356 5314 3657 2327 1546 944 597 309
;->  203 82 46 23 9 3 1 2 0 0 0 0 0 0 0)
(map (fn(x) (mul 100 (div x (apply + sol)))) sol)
;-> (8.8666 8.8925 8.7689 8.564500000000001 8.2462
;->  7.8072 7.3074 6.709 6.0151 5.3463 4.6363 4.0217 3.3591
;->  2.799 2.2455 1.7826 1.3485 1.0417 0.7355999999999999 0.5314
;->  0.3657 0.2327 0.1546 0.0944 0.0597 0.0309 0.0203
;->  0.008200000000000001 0.0046 0.0023 0.0009 0.0003 9.999999999999999e-005
;->  0.0002 0 0 0 0 0 0 0)

Le due soluzioni sono congruenti.

Per finire vediamo un modo alternativo di selezionare i fiammiferi dalle scatole.
Possiamo creare una lista con tutti i valori possibili del nostro universo che è rappresentato dalle estrazioni di un fiammifero da una delle scatole a disposizione. Supponiamo di avere N scatole con M fiammiferi, allora il nostro universo vale N volte la lista (1 2 ... M):

                      (x M volte)
  (1 2 ... N) (1 2 ... N) ... (1 2 ... N) =

= (1 1 ... 1) (2 2 ... 2) ... (N N ... N)
   (M volte)

Cioè dobbiamo estrarre M volte la scatola X per estrarre tutti i fiammiferi. Mettendo insieme tutti i valori possibili otteniamo una lista del tipo:

(1 1 .. 1 2 2 .. 2 ... N N .. N)

Un esempio chiarisce meglio il concetto:

(setq n 3 m 5)
(setq rnd (randomize (flat (dup (sequence 1 n) (+ m 1)))))
;-> (3 1 2 2 1 3 3 3 3 1 3 1 2 1 1 2 2 2)

Questa lista rappresenta l'ordine (casuale) con cui devono essere estratti i fiammiferi dalle scatole: scatola 3, poi 1, poi 2, ecc. e infine rimane la scatola 2.
Abbiamo usato (m+1) perchè la scatola deve arrivare a -1 e non a 0 per essere considerata vuota.
In questo caso il numero di fiammiferi rimasti nell'ultima scatola è pari al numero di valori uguali consecutivi in "rnd" (partendo dal fondo) meno uno. Ad esempio nel caso precedente abbiamo 3 valori uguali (2) alla fine di "rnd", quindi ci sono (3 - 1) = 2 fiammiferi rimasti nell'ultima scatola.

(define (banach3 n m)
  (local (rnd fiam box idx conta)
    ; creazione di tutte le estrazioni casuali
    (setq rnd (randomize (flat (dup (sequence 1 n) (+ m 1)))))
    ; ultima scatola da estrarre
    (setq box (rnd -1))
    ; posizione indice
    (setq idx -2)
    ; numero fiammiferi rimasti nell'ultima scatola
    (setq conta 0)
    (while (= (rnd idx) box)
      ; aggiorna indice
      (-- idx)
      ; aumenta numero di fiammiferi
      (++ conta)
    )
    conta))

(define (banach3-test n m iter)
  (local (out)
    (setq out (array (+ m 1) '(0)))
    (for (i 1 iter)
      (++ (out (banach3 n m)))
    )
    out))

(setq sol (banach3-test 5 10 10000))
;-> (8137 1543 277 36 6 1 0 0 0 0 0)
(map (fn(x) (mul 100 (div x (apply + sol)))) sol)
;-> (81.37000000000001 15.43 2.77 0.36 0.06 0.01
;->  0 0 0 0 0)

(setq sol (banach3-test 5 10 1e6))
;-> (814717 153676 26567 4410 565 57 7 1 0 0 0))
(map (fn(x) (mul 100 (div x (apply + sol)))) sol)
;-> (81.4717 15.3676 2.6567 0.441 0.0565 0.0057
;->  0.0007 9.999999999999999e-005 0 0 0)

In questo caso i risultati sono diversi dalle prime due simulazioni perchè la funzione di casualità viene applicata a tutta la simulazione e non ad ogni singolo passo della simulazione (cioè ad ogni estrazione di un fiammifero).


-----------------------------------------------------
Conflitti read-write nelle transazioni di un database
-----------------------------------------------------

Dato un elenco di transazioni di database, trovare tutti i conflitti di lettura-scrittura tra di loro. Si supponga che non esista un protocollo (es. Strict 2PL) per prevenire conflitti di read-write (lettura-scrittura).

Ogni transazione del database è data sotto forma di tupla. La tupla ('T', 'A', 't', 'R') indica che una transazione T ha avuto accesso a un record del database A all'istante t e che viene eseguita un'operazione di lettura R sul record.

Supponiamo che si verifichi un conflitto di dati quando due transazioni accedono allo stesso record nel database entro un intervallo di 5 unità. Sul record viene eseguita almeno un'operazione di scrittura.

Per esempio, il seguente gruppo di transazioni di input:

  (T1, A, 0, R)
  (T2, A, 2, W)
  (T3, B, 4, W)
  (T4, C, 5, W)
  (T5, B, 7, R)
  (T6, C, 8, W)
  (T7, A, 9, R)

Dovrebbe produrre il seguente output:

  Le transazioni T1 e T2 sono coinvolte nel conflitto RW
  Le transazioni T3 e T5 sono coinvolte nel conflitto WR
  Le transazioni T4 e T6 sono coinvolte nel conflitto WW

Breve panoramica sui conflitti di lettura-scrittura
---------------------------------------------------
Nei database può verificarsi un conflitto di dati durante un'operazione di lettura o scrittura da parte delle diverse transazioni sugli stessi dati durante la vita della transazione, portando a uno stato finale del database incoerente. Esistono tre tipi di conflitti di dati coinvolti nelle transazione di un database.

1) Conflitto tra scrittura e lettura (WR) (lettura sporca)
----------------------------------------------------------
Questo conflitto si verifica quando una transazione legge i dati scritti dall'altra transazione, ma non ancora confermati.

2) Conflitto di lettura-scrittura (RW)
--------------------------------------
Questo conflitto si verifica quando una transazione scrive i dati che sono stati precedentemente letti dall'altra transazione.

3) Conflitto di scrittura-scrittura (WW) (operazione di scrittura cieca)
------------------------------------------------------------------------
Questo conflitto si verifica quando i dati aggiornati da una transazione vengono sovrascritti da un'altra transazione che potrebbe portare alla perdita dell'aggiornamento dei dati.
Si noti che non vi è alcun conflitto di lettura-lettura (RR) nel database poiché nessuna informazione viene aggiornata nel database durante l'operazione di lettura.

Per risolvere il nostro problema, l'idea è di ordinare tutte le transazioni in ordine crescente di record del database e del relativo tempo di accesso. Per ogni record del database, considerare tutte le coppie di transazioni che hanno avuto accesso al record corrente entro un intervallo di 5 unità. Infine, memorizziamo tutte le coppie di transazioni in conflitto per le quali viene eseguita almeno un'operazione di scrittura sul record corrente.

(define (check-conflict transaction)
  (local (tr out)
    (setq tr '() out '())
    ; per ogni transazione Tx sposta
    ; il nome della transazione all'ultimo posto
    (dolist (t transaction)
      (setq el (select t '(1 2 3 0)))
      (push el tr -1)
    )
    ; ordina le transazioni per record e tempo di accesso
    (sort tr)
    ; ricerca dei conflitti nelle operazioni di lettura e scrittura
    (for (i 0 (- (length tmp) 1))
      (setq j (- i 1))
      (while (and (>= j 0) (= (tmp i 0) (tmp j 0)) (<= (tmp i 1) (+ 5 (tmp j 1))))
        ; per l'esistenza di un conflitto,
        ; almeno una operazione deve essere di scrittura (W)
        (if (or (= 'W (tmp i 2)) (= 'W (tmp j 2)))
            (push (list (tmp j) (tmp i)) out -1)
        )
        (-- j)
      )
    )
    out))

Proviamo la funzione:

(setq transact '(
  (T1 A 0 R)
  (T2 A 2 W)
  (T3 B 4 W)
  (T4 C 5 W)
  (T5 B 7 R)
  (T6 C 8 W)
  (T7 A 9 R)))

(check-conflict transact)
;-> (((A 0 R T1) (A 2 W T2))
;->  ((B 4 W T3) (B 7 R T5))
;->  ((C 5 W T4) (C 8 W T6)))

Le transazioni T1 e T2 sono coinvolte nel conflitto RW.
Le transazioni T3 e T5 sono coinvolte nel conflitto WR.
Le transazioni T4 e T6 sono coinvolte nel conflitto WW.


-----------------------------------
Unico elemento diverso in una lista
-----------------------------------

Dato una lista di interi in cui tutti gli elementi sono uguali tranne uno, trovare l'unico elemento diverso nella lista.

Esempi:
Input: lst = (10 10 10 20 10 10)
Output: 20

Input: lst = (30 10 30 30 30)
Output: 10

Una soluzione semplice è attraversare la lista. Per ogni elemento, controllare se è diverso dagli altri o meno. La complessità temporale di questa soluzione sarebbe O(n^2)
Una soluzione migliore è usare l'hashing. Contiamo le frequenze di tutti gli elementi. La tabella hash avrà due elementi. La soluzione è l'elemento con valore (o frequenza) uguale a 1. Questa soluzione opera in tempo O(n), ma richiede O(n) spazio extra.
Una soluzione più efficiente consiste nell'iniziare a controllare i primi tre elementi. Ci possono essere due casi:
1) Due elementi sono uguali, cioè uno è diverso a seconda delle condizioni definite. In questo caso, l'elemento diverso è tra i primi tre, quindi restituiamo l'elemento diverso.
2) Tutti e tre gli elementi sono uguali. In questo caso, l'elemento diverso si trova nell'array rimanente. Quindi attraversiamo l'array dal quarto elemento e controlliamo semplicemente se il valore dell'elemento corrente è diverso dal precedente o meno.

Vediamo di implementare quest'ultimo metodo con una funzione che restituisce l'indice dell'elemento diverso.

(define (find-unique lst)
(catch
  (let (len (length lst))
    ; se la lista ha meno di due elementi,
    ; allora restituisce nil
    (cond ((= len 0) nil)
          ((= len 1) nil)
          ; se la lista ha due elementi,
          ; allora possiamo restituire l'indice 0 o l'indice 1
          ((= len 2) 0) ; oppure 1
          (true ; se la lista ha più di due elementi
            (cond ((and (= (lst 0) (lst 1)) (!= (lst 0) (lst 2))) throw 2)
                  ((and (= (lst 0) (lst 2)) (!= (lst 0) (lst 1))) throw 1)
                  ((and (= (lst 1) (lst 2)) (!= (lst 0) (lst 1))) throw 0)
                  (true
                    (for (i 3 (- len 1))
                      (if (!= (lst i) (lst (- i 1)))
                          (throw i)
                      )
                    )
                  )
            )
          )
    ))))

(find-unique '())
;-> nil
(find-unique '(1))
;-> nil
(find-unique '(3 1 1 1 1 1 1 1))
;-> 0
(find-unique '(1 3 1 1 1 1 1 1))
;-> 1
(find-unique '(1 1 3 1 1 1 1 1))
;-> 2
(find-unique '(1 1 1 1 1 1 3 1))
;-> 6


-----
1 o 2
-----

Scrivere una funzione che restituisce 1 quando viene passato 2 e restituisce 2 quando viene passato 1.

(define (f12a x)
  (if (= x 1) 2 1))

(f12a 1)
;-> 2
(f12a 2)
;-> 1

Scrivere la stessa funzione senza utilizzare la primitiva "if" o "cond".

(define (f12b x)
  (- 3 x))

(f12b 1)
;-> 2
(f12b 2)
;-> 1

Scrivere la stessa funzione senza utilizzare le operazioni aritmetiche elementari "+", "-", "*", "/".

(define (f12c x)
  (^ x 1 2))

(f12c 1)
;-> 2
(f12c 2)
;-> 1

Vediamo quale delle tre funzioni è la più veloce:

(time (f12a 2) 1e7)
;-> 685.196
(time (f12b 2) 1e7)
;-> 567.46
(time (f12c 2) 1e7)
;-> 610.196


-------------------------------------------------
Generare tutte le coppie di elementi di una lista
-------------------------------------------------

Scrivere una funzione per generare tutte le coppie diverse degli elementi di una lista.
Per esempio, la lista (a b c) genera la lista di coppie ((a b) (a c) (b c)).
Nota: le coppie (a b) e (b a) sono uguali.

La funzione è abbastanza semplice:

(define (pair-bind lst)
  (let (out '())
    (for (i 0 (- (length lst) 2))
      (for (j (+ i 1) (- (length lst) 1))
        (push (list (lst i) (lst j)) out -1)
      )
    )
    out))

(setq lst '(1 2 3 4 5))
(pair-bind lst)
;-> ((1 2) (1 3) (1 4) (1 5) (2 3) (2 4) (2 5) (3 4) (3 5) (4 5))

Adesso possiamo usare questo risultato per calcolare, ad esempio, le somme delle coppie di elementi:

(map (fn(x) (+ (first x) (last x))) (pair-bind lst))
;-> (3 4 5 6 5 6 7 7 8 9)

Oppure possiamo scrivere una funzione simile a "pair-bind" per calcolare la somma delle coppie di elementi:

(define (pair-sum lst)
  (let (out '())
    (for (i 0 (- (length lst) 2))
      (for (j (+ i 1) (- (length lst) 1))
        (push (+ (lst i) (lst j)) out -1)
      )
    )
    out))

(pair-sum lst)
;-> (3 4 5 6 5 6 7 7 8 9)

Notiamo che le due funzioni "pair-bind" e "pair-sum" sono uguali tranne la funzione che viene applicata ad ogni coppia di elementi, allora possiamo scrivere una funzione generica che prende come parametro la funzione da applicare (list, +, -, *, ecc.):

(define (pair-func f lst)
  (let (out '())
    (for (i 0 (- (length lst) 2))
      (for (j (+ i 1) (- (length lst) 1))
        (push (f (lst i) (lst j)) out -1)
      )
    )
    out))

Vediamo di simulare la funzione "pair-bind":

(pair-func list lst)
;-> ((1 2) (1 3) (1 4) (1 5) (2 3) (2 4) (2 5) (3 4) (3 5) (4 5))

Adesso la funzione "pair-sum":

(pair-func + lst)
;-> (3 4 5 6 5 6 7 7 8 9)

Calcoliamo la potenza di ogni coppia:

(pair-func pow lst)
;-> (1 1 1 1 8 16 32 81 243 1024)

Adesso un problema inverso, data una lista i cui elementi sono le coppie di elementi di un'altra lista, determinare la lista originale.
Per esempio, data la lista ((1 2) (1 3) (1 4) (1 5) (2 3) (2 4) (2 5) (3 4) (3 5) (4 5)), allora la lista originale vale (1 2 3 4 5).

(setq lst '((1 2) (1 3) (1 4) (1 5) (2 3) (2 4) (2 5) (3 4) (3 5) (4 5)))

(define (pair-inverse lst)
  (local (palo out)
    ; il primo valore è il palo (sentinella)
    (setq palo (lst 0 0))
    ; inserisce il primo valore
    (setq out (list palo))
    (dolist (el lst)
      ; se il valore è diverso,
      ; allora lo inserisce nella lista e
      ; aggiorna il valore del palo
      (if (!= (el 0) palo)
          (begin
          (setq palo (el 0))
          (push palo out -1))
      )
    )
    ; inserisce l'ultimo valore
    (push (lst -1 1) out -1)
  out))

(pair-inverse lst)
;-> (1 2 3 4 5)

Adesso un problema più complesso, data una lista i cui elementi sono la somma dele coppie di elementi di un'altra lista, determinare la lista originale.
Per esempio, data la lista (3 4 5 6 5 6 7 7 8 9), allora la lista originale vale (1 2 3 4 5).

In generale, la lista delle somme delle coppie della lista lst[0..n-1] vale (lst[0]+lst[1], lst[0]+lst[2], ..., lst[1]+lst[2], lst[1]+lst[3], ..., lst[2]+lst[3], lst[2]+lst[4], ..., lst[n-2]+lst[n-1]).

Supponiamo che la lista data sia "pair" e che ci siano n elementi nella lista originale. Se diamo un'occhiata ad alcuni esempi, possiamo osservare che lst[0] è la metà di pair[0] + pair[1] – pair[n-1]. Nota che il valore di pair[0] + pair[1] – pair[n-1] è (lst[0] + lst[1]) + (lst[0] + lst[2]) – (lst[1] + lst[2]). Una volta valutato lst[0], possiamo valutare altri elementi sottraendo lst[0]. Ad esempio lst[1] può essere valutato sottraendo lst[0] da pair[0], lst[2] può essere valutato sottraendo lst[0] da pair[1].
Possiamo ricavare la lunghezza della lista originale notando che è legata all'equazione dei numeri triangolari:

  (length pair) = (Triangular((length lst) - 1))
  Triangular(n) = n*(n-1)/2

dove:

  n = (length lst) - 1

quindi possiamo scrivere:

  (length (pair) = n*(n-1)/2 ==> 2*(length pair) = n*n - n

e ricavare n, cioè (length lst) - 1, risolvendo l'equazione di secondo grado:

(length lst) = (+ 1 (sqrt(1 + (8 * (length pair)))))/2

Adesso possiamo scrivere la funzione:

(define (pair-sum-inverse pair)
  (local (base len out)
    (setq out '())
    ; lunghezza della lista originale
    (setq len (/ (+ 1 (sqrt (+ 1 (* 8 (length pair))))) 2))
    ; valore base
    (setq base (/ (+ (pair 0) (pair 1) (- (pair (- len 1)))) 2))
    (push base out -1)
    (for (i 1 (- len 1))
      (push (- (pair (- i 1)) base) out -1)
    )
    out))

(pair-sum-inverse (pair-sum '(1 2 3 4 5)))
;-> (1 2 3 4 5)
(pair-sum-inverse (pair-sum '(1 2 3 4 5 6 7 8 9)))
;-> (1 2 3 4 5 6 7 8 9)
(pair-sum-inverse (pair-sum '(2 2 1 1 3 3 4 4 5)))
;-> (2 2 1 1 3 3 4 4 5)
(pair-sum-inverse (pair-sum '(2 1 2)))
;-> (2 1 2)


---------------------------------
Numero di partite nel Tic-Tac-Toe
---------------------------------

Quante partite diverse di Tic-Tac-Toe sono possibili?

http://www.se16.info/hgb/tictactoe.htm

Abbiamo 9 modi possibili per posizionare il primo segno, 8 modi per posizionare il secondo, 7 modi il terzo, ... e 1 per il nono. Quindi risulta 9*8*7*6*5*4*3*2*1 = 9! = 362880.

Ma nelle 362880 partite esistono anche quelle che dovrebbero essere terminate prima a causa della vittoria di uno dei due giocatori. Quindi le sole partite valide (cioè le partite che devono essere considerate terminate) sono quelle che terminano appena qualcuno ottiene tre simboli uguali in fila oppure quelle partite che hanno tutti le caselle riempite e senza nessun tris. Da notare che la partita di lunghezza minima ha 5 caselle occupate.
Possiamo trovare il numero totale di partite calcolando quante partite finiscono con cinque caselle, sei caselle, sette caselle, otto caselle e nove casella e poi sommando il tutto.

Nel caso di nove caselle ci sono due possibilità: o qualcuno ha vinto alla nona mossa, o è un pareggio senza tre di fila.

Supponiamo che il primo giocatore inizi con una X e il secondo usi una O.

Numero di partite che terminano alla quinta mossa
ci sono 8 linee di tre quadrati (tre verticali, tre orizzontali e due diagonali) e non importa in quale ordine sono state messe le tre X, e le due O potrebbero essere andate in due delle altre sei quadrati in qualsiasi ordine. Quindi abbiamo 8*3!*6*5 = 1440 partite che finiscono con una vittoria alla quinta mossa.

Numero di partite che terminano alla sesta mossa
ci sono ancora 8 righe di tre quadrati, e non importa in quale ordine sono state disposte le tre O, e le tre X avrebbero potuto essere inserite in tre degli altri sei quadrati in qualsiasi ordine (a condizione che le X siano non tre di fila). Ignorando la frase tra parentesi, questo ci dà 8*3!*6*5*4 = 5760 possibilità. Per tener conto della parentesi dobbiamo escludere i casi in cui ci sono tre O di fila e tre X di fila: nessuna di esse può essere una diagonale, e se si prende una riga particolare, ci sono solo altre due righe possibili , quindi dobbiamo escludere 6*3!*2*3! = 432 casi. Quindi stiamo guardando 5760-432 = 5328 partite che finiscono con una vittoria alla sesta mossa.

Numero di partite che terminano alla settima mossa
ci sono ancora 8 linee di tre quadrati, ma questa volta importa in quale ordine sono state poste le quattro X, poiché la quarta deve essere sulla linea, mentre le tre O potrebbero essere andate in tre delle altre cinque quadrati in qualsiasi ordine (a condizione che le O non siano tre di fila). Ignorando la frase tra parentesi, questo ci dà 8*3*6*3!*5*4*3 = 51840 possibilità. Per tener conto della parentesi dobbiamo escludere i casi in cui ci sono tre O di fila e tre X di fila: nessuna di esse può essere una diagonale, e se una determinata riga viene presa con X, ci sono solo altre due possibili righe di cui una ha una X, quindi dobbiamo escludere 6*3*6*3!*3! = 3888 casi. Quindi abbiamo 51840-3888 = 47952 partite che finiscono con una vittoria alla settima mossa.

Numero di partite che terminano all'ottava mossa
ci sono di nuovo 8 linee di tre quadrati, ma anche in questo caso non importa in quale ordine sono state disposte le quattro O, poiché la quarta deve essere sulla linea, mentre le quattro X potrebbero essere andate in quattro delle altre cinque quadrati in qualsiasi ordine (a condizione che le X non siano tre di fila). Ignorando la frase tra parentesi, questo ci dà 8*3*6*3!*5*4*3*2 = 103680 possibilità. Per tener conto della condizione tra parentesi, dobbiamo escludere i casi in cui ci sono tre O di fila e tre X di fila: nessuna di esse può essere una diagonale, e se una determinata riga viene presa con O, ci sono solo altre due possibili righe di cui una ha una O e due posti rimanenti per una X, quindi dobbiamo escludere 6*3*6*3!*2*4! = 31104 casi. Quindi sono 103680-31104 = 72576 partite che finiscono con una vittoria all'ottava mossa.

Numero di partite che terminano alla nona mossa
Questo potrebbe essere facilmente calcolato sottraendo le possibilità già coperte da 9!. Ma lo terremo da parte per un controllo finale e useremo la forza bruta. La partita potrebbe concludersi con una vittoria o un pareggio, e li calcoleremo entrambi.

Per vincere, ci sono molte di possibilità:
non solo dobbiamo assicurarci che non ci siano tre O in fila prima che la quinta X sia posizionata, ma anche che non ci sia già una linea distinta di tre X in fila. Per prima cosa consideriamo una vittoria che coinvolge solo una diagonale: ce ne sono due e la quinta X deve essere sulla diagonale. Questo significa che le altre due X possono trovarsi solo in 8 delle restanti 15 possibili coppie di quadrati fuori dalla diagonale: questo porta a 2*3*8*4!*4! = 27648 possibilità. In secondo luogo consideriamo una vincita che coinvolge solo un tre di fila verticale o orizzontale: le altre due X possono essere in 10 delle restanti 15 possibili coppie di quadrati fuori dalla fila per evitare altri tre X di fila, solo 4 su 10 evitano tre O di fila, ancora la quinta X deve trovarsi nella riga desiderata, questo porta a 6*3*4*4!*4! = 41472 possibilità. Terzo,bisogna considerare la possibilità che la quinta X completi due distinti tre di fila dove si intersecano: ci sono 22 possibili coppie di tre intersecanti di fila, la quinta X deve essere l'intersezione, questo porta a 22*1*4!*4! = 12672 possibilità. Quindi stiamo guardando 27648+41472+12672 = 81792 possibilità di partite che terminano con una vittoria alla nona mossa.

Per un pareggio:
ci sono un totale di 16 possibili modelli per le cinque X e quattro O che non hanno tre simboli in fila (ci sono tre modelli di base che aumentano a 8+4+4 con riflessioni e rotazioni). Quindi abbiamo 16*5!*4! = 46080 possibilità di partite che finiscono in parità alla nona mossa.

Quindi in totale abbiamo 81792+46080 = 127872 partite che durano fino alla nona mossa.

Controllo sul calcolo
Avremmo potuto calcolare la possibilità della nona mossa come 9! -4!*(quinta mossa vince) -3!*(sesta mossa vince) -2!*(settima mossa vince) -1!*(otto mossa vince) = 362880-24*1440-6*5328-2*47952 -1*72576 = 127872. Questo è lo stesso risultato di prima, quindi nonostante la possibilità di errori di compensazione, possiamo avere una certa fiducia nel risultato.

Quanti giochi di Tic-Tac-Toe (zero e croci) sono possibili?
Sommando tutte queste cifre si ottiene il risultato desiderato: 1440+5328+47952+72576+81792+46080 = 255168 possibili partite in totale .

Questa tabella riporta i risultati:

  Mosse            Partite         %
--------------------------------------
  Vittoria in 5     1440          0,6%
  Vittoria in 6     5328          2,1%
  Vittoria in 7    47952         18,8%
  Vittoria in 8    72576         28,4%
  Vittoria in 9    81792         32,1%
  Pareggio         46080         18,1%
--------------------------------------
  Totale           255168       100.0%

Comunque se entrambi i giocatori giocano in modo perfetto, allora le partite terminano sempre in pareggio.

Vediamo di implementare una simulazione.
Generiamo tutte le permutazioni delle 9 mosse.
Per ogni permutazione giochiamo la partita e vediamo come finisce, ad esempio, la permutazione/partita (2 7 6 5 1 4 9 3 8) si gioca nel modo seguente:
X occupa la casella 2
fine partita? (-1 X -1 -1 -1 -1 -1 -1 -1)
O occupa la casella 7
fine partita? (-1 X -1 -1 -1 -1 O -1 -1)
X occupa la casella 6
fine partita? (-1 X -1 -1 -1 X O -1 -1)
O occupa la casella 5
fine partita? (-1 X -1 -1 O X O -1 -1)
...
Per ogni partita memorizziamo il risultato e mettiamo la posizione finale in una lista.

Scriviamo alcune funzioni.

Generate tutte le permutazioni senza ripetizioni:

(define (perm lst)
  (local (i indici out)
    (setq indici (dup 0 (length lst)))
    (setq i 0)
    (setq out (list lst))
    (while (< i (length lst))
      (if (< (indici i) i)
          (begin
            (if (zero? (% i 2))
              (swap (lst 0) (lst i))
              (swap (lst (indici i)) (lst i))
            )
            (push lst out -1)
            (++ (indici i))
            (setq i 0)
          )
          (begin
            (setf (indici i) 0)
            (++ i)
          )
       )
    )
    out))

(length (perm '(1 2 3 4 5 6 7 8 9)))
;-> 362880

(silent (setq all-game (perm '(1 2 3 4 5 6 7 8 9))))
(all-game 21)
;-> (4 2 3 1 5 6 7 8 9)

Funzione che controlla se e come è terminata una partita:

(define (game-over? pos)
          ; controllo righe
    (cond ((or (and (!= (pos 0) -1) (= (pos 0) (pos 1) (pos 2)))
               (and (!= (pos 3) -1) (= (pos 3) (pos 4) (pos 5)))
               (and (!= (pos 6) -1) (= (pos 6) (pos 7) (pos 8))))
           '1)
          ; controllo colonne
          ((or (and (!= (pos 0) -1) (= (pos 0) (pos 3) (pos 6)))
               (and (!= (pos 1) -1) (= (pos 1) (pos 4) (pos 7)))
               (and (!= (pos 2) -1) (= (pos 2) (pos 5) (pos 8))))
           '1)
          ; controllo diagonali
          ((or (and (!= (pos 0) -1) (= (pos 0) (pos 4) (pos 8)))
               (and (!= (pos 2) -1) (= (pos 2) (pos 4) (pos 6))))
           '1)
          ; controllo caselle tutte occupate (partita terminata patta)
          ((zero? (first (count '(-1) pos)))
           '0)
          ; partita non finita
          (true '2)))

(setq pos '(1 0 1
            0 0 1
            0 1 -1))
(game-over? pos)
;-> 2
(setq pos '(1 0 1
            0 0 1
            0 1 0))
(game-over? pos)
;-> 0
(setq pos '(1 1 1
            0 -1 -1
            0 -1 -1))
(game-over? pos)
;-> 1
(setq pos '(0 1 1
            0 1 -1
            0 -1 1))
(game-over? pos)
;-> 1
(setq pos '(0 1 1
            1 1 -1
            0 -1 1))
(game-over? pos)
;-> 2
(setq pos '(-1 1 1
            1 -1 -1
            0 -1 -1))
(game-over? pos)
;-> 2

Funzione che gioca una posizione (per esempio (8 7 2 3 5 4 1 9 6)):

(define (play pos)
  (local (cur res stop)
    (setq cur (dup -1 9))
    (for (i 0 3)
      (if (even? i)
          (setf (cur (- (pos i) 1)) '1)
          (setf (cur (- (pos i) 1)) '0)
      )
    )
    ;(println "partita iniziale: ")
    ;(print-board cur)
    ;(read-line)
    (for (i 4 8 1 stop)
      (if (even? i)
          (setf (cur (- (pos i) 1)) '1)
          (setf (cur (- (pos i) 1)) '0)
      )
      ; res -> (1=win 0=draw 2=play)
      (setq res (game-over? cur))
      ;(println "partita attuale: ")
      ;(print-board cur)
      ;(println "risultato: " res)
      ;(read-line)
      (cond ((or (= res 1) (= res 0))
             (setq stop true)
             (if (= res 1) (push cur out -1))
             (++ (freq res)))
            ((= res 2) nil)
            (true (println "error:" res))
      ))))

Funzione che stampa una posizione:

(define (print-board pos)
  (println (format "%2d %2d %2d" (pos 0) (pos 1) (pos 2)))
  (println (format "%2d %2d %2d" (pos 3) (pos 4) (pos 5)))
  (println (format "%2d %2d %2d" (pos 6) (pos 7) (pos 8))))

(print-board pos)
;->  1  1  1
;->  0 -1 -1
;->  0 -1 -1

Nota: per provare la funzione play occorre definire: (setq freq '(0 0))

Funzione che gestisce tutta la simulazione:

(define (num-ttt)
  (local (freq out)
    (setq out '())
    (setq freq '(0 0))
    (setq all-game (perm '(1 2 3 4 5 6 7 8 9)))
    (dolist (game all-game)
      (play game)
    )
    (println freq)
    out))

(silent (setq allwin (num-ttt)))
;-> (46080 316800)

(allwin 1)
;-> (0 1 1 0 1 0 1 -1 -1)

(print-board (allwin 1))
;->  0  1  1
;->  0  1  0
;->  1 -1 -1

(game-over? (allwin 1))
;-> 1

(length allwin)
;-> 316800

Adesso contiamo le vittorie in base al numero delle mosse (5,6,7,8 o 9):

(define (contawin lst)
  (local (fwin num)
    (setq fwin '(0 0 0 0 0 0 0 0 0 0))
    (dolist (el lst)
      ; conta quanti -1 esistono nella posizione
      ; e poi aggiorna la lista delle frequenza
      (setq num (- 9 (first (count '(-1) el))))
      (++ (fwin num))
    )
    fwin))

(contawin allwin)
;-> (0 0 0 0 0 34560 31968 95904 72576 81792)

Questo significa che tra tutte le partite vinte:

34560 partite terminano in 5 mosse
31968 partite terminano in 6 mosse
95904 partite terminano in 7 mosse
72576 partite terminano in 8 mosse
81792 partite terminano in 9 mosse

Ricordiamo dal Controllo del calcolo precedente che risulta:

(* 24 1440)
;-> 34560
(* 6 5328)
;-> 31968
(* 2 47952)
;-> 95904
(* 1 72576)
;-> 72576
(* 1 81792)
;-> 81792

Numero di partite patte:

(- 362880 (+ 34560 31968 95904 72576 81792))
;-> 46080

Nota: una posizione finale può derivare da molte partite diverse.

Quindi le posizioni della lista allwin contengono anche molte posizioni doppie. Vediamo di calcolare solo le posizioni finali univoche:

(setq allvalidwin (unique allwin))

(length allvalidwin)
;-> 942

Adesso contiamo le vittorie delle posizioni finali uniche in base al numero delle mosse (5,6,7,8 o 9):

(contawin allvalidwin)
;-> (0 0 0 0 0 120 148 444 168 62)

Questo significa che ci sono:

120 posizioni finali univoche di vittoria in 5 mosse
148 posizioni finali univoche di vittoria in 6 mosse
444 posizioni finali univoche di vittoria in 7 mosse
168 posizioni finali univoche di vittoria in 8 mosse
 62 posizioni finali univoche di vittoria in 9 mosse


---------------------------
Estrazione dati da file PDF
---------------------------

Questo esempio è tratto da un problema reale. Dato un file PDF con la struttura simile a quella del file "db.pdf" (disponibile nella cartella "data") occorre estrarre tutti i numeri ISBN che si trovano nel file.
Per convertire il file PDF in un file TXT ho utilizzato il software open-source "Xpdf" tools (https://www.xpdfreader.com/).

(define (find-isbn str)
  (setq out '())
  (setq lst (parse (replace "[^0-9]+" str " " 0)))
  (dolist (el lst)
    (if (> (length (int el 0 10)) 12)
      (push (int el 0 10) out -1)))
  out)

(define (isbn)
  ; extract text from pdf with xpdf tools
  ;(! "pdftotext.exe db.pdf" 0)
  (! "pdftotext.exe -table db.pdf" 0)
  (setq db (open "db.txt" "read"))
  ; search numbers with more than 12 digits
  (while (read-line db)
        (setq res (find-isbn (current-line)))
        ; print number
        (if res (println res))
  )
  (close db))

(real-path)
;-> "F:\\Lisp-Scheme\\newLisp\\MAX"
(change-dir "f:\\temp\\xpdf-tools-win-4.03\\bin64")
;-> true

(isbn)
;-> (9788835049371)
;-> (9788869105210)
;-> (9788826819907)
;-> (9788826819921)
;-> (9788848263948)
;-> (9788808520746)
;-> (9788808232953)
;-> (9788883394508)
;-> (9781108440387)
;-> (9781108465953)
;-> (9780194527897)
;-> (9788842115960)
;-> (9788808237347)
;-> (9788808172082)
;-> (9788857791302)
;-> true


--------------
Media continua
--------------

Per calcolare la media aritmetica di una lista di numeri possiamo usare la seguente funzione:

(define (media lst)
  (div (apply add lst) (length lst)))

Ma per calcolare la media di una lista di numeri che aumenta di dimensione possiamo utilizzare la seguente funzione:

(define (media-continua media val items)
  (div (add val (mul media items)) (+ items 1)))

(media '(1 2 3))
;-> 2

(media-continua 1 2 1)
;-> 1.5

(media-continua 1.5 3 2)
;-> 2

In questo modo possiamo calcolare la nuova media anche senza modificare la lista. Inoltre la funzione potrebbe essere usata come un generatore.


---------------------
Sequenza di Kolakoski
---------------------

Kolakoski sequence: a(n) is length of n-th run, a(1) = 1, sequence consists just of 1's and 2's.
In other words, is an infinite sequence of symbols {1,2} that is the sequence of run lengths in its own run-length encoding.

Sequenza OEIS A000002: 1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, 1, 1, 2, 1, 1,
                       2, 2, 1, 2, 1, 1, 2, 1, 2, 2, 1, 1, 2, 1, 1, 2, 1,
                       2, 2, 1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 1, 1, 2, ...

La sequenza è stata discussa per primo da da Rufus Oldenburger nel 1939 e poi da Kolakoski nel 1965.

La successione di Kolakoski è una successione infinita di numeri naturali, (escluso lo zero) con la proprietà:

  se si forma una nuova sequenza dai conteggi delle ripetizioni dello stesso numero nella prima sequenza, questa nuova sequenza è uguale alla prima sequenza.

  if you form a new sequence from the counts of runs of the same number in the first sequence, this new sequence is the same as the first sequence

Esempio:

Questa non è una sequenza di Kolakoski:

1,1,2,2,2,1,2,2,1,2,...

La sua sequenza di conteggi delle ripetizioni, (simile alla codifica Run Length Encoding (RLE), ma una vera RLE fornisce anche il carattere codificato una sola volta), viene calcolata in questo modo:

Partendo dal numero più a sinistra della sequenza abbiamo 2 unità, seguite da 3 due, quindi 1 unità, 2 due, 1 uno, ...

Quanto sopra fornisce il RLE di:

2, 3, 1, 2, 1, ...

La sequenza originale è diversa dal suo RLE in questo caso. Sarebbe la stessa per una vera sequenza di Kolakoski.

Creazione di una sequenza di Kolakoski

Cominciamo con i due numeri (1, 2) che andremo a scorrere, cioè verranno utilizzati in questo ordine:

1,2,1,2,1,2,....

Iniziamo la sequenza s con il primo elemento del ciclo c:

1

Un indice, k, nella sequenza, (in espansione), passerà, o indicizzerà, attraverso ogni elemento della sequenza s dal primo, al proprio ritmo.

Faremo in modo che il k-esimo elemento di s indichi quante volte l'ultimo elemento di s dovrebbe apparire alla fine di s.

Abbiamo iniziato s con 1 e quindi s[k] afferma che dovrebbe apparire solo 1 volta.

Incremento k

Prendi l'elemento successivo da c e aggiungilo alla fine della sequenza s. s diventerà quindi:

1, 2

k è stato spostato al secondo elemento dell'elenco e s[k] afferma che dovrebbe apparire due volte, quindi aggiungi un altro dell'ultimo elemento alla sequenza s:

1, 2, 2

Incremento k

Aggiungi l'elemento successivo del ciclo all'elenco:

1, 2, 2, 1

k è ora al terzo elemento nell'elenco che indica che l'ultimo elemento dovrebbe apparire due volte, quindi aggiungi un'altra copia dell'ultimo elemento alla sequenza s:

1, 2, 2, 1, 1

incremento k

...

Nota che l'RLE di 1, 2, 2, 1, 1, ... inizia 1, 2, 2 che è l'inizio della sequenza originale. L'algoritmo di generazione garantisce che sarà sempre così.

Compito (rosetta-code):

Creare una funzione che, data una lista ordinata iniziale, ecc. dei numeri naturali (1, 2), restituisca il numero successivo dalla lista quando si accede in un ciclo.

Creare un'altra funzione che, data la lista ordinata iniziale (1, 2) e la lunghezza minima della sequenza da generare, usa la prima routine e l'algoritmo sopra, per generare almeno i primi membri richiesti della sequenza kolakoski.

Creare una funzione che, quando viene data una sequenza, crei la codifica della lunghezza di esecuzione di quella sequenza (come definita sopra) e restituisca il risultato del controllo se la sequenza inizia con i membri esatti del suo RLE. (Ma nota, a causa del campionamento, non confrontare l'ultimo membro del RLE).

Mostrare i primi 20 membri della sequenza generata da (1, 2).
Controllare la sequenza contro il suo RLE.

Mostrare i primi 20 membri della sequenza generata da (2, 1).
Controllare la sequenza contro il suo RLE.

Mostrare i primi 30 membri della sequenza Kolakoski generata da (1, 3, 1, 2)
Controlla la sequenza contro il suo RLE.

Mostrare i primi 30 membri della sequenza Kolakoski generata da (1, 3, 2, 1)
Controlla la sequenza contro il suo RLE.

(Ci sono regole sulla generazione di sequenze di Kolakoski da questo metodo che sono infrante dall'ultimo esempio).

Soluzione:

(define (next-in-cycle c idx)
  (c (% idx (length c))))

(define (kolakoski c len)
(catch
  (local (i j k clen slen)
    (setq i 0 j 0 k 0)
    (setq clen (length c))
    ;(setq slen (length s))
    (setq slen len)
    (while true
      (setf (s i) (next-in-cycle c k))
      (if (> (s k) 1)
          (for (j 1 (- (s k) 1))
            (++ i)
            ;(if (= i slen) (throw nil))
            (if (= i slen) (throw s))
            (setq (s i) (s (- i 1)))
          )
      )
      (++ i)
      ;(if (= i slen) (throw nil))
      (if (= i slen) (throw s))
      (++ k)
    ))))

(setq s (array 20 '(0)))
(kolakoski '(1 2) 20)
;-> (1 2 2 1 1 2 1 2 2 1 2 2 1 1 2 1 1 2 2 1)

(define (possible-kolakoski s)
  (local (i j prev cnt len rle res)
    (setq j 0 prev (s 0) cnt 1 len (length s))
    (setq rle '())
    (setq res true)
    (for (i 1 (- len 1))
      (if (= (s i) prev)
          (++ cnt)
          (begin
            (push cnt rle -1)
            (setq cnt 1)
            (setq prev (s i))
          )
      )
    )
    ;(println rle)
    ; non aggiunge il valore finale di 'cnt' a rle perché non viene mai confrontato
    ;(for (i 0 (- j 1) 1 (not res))
    (for (i 0 (- (length rle) 1) 1 (not res))
      (if (!= (rle i) (s i))
          (setq res nil)
      )
    )
    (println s)
    res))

(possible-kolakoski (kolakoski '(1 2) 20))
;-> (1 2 2 1 1 2 1 2 2 1 2 2 1 1 2 1 1 2 2 1)
;-> true

(possible-kolakoski (kolakoski '(2 1) 20))
;-> (2 2 1 1 2 1 2 2 1 2 2 1 1 2 1 1 2 2 1 2)
;-> true

(possible-kolakoski (kolakoski '(1 3 1 2) 20))
;-> (1 3 3 3 1 1 1 2 2 2 1 3 1 2 2 1 1 3 3 1)
;-> true

(possible-kolakoski (kolakoski '(1 3 2 1) 20))
;-> (1 3 3 3 2 2 2 1 1 1 1 1 3 3 2 2 1 1 3 2)
;-> nil

Funzione per calcolare la sequenza di kolakoski di lunghezza generica:

(define (kolakoski-seq start-lst len)
  (let (s (array len '(0)))
    (println (kolakoski start-lst len))
    ;(println (possible-kolakoski s))
  ))

(kolakoski-seq '(1 2) 20)
;-> (1 2 2 1 1 2 1 2 2 1 2 2 1 1 2 1 1 2 2 1)
(kolakoski-seq '(1 2) 30)
;-> (1 2 2 1 1 2 1 2 2 1 2 2 1 1 2 1 1 2 2 1 2 1 1 2 1 2 2 1 1 2)
(possible-kolakoski (kolakoski-seq '(1 3 1 2) 30))
;-> (1 3 3 3 1 1 1 2 2 2 1 3 1 2 2 1 1 3 3 1 2 2 2 1 3 3 1 1 2 1)
;-> true


----------------------------------------
Da stringa generica a stringa palindroma
----------------------------------------

Verificare se i caratteri di una data stringa possono essere riposizionati per formare una stringa palindroma.

Un insieme di caratteri può formare una stringa palindroma se, al massimo, un carattere si verifica un numero dispari di volte e tutti gli altri caratteri si verificano un numero pari di volte.

Il carattere dispari, se esiste, è quello che compare al centro della stringa palindroma.

Un metodo semplice è eseguire due cicli, il ciclo esterno seleziona tutti i caratteri uno per uno, il ciclo interno conta il numero di occorrenze del carattere selezionato tenendo traccia dei conteggi dispari. La complessità temporale di questa soluzione è O(n^2).
Possiamo farlo in tempo O(n) usando una lista di frequenze:

1) Creare una lista di frequenze di dimensioni alfabetiche (per i caratteri ASCII vale 256). Inizializzare tutti i valori della lista a 0.
2) Attraversare la stringa data e incrementare il conteggio di ogni carattere nella lista delle frequenze.
3) Attraversare la lista delle frequenze e se incontriamo più di un valore dispari, restituire nil. In caso contrario, restituire true.

(define (can-palindrome? str)
  (local (freq oddies)
    (setq freq (array 256 '(0)))
    (dostring (ch str)
      (++ (freq ch))
    )
    (setq oddies 0)
    (dolist (el freq)
      (if (odd? el) (++ oddies))
    )
    (< oddies 2)))

(can-palindrome? "pippo")
;-> nil
(can-palindrome? "mama")
;-> true
(can-palindrome? "presaelaserpe")
;-> true

Adesso vogliamo elencare tutte le stringhe palindrome che possono essere create quando il risultato vale true.

(define (make-palindrome? str)
  (local (freq oddies lst oddch oddnum)
    ; carattere dispari
    (setq oddch "")
    ; numero occorrenze carattere dispari
    (setq oddnum -1)
    ; lista dei caratteri pari
    (setq lst '())
    ; lista delle frequenze dei caratteri
    (setq freq (array 256 '(0)))
    ; calcola la frequenza dei caratteri di str
    (dostring (ch str)
      (++ (freq ch))
    )
    (setq oddies 0)
    ; verifica quanti caratteri dispari esistono,
    ; memorizza il carattere dispari e il numero di occorrenze
    ; crea la lista dei caratteri pari
    (dolist (el freq)
      (if (odd? el) (begin
          (++ oddies)
          (setq oddch (char $idx))
          (setq oddnum el))
          ;else
          (if (!= el 0)
            (for (i 1 el)
              (push (char $idx) lst -1)
            )
          )
      )
    )
    ; se i caratteri dispari sdono maggiori di 1
    ; allora restituisce nil
    (cond ((> oddies 1) nil)
          ; altrimenti calcola le stringhe palindrome
          (true (make-pali lst oddch oddnum)))))

La funzione "make-palindrome?" restituisce nil o chiama la funzione "make-pali" con i seguenti parametri:
  1) lista dei caratteri pari - lst
  2) carattere dispari - oddch
  3) occorrenze del carattere dispari - oddnum

Per calcolare le stringhe palindrome utilizziamo la funzione "anagrams" che calcola tutti gli anagrammi di una data stringa. Il metodo è il seguente:
prima di tutto la funzione "make-pali" aggiorna la lista dei caratteri pari con (oddnum -1) ripetizioni del carattere dispari, poi prendiamo solo i caratteri univoci. Ad esempio la stringa "pippoio" genera:

  lst = ("i" "i" "o" "o")
  oddch = "p"
  oddnum = 3

Quindi la lista lst viene aggiornata con (oddnum - 1) = 2 caratteri oddch = "p":

  lst = ("i" "i" "o" "o" "p" "p")

I caratteri univoci di lst sono: ("i" "o" "p").

Adesso le stringhe palindrome sono formate da un anagramma dei caratteri ("i" "o" "p") + il carattere oddch = "p" + l'inverso dell'anagramma iniziale, ad esempio il primo caso vale:

  "iop" + "p" + (reverse "iop") = "iop" + "p" + "poi" = "iopppoi"

Prima scriviamo la funzione per gli anagrammi:

(define (anagrams str)
  (map (fn (perm) (select str perm))
       (permute-aux (sequence 0 (- (length str) 1)))))
; auxiliary permutation function
(define (permute-aux lst)
  (if (= (length lst) 1)
   lst
   (apply append (map (fn (rot)
                      (map (fn (perm) (cons (first rot) perm))
                           (permute-aux (rest rot))))
                      (rotate-aux lst)))))
; auxiliary rotation function
(define (rotate-aux lst)
  (map (fn (x) (rotate lst)) (sequence 1 (length lst))))

Poi scriviamo la funzione "make-pali":

(define (make-pali lst oddch oddnum)
  (local (all-ana out)
  ;(println lst { } oddch { } oddnum)
  (setq out '())
  ; aggiunge (oddnum-1) caratteri oddch alla lista dei caratteri
  (if (> oddnum 2)
    (for (i 1 (- oddnum 1))
      (push oddch lst -1)
    )
  )
  ; creazione di tutti gli anagrammi delle mezze parole palindrome
  (setq all-ana (anagrams (join (unique lst))))
  (dolist (ana all-ana)
    ; oddch = "" se non esiste il carattere dispari
    (push (string ana oddch (reverse ana)) out -1)
  )
  out))

(make-palindrome? "pippoio")
;-> ("poipiop" "piopoip" "oipppio" "opipipo" "ipopopi" "iopppoi")
(make-palindrome? "pippo")
;-> nil
(make-palindrome? "mama")
;-> ("maam" "amma")

(make-palindrome? "iomassimo")
;-> ("somiaimos" "soimamios" "smioaoims" "smoiaioms" "siomamois"
;->  "simoaomis" "omisasimo" "omsiaismo" "oismamsio" "oimsasmio"
;->  "osmiaimso" "osimamiso" "misoaosim" "miosasoim" "msoiaiosm"
;->  "msioaoism" "moisasiom" "mosiaisom" "isomamosi" "ismoaomsi"
;->  "iomsasmoi" "iosmamsoi" "imsoaosmi" "imosasomi")
"isomamosi"


------------------------------------
Frasi e semplici regole grammaticali
------------------------------------

Una frase semplice è sintatticamente corretta se soddisfa determinate regole regole grammaticali. Di seguito sono riportate le regole della grammatica per il questo problema:

1. La frase deve iniziare con un carattere maiuscolo
2. Quindi segue il carattere minuscolo.
3. Devono esserci spazi tra le parole.
4. Quindi la frase deve terminare con un punto "." dopo l'ultima parola.
5. Non sono ammessi due spazi continui.
6. Non sono consentiti due caratteri maiuscoli continui.
7. Tuttavia, la frase può terminare dopo un carattere maiuscolo (da solo).

Esempi:

Frasi corrette:
   "Mi chiamo Eva."
   "Il vertice è A."
   "Sono a casa."
   "Mi piace newlisp."

Frasi errate:
   "Mi chiamo MAX."
   "Amo il cinema"
   "Forza. Andiamo."
   "Tu sei mio  amico."
   "Amo i libri ."

Scrivere una funzione che verifica se una frase è corretta rispetto alle precedenti regole grammaticali

Il problema può essere risolto utilizzando un automa/diagramma degli stati che rappresenta le nostre regole..

Algoritmo:

1. Controllare i casi ad inizio e fine frase (stringa)
  1.a) Controllare se il primo carattere è maiuscolo o meno nella frase.
  1.b) Controllare se l'ultimo carattere è un punto o meno.

2. Per il resto della stringa possiamo seguire il diagramma di stato rappresentato di seguito:

         [A-Z]
    +-------------+
    |             |
    |             ■
  ╔═══╗  space  ╔═══╗
  ║ 1 ║■--------║ 0 ║
  ╚═══╝         ╚═══╝
    |  ■          |  \
    |   \ space   |   \
    |    \        |    \
    |     \       |     \ [A-Z]
    |      \      |      \
    |       \     |       \
    |        \    | [a-z]  \ (.)
    |         \   |         \
    |          \  ■          ■
    |  [a-z]    ╔═══╗   (.)   ╔═══╗
    +----------■║ 2 ║--------■║ 3 ║
                ╚═══╝         ╚═══╝
                |   ■
                |   |
                +---+
                [a-z]

       Diagramma degli stati

3. Dobbiamo mantenere lo stato precedente e quello attuale dei diversi caratteri nella stringa. Sulla base di ciò possiamo sempre convalidare la frase di ogni carattere attraversato.

Di seguito è riportata un'implementazione basata su C. (A proposito, anche questa frase è corretta secondo la regola e il codice)

(define (check-grammar str)
(catch
  (local (len prev curr idx)
    (setq len (length str))
    ; Controlla che la frase inizi correttamente
    ; Check that the first character lies in [A-Z]
    (if (or (< (str 0) "A") (> (str 0) "Z"))
        (throw nil))
    ; Controlla che la frase termini correttamente
    ; Check if the last character is a full stop (.)
    (if (!= (str -1) ".")
        (throw nil))
    ; Inizializzazione degli stati da memorizzare
    (setq prev 0)
    (setq curr 0)
    ; Indice della stringa
    (setq idx 1)
    (while (< idx len)
      ; Set states according to the input characters
      ; in the string and the rule defined in the description.
            ; If current character is [A-Z], set current state as 0.
      (cond ((and (>= (str idx) "A") (<= (str idx) "Z"))
             (setq curr 0))
            ; If current character is a space, set current state as 1.
            ((= (str idx) " ")
             (setq curr 1))
            ; If current character is [a-z], set current state as 2.
            ((and (>= (str idx) "a") (<= (str idx) "z"))
             (setq curr 2))
            ; If current character is a dot, set current state as 3.
            ((= (str idx) ".")
             (setq curr 3))
      )
      ;;(println (str idx)) (read-line)
      ;;(println prev { } curr)
      ; Validates all current state with previous state
      ; for the rules in the description of the problem.
      (if (and (= prev curr) (!= curr 2))
          (throw nil))
      ;;(println prev { } curr)
      ;;(println "1") (read-line)
      (if (and (= prev 2) (= curr 0))
          (throw nil))
      ;;(println prev { } curr)
      ;;(println "2") (read-line)
      (if (and (= curr 3) (!= prev 1))
          (throw (= (+ idx 1) len)))
      ;;(println prev { } curr)
      ;;(println "3") (read-line)
      ; indice prossimo carattere
      (++ idx)
      ; aggiorna valore degli stati
      (setq prev curr)
    )
    nil)))

Proviamo la funzione:

(check-grammar "Viva la pasta.")
;-> true
(check-grammar "Mi chiamo Eva.")
;-> true
(check-grammar "Mi chiamo Eva")
;-> nil
(check-grammar "Mi chiamo Eva..")
;-> nil
(check-grammar "Mi chiamo EVA.")
;-> nil
(check-grammar "Mi chiamo evA.")
;-> nil
(check-grammar "Mi chiamo A.")
;-> true
(check-grammar "Amo i libri .")
;-> nil
(check-grammar "Forza. Andiamo.")
;-> nil
(check-grammar "Tu sei mio  amico.")
;-> nil


---------------------
commonLISP in newLISP
---------------------

Nel blog di johu https://johu02.wordpress.com/ ci sono molte informazioni su newLISP. In particolare ci sono due librerie ("newlisp-utility.lsp" e "onnewlisp.lsp") che permettono di studiare il libro "On Lisp" di Paul Graham utilizzando newLISP. I post sono molto istruttivi e l'unico problema è che il blog è scritto in giapponese (ma con Google Translate si può tradurlo facilmente).
Riportiamo di seguito il codice delle due librerie.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; newlisp-utility.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 2008/12/23 second, third, fourth and labels are added.
;            with-open-file is improved.( setq _stream -> let )
; 2009/ 1/ 6 hayashi is improved. (push used.)
;            gensym, mklist, flat1, mappend are added.
;            with-open-file is improved. (catch and gensym used.)
; 2009/ 1/ 7 mapc,psetq are added.
; 2009/ 1/12 mapc is improved. (nthlst -> (map (curry nth i)))
; 2009/ 1/17 mappend is improved. (function -> macro)
;            maplist is added.
;            reference-inversion is added.
; 2009/ 1/21 read-integer is improved. (remove apostrophe for inc)
; 2009/ 1/26 reference-inversion:reference-inversion is improved. (remove macro-detect)
; 2009/ 1/27 incf & decf are improved. (On Lisp compatible)
; 2009/ 2/18 car is improved. (Common Lisp compatible)
; 2009/ 4/ 7 multi-let is added.
; 2009/ 4/15 read-string is improved. (read-buffer used.)
; 2010/ 6/15 ++ & -- is removed.
; 2010/ 6/16 map-mv is added.
;            null is improved.(using not only)
;            reference-inversion:reference-inversion is improved. (using MAIN:setf in defref)
; 2010/ 6/18 gensym is improved. (no suffix of context)
;            lables is improved. (remove begin in body)
;            ++ & -- are added.
;            consp is improved. (function -> macro)
;            aif is added.
; 2010/ 6/23 mklist is improved. (function -> macro)
; 2010/ 6/24 mappend is improved. (macro -> function)
; 2010/ 7/14 consp is improved. (macro -> function)
; 2010/ 8/ 2 cdr is improved. ((cdr '(a)) -> nil)
; 2010/12/10 curryEx is added.
; 2010/12/17 car, cdr, second, third, fourth are improved. (Common Lisp compatible)
;

;http://www.alh.net/newlisp/phpbb/viewtopic.php?t=1942&highlight=gensym
;(define (gensym) (sym (string "gs" (uuid))))
(define *gensym*:*gensym* 0)
(define (gensym num)
  (if (number? num)
      (let (res)
        (dotimes (i num)
          (push (sym (string  "gensym" (++ *gensym*:*gensym*))) res -1)))
    (sym (string  "gensym" (++ *gensym*:*gensym*)))))
(global 'gensym)
(context 'MAIN:with-open-file)
(define-macro (with-open-file:with-open-file)
  (letex (_result (gensym)
          _stream (args 0 0)
          _open (cons 'open (1 (args 0)))
          _body (cons 'begin (1 (args))))
    (let ((_stream _open) (_result))
      (catch _body '_result)
      (and _stream (close _stream))
      _result)))

(context 'MAIN:defun)
;http://www.alh.net/newlisp/phpbb/viewtopic.php?t=1064&highlight=defun
(set 'defun:defun
	(lambda-macro (_func-name _arguments)
      (set _func-name (append '(lambda ) (list _arguments) (args)))))

(context 'MAIN:labels)
(define-macro (labels:labels)
  (letex (_labels (append '(begin)
                          (map (fn (x)
                                 (list 'setq (x 0) (append '(fn) (list (x 1)) (2 x))))
                            (args 0))
                          (1 (args))))
    _labels))

(context 'MAIN:hayashi)
(define-macro (hayashi:hayashi)
;  (letex ((_func (flat (list (args 0) '_x (1 (args))))))
  (letex (_func (push '_x (args) 1))
    (fn (_x) _func )))

(context 'MAIN:decf)
;(set 'decf:decf
;  (lambda-macro (_number)
;    (set _number (- (eval _number) 1))))
(define-macro (decf:decf place (val 1))
  (letex (_place place
          _val val)
    (setf _place (- $it _val))))

(context 'MAIN:incf)
;(define-macro (incf:incf)
;  (letex (_number (args 0))
;    (setq _number (+ (eval _number) 1))))
(define-macro (incf:incf place (val 1))
  (letex (_place place
          _val val)
    (setf _place (+ $it _val))))

(context 'MAIN:rsetq)
(define-macro (rsetq:rsetq)
  (letex (_arg (args 0 1)
          _func (args 0))
    (setq _arg _func)))

(context 'MAIN:reference-inversion)
(setq *reference-inversion* nil)
(setq *set* 'reference-inversion:set)

(define-macro (reference-inversion:set expr)
  (letex (_expr expr)
    (if *reference-inversion* '_expr _expr)))

(define-macro (reference-inversion:reference-inversion m)
  (setq *reference-inversion* true)
  (letex (_body (if (and (list? (args 0))
                         ;(macro? (eval (args 0 0)))
                         (ref *set* (eval (args 0 0))))
                    (append (list m (eval (args 0))) (1 (args)))
                  (cons m (args))))
    (begin
      (setq *reference-inversion* nil)
      _body)))

(define-macro (reference-inversion:setf)
  (letex (_body (cons 'begin
                      (map (curry append '(reference-inversion MAIN:setf))
                           (explode (args) 2))))
    (begin
      _body)))

(define-macro (reference-inversion:defref)
  (letex (_mname (args 0))
    (if (ref *set* (eval _mname)) nil
        (MAIN:setf (nth '(1 -1) _mname) (cons *set* (list $it))))))

(context MAIN)

(define cdr    (fn (lst) (and (not (nil? lst)) (or (rest lst) nil))))
(define car    (fn (lst) (first (or lst '(nil)))))
(define second (fn (lst) (car (cdr lst))))
(define third  (fn (lst) (car (cdr (cdr lst)))))
(define fourth (fn (lst) (car (cdr (cdr (cdr lst))))))
(define cadr   second)
(define progn begin)
(define t true)
(define equal =)
(define char-code char)
(define atom atom?)
(define floatp float?)
(define integerp integer?)
(define listp list?)
;(define null (fn (x) (not (true? x))))
(define null not)
(define numberp number?)
(define stringp string?)
(define symbolp symbol?)
(define zerop zero?)

(defun read-integer (bytes INPUT-STREAM)
  (let ((c nil) (value 0) (cnt 0) (base 1))
    (while (and (< cnt bytes) (setq c (read-char INPUT-STREAM)))
      (setq value (+ value (* base c)))
      (setq base (* base 256))
      (inc cnt))
    (if c value nil)))

(defun read-string (bytes INPUT-STREAM)
  (let (buff (dup "00" bytes))
    (read-buffer INPUT-STREAM buff bytes)
    buff))

(defun remove (item seq)
  (cond ((string? seq) (replace item (copy seq) ""))
	(true (replace item (copy seq)))))
(define remove-if clean)
(define remove-if-not filter)

(defun evenp (num)
  (= (& num 1) 0))
(defun oddp (num)
  (= (& num 1) 1))
(define (consp L) (and (list? L) (true? L)))
(defun flat1 (lst)
  (apply append (map mklist lst)))
(defun mappend ()
  (apply append (apply map (args))))
(defun mapc (f)
 (let (lsts (args))
  (dotimes (i (apply min (map length lsts)))
    (apply f (map (curry nth i) lsts)))))
(defun maplist (f)
  (let ((lsts (args))(res))
    (dotimes (i (apply min (map length lsts)))
      (push (apply f (map (hayashi slice i) lsts)) res -1))
  res))

;(define (sprint) (silent (apply print (args))))
;(define (sprintln) (silent (apply println (args))))

(global 'cdr 'car 'second 'third 'fourth 'cadr 'progn 't 'equal 'char-code)
(global 'atom 'floatp 'integerp 'listp 'null 'numberp 'stringp 'symbolp 'zerop)
(global 'read-integer 'read-string)
(global 'evenp 'oddp 'consp)
(global 'remove 'remove-if 'remove-if-not)
(global 'flat1 'mappend 'mapc 'maplist)
;(global 'sprint 'sprintln)
;(constant (global '+) add))
;(constant (global '-) sub))
;(constant (global '*) mul))
;(constant (global '/) div))
(context 'MAIN:psetq)
(define-macro (psetq:psetq)
  (letn (_args (explode (args) 2)
         _temp (gensym (length _args)))
    (letex (_vars (transpose (list _temp (map second _args)))
            _pset (flat (cons 'setq (transpose (list (map first _args) _temp)))))
           (let _vars _pset))))
(context MAIN)
(context 'MAIN:multi-let)
(define-macro (multi-let:multi-let)
  (letex (_varlst (map list (args 0))
          _var (args 0)
          _val (args 1)
          _body (cons 'begin (2 (args))))
	   (let _varlst
         (map set '_var (MAIN:mklist _val)) ; corrected 2010/ 6/23
         _body)))
(context MAIN)
(context 'MAIN:map-mv)
(define-macro (map-mv:map-mv)
;(mvmap exp-functor nested-list)
   (letex (_func (args 0)
           _vals (args 1))
     (map (curry apply _func) _vals)))
(context MAIN)
(if macro
    (unless (or i+ i-)
      (macro (i+ X) (+ X 1))
      (macro (i- X) (- X 1))
      (macro (mklist Obj) (if (list? Obj) Obj (list Obj)))
      (macro (aif S A B) (let (it S) (if it A B)))
      (macro (curryEx F A) (lambda () (apply F (cons A $args))))
    )
  (begin
    (define (i+ X) (+ X 1))
    (define (i- X) (- X 1))
    (define (mklist Obj) (if (list? Obj) Obj (list Obj)))
    (define-macro (aif)
      ; (aif test-form then-form &optional else-form)
      (letex (_test-form (args 0)
              _then-form (args 1)
              _else-form (third (args)))
        (let (it _test-form)
          (if it _then-form _else-form))))
    (define-macro (curryEx)
      (letex (_func (args 0) _arg (args 1))
        (lambda () (apply _func (cons _arg $args)))))
  )
)
(global 'i+ 'i- 'aif 'mklist 'curryEx)
; eof newlisp-utility.lsp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; onnewlisp.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 2010/ 8/ 2 identity is added.
;            map0-n, map1-n and mapa-b are added.
; 2010/ 8/ 3 "newlisp-utility.lsp" is necessary.
;            https://johu02.wordpress.com/newlisp-utility-lsp/
;            include is defined in https://johu02.wordpress.com/init-lsp/
;            functionp is added.
;            lrec is added.
; 2010/ 8/ 4 lrec is improved. (cdr -> rest)
;            MACRO? is added.
;            trec is added.
; 2010/ 8/14 multiple-value-bind and multiple-value-list are improved.
;              (avoided the multiple evaluation problem of _val)
;
; 2010/ 8/20 =lambda, =defun, =bind, =values, =funcall and =apply are added.
; 2010/ 8/24 defstruct and structurep are added.
;

(include "newlisp-utility.lsp")

(context 'MAIN:do)
(define (make-stepform bindform)
  (remove nil (mappend (fn (b) (if (and (consp b) (third b))
                               (list (car b) (third b))
                                '()))
                         bindform)))
(define-macro (do:do)
  (letex (_init (map (hayashi slice 0 2) (args 0))
          _steps (cons 'psetq (make-stepform (args 0)))
          _results (cons 'begin (rest (args 1)))
          _end-test (first (args 1))
          _body (cons 'begin (2 (args))))
   (let _init
     (until _end-test
       _body
       _steps)
     _results)))

(context 'MAIN:do*)
(define (make-stepform bindform)
  (remove nil (mappend (fn (b) (if (and (consp b) (third b))
                               (list (car b) (third b))
                                '()))
                         bindform)))
(define-macro (do*:do*)
  (letex (_init (map (hayashi slice 0 2) (args 0))
          _steps (cons 'setq (make-stepform (args 0)))
          _results (cons 'begin (rest (args 1)))
          _end-test (first (args 1))
          _body (cons 'begin (2 (args))))
   (letn _init
     (until _end-test
       _body
       _steps)
     _results)))

(context 'MAIN:multiple-value-bind)
(define (add-nil lst c)
  (let (len (- c (length lst)))
    (if (> c) (append lst (dup nil c)) lst)))
(define-macro (multiple-value-bind:multiple-value-bind)
  (letex (_var (args 0)
          _len (length (args 0))
          _val (args 1)
          _body (cons 'begin (2 (args))))
	  (local _var
      (setq values:mv-set true)
      (let (_res _val)
        (map set '_var (add-nil (mklist _res) _len)))
      (setq values:mv-set nil)
      _body)))

(context 'MAIN:multiple-value-list)
(define-macro (multiple-value-list:multiple-value-list)
  (letex (_val (args 0))
    (let (_lst)
      (setq values:mv-set true)
      (let (_res _val) (setq _lst (mklist _res)))
      (setq values:mv-set nil)
      _lst)))

(context 'MAIN:values)
(define-macro (values:values)
  (letex (_item (args 0)
          _lst  (cons 'list (args)))
    (if mv-set _lst _item)))

(context MAIN)

(define (identity x) x)

(define (functionp x) (or (lambda? x) (primitive? x)))

(define (lrec rec-f base-f)
  (letex (rec rec-f
          base base-f)
    (labels ((self-r (lst)
                   (if (null lst)
                       (if (functionp 'base) (base) 'base)
                       (rec (first lst)
                            (fn () (self-r (rest lst)))))))
      self-r)))

(define (map0-n f n)
  (map f (sequence 0 n)))
(define (map1-n f n)
  (map f (sequence 1 n)))
(define (mapa-b f a b (step 1))
  (map f (sequence a b step)))

(define (MACRO? f)
  (and (list? f) (macro? f) (= 'expand (nth '(1 0) f))))

(define (trec rec-f (base-f identity))
  (letex (rec rec-f
          base base-f)
    (labels
      ((self-r (tree)
         (if (atom tree)
             (if (functionp 'base) (base tree)
                 (MACRO?    'base) (eval (base tree))
               'base)
             (rec tree (fn () (self-r (first tree)))
                       (fn () (if (rest tree)
                                  (self-r (rest tree))))))))
      self-r)))

(global 'identity 'map0-n 'map1-n 'mapa-b)
(global 'functionp 'lrec 'trec 'MACRO?)

(setq *cont* values)

(define-macro (=lambda)
; (=lambda parms &body body)
  (letex (_parms (cons '*cont* (args 0))
          _body (cons 'begin (1 (args))))
    (fn _parms _body)))

(define-macro (=defun)
; (= defun name parms &body body)
  (let (_f (sym (string "=" (args 0))))
    (letex (_mname (cons (args 0)
                   (map sym (map (curry string "_") (args 1))))
            _fname (append (list _f '*cont*)
                           (map sym (map (curry string "_") (args 1))))
            _vars (if (args 1)
                      (transpose (list (args 1)
                                       (map sym
                                            (map (curry string "_")
                                                 (args 1)))))
                    '())
            _body (cons 'begin (2 (args))))
      (begin
        (define-macro _mname
           _fname)
        (define _fname
          (letex _vars _body))))))

(define-macro (=bind)
; (=bind parms expr &body body)
  (letex (_parms (args 0)
          _expr (args 1)
          _body (cons 'begin
                      (or (set-ref '=values (2 (args)) (eval *cont*))
                          (2 (args)))))
    (let (*cont* (fn _parms _body)) _expr)))

(define-macro (=values)
; (=value &rest retvals)
  (letex (_body (cons '*cont* (args)))
    _body))

(define-macro (=funcall)
; (=fancall fn &rest args)
  (letex (_body (append (list (args 0) '*cont*) (1 (args))))
    _body))

(define-macro (=apply)
; (=apply fn &rest args)
  (letex (_body (append (list 'apply (args 0) '*cont*) (1 (args))))
    _body))

(global '=lambda '=defun '=values '=bind '=funcall '=apply)

(define (structurep s)
  (letex (_s (sym (string s) s))
    (and (context? s) _s (= (s 0) 'structure))))

(define-macro (structfunc funcname propname)
  (letex (_funcname funcname
          _propname propname)
    (setq _funcname (lambda (symbol)
      (letex (_sym (sym '_propname symbol))
        (reference-inversion:set _sym))))))

(define-macro (structfuncs)
  (letex (_pair (cons 'begin (map (curry cons 'structfunc) (args))))
    _pair))

(define-macro (defstruct defname)
  (let (_name defname
        _var (map (fn (x) (first (mklist x))) (args))
        _val (map (fn (x) (second (mklist x))) (args)))
    (letex (_defctx _name
            _strucp (sym (string _name "-p"))
            _copy-n (sym (string "copy-" _name))
            _make-n (sym (string "make-" _name))
            _funcs (cons 'structfuncs (map (fn (x) (list (sym (string _name "-" x)) x)) _var))
            _vari _var
            _vali _val)
      _funcs
      (setq _copy-n (fn (s) (letex (_ctx (sym (gensym))) (new s '_ctx))))
      (setq _strucp (fn (s) (and (structurep s) (= (s 1) '_defctx))))
      (setq _make-n
            (lambda-macro ()
              (let (_gsym (sym (gensym))
                    _vars (append '_vari (map (fn (x) (first (mklist x))) (args)))
                    _vals (append '_vali (map (fn (x) (second (mklist x))) (args))))
                (letex (_ctx _gsym
                        _default (sym _gsym _gsym)
                        _structurep (append (list 'structure '_defctx) '_vari)
                        _var (cons 'setq (apply append (transpose (list (map (hayashi sym _gsym) _vars) _vals)))))
                  (setq _default '_structurep)
                  _var
                  _ctx)))))))

(global 'defstruct 'structurep)
; eof onnewlisp.lsp


--------------------------------------
Peso ideale e indice di massa corporea
--------------------------------------

Peso ideale
-----------
Il peso ideale è il peso forma teorico di una persona. Ma come calcolare questo peso forma teorico?
La soluzione esatta del problema è praticamente impossibile. Molti scienziati hanno cercato di creare una formula e, nonostante ne esistano diverse, ognuna ha i suoi difetti. Questo non significa che siano completamente sbagliate, ma solo che i risultati variano da formula a formula. Questo perché ci sono delle caratteristiche dell’essere umano che non vengono prese in considerazione. Queste formule utilizzano come parametri l'età, il sesso e l'altezza, mentre non tengono conto della struttura scheletrica (dimensione delle ossa) e della struttura muscolare (grasso o muscoli).
Vediamo le formule più famose e indicative.

Formula di Lorenz
-----------------
Questa formula per il calcolo del peso ideale non tiene conto né dell'età né della struttura scheletrica, ma è molto utilizzata. Inoltre non fornisce risultati affidabili nei soggetti longilinei e brachitipici.

Peso ideale Uomini = altezza in cm - 100 - (altezza in cm - 150)/4
Peso ideale Donne = altezza in cm - 100 - (altezza in cm - 150)/2

Formula di Broca
----------------
Questa formula è la più semplice, ma tiene conto solo dell'altezza. I limiti maggiori risiedono nella non corrispondenza del peso ideale per i soggetti medio alti.

Peso ideale Maschi = altezza in cm - 100
Peso ideale Femmine = altezza in cm - 104

Formula di Wan der Vael
-----------------------
Anche questa formula considera solo l'altezza.

Peso ideale Uomini = (altezza in cm - 150) x 0.75 + 50
Peso ideale Donne = (altezza in cm - 150) x 0.6 + 50

Formula di Berthean
-------------------
Questa formula tiene conto dell'età e dell'altezza.
Peso ideale = 0.8 x (altezza in cm - 100) + età/2

Formula di Perrault
-------------------
Questa formula tiene conto dell'età e dell'altezza.
Peso ideale = Altezza in cm - 100 + età/10 x 0.9

Formula di Keys
---------------
Peso ideale Uomini = (altezza in m)² x 22.1
Peso ideale Donne = (altezza in m)² x 20.6

Formula di Travia
-----------------
Peso ideale = (1.012 x altezza in cm) - 107.5

Formula di Livi
---------------
Peso ideale = (2.37 x altezza in m)^3

Buffon, Roher e Bardeen (confermata da Quételet e Martin)
---------------------------------------------------------
Peso ideale Uomini = (1.40 x altezza in dm3)/100

Peso ideale Donna = (135 x altezza in dm3)/100

Indice di massa corporea
------------------------
Dato che tutte queste formule producono risultati diversi, l’OMS (Organizzazione Mondiale della Sanità), ha preferito definire un indice che viene interpretato in un range di valori (invece che il solo valore del peso forma). In questo modo l'indice appartiene ad una classe con determinati limiti (minimo e massimo). Ad esempio, se ci troviamo nella classe (range) "Normale" non ci sono problemi sia che ci troviamo verso l’alto che verso il basso (se usciamo dal range "Normale", invece, occorre preoccuparsi).

La formula del BMI (Body Mass Index) o IMC (Indice di Massa Corporea) che viene utilizzata è la seguente:

BMI = peso / (altezza in m)²

Questa formula da un valore che non è il peso forma teorico, ma un punteggio. Comunque questa formula ha dei limiti, ovvero tende a valutare come sovrappeso individui muscolosi oppure come sottopeso individui esili con ossa piccole. La formula è stata perfezionata in un nuovo indice che viene chiamato "Nuovo BMI":

NuovoBMI: 1.3 x peso in Kg / (altezza in m)^2.5

In pratica, questa nuova formula normalizza l’altezza rendendola più significativa del peso.

Possiamo utilizzare tutte e due le formule e, pur trovando due valori leggermente diversi, interpretare i risultati con la seguente tabella:

  BMImin   BMImax   Classe
  -----------------------------------
  > 40   |        | Obesità (terzo grado)
  > 35   | < 40   | Obesità (secondo grado)
  > 30   | < 35   | Obesità (primo grado)
  > 25   | < 30   | Sovrappeso
  > 18.5 | < 25   | Normale
  > 17.5 | < 18.5 | Sottopeso
  > 15.5 | < 17.5 | Anoressia moderata
  >  0   | < 15.5 | Anoressia

Scriviamo una funzione che calcola il "Nuovo BMI" e la relativa classe:

(define (newBMI peso altezza)
  (local (bmi tipo)
    (setq bmi (div (mul 1.3 peso) (pow altezza 2.5)))
    (cond ((> bmi 40) (setq tipo "Obesità (terzo grado)"))
          ((and (> bmi 35) (<= bmi 40)) (setq tipo "Obesità (secondo grado)"))
          ((and (> bmi 30) (<= bmi 35)) (setq tipo "Obesità (primo grado)"))
          ((and (> bmi 25) (<= bmi 30)) (setq tipo "Sovrappeso"))
          ((and (> bmi 18.5) (<= bmi 25)) (setq tipo "Normale"))
          ((and (> bmi 17.5) (<= bmi 18.5)) (setq tipo "Sottopeso"))
          ((and (> bmi 15.5) (<= bmi 17.5)) (setq tipo "Anoressia moderata"))
          ((and (> bmi 0) (<= bmi 15.5)) (setq tipo "Anoressia"))
          (true (setq tipo "errore: valore fuori dai limiti"))
    )
    (list bmi tipo)))

Facciamo alcune prove:

(newBMI 79 1.80)
;-> (23.62594457708111 "Normale")
(newBMI 89 1.75)
;-> (28.55868703815026 "Sovrappeso")
(newBMI 60 1.85)
;-> (16.755804389574 "Anoressia moderata")
(newBMI 50 1.65)
;-> (18.5867516512393 "Normale")
(newBMI 45 1.60)
;-> (18.06574639842287 "Sottopeso")
(newBMI 75 1.60)
;-> (30.10957733070478 "Obesità (primo grado)")


------------------
Sequenza di Golomb
------------------

La sequenza di Golomb (definita dal matematico e ingegnere Solomon Golomb) è una successione di interi monotona non decrescente nella quale a(n) rappresenta il numero di volte in cui n compare nella successione stessa. La successione inizia con a1 = 1 e ha la proprietà che, per qualsiasi n > 1, a(n) è il primo e unico intero che soddisfa la definizione. Ad esempio, il termine a1 = 1 afferma che il numero 1 appare una e una sola volta nella sequenza, perciò a2 non può essere anch'esso 1, ma può (e deve) essere l'intero successivo, 2. Seguendo questo ragionamento otteniamo:

  a1 = 1
  Pertanto 1 si verifica esattamente una volta in questa sequenza.
  a2 > 1
  a2 = 2
  2 si verifica esattamente 2 volte in questa sequenza.
  a3 = 2
  3 si verifica esattamente 2 volte in questa sequenza.
  a4 = a5 = 3
  4 si verifica esattamente 3 volte in questa sequenza.
  5 si verifica esattamente 3 volte in questa sequenza.
  a6 = a7 = a8 = 4
  a9 = a10 = a11 = 5
  ...

Sequenza OEIS A001462: 1, 2, 2, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 6,
 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11,
 11, 11, 11, 12, 12, 12, 12, 12, 12,...

La formula ricorsiva per calcolare i termini della sequenza è la seguente (Colin Mallows):

  a(1) = 1
  a(n+1) = 1 + a*(n + 1 - a(a(n)))

Nota: dalla definizione ricorsiva segue che questa è una sequenza autoreferenziale.

La stima asintotica per a(n) vale (Marcus e Fine):

  a(n) = phi^(2-phi)*n^(phi-1) + E(n),
  dove phi è il rapporto aureo (1+sqrt(5))/2
  e E(n) è il termine di errore che vale (Ilan Vardi): O( n^(phi-1) / log n )

Scriviamo una funzione che calcola la stima asintotica di a(n):

(setq phi (div (add 1 (sqrt 5)) 2))
;-> 1.618033988749895

(setq n 20)
(define (golomb-stima n)
  (local (phi an en)
    (setq phi (div (add 1 (sqrt 5)) 2))
    (setq an (mul (pow phi (sub 2 phi)) (pow n (sub phi 1))))
    (setq en (div (pow n (sub phi 1)) (log n)))
    (list an en)
  ))

(golomb-stima 100)
;-> (20.69636871119573 3.739575390803224)

Scriviamo una funzione ricorsiva che calcola la sequenza di Golomb fino a un dato valore n:

(define (find-golomb n)
  (cond ((= n 1) 1)
        (true (+ 1 (find-golomb (- n (find-golomb (find-golomb (- n 1)))))))))

(define (golomb-rec n)
  (local (gol)
    (setq gol '())
    (for (i 1 n)
      (push (find-golomb i) gol -1)
    )
    gol))

(golomb-rec 10)
;-> (1 2 2 3 3 4 4 4 5 5)
(golomb-rec 25)
;-> (1 2 2 3 3 4 4 4 5 5 5 6 6 6 6 7 7 7 7 8 8 8 8 9 9)

Scriviamo una funzione che utilizza la programmazione dinamica per calcolare la sequenza di Golomb fino a un dato valore n:

(define (golomb-dp n)
  (let (gol (array (+ n 1) '(0)))
    (setf (gol 1) 1)
    (for (i 1 (- n 1))
      (setf (gol (+ i 1)) (+ 1 (gol (+ i 1 (- (gol (gol i)))))))
    )
    (slice gol 1)))

(golomb-dp 10)
;-> (1 2 2 3 3 4 4 4 5 5)
(golomb-dp 25)
;-> (1 2 2 3 3 4 4 4 5 5 5 6 6 6 6 7 7 7 7 8 8 8 8 9 9)

Vediamo un'altra funzione che calcola la sequenza di Golomb fino a che a(k) è uguale a n:

(define (golomb-k n)
  (local (gol next-val)
    (setq gol '(1))
    (for (i 0 (- n 2))
      (setq next-val (+ (gol (- (length gol) 1)) 1))
      (push next-val gol -1)
      (for (j 0 (- (gol (- next-val 1)) 2))
        (push next-val gol -1)
      )
    )
    gol))

(golomb-k 10)
;-> (1 2 2 3 3 4 4 4 5 5 5 6 6 6 6 7 7 7 7 8 8 8 8 9 9 9 9 9 10 10 10 10 10)
(golomb-k 25)
;-> (1 2 2 3 3 4 4 4 5 5 5 6 6 6 6 7 7 7 7 8 8 8 8 9 9 9 9 9 10 10 10 10 10
;->  11 11 11 11 11 12 12 12 12 12 12 13 13 13 13 13 13 14 14 14 14 14 14 15
;->  15 15 15 15 15 16 16 16 16 16 16 16 17 17 17 17 17 17 17 18 18 18 18 18
;->  18 18 19 19 19 19 19 19 19 20 20 20 20 20 20 20 20 21 21 21 21 21 21 21
;->  21 22 22 22 22 22 22 22 22 23 23 23 23 23 23 23 23 24 24 24 24 24 24 24
;->  24 24 25 25 25 25 25 25 25 25 25)


---------------------------
Acquistare e vendere azioni
---------------------------

Nel trading di azioni, un acquirente compra azioni e le vende in una data futura. Dato il prezzo delle azioni di n giorni, il trader può effettuare al massimo k transazioni (dove una nuova transazione può iniziare solo dopo che la transazione precedente è stata completata). Determinare il profitto massimo che un trader può realizzare dato il prezzo delle azioni di n giorni e il numero k di transazioni.

Esempi:

Input:
Valore azioni = [10, 22, 5, 75, 65, 80]
Transazioni = 2
Output: 87
Il trader guadagna 87 come somma di 12 e 75.
Acquista a prezzo 10, vende a 22, acquista a 5 e vende a 80.

Input:
Valore azioni = [12, 14, 17, 10, 14, 13, 12, 15]
Transazioni = 3
Output: 12
Il trader guadagna 12 come somma di 5, 4 e 3.
Acquista a prezzo 12 e vende a 17, acquista a 10 e vende a 14, acquista a 12 e vende a 15.

Input:
Valore azioni = [100, 30, 15, 10, 8, 25, 80]
Transazioni = 3
Output: 72
Due transazioni. Acquista a prezzo 8 e vende a 25, acquista a prezzo 25 e vende a 80.

Input:
Valore azioni = [90, 80, 70, 60, 50]
Transazioni = 1
Output: 0
Non è possibile guadagnare.

Esistono varie versioni del problema. Se è possibile comprare e vendere solo una volta, allora possiamo usare l'algoritmo "differenza massima tra due elementi". Se è possibile comprare e vendere un numero qualsiasi di volte, possiamo utilizzare il metodo seguente.

Il problema può essere risolto utilizzando la programmazione dinamica.

Poniamo che profitto[t][i] rappresenti il ​​profitto massimo utilizzando al massimo t transazioni fino al giorno i (incluso il giorno i).
Allora la relazione è:

  profitto[t][i] = max(profitto[t][i-1], max(prezzo[i] – prezzo[j] + profitto[t-1][j]))
  per tutti j nell'intervallo [0, i-1]

profitto[t][i] sarà il massimo di:
  1) profitto[t][i-1] che rappresenta non fare alcuna transazione il giorno i-esimo.
  2) Massimo profitto ottenuto vendendo l'iesimo giorno. Per vendere azioni l'i-esimo giorno, dobbiamo acquistarle in uno qualsiasi dei [0, i – 1] giorni. Se acquistiamo azioni il giorno j-esimo e le vendiamo il giorno i-esimo, il profitto massimo sarà prezzo[i] – prezzo[j] + profitto[t-1][j] dove j varia da 0 a i-1. Qui il profitto[t-1][j] è il migliore che avremmo potuto fare con una transazione in meno fino al j-esimo giorno.

Vediamo una possibile implementazione:

(define (max-profit price k)
  (local (n profit val-max)
    ; numero giorni
    (setq n (length price))
    ; matrice per memorizzare i risultati dei sottoproblemi
    ; profit[t][i] memorizza il massimo profitto usando al massimo
    (setq profit (array (+ k 1) n '(0)))
    ; Riempimento della matrice in modo bottom-up
    (for (i 1 k)
      (for (j 1 (- n 1))
        (setq val-max 0)
        (for (m 0 (- j 1))
          (setq val-max (max val-max (+ (price j) (profit (- i 1) m) (- (price m)))))
        )
        (setf (profit i j) (max (profit i (- j 1)) val-max))
      )
    )
    (print-transaction profit price)
    (profit k (- n 1))))

Adesso scriviamo la funzione che stampa i valori delle singole transazioni:

(define (print-transaction profit price)
  (local (i j stack max-diff continua stop)
    (setq i (- (length profit) 1))
    (setq j (- (length (profit 0)) 1))
    (setq continua true)
    (while continua
      (cond ((or (= i 0) (= j 0))
             (setq continua nil))
            (true
             (if (= (profit i j) (profit i (- j 1)))
                 (-- j)
             (begin ;else
                 (push j stack)
                 (setq max-diff (- (profit i j) (price j)))
                 (setq stop nil)
                 (for (k (- j 1) 0 -1 stop)
                     (if (= (- (profit (- i 1) k) (price k)) max-diff) (begin
                         (-- i)
                         (setq j k)
                         (push j stack)
                         (setq stop true))
                     )
                 )
             )))
      )
    )
    (if (> (length stack) 0)
      (for (i 0 (- (length stack) 2) 2)
        (println "compra a " (price (stack i)) " e vende a " (price (stack (+ i 1))) " (" (- (price (stack (+ i 1))) (price (stack i))) ")")
      )
    )
  )
)

Facciamo alcune prove:

(max-profit '(10 22 5 75 65 80) 2)
;-> compra a 10 e vende a 22 (12)
;-> compra a 5 e vende a 80 (75)
;-> 87
(max-profit '(12 14 17 10 14 13 12 15) 3)
;-> compra a 12 e vende a 17 (5)
;-> compra a 10 e vende a 14 (4)
;-> compra a 12 e vende a 15 (3)
;-> 12
(max-profit '(100 30 15 10 8 25 80) 3)
;-> compra a 8 e vende a 25 (17)
;-> compra a 25 e vende a 80 (55)
;-> 72
(max-profit '(90 80 70 60 50) 1)
;-> 0

Questa soluzione ha complessità temporale O(k*n^2).
È possibile calcolare il massimo profitto ottenuto vendendo azioni il giorno i-esimo in tempo costante.

  profitto[t][i] = max(profitto [t][i-1], max(prezzo[i] – prezzo[j] + profitto[t-1][j]))
  per tutti j nell'intervallo [0, i-1]

Se notiamo con attenzione l'espressione,
  max(prezzo[i] – prezzo[j] + profitto[t-1][j])
  per tutti j nell'intervallo [0, i-1]

può essere riscritta come,
  = prezzo[i] + max(profitto[t-1][j] – prezzo[j])
  per tutti j nell'intervallo [0, i-1]
  = prezzo[i] + max(prev-diff, profitto[t-1][i-1] – prezzo[i-1])
  dove prev-diff è max(profit[t-1][j] – prezzo[j])
  per tutti j nell'intervallo [0, i-2]

Quindi, se abbiamo già calcolato max(profit[t-1][j] – prezzo[j]) per tutti j nell'intervallo [0, i-2], possiamo calcolarlo per j = i – 1 in tempo costante. In altre parole, non dobbiamo più guardare indietro nell'intervallo [0, i-1] per scoprire il giorno migliore per l'acquisto. Possiamo determinarlo in tempo costante usando la relazione seguente:

  profitto[t][i] = max(profitto[t][i-1], prezzo[i] + max(prev-diff, profitto [t-1][i-1] – prezzo[i-1])
  dove prev-diff è max(profit[t-1][j] – price[j]) per tutti j nell'intervallo [0, i-2]

Scriviamo una possibile implementazione:

(define (max-profit-2 price k)
  (local (n profit prev-diff)
    ; numero giorni
    (setq n (length price))
    ; matrice per memorizzare i risultati dei sottoproblemi
    ; profit[t][i] memorizza il massimo profitto usando al massimo
    ; t transazioni fino al giorno i (incluso)
    (setq profit (array (+ k 1) n '(0)))
    ; Riempimento della matrice in modo bottom-up
    (for (i 1 k)
      (setq prev-diff -9223372036854775808)
      (for (j 1 (- n 1))
        (setq prev-diff (max prev-diff (- (profit (- i 1) (- j 1)) (price (- j 1)))))
        (setf (profit i j) (max (profit i (- j 1)) (+ (price j) prev-diff)))
      )
    )
    ; stampa le singole transazioni
    (print-transaction profit price)
    ; restituisce il valore finale
    (profit k (- n 1))))

Verifichiamo i risultati precedenti:

(max-profit-2 '(10 22 5 75 65 80) 2)
;-> compra a 10 e vende a 22 (12)
;-> compra a 5 e vende a 80 (75)
;-> 87
(max-profit-2 '(12 14 17 10 14 13 12 15) 3)
;-> compra a 12 e vende a 17 (5)
;-> compra a 10 e vende a 14 (4)
;-> compra a 12 e vende a 15 (3)
;-> 12
(max-profit-2 '(100 30 15 10 8 25 80) 3)
;-> compra a 8 e vende a 25 (17)
;-> compra a 25 e vende a 80 (55)
;-> 72
(max-profit-2 '(90 80 70 60 50) 1)
;-> 0

Questa soluzione ha complessità temporale O(k*n).

Vediamo la differenza di velocità tra le due funzioni:

(setq azioni (randomize (sequence 1 1000)))
(time (println (max-profit azioni 10)))
;-> compra a 2 e vende a 1000 (998)
;-> compra a 17 e vende a 997 (980)
;-> compra a 1 e vende a 996 (995)
;-> compra a 8 e vende a 998 (990)
;-> compra a 13 e vende a 990 (977)
;-> compra a 9 e vende a 994 (985)
;-> compra a 15 e vende a 995 (980)
;-> compra a 4 e vende a 977 (973)
;-> compra a 6 e vende a 992 (986)
;-> compra a 3 e vende a 999 (996)
;-> 9860
;-> 6257.59

(time (println (max-profit-2 azioni 10)))
;-> compra a 2 e vende a 1000 (998)
;-> compra a 17 e vende a 997 (980)
;-> compra a 1 e vende a 996 (995)
;-> compra a 8 e vende a 998 (990)
;-> compra a 13 e vende a 990 (977)
;-> compra a 9 e vende a 994 (985)
;-> compra a 15 e vende a 995 (980)
;-> compra a 4 e vende a 977 (973)
;-> compra a 6 e vende a 992 (986)
;-> compra a 3 e vende a 999 (996)
;-> 9860
;-> 22.303


---------------
Numeri armonici
---------------

Per ogni intero naturale n si definisce come n-esimo numero armonico la somma:

                                   n
H(n) = 1 + 1/2 + 1/3 + ... + 1/n = ∑ 1/k
                                   k=1

Questi sono numeri razionali e le corrispondenti frazioni ridotte ai minimi termini hanno numeratore dispari e denominatore pari.

I primi termini della successione dei numeri armonici sono:

1, 3/2, 11/6, 25/12, 137/60, 49/20, 363/140, 761/280, 7129/2520, 7381/2520, 83711/27720, ...

I numeratori dei numeri armonici sono la sequenza A001008 OEIS.
I denominatori dei numeri armonici sono la sequenza A002805 OEIS.

I numeri armonici costituiscono le somme parziali della serie armonica (che è divergente).

Per questi numeri vale la seguente relazione ricorsiva:

H(n+1) = H(n) + 1/(n + 1)

Nota: il valore di un numero armonico è compreso tra: log(n) < H(n) < log(n) + 1

Scriviamo le funzioni necessarie per calcolare i numeri armonici.

Funzioni per il calcolo delle quattro operazioni aritmetiche con le frazioni "+", "-" "*" "/" (big integer):

(define (rat n d)
  (let (g (gcd n d))
    (map (curry * 1L)
         (list (/ n g) (/ d g)))))
(define (+rat r1 r2)
  (setq r1 (list (bigint (r1 0)) (bigint(r1 1))))
  (setq r2 (list (bigint (r2 0)) (bigint(r2 1))))
  (rat (+ (* (r1 0L) (r2 1L))
          (* (r2 0L) (r1 1L)))
       (* (r1 1L) (r2 1L))))
(define (-rat r1 r2)
  (setq r1 (list (bigint (r1 0)) (bigint(r1 1))))
  (setq r2 (list (bigint (r2 0)) (bigint(r2 1))))
  (rat (- (* (r1 0L) (r2 1L))
          (* (r2 0L) (r1 1L)))
       (* (r1 1) (r2 1))))
(define (*rat r1 r2)
  (setq r1 (list (bigint (r1 0)) (bigint(r1 1))))
  (setq r2 (list (bigint (r2 0)) (bigint(r2 1))))
  (rat (* (r1 0L) (r2 0L))
       (* (r1 1L) (r2 1L))))
(define (/rat r1 r2)
  (setq r1 (list (bigint (r1 0)) (bigint(r1 1))))
  (setq r2 (list (bigint (r2 0)) (bigint(r2 1))))
  (rat (* (r1 0L) (r2 1L))
       (* (r1 1L) (r2 0L))))
;; (+f '(1 2) '(1 2))           ==> (1L 1L)
;; (+f '(1 2) '(1 2) '(1 2))    ==> (3L 2L)
;; (+f '(-1 -2) '(2 1) '(1 1))  ==> (-7L -2L)
(define-macro (+f)
  (apply +rat (map eval (args)) 2))
;; (-f '(1 2) '(1 2))          ==> (0L 1L)
;; (-f '(1 2) '(1 2) '(1 2))   ==> (-1L 2L)
(define-macro (-f)
  (apply -rat (map eval (args)) 2))
;; (*f '(2 5) '(5 2))         ==> (1L 1L)
;; (*f '(1 2) '(1 2) '(1 2))  ==> (1L 8L)
(define-macro (*f)
  (apply *rat (map eval (args)) 2))
;; (/f '(1 2) '(1 2) '(1 2))    ==> (2L 1L)
;; (/f '(4 1) '(1 1) '(1 2))    ==> (8L 1L)
(define-macro (/f)
  (apply /rat (map eval (args)) 2))

Scriviamo una funzione che calcola il numero armonico di un numero n:

(define (harmonic n)
  (local (h)
    (setq h '(0L 1L))
    (for (i 1 n)
      (setq h (+f h (list 1 i)))
    )
    h))

(harmonic 1)
;-> (1L 1L)

Calcoliamo i numeri armonici dei primi dieci interi:

(for (i 1 10) (println (harmonic i)))
;-> (1L 1L)
;-> (3L 2L)
;-> (11L 6L)
;-> (25L 12L)
;-> (137L 60L)
;-> (49L 20L)
;-> (363L 140L)
;-> (761L 280L)
;-> (7129L 2520L)
;-> (7381L 2520L)

I valori del numeratore e del denominatore crescono molto velocemente:

(harmonic 42)
;-> (12309312989335019L 2844937529085600L)


-----------------------------------------
Numero previsto di prove fino al successo
-----------------------------------------

Teorema
Se la probabilità di successo è p in ogni prova, il numero previsto di prove fino al successo vale 1/p.

Problema
Un dado a 6 facce viene lanciato fino a quando non esce un '5'. Qual è il numero previsto di lanci?

Soluzione
Poichè per ogni lancio la probabilità che esca un 5 vale p = 1/6, allora il numero previsto di lanci vale 1/p = 6.

Possiamo verificare questo risultato con le seguente funzioni:

Funzione che simula il lancio di un dado con n facce (da 1 a n):

(define (dado n) (+ (rand n) 1))

(dado 6)
;-> 2

Funzione che calcola la media dei successi (cioè la frequenza di uscita del numero k):

(define (media-successo k iter)
  (let (conta 0)
    (for (i 1 iter)
      (if (= (dado 6) k)
        (++ conta)
      )
    )
    (println conta)
    (div conta iter)))

Facciamo alcune prove:

(media-successo 1 100000)
;-> 16573
;-> 0.16573
(media-successo 2 100000)
;-> 16459
;-> 0.16459
(media-successo 1 100000)
;-> 16634
;-> 0.16634
(media-successo 2 100000)
;-> 16519
;-> 0.16519
(media-successo 3 100000)
;-> 16699
;-> 0.16699
(media-successo 4 100000)
;-> 16685
;-> 0.16685
(media-successo 5 100000)
;-> 16618
;-> 0.16618
(media-successo 6 100000)
;-> 16554
;-> 0.16554

Il valore teorico vale 1/6 = 0.1666666666666667, cioè, in media, il numero k esce ogni 6 lanci.

Con la funzione seguente possiamo calcolare quante volte, in media, occorre lanciare un dado prima che esca il numero k:

(define (freq-successo k iter)
  (local (conta lanci continua)
    ; numero totale di lanci per ottenere "iter" successi
    (setq conta 0)
    (for (i 1 iter)
      ; numero di lanci per l'i-esimo successo
      (setq lanci 0)
      (setq continua true)
      (while continua
        (++ lanci)
        (if (= (dado 6) k) (begin
            (setq conta (+ conta lanci))
            (setq continua nil)
        )
      )
    )
    (div conta iter))))

Facciamo alcune prove:

(freq-successo 1 100000)
;-> 6.01599
(freq-successo 2 100000)
;-> 6.00242
(freq-successo 3 100000)
;-> 6.00706
(freq-successo 4 100000)
;-> 6.00222
(freq-successo 5 100000)
;-> 6.02989
(freq-successo 6 100000)
;-> 5.99746

Quindi, affinchè esca il numero k occorrono in media 6 lanci.


------------------------------------------
Valore atteso e linearità dell'aspettativa
------------------------------------------

Il valore atteso (chiamato anche media o speranza matematica) di una variabile casuale X, è un numero indicato con E[X] che formalizza l'idea euristica di valore medio di un fenomeno aleatorio.

In generale il valore atteso di una variabile casuale discreta (che assuma cioè solo un numero finito di valori) è dato dalla somma dei possibili valori di tale variabile, ciascuno moltiplicato per la probabilità di verificarsi, cioè è la media ponderata dei possibili risultati.

        n
  E[X]= ∑ x(i)*p(i)
       i=1

Per esempio, nel gioco testa o croce, il valore atteso per "testa" vale:

  E[testa]= 1*0.5 + 0*0.5 = 0.5

cioè il valore atteso del gioco di testa vale 0.5, ovvero la media delle vincite e perdite pesata in base alle probabilità (50% per entrambi i casi).

Invece, lanciando un dado il valore atteso vale:

  E[dado] = 1*1/6 + 2*1/6 + 3*1/6 + 4*1/6 + 5*1/6 + 6*1/6 = 21/6 = 3.5

La linearità dell'aspettativa dice fondamentalmente che il valore atteso di una somma di variabili casuali è uguale alla somma delle aspettative individuali. La sua importanza è fondamentale per l'area degli algoritmi randomizzati e dei metodi probabilistici. La sua forza principale consiste sul fatto che:

  a) è applicabile per somme di qualsiasi variabile casuale (indipendente o meno), e
  b) spesso consente semplici argomenti “locali” invece di quelli “globali”.

         n
  E[X] = ∑ E[x(i)]
        i=1

Per esempio, nel lancio di due dadi (con distribuzioni indipendenti X1 e X2) il valore atteso di X = X1 + X2 vale:

  E[X] = 2*1/36 + 3*1/36 + ... + 12*1/36 = 7

Cioè, la linearità dell'aspettativa ci permette di calcolare il valore atteso di una somma di variabili casuali calcolando la somma delle aspettative individuali.

Problema
Supponiamo di avere n buche e un numero infinito di palline. Lanciando una pallina questa termina in una delle n buche (con distribuzione uniforme). Quanti lanci dobbiamo effettuare, in media, affinchè tutte le buche contengano almeno una pallina?

Soluzione
Dal punto di vista matematico è possibile dimostrare (utilizzando la proprietà della linearità delle aspettative) che il risultato vale:

 E[X] = n * H(n)
 dove H(n) è l'n-esimo numero armonico.

Prima scriviamo le funzioni per calcolare il valore matematico della soluzione.

Funzioni per il calcolo delle quattro operazioni aritmetiche con le frazioni "+", "-" "*" "/" (big integer):

(define (rat n d)
  (let (g (gcd n d))
    (map (curry * 1L)
         (list (/ n g) (/ d g)))))
(define (+rat r1 r2)
  (setq r1 (list (bigint (r1 0)) (bigint(r1 1))))
  (setq r2 (list (bigint (r2 0)) (bigint(r2 1))))
  (rat (+ (* (r1 0L) (r2 1L))
          (* (r2 0L) (r1 1L)))
       (* (r1 1L) (r2 1L))))
(define (-rat r1 r2)
  (setq r1 (list (bigint (r1 0)) (bigint(r1 1))))
  (setq r2 (list (bigint (r2 0)) (bigint(r2 1))))
  (rat (- (* (r1 0L) (r2 1L))
          (* (r2 0L) (r1 1L)))
       (* (r1 1) (r2 1))))
(define (*rat r1 r2)
  (setq r1 (list (bigint (r1 0)) (bigint(r1 1))))
  (setq r2 (list (bigint (r2 0)) (bigint(r2 1))))
  (rat (* (r1 0L) (r2 0L))
       (* (r1 1L) (r2 1L))))
(define (/rat r1 r2)
  (setq r1 (list (bigint (r1 0)) (bigint(r1 1))))
  (setq r2 (list (bigint (r2 0)) (bigint(r2 1))))
  (rat (* (r1 0L) (r2 1L))
       (* (r1 1L) (r2 0L))))
(define-macro (+f)
  (apply +rat (map eval (args)) 2))
(define-macro (-f)
  (apply -rat (map eval (args)) 2))
(define-macro (*f)
  (apply *rat (map eval (args)) 2))
(define-macro (/f)
  (apply /rat (map eval (args)) 2))

Funzione per il calcolo dell'n-esimo numero armonico:

(define (harmonic-value n)
  (local (h)
    (setq h '(0L 1L))
    (for (i 1 n)
      (setq h (+f h (list 1 i)))
    )
    (div (h 0) (h 1))))

(harmonic-value 10)
;-> 2.928968253968254

Funzione che calcola il risultato matematico del problema:

(define (math-value n)
  (mul n (harmonic-value n)))

Adesso scriviamo le funzioni per effettuare una simulazione del processo e calcolare una soluzione numerica.

Funzione che effettua il processo di riempire le buche con almeno una pallina in ogni buca e restituisce il numero di lanci necessari:

(define (fill-hole n)
  (local (buche lanci continua filled break)
    (setq buche (array (+ n 1) '(0)))
    (setq lanci 0)
    (setq continua true)
    (while continua
      ; lancio nella buca b
      (setq b (+ (rand n) 1))
      (++ lanci)
      (++ (buche b))
      ; controllo riempimento buche
      (setq filled true)
      (setq break nil)
      (for (i 1 n 1 break)
        (if (zero? (buche i))
          (setq filled nil break true)
        )
      )
      (if filled (setq continua nil))
    )
    ;(println buche)
    ;(println (apply + buche))
    lanci))

Funzione che simula iter volte il processo di riempimento visto sopra:

(define (fill-hole-test n iter)
  (local (conta lanci continua)
    ; numero totale di lanci per ottenere "iter" successi
    (setq conta 0)
    (for (i 1 iter)
      ; (fill-hole n) -> numero di lanci per l'i-esimo successo
      ; (successo = tutte le buche almeno con 1 pallina)
      (setq conta (+ conta (fill-hole n)))
    )
    (div conta iter)))

Verifichiamo che il risultati teorici siano congruenti con quelli delle simulazioni:

(fill-hole-test 10 10000)
;-> 29.30323
(math-value 10)
;-> 29.28968253968254

(fill-hole-test 20 10000)
;-> 72.2317
(math-value 20)
;-> 72.03876

(fill-hole-test 30 10000)
;-> 119.7455
(math-value 30)
;-> 119.8496139276117

I risultati teorici confermano i risultati delle simulazioni.


-------------------------
Moltiplicazione ricorsiva
-------------------------

Moltiplicare due interi senza utilizzare gli operatori di moltiplicazione, divisione e bitwise. Inoltre non è possibile utilizza cicli (for, while, ecc).

La soluzione consiste nell'utilizzare una funzione ricorsiva:

(define (molt x y)
        ; 0*x = 0
  (cond ((zero? y) 0)
        ; aggiunge x ogni volta
        ((> y 0) (+ x (molt x (- y 1))))
        ; caso in cui y è negativo
        ((< y 0) (- (molt x (- y))))
        (true nil)))

(molt 3 4)
;-> 12
(molt -2 4)
;-> -8
(molt 2 -4)
;-> -8
(molt -1 -3)
;-> 3
(molt 0 0)
;-> 0
(molt 0 2)
;-> 0
(molt 2 0)
;-> 0

Nota: questa funzione ha il problema dello stack overflow per numeri relativamente grandi:

(molt 5000 -1234)
;-> ERR: call or result stack overflow in function cond : zero?
;-> called from user function (molt x (- y 1))


------------------
Il gioco del Lotto
------------------

Il gioco del Lotto consiste in un’urna che contiene 90 palline numerate. Vengono estratte a caso 5 palline, 85 di queste sono perdenti, 5 sono vincenti.
I casi possibili sono tutti i modi di estrarre un gruppo di k=5 palline tra n=90 (poichè le ripetizioni non sono ammesse e l’ordine di estrazione non è rilevante, allora si tratta del numero di combinazioni):

  Numero di casi possibili = Combinazioni(90,5)

Per calcolare le combinazioni utilizziamo la funzione che calcola il coefficiente binomiale (n k) = n!/(k!*(n - k)!):

(define (binom num k)
  (cond ((> k num) 0)
        ((zero? k) 1)
        (true
          (let (r 1L)
            (for (d 1 k)
              (setq r (/ (* r num) d))
              (-- num)
            )
          r))))

(binom 90 5)
;-> 43949268L

Prima di calcolare tutte le probabilità del lotto, vediamo un esempio di queste probabilità utilizzando il calcolo combinatorio.

Esempio
-------
Una persona gioca 4 numeri al lotto, calcolare la probabilità di vincere almeno un terno (ossia un terno o una quaterna).

La formula per calcolare la probabilità è la seguente:

          C(a x) * C(b y)
  P(x) = -----------------
              C(N n)

dove:
  a = numeri giocati (4)
  b = numeri non giocati (86)
  x = numeri favorevoli estratti (3 per il terno o 4 per la quaterna)
  y = numeri non favorevoli estratti (2 per il terno 1 per la quaterna)
  N = popolazione totale (90)
  n = numero palline estratte (5)

La formula considera che i casi favorevoli siano dati dal prodotto cartesiano di tutti i possibili raggruppamenti dei 4 numeri giocati con i 3 numeri del terno uscito e tutti i possibili raggruppamenti degli 86 numeri non giocati con i 2 numeri avanzati che non costituiscono il terno. I casi totali sono dati da tutte le possibili combinazioni dei 90 numeri del lotto presi a gruppi di 5.

Per il terno abbiamo:

          C(4,3) * C(86,2)       170
  P(3) = ------------------ = ----------
              C(90,5)           511038

Per la quaterna abbiamo:

          C(4,4) * C(86,1)        1
  P(4) = ------------------ = ----------
              C(90,5)           511038

Probabilità di estrazione su singola ruota
------------------------------------------

A) Probabilità secche

Probabilità che 1 numero giocato venga estratto:

C(89,4)*C(1,1) / C(90,5) = 2441626 / 43949268 = 1/18 = 0.05555555555555555

(* (binom 89 4) (binom 1 1))
;-> 2441626L
(div 2441626 43949268)
;-> 0.05555555555555555
(div (div 2441626 43949268))
;-> 18

Probabilità che 2 numeri giocati vengano estratti (ambo secco):

Siccome i numeri estratti sono 5 numeri i casi favorevoli sono quelli in cui i due numeri giocati sono fissi C(2,2) e gli altri 3 numeri variabili, cioe' tutte le terne che si possono formare con gli 88 numeri restanti, cioè C(88,3).
Poichè i casi possibili sono tutte le cinquine che posso formare con i 90 numeri C(90,5), otteniamo:

                 C(88,3)*C(2 2)      2
P(ambo secco) = ---------------- = ----- = 0.002496878901373283 (~ 0,25%)
                    C(90,5)         801

C(88,3)*C(2,2) / C(90,5) = 109736 / 43949268 = 1/400.5 = 0.002496878901373283

(* (binom 88 3) (binom 2 2))
;-> 109736L
(div 109736 43949268)
;-> 0.002496878901373283
(div (div 109736 43949268))
;-> 400.5

Probabilità che 3 numeri giocati vengano estratti (terno secco):

C(87,2)*C(3,3) / C(90,5) = 3741 / 43949268 = 1/11748 = 8.512087163772556e-005

(* (binom 87 2) (binom 3 3))
;-> 3741L
(div 3741 43949268)
;-> 8.512087163772556e-005
(div (div 3741 43949268))
;-> 11748

Probabilità che 4 numeri giocati vengano estratti (quaterna secca):

C(86,1)*C(4,4) / C(90,5) = 86 / 43949268 = 1/511038 = 1.956801646844266e-006

(* (binom 86 1) (binom 4 4))
;-> 86L
(div 86 43949268)
;-> 1.956801646844266e-006
(div (div 86 43949268))
;-> 511038

Probabilità che 5 numeri giocati vengano estratti (cinquina secca):

C(85,0)*C(5,5) / C(90,5) = 1 / 43949268 = 2.275350752144495e-008

(* (binom 85 0) (binom 5 5))
;-> 1L
(div 43949268)
;-> 2.275350752144495e-008
(div (div 43949268))
;-> 43949268

B) Probabilità con 5 numeri giocati

Probabilità che 0 dei 5 numeri giocati venga estratto:

C(85,5)*C(5,0) / C(90,5) = 32801517 / 43949268 =

(* (binom 85 5) (binom 5 0))
;-> 32801517L
(div 32801517 43949268)
;-> 0.7463495637743045
(div (div 32801517 43949268))
;-> 1.339854739035393

Probabilità che 1 dei 5 numeri giocati venga estratto:

C(85,4)*C(5,1) / C(90,5) = 10123925 / 43949268 = 0.2303548036340446

(* (binom 85 4) (binom 5 1))
;-> 10123925L
(div 10123925 43949268)
;-> 0.2303548036340446
(div (div 10123925 43949268))
;-> 4.341129354474673

Probabilità che 2 dei 5 numeri giocati vengano estratti:

C(85,3)*C(5,2) / C(90,5) = 987700 / 43949268 = 0.02247363937893118

(* (binom 85 3) (binom 5 2))
;-> 987700
(div 987700 43949268)
;-> 0.02247363937893118
(div (div 987700 43949268))
;-> 44.4965758833654

Probabilità che 3 dei 5 numeri giocati vengano estratti:

C(85,2)*C(5,3) / C(90,5) = 35700 / 43949268 = 0.0008123002185155848

(* (binom 85 2) (binom 5 3))
;-> 35700L
(div 35700 43949268)
;-> 0.0008123002185155848
(div (div 35700 43949268))
;-> 1231.071932773109

Probabilità che 4 dei 5 numeri giocati vengano estratti:

C(85,1)*C(5,4) / C(90,5) = 425 / 43949268 = 9.670240696614104e-006

(* (binom 85 1) (binom 5 4))
;-> 425L
(div 425 43949268)
;-> 9.670240696614104e-006
(div (div 425 43949268))
;-> 103410.0423529412

Probabilità che 5 dei 5 numeri giocati vengano estratti:

C(85,0)*C(5,5) / C(90,5) = 1 / 43949268 = 2.275350752144495e-008

(* (binom 85 0) (binom 5 5))
;-> 1L
(div 43949268)
;-> 2.275350752144495e-008
(div (div 43949268))
;-> 43949268

Probabilità di estrazione su più ruote
--------------------------------------
Data la probabilità P di estrazione su una ruota di un evento (numero singolo o ambo o terno o quaterna o cinquina), per ottenere la probabilità di estrazione dello stesso evento su N ruote (considerando favorevoli i casi in cui esso esce su almeno una delle N ruote e che le estrazioni siano indipendenti una dall'altra) possiamo usare il teorema della probabilità composta.
La probabilità che l'evento non si verifichi è data da)
indicando con N il numero di ruote su cui si gioca e considerando che le estrazioni su ciascuna di esse sono indipendenti le une dalle altre, la probabilità di non estrazione su nessuna delle N ruote vale:

  Probabilità di non estrazione = (1-P)^N

Pertanto, la probabilità che l'evento si verifichi su almeno una delle N ruote vale:

  Probabilità di estrazione = 1 - (1-P)^N

Simulazione del gioco del lotto
-------------------------------
Adesso scriviamo delle funzioni per simulare il gioco del lotto e verificare i risultati matematici.
Per confrontare i numeri vincenti con i numeri estratti usiamo la funzione primitiva "difference", per esempio:

(setq win '(1 3 5 7 9))
(setq a '(3 1 7 5 9))
(setq b '(1 7 5 6))
(setq c '(5 4 8))
(setq d '(2 4 6 8 10))
(setq y '(2 1))

Tutti numeri uguali (5 giocati):
(difference win a)
;-> ()

3 numeri uguali (4 giocati):
(difference win b)
;-> (3 9)

1 numero uguale (3 giocati):
(difference win c)
;-> (1 3 7 9)

0 numeri uguali (5 giocati):
(difference win d)
;-> (1 3 5 7 9)

1 numero uguale (2 giocati):
(difference win y)
;-> (3 5 7 9)

Scriviamo due funzioni, una per calcolare le probabilità delle giocate secche e una per le calcolare le probabilità delle giocate con 5 numeri.

Funzione per simulare le giocate secche nel lotto:

(define (lotto-secco-test num iter)
  (local (conta urna ev estratti)
    (setq urna (sequence 1 90))
    (setq conta 0)
    (for (i 1 iter)
      ; scommessa secca
      ; estrazione dei num numeri giocati
      (setq ev (slice (randomize urna true) 0 num))
      ; estrazione dei 5 numeri vincenti
      (setq estratti (slice (randomize urna true) 0 5))
      (setq res (length (difference estratti ev)))
      ;(if (= res (- 5 num))
      ;  (println ev { } estratti { } res)
      ;)
      ; confronto vincenti con numeri giocati
      (if (= res (- 5 num)) (++ conta))
    )
    (div conta iter)))

Vediamo l'output delle simulazioni:

(lotto-secco-test 1 1e6)
;-> 0.055632
(lotto-secco-test 2 1e6)
;-> 0.002448
(lotto-secco-test 3 1e6)
;-> 8.1e-005
(lotto-secco-test 4 1e7)
;-> 1.7e-006
(lotto-secco-test 5 1e7)
;-> 0

Nota: quando le percentuali di un evento si avvicinano a zero, allora il processo di simulazione deve utilizzare un numero maggiore di iterazioni. Ad esempio, la cinquina ha una probabilità di uscita di 1 su 43949268 (43milioni 949mila 268), quindi per simulare il processo dovremmo usare tra 50 e 100 milioni di iterazioni. Questo è il motivo per cui l'ultimo valore della simulazione vale 0 (semplicemente perchè 1e7 iterazioni (10 milioni) non sono sufficienti per calcolare correttamente la probabilità della cinquina).

Proviamo con 100 milioni di iterazioni:
(time (println (lotto-secco-test 5 1e8)))
;-> 2e-008
;-> 504951.426

Funzione per simulare le giocate con 5 numeri nel lotto:

(define (lotto5-test num iter)
  (local (conta urna ev estratti)
    (setq urna (sequence 1 90))
    (setq conta 0)
    (for (i 1 iter)
      ; scommessa con 5 numeri
      ; estrazione dei 5 numeri giocati
      (setq ev (slice (randomize urna true) 0 5))
      ; estrazione dei 5 numeri vincenti
      (setq estratti (slice (randomize urna true) 0 5))
      (setq res (length (difference estratti ev)))
      ;(if (= res (- 5 num))
      ;  (println ev { } estratti { } res)
      ;)
      ; confronto vincenti con numeri giocati
      (if (= res (- 5 num)) (++ conta))
    )
    (div conta iter)))

Vediamo l'output delle simulazioni:

(lotto5-test 1 1e6)
;-> 0.231228
(lotto5-test 2 1e6)
;-> 0.022308
(lotto5-test 3 1e6)
;-> 0.000833
(lotto5-test 4 1e7)
;-> 8.5e-006
(lotto5-test 5 1e7)
;-> 0

Proviamo con 100 milioni di iterazioni:

(time (println (lotto5-test 5 1e8)))
;-> 2e-008
;-> 498999.692

La simulazione ottiene dei valori congruenti con i risultati calcolati matematicamente.

Per finire vediamo un metodo per ottimizzare le due funzioni di simulazione del lotto. Invece di utilizzare le funzioni "randomize" e "slice" usiamo "rand" con una lista di lunghezza variabile (ogni numero estratto viene tolto dalla lista). Scriviamo solo la funzione per le giocate secche:

(define (lotto-secco2-test num iter)
  (local (conta base urna ev estratti)
    (setq base (sequence 0 90))
    (setq conta 0)
    (for (i 1 iter)
      ; scommessa secca
      ; generazione numeri giocati (1 o 2 o 3 o 4 o 5)
      (setq urna base)
      (setq ev '())
      (for (i 0 (- num 1))
        (push (pop urna (+ 1 (rand (- 90 i)))) ev -1)
      )
      ; generazione numeri vincenti (5)
      (setq urna base)
      (setq estratti '())
      (for (i 0 4)
        (push (pop urna (+ 1 (rand (- 90 i)))) estratti -1)
      )
      (setq res (length (difference estratti ev)))
      ;(if (= res (- 5 num))
      ;  (println ev { } estratti { } res)
      ;)
      ; confronto vincenti con numeri giocati
      (if (= res (- 5 num)) (++ conta))
    )
    (div conta iter)))

Vediamo i risultati:

(lotto-secco2-test 1 1e6)
;-> 0.055617
(lotto-secco2-test 2 1e6)
;-> 0.002464
(lotto-secco2-test 3 1e6)
;-> 8.4e-005
(lotto-secco2-test 4 1e7)
;-> 1.6e-006
(time (println (lotto-secco2-test 5 1e8)))
;-> 4e-008
;-> 393129.225


-------------------
Hash-map e contesti
-------------------

In newLISP quando creiamo una hash-map creiamo un dizionario di contesto con lo stesso nome (in pratica una hash-map viene rappresentata con un contesto).
Nota:
Chiamiamo spesso i dizionari di contesto "hash", ma non c'è alcuna funzione di hash alla base di esso. "Hash" è solo un nome conveniente poiché la maggior parte degli altri linguaggi implementa la funzionalità di ricerca utilizzando le funzioni di hash.
In newLISP i dizionari sono costruiti separatamente come alberi binari bilanciati rosso-nero e solo la radice di esso - il nome del contesto - fa parte dello spazio dei simboli principale. Quindi non si verifica alcun "inquinamento" dello spazio dei nomi.

Per vedere la lisa dei contesti attivi possiamo utilizzare la funzione seguente:

(define (contexts-lst)
  (filter context? (map eval (symbols))))

Se usiamo la funzione in una nuove REPL otteniamo:

(contexts-lst)
;-> (Class MAIN Tree)

I contesti "Class", "MAIN" e "Tree" sono dei contesti predefiniti.
Definiamo un nuovo contesto con una funzione:

(context 'demo)
;-> demo
(define (pippo a b) (+ a b))
;-> (lambda (a b) (+ a b))
(context MAIN)
;-> MAIN

(pippo 1 2)
;-> ERR: invalid function : (pippo 1 2)
(demo:pippo 1 2)
;-> 3

Vediamo come si è modificata la lista dei contesti:

(contexts-lst)
;-> (Class MAIN Tree demo)

Adesso scriviamo una funzione che prende n numeri diversi da una lista di numeri e utilizza una hash-map "myHash":

(define (rand-range min-val max-val)
  (+ min-val (rand (+ (- max-val min-val) 1))))
(define (sample-rand num min-val max-val)
  (local (value out)
    (cond ((> num (+ max-val (- min-val) 1)) '()) ; controllo
          (true
            ; creazione di una hashmap
            (new Tree 'myHash)
            (until (= (length (myHash)) num)
              ; genera valore casuale
              (setq value (rand-range min-val max-val))
              ; inserisce valore casuale nell'hash
              (myHash (string value) value))
              ; assegnazione dei valori dell'hasmap ad una list
              (setq out (myHash))
              (setq out (map last out))
              ; eliminazione dell'hashmap
              ; ELIMINARE IL COMMENTO SEGUENTE
              ; PER IL CORRETTO FUNZIONAMENTO
              ; DELLA FUNZIONE
              ;(delete 'myHash)
              (sort out)))))

Nella funzione, l'espressione che elimina la hash-map (delete 'myHash) è commentata. In questo modo la funzione genera sempre gli stessi risultati (quelli contenuti nella hash-map "myHash").

(sample-rand 5 1 100)
;-> (1 20 57 59 81)
(sample-rand 5 1 100)
;-> (1 20 57 59 81)
(sample-rand 5 1 100)
;-> (1 20 57 59 81)

Vediamo come è cambiata la lista dei contesti:

(contexts-lst)
;-> (Class MAIN Tree demo myHash)

A questo punto il problema è il seguente, come riconoscere un contesto con funzioni da un contesto che rappresenta una hash-map?

Se elenchiamo i valori della hash-map otteniamo:

(myHash)
;-> (("1" 1) ("20" 20) ("57" 57) ("59" 59) ("81" 81))
(length (myHash))
;-> 5

Se elenchiamo i valori del contesto otteniamo:

(demo)
;-> ()
(length (demo))
;-> 0

Quindi una hash-map contiene una lista di valori, mentre un contesto con funzioni ha la lista vuota () (e ha lunghezza pari a 0).
Vediamo come possiamo identificare questa differenza.

Stampiamo la lista dei contesti:

(dolist (_el (symbols))
  (if (context? (eval _el)) (println _el)))
;-> Class
;-> MAIN
;-> Tree
;-> demo
;-> myHash
;-> nil

Per filtrare solo i contesti che sono hash-map dobbiamo vedere la lunghezza della lista dei valori del contesto:

(dolist (_el (symbols))
  (if (context? (eval _el))
      (println (eval _el) { } (length (eval _el)))))
;-> Class 2
;-> MAIN 0
;-> Tree 0
;-> demo 0
;-> myHash 0
;-> nil

Purtroppo la funzione "lenght" ha bisogno della valutazione del contesto (length (contesto)) e non del contesto stesso (length contesto). Per fare questo l'unico metodo che ho trovato è quello di ricorrere alla funzione "eval-string":

(dolist (_el (symbols))
  (if (and (context? (eval _el))
      (not (= _el 'MAIN))
      (not (= _el 'Tree))
      (not (= _el 'Class)))
      (println (eval _el) { } (eval-string (string "(" _el ")")))))
;-> demo ()
;-> myHash (("1" 1) ("20" 20) ("57" 57) ("59" 59) ("81" 81))
;-> nil

Miglioriamo un pò la stampa dei risultati:

(dolist (_el (symbols))
  (if (and (context? (eval _el))
      (not (= _el 'MAIN))
      (not (= _el 'Tree))
      (not (= _el 'Class)))
    (begin
      (setq ctxlst (eval-string (string "(" _el ")")))
      (println (eval _el) { } (length ctxlst))
      (println (eval _el) { } (eval-string (string "(" _el ")"))))))
;-> demo 0
;-> demo ()
;-> myHash 5
;-> myHash (("1" 1) ("20" 20) ("57" 57) ("59" 59) ("81" 81))
;-> nil

Adesso scriviamo una funzione che filtra i contesti che sono hash-map:

(define (hashmap-lst)
  (let (ctxlst '())
    (dolist (_el (symbols))
      (if (and (context? (eval _el))
          (not (= _el 'MAIN))
          (not (= _el 'Tree))
          (not (= _el 'Class)))
          (push (list (eval _el) (eval-string (string "(" _el ")"))) ctxlst -1)))
    ctxlst))

(hashmap-lst)
;-> ((demo ()) (myHash (("1" 1) ("20" 20) ("57" 57) ("59" 59) ("81" 81))))

Con la funzione "length" possiamo controllare se i due contesti hanno valori oppure sono la lista vuota:

(length (demo))
;-> 0
(length (myHash))
;-> 5

Eliminiamo i valori della hash-map "myHash":

(myHash "36" nil)
(myHash "48" nil)
(myHash "75" nil)
(myHash "83" nil)
(myHash "90" nil)

(hashmap-lst)
;-> ((demo ()) (myHash ()))

In questa ultima situazione non siamo in grado di stabilire se il contesto "myHash" (o "demo") è una hash-map.

Comunque quello che abbiamo visto ci permette di migliorare la funzione "free-vars" in modo da elencare anche le hash-map:

(define (free-vars _ctx)
"Print a list of free symbols/variables"
  (local (_vars _lst-ctx)
    (if (= _ctx nil) (setq _ctx (context)))
    (setq _vars '())
    (setq _lst-ctx '())
    (dolist (_el (symbols _ctx))
      ;(if (= _el myHash) (println _el))
      (if (and (context? (eval _el))
               (not (= _el '_ctx))
               (not (= _el 'MAIN))
               (not (= _el 'Tree))
               (not (= _el 'Class)))
          (push (eval _el) _lst-ctx -1))
      (if (and (not (lambda? (eval _el)))
               (not (primitive? (eval _el)))
               (not (protected? _el))
               (not (global? _el))
               (not (= _el '_ctx))
               (not (= _el '_lst-ctx))
               (not (= _el '_vars))
               (not (= _el '_el))
               (not (= _el '_v)))
          (push _el _vars -1))
    )
    (dolist (_v _vars)
      (if (eval _v)
        (println _v { } (eval _v)))
    )
    (dolist (_v _lst-ctx)
      (if (eval _v)
        (println (eval _v) { } (eval-string (string "(" _v ")")))
      )
    )
    nil))

Ricreiamo i valori nella hash-map "myHash":

(sample-rand 5 1 100)

E creiamo una variabile:

(setq z 999)

Adesso possiamo provare la funzione free-:vars

(free-vars)
;-> ctxlst (("1" 1) ("20" 20) ("57" 57) ("59" 59) ("81" 81))
;-> z 999
;-> demo ()
;-> myHash (("1" 1) ("20" 20) ("57" 57) ("59" 59) ("81" 81))

Suggerimento di ralph.ronnquist:

1) a "hashmap" is a context without default functor, i.e.
(and (context? S) (nil? (sym (term S) S nil)))

2) using the symbol as functor results in its list if entries, i.e.
(apply S)

La seguente funzione è un tentativo (parzialmente fallito) di identificare le hash-map:

(define (test)
  (dolist (el (symbols))
    (if (and (context? (eval el))
             ;(= el 'myHash)
             ; suggerimento di ralph.ronnquist
             (nil? (eval (sym (term el) el nil))))
        (begin
          ; (prefix el) -> stringa
          (println "(prefix el): " (prefix el))
          ; (term el) -> stringa
          (println "(term el): " (term el))
          (println "(sym (term el)): " (sym (term el)))
          ; converte la stringa in simbolo
          (setq S (sym (term el) el nil))
          (println "S: " S)
          (println (eval (sym (term el) el nil)))
          ;(apply S)
          (println "------------")
        )
    )))

(test)
;-> (prefix el): MAIN
;-> (term el): Tree
;-> (sym (term el)): Tree
;-> S: Tree:Tree
;-> nil
;-> ------------
;-> (prefix el): MAIN
;-> (term el): demo
;-> (sym (term el)): demo
;-> S: demo:demo
;-> nil
;-> ------------
;-> (prefix el): MAIN
;-> (term el): myHash
;-> (sym (term el)): myHash
;-> S: myHash:myHash
;-> nil
;-> ------------

Nota: un contesto può contenere funzioni ed essere una hash-map Per esempio, modifichiamo il contesto "demo" creando una hash-map con lo stesso nome:

(demo "1" 1)
;-> 1
(demo "2" 2)
;-> 2

Adesso "demo" è un contesto con funzioni e una hash-map:

(demo:pippo 3 5)
;-> 8
(demo)
;-> (("1" 1) ("2" 2))

Possiamo creare anche il "funtore" del contesto "demo":

(context 'demo)
(define (demo)
  (println "Functor"))
(context MAIN)

(demo:demo)
;-> Functor

Invece di utilizzare (context 'demo) o (define (demo:demo)...) per creare un hash-map è meglio utilizzare (new Tree 'demo): il risultato è lo stesso, tranne che viene creato il funtore di default "demo:demo" come costante (con valore nil)).

Nota:
Se assegniamo una hash-map ad un simbolo/variabile non viene creata una copia della hash-map, ma solo un simbolo che punta alla hash-map originale. In questo modo i valori delle due hash-map sono sempre uguali anche quando modifichiamo una sola delle due hash-map(perchè i simboli delle due hash-map puntano agli stessi indirizzi di memoria).
Per esempio:

(setq hh myHash)
;-> myHash
(hh)
;-> (("1" 1) ("20" 20) ("57" 57) ("59" 59) ("81" 81))

Modifichiamo un valore di hh:
(hh "1" 0)
;-> 0
Modifichiamo un valore di myHash:
(myHash "20" 0)
;-> 0

Vediamo che i valori delle due-hashmap sono gli stessi:
(hh)
;-> (("1" 0) ("20" 0) ("57" 57) ("59" 59) ("81" 81))
(myHash)
;-> (("1" 0) ("20" 0) ("57" 57) ("59" 59) ("81" 81))

Nota: per una questione di stile, è meglio definire in anticipo tutti gli hash e creare altri contesti nel contesto MAIN come tutti gli altri simboli utilizzati a livello globale. In progetti newLISP più grandi o quando si lavora con diversi programmatori sullo stesso progetto in questo modo si evitano conflitti/problemi.


-----------------
Numeri di Motzkin
-----------------

Dati n punti su una circonferenza, si definisce come numero di Motzkin, M(n), il numero di modi in cui si possono tracciare tra questi delle corde non intersecanti, senza che tutti i punti siano necessariamente toccati da una corda.
La successione di questi numeri interi prende il nome dal matematico americano Theodore Motzkin.

Sequenza OEIS A001006:
  1, 1, 2, 4, 9, 21, 51, 127, 323, 835, 2188, 5798, 15511, 41835, 113634,
  310572, 853467, 2356779, 6536382, 18199284, 50852019, 142547559,
  400763223, 1129760415, 3192727797, 9043402501, 25669818476, 73007772802,
  208023278209, ...

I numeri di Motzkin soddisfano la seguente relazione ricorsiva:

                (n-2)                2*n + 1            3*n - 3
  M(n) = M(n-1) + ∑ M(i)*M(n-2-i) = ---------*M(n-1) + ---------*M(n-2)
                i=0                  n + 2              n + 2

Funzione che usa la ricorsione per calcolare il numero di Motzkin:

(define (motzkin1 num)
  (cond ((or (= num 0) (= num 1))
         1)
        (true
          (/ (+ (* (+ (* 2 num) 1) (motzkin1 (- num 1)))
                (* (- (* 3 num) 3) (motzkin1 (- num 2))))
             (+ num 2))
        )))

(map motzkin1 (sequence 0 20))
;-> (1 1 2 4 9 21 51 127 323 835 2188 5798 15511 41835 113634 310572
;->  853467 2356779 6536382 18199284 50852019)

Funzione che usa la programmazione dinamica per calcolare il numero di Motzkin:

(setq pp (array (+ 4 1) '(0)))

(define (motzkin2 num)
  (let (dp (array (+ num 1) '(0)))
    (cond ((= num 0)
           (setf (dp 0) 1))
          ((= num 1)
           (setf (dp 0) 1)
           (setf (dp 1) 1))
          ((> num 1)
           (setf (dp 0) 1)
           (setf (dp 1) 1)
           (for (i 2 num)
             (setf (dp i) (/ (+ (* (+ (* 2 i) 1) (dp (- i 1)))
                                (* (- (* 3 i) 3) (dp (- i 2))))
                             (+ i 2)))))
    )
    (dp num)))

(map motzkin2 (sequence 0 20))
;-> (1 1 2 4 9 21 51 127 323 835 2188 5798 15511 41835 113634 310572
;->  853467 2356779 6536382 18199284 50852019)

Poichè utilizziamo solo gli ultimi due valori della matrice dp per calcolare il valore successivo, allora possiamo evitare di usare una matrice ed utilizzare semplicemente due variabili a e b. Questo velocizza un pò la funzione, ma perdiamo i valori dei numeri di Motzkin precedenti (che invece vengono mantenuti con la matrice dp).

Funzione che usa l'iterazione pura per calcolare il numero di Motzkin:

(define (motzkin3 num)
  (let ((a 1) (b 1) (c 0))
    (cond ((or (= num 0) (= num 1))
           (setq b 1))
          ((> num 1)
           (for (i 2 num)
             (setq c (/ (+ (* (+ (* 2 i) 1) b)
                           (* (- (* 3 i) 3) a))
                           (+ i 2)))
             (setq a b)
             (setq b c)))
    )
  b))

(map motzkin3 (sequence 0 20))
;-> (1 1 2 4 9 21 51 127 323 835 2188 5798 15511 41835 113634 310572
;->  853467 2356779 6536382 18199284 50852019)

I valori dei numeri di Motzkin crescono molto velocemente, quindi per calcolarli in modo corretto occorre utilizzare i big integer.
La seguente espressione produce un risultato errato:

(motzkin3 100)
;-> -17402571795490030 ;risultato errato

Modifichiamo la funzione che usa la programmazione dinamica per utilizzare i big integer:

(define (motzkin-big num)
  (let (dp (array (+ num 1) '(0)))
    (cond ((= num 0)
           (setf (dp 0) 1L))
          ((= num 1)
           (setf (dp 0) 1L)
           (setf (dp 1) 1L))
          ((> num 1)
           (setf (dp 0) 1L)
           (setf (dp 1) 1L)
           (for (i 2 num)
             (setf (dp i) (/ (+ (* (+ (* 2L i) 1L) (dp (- i 1)))
                                (* (- (* 3L i) 3L) (dp (- i 2))))
                             (+ i 2L)))))
    )
    (dp num)))

(motzkin-big 10)
;-> 2188L
(motzkin-big 100)
;-> 737415571391164350797051905752637361193303669L


------------------
Numeri di Narayana
------------------

I numeri Narayana formano una matrice triangolare di numeri naturali, chiamato triangolo di Narayana, che si verificano in vari problemi di calcolo combinatorio (parole di Dick, cammini reticolari monotoni, alberi con radice, ecc.).

I numeri di Narayana possono essere espressi in termini di coefficienti binomiali nel modo seguente:

  N(n,k) = (1/n)*binom(n,k)*binom(n, k-1)

Le prime dieci righe ti tale disposizione sono:[3]

k =       1   2   3   4   5   6   7   8   9   10
------------------------------------------------
n = 1  |  1
    2  |  1   1
    3  |  1   3   1
    4  |  1   6   6   1
    5  |  1  10  20  10   1
    6  |  1  15  50  50  15   1
    7  |  1  21 105 175 105  21   1
    8  |  1  28 196 490 490 196  28   1
    9  |  1  36 336 1176 1764 1176 336 36 1
   10  |  1  45 540 2520 5292 5292 2520 540 45 1

Più in generale, si può dimostrare che il triangolo Narayana è simmetrico:

   N(n,k) = N(n,n-k+1)

La somma delle righe in questo triangolo è uguale ai numeri catalani:

   N(n,1) + N(n,2) + N(n,3) + ... + N(n,n) = Catalan(n)

Sequenza OEIS A001263:
	1, 1, 1, 1, 3, 1, 1, 6, 6, 1, 1, 10, 20, 10, 1, 1, 15, 50, 50, 15, 1, 1,
  21, 105, 175, 105, 21, 1, 1, 28, 196, 490, 490, 196, 28, 1, 1, 36, 336,
  1176, 1764, 1176, 336, 36, 1, 1, 45, 540, 2520, 5292, 5292, 2520, 540, 45,
  1, 1, 55, 825, 4950, 13860, 19404, 13860, 4950, 825, ...

Scriviamo una funzione che calcola il numero di Narayana per un dato n e k:

(define (binom num k)
  (cond ((> k num) 0)
        ((zero? k) 1)
        (true
          (let (r 1L)
            (for (d 1 k)
              (setq r (/ (* r num) d))
              (-- num)
            )
          r))))

(define (narayana n k)
  (/ (* (binom n k) (binom n (- k 1))) n))

(narayana 5 4)
;-> 10L
(narayana 7 4)
;-> 175L

Adesso scriviamo la funzione per calcolare il triangolo di narayana fino ad un dato n e k:

(define (triangle-narayana n k)
  (local (out kappa)
    (setq out '())
    (for (i 1 n)
      ; lista dei numeri di Narajana da 1 a k per un determinato n
      (setq kappa '())
      (for (j 1 k)
        (push (narayana i j) kappa -1)
      )
      (push (list i kappa) out -1)
    )
    out))

(triangle-narayana 10 10)
;-> ((1 (1L 0 0 0 0 0 0 0 0 0))
;->  (2 (1L 1L 0 0 0 0 0 0 0 0))
;->  (3 (1L 3L 1L 0 0 0 0 0 0 0))
;->  (4 (1L 6L 6L 1L 0 0 0 0 0 0))
;->  (5 (1L 10L 20L 10L 1L 0 0 0 0 0))
;->  (6 (1L 15L 50L 50L 15L 1L 0 0 0 0))
;->  (7 (1L 21L 105L 175L 105L 21L 1L 0 0 0))
;->  (8 (1L 28L 196L 490L 490L 196L 28L 1L 0 0))
;->  (9 (1L 36L 336L 1176L 1764L 1176L 336L 36L 1L 0))
;->  (10 (1L 45L 540L 2520L 5292L 5292L 2520L 540L 45L 1L)))

Funzione per calcolare la sequenza OEIS:

(define (A001263 n k)
  (local (out nara)
    (setq out '())
    (for (i 1 n)
      (for (j 1 k)
        (setq nara (narayana i j))
        (if (!= nara 0)
            (push (narayana i j) out -1)
        )
      )
    )
    out))

(A001263 10 10)
;-> (1L 1L 1L 1L 3L 1L 1L 6L 6L 1L 1L 10L 20L 10L 1L 1L 15L 50L 50L 15L
;->  1L 1L 21L 105L 175L 105L 21L 1L 1L 28L 196L 490L 490L 196L 28L 1L
;->  1L 36L 336L 1176L 1764L 1176L 336L 36L 1L 1L 45L 540L 2520L 5292L
;->  5292L 2520L 540L 45L 1L)


----------------------------------------
Permutazioni, Disposizioni, Combinazioni
----------------------------------------

Formule per il calcolo del numero di permutazioni, disposizioni e combinazioni
------------------------------------------------------------------------------
Permutazione di n elementi: P(n) = n!
Permutazioni di n elementi con un elemento ripetuto m volte: P(n,m) = n!/m!
Permutazioni di n elementi con "a" ripetuto k1 volte, "b" ripetuto k2 volte, "c" ripetuto k3 volte, ecc.: P(n,k1!,k2!,k3!,...,km!) = n!/(k1!*k2!*k3!*...*km!)
Permutazioni cicliche di n elementi in una circonferenza: PC(n) = (n - 1)!
Disposizioni semplici di n elementi presi k a k: D(n,k) = n*(n-2)* ... *(n - k + 1)
Disposizioni con ripetizione di n elementi presi k a k con possibile ripetizione di ogni elemento fino a k volte: DR(n,k) = n^k
Combinazioni semplici di n elementi presi k a k: C(n,k) = D(n,k) / P(k) = (n*(n-2)* ... *(n - k + 1))/k!
Combinazioni con ripetizione di n elementi con possibile ripetizione di ogni elemento fino a k volte: CR(n,k) = C(n+k-1,k)

Permutazioni - P(n)
-------------------
Dati n elementi distinti, si dicono permutazioni, P(n), i gruppi che si possono formare in modo che:
- ogni gruppo contenga tutti gli n elementi (ogni elemento contato una sola volta)
- ogni gruppo differisca dagli altri solo per l'ordine degli elementi

Nota: una permutazione è una corrispondenza biunivoca di un insieme con se stesso.

Esempi:
Per n = 2: (ab ba)
Per n = 3: (abc acb bac bca cab cba)
Per n = 4: (abcd abdc acbd acdb adbc adcb
            bacd badc bcad bcda bdac bdca
            cabd cadb cbad cbda cdab cdba
            dabc dacb dbac dbca dcab dcba)

Numero di permutazioni di n elementi: P(n) = n!

Funzione per il calcolo del Fattoriale:
  fattoriale(n) = n!

(define (fact num)
  (if (zero? num)
      1
      (let (out 1L)
        (for (x 1L num)
          (setq out (* out x))))))

Funzione per il calcolo del numero di Permutazioni:
  P(n) = n!

(define (P n) (fact n))

Permutazioni di n elementi non tutti diversi - PR(n,k1,k2,k3,...km)
-------------------------------------------------------------
Queste permutazioni si hanno quando:
- negli n elementi da permutare ve ne è uno ripetuto m volte
- oppure ve ne sono diversi ripetuti, a1 ripetuto k1 volte, a2 ripetuto k2 volte, a3 ripetuto k3 volte, ecc.
Esempio:
Ad esempio, se vogliamo costruire le permutazioni di "abcc" prendiamo le permutazioni di 4 elementi, abcd e sostituiamo c al posto di d, poi eliminiamo le permutazioni uguali:
Per n = 4: (abcd abdc acbd acdbadbc adcb
            bacd badc bcad bcda bdac bdca
            cabd cadb cbad cbda cdab cdba
            dabc dacb dbac dbca dcab dcba)

Sostituiamo:
(abcc abcc acbc accbacbc accb
 bacc bacc bcac bcca bcac bcca
 cabc cacb cbac cbca ccab ccba
 cabc cacb cbac cbca ccab ccba)

Eliminiamo i doppioni:
(abccabcc acbcaccbacbc accb
 baccbacc bcacbccabcac bcca
 cabccacbcbaccbcaccabccba
 cabc cacb cbac cbca ccab ccba)

Si procede allo stesso modo se gli oggetti ripetuti sono più di uno.

Numero di prmutazioni di n elementi non tutti diversi: PR(n, k1, k2, k3,...,km) = n! / k1!*k2!*k3!*...*km!

Funzione per il calcolo del numero di Permutazioni con ripetizione:
  PR(n, k1, k2, k3,...,km) = n! / k1!*k2!*k3!*...*km!

(define (PR n rip)
  (* (fact n) (apply * (map fact q))))

(PR 10 '(2 3 4))
;-> 43545600L

Permutazioni cicliche - PC(n)
-----------------------------
Sono le permutazioni di n elementi lungo una circonferenza (o circuito chiuso).
Vediamo la dimostrazione seguendo un esempio:
Esempio:
lista = A B C
permutazioni semplici = (A B C) (B A C) (B C A) (A C B) (C A B) (C B A)
Se rappresentiamo queste permutazioni intorno ad un cerchio, notiamo che alcune di loro sono equivalenti:

      A           B           B           A           C           C
    C   B       C   A       A   C       B   C       B   A       A   B
     (1)         (2)         (3)         (4)         (5)         (6)

La (1), la (3) e la (5) sono equivalenti (sono tutte rotazioni una dell'altra).
La (2), la (4) e la (6) sono equivalenti (sono tutte rotazioni una dell'altra).

Quindi abbiamo solo due permutazioni circolari uniche. Poichè il numero di permutazioni semplici vale n!, ed ogni permutazione semplice ha n permutazioni circolari equivalenti, possiamo calcolare il numero di permutazioni circolari in questo modo:

numero_permutazioni_circolari(n) = numero_permutazioni_semplici(n) / n = n!/n = (n - 1)!

Numero di permutazioni cicliche: PC(n) = (n-1)!

Funzione per il calcolo del numero di Permutazioni cicliche:
  PC(n) = (n - 1)!

(define (PC n) (fact (- n 1)))

Disposizioni semplici - D(n,k)
------------------------------
Dati n elementi distinti e un numero k<=n si dicono disposizioni di questi n elementi, presi a k a k (o di classe k), D(n,k), tutti i gruppi che si possono formare con gli elementi dati, in modo che:
- ogni gruppo contenga k elementi distinti
- due gruppi qualunque differiscano fra loro per qualche elemento oppure per l'ordine in cui gli elementi sono disposti

Nota: nelle disposizioni ha importanza l'ordine degli elementi.

Esempi:
Le disposizioni semplici di 3 elementi (abc) presi a 2 a 2 sono:
(ab ac ba bc ca cb)
Le disposizioni semplici di 4 elementi (abcd) presi a 3 a 3 sono:
(abc abd acb acd adb adc bac bad
 bca bcd bda bdc cab cad cba cbd
 cda cdb dab dac dba dbc dca dcb)

Nota. Se tutti gli elementi sono distinti (cioè k=n), allora la formula è uguale a quella delle permutazioni: D(n,k=n) = n!.
Se invece gli elementi sono tutti uguali k=1, c'è una sola disposizione semplice: D(n,1) = 5.

Numero di disposizioni semplici: D(n,k) = n(n-1)(n-2)...(n-k+1) = n!/(n - k)! = n!/(n - k)!

Funzione per il calcolo del numero di Disposizioni semplici:
  D(n,k) = n(n-1)(n-2)...(n-k+1) = n!/(n - k)!

(define (D n k)
  (/ (fact n) (fact (- n k))))

(define (D2 n k)
  (let (out 1L)
    (for (i 0 (- k 1))
      (setq out (* out (- n i)))
    )
    out))

(D 3 2)
;-> 6L
(D2 3 2)
;-> 6L
(D 12 6)
;-> 665280L
(D2 12 6)
;-> 665280L

Esempio:
A una gara partecipano 10 atleti. Quante sono le possibili disposizioni dei primi tre posti sul podio?
I dati del problema sono n = 10 e k = 3.
Le disposizioni semplici sono D(10,3) = 720
(D 10 3)
;-> 720L

Disposizioni con ripetizione - DR(n,k)
-------------------------------------
Dati n elementi distinti e un numero k<=n si dicono disposizioni con ripetizione di questi n elementi, presi a k a k (o di classe k), D(n,k), tutti i gruppi che si possono formare con gli elementi dati, in modo che:
- ogni gruppo contenga k elementi non necessariamente distinti
- ogni elemento possa trovarsi ripetuto nel gruppo fino a k volte
- due gruppi qualunque differiscano fra loro per qualche elemento oppure per l'ordine in cui gli elementi sono disposti
Esempi:
Le disposizioni con ripetizione di 3 elementi (abc) presi a 2 a 2 sono:
(aa ab ac ba bb bc ca cb cc)
Le disposizioni con ripetizione di 4 elementi (abcd) presi a 3 a 3 sono:
(aaa aab aac aad aba abb abc abd
 aca acb acc acd ada adb adc add
 baa bab bac bad bba bbb bbc bbd
 bca bcb bcc bcd bda bdb bdc bdd
 caa cab cac cad cba cbb cbc cbd
 cca ccb ccc ccd cda cdb cdc cdd
 daa dab dac dad dba dbb dbc dbd
 dca dcb dcc dcd dda ddb ddc ddd)

Numero di disposizioni con ripetizione: DR(n,k) = n^k

Funzione per il calcolo del numero di Disposizioni con ripetizione:
  DR(n,k) = n^k

(define (DR n k) (pow n k))

Esempio:
Con tre lettere A,B,C quante stringhe diverse da due lettere si possono creare?
I dati del problema sono n = 3 e k = 2.
Le disposizioni con ripetizione di classe k=2 sono DR(3,2) = 3^2 = 9
(DR 3 2)
;-> 9

Nota: Ecco tutte le 9 disposizioni con ripetizione possibili. Le disposizioni semplici (senza ripetizione) sono invece 3*2=6. Questo esempio rende più chiara la differenza tra le disposizioni semplici e le disposizioni con ripetizione.
  Disposizioni            Disposizioni
  con ripetizione         senza ripetizione
  AA                      AA (non valida)
  AB                      AB
  AC                      AC
  BA                      BA
  BB                      BB (non valida)
  BC                      BC
  CA                      CA
  CB                      CB
  CC                      CC (non valida)

Combinazioni semplici - C(n,k)
------------------------------
Dati n elementi distinti e un numero intero positivo k<=n, si chiamano combinazioni C(n,k) di questi n elementi, a k a k (o di classe k), tutti gruppi che si possono formare con gli elementi dati, in modo che:
- ciascun gruppo contenga k elementi
- due guppi qualunque differiscano per almeno un elemento.

Nota: in una combinazione l'ordine degli elementi non è importante.

Esempi:
Le combinazioni di 3 elementi (abc) presi a 2 a 2 sono:
(ab ac bc)
Le combinazioni di 4 elementi (abcd) presi a 3 a 3 sono:
(abc abd acd bcd)

Numero di combinazioni semplici:
C(n,k) = D(n,k) / P(k)
C(n,k) = [n*(n-1)*(n-2)*...*(n-k+1)] / k! = n! / (k!*(n - k)!)

Funzione per il calcolo del numero di Combinazioni semplici:
  C(n,k) = [n*(n-1)*(n-2)*...*(n-k+1)] / k! = n! / (k!*(n - k)!)

Nota: L'espressione n! / (k!*(n - k)!) è il cofficiente binomiale.

Funzione per il calcolo del Coefficiente binomiale:

(define (binom num k)
  (cond ((> k num) 0)
        ((zero? k) 1)
        (true
          (let (r 1L)
            (for (d 1 k)
              (setq r (/ (* r num) d))
              (-- num)
            )
          r))))

(define (C n k) (binom n k))

(C 10 2)
;-> 45L

Esempio:
Dato un insieme con le tre lettere I = (A B C), trovare le combinazioni di classe 2 semplici, ossia i raggruppamenti possibili delle lettere prese a coppia.
In questo caso n = 3 e k = 2.
Applicando la formula per il calcolo delle combinazioni semplici C(3,2)= 3!/(2!*(3−2)!) = 6/2 = 3.
Le combinazioni semplici possibili sono tre: (A B), (A C), (B C).

Combinazioni con ripetizione
----------------------------
Dati n elementi distinti e un numero intero positivo k<=n, si chiamano combinazioni con ripetizione CR(n,k) di questi n elementi, a k a k (o di classe k), tutti gruppi che si possono formare con gli elementi dati, in modo che:
- ciascun gruppo contenga k elementi
- ogni elemento possa trovarsi ripetuto nel gruppo fino a k volte
- due gruppi qualunque differiscano per almeno un elemento
Esempi:
Le combinazioni con ripetizione di 3 elementi (abc) presi a 2 a 2 sono:
(aa ab ac bb bc cc)
Le combinazioni con ripetizione di 4 elementi (abcd) presi a 3 a 3 sono:
(aaa aab aac aad abb abc abd acc acd add
 bbb bbc bbd bcc bcd bdd ccc ccd cdd ddd)

Numero di combinazioni con ripetizione:
CR(n,k) = C(n+k-1,k)

Funzione per il calcolo del numero di Combinazioni con ripetizione:
  CR(n,k) = C(n+k-1,k)

(define (CR n k) (binom (+ n k (- 1)) k))

(CR 10 2)
;-> 55L

Esempio:
Dato un insieme con le tre lettere I = (A B C), trovare le combinazioni di classe 2 semplici, ossia i raggruppamenti possibili delle lettere prese a coppia. In ogni coppia può esserci anche due volte la stessa lettera.
In questo caso n = 3 e k = 2.
Applicando la formula per il calcolo delle combinazioni con ripetizione CR(3,2)= (3+2-1)!/(2!*(3−1)!) = 24/4 = 6.
Le combinazioni con ripetizione possibili sono sei: (A A), (A B), (A C), (B B), (B C), (C C).

La differenza tra disposizioni e combinazioni
---------------------------------------------
Nelle disposizioni è importante l'ordine degli elementi. Nelle combinazioni, invece, non conta l'ordine degli elementi.
Esempio.
Le stringhe AB e BA sono due disposizioni diverse ma identificano una sola combinazione (AB). Le combinazioni sono insiemi di lettere in cui l'ordine non conta. Le disposizioni sono invece delle stringhe dove l'ordine è importante.

La differenza tra disposizioni e permutazioni
---------------------------------------------
Nelle disposizioni definisco raggruppamenti con k<n elementi.
Nelle permutazioni, invece, prendo in considerazione dei raggruppamenti con n elementi.
Nota. Se k=n il numero delle disposizioni semplici è uguale a quello delle permutazioni.

Come risolvere i problemi di Calcolo Combinatorio
-------------------------------------------------
Diagramma per capire se usare una permutazione, una disposizione o una combinazione.

                          +--------------------------+
                          |  Nei raggruppamenti      |
                          |  l'ordine è importante?  |
                          +--------------------------+
                             /                   \
                            /                     \
                           /                       \
                       +------+                 +------+
                       |  SI  |                 |  NO  |
                       +------+                 +------+
                          |                         |
                          |                         |
           +-----------------------------+   +--------------+
           | Permutazioni o Disposizioni |   | Combinazioni |
           +-----------------------------+   +--------------+
                         |                         |
                         |                         |
                   +---------+              +-------------------+
                   | k = n ? |              | Elemento ripetuto |
                   +---------+              | nel gruppo?       |
                     /     \                +-------------------+
                    /       \                     /       \
             +------+       +------+        +------+     +------+
             |  SI  |       |  NO  |        |  SI  |     |  NO  |
             +------+       +------+        +------+     +------+
                /               \              /               \
               /                 \            /                 \
    +--------------+    +--------------+   +--------------+   +--------------+
    | Permutazioni |    | Disposizioni |   | Combinazioni |   | Combinazioni |
    +--------------+    +--------------+   | Semplici     |   | con Ripetiz  |
           /                          \    +--------------+   +--------------+
          /                            \
         /                              \
   +----------------------+           +-------------------+
   | I k (=n) elementi    |           | Elemento ripetuto |
   | sono tutti distinti? |           | nel gruppo?       |
   +----------------------+           +-------------------+
        /            \                     /            \
       /              \                   /              \
   +------+        +------+            +------+        +------+
   |  SI  |        |  NO  |            |  SI  |        |  NO  |
   +------+        +------+            +------+        +------+
      |                |                  |                 |
      |                |                  |                 |
+--------------+   +--------------+   +--------------+    +--------------+
| Permutazioni |   | Permutazioni |   | Disposizioni |    | Disposizioni |
| Semplici     |   | con Ripetiz  |   | con ripetiz  |    | Semplici     |
+--------------+   +--------------+   +--------------+    +--------------+

Esempio 1
---------
Le targhe automobilistiche sono formate nel modo seguente:

  lettera lettera numero numero numero lettera lettera

Quante auto si possono immatricolare con l'alfabeto internazionale di 26 lettere e i numeri da 0 a 9?

Abbiamo 3 raggruppamenti diversi:

1) lettera lettera

In questo caso k = 2 e n = 26.
L'ordine ha importanza? si (e poichè k ≠ n, allora dobbiamo usare le disposizioni).
Un elemento può essere ripetuto nel gruppo? si

Quindi si tratta di Disposizioni con ripetizione di classe k. Quindi il primo gruppo può essere raggruppato in:

DR(26,2) = 26^2 = 676

2) numero numero numero

In questo caso k = 3 e n = 10.
L'ordine ha importanza? si (e poichè k ≠ n, allora dobbiamo usare le disposizioni).
Un elemento può essere ripetuto nel gruppo? si

Quindi si tratta di Disposizioni con ripetizione di classe k. Quindi il primo gruppo può essere raggruppato in:

DR(10,3) = 10^3 = 1000

3) lettera lettera

In questo caso k = 2 e n = 26.
L'ordine ha importanza? si (e poichè k ≠ n, allora dobbiamo usare le disposizioni).
Un elemento può essere ripetuto nel gruppo? si

Quindi si tratta di Disposizioni con ripetizione di classe k. Quindi il primo gruppo può essere raggruppato in:

DR(26,2) = 26^2 = 676

Quindi in totale si possono immatricolare:

DR(26,2) * DR(10,3) * DR(26,2) = 676 * 1000 * 676 = 456976000 auto

Esempio 2
---------
Una classe di 27 ex-compagni di scuola si rivedono per una cena. Alla fine, ognuno stringe la mano a tutti gli altri compagni. Quante strette di mano sono avvenute?

In questo caso k = 2 e n = 27.
L'ordine ha importanza? no, perchè le strette di mano non hanno un ordine (quindi dovremo usare le combinazioni).
Un elemento può essere ripetuto nel gruppo? no, perchè nessuno si stringe la mano da solo.

Quindi si tratta di Combinazioni semplici: C(27,2) = 27!/(2!*(27-2)!) = 351

Esempio 3
---------
Una squadra di 8 persone va a cena tutte le settimane dopo la partitadi calcetto.
Quante posizioni diverse possono assumere nella tavolata?

In questo caso k = 8 e n = 8.
L'ordine ha importanza? si, infatti ogni posizione è diversa in base all'ordine (e poichè k = n, allora dobbiamo usare le Permutazioni).
Un elemento può essere ripetuto nel gruppo: no, poichè gli elementi sono tutti distinti.

Quindi si tratta di Permutazioni semplici: P(8) = 8! = 40320 posizioni.


------------------------------------
Valore massimo di una lista ordinata
------------------------------------

Data una lista ordinata (di cui non si conosce il tipo di ordinamento) trovare l'elemento massimo.

Risolviamo il problema con due metodi: nel primo metodo utilizziamo le primitive di newLISP, mentre nel secondo metodo utilizziamo un algoritmo ad-hoc.

Primo metodo
------------
Per calcolare il valore massimo della lista usiamo la primitiva "max":

(define (f1 lst) (apply max lst))

Secondo metodo
--------------
Notiamo che la lista può essere ordinata in uno dei seguenti modi:
1) Strettamente decrescente
2) Decrescente
3) Tutti elementi uguali
4) Crescente
5) Strettamente decrescente
Il nostro algoritmo calcola la differenza tra il primo e l'ultimo elemento della lista:
- se la differenza vale 0, allora la lista contiene tutti numeri uguali (prendiamo un numero qualunque)
- se la differenza è maggiore di zero, allora la lista è decrescente o strettamente decrescente (prendiamo il primo numero della lista)
- se la differenza è minore di zero, allora la lista è crescente o strettamente crescente (prendiamo l'ultimo numero della lista)
Scriviamo la funzione che implementa l'algoritmo:

(define (f2 lst)
  (let (val (- (lst 0) (lst -1)))
    (cond ((> val 0) (lst 0))  ; lista decrescente
          ((< val 0) (lst -1)) ; lista crescente
          (true (lst 0)))))    ; tutti elementi uguali

Creiamo tre liste per effettuare i test:

(silent
(setq a (sequence 1 10000))
(setq b (reverse (copy a)))
(setq c (dup '10000 10000)))

(f1 a)
;-> 10000
(f1 b)
;-> 10000
(f1 c)
;-> 10000

(f2 a)
;-> 10000
(f2 b)
;-> 10000
(f2 c)
;-> 10000

Vediamo i tempi di esecuzione:

(time (f1 a) 10000)
;-> 1461.643
(time (f2 a) 10000)
;-> 512.362

(time (f1 b) 10000)
;-> 1461.585
(time (f2 b) 10000)
;-> 504.808

(time (f1 c) 10000)
;-> 1468.911
(time (f2 c) 10000)
;-> 516.737

Proviamo con liste più grandi (un milione di elementi):

(silent
(setq a (sequence 1 1000000))
(setq b (reverse (copy a)))
(setq c (dup '1000000 1000000)))

(time (f1 a) 100)
;-> 2009.643
(time (f2 a) 100)
;-> 730.251

(time (f1 b) 100)
;-> 1977.548
(time (f2 b) 100)
;-> 767.725

(time (f1 c) 100)
;-> 1948.062
(time (f2 c) 100)
;-> 729.342

In questo problema è molto più efficiente utilizzare l'algoritmo ad-hoc al posto delle primitive di newLISP (caso poco frequente).


--------------
Treni e binari
--------------

Dati gli orari di arrivo e partenza di tutti i treni che raggiungono una stazione ferroviaria, è trovare il numero minimo di binari necessari in modo che nessun treno rimanga in attesa.
Gli orari di arrivo e partenza dei treni sono contenuti in due liste, "arrivi" e "partenze".

Esempio:
Treno 1: arrivo=9:05 - partenza= 9:15
Treno 2: arrivo=9:40 - partenza= 12:05
Treno 3: arrivo=9:55 - partenza= 11:20
Treno 4: arrivo=11:10 - partenza= 11:25
Treno 5: arrivo=15:10 - partenza= 18:30
Treno 6: arrivo=18:10 - partenza= 20:20

lista arrivi = (9:05 9:40 9:55 11:00 15:10 18:10)
lista partenze = (9:15 12:05 11:20 11:30 18:30 20:20)

In questo caso occorrono 3 binari perchè ci sono tre treni tra le 11:10 e le 11:25.

Per risolvere il problema trasformiamo ogni orario di partenza e arrivo in un numero (in questo modo i valori rimangono ordinati):

 9:00 --> 900
 12:30 --> 1230
 ...

Adesso creiamo una lista unica ordinata con tutti gli orari di arrivo e di partenza:

; lista degli arrivi
(setq arr '(905 940 955 1110 1510 1830))
; lista delle partenze
(setq par '(915 1205 1120 1125 1830 2020))
; lista degli arrivi con il codice "A"
(setq arr-t (map (fn(x) (list x "A")) arr))
;->  ((905 "A") (940 "A") (955 "A") (1110 "A") (1510 "A") (1830 "A"))
; lista delle partenze con il codice "P"
(setq par-t (map (fn(x) (list x "P")) par))
;-> ((915 "P") (1205 "P") (1120 "P") (1125 "P") (1830 "P") (2020 "P"))
; lista ordinata con tutti gli orari
(setq all (sort (append arr-t par-t)))
;-> ((905 "A") (915 "P") (940 "A") (955 "A") (1110 "A") (1120 "P")
;->  (1125 "P") (1205 "P") (1510 "A") (1830 "A") (1830 "P") (2020 "P"))

Il prossimo passo è quello di attraversare la lista e contare i binari necessari per ogni arrivo o partenza nel modo seguente:
- se il codice vale "A", allora aumentiamo il numero dei binari necessari correnti
- se il codice vale "P", allora diminuiamo il numero dei binari necessari correnti
Il numero di binari necessari è pari al valore massimo del numero dei binari necessari correnti

; numero necessario di binari
(setq binari 0)
; numero necessario corrente di binari
(setq curr 0)
(dolist (el all)
  (cond ((= (el 1) "A") (++ curr))
        ((= (el 1) "P") (-- curr))
  )
  ; aggiorna il numero necessario di binari
  (setq binari (max binari curr))
  ; stampa la situazione corrente della stazione
  (println (el 0) { } (el 1) { } curr)
)
;-> 905 A 1
;-> 915 P 0
;-> 940 A 1
;-> 955 A 2
;-> 1110 A 3
;-> 1120 P 2
;-> 1125 P 1
;-> 1205 P 0
;-> 1510 A 1
;-> 1830 A 2
;-> 1830 P 1
;-> 2020 P 0

Vediamo il valore dei binari necessari:

binari
;-> 3

Scriviamo la funzione finale:

(define (station arr par)
  (local (arr-t par-t all curr binari)
    ; lista degli arrivi con il codice "A"
    (setq arr-t (map (fn(x) (list x "A")) arr))
    ; lista delle partenze con il codice "P"
    (setq par-t (map (fn(x) (list x "P")) par))
    ; lista ordinata con tutti gli orari
    (setq all (sort (append arr-t par-t)))
    ; numero necessario di binari
    (setq binari 0)
    ; numero necessario corrente di binari
    (setq curr 0)
    (dolist (el all)
      (cond ((= (el 1) "A") (++ curr))
            ((= (el 1) "P") (-- curr))
      )
      ; aggiorna il numero necessario di binari
      (setq binari (max binari curr))
      ; stampa la situazione corrente della stazione
      (println (el 0) { } (el 1) { } curr)
    )
    binari))

(station arr par)
;-> 905 A 1
;-> 915 P 0
;-> 940 A 1
;-> 955 A 2
;-> 1110 A 3
;-> 1120 P 2
;-> 1125 P 1
;-> 1205 P 0
;-> 1510 A 1
;-> 1830 A 2
;-> 1830 P 1
;-> 2020 P 0
;-> 3

Nota: questo algoritmo presuppone che i treni arrivino e partano nello stesso giorno.


----------------------
Mastermind (by Norman)
----------------------
All'indirizzo web http://newlisp.digidep.net/ troviamo la "Norman's Collection", una varietà di piccole utilità estremamente utili e creative scritte dall'utente Norman. Non tutte le utilità sono aggiornate a newLISP 10.7.5, ma sono molto interessanti per vedere lo stile di programmazione di un esperto.
Di seguito riportiamo il programma "mastermind" aggiornato (con piccole modifiche) alla versione 10.7.5.

#!/usr/bin/newlisp
;; ---------------------------------------------------------------------
;;
;; An ANSI based MASTERMIND v0.7
;;
;; Colors can occur more than once (more fun).
;; You have 10 guesses to finish in.
;;
;;
;; Enjoy, Norman 2006
;; uptated to newLISP 10.7.5 by cameyo, 25-Sep-2021
;; ---------------------------------------------------------------------
;; defines
;; ---------------------------------------------------------------------
(define r "\027[0;31m")
(define g "\027[0;32m")
(define b "\027[0;34m")
(define y "\027[0;33m")
(define m "\027[0;35m")
(define c "\027[0;36m")
(define w "\027[0;37m")
(define d "\027[0;0m" )
;------------------
(define (cls) (println "\027[H\027[2J"))
(define (line) (println "\t\t" (dup "-" 32)))
;------------------
(setq colors '(r g b y m c w))
(setq title (explode "MASTERMIND"))
;; ---------------------------------------------------------------------
;; header
;; ---------------------------------------------------------------------
(define (header)
	(cls)
	(seed (nth 6 (now)) )
	(setq solution (0 4 (randomize (flat (dup (randomize colors) 4)))))
	;(println "\t\t Solution: " solution)
	(line)
	(dotimes (l 3) (print "\t\t ") (dotimes (l 3) (dolist (l title) (print (eval (nth 0 (randomize colors))) l ))) (println d))
	(line)
	(println "\t\t " w "Type the keys: " r "R" g "G" b "B" y "Y" m "M" c "C" w "W" d " to play")
	(println "\t\t     " w {Press "\" to quit})
	(println "\t\t " c "!" d " - correct color and place")
	(println "\t\t " r "?" d " - correct color wrong place")
	(line)
	(println "\t\t [" g (dup "  #" 4) d "  ]")
	(line))
;; ---------------------------------------------------------------------
;; print colors
;; ---------------------------------------------------------------------
(define (output)
	(print "\t\t [ " )
	(dolist (p solution) (print (eval p) " @ " )) (println d " ] "))
;; ---------------------------------------------------------------------
;; handle input
;; ---------------------------------------------------------------------
(define (input)
	(setq pushed 0)
	(setq current '())
	(print "\t\t [ " )
	(while (!= pushed 4)
		(setq h (sym (char (read-key))))
       ; check quit game char
       (if (= h '\) (exit))
			 (if (find h colors)
				(begin
					(print (eval h) " @ " d)
					(push h current -1)
					(++ pushed)	)))
	(print " ]")
	(check))
;; ---------------------------------------------------------------------
;; check & print colors and positions
;; ---------------------------------------------------------------------
(define (check)
	(setq work solution)
	(print "\t[")
	'(for (x 0 3) (if (= (nth x current) (nth x work)) (begin (set-nth x current 'nil) (set-nth x work 'nil) (print c "!" d))))
	(for (x 0 3) (if (= (nth x current) (nth x work)) (begin (setf (current x) 'nil) (setf (work x) 'nil) (print c "!" d))))
	(setq current (clean nil? current))
	(if (empty? current) (begin (println "]") (line) (println "\t\t " g "Well Done!" d) (restart)))
	(setq work (clean nil? work))
	(dolist (x current) (if (setq i (find x work)) (begin (setf (work i) 'nil) (print r "?" d))))
	(println "]")
	(line))
;; ---------------------------------------------------------------------
;; restart
;; ---------------------------------------------------------------------
(define (restart)
	(line)
	(print "\t\t " w "Play Again? (" g "y" w "/" r "n" c"): " d)
	(if (= (lower-case (char (read-key))) "y") (game) (begin (println "\n\n") (exit))))
;; ---------------------------------------------------------------------
;; GAME
;; ---------------------------------------------------------------------
(define (game)
	(header)
	(setq counter 0)
	(while (!= counter 10) (input) (++ counter))
	(output)
	(restart))
;(exit)

Proviamo a fare una partita:

(game)
;-> --------------------------------
;->  MASTERMINDMASTERMINDMASTERMIND
;->  MASTERMINDMASTERMINDMASTERMIND
;->  MASTERMINDMASTERMINDMASTERMIND
;-> --------------------------------
;->  Type the keys: RGBYMCW to play
;->      Press \ to quit
;->  ! - correct color and place
;->  ? - correct color wrong place
;-> --------------------------------
;->  [  #  #  #  #  ]
;-> --------------------------------
;->  [  @  @  @  @  ]       [!]
;-> --------------------------------
;->  [  @  @  @  @  ]       []
;-> --------------------------------
;->  [  @  @  @  @  ]       [??]
;-> --------------------------------
;->  [  @  @  @  @  ]       [??]
;-> --------------------------------
;->  [  @  @  @  @  ]       [??]
;-> --------------------------------
;->  [  @  @  @  @  ]       [!?]
;-> --------------------------------
;->  [  @  @  @  @  ]       [!!]
;-> --------------------------------
;->  [  @  @  @  @  ]       [!!!]
;-> --------------------------------
;->  [  @  @  @  @  ]       [!!!]
;-> --------------------------------
;->  [  @  @  @  @  ]       [!!!!]
;-> --------------------------------
;->  Well Done!
;-> --------------------------------
;->  Play Again? (y/n):

Nota: vedi l'immagine "mastermind.png" nella cartella "data" per vedere l'output precedente a colori.


--------------
newLISP banner
--------------

(define (banner1)
  (println "███    ██ ███████ ██     ██ ██      ██ ███████ ██████ ")
  (println "████   ██ ██      ██     ██ ██      ██ ██      ██   ██")
  (println "██ ██  ██ █████   ██  █  ██ ██      ██ ███████ ██████ ")
  (println "██  ██ ██ ██      ██ ███ ██ ██      ██      ██ ██     ")
  (println "██   ████ ███████  ███ ███  ███████ ██ ███████ ██     ")
  (print))
(banner1)

(define (banner2)
  (println "                                        _|        _|_|_|    _|_|_|  _|_|_|  ")
  (println "_|_|_|      _|_|    _|      _|      _|  _|          _|    _|        _|    _|")
  (println "_|    _|  _|_|_|_|  _|      _|      _|  _|          _|      _|_|    _|_|_|  ")
  (println "_|    _|  _|          _|  _|  _|  _|    _|          _|          _|  _|      ")
  (println "_|    _|    _|_|_|      _|      _|      _|_|_|_|  _|_|_|  _|_|_|    _|      ")
  (print))
(banner2)

(define (banner3)
  (println "                                                                           LLLLLLLLLLL             IIIIIIIIII   SSSSSSSSSSSSSSS PPPPPPPPPPPPPPPPP   ")
  (println "                                                                           L:::::::::L             I::::::::I SS:::::::::::::::SP::::::::::::::::P  ")
  (println "                                                                           L:::::::::L             I::::::::IS:::::SSSSSS::::::SP::::::PPPPPP:::::P ")
  (println "                                                                           LL:::::::LL             II::::::IIS:::::S     SSSSSSSPP:::::P     P:::::P")
  (println "nnnn  nnnnnnnn        eeeeeeeeeeee  wwwwwww           wwwww           wwwwwwwL:::::L                 I::::I  S:::::S              P::::P     P:::::P")
  (println "n:::nn::::::::nn    ee::::::::::::ee w:::::w         w:::::w         w:::::w L:::::L                 I::::I  S:::::S              P::::P     P:::::P")
  (println "n::::::::::::::nn  e::::::eeeee:::::eew:::::w       w:::::::w       w:::::w  L:::::L                 I::::I   S::::SSSS           P::::PPPPPP:::::P ")
  (println "nn:::::::::::::::ne::::::e     e:::::e w:::::w     w:::::::::w     w:::::w   L:::::L                 I::::I    SS::::::SSSSS      P:::::::::::::PP  ")
  (println "  n:::::nnnn:::::ne:::::::eeeee::::::e  w:::::w   w:::::w:::::w   w:::::w    L:::::L                 I::::I      SSS::::::::SS    P::::PPPPPPPPP    ")
  (println "  n::::n    n::::ne:::::::::::::::::e    w:::::w w:::::w w:::::w w:::::w     L:::::L                 I::::I         SSSSSS::::S   P::::P            ")
  (println "  n::::n    n::::ne::::::eeeeeeeeeee      w:::::w:::::w   w:::::w:::::w      L:::::L                 I::::I              S:::::S  P::::P            ")
  (println "  n::::n    n::::ne:::::::e                w:::::::::w     w:::::::::w       L:::::L         LLLLLL  I::::I              S:::::S  P::::P            ")
  (println "  n::::n    n::::ne::::::::e                w:::::::w       w:::::::w      LL:::::::LLLLLLLLL:::::LII::::::IISSSSSSS     S:::::SPP::::::PP          ")
  (println "  n::::n    n::::n e::::::::eeeeeeee         w:::::w         w:::::w       L::::::::::::::::::::::LI::::::::IS::::::SSSSSS:::::SP::::::::P          ")
  (println "  n::::n    n::::n  ee:::::::::::::e          w:::w           w:::w        L::::::::::::::::::::::LI::::::::IS:::::::::::::::SS P::::::::P          ")
  (println "  nnnnnn    nnnnnn    eeeeeeeeeeeeee           www             www         LLLLLLLLLLLLLLLLLLLLLLLLIIIIIIIIII SSSSSSSSSSSSSSS   PPPPPPPPPP          ")
  (print))
(banner3)

(define (banner4)
(println "                       __    _________ ____ ")
(println "   ____  ___ _      __/ /   /  _/ ___// __ \\")
(println "  / __ \\/ _ \\ | /| / / /    / / \\__ \\/ /_/ /")
(println " / / / /  __/ |/ |/ / /____/ / ___/ / ____/ ")
(println "/_/ /_/\\___/|__/|__/_____/___//____/_/      ")
(print))
(banner4)

(define (banner5)
(println "                     _     ___ ____  ____  ")
(println " _ __   _____      _| |   |_ _/ ___||  _ \\ ")
(println "| '_ \\ / _ \\ \\ /\\ / / |    | |\\___ \\| |_) |")
(println "| | | |  __/\\ V  V /| |___ | | ___) |  __/ ")
(println "|_| |_|\\___| \\_/\\_/ |_____|___|____/|_|    ")
(print))
(banner5)

(define (banner6)
  (println "                     #       ###  #####  ###### ")
  (println "#    # ###### #    # #        #  #     # #     #")
  (println "##   # #      #    # #        #  #       #     #")
  (println "# #  # #####  #    # #        #   #####  ###### ")
  (println "#  # # #      # ## # #        #        # #      ")
  (println "#   ## #      ##  ## #        #  #     # #      ")
  (println "#    # ###### #    # ####### ###  #####  #      ")
  (print))
(banner6)

(define (banner7)
  (println "##    ## ######## ##      ## ##       ####  ######  ######## ")
  (println "###   ## ##       ##  ##  ## ##        ##  ##    ## ##     ##")
  (println "####  ## ##       ##  ##  ## ##        ##  ##       ##     ##")
  (println "## ## ## ######   ##  ##  ## ##        ##   ######  ######## ")
  (println "##  #### ##       ##  ##  ## ##        ##        ## ##       ")
  (println "##   ### ##       ##  ##  ## ##        ##  ##    ## ##       ")
  (println "##    ## ########  ###  ###  ######## ####  ######  ##       ")
  (print))
(banner7)

(define (banner8)
  (println "                                                  _               _  _  _     _  _  _  _     _  _  _  _   ")
  (println "                                                 (_)             (_)(_)(_)  _(_)(_)(_)(_)_  (_)(_)(_)(_)_ ")
  (println " _  _  _  _      _  _  _  _     _             _  (_)                (_)    (_)          (_) (_)        (_)")
  (println "(_)(_)(_)(_)_   (_)(_)(_)(_)_  (_)           (_) (_)                (_)    (_)_  _  _  _    (_) _  _  _(_)")
  (println "(_)        (_) (_) _  _  _ (_) (_)     _     (_) (_)                (_)      (_)(_)(_)(_)_  (_)(_)(_)(_)  ")
  (println "(_)        (_) (_)(_)(_)(_)(_) (_)_  _(_)_  _(_) (_)                (_)     _           (_) (_)           ")
  (println "(_)        (_) (_)_  _  _  _     (_)(_) (_)(_)   (_) _  _  _  _   _ (_) _  (_)_  _  _  _(_) (_)           ")
  (println "(_)        (_)   (_)(_)(_)(_)      (_)   (_)     (_)(_)(_)(_)(_) (_)(_)(_)   (_)(_)(_)(_)   (_)           ")
  (print)   )
(banner8)

(define (banner9)
  (println "                          LL      IIIII  SSSSS  PPPPPP ")
  (println "nn nnn    eee  ww      ww LL       III  SS      PP   PP")
  (println "nnn  nn ee   e ww      ww LL       III   SSSSS  PPPPPP ")
  (println "nn   nn eeeee   ww ww ww  LL       III       SS PP     ")
  (println "nn   nn  eeeee   ww  ww   LLLLLLL IIIII  SSSSS  PP     ")
  (print))
(banner9)

(define (banner str)
  (let (line (dup "+-" (length str)))
    (println line "+")
    (map (fn(x) (print "|" x)) (explode str))
    (println "|")
    (println line "+")
    (print)))
(banner "newLISP")
;-> +-+-+-+-+-+-+-+
;-> |n|e|w|L|I|S|P|
;-> +-+-+-+-+-+-+-+


--------------------
Puzzle di Gordon Lee
--------------------

Data una matrice NxN con numeri composti con una sola cifra (0..9) anche ripetuti, contare i distinti numeri primi incorporati nella matrice. I numeri si possono leggere con orientamento verticale, orizzontale o diagonale, in entrambe le direzioni.
Ad esempio nella matrice:

  1 2 3
  4 5 6
  7 8 9

Sono inglobati i seguenti 65 numeri:

(1 2 3 4 5 6 7 8 9 12 14 15 21 23 24 25 26 32 35 36 41 42 45 47 48 51 52 53 54 56
 57 58 59 62 63 65 68 69 74 75 78 84 85 86 87 89 95 96 98 123 147 159 258 321 357
 369 456 654 741 753 789 852 951 963 987)

Questo puzzle è stato proposto per la prima volta nel 1989 da Gordon Lee per una matrice 6x6.

La matrice 6x6 con il maggior numero di primi è stata trovata da Stephen Root:

  3 1 7 3 3 3
  9 9 5 6 3 9
  1 1 8 1 4 2
  1 3 6 3 7 3
  3 4 9 1 9 9
  3 7 9 3 7 9

Questa matrice contiene all'interno 187 numeri primi.

Nota: i numeri contenuti nella matrice non sono necessariamente tutti differenti.

Quello che ci serve è una funzione che, data una matrice, sia in grado di generare tutti i numeri inglobati.

(define (numatrix mtx)
  (local (sol val num cur-row cur-col max-row max-col)
    (setq sol '())
    (setq max-row (length mtx))
    (setq max-col (length (mtx 0)))
    ; ricerca dei numeri inglobati
    ; per ogni elemento della matrice...
    (for (r 0 (- max-row 1))
      (for (c 0 (- max-col 1))
        (setq num (mtx r c))
        ; inseriamo il numero corrente nella soluzione
        (push num sol -1)
        ; numeri per colonna in avanti
        (setq val num)
        (setq cur-row (+ r 1))
        (while (< cur-row max-row)
          (setq val (+ (* val 10) (mtx cur-row c)))
          (push val sol -1)
          (++ cur-row)
        )
        ; numeri per colonna all'indietro
        (setq val num)
        (setq cur-row (- r 1))
        (while (>= cur-row 0)
          (setq val (+ (* val 10) (mtx cur-row c)))
          (push val sol -1)
          (-- cur-row)
        )
        ; numeri per riga in avanti
        (setq val num)
        (setq cur-col (+ c 1))
        (while (< cur-col max-col)
          (setq val (+ (* val 10) (mtx r cur-col)))
          (push val sol -1)
          (++ cur-col)
        )
        ; numeri per riga all'indietro
        (setq val num)
        (setq cur-col (- c 1))
        (while (>= cur-col 0)
          (setq val (+ (* val 10) (mtx r cur-col)))
          (push val sol -1)
          (-- cur-col)
        )
        ; numeri in diagonale basso-sx
        (setq val num)
        (setq cur-col (- c 1))
        (setq cur-row (+ r 1))
        (while (and (>= cur-col 0) (< cur-row max-row))
          (setq val (+ (* val 10) (mtx cur-row cur-col)))
          (push val sol -1)
          (-- cur-col)
          (++ cur-row)
        )
        ; numeri in diagonale basso-dx
        (setq val num)
        (setq cur-col (+ c 1))
        (setq cur-row (+ r 1))
        (while (and (< cur-col max-col) (< cur-row max-row))
          (setq val (+ (* val 10) (mtx cur-row cur-col)))
          (push val sol -1)
          (++ cur-col)
          (++ cur-row)
        )
        ; numeri in diagonale alto-sx
        (setq val num)
        (setq cur-col (- c 1))
        (setq cur-row (- r 1))
        (while (and (>= cur-col 0) (>= cur-row 0))
          (setq val (+ (* val 10) (mtx cur-row cur-col)))
          (push val sol -1)
          (-- cur-col)
          (-- cur-row)
        )
        ; numeri in diagonale alto-dx
        (setq val num)
        (setq cur-col (+ c 1))
        (setq cur-row (- r 1))
        (while (and (< cur-col max-col) (>= cur-row 0))
          (setq val (+ (* val 10) (mtx cur-row cur-col)))
          (push val sol -1)
          (++ cur-col)
          (-- cur-row)
        )
      )
    )
    (sort sol)))

Facciamo alcune prove:

(setq m2 '((1 2) (3 4)))
(setq n2 (numatrix m2))
;-> (1 2 3 4 12 13 14 21 23 24 31 32 34 41 42 43)
(length n2)
;-> 16

(setq m3 '((1 2 3) (4 5 6) (7 8 9)))
(setq n3 (numatrix m3))
;-> (1 2 3 4 5 6 7 8 9 12 14 15 21 23 24 25 26 32 35 36 41 42 45 47 48 51
;->  52 53 54 56 57 58 59 62 63 65 68 69 74 75 78 84 85 86 87 89 95 96 98
;->  123 147 159 258 321 357 369 456 654 741 753 789 852 951 963 987)
(length n3)
;-> 65

(setq m4 '((1 2 3 4) (4 5 6 7) (7 8 9 1) (3 7 9 0)))
(setq n4 (numatrix m4))
;-> (0 1 1 1 2 3 3 4 4 5 6 7 7 7 8 9 9 9 9 10 12 14 15 16 17 17 19 19 21 23 24
;->  25 26 32 34 35 36 37 37 37 38 41 42 43 45 46 47 47 48 51 52 53 54 56 57 58
;->  59 61 62 63 64 65 67 68 69 71 73 73 73 74 74 75 76 77 77 78 78 79 79 79 83
;->  84 85 86 87 87 89 89 90 90 91 91 95 95 96 97 97 97 97 98 98 99 99 123 147
;->  159 162 174 174 198 234 258 261 321 357 369 374 379 386 432 456 468 471
;->  473 489 567 587 590 654 683 699 710 741 753 765 785 789 790 797 797 852
;->  864 891 951 951 963 973 973 984 987 996 1234 1473 1590 1987 2587 3699
;->  3741 3790 3864 4321 4567 4683 4710 7654 7852 7891 9963)
(length n4)
;-> 168

(setq m5 '((1 2 3 4 5) (1 2 3 4 5) (1 2 3 4 5) (1 2 3 4 5) (1 2 3 4 5)))
(length (setq n5 (numatrix m5)))
;-> 345

(setq m6 '((1 2 3 4 5 6) (1 2 3 4 5 6) (1 2 3 4 5 6) (1 2 3 4 5 6) (1 2 3 4 5 6) (1 2 3 4 5 6)))
(length (setq n6 (numatrix m6)))
;-> 616

Quindi abbiamo la seguente tabella:

  Ordine    Numero elementi
  ------    ---------------
  1x1         1 numero
  2x2        16 numeri
  3x3        65 numeri
  4x4       168 numeri
  5x5       345 numeri
  6x6       616 numeri

Adesso abbiamo bisogno di una funzione per verificare/calcolare i numeri primi:

Funzione che genera tutti i numeri primi minori o uguali a un dato numero:

(define (primes-to num)
  (cond ((= num 1) '())
        ((= num 2) '(2))
        (true
         (let ((lst '(2)) (arr (array (+ num 1))))
          (for (x 3 num 2)
                (when (not (arr x))
                  (push x lst -1)
                  (for (y (* x x) num (* 2 x) (> y num))
                      (setf (arr y) true)))) lst))))

Funzione che verifica se un dato numero è primo:

(define (prime? num)
   (if (< num 2) nil
       (= 1 (length (factor num)))))

Possiamo usare due metodi per calcolare i numeri primi della matrice:

1) identificare se ogni numero della matrice è primo
(filter prime? numeri)

2) precalcolare i numeri primi fino a 10^(N+1) (dove N è l'ordine della matrice)
(intersect primi numeri)

Per esempio:

(setq mx3 '((1 2 3) (4 5 6) (7 8 9)))
(setq numeri (unique (sort (numatrix mx3))))
;-> (1 2 3 4 5 6 7 8 9 12 14 15 21 23 24 25 26 32 35 36 41 42 45 47 48 51 52
;->  53 54 56 57 58 59 62 63 65 68 69 74 75 78 84 85 86 87 89 95 96 98 123
;->  147 159 258 321 357 369 456 654 741 753 789 852 951 963 987)
(filter prime? numeri)
;-> (2 3 5 7 23 41 47 53 59 89)
(setq primi (primes-to 1e3))
(intersect numeri primi)
;-> (2 3 5 7 23 41 47 53 59 89)

Verifichiamo la matrice record 6x6 vista sopra:

(setq x6
 '((3 1 7 3 3 3)
  (9 9 5 6 3 9)
  (1 1 8 1 4 2)
  (1 3 6 3 7 3)
  (3 4 9 1 9 9)
  (3 7 9 3 7 9)))
(setq numeri (unique (sort (numatrix x6))))
(setq sol (filter prime? numeri))
;-> (2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97
;->  113 131 139 149 151 163 173 179 181 191 193 197 199 233 239 241 271 293
;->  311 313 317 331 337 347 349 373 379 389 397 431 433 439 461 467 479 491
;->  563 599 613 617 619 631 643 659 683 719 733 739 743 797 811 839 857 863
;->  911 919 937 941 971 983 991 1153 1181 1193 1619 1733 1811 1913 2399
;->  2719  3119 3163 3191 3347 3371 3461 3467 3491 3511 3613 3631 3637 3659
;->  3793  3863  3911 3923 3931 4397 4919 5179 5639 5869 6131 6133 6373 6599
;->  6833 6857 7151 7333 7433 7643 7937 8699 9161 9199 9239 9349 9439 9739
;->  9743 9839 13163 17333 24181 31193 31643 33119 33479 33713 33863 34613
;->  34919 36131 36373 36599 36833 37363 39113 39239 39839 46133 49199 58699
;->  73973 75869 79349 79379 91943 92399 93893 94397 96857 97151 97397 99563
;->  136373 241811 313163 317333 333713 346133 349199 361313 373631 391133
;->  758699 936599 991943 993893 996857)
(length sol)
;-> 187

Verifichiamo altri record dal sito:

https://www.primepuzzles.net/puzzles/puzz_001.htm

Matrice 3x3 con 30 numeri primi:
(setq x3
       '((1 1 3)
         (7 5 4)
         (9 3 7)))
(setq numeri (unique (sort (numatrix x3))))
(setq sol (filter prime? numeri))
;-> (3 5 7 11 13 17 31 37 41 43 47 53 59 71 73 79 97 113 157 179 311 347
;->  359 457 739 743 751 937 953 971)
(length sol)
;-> 30

Matrice 4x4 con 63 numeri primi:
(setq x4
       '((1 1 3 9)
         (6 4 5 1)
         (7 3 9 7)
         (3 9 2 9)))
(setq numeri (unique (sort (numatrix x4))))
(setq sol (filter prime? numeri))
;-> (2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 97 113
;->  139 149 157 167 179 199 293 311 347 359 397 439 499 673 719 739 743
;->  751 761 929 937 941 953 971 991 1439 1499 2953 3359 3761 3929 6451
;->  7937 9293 9311 9341 9533 9719 9941)
(length sol)
;-> 63

Matrice 5x5 con 116 numeri primi:
(setq x5
       '((1 1 9 3 3)
         (9 9 5 6 3)
         (8 9 4 1 7)
         (3 3 7 3 1)
         (3 2 9 3 9)))
(setq numeri (unique (sort (numatrix x5))))
(setq sol (filter prime? numeri))
;-> (2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97
;->  137 149 151 163 173 193 199 239 271 293 317 331 337 349 359 373 379 389
;->  433 439 463 479 491 547 563 593 599 613 643 659 719 733 739 769 839 911
;->  937 941 953 967 983 991 997 1151 1193 1373 1511 1733 1933 1993 2399 2713
;->  2939 3163 3371 3373 3389 3391 3463 3491 3593 3613 3643 3659 3719 3733
;->  3911 3923 5479 6133 6599 7459 8941 9173 9349 9439 9547 9833 9973 11933
;->  32939 33911 36433 36599 89417 91733 93491 93923 95479 97459 99563)
(length sol)
;-> 116

Matrice 7x7 con 281 numeri primi:
(setq x7
       '((9 3 3 7 3 1 3)
         (3 3 3 3 2 9 9)
         (4 9 8 7 7 9 6)
         (9 1 9 5 1 6 7)
         (1 1 2 4 3 7 7)
         (9 3 9 7 4 9 9)
         (9 9 9 1 7 3 3)))
(setq numeri (unique (sort (numatrix x7))))
(length (numatrix x7))
(setq sol (filter prime? numeri))
(length sol)
;-> 281

Otteniamo la seguente tabella:

  Ordine    Numero elementi    Numeri primi
  ------    ---------------    ------------
  1x1          1 numero          1
  2x2         16 numeri          ? (11)
  3x3         65 numeri         30
  4x4        168 numeri         63
  5x5        345 numeri        116
  6x6        616 numeri        187
  7x7       1001 numeri        281

Manca il numero di primi per la matrice 2x2. In questo caso possiamo trovare la soluzione esaustivamente considerando tutte le matrici che si possono generare con i numeri da 0 a 9 e calcolando il relativo numero di primi.

Funzione che genera tutte le permutazioni di k elementi con ripetizione da un elenco di elementi:

(define (perm-rep k lst)
  (if (zero? k) '(())
      (flat (map (lambda (p) (map (lambda (e) (cons e p)) lst))
                         (perm-rep (- k 1) lst)) 1)))

Funzione che calcola la matrice con il più grande numero di primi:

(define (find-x2)
  (local (m numeri sol max-val out)
    (setq max-val 0)
    (setq all (perm-rep 4 '(0 1 2 3 4 5 6 7 8 9)))
    (dolist (el all)
      (setq m (list (select el 0 1) (select el 2 3)))
      (setq numeri (unique (sort (numatrix m))))
      (setq sol (filter prime? numeri))
      (if (> (length sol) max-val)
        (begin
        (setq m-sol m)
        (setq max-val (length sol))
        (setq out sol)
        )
      )
    )
    (println m-sol { } max-val { } out)))

Proviamo a trovare la matrice 2x2 con il maggior numero di primi:

(find-x2)
;-> ((7 4) (3 1)) 11 (3 7 13 17 31 37 41 43 47 71 73)


-------------
Orologio ANSI
-------------

;;
;; Newlisp clocking
;;
;; linux version or dos-box with ansi support or windows console 20H1.
;; enjoy...norman.
;;
(set 'digits '(
(" ### " "  #  " "#####" "#####" "#   #" "#####" "#    " "#####" "#####" " ### " "     ")
("#   #" " ##  " "    #" "    #" "#   #" "#    " "#    " "    #" "#   #" "#   #" "  #  ")
("#   #" "  #  " "#####" " ### " "#####" "#####" "#####" "   ##" "#####" " ####" "     ")
("#   #" "  #  " "#    " "    #" "    #" "    #" "#   #" "   # " "#   #" "   # " "  #  ")
(" ### " "  #  " "#####" "#####" "    #" "#####" "#####" "   # " "#####" "  #  " "     ")))
(while true
 ;; clear screen (ANSI sequence)
 (println "\027[H\027[2J\027[0;32m")
 ;; define time without ":" get from apply date
 (set 'ticks (replace ":" (slice (date (apply date-value (now))) 11 8) ""))
 ;; write 5 rows of 6 digits and 2 seperators
 (dotimes (x 5)
   (dotimes (y 6)
	(print " " (nth (integer (nth 0 (nth y ticks))) (nth x digits)))
	(if (or (= y 1) (= y 3)) (print (nth 10 (nth x digits)))))
  (println))
(sleep 1000)
)


---------------
Indici ordinali
---------------

Le seguenti funzioni permettono di indicizzare i primi dieci elementi di una lista (o stringa o vettore):

(define (second  x) (unless (>= 1 (length x)) (nth 1 x) 'nil))
(define (third   x) (unless (>= 2 (length x)) (nth 2 x) 'nil))
(define (fourth  x) (unless (>= 3 (length x)) (nth 3 x) 'nil))
(define (fifth   x) (unless (>= 4 (length x)) (nth 4 x) 'nil))
(define (sixth   x) (unless (>= 5 (length x)) (nth 5 x) 'nil))
(define (seventh x) (unless (>= 6 (length x)) (nth 6 x) 'nil))
(define (eigth   x) (unless (>= 7 (length x)) (nth 7 x) 'nil))
(define (ninth   x) (unless (>= 8 (length x)) (nth 8 x) 'nil))
(define (tenth   x) (unless (>= 9 (length x)) (nth 9 x) 'nil))


-----------------------
Generazione di password
-----------------------

(define (pwd1)
  ; simple pwd gen 8 chars
  ; [a-n p-z A-N P-Z 1-9]
  (seed (time-of-day))
  (println (join (map char (0 8 (randomize (flat (map (fn(x) (sequence (x 0) (x 1))) '( (50 57) (65 78) (80 90) (97 110) (112 122) )))))))))

(pwd1)
;-> ixHsMClA
(pwd1)
;-> GQ7Crwet

(define (pwd2)
  ; simple pwd gen 16 chars 4x4
  ; one time password
  ; [a-n p-z A-N P-Z 1-9]
  (seed (time-of-day))
  (println (join (explode (join (map char (0 16 (randomize (flat (map (fn(x) (sequence (x 0) (x 1))) '( (50 57) (65 78) (80 90) (97 110) (112 122) ))))))) 4)" ")))

(pwd2)
;-> BvmF Kf4w WArj ULRH
(pwd2)
;-> SnZJ 29VP DyQq sTcM

(define (pwd3)
  ; simple pwd gen 10 chars
  ; [!-/ :-@ [-` {-~ a-n p-z A-N P-Z 1-9]
  (seed (time-of-day))
  (println (join (map char (0 10 (randomize (flat (map (fn(x) (sequence (x 0) (x 1))) '( (33 47) (50 78) (80 110) (112 126) )))))))))

(pwd3)
;-> X_u|=\,C#9
;-> NjA3Hk'[9Y


-------------------------------
Verifica accessibilità siti web
-------------------------------

La seguente funzione controlla se un sito web è online (connesso) | offline (disconnesso):

(define (online? www)
 (if (setq checkup (net-connect www 80))
	(begin (net-close checkup ) "Online ") "Offline"))

(setq urls '(
	"newlisp.org"
	"pazzzo.org"
	"www.gnu.org"
  "google.com"))

(dolist (url urls) (println (online? url) " : " url))
;-> Online  : newlisp.org
;-> Offline : pazzzo.org
;-> Online  : www.gnu.org
;-> Online  : google.com


------------------------
Miglior punto d'incontro
------------------------

Un gruppo di due o più persone vuole incontrarsi e ridurre al minimo la distanza totale del viaggio. Viene data una griglia 2D di
valori 0 o 1, dove 1 indica la posizione di qualcuno nel gruppo. La distanza è calcolata utilizzando il metodo Manhattan:

  Distanza di Manhattan (p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.

Ad esempio, date tre persone che si trovano a (0,0), (0,4) e (2,2):

  1 - 0 - X - 0 - 1
  |   |   |   |   |
  0 - 0 - 0 - 0 - 0
  |   |   |   |   |
  0 - 0 - 1 - 0 - 0

Funzione che calcola la distanza Manhattan (4 direzioni - torre) di due punti P1=(x1 y1) e P2=(x2 y2):

(define (manhattan x1 y1 x2 y2)
  (+ (abs (- x1 x2)) (abs (- y1 y2))))

Soluzione brute-force:

(define (meet grid girl)
  (local (cols rows num-rows num-cols dmin dist)
    (setq num-rows (length grid))
    (setq num-cols (length (grid 0)))
    (setq rows '())
    (setq cols '())
    (setq pos '(0 0))
    (setq dmin 999999999)
    ; per ogni cella della griglia...
    (for (r 0 (- num-rows 1))
      (for (c 0 (- num-cols 1))
        (setq dist 0)
        ; calcola il valore minimo
        ; della somma delle distanze
        ; di tutte le persone
        (dolist (m girl)
          (setq dist (+ dist (manhattan (m 0) (m 1) r c)))
        )
        (println dist { } (grid r c))
        ; aggiorna il valore minimo e la posizione migliore
        (if (< dist dmin)
            (setq dmin dist pos (list r c))
        )
      )
    )
    (list pos dmin)))

(setq grid '((1 0 0 0 1) (0 0 0 0 0) (0 0 1 0 0)))
(setq girl '((0 0) (0 4) (2 2)))

(meet grid girl)
;-> ((0 2) 6)

Se vogliamo trovare solo la distanza minima, allora il problema consiste nel trovare il valore mediano sull'asse x e sull'asse y.

(define (meeting lst girl)
  (local (cols rows num-rows num-cols somma)
    (setq num-rows (length lst))
    (setq num-cols (length (lst 0)))
    (setq rows '())
    (setq cols '())
    (for (r 0 (- num-rows 1))
      (for (c 0 (- num-cols 1))
        (if (= 1 (lst r c))
            (begin
            (push c cols -1)
            (push r rows -1))
        )
      )
    )
    (setq rows (map first girl))
    (setq cols (map last girl))
    (setq somma 0)
    (setq r-mid (/ (length rows) 2))
    (dolist (el rows)
      (setq somma (+ somma (abs (- el (rows r-mid)))))
    )
    (setq c-mid (/ (length cols) 2))
    (sort cols)
    (dolist (el cols)
      (setq somma (+ somma (abs (- el (cols c-mid)))))
    )
    somma))

(meeting grid girl)
;-> 6

Vediamo altri esempi:

  1 - 0 - 0 - 0 - 1 - 0 - 1
  |   |   |   |   |   |   |
  0 - 0 - 0 - 0 - 0 - 1 - 1
  |   |   |   |   |   |   |
  0 - 0 - 1 - 0 - 0 - 0 - 1
  |   |   |   |   |   |   |
  1 - 0 - 0 - 0 - 0 - 1 - 1
  |   |   |   |   |   |   |
  0 - 0 - 0 - 0 - 0 - 0 - 1

(setq grid '((1 0 0 0 1 0 1)
             (0 0 0 0 0 1 1)
             (0 0 1 0 0 0 1)
             (1 0 0 0 0 1 1)
             (0 0 0 0 0 0 1)))

(setq girl '((0 0) (0 4) (0 5) (0 6) (2 2) (2 6) (3 0) (3 5) (3 6) (4 6)))

(meet grid girl)
;-> ((2 5) 31)

(setq grid '((0 1 0 0)
             (0 1 1 0)
             (0 0 0 0)))

(setq girl '((0 1) (1 1) (1 2)))

(meet grid girl)
;-> ((1 1) 2)


-------------------------------
Stringhe Unicode (UTF8) o ASCII
-------------------------------

Per verificare se una stringa contiene solo caratteri ASCII oppure contiene anche caratteri Unicode (UTF8) possiamo usare le seguenti due funzioni:

(define (ascii? str) (= (length str) (utf8len str)))

(define (utf? str) (!= (length str) (utf8len str)))

Se la lunghezza ASCII è uguale alla lunghezza UTF8, allora la stringa contiene solo caratteri ASCII, altrimenti contiene anche caratteri UTF8.

(setq s "abcde")
(ascii? s)
;-> true
(utf? s)
;-> nil

(setq s "abc╬de")
(ascii? s)
;-> nil
(utf? s)
;-> true

Nota: la funzione "utf8len" è disponibile solo nella versione di newLISP UTF8.


----------------
Funzione set-nth
----------------

La funzione "set-nth" è deprecata e non è più disponibile nelle versione 10.7.5 di newLISP.
Questa funzione è stata sostituita da "setf" e l'indicizzazione implicita.
Riportiamo la sintassi della funzione "set-nth" al fine di facilitare la conversione di vecchi programmi newLISP che la utilizzano:

  (set-nth indice list|string|array value)

Sostituisce l'elemento in posizione "indice" di una lista, vettore o stringa con il valore del parametro "value".

Esempi:

(setq s "abc")
;-> "abc"
(set-nth 0 s "z")
;-> "zbc"

(setq lst '(1 2 3 4))
;-> (1 2 3 4)
(set-nth 0 lst 99)
;-> (99 2 3 4)

Nella versione 10.7.5, al posto di set-nth, utilizziamo "setf" con l'indicizzazione implicita:

(setq s "abc")
;-> "abc"
(setf (s 0) "z")
;-> "z"
s
;-> "zbc"

(setq lst '(1 2 3 4))
;-> (1 2 3 4)
(setf (lst 0) 99)
;-> 99
lst
;-> (99 2 3 4)

Possiamo anche scrivere una funzione per simulare "set-nth":

(define (set-nth idx obj val)
  (setf (obj idx) val)
  obj)

(setq lst '(1 2 3 4))
(set-nth 0 lst "0")
;-> ("0" 1 2 3 4)

Ma in questo modo "lst" non vien modificata:

lst
;-> (1 2 3 4)

Quindi dobbiamo scrivere:

(setq lst (set-nth 0 lst "0"))
;-> ("0" 1 2 3 4)

Nota: abbiamo anche "push" e "pop" che possono inserire o estrarre pezzi di uno o più caratteri da una stringa:

(setq s "abc")
(pop s) (push "z" s)
;-> "a"
;-> "zbc"


----------------------------------------
Somma di interi rappresentati come liste
----------------------------------------
 
Sommare due numeri interi positivi contenuti in due liste.

Esempio:
lst1 = (1 4 3)
lst2 = (7 7)
lst1 + lst2 = (2 2 0)

L'algoritmo segue il procedimento manuale per fare una addizione.

(define (add-int lst1 lst2 out)
  (local (carry prev temp somma)
    (setq out '())
    ; riporto
    (setq carry 0)
    ; indici delle liste (partendo dalla fine)
    (setq idx1 (- (length lst1) 1))
    (setq idx2 (- (length lst2) 1))
    ; fino a che le liste non sono entrambe vuote
    (while (or (>= idx1 0) (>= idx2 0))
      ; prende le cifre correnti (partendo dall'ultima)
      ; se la lista è terminata, allora prende il valore 0
      ; altrimenti prende il valore corrispondente a idx
      (if (< idx1 0)
          (setq cifra1 0)
          (setq cifra1 (lst1 idx1))
      )
      (if (< idx2 0)
          (setq cifra2 0)
          (setq cifra2 (lst2 idx2))
      )
      ; somma delle due cifre e del riporto
      (setq somma (+ cifra1 cifra2 carry))
      ; verifica del riporto
      ; ed aggiustamento della somma (che deve essere una sola cifra)
      (if (< somma 10)
          (setq carry 0 somma somma)
          (setq carry 1 somma (% somma 10))
      )
      ; inserisce la somma nella lista soluzione
      (push somma out)
      ;(println somma { } carry)
      ; posiziona gli indici sulle prossime cifre
      (-- idx1)
      (-- idx2)
    )
    ; se abbiamo un riporto all'ultima cifra,
    ; allora lo inseriamo nella lista soluzione
    (if (= carry 1) (push carry out))
    out))

Proviamo la funzione:

(add-int '(3) '(6))
;-> (9)
(add-int '(3 1) '(6 2))
;-> (9 3)
(add-int '(3 6) '(8 6))
;-> (1 2 2)

Funzione che converte un numero intero in una lista di cifre:

(define (int-lst num)
  (let (out '())
    (while (!= num 0)
      (push (% num 10) out)
      (setq num (/ num 10))) out))

Funzione che converte una lista di cifre in intero:

(define (lst-int lst)
  (let (num 0)
    (dolist (el lst) (setq num (+ el (* num 10))))))

(setq a 1237561238576352)
(setq b 123875612323)
(+ a b)
;-> 1237685114188675
(= (+ a b) (lst-int (add-int (int-lst a) (int-lst b))))
;-> true

Proviamo con degli interi big-integer:

(setq c 786762621237561238576352)
;-> 786762621237561238576352L
(setq d 222123875612323)
;-> 222123875612323
(+ c d)
;-> 786762621459685114188675L
(= (+ c d) (lst-int (add-int (int-lst c) (int-lst d))))
;-> true

(setq e 786762621237561238576352)
;-> 786762621237561238576352L
(setq f 131313131313131222123875612323L)
;-> 222123875612323
(+ e f)
;-> 131313918075752459685114188675L
(= (+ e f) (lst-int (add-int (int-lst e) (int-lst f))))
;-> true

=============================================================================

===========

 APPENDICI

===========

============================================================================
 Lista delle funzioni newLISP
============================================================================

List processing, flow control, and integer arithmetic
=====================================================
+, -, *, /, %     integer arithmetic
++                increment integer numbers
--                decrement integer numbers
<, >, =           compares any data type: less, greater, equal
<=, >=, !=        compares any data type: less-equal, greater-equal, not-equal
:                 constructs a context symbol and applies it to an object
and               logical and
append            appends lists ,arrays or strings to form a new list, array or string
apply             applies a function or primitive to a list of arguments
args              retrieves the argument list of a function or macro expression
assoc             searches for keyword associations in a list
begin             begins a block of functions
bigint            convert a number to big integer format
bind              binds variable associations in a list
case              branches depending on contents of control variable
catch             evaluates an expression, possibly catching errors
chop              chops elements from the end of a list
clean             cleans elements from a list
collect           repeat evaluating an expression and collect results in a list
cond              branches conditionally to expressions
cons              prepends an element to a list, making a new list
constant          defines a constant symbol
count             counts elements of one list that occur in another list
curry             transforms a function f(x, y) into a function fx(y)
define            defines a new function or lambda expression
define-macro      defines a macro or lambda-macro expression
def-new           copies a symbol to a different context (namespace)
difference        returns the difference between two lists
doargs            iterates through the arguments of a function
dolist            evaluates once for each element in a list
dostring          evaluates once for each character in a string
dotimes           evaluates once for each number in a range
dotree            iterates through the symbols of a context
do-until          repeats evaluation of an expression until the condition is met
do-while          repeats evaluation of an expression while the condition is true
dup               duplicates a list or string a specified number of times
ends-with         checks the end of a string or list against a key of the same type
eval              evaluates an expression
exists            checks for the existence of a condition in a list
expand            replaces a symbol in a nested list
explode           explodes a list or string
extend            extends a list or string
first             gets the first element of a list or string
filter            filters a list
find              searches for an element in a list or string
flat              returns the flattened list
fn                defines a new function or lambda expression
for               evaluates once for each number in a range
for-all           checks if all elements in a list meet a condition
if                evaluates an expression conditionally
index             filters elements from a list and returns their indices
intersect         returns the intersection of two lists
lambda            defines a new function or lambda expression
last              returns the last element of a list or string
length            calculates the length of a list or string
let               declares and initializes local variables
letex             expands local variables into an expression, then evaluates
letn              initializes local variables incrementally, like nested lets
list              makes a list
local             declares local variables
lookup            looks up members in an association list
map               maps a function over members of a list, collecting the results
match             matches patterns against lists; for matching against strings, see find and regex
member            finds a member of a list or string
not               logical not
nth               gets the nth element of a list or string
or                logical or
pop               deletes and returns an element from a list or string
pop-assoc         removes an association from an association list
push              inserts a new element into a list or string
quote             quotes an expression
ref               returns the position of an element inside a nested list
ref-all           returns a list of index vectors of elements inside a nested list
rest              returns all but the first element of a list or string
replace           replaces elements inside a list or string
reverse           reverses a list or string
rotate            rotates a list or string
select            selects and permutes elements from a list or string
self              Accesses the target object inside a FOOP method
set               sets the binding or contents of a symbol
setf setq         sets contents of a symbol or list, array or string reference
set-ref           searches for an element in a nested list and replaces it
set-ref-all       searches for an element in a nested list and replaces all instances
silent            works like begin but suppresses console output of the return value
slice             extracts a sublist or substring
sort              sorts the members of a list
starts-with       checks the beginning of a string or list against a key of the same type
swap              swaps two elements inside a list or string
unify             unifies two expressions
unique            returns a list without duplicates
union             returns a unique list of elements found in two or more lists.
unless            evaluates an expression conditionally
until             repeats evaluation of an expression until the condition is met
when              evaluates a block of statements conditionally
while             repeats evaluation of an expression while the condition is true

String and conversion functions
===============================
address           gets the memory address of a number or string
bigint            convert a number to big integer format
bits              translates a number into binary representation
char              translates between characters and ASCII codes
chop              chops off characters from the end of a string
dostring          evaluates once for each character in a string
dup               duplicates a list or string a specified number of times
ends-with         checks the end of a string or list against a key of the same type
encrypt           does a one-time–pad encryption and decryption of a string
eval-string       compiles, then evaluates a string
explode           transforms a string into a list of characters
extend            extends a list or string
find              searches for an element in a list or string
find-all          returns a list of all pattern matches found in string
first             gets the first element in a list or string
float             translates a string or integer into a floating point number
format            formats numbers and strings as in the C language
get-char          gets a character from a memory address
get-float         gets a double float from a memory address
get-int           gets a 32-bit integer from a memory address
get-long          gets a long 64-bit integer from a memory address
get-string        gets a string from a memory address
int               translates a string or float into an integer
join              joins a list of strings
last              returns the last element of a list or string
lower-case        converts a string to lowercase characters
member            finds a list or string member
name              returns the name of a symbol or its context as a string
nth               gets the nth element in a list or string
pack              packs newLISP expressions into a binary structure
parse             breaks a string into tokens
pop               pops from a string
push              pushes onto a string
regex             performs a Perl-compatible regular expression search
regex-comp        pre-compiles a regular expression pattern
replace           replaces elements in a list or string
rest              gets all but the first element of a list or string
reverse           reverses a list or string
rotate            rotates a list or string
select            selects and permutes elements from a list or string
setf setq         sets contents of a string reference
slice             extracts a substring or sublist
source            returns the source required to bind a symbol as a string
starts-with       checks the start of the string or list against a key string or list
string            transforms anything into a string
sym               translates a string into a symbol
title-case        converts the first character of a string to uppercase
trim              trims a string on one or both sides
unicode           converts ASCII or UTF-8 to UCS-4 Unicode
utf8              converts UCS-4 Unicode to UTF-8
utf8len           returns length of an UTF-8 string in UTF-8 characters
unpack            unpacks a binary structure into newLISP expressions
upper-case        converts a string to uppercase characters

Floating point math and special functions
=========================================
abs               returns the absolute value of a number
acos              calculates the arc-cosine of a number
acosh             calculates the inverse hyperbolic cosine of a number
add               adds floating point or integer numbers and returns a floating point number
array             creates an array
array-list        returns a list conversion from an array
asin              calculates the arcsine of a number
asinh             calculates the inverse hyperbolic sine of a number
atan              calculates the arctangent of a number
atanh             calculates the inverse hyperbolic tangent of a number
atan2             computes the principal value of the arctangent of Y / X in radians
beta              calculates the beta function
betai             calculates the incomplete beta function
binomial          calculates the binomial function
ceil              rounds up to the next integer
cos               calculates the cosine of a number
cosh              calculates the hyperbolic cosine of a number
crc32             calculates a 32-bit CRC for a data buffer
dec               decrements a number in a variable, list or array
div               divides floating point or integer numbers
erf               calculates the error function of a number
exp               calculates the exponential e of a number
factor            factors a number into primes
fft               performs a fast Fourier transform (FFT)
floor             rounds down to the next integer
flt               converts a number to a 32-bit integer representing a float
gammai            calculates the incomplete Gamma function
gammaln           calculates the log Gamma function
gcd               calculates the greatest common divisor of a group of integers
ifft              performs an inverse fast Fourier transform (IFFT)
inc               increments a number in a variable, list or array
inf?              checks if a floating point value is infinite
log               calculates the natural or other logarithm of a number
min               finds the smallest value in a series of values
max               finds the largest value in a series of values
mod               calculates the modulo of two numbers
mul               multiplies floating point or integer numbers
NaN?              checks if a float is NaN (not a number)
round             rounds a number
pow               calculates x to the power of y
sequence          generates a list sequence of numbers
series            creates a geometric sequence of numbers
sgn               calculates the signum function of a number
sin               calculates the sine of a number
sinh              calculates the hyperbolic sine of a number
sqrt              calculates the square root of a number
ssq               calculates the sum of squares of a vector
sub               subtracts floating point or integer numbers
tan               calculates the tangent of a number
tanh              calculates the hyperbolic tangent of a number
uuid              returns a UUID (Universal Unique IDentifier)

Matrix functions
================
det               returns the determinant of a matrix
invert            returns the inversion of a matrix
mat               performs scalar operations on matrices
multiply          multiplies two matrices
transpose         returns the transposition of a matrix

Array functions
===============
append            appends arrays
array             creates and initializes an array with up to 16 dimensions
array-list        converts an array into a list
array?            checks if expression is an array
det               returns the determinant of a matrix
first             returns the first row of an array
invert            returns the inversion of a matrix
last              returns the last row of an array
mat               performs scalar operations on matrices
multiply          multiplies two matrices
nth               returns an element of an array
rest              returns all but the first row of an array
setf              sets contents of an array reference
slice             returns a slice of an array
transpose         transposes a matrix

Bit operators
=============
<<, >>            bit shift left, bit shift right
&                 bitwise and
|                 bitwise inclusive or
^                 bitwise exclusive or
~                 bitwise not

Predicates
==========
atom?             checks if an expression is an atom
array?            checks if an expression is an array
bigint?           checks if a number is a big integer
context?          checks if an expression is a context
directory?        checks if a disk node is a directory
empty?            checks if a list or string is empty
even?             checks the parity of an integer number
file?             checks if a file exists
float?            checks if an expression is a float
global?           checks if a symbol is global
inf?              checks if a floating point value is infinite
integer?          checks if an expression is an integer
lambda?           checks if an expression is a lambda expression
legal?            checks if a string contains a legal symbol
list?             checks if an expression is a list
macro?            checks if an expression is a lambda-macro expression
NaN?              checks if a float is NaN (not a number)
nil?              checks if an expression is nil
null?             checks if an expression is nil, "", (), 0 or 0.0
number?           checks if an expression is a float or an integer
odd?              checks the parity of an integer number
protected?        checks if a symbol is protected
primitive?        checks if an expression is a primitive
quote?            checks if an expression is quoted
string?           checks if an expression is a string
symbol?           checks if an expression is a symbol
true?             checks if an expression is not nil
zero?             checks if an expression is 0 or 0.0

Date and time functions
=======================
date              converts a date-time value to a string
date-list         returns a list of year, month, day, hours, minutes, seconds from a time value in seconds
date-parse        parses a date string and returns the number of seconds passed since January 1, 1970, (formerly parse-date)
date-value        calculates the time in seconds since January 1, 1970 for a date and time
now               returns a list of current date-time information
time              calculates the time it takes to evaluate an expression in milliseconds
time-of-day       calculates the number of milliseconds elapsed since the day started

Statistics, simulation and modeling functions
=============================================
amb               randomly selects an argument and evaluates it
bayes-query       calculates Bayesian probabilities for a data set
bayes-train       counts items in lists for Bayesian or frequency analysis
corr              calculates the product-moment correlation coefficient
crit-chi2         calculates the Chi² statistic for a given probability
crit-f            calculates the F statistic for a given probability
crit-t            calculates the Student's t statistic for a given probability
crit-z            calculates the normal distributed Z for a given probability
kmeans-query      calculates distances to cluster centroids or other data points
kmeans-train      partitions a data set into clusters
normal            makes a list of normal distributed floating point numbers
prob-chi2         calculates the tail probability of a Chi² distribution value
prob-f            calculates the tail probability of a F distribution value
prob-t            calculates the tail probability of a Student's t distribution value
prob-z            calculates the cumulated probability of a Z distribution value
rand              generates random numbers in a range
random            generates a list of evenly distributed floats
randomize         shuffles all of the elements in a list
seed              seeds the internal random number generator
stats             calculates some basic statistics for a data vector
t-test            compares means of data samples using the Student's t statistic

Pattern matching
================
ends-with         tests if a list or string ends with a pattern
find              searches for a pattern in a list or string
find-all          finds all occurrences of a pattern in a string
match             matches list patterns
parse             breaks a string along around patterns
ref               returns the position of an element inside a nested list
ref-all           returns a list of index vectors of elements inside a nested list
regex             finds patterns in a string
replace           replaces patterns in a string
search            searches for a pattern in a file
starts-with       tests if a list or string starts with a pattern
unify             performs a logical unification of patterns

Financial math functions
========================
fv                returns the future value of an investment
irr               calculates the internal rate of return
nper              calculates the number of periods for an investment
npv               calculates the net present value of an investment
pv                calculates the present value of an investment
pmt               calculates the payment for a loan

Input/output and file operations
================================
append-file       appends data to a file
close             closes a file
current-line      retrieves contents of last read-line buffer
device            sets or inquires about current print device
exec              launches another program, then reads from or writes to it
load              loads and evaluates a file of newLISP code
open              opens a file for reading or writing
peek              checks file descriptor for number of bytes ready for reading
print             prints to the console or a device
println           prints to the console or a device with a line-feed
read              reads binary data from a file
read-char         reads an 8-bit character from a file
read-file         reads a whole file in one operation
read-key          reads a keyboard key
read-line         reads a line from the console or file
read-utf8         reads UTF-8 character from a file
save              saves a workspace, context, or symbol to a file
search            searches a file for a string
seek              sets or reads a file position
write             writes binary data to a file
write-char        writes a character to a file
write-file        writes a file in one operation
write-line        writes a line to the console or a file

Processes and the Cilk API
==========================
!                 shells out to the operating system
abort             aborts a child process started with spawn
destroy           destroys a process created with fork or process
exec              runs a process, then reads from or writes to it
fork              launches a newLISP child process
pipe              creates a pipe for interprocess communication
process           launches a child process, remapping standard I/O and standard error
receive           receive a message from another process
semaphore         creates and controls semaphores
send              send a message to another process
share             shares memory with other processes
spawn             launches a child process for Cilk process management
sync              waits for child processes launched with spawn and collects results
wait-pid          waits for a child process to end

File and directory management
=============================
change-dir        changes to a different drive and directory
copy-file         copies a file
delete-file       deletes a file
directory         returns a list of directory entries
file-info         gets file size, date, time, and attributes
make-dir          makes a new directory
real-path         returns the full path of the relative file path
remove-dir        removes an empty directory
rename-file       renames a file or directory

HTTP networking API
===================
base64-enc        encodes a string into BASE64 format
base64-dec        decodes a string from BASE64 format
delete-url        deletes a file or page from the web
get-url           reads a file or page from the web
json-error        returns error information from a failed JSON translation.
json-parse        parses JSON formatted data
post-url          posts info to a URL address
put-url           uploads a page to a URL address
xfer-event        registers an event handler for HTTP byte transfers
xml-error         returns last XML parse error
xml-parse         parses an XML document
xml-type-tags     shows or modifies XML type tags

Socket TCP/IP, UDP and ICMP network API
=======================================
net-accept        accepts a new incoming connection
net-close         closes a socket connection
net-connect       connects to a remote host
net-error         returns the last error
net-eval          evaluates expressions on multiple remote newLISP servers
net-interface     Sets the default interface IP address on multihomed computers.
net-ipv           Switches between IPv4 and IPv6 internet protocol versions.
net-listen        listens for connections to a local socket
net-local         returns the local IP and port number for a connection
net-lookup        returns the name for an IP number
net-packet        send a custom configured IP packet over raw sockets
net-peek          returns the number of characters ready to be read from a network socket
net-peer          returns the remote IP and port for a net connect
net-ping          sends a ping packet (ICMP echo request) to one or more addresses
net-receive       reads data on a socket connection
net-receive-from  reads a UDP on an open connection
net-receive-udp   reads a UDP and closes the connection
net-select        checks a socket or list of sockets for status
net-send          sends data on a socket connection
net-send-to       sends a UDP on an open connection
net-send-udp      sends a UDP and closes the connection
net-service       translates a service name into a port number
net-sessions      returns a list of currently open connections

API for newLISP in a web browser
================================
display-html      display an HTML page in a web browser
eval-string-js    evaluate JavaScript in the current web browser page

Reflection and customization
============================
command-event     pre-processes the command-line and HTTP requests
error-event       defines an error handler
history           returns the call history of a function
last-error        report the last error number and text
macro             create a reader expansion macro
ostype            contains a string describing the OS platform
prefix            Returns the context prefix of a symbol
prompt-event      customizes the interactive newLISP shell prompt
read-expr         reads and translates s-expressions from source
reader-event      preprocess expressions before evaluation event-driven
set-locale        switches to a different locale
source            returns the source required to bind a symbol to a string
sys-error         reports OS system error numbers
sys-info          gives information about system resources
term              returns the term part of a symbol or its context as a string

System functions
================
$                 accesses system variables $0 -> $15
callback          registers a callback function for an imported library
catch             evaluates an expression, catching errors and early returns
context           creates or switches to a different namespace
copy              copies the result of an evaluation
debug             debugs a user-defined function
delete            deletes symbols from the symbol table
default           returns the contents of a default functor from a context
env               gets or sets the operating system's environment
exit              exits newLISP, setting the exit value
global            makes a symbol accessible outside MAIN
import            imports a function from a shared library
main-args         gets command-line arguments
new               creates a copy of a context
pretty-print      changes the pretty-printing characteristics
read-expr         translates a string to an s-expression without evaluating it
reset             goes to the top level
signal            sets a signal handler
sleep             suspends processing for specified milliseconds
sym               creates a symbol from a string
symbols           returns a list of all symbols in the system
throw             causes a previous catch to return
throw-error       throws a user-defined error
timer             starts a one-shot timer, firing an event
trace             sets or inquires about trace mode
trace-highlight   sets highlighting strings in trace mode

Importing libraries
===================
address           returns the memory address of a number or string
callback          registers a callback function for an imported library
flt               converts a number to a 32-bit integer representing a float
float             translates a string or integer into a floating point number
get-char          gets a character from a memory address
get-float         gets a double float from a memory address
get-int           gets a 32-bit integer from a memory address
get-long          gets a long 64-bit integer from a memory address
get-string        gets a string from a memory address
import            imports a function from a shared library
int               translates a string or float into an integer
pack              packs newLISP expressions into a binary structure
struct            Defines a data structure with C types
unpack            unpacks a binary structure into newLISP expressions

newLISP internals API
=====================
command-event     pre-processes the command-line and HTTP requests
cpymem            copies memory between addresses
dump              shows memory address and contents of newLISP cells
prompt-event      customizes the interactive newLISP shell prompt
read-expr         reads and translates s-expressions from source
reader-event      preprocess expressions before evaluation event-driven

Riguardare la lista rinfresca la memoria e aiuta a trovare funzioni... prima sconosciute.

============================================================================
Sul linguaggio newLISP - FAQ di Lutz Mueller
============================================================================

Questa è la traduzione della pagina web relativa alle FAQ (Frequently Asked Questions) su newLISP:

http://www.newLISP.org/index.cgi?FAQ

1.  Cos'è newLISP e cosa posso fare con questo linguaggio?
2.  Perché newLISP, perché non uno degli altri LISP standard?
3.  Come posso studiare newLISP?
4.  Quanto è veloce newLISP?
5.  newLISP ha le matrici?
6.  newLISP ha le tabelle hash?
7.  newLISP ha una gestione automatica della memoria?
8.  newLISP può passare i dati per riferimento?
9.  Come funziona il variable scoping in newLISP?
10. newLISP gestisce il multiprocessing?
11. Posso usare newLISP per compiti di calcolo distribuiti?
12. Possiamo utilizzare la metodologia di programmazione orientata agli oggetti?
13. Cosa sono di pacchetti e moduli?
14. Quali sono alcune differenze tra newLISP e altri LISP?
15. newLISP funziona sul sistema operativo XYZ?
16. newLISP può gestire i caratteri speciali del mio paese e della mia lingua?
17. L'indicizzazione implicita non infrange le regole di sintassi del LISP?
18. newLISP può essere incorporato in altri programmi?
19. Posso mettere il copyright ai miei script anche se newLISP è concesso in licenza GPL?
20. Dove posso segnalare eventuali bug?

1. Cos'è newLISP e cosa posso fare con questo linguaggio?
---------------------------------------------------------
newLISP è un linguaggio di scripting simile al LISP per fare quelle cose che si fanno tipicamente con linguaggi di scripting: programmazione per internet, amministrazione di sistema, elaborazione testi, incollare diversi altri programmi insieme, ecc. newLISP è un LISP di scripting per persone che sono affascinate dalla bellezza e dal potere espressivo del LISP, ma che hanno bisogno di una versione ridotta per imparare facilmente l'essenziale.

2. Perché newLISP, perché non uno degli altri LISP standard?
------------------------------------------------------------
LISP è un vecchio linguaggio nato, cresciuto e standardizzato in tempi molto diversi da oggi, tempi in cui la programmazione era per persone altamente istruite che hanno progettato programmi. newLISP è un LISP rinato come linguaggio di scripting: pragmatico e casuale, semplice da imparare senza che tu debba conoscere concetti avanzati di informatica. Come ogni buon linguaggio di scripting, newLISP è relativamente semplice da imparare e potente per terminare il proprio lavoro senza problemi.

Vedi anche: "In Praise of Scripting: Real Programming Pragmatics" di Ronald P. Loui

http://web.cs.mun.ca/~harold/Courses/Old/CS2500.F09/Diary/04563874.pdf

newLISP ha un tempo di avvio molto veloce, ha bisogno di poche risorse come spazio su disco e memoria ed ha una pratica API con funzioni native per networking, statistica, machine learning, espressioni regolari, multiprocessing e calcolo distribuito, non aggiunte successivamente con moduli esterni.

3. Come posso studiare newLISP?
-------------------------------
Almeno all'inizio, studia principalmente newLISP utilizzandolo. Se capisci questo:

(+ 1 2 3); calcola la somma di 1,2,3 => 6

e questo:

(define (double x) (+ x x)); definisce una funzione

(doppio 123); calcola il doppio di 123 => 246

allora hai imparato abbastanza per iniziare a programmare in newLISP. Ci sono alcuni altri concetti come le funzioni anonime, l'applicazione di funzioni, spazi dei nomi (contesti) e l'indicizzazione implicita. Imparerai queste tecniche mentre usi newLISP.
I libri su LISP o Scheme, che sono due standard di LISP diversi e più vecchi, insegnano concetti che non hai la necessità di imparare per programmare in newLISP. Molte volte newLISP esprime le cose in modo diverso dai LISP tradizionali e in modi più applicabili ai compiti di programmazione odierni e ad un livello superiore più vicino al problema in questione.
Impara a risolvere i problemi con il modo newLISP! Per una comprensione più approfondita di newLISP, leggi la sezione del "manuale utente" di newLISP, con meno teoria e più esempi. Dai uno sguardo al "manuale di riferimento" per avere un'idea della profondità e dell'ampiezza delle funzioni API integrate.
Per lavorare seriamente con newLISP occorre leggere il manuale "Code Patterns" con altri suggerimenti e pezzi di codice. Una buona introduzione per principianto è il libro "Introduction to newLISP" oppure i video tutorial che sono disponibili nella pagina ufficiale della documentazione.
Molte funzioni in newLISP hanno una funzionalità facile da capire, ma sono molto più potenti quando si conoscono e si usano le opzioni speciali di quella funzione. La profondità della API di newLISP non è basata sulla quantità delle funzioni, ma piuttosto sulle opzioni e sulle sintassi multipla di ogni specifica funzione
Inizia a scrivere il tuo primo programma ora. Guarda le porzioni di codice (snippet) riportate in tutto il manuale e su questo sito web. Se hai domande, iscriviti al forum di discussione di newLISP e chiedi.

4. Quanto è veloce newLISP?
---------------------------
La velocità di calcolo di newLISP è confrontabile con quella dei popolari strumenti di scripting come Perl o Python, ma si comporta meglio quando si tratta di tempi di avvio e di memoria / spazio su disco.
Dai un'occhiata ad alcuni benchmark: http://www.newLISP.org/benchmarks/
Molte funzioni per cui altri linguaggi richiedono l'utilizzo di moduli esterni sono già incorporate in newLISP. Funzioni di networking e metodi matematici come FFT (Fast Fourier Analysis) o funzioni di apprendimento automatico bayesiano sono rapidissime in newLISP. Sono funzioni integrate e non richiedono alcun modulo esterno. Nonostante ciò, newLISP è più piccolo di altri linguaggi di scripting.

5. newLISP ha le matrici?
-------------------------
Sì. Per le applicazioni con accesso random a liste di grandi dimensioni, l'accesso può essere effettuato più velocemente utilizzando gli array di newLISP.

6. newLISP ha le tabelle hash?
------------------------------
newLISP utilizza alberi binari red-black per l'accesso alla memoria associativa quando si gestiscono spazi dei nomi (namespace), dizionari e per l'accesso ai valori-chiave simili alla tecnica hash.

7. newLISP ha una gestione automatica della memoria?
----------------------------------------------------
Sì. Ma non è il tipico processo di garbage collection che trovi in altri linguaggi interattivi. Proprio come la garbage collection dei tradizionali linguaggi, newLISP ricicla la memoria inutilizzata. Tuttavia, newLISP lo fa in un modo nuovo, molto più efficiente. La gestione della memoria di newLISP è sincrona senza pause improvvise nell'elaborazione che vengono osservate in linguaggi con garbage collection vecchio stile. L'esclusiva gestione automatica della memoria di newLISP è una delle ragioni della sua velocità, delle sue dimensioni ridotte e dell'uso efficiente della memoria.
Vedi anche: "Automatic Memory Management in newLISP" di Lutz Mueller

http://www.newLISP.org/MemoryManagement.html

8. newLISP può passare i dati per riferimento?
----------------------------------------------
Tutte le funzioni integrate passano liste e stringhe per riferimento sia in ingresso che in uscita. Per passare per riferimento a funzioni definite dall'utente, liste e stringhe possono essere raggruppati in spazi dei nomi particolari (context). Maggiori informazioni su questo argomento sul manuale utente. Dalla versione 10.2, FOOP passa per riferimento anche l'oggetto.

9. Come funziona il variable scoping in newLISP?
------------------------------------------------
newLISP ha uno scope dinamico applicato all'interno di contesti o spazi dei nomi separati lessicalmente. I namespace hanno un overhead molto piccolo e possono esisterne a milioni. I contesti in newLISP consentono la chiusura lessicale di più di una funzione lambda e di un oggetto. I contesti possono essere utilizzati per scrivere funzioni con scope lessicale con memoria, moduli software e oggetti. Ciò evita le insidie dello scope dinamico e aiuta a strutturare programmi più grandi.

10. newLISP gestisce il multiprocessing?
----------------------------------------
Le versioni Linux / UNIX di newLISP possono eseguire il fork e lo spawn dei processi. Le versioni di Windows possono avviare processi figlio indipendenti. I semafori vengono utilizzati per sincronizzare i processi e la memoria condivisa può essere utilizzata per le comunicazioni tra i processi.
Su macOS, Linux e altri Unix, l'API Cilk è integrata per facilitare il lancio e la sincronizzazione di più processi, in modo trasparente senza preoccuparsi di semafori, blocchi, ecc. È disponibile un'API di messaggistica asincrona per comunicare tra processi.

11. Posso usare newLISP per compiti di calcolo distribuiti?
-----------------------------------------------------------
Alcune delle applicazioni più grandi di oggi vengono distribuite su più computer, dividendo le loro complesse attività tra più nodi su una rete. newLISP può essere eseguito come server per valutare i comandi inviati da altri client newLISP ad esso connessi. La funzione "net-eval" incapsula tutta la gestione della rete necessaria per comunicare con altri computer sulla rete, distribuire il codice e le attività di calcolo e raccogliere i risultati in un modo bloccante o basato sugli eventi. newLISP può anche fungere da server Web che gestisce le richieste HTTP incluso CGI.

12. Possiamo utilizzare la metodologia di programmazione orientata agli oggetti?
--------------------------------------------------------------------------------
newLISP offre un nuovo modo di programmazione orientata agli oggetti funzionale chiamata FOOP. Usa gli spazi dei nomi per raccogliere tutti i metodi per una classe di oggetti e usa le normali espressioni S per rappresentare gli oggetti. Per ulteriori dettagli su questo nuovo modo di programmazione orientata agli oggetti in newLISP consultare la serie di video di addestramento "Towards FOOP" nella sezione documentazione e il capitolo "Functional object-oriented programming" nel manuale utente. Dalla versione 10.2 gli oggetti FOOP sono mutabili.

13. Cosa sono  pacchetti e moduli?
----------------------------------
newLISP utilizza gli spazi dei nomi per la creazione di pacchetti e moduli. Esistono moduli per l'accesso ai database come MySQL, PostgreSQL e SQLite, nonché ODBC. I moduli aggiuntivi supportano i protocolli Internet FTP, POP3, SMTP e REST. Poiché i nuovi spazi dei nomi di LISP vengono chiusi lessicamente, newLISP consente ai programmatori di trattare i moduli come black box. Questo metodologia è adatta per gruppi di programmatori che lavorano su applicazioni di grandi dimensioni.
newLISP può anche chiamare funzioni di librerie C condivise su Linux / UNIX e sistemi operativi Windows per espandere le sue funzionalità.
I moduli possono essere documentati utilizzando il sistema di documentazione automatica  newLISPdoc.

14. Quali sono alcune differenze tra newLISP e altri LISP?
----------------------------------------------------------
Le nuove differenze di LISP dagli altri LISP includono: il funzionamento delle espressioni lambda, l'esistenza di namespace (o contesti), il passaggio parametri e, naturalmente, la  API di newLISP (repertorio di funzioni). Nel complesso, il nuovo modo di programmazione del LISP di newLISP lo rendono più veloce, più piccolo e più facile da capire e da apprendere. Per una discussione più dettagliata, vedere "Comparison to Common Lisp and Scheme":

http://www.newLISP.org/index.cgi?page=Differences_to_Other_LISPs

15. newLISP funziona sul sistema operativo XYZ?
-----------------------------------------------
Probabilmente si. newLISP ha un minimo di dipendenze. Utilizza solo librerie C standard per la compilazione. Se il tuo sistema ha strumenti GNU come il compilatore GCC e l'utility make, allora newLISP dovrebbe compilare e linkare immediatamente usando uno dei makefile contenuti nella sua distribuzione sorgente.
newLISP viene creato utilizzando uno dei numerosi makefile, ciascuno scritto per una piattaforma specifica. Non ci sono script di make complessi. I makefile sono brevi e facili da modificare e adattare se  non sono già inclusi nella tua piattaforma o configurazione.

16. newLISP può gestire i caratteri speciali del mio paese e della mia lingua?
------------------------------------------------------------------------------
Nella maggior parte del mondo occidentale, è sufficiente impostare le impostazioni internazionali utilizzando la funzione newLISP "set-locale".
Più della metà dei paesi del mondo usano una virgola decimale invece di un punto decimale. newLISP leggerà e scriverà correttamente le virgole decimali quando passerà alla corretta locale.
La maggior parte degli alfabeti nell'emisfero occidentale si adattano a tabelle di codici carattere a 256 codici e ogni carattere richiede un solo byte di 8 bit da codificare. Se la lingua del tuo paese richiede caratteri multibyte per codificarla, allora hai bisogno della versione di newLISP con supporto UTF-8 abilitato. I Makefile per Windows e Linux sono inclusi per compilare le versioni UTF-8 di newLISP. Nella versione UTF-8, molte funzioni di gestione dei caratteri sono in grado di gestire caratteri multibyte. Vedere il capitolo sulla localizzazione e UTF-8 nel manuale per i dettagli.

17. L'indicizzazione implicita non infrange le regole di sintassi del LISP?
---------------------------------------------------------------------------
Al contrario, l'indicizzazione implicita è un'estensione logica della sintassi LISP. Quando si valutano le espressioni S, il primo elemento viene applicato come una funzione agli elementi restanti nell'espressione che servono come argomenti della funzione. L'indicizzazione implicita consiste semplicemente nel considerare i membri dei tipi di dati numerici, di stringa e di elenco come operatori speciali di indicizzazione quando si trovano nella prima posizione di un'espressione S.

18. newLISP può essere incorporato in altri programmi?
------------------------------------------------------
newLISP può essere compilato come libreria condivisa UNIX o DLL Windows (libreria a collegamento dinamico). Di conseguenza, le versioni di libreria condivisa di newLISP possono essere utilizzate all'interno di altri programmi che sono in grado di importare funzioni di libreria condivisa. Altri modi per integrare la tua applicazione con newLISP includono i pipe I/O e le porte di rete.
Sui sistemi Win32, newLISP è stato utilizzato all'interno di MS Excel, MS Visual Basic e del generatore di applicazioni GUI NeoBook. Su UNIX, newLISP è stato utilizzato all'interno del foglio di calcolo di GNumeric. Su macOS, newLISP è stato utilizzato come linguaggio di estensione per l'editor di BBEdit grazie alla nuova LISP che comunica con BBEdit tramite i pipe di I/O standard. Il Guiserver basato su Java e il vecchio frontend Tcl/Tk per newLISP sono esempi di integrazione di newLISP tramite porte di rete.

19. Copyright sui miei script anche se newLISP è concesso in licenza GPL?
-------------------------------------------------------------------------
Si, puoi. Le FAQ di gnu.org per la GPL lo spiegano. Finché i tuoi script non usano altro software GPL di terze parti sotto forma di librerie importate o moduli caricati, i tuoi script in newLISP non devono necessariamente avere una licenza GPL. La maggior parte dei moduli sul sito Web di newLISP non ha licenza e non importa altre librerie. Se lo fanno, consultare le licenze di quelle librerie di terze parti.
newLISP ti permette di distribuire un binario dell'interprete insieme al tuo sorgente. Quando si utilizza newLISP nel software, menzionare sempre il sito Web www.newLISP.org nella documentazione come luogo in cui è disponibile il codice sorgente per newLISP.

20. Dove posso segnalare eventuali bug?
---------------------------------------
La maggior parte delle segnalazioni di bug risulta dalla mancata lettura della documentazione o dal ritenere che newLISP funzioni come Common Lisp o Scheme. Le domande, i commenti e le segnalazioni di bug sono pubblicati sul forum ufficiale, dove vengono letti da molti altri, dando loro l'opportunità di commentare o dare consigli. Il forum consente anche di inviare messaggi privati.

21. Posso compilare i miei script in programmi eseguibili?
----------------------------------------------------------
Si. Il comando: newLISP -x "myscript.lsp" "myscript.exe" genera un file eseguibile sul proprio sistema operativo.


============================================================================
newLISP in 21 minuti (John W. Small)
============================================================================

newLISP: un tutorial interattivo
--------------------------------
Questo documento è stato riformattato per HTML con alcune correzioni e aggiornamenti fatti da Rick Hanson nel maggio 2006, cryptorick@gmail.com. Ulteriori aggiornamenti da LM gennaio 2008, dicembre 2011, novembre 2014, maggio 2018.
Traduzione in italiano, aggiornamenti e adattamenti fatti da cameyo 2019.

Copyright 2004, John W. Small, Tutti i diritti riservati

Puoi scaricare e installare newLISP dal sito web www.newLISP.org.

Si prega di inviare eventuali commenti o domande riguardanti questo tutorial a jsmall@atlaol.net.

Indice
------
Ciao Mondo!
Codice sorgente e dati sono intercambiabili
Argomenti di funzione
Effetti collaterali e contesti
Sequenze di espressioni
Eseguibili e librerie dinamiche (dll)
Binding (associazione/legame)
Lista come struttura ricorsiva
Funzioni
Funzioni di ordine superiore
Liste lambda
Ambito dinamico (Dynamic scope)
Lista degli argomenti di una funzione
Lambda-macro
Contesti
Ambito lessicale (Lexical scope)

Ciao Mondo!
-----------
Con newLISP installato sul tuo sistema, al prompt della riga di comando della shell (cmd in windows) inserisci newLISP per avviare la REPL (Read, Eval, Print, Loop).
Su Linux, la console sarebbe simile a questa:

$ newLISP
> _

E su piattaforme Windows, sarebbe simile a questa.

c:\> newLISP
> _

Dopo l'avvio, newLISP risponde con il simbolo del prompt.

> _

Nota del traduttore:
per utilizzare questo documento con notepad++ e la REPL di newLISP ho eliminato il simbolo del prompt ">" quando viene seguito da un'espressione (in questo modo è possibile eseguire l'espressione direttamente). Inoltre l'output della REPL viene preceduto dalla stringa "->".

Inserisci l'espressione qui sotto per stampare "Ciao Mondo!" sulla console.

(println "Ciao Mondo!")

newLISP stampa il valore dell'espressione immessa nel prompt della REPL prima di eseguire il ciclo e richiedere un nuovo input.

(println "Ciao Mondo!")
;-> Ciao Mondo!
;-> "Ciao Mondo!"
> _

Perché è stato stampato due volte?

La funzione println stampa la prima riga, es. Ciao Mondo! nella console a causa effetto collaterale (side effect) della chiamata di funzione.
Inoltre la funzione println restituisce la stringa di valore "Ciao Mondo!", cioè il suo ultimo argomento, alla REPL che a sua volta stampa la seconda riga, cioè

"Ciao Mondo!"

La REPL valuta qualsiasi espressione e non solo le chiamate di funzione:

"Ciao Mondo!"
;-> "Ciao Mondo!"
> _

Se inserisci l'espressione stringa "Ciao Mondo!", come mostrato sopra, questa restituisce semplicemente se stessa come qualsiasi espressione letterale e come i numeri letterali.

1
;-> 1
> _

A questo punto potresti essere intimorito dalle parentesi. Se iniziate newLISP conoscendo un normale linguaggio informatico, sembrerebbe più naturale scrivere una chiamata di funzione nel modo seguente:

println ("Ciao Mondo!")

Dovrai solo credermi sulla parola - nel tempo preferirai di gran lunga:

(println "Ciao Mondo!")

a

println ("Ciao Mondo!")

per ragioni che non possono essere adeguatamente spiegate fino a quando non avrai visto molti più esempi di elaborazione di liste simboliche.

Codice sorgente e dati sono intercambiabili
-------------------------------------------
Lisp è l'acronimo di List Processor. Poiché le liste sono utilizzate per rappresentare sia il codice che i dati in Lisp, questi ultimi sono essenzialmente intercambiabili.
La precedente espressione println è in realtà una lista con due elementi:

(println "Ciao mondo!")

Il primo elemento è:

println

e l'ultimo elemento è:

"Ciao Mondo!"

Lisp interpreta sempre una lista come una chiamata di funzione, a meno che non venga "quotata", indicando così che dovrebbe essere presa come un'espressione simbolica, cioè come un dato.
Per "quotare" occorre inserire il carattere " ' " davanti all'espressione.

'(println "Ciao Mondo!")
;-> (println "Ciao Mondo!")
> _

Un'espressione simbolica può tuttavia essere valutata come codice sorgente con la funzione "eval".

(eval '(println "Ciao Mondo!"))
;-> Ciao Mondo!
;-> "Ciao Mondo!"
> _

Un programma Lisp può modificare se stesso durante l'esecuzione (runtime) costruendo liste di dati ed eseguendoli come codice sorgente!

(eval '(eval '(println "Ciao Mondo!")))
;-> Ciao Mondo!
;-> "Ciao Mondo!"
> _

In realtà il carattere " ' " rappresenta la funzione quote (syntactical sugar).

(quote (println "Ciao Mondo!"))
;-> (println "Ciao Mondo!")
> _

Pensa alla funzione quote come una funzione che utilizza i suoi argomenti letteralmente, cioè come simboli.

'x
;-> x
(quote x)
;-> x
'(1 2 tre "quattro")
;-> (1 2 tre "quattro")
> _

I simboli, come x e tre sopra, e le liste simboliche svolgono un ruolo di vitale importanza nell'intelligenza artificiale (AI). Questo tutorial non riguarderà argomenti di AI. Tuttavia, una volta che avrai imparato a programmare in Lisp, sarai in grado di seguire tranquillamente gli esempi Lisp che si trovano nella maggior parte dei libri di testo su AI.
Considera il seguente esempio.

'Ciao
;-> Ciao
"Ciao"
;-> "Ciao"
> _

Il simbolo 'Ciao non è lo stesso della stringa "Ciao". Ora puoi capire perché la REPL stampa le virgolette per indicare una stringa, distinguendola quindi da un simbolo con le stesse lettere.

Argomenti di funzione
---------------------
La funzione println può avere un numero variabile di argomenti.

(println "Ciao " "Mondo!")
;-> Ciao Mondo!
;-> "Mondo!"
> _

Gli argomenti sono semplicemente concatenati attraverso il flusso di output mentre l'ultimo argomento viene restituito come valore della chiamata di funzione.
In genere, gli argomenti passati a una funzione vengono valutati da sinistra a destra e i valori risultanti vengono quindi passati alla funzione. Si dice che gli argomenti correnti di una funzione sono valutati in modo rigoroso. Questo è noto come valutazione applicata in base all'ordine (applicative-order evaluation).
Ma notate che, per la funzione quote, questo non è il caso:

(quote (println "Ciao Mondo!"))
;-> (println "Ciao Mondo!")
> _

Se il suo argomento, vale a dire:

(println "Ciao Mondo!")

fosse stato rigorosamente valutato, avremmo visto:

Ciao Mondo!

visualizzato sulla console.
La funzione di quote è una funzione atipica a volte definita "forma speciale".
Puoi scrivere le tue funzioni speciali con newLISP. Queste sono chiamate macro e i loro argomenti sono detti "chiamati per nome", cioè letteralmente.
Questo è noto come ordine di valutazione normale e diciamo che la strategia di valutazione è pigra (lazy). In altre parole, gli argomenti di una macro non vengono valutati fino a quando, e solo se, si specifica direttamente l'esecuzione della valutazione (come vedremo in seguito).
Quindi, l'argomento della funzione quote viene preso alla lettera e restituito. In un certo senso, quote è una funzione di identità con una strategia di valutazione pigra (lazy evaluation). Non si preoccupa mai di valutare i sui argomenti, invece la restituisce letteralmente nella sua forma simbolica di codice sorgente.
Senza forme speciali, i costrutti di controllo del flusso trovati in altri linguaggi non potrebbero essere implementati in una linguaggio con solo liste di espressioni come sintassi con cui lavorare. Ad esempio,  considera il seguente if:

(if true (println "Ciao") (println "Arrivederci"))
;-> Ciao
;-> "Ciao"
> _

La forma speciale if prende tre argomenti:

sintassi: (if condizione conseguenza alternativa)

condizione  => vero
conseguenza => (println "Ciao")
alternativa => (println "Arrivederci")

L'argomento della condizione viene sempre valutato (strict evaluation), ma le conseguenze e le espressioni alternative sono valutate in modo pigro (lazy). Inoltre l'espressione alternativa è facoltativa.
Si noti che if è un'espressione. Restituisce il valore della espressione conseguenza o dell'espressione alternativa a seconda che la condizione sia rispettivamente vera (true) o falsa. Nell'esempio sopra, sappiamo che l'espressione alternativa non è stata valutata, perché il suo effetto collaterale della stampa "Arrivederci" sulla console non si è mai verificato.
Il valore di un'espressione if con una condizione falsa che non ha alternative e vale semplicemente nil (nullo). Il valore nil (nullo) indica vuoto o falso a seconda dell'interpretazione richiesta.
Nota: nella maggior parte dei linguaggi di programmazione tradizionali if è un'istruzione, e quindi non ha un valore di ritorno.
Se il Lisp non avesse avuto una strategia di valutazione pigra (lazy), non sarebbe possibile implementare forme speciali o macro. Senza una strategia di valutazione pigra, sarebbe stato necessario aggiungere parole chiave e/o sintassi al linguaggio. Quale tipi di sintassi hai visto fino ad ora, oltre alla parentesi e alle virgolette? Risposta: non molto!
Il rovescio della valutazione pigra (lazy) è che ora possibile aggiungere il proprio controllo di flusso al linguaggio estendendo così la "sintassi" di Lisp che consente di incorporare mini-linguaggi specifici dell'applicazione. La scrittura di funzioni e di macro sarà trattata in una sezione successiva di questo tutorial.

Effetti collaterali e contesti
------------------------------
Senza effetti collaterali, avere un REPL sarebbe inutile. Per capire il perché, consideriamo la seguente sequenza di espressioni:

(set 'ciao "Ciao")
;-> "Ciao"
(set 'mondo " Mondo")
;-> " Mondo"
(println ciao mondo)
;-> Ciao Mondo
;-> "Mondo"
> _

La funzione set sopra ha un effetto collaterale, come dimostrato di seguito:

ciao
;-> "Ciao"
mondo
;-> " Mondo"
> _

I simboli 'ciao e 'mondo sono legati nel contesto corrente a "Ciao" e "Mondo" rispettivamente.
Tutte le funzioni integrate (built-in) sono associate a simboli del contesto MAIN.

println
println@<409040>
set
set@<4080D0>
> _

Questo ci dice che println è associato a una funzione chiamata println con un punto di ingresso di 409040 (Versioni (build) diverse di newLISP avranno ovviamente punti di ingresso diversi per println).
Il contesto predefinito è MAIN. Un contesto è essenzialmente uno spazio dei nomi di stato. Impareremo in seguito i contesti definiti dall'utente.
Si noti che il simbolo letterale 'ciao valuta se stesso:

'ciao
;-> ciao
> _

La valutazione del simbolo 'ciao restituisce il valore a cui è associato nel contesto corrente:

(eval 'ciao)
;-> "Ciao"
> _

Se il simbolo non è associato quando viene valutato, restituisce semplicemente nil:

(eval 'z)
;-> nil
> _

In realtà non abbiamo bisogno di eval, dal momento che il simbolo senza la funzione quote viene automaticamente valutato nel contesto attuale:

ciao
;-> "Ciao"
z
;-> nil
> _

Quindi il valore di ciao e di mondo sono "Ciao" e "Mondo" rispettivamente:

(println ciao mondo)
;-> Ciao Mondo
;-> "Mondo"
> _

Cosa verrebbe visualizzato se inseriamo quanto segue?

(println 'ciao 'mondo)
?

Pensaci per un momento.

La funzione println visualizza i simboli uno immediatamente dopo l'altro sulla prima riga:

(println 'ciao 'mondo)
;-> ciaomondo
;-> mondo
> _

Sequenze di espressioni
-----------------------
Una sequenza di espressioni può essere combinata in un'espressione composta con la funzione begin:

(begin "Ciao" " Mondo!")
;-> " Mondo!"
> _

Cosa è successo a "Ciao"? Poiché un'espressione composta restituisce un singolo valore, restituisce il valore della sua ultima espressione. Ma le espressioni sono infatti valutate in sequenza. È solo che l'espressione "Ciao" non ha alcun effetto collaterale, quindi il suo valore di ritorno viene scartato e non si vede mai alcuna prova della sua valutazione:

(begin (print "Ciao") (println " Mondo!"))
;-> Ciao Mondo!
;-> " Mondo!"
> _

Questa volta, gli effetti collaterali di print e println sono evidenziati nella finestra della console e l'ultimo valore restituito viene visualizzato dal REPL.
La funzione begin è utile per combinare espressioni in una singola espressione. Ricordiamo la forma speciale if:

(if true
  (begin
    (print "Ciao" )
    (println " newLISP!"))
  (println "Java/Python/Ruby!"))

;-> Ciao newLISP!
;-> "newLISP!"
> _

Le istruzioni multilinea e le funzioni devono essere immesse premendo il tasto [invio] al prompt. Per uscire dalla modalità multilinea, premere di nuovo il tasto [invio] al prompt.
Ricorda che l’espressione if accetta solo tre argomenti:

sintassi: (if condizione conseguenza alternativa)

L'espressione (begin ...) viene utilizzata per combinare due espressioni in un'unica espressione, che viene quindi considerata come argomento conseguenza.
Terminiamo questa sezione vedendo come trasformare il nostro esempio in un programma eseguibile (exe).
Si noti che è possibile uscire dalla REPL in qualsiasi momento con la funzione (exit):

> (exit)
$ (linux) oppure c:\> (windows)

Puoi anche uscire con un argomento intero opzionale:

> (exit 3)

Questo può essere utile nell'elaborazione di shell o file batch creando punti di uscita con valori diversi in base agli errori avvenuti.
Ora possiamo mettere la nostra sequenza di espressioni in un file sorgente:

 ;Questo è un commento
 ;hw.lsp
 (println "Ciao mondo!")
 (exit)

E possiamo eseguirlo dalla riga di comando, in questo modo:

$ newLISP hw.lsp
Ciao mondo!

O in Windows:

c: \> newLISP hw.lsp
Ciao mondo!

Eseguibili e librerie dinamiche (dll)
-------------------------------------
Creare eseguibili nativi della piattaforma (exe in windows) e collegarsi alle librerie di collegamenti dinamici (dll in windows e so in linux) con newLISP è semplice.
Nelle vecchie versioni, dovresti trovare il file link.lsp nella sottodirectory degli esempi oppure dovresti scaricare gli esempi e i moduli separatamente da www.newLISP.org.
Con la versione 10.4.7 il processo di collegamento dei file sorgente LISP con un nuovo eseguibile LISP è cambiato e il file link.lsp non è più necessario.
Il processo è ora disponibile utilizzando l'opzione della riga di comando -x.
Consideriamo il seguente programma:

;; uppercase.lsp - Link example
(println (upper-case (main-args 1)))
(exit)

Il programma uppercase.lsp prende il primo argomento e lo converte in maiuscolo:
Le operazioni per creare un file eseguibilie sono le seguenti:

# in OSX, Linux e altri UNIX
newLISP -x "uppercase.lsp" "uppercase"

# impostiamo i permessi di esecuzione
chmod 755 uppercase

# in Windows il file eseguibile deve avere estensione .exe
newLISP -x "uppercase.lsp" "uppercase.exe"

In questo modo vengono messi insieme newLISP.exe e uppercase.lsp per creare il file eseguibile uppercase.exe. Per eseguire il programma occorre scrivere dal prompt dei comandi:

uppercase "testo da convertire"

L'output della console sarà:

TESTO DA CONVERTIRE

Nota: i file di inizializzazione (init.lsp o .init.lsp) non vengono caricati prima dell'esecuzione del programma.

Anche il collegamento a una libreria di collegamento dinamico è semplice. Sulle piattaforme Windows, le seguenti espressioni visualizzeranno una finestra di dialogo:

(import "user32.dll" "MessageBoxA")
(MessageBoxA 0 "Ciao mondo!" "newLISP Scripting Demo" 0)

Si noti che MessageBoxA è l'interfaccia di una funzione C nella libreria utente del sistema win32.
L'esempio seguente mostra come chiamare una funzione echo esterna scritta in C e compilata con Visual C ++:

// echo.c

#include <STDIO.H>
#define DLLEXPORT _declspec (dllexport)

DLLEXPORT void echo (const char * msg)
{
  printf (msg);
}

Dopo aver compilato il file echo.c in una DLL, può essere importata con il seguente codice:

(import "echo.dll" "echo")

(echo "Hello newLISP scripting World!")

La facilità con cui newLISP può collegarsi alle DLL è una caratteristica che lo rende un linguaggio di scripting ideale.
Assicurati di studiare gli altri esempi e i moduli che mostrano come programmare con i socket, connettersi ai database, ecc.

Binding (associazione/legame)
-----------------------------
Come mostrato in precedenza, la funzione set viene utilizzata per associare un valore a un simbolo:

(set 'y 'x)
;-> x
> _

In questo caso il valore 'x, un simbolo, è stato associato alla variabile denominata y .
Ora considera il seguente legame:

(set y 1)
;-> 1
> _

Dato che y non è quotato, esso viene valutato come 'x e di conseguenza 1 è legato alla variabile di nome x.

y
;-> x
x
;-> 1
> _

E ovviamente y rimane legato a 'x come mostrato sopra.

La funzione setq ti evita di dover scrivere quote ogni volta.

(setq y 1)
;-> 1
> _

Ora la variabile chiamata y è stata associata al valore 1.

y
;-> 1
> _

La funzione define funziona allo stesso modo:

(define y 2)
;-> 2
y
;-> 2
> _

Si noti che sia set che setq possono associare più variabili alla volta.

(set 'x 1 'y 2)
;-> 2
(setq x 3 y 4)
;-> 4
x
;-> 3
y
;-> 4
> _

(Dovresti verificare questi esempi mentre procediamo in modo che rimangano nella tua memoria.)
A differenza di setq, la funzione define può associare solo un'associazione alla volta. Tuttavia ci sono altri usi per define che saranno discussi a breve.
Ovviamente le funzioni set, setq e define hanno effetti collaterali oltre a restituire un valore. L'effetto collaterale è che l'associazione che lega la variabile ad un valore viene memorizzata nella tabella corrente dei simboli (implicita).
Possiamo visualizzare questa tabella di simboli implicita come una lista di associazioni:

'((x 1) (y 2))
;-> ((x 1) (y 2))
> _

L'elenco di associazioni sopra riportato è una lista di liste. Le liste annidate hanno due elementi ciascuna, vale a dire una coppia chiave-valore. Il primo elemento rappresenta il nome dell'associazione mentre l'ultimo elemento rappresenta il suo valore.

(first '(x 1))
;-> x
(last '(x 1))
;-> 1
> _

Il primo elemento di una lista di associazioni è naturalmente un'associazione:

(first '((x 1) (y 2)))
;-> (x 1)
> _

Le funzioni incorporate assoc e lookup sono fornite per facilitare il lavoro con gli elenchi di associazioni:

(assoc 'x' ((x 1) (y 2) (x 3)))
;-> (x 1)
(lookup 'x' ((x 1) (y 2) (x 3)))
;-> 1
> _

(La funzione lookup ha anche altri usi che puoi trovare nella documentazione di newLISP)
Nota che sia assoc e lookup restituiscono il legame e il valore rispettivamente della prima associazione che ha come chiave 'x. Questo punto sarà importante in seguito, man mano che si svilupperà la discussione sulle tabelle dei simboli e sui contesti di visibilità delle variabili (scope).

Lista come struttura ricorsiva
------------------------------
Qualsiasi lista che includa una lista di associazioni può essere vista come una struttura dati ricorsiva, probabilmente annidata. Una lista, per definizione, ha un primo elemento, una coda e un ultimo elemento:

(first '(1 2 3))
;-> 1
(rest '(1 2 3))
;-> (2 3)
(last '(1 2 3))
;-> 3

Ma considera quanto segue:

(rest '(1))
;-> ()
(rest '())
;-> ()
(first '())
;-> ERR: list is empty in function first : '()
(last '())
;-> ERR: list is empty in function last : '()

Il rest di una lista vuota o di un elenco con un solo elemento è di nuovo la lista vuota. Cercare di estrarre il primo o l'ultimo elemento da una lista vuota genera un errore. Si noti che (diversamente dal LISP) nil non rappresenta mai una lista vuota! Solo gli elementi inesistenti sono rappresentati con il valore nil!

(Si noti che la definizione di lista di newLISP è diversa da quella definita nel LISP e in Scheme)

Una lista può essere processata con un algoritmo ricorsivo.

Ad esempio, un algoritmo ricorsivo per calcolare la lunghezza di una lista generico potrebbe essere definito come segue:

(define (list-length a-list)
   (if a-list
   (+ 1 (list-length (rest a-list)))
   (0)))

Prima di tutto, si noti che define può essere utilizzata non solo per definire variabili, ma anche funzioni. Il nome della nostra funzione è list-length e richiede un argomento e precisamente una lista (a-list). Tutti gli altri argomenti di define costituiscono il corpo della funzione.
I nomi dei simboli (a differenza dei linguaggi principali) possono utilizzare tutti (quasi) i caratteri, permettendo uno stile di denominazione estrememente ampio. Assicurati di consultare la documentazione di newLISP per vedere le regole complete per la denominazione dei simboli!
La condizione if interpreta qualsiasi valore che non sia nil o la lista vuota (),  come true (vero). Così abbiamo potuto semplicemente fare il test sulla lista a-list ottenendo lo stesso risultato:

 (if a-list
     ...

Fintanto che una lista contiene il primo elemento (first) rimanente, il conteggio continua aggiungendo 1 al risultato della chiamata list-length sul resto (rest) della lista. Quando il primo elemento di una lista vuota è nil, viene restituito il valore alternativo zero che permette anche di uscire dalle chiamate ricorsive dell’algoritmo annidate nello stack (pila).
Diciamo che una lista è una struttura dati ricorsiva perché la sua definizione è ricorsiva e non semplicemente perché è suscettibile di algoritmi di elaborazione ricorsivi.
Una definizione ricorsiva di una lista potrebbe eseere qualcosa di simile:

 type list :: = empty-list |  first * list

Una lista è o la lista vuota o una lista con un primo elemento e una coda che è di per sé una lista.
Poiché il calcolo della lunghezza di una lista è abbastanza comune, esiste una funzione di libreria predefinita chiamata length che fa il lavoro per noi:

 (list-length '(1 2 5))
 ;-> 3
 (length '(1 2 5))
 ;-> 3
 > _

Torneremo alla nostra discussione sulle funzioni definite dall'utente più avanti.
Il concetto di una tabella di simboli implicita può essere visto come una successione di valutazioni delle espressioni:

 (set 'x 1)
 ;-> 1
 (+ x 1)
 ;-> 2
 > _

Quindi gli effetti collaterali tipicamente influenzano il flusso di output o questo contesto implicito. Una lista di associazioni è solo un modo per visualizzare concettualmente questa tabella di simboli implicita.

Supponiamo di voler ora cambiare momentaneamente il legame di una variabile senza sovrascriverlo in modo permanente.

 (set 'x 1' y 2)
 ;-> 2
 (let ((x 3) (y 4))
    (println x)
    (list x y))
 ;-> 3
 ;-> (3 4)
 x
 ;-> 1
 y
 ;-> 2
 > _

Si noti che x e y sono legati rispettivamente a 1 e 2 nella tabella dei simboli impliciti. L'espressione let associa momentaneamente (dinamicamente) x e y a 3 e 4 per la durata dell'espressione let. In altre parole, il primo argomento di let è un elenco di associazioni e gli argomenti rimanenti vengono eseguiti in sequenza.

La funzione list prende un numero variabile di argomenti che vengono valutati rigorosamente restituendo ogni valore risultante in una lista.

La forma let è simile alla forma iniziale mostrata in precedenza, tranne che estende dinamicamente la tabella dei simboli implicita per la durata del "blocco let" che include tutti gli argomenti dell'espressione let . Questo è possibile perché questi argomenti vengono pigramente valutati all'interno del contesto esteso del "blocco let". Se visualizzassimo la tabella dei simboli implicita all'interno del blocco let, avremmo la seguente lista di associazioni estesa:

 '((y 4) (x 3) (y 2) (x 1))

Poiché la ricerca inizia da sinistra, i valori di associazione di x e y vengono restituiti, in modo da nascondere i loro valori originali al di fuori dell’espressione let.
Quando l'espressione let termina, la tabella dei simboli si presenta come segue:

 '((y 2) (x 1))

E di conseguenza x e y assumono i valori originali (cioè quelli che avevano prima dell’esecuzione dell’espressione let).

Per capire meglio, confronta quanto segue:

 (begin (+ 1 1) (+ 1 2) (+ 1 3))
 ;-> 4
 (list (+ 1 1) (+ 1 2) (+ 1 3))
 ;-> (2 3 4)
 (quote (+ 1 1) (+ 1 2) (+ 1 3))
 ;-> (+ 1 1)
 (quote (2 3 4))
 ;-> (2 3 4)
 (let () (+ 1 1) (+ 1 2) (+ 1 3))
 ;-> 4

Nota che la funzione quote prende solo un argomento (impareremo in seguito come tale funzione è in grado di ignorare ulteriori argomenti estranei). L'espressione let senza nessuna associazione dinamica (cioè senza la dichiarazione di nuove variabili) si comporta come se fosse la funzione begin.

Ora determina che cosa restituiscono le seguenti espressioni (le risposte sono di seguito).

 (setq x 3 y 4)
 (let ((x 1) (y 2)) x y)
 ;-> ?
 x
 ;-> ?
 y
 ;-> ?

 (setq x 3 y 4)
 (begin (set 'x 1 'y 2) x y)
 ;-> ?
 x
 ;-> ?
 y
 ;-> ?

Risposte:

 (setq x 3 y 4)
 (let ((x 1) (y 2)) x y)
 ;-> 2
 x
 ;-> 3
 y
 ;-> 4

 (setq x 3 y 4)
 (begin (set 'x 1 'y 2) x y)
 ;-> 2
 x
 ;-> 1
 y
 ;-> 2

Adesso proviamo qualcosa di un pò più difficile.

 (setq x 3 y 4)
 (let ((y 2)) (setq x 5 y 6) x y)
 ;-> ?
 x
 ;-> ?
 y
 ;-> ?

Risposte:

 (setq x 3 y 4)
 (let ((y 2)) (setq x 5 y 6) x y)
 ;-> 6
 x
 ;-> 5
 y
 ;-> 4

Per capire perché la risposta sopra è corretta, considera quanto segue.

 '((y 2) (y 4) (x 3))

La lista di associazioni sopra riportata rappresenta la tabella dei simboli quando si entra nel corpo dell'espressione let subito dopo il l’associazione (dinamica) di y .

Dopo:

 (setq x 5 y 6)

la tabella dei simboli estesa diventa la sequente:

 '((y 6) (y 4) (x 5))

E al ritorno dall'espressione let viene modificata in questo modo:

 '((y 4) (x 5))

Quindi set, setq e define associano il simbolo se viene trovato nella tabella dei simboli oppure inseriscono la nuova associazione all’inizio (sulla parte anteriore) della lista di associazioni. Torneremo sulla visibilità delle variabili (scoping) dopo aver esplorato ulteriormente le funzioni.

Funzioni
--------
L’utente può definire nuove funzioni (come discusso in precedenza). La seguente funzione f restituisce la somma dei suoi due argomenti:

 (define (f x y) (+ x y))

Questa è in realtà una scorciatoia per qualsiasi delle seguenti definizioni:

 (define f (lambda (x y) (+ x y)))

 (setq f (lambda (x y) (+ x y)))

 (set 'f (lambda (x y) (+ x y)))

L'espressione "lambda" definisce una funzione anonima, cioè una funzione senza nome. Il primo argomento dell'espressione lambda è la sua lista di argomenti formali e le restanti espressioni costituiscono una sequenza (ritardata) di espressioni che costituiscono il corpo della funzione (questa sequenza di espressioni viene detta "ritardata" perchè viene valutata solamente quando chiamiamo la funzione).

 (f 1 2)
 ;-> 3
 ((lambda (x y) (+ x y)) 1 2)
 ;-> 3
 > _

Ricorda che una lista non quotata viene interpretata come una chiamata di funzione in cui tutti gli argomenti sono valutati rigorosamente. Il primo elemento della lista sopra è un'espressione lambda, quindi viene valutata restituendo una funzione anonima che viene poi applicata agli argomenti 1 e 2.

Si noti che le seguenti due espressioni sono essenzialmente le stesse:

 (let ((x 1) (y 2)) (+ x y))
 ;-> 3
 ((lambda (x y) (+ x y)) 1 2)
 ;-> 3
 > _

L'unica vera differenza è che la sequenza di espressioni nell'espressione lambda viene ritardata fino a quando non viene applicata agli argomenti. Applicare l'espressione lambda agli argomenti in effetti crea un’associazione tra gli argomenti formali e gli argomenti effettivi a cui viene applicata la funzione.

Quali sono i valori nelle seguenti espressioni?

 (setq x 3 y 4)
 ((lambda (y) (setq x 5 y 6) (+ x y)) 1 2)
 ;-> ?
 x
 ;-> ?
 y
 ;-> ?

Ricorda che le espressioni lambda e let sono essenzialmente le stesse.

 (setq x 3 y 4)
 ((lambda (y) (setq x 5 y 6) (+ x y)) 1 2)
 ;-> 11
 x
 ;-> 5
 y
 ;-> 4

Gli argomenti 1 e 2 sono superflui. L'argomento formale y nasconde la y definita al di fuori dell'espressione lambda in modo che l'impostazione di x al valore 5 sia l'unica che ha effetto dopo l’esecuzione (il ritorno) della funzione lambda.

Funzioni di primo ordine
------------------------
Le funzioni in Lisp sono valori di prima classe (ordine). Come i dati, possono essere create in fase di esecuzione e passate come qualsiasi altro valore di dati per effettuare una programmazione funzionale di ordine superiore. Si noti che i puntatori di funzione che troviamo nel linguaggio in C (e anche gli event-listener in Java/Csharp), ad esempio, non sono funzioni di prima classe. Sebbene possano essere trasmessi come dati, non possono mai essere creati in fase di esecuzione (come i dati).

Forse la funzione di ordine superiore più comunemente utilizzata è la funzione map (talvolta chiamata collect in linguaggi object oriented che hanno trasferito l'idea dal Lisp tramite Smalltalk).

 (map eval '((+ 1) (+ 1 2 3) 11))
 ;-> (1 6 11)
 > _

La funzione map applica la funzione eval a ciascun elemento della lista data. Si noti che la funzione + accetta un numero variabile di argomenti.

In questo caso avremmo potuto semplicemente scrivere quanto segue:

 (lista (+ 1) (+ 1 2 3) 11)
 ;-> (1 6 11)
 > _

Ma la funzione map può anche eseguire operazioni più interessanti.

 (map string? '(1 "Hello" 2 "World!")))
 ;-> (nil true true true)
 > _

La funzione map può processare più di una lista come argomento.

 (map + '(1 2 3 4)' (4 5 6 7) '(8 9 10 11))
 ;-> (13 16 19 22)
 > _

Alla prima iterazione + viene applicato il primo elemento di ciascuna lista.

 (+ 1 4 8)
 ;-> 13
 > _

Supponiamo di voler rilevare quali elementi di una lista sono pari:

 (map (fn (x) (= 0 (% x 2))) '(1 2 3 4))
 (nil true true true)
 > _

"fn" è una scorciatoia per "lambda":

 (fn (x) (= 0 (% x 2)))) (lambda (x) (= 0 (% x 2))))
 > _

L'operatore rimanente % viene utilizzato per determinare se un numero è divisibile per 2 (senza resto).

La funzione filter è un'altra funzione di ordine superiore comunemente utilizzata (talvolta chiamata select nelle librerie dei linguaggi Object-Oriented):

 (filter (fn (x) (= 0 (% x 2))) '(1 2 3 4))
 ;-> (2 4)
 > _

La funzione index può essere utilizzata invece per identificare gli indici degli elementi nell'elenco originale.

 (index (fn (x) (= 0 (% x 2))) '(1 2 3 4))
 ;-> (1 3)
 > _

La funzione apply è un'altra funzione di ordine superiore.

 (apply + '(1 2 3))
 ;-> 6
 > _

Perché non scrivere semplicemente (+ 1 2 3) ?

A volte potresti non sapere in anticipo quale funzione verrà applicata.

 (setq op +)
 ;-> + <40727D>
 (applica op '(1 2 3))
 ;-> 6
 > _

Questo approccio potrebbe essere utilizzato, per esempio, per implementare un dispatcher  dinamico.

Liste lambda
------------
Considera la seguente funzione:

 (define (f x y) (+ x y z))
 ;-> (lambda (x y) (+ x y z))
 f
 ;-> (lambda (x y) (+ x y z))
 > _

La funzione è un tipo speciale di lista noto come "lista lambda".

 (first f)
 ;-> (x y)
 (last f)
 ;-> (+ x y z)
 > _

Quindi una funzione "compilata" può essere esaminata (introspezione) in fase di esecuzione. In effetti può anche essere modificata in fase di esecuzione!

 (setf (n 1 f) '(+ x y z 1))
 (lambda (x y) (+ x y z 1))
 > _

(Assicurati di controllare la funzione nth-set nella documentazione di newLISP)

La funzione expand è utile in generale per modificare le liste, comprese le liste lambda.

 (let ((z 2)) (expand f 'z))
 ;-> (lambda (x y) (+ x y 2 1))
 > _

La funzione expand prende una lista di argomenti e sostituisce i simboli al suo interno con i valori simbolici di tutti gli argomenti rimanenti.

Ambito dinamico (Dynamic scope)
-------------------------------
Considera la seguente definizione di funzione:

 (define f
  (let ((x 1) (y 2))
    (lambda (z) (lista x y z))))

 ;-> (lambda (z) (lista x y z))
 > _

Da notare che il valore di f è solo lambda:

 f
 ;-> (lambda (z) (lista x y z))
 (setq x 3 y 4 z 5)
 ;-> 5
 (f 1)
 ;-> (3 4 1)
 (let ((x 5) (y 6) (z 7)) (f 1))
 ;-> (5 6 1)

Anche se l'espressione lambda è definita all'interno dell'ambito lessicale della espressione let che associa x a 1 e y a 2, al momento della sua chiamata è l'ambito dinamico che conta. Diciamo che l’associazione delle espressioni lambda in newLISP è dinamico (rispetto all’associazione lessicale del Common Lisp e di Scheme).

Qualsiasi variabile libera di un'espressione lambda viene associata dinamicamente nel momento in cui viene valutato il corpo delle espressioni. Le variabili non specificate (non associate) nella lista degli argomenti formali sono chiamate libere (free).

Possiamo usare la funzione di expand mostrata in precedenza per "chiudere" un'espressione lambda, cioè per associare tutte le variabili libere:

 (define f
  (let ((x 1) (y 2))
    (expand (lambda (z) (lista x y z)) 'x 'y)))

 ;-> (lambda (z) (lista 1 2 z))
 > _

Si noti che l'espressione lambda non ha variabili libere ora.

Tuttavia, "chiudere" l'espressione lambda con la funzione expand non è la stessa cosa della chiusura lessicale lambda che si trova in CL (Common Lisp) e Scheme. Le chiusure lessicali esistono in newLISP e saranno discusse in una sezione successiva basata sui contesti.

Lista degli argomenti di una funzione
-------------------------------------
Una funzione in newLISP può avere un numero qualsiasi di argomenti (entro limiti ragionevoli):

 (define (f z , x y)
  (setq x 1 y 2)
  (list x y z))

 ;-> (lambda (z , x y) (setq x 1 y 2) (list x y z))
 > _

I quattro argomenti formali di f sono:

 z , x y

Si noti che la virgola è il nome di un argomento (vedere le regole di denominazione dei simboli). Qui viene usato come espediente visivo.

L'unico argomento intenzionale è z .

Se il numero di argomenti formali supera il numero di argomenti effettivi a cui viene applicata la funzione, gli argomenti formali rimanenti vengono semplicemente inizializzati a nil.

 (f 3)
 ;-> (1 2 3)
 > _

In questo caso:
 , x y

sono tutti e tre inizializzati a nil. Poiché x e y appaiono come argomenti formali, agiscono come variabili locali, quindi:

 (setq x 1 y 2)

non sovrascrive il legame di x e y al di fuori dell'ambito dell'espressione lambda.

Avremmo potuto scrivere quanto segue per ottenere lo stesso effetto delle variabili locali:

 (define (f z)
  (let ((x 1) (y 2))
    (list x y z)))

;->  (lambda (z)
;->   (let ((x 1) (y 2))
;->     (list x y z)))
 > _

La virgola e gli argomenti formali inutilizzati sono un idioma utilizzato spesso in newLISP per fornire variabili locali.

Una funzione può anche essere chiamata con più argomenti di quelli che sono specificati nella sua lista di argomenti formali. In questo caso gli argomenti in eccesso vengono semplicemente ignorati.

Gli argomenti formali in eccedenza possono quindi essere trattati come argomenti opzionali:

 (define (f z x y)
  (if (not x) (setq x 1))
  (if (not y) (setq y 2))
  (lista x y z))

Ora se f viene chiamata con un solo argomento, x e y sono associati rispettivamente con i valori 1 e 2.

Lambda-macro
------------
Gli argomenti effettivi di una funzione lambda-macro non vengono valutati rigorosamente (come nel caso di una funzione lambda):

 (define-macro (my-setq _key _value)
  (set _key (eval _value)))

Poiché _key non viene valutato, si trova in forma simbolica (cioè, è come se fosse quotato). Anche _value è in forma simbolica, quindi deve essere ancora valutato:

 (my-setq key 1)
 ;-> 1
 key
 ;-> 1
 > _

Il carattere underscore "_" viene utilizzato per impedire la "cattura" delle variabili.
Considera quanto segue:

 (my-setq _key 1)
 ;-> 1
 _key
 ;-> nil
 > _

Che cosa è successo?

L’espressione:

 (set _key 1)

imposta semplicemente la variabile locale _key . Diciamo che la variabile _key è stata catturata dalla "espansione" della macro. Scheme ha macro "igieniche" (hygenic) che sono "pulite" (clean) nel senso che garantiscono la protezione delle variabili (cioè impediscono la cattura delle variabili). Normalmente, utilizzare il carattere underscore "_" nei nomi degli argomenti formali della macro è sufficiente per impedire la cattura delle variabili.
La funzione define-macro è una scorciatoia per associare un'espressione lambda-macro in un unico passaggio.

 (define my-setq
  (lambda-macro (_key _value)
  (set _key (eval _value))))

La definizione sopra è equivalente alla precedente definizione di my-setq.

Oltre alla valutazione lazy, le lambda-macro permettono anche di fornire un numero variabile di argomenti:

 (define-macro (my-setq)
  (eval (cons 'setq (args))))

La funzione cons unisce una lista con un nuovo primo elemento (inserisce un elemento al primo posto di una lista):

 (cons 1 '(2 3))
 ;-> (1 2 3)
 > _

La definizione di my-setq è ora un'implementazione più completa che consente di associare/utilizzare un numero variabile di argomenti:

 (my-setq x 10 y 11)
 ;-> 11
 x
 ;-> 10
 y
 ;-> 11
 > _

La chiamata alla funzione (args) restituisce l'elenco di tutti gli argomenti alla lambda-macro, cioè quelli non valutati.

Quindi la macro my-setq prima costruisce l'espressione simbolica mostrata sotto:

 '(setq x 10 y 11)

Poi questa espressione viene valutata.

Tuttavia, lo scopo principale delle macro è estendere la sintassi del linguaggio.

Supponiamo di voler introdurre il controllo del flusso repeat...until come estensione della sintassi del linguaggio.

 (repeat-until condition body ...)

La seguente macro permette proprio questo:

 (define-macro (repeat-until _condition)
  (let ((body (cons 'begin (rest (args)))))
  (eval (expand (cons 'begin
    (list body
      '(while (not _condition) body))) 'body '_condition))))

Usando il nostro repeat-until possiamo scrivere:

 (setq i 0)
 (repeat-until (> i 5)
  (println i)
  (inc i))
  ;  => 0 1 2 3 4 5

Le macro possono diventare complesse abbastanza rapidamente. Un trucco per convalidarle è sostituire eval con list o println per verificare l'aspetto dell'espansione appena prima di essere valutata:

 (define-macro (repeat-until _condition )
  (let ((body (cons 'begin (rest (args)))))
    (list (expand (cons 'begin
      (list body
        '(while _condition body))) 'body '_condition))))

Ora possiamo controllare l'aspetto dell'espansione.

 (repeat-until (> i 5)
 (println i) (inc i))

 ((begin
    (begin
      (println i)
      (inc i))
    (while (> i 5)
      (begin (println i) (inc i)))))
 > _

Contesti
--------
All'avvio il contesto predefinito è MAIN .

 (context)
 ;-> MAIN

Un contesto è uno spazio di nomi:

 (setq x 1)
 ;-> 1
 x
 ;-> 1
 MAIN:x
 ;-> 1
 > _

Una variabile di contesto può essere utilizzata per qualificare completamente un nome di variabile. MAIN:x si riferisce alla variabile x nel contesto MAIN.

Per creare un nuovo spazio di nomi usa la funzione "context":

 (context 'FOO)
 ;-> FOO
 FOO> _

L'istruzione sopra crea lo spazio di nomi (namespace) FOO, se non esiste già e passa ad esso. Il prompt indica lo spazio di nomi corrente soltanto se è diverso da MAIN.

Usa il predicato "context?" per determinare se una variabile è associata ad un contesto:

 FOO> (context? FOO)
 ;-> true
 FOO> (context? MAIN)
 ;-> true
 FOO> (context? Z)
 ;-> nil
 FOO> _

Le funzioni set, setq e define creano le associazioni nel contesto corrente (cioè nello spazio di nomi):

 FOO> (setq x 2)
 ;-> 2
 FOO> x
 ;-> 2
 FOO> FOO:x
 ;-> 2
 FOO> MAIN:x
 ;-> 1
 FOO> _

Per specificare una variabile, ad esempio FOO:x, non è richiesto un nome completo quando è associata al contesto corrente.

Per tornare al contesto MAIN (o a qualsiasi altro) utilizzare la variabile MAIN o il simbolo 'MAIN:

 FOO> (context MAIN)
 ;-> MAIN
 > _

 Oppure

 FOO> (context 'MAIN)
 ;-> MAIN
 > _

La funzione quote deve essere utilizzata solamente quando si creano nuovi contesti.

I contesti non possono essere nidificati: risiedono tutti allo stesso.

Si noti nell'esempio seguente che il nome y, che è definito in MAIN, non è noto nel contesto FOO:

 (setq y 3)
 ;-> 3
 (context FOO)
 ;-> FOO
 FOO> y
 ;-> nil
 FOO> MAIN:y
 ;-> 3
 FOO> _

Il prossimo esempio mostra che MAIN non è speciale in alcun modo: è soltanto il contesto predefinito. MAIN non conosce z, ad esempio:

 FOO> (setq z 4)
 ;-> 4
 FOO> (context MAIN)
 ;-> MAIN
 z
 ;-> nil
 FOO:z
 ;-> 4

Tutti i nomi delle funzione predefinite si trovano in una sezione globale speciale del contesto MAIN:

 println
 ;-> println <40AC99>
 (context FOO)
 FOO
 FOO> println
 ;-> println <40AC99>
 FOO>

La funzione built-in di println è nota in entrambi i contesti MAIN e FOO.
La funzione println è stata "esportata" nello stato globale.

La sequenza di espressioni qui sotto mostra che MAIN:t non è conosciuto inizialmente nei contesti FOO o BAR finché non è stato elevato allo stato globale:

 FOO> (context MAIN)
 ;-> MAIN
 (setq t 5)
 ;-> 5
 (context 'BAR)
 ;-> BAR
 BAR> t ;questa istruzione genera il simbolo t nel contesto BAR
 ;-> nil
 BAR> (context FOO)
 ;-> FOO
 FOO> t ;questa istruzione genera il simbolo t nel contesto BAR
 ;-> nil
 FOO> (context MAIN)
 ;-> MAIN

Eleviamo t allo stato globale (che si trova nel contesto MAIN):

 (global 't)
 ;-> t
 (context FOO)
 ;-> FOO
 FOO> t
 ;-> 5 ;purtroppo si ottiene nil perchè t è già stato creato in FOO
 FOO> (context BAR)
 ;-> BAR
 BAR> t
 ;-> 5 ;purtroppo si ottiene nil perchè t è già stato creato in BAR

Solo i nomi definiti nel contesto MAIN possono essere elevati allo stato globale.

Nota del traduttore
Le seguenti istruzioni funzionano correttamente con lo stato globale:
; partiamo dal contesto MAIN
(context MAIN)
; definiamo il contesto A1
(context 'A1)
;-> A1
; ritorniamo al contesto MAIN
(context MAIN)
;-> MAIN
; definiamo il contesto A1
(context 'A2)
;-> A2
; ritorniamo al contesto MAIN
(context MAIN)
;-> MAIN
; definiamo una variabile
(setq a 2)
;-> 2
; eleviamo la variabile allo stato globale
(global 'a)
;-> a
(context 'A1)
;-> A1
a
;-> 2
(context 'A2)
;-> A2
a
;-> 2
(context MAIN)
;-> MAIN

; Continuiamo l'esempio per vedere cosa accade:
(context 'A3)
;-> A3
(symbols)
;-> () ; la lista dei simboli del contesto A3 è vuota
; Quando si esegue una istruzione, i simboli dell'istruzione vengono associati a quelli esistenti (nel contesto corrente e nello stato globale) oppure, se non esistono, vengono creati nel contesto corrente.
a ; questa istruzione crea il simbolo a nel contesto corrente
;-> nil
(symbols)
;-> (a) ; come volevasi dimostrare.

Ambito lessicale
----------------
Le funzioni set, setq e define associano i nomi nel contesto corrente:

 (context 'F)
 ;-> F
 F> (setq x 1 y 2)
 ;-> 2
 ; elenco dei simboli definiti nel contesto corrente
 F> (symbols)
 ;-> (x y)
 F> _

Si noti che la funzione symbols restituisce i nomi dei simboli associati al contesto corrente.

 F> (define (id z) z)
 ;-> (lambda (z) z)
 F> (symbols)
 ;-> (id x y z)
 F> _

L’ambito lessicale del contesto corrente continua fino al prossimo cambio di contesto. Poiché è possibile in seguito tornare a un particolare contesto, è possibile aumentare il suo ambito lessicale e potrebbe apparire frammentato nel file sorgente.

 F> (context 'B)
 ;-> B
 B> (setq a 1 b 2)
 ;-> 2
 B> _

Per ambito lessicale, intendiamo l'ambito definito dal codice sorgente. I nomi x ed y sono definiti nell'ambito lessicale del contesto F mentre i nomi a e b sono definiti nell'ambito lessicale del contesto B.

Tutte le espressioni lambda sono associate all’ambito lessicale del contesto in cui sono definite. Di conseguenza le espressioni lambda sono in definitiva "chiuse" dal contesto.

L'espressione lambda sottostante si trova nell’ambito lessicale di MAIN e anche nell’ambito lessicale dell'espressione (let ((x 3)) ...).

 (context MAIN)
 (setq x 1 y 2)
 ;-> 2

 (define foo
    (let ((x 3))
      (lambda () (list x y))))

 ;-> (lambda () (list x y))

 (foo)
 ;-> (1 2)
 > _

Ricordiamo che le invocazioni lambda in generale hanno un ambito dinamico. Anche se questo è vero occorre notare che la chiamata alla funzione lambda è in definitiva "chiusa" dall'ambito lessicale del contesto MAIN e non dall'espressione let .

Continuando con l'ultimo esempio possiamo vedere questo ibrido ambito lessicale/dinamico al lavoro:

 (let ((x 4)) (foo))
 ;-> (4 2)
 > _

Questa volta il contesto con ambito lessicale viene ampliato dinamicamente durante l'esecuzione dell'espressione let in modo che (foo) venga richiamato nell'ambito dinamico dell'espressione let.

Cosa succederà se invochiamo (foo) in un contesto alieno?

 (context 'FOO)
 ;-> FOO
 FOO> (let ((x 5)) (MAIN:foo))
 ?

Pensaci per un momento. L'espressione let in alto estende dinamicamente l'ambito lessicale di FOO anziché MAIN.

 FOO> (let ((x 5)) (MAIN:foo))
 ;-> (1 2)
 FOO> _

Che cosa è successo? L’ambito dinamico di MAIN:foo include solo l'ambito del contesto MAIN eventualmente esteso dinamicamente. Poiché l'espressione let estende l'ambito dinamico di FOO, l'invocazione di MAIN:foo non vede l’associazione FOO:x => 5.

La seguente espressione è rivelatrice:

 FOO> MAIN:foo
 ;-> (lambda () (list MAIN:x MAIN:y))
 FOO> _

Quando abbiamo introspettato foo nel contesto MAIN, non abbiamo visto il qualificatore predefinito MAIN.

 (context MAIN)
 foo
 (lambda () (lista x y))
 > _

Quindi, anche se il contesto FOO è stato ampliato in modo dinamico con l’associazione FOO:x => 5, possiamo vedere che quando MAIN:foo viene eseguito esecuzione, limita la sua ricerca solo al contesto MAIN (possibilmente esteso dinamicamente).

Quale sarebbe il valore della seguente espressione?

 (context FOO)
 FOO> (let ((MAIN:x 5)) (MAIN:foo))
 ?

Se hai risposto quanto segue, hai indovinato:

 (context FOO)
 FOO> (let ((MAIN: x 5)) (MAIN:foo))
 ;-> (5 2)
 FOO> _

Diciamo che il contesto, o spazio dei nomi, è la chiusura lessicale di tutte le funzioni definite all'interno di quel contesto.

Comprendere come newLISP traduce e valuta il codice sorgente è fondamentale per capire correttamente il funzionamento dei contesti.

Ogni espressione di livello superiore viene prima tradotta e quindi valutata in ordine da newLISP prima di passare alla successiva espressione di livello superiore. Durante la fase di traduzione tutti i simboli (non qualificati) sono considerati da associare nel contesto corrente. Quindi l'espressione di contesto è semplicemente una direttiva per passare (o creare e passare) al contesto indicato. Questo ha importanti implicazioni come vedremo tra poco:

; prima espressione
(context 'FOO)

;seconda espressione
(setq r 1 s 2)

Ciascuna delle espressioni di cui sopra sono espressioni di livello superiore, nonostante l’indentazione suggerisca diversamente. La prima espressione viene tradotta nel contesto corrente. In questo modo, FOO diventa un simbolo associato al contesto corrente (ad es. MAIN, se non lo è già) prima che l'espressione venga effettivamente valutata. Una volta che l'espressione tradotta viene valutata, avviene il cambio di contesto, che può essere visto chiaramente quando si opera in modalità interprete:

(context MAIN)
(context 'FOO)
;-> FOO
FOO>

Quindi, quando newLISP si appresta a interpretare:

FOO> (setq r 1 s 2)

il contesto attuale è ora FOO.

Considerare ora il seguente frammento di codice:

(context MAIN)
(begin (context 'FOO) (setq z 5))
;-> 5
FOO> z
;-> nil
FOO> MAIN:z
;-> 5
FOO> _

Che cosa è successo?

Prima la singola espressione di primo livello:

(begin (context 'FOO) (setq z 5))

è stato tradotta nel contesto MAIN. Quindi z è diventata:

(setq MAIN:z 5)

Appena l'espressione composta begin inizia ad essere valutata viene cambiato il contesto, ma la variabile MAIN:z è già impostata a 5 (perchè prima della valutazione vengono associati i simboli). Al ritorno della valutazione dell'espressione composta, il contesto rimane commutato su FOO.

Per capire correttamente questo funzionamento dobbiamo considerare il comportamento del codice sorgente nelle sue due fasi, cioè la traduzione e l'esecuzione, specialmente quando utilizziamo i contesti.

I contesti possono essere utilizzati per organizzare dati e/o funzioni come record o strutture, classi e moduli:

(context MAIN)
(context 'POINT)
;-> POINT
POINT> (setq x 0 y 0)
(context MAIN)

Il contesto POINT mostrato sopra può essere pensato per una struttura che ha due campi (o slot):

POINT:x
;-> 0
> _

Ma poichè i contesti possono anche essere clonati, possono servire da semplice classe o prototipo. La funzione new mostrata di seguito crea un nuovo contesto chiamato p se non esiste già e quindi unisce una copia delle associazioni trovate nel contesto POINT:

(new POINT 'p)
;-> p
p:x
;-> 0
(setq p:x 1)
;-> 1
p:x
;-> 1
POINT:x
;-> 0

La sequenza di espressioni sopra mostra che il contesto p è una copia distinta e separata di POINT.

L'esempio seguente mostra come i contesti potrebbero essere utilizzati per fornire un semplice meccanismo di ereditarietà della struttura dati:

(context 'POINT)
;-> POINT
(setq x 0 y 0)
;-> 0
(context MAIN)
;-> MAIN

(context 'CIRCLE)
;-> CIRCLE
(new POINT CIRCLE)
;-> CIRCLE
(setq radius 1)
;-> 1
(context MAIN)
;-> MAIN

(context 'RECTANGLE)
;-> RECTANGLE
(new POINT RECTANGLE)
;-> RECTANGLE
(setq width 1 height 1)
;-> 1
(context MAIN)

Si noti come la funzione new unisce i campi x e y di POINT in CIRCLE che aggiunge un campo aggiuntivo chiamato radius. RECTANGLE "eredita" da POINT in modo simile.

La macro def-make qui sotto ci consente di definire istanze nominali di un contesto e facoltativamente specificare gli inizializzatori:

(define-macro (def-make _name _ctx)
  (let ((ctx (new (eval _ctx) _name))
        (kw-args (rest (rest (args)))))
  (while kw-args
    (let ((slot (pop kw-args))
          (val (eval (pop kw-args))))
         (set (sym (name slot) ctx) val)))
ctx))

Ad esempio, è possibile creare un'istanza RECTANGLE di nome r e sovrascrivere i valori predefiniti per x e height con la seguente espressione:

(def-make r RECTANGLE x 2 height 2)

La seguente funzione convertirà una "istanza" di contesto in una stringa:

(define (context->string _ctx)
  (let ((str (list (format "#S(%s" (string _ctx)))))
  (dotree (slot _ctx)
    (push (format "%s:%s" (name slot)
           (string (eval (sym (name slot) _ctx))))
            str -1))
    (push ")" str -1)
(join a str)))

Ora possiamo verificare il contenuto di r:

(context->string r)
"#S(r height:2 width:1 x:2 y:0)"
> _

Si noti come vari caratteri come " -> " possono essere usati nei nomi degli identificatori.

Adesso dovresti conoscere abbastanza su newLISP ora per decifrare le funzioni def-make e context->string che abbiamo definito. Assicurati di cercare nella documentazione di newLISP eventuali operazioni primitive come dotree, push, join, ecc. che non ti sono familiari.

Sia Common Lisp che Scheme hanno funzioni lessical scope, questo significa che una chiusura è esclusiva per una particolare funzione. Le funzioni in newLISP possono condividere una chiusura lessicale, cioè il contesto, che è simile a un oggetto i cui metodi condividono uno stato comune. Gli esempi di contesto mostrati finora potrebbero aver incluso anche funzioni. La documentazione di newLISP fornisce diversi esempi di utilizzo dei contesti come semplice oggetti.


============================================================================
newLISP per programmatori (Dmitry Chernyak)
============================================================================
v. 1.1

(C) 2006, Dmitry Chernyak losthost@narod.ru.
http://en.feautec.pp.ru
https://web.archive.org/web/20091010040813/http://en.feautec.pp.ru/store/fun-of-newlisp.html

Traduzione: Massimo Corinaldesi aka cameyo 2019

Questo articolo è stato scritto per i programmatori di linguaggi "tradizionali" procedurali e object-oriented. Il suo scopo è quello di mostrare alcune convenienti tecniche di programmazione comuni per il linguaggio funzionale LISP, ma raramente utilizzati in altre linguaggi.

LISP è un'intera famiglia di dialetti, il più famoso e riconosciuto tra questi è Common LISP. Tuttavia, la base di questo articolo è il dialetto semplificato newLISP, il cui interprete funziona in qualsiasi sistema operativo e che può essere utilizzato per "le attività quotidiane" a livello del linguaggio Perl. Le differenze tra newLISP e Common LISP nel quadro del materiale presentato non sono assolutamente significative.

Dove trovare la distribuzione newLISP è scritto nell'ultimo capitolo.

Dunque proviamo!

A COSA SERVE IL LISP?
---------------------

La maggior parte dei linguaggi di programmazione ​​(Con l'eccezione del BASIC :-)) sono stati sviluppati per semplificare la soluzione di certi problemi. Il nome del linguaggio LISP sta per "LISt Processor", "gestore di liste" - questa è la principale area delle sua applicazioni.

Durante la scrittura di codice LISP, le liste sono delimitate da parentesi tonde, ed i suoi elementi sono separati dal carattere spazio. Che cosa può contenere una lista? - in LISP - quasi tutto! Gli elementi di una lista possono essere costanti, nomi di variabili e funzioni (nella terminologia LISP, simboli) e, naturalmente, altre liste:

(1 2 "abc" var (34 "w"))

Non è esagerato dire che in LISP la lista è la principale struttura di dati e di aggregazione. Records e strutture in Common Lisp sono implementati per mezzo del linguaggio stesso (primitive), ma in newLISP non ce ne sono affatto. Le implementazioni moderne (tra cui newLISP) sono dotate di supporto per gli array e gli hash, ma in realtà sono utilizzati solo nei casi in cui l'algoritmo ha davvero bisogno array o hash, vale a dire, sorprendentemente, alquanto raramente. Va notato che in LISP vengono solitamente utilizzate le "liste associative" al posto degli hash.

Una lista associativa è una "lista di liste", in cui il primo elemento è utilizzato come chiave per la ricerca:

((key1 value1_1 value1_2) (key2 value2_1 value2_2) ...)

Per la ricerca nelle liste associative, si utilizzano le funzioni "assoc" e "lookup". Da un lato, questo approccio (teoricamente) porta ad una riduzione delle prestazioni di ricerca (in pratica, questo è un punto controverso...), ma d'altra parte, si può avere più elementi con la stessa chiave e si ha sempre una sequenza fissa di record.

(Come?
 (leggi il programma Lisp))

È molto semplice - tutto ciò che è all'interno delle parentesi è una chiamata di funzione, la prima parola dopo la parentesi aperta è il nome della funzione, e il resto sono i suoi parametri.
Un matematico scriverebbe:

f1 (x, y)

su LISP sarà simile a:

(f1 x y)

Una espressione più complicata:

f1(x, f2(y, z))

si trasformerà in:

(f1 x (f2 y z))

Esempio, addizione

"in modo matematico":

1 + 2 -> 3

"in modo LISP":

(+ 1 2) -> 3

(di seguito, il segno "->" precederà il risultato della valutazione dell'espressione)

Pensi che sia "scomodo!"? – Allora guarda questo:

(+ 1 2 3 4 5) -> 15

Inoltre saranno mostrate le conseguenze più interessanti di questo tipo di approccio.

COME VIENE CALCOLATA UN'ESPRESSIONE LISP?
-----------------------------------------

Così come in matematica: quando calcoliamo una funzione, prima vengono calcolati i suoi argomenti, e poi le azioni definite da questa funzione sono eseguite su di essi.

(+ 10 (sqrt 25)) -> 15

la funzione sqrt (radice quadrata) è calcolata, il risultato (5) viene passato alla funzione +, che, a sua volta, viene calcolata e restituisce il risultato: 10 + 5 = 15.

Alcuni esempi utili:

(setq a "test") -> "test"

"setq" è una funzione di assegnazione, restituisce il valore dell'ultimo argomento, ma assegna anche al carattere "a" il valore "test".

a -> "test"

Il calcolo di un carattere restituisce il suo valore.

(setq b (sqrt 25)) -> 5

Non ci sono commenti.

(setq b '(sqrt 25)) -> (sqrt 25)

un apostrofo "quote" è un carattere speciale che impedisce la valutazione dell'espressione: il risultato è una mormale lista. In realtà, un apostrofo è un'abbreviazione della funzione quote. Questa è l'unica estensione che è stata introdotta nella sintassi del LISP (uso puro di parentesi), grazie all'uso frequente:

(setq b (quote (sqrt 25))) -> (sqrt 25)

"quote", a sua volta, è l'esempio più semplice di una "funzione macro" - una funzione speciale i cui argomenti non vengono calcolati/valutati automaticamente. Torneremo in seguito sui diversi modi di applicare le funzioni macro.

(setq b '(("first" 1) ("second" 2) ("third" 3)))
 -> (("first" 1) ("second" 2) ("third" 3))

(b 1) -> ("second" 2)

per ottenere un elemento tramite un indice, il primo elemento ha indice 0. Tale sintassi di newLISP si chiama "indicizzazione implicita".

(nota: non esiste una sintassi simile in Common LISP, l'indicizzazione viene eseguita dalla funzione nth).

(1 b) -> (("second" 2) ("third" 3))

Taglio (slice) dal secondo elemento alla fine della lista.

(0 2 b) -> (("first" 1) ("second" 2))

taglio dal primo elemento della lista con una lunghezza di 2 elementi. C'è un modo più tradizionale per LISP - la funzione "nth" (elemento per indice) e "slice" - taglio.

(assoc "second" b) -> ("second" 2)
(lookup "second" b) -> 2
(lookup "second" b 0) -> "second"
(lookup "second" b 1) -> 2

Ricerca nella lista associativa: "assoc" restituisce l'intero sottolista, e "lookup" restituisce l'ultimo elemento della sottolista, o un elemento con l'indice specificato nel terzo parametro.

(Perchè?
 (tutte
 (queste parentesi)))

Il codice di un programma LISP è visivamente simile al titolo di questo capitolo. Naturalmente, la cosa più importante che cattura immediatamente l'occhio è l'abbondanza di parentesi :-). E la prima domanda che di solito si pone quando si acquisisce familiarità con LISP è perché usare così tante parentesi quando potrebbero essere sostituite con lo stesso numero di virgole, punti e virgola, parentesi graffe e altre sintassi convenienti?

La risposta si trova in superficie: probabilmente hai già notato la somiglianza tra le liste del LISP e le espressioni del LISP. In effetti, l'espressione LISP è sintatticamente una lista LISP. Inoltre un'espressione può essere trattata come una normale lista – memorizzata in variabili, sottoposta a trasformazioni, passata come parametro di una funzione nella forma di una lista e, ovviamente, verranno eseguite!

Questa è una delle proprietà fondamentali del LISP - l'uso del codice come dati.

Un semplice programma di esempio: movimento in modo casuale nelle quattro direzioni

(setq x 0 y 0); posizione iniziale

(define (up moves) (dec 'y moves))
; definizione di una funzione con il nome "up",
; il parametro "sposta", che riduce
; il valore del carattere "y" per il valore di "moves"

(define (down moves)  (inc 'y moves)); similare
(define (left moves)  (dec 'x moves))
(define (right moves) (inc 'x moves))

(setq doings (list up down left right))
; solo un elenco di caratteri con
; le funzioni appena definite ;-)
; funzione list - crea una lista

(seed (date-value))
; inizializza il generatore di numeri random

; spostamento diretto
dotimes (i 100)
  ((doings (rand 4)) (rand 5))
  (println x ":" y))

Analizziamo l'espressione spostamento più in dettaglio:

(dotimes (i 100) espressione1 espressione2 ...) - calcola le "espressioni" 100 volte, mentre il simbolo "i" assume valori​​da 0 a 99.

(rand 4) - genera un numero intero casuale nell'intervallo da 0 a 3.

(doings (rand 4)) - questa forma è stata descritta nel capitolo precedente come "ottenere un elemento da una lista in base all'indice". Di conseguenza: "doings" è una lista, e "(rand 4)" serve come indice.

Vale la pena di guardare la lista delle azioni/moves più da vicino:

doings ->
 ((lambda (moves) (dec 'y moves))
  (lambda (moves) (inc 'y moves))
  (lambda (moves) (dec 'x moves))
  (lambda (moves) (inc 'x moves)))

Come promesso all'inizio del capitolo, una normale lista può contenere codice di programma! La parola "lambda", che si trova all'inizio di ogni funzione - l'elemento dell'azione, non è un elemento della lista, ma indica che questa lista è una funzione che può essere chiamata. Tali funzioni sono chiamate "funzioni lambda" o "funzioni senza nome." Allo stesso tempo, la funzione lambda è una lista normale, e il primo elemento (zero) della nostra lista lambda è l'elemento "(moves)".

Forse avete una domanda: che dire dei nomi - "up", "down", "left" e "destra"? In realtà, questi nomi sono solo i caratteri delle variabili a cui vengono assegnate le liste lambda come valori:

up -> (lambda (sposta) (dec 'y mosse))

(up 1) -> -1; funzione viene chiamata con il parametro 1

(nth 0 up) -> (moves)
; poiché indicizzazione implicita non funziona in questo
; caso, utilizzare la funzione ennesima per ottenere
; l'elemento 0

(setq up-new up)

up-new -> (lambda (moves) (dec 'y moves))

(up-new 1) -> -2; era -1, diminuiamo ancora di uno...

Infatti, le due espressioni seguenti sono identiche:

define (up moves) (dec 'y moves))

setq up '(lambda (moves) (dec' y moves)))

Tuttavia, andiamo avanti con il nostro esempio ...

((doings (rand4)) (rand 5)) - dal momento gli elementi della lista "doings" sono funzioni, si può usare come una normale chiamata a funzione - cioè, sostituire il nome della funzione nell'espressione LISP. Di conseguenza, un numero casuale (rand 5) sarà l'argomento della funzione.

(println expression1 expression2 ...) - stampa i risultati della valutazione delle espressioni-argomenti, completandoli con un avanzamento di riga. Inoltre, la funzione println restituisce il risultato della valutazione dell'ultima espressione dell'argomento.

In conclusione dell'analisi di questo esempio, occorre notare che, con non meno di successo, potremmo fare una lista di "azioni" non dal codice della funzione, ma dai caratteri a cui sono assegnati:

...
(setq doings' (up down left right))
...
(dotimes (i 100)
  (apply (doings (rand 4)) (list (rand 5)))
  (println x ":" y))

L'unica nuova funzione qui è "apply" - il suo primo argomento è il nome della funzione che si deve chiamare, e il secondo è un elenco di argomenti a cui questa funzione deve essere applicata.

Opportunità simili a quelli descritte e parzialmente rudimentali sono presenti nei linguaggi procedurali, tuttavia, essi sono utilizzati principalmente da programmatori molto esperti nei in momenti di disperazione. Per renderli più amichevoli, la OOP è stata aggiunta ai linguaggi procedurali, che, a sua volta, richiede la decomposizioni in oggetti e rende più complessa la programmazione.

Tuttavia, in LISP, l'uso del codice come dati è una pratica "quotidiana", applicata quando necessario (e anche quando non servirebbe :-).

Alla fine del capitolo, qualche parola sulla OOP in Lisp: In Common Lisp, il sistema di programmazione orientata agli oggetti (CLOS) è implementato come una normale libreria scritta in Common LISP - senza alcuna modifica al linguaggio in se stesso.
Nel linguaggio newLISP, per la programmazione con gli oggetti, viene proposto un sistema integrato di "contesti" ( "context") – spazi di nomi (namespace) isolati che implementano i principi fondamentali della programmazione orientata agli oggetti in forma più adatta per la scrittura rapida di "script".

LE ECCEZIONI CHE CONFERMANO LE REGOLE.
--------------------------------------

Nei capitoli precedenti, abbiamo già incontrato un'eccezione insolita alla sintassi armoniosa delle parentesi LISP - il simbolo della apostrofo, una notazione abbreviata per la funzione macro "quote". Infatti, questa funzione è l'unico modo in LISP per impostare una funzione costante (non valutata) come argomento. Cosa che la rende così speciale?

(define (test1 arg) (println arg))
; definiamo una funzione ordinaria
(test1 (+ 1 2)) -> 3
; e prova ...

(define-macro (test2 arg) (println arg))
; ora definiamo una "inusuale" funzione macro
(test2 (+ 1 2)) -> (+ 1 2)
; e prova ...

A differenza delle funzioni ordinarie, in cui gli argomenti vengono valutati automaticamente prima della chiamata, quando si utilizzano le "funzioni macro" viene utilizzato il modello di valutazione "lazy" (pigro), in cui gli argomenti non vengono assolutamente valutati.

Al fine di evitare confusione inutile, è opportuno notare che il termine "macro" in LISP non significa che la funzione viene calcolata/espansa dal preprocessore prima di interpretare (compilare) il codice principale, come avviene nel linguaggio C. – Le funzioni "Macro", così come quelle ordinari, vengono calcolate/valutate direttamente durante l'esecuzione del programma.

La funzione di "quote" è la funzione macro più semplice. Se non fosse definita nel linguaggio, potrebbe essere scritta come segue:

(define-macro (quote a) a)
; funzione prende un argomento
; e lo restituisce inalterato (senza valutarlo)

Se si passa un'espressione LISP come argomento a una funzione macro, allora questa espressione in sé (non valutata) sarà disponibile come variabile nel calcolo della funzione macro chiamata. Se si desidera valutarla, è necessario utilizzare la funzione "eval":

(define-macro (test3 arg) (println (eval arg)))
(test3 (+ 1 2) -> 3

Tale comportamento permette una interessante opportunità:

(define-macro (my-if condition result-true result-false)
  (let  (_c (eval condition))
    (and _c (eval result-true))
    (or  _c (eval result-false))))

(my-if (= 1 1) (println "true") (println "false")) -> "true"
(my-if (= 1 2) (println "true") (println "false")) -> "false"

La funzione "let" ha la seguente sintassi:

(let (character1 expression-value1 character2 expression-value2 ...)
  action expression
  action expression
  ....)

crea e inizializza i caratteri/variabili che agiranno al momento del calcolo delle espressioni-azioni, e cessano di esistere (memoria libera) al momento del ritorno dalla funzione "let". Il risultato della funzione let è il risultato della valutazione dell'ultima espressione.

Le funzioni "and" e "or" sono operatori logici ed operano secondo uno schema evidente: per "or" - se la prima espressione è falsa, la seconda è calcolata, ecc, viene ritornato il risultato della prima espressione vera (true).
Per "and", rispettivamente.

Così, abbiamo discretamente definito e provato un nuovo costrutto di sintassi - l'operatore più comune di branching condizionale! E la cosa più sorprendente di questo operatore è che esteriormente è indistinguibile da tutti i costrutti della sintassi LISP, compresi quelli incorporati! (built-in)
Grazie a questa caratteristica, LISP è giustamente chiamato un "meta-linguaggio", o "il linguaggio per la creazione di linguaggi": uno dei metodi di programmazione raccomandati in LISP è quello di creare il proprio linguaggio con la sintassi conveniente per risolvere un problema specifico, e quindi utilizzare questo linguaggio per ottenere il risultato desiderato.

Tra l'altro, durante la creazione di compilatori Common Lisp, la maggior parte della sintassi del linguaggio standard è implementato non nel linguaggio di creazione del compilatore, ma in Common Lisp se stesso, come librerie.

Naturalmente, ci sono modi più complessi e produttivi per costruire le funzioni-macro, basati sula modifica del codice passato loro e la compilazione di nuove espressioni sulla base di questo codice. Durante la scrittura di macro in newLISP non dimenticate di fare la conoscenza con la funzione "letex".

UN PÒ DI COMPUTAZIONE CONDIZIONALE.
-----------------------------------

Dal momento che abbiamo citato l'operatore condizionale, diamo uno sguardo più da vicino ai calcoli logici in newLISP (il LISP tradizionale ha alcune differenze, in particolare, una diversa interpretazione del concetto di "nil" e regole molto insoliti di uguaglianza).
La base dei calcoli logici, la logica binaria, è costruita sui valori ​​di "vero" (true) e "falso" (false). In newLISP, il valore "false" utilizza il simbolo "nil". Il secondo scopo di questo carattere è il valore "null" che hanno i caratteri non inizializzati.

Tutti gli altri valori ​​in newLISP sono trattati come true (incluso 0, una stringa vuota e una lista vuota). Per facilità di scrittura, newLISP ha anche un simbolo speciale "true" - alcune funzioni logiche possono restituirlo.

(if condition expression
    condition expression
    ...
    otherwise, expression)

Così appare la vera funzione della ramificazione condizionale. Se la "condition" è vera, allora la corrispondente "espressione" viene eseguita e il calcolo della funzione viene interrotto. Se tutte le "condition" sono false, allora viene eseguita l’espressione "otherwise, expression". Se una qualsiasi "espression" viene valutata, allora il risultato viene restituito come risultato della funzione, altrimenti viene restituito nil.
Si noti che un "expression" può essere una sola espressione:

(if right (+ x 1))

Se è necessario eseguire una sequenza di espressioni diverse, allora è necessario "racchiuderle" con la funzione "begin":

(if right (begin
            (+ x 1)
            (+ y 1)))

"begin" è una semplice funzione per collegare una sequenza di espressioni. Naturalmente, se necessario, invece di questa, è possibile utilizzare la funzione già vista "let" o un altro operatore condizionale o qualcos'altro adatto per il caso.

Notare che l'esempio potrebbe utilizzare dei caratteri UTF-8 per i nomi dei simboli, poichè in newLISP questo è valido.

Un'alternativa al costrutto "if" è la funzione "cond":

(cond (expression condition)
       (expression condition)
       ...)

A causa delle parentesi aggiuntive, "expression" può essere una sequenza di diverse espressioni, senza ulteriori contenitori.

E, infine, la regina delle funzioni condizionali è la funzione "case":

(case symbol
   (test constant expression)
   (test constant expression)
   ...
   (true expressions))

Esempio:

(define (translate n)
  (case n
    (1 "one")
    (2 "two")
    (3 "three")
    (4 "four")
    (true "Can't translate this")))

 (translate 3) -> "three"
 (translate 10) -> "Can't translate this"

In questo esempio, il valore del simbolo "n" sarà sequenzialmente confrontato con i "test costanti" 1, 2, 3, ecc. e, se abbinato, l'espressione corrispondente verrà calcolato. Si noti che in questo esempio costanti di tipo stringa sono utilizzate come expressions. La costante finale "true" viene usata per indicare l'azione predefinita.

Ora, utilizzando la funzione "translate", un valore numerico può essere convertito in una stringa numerica.

Va notato che la funzione "caso" ha una particolarità: le "costanti di prova" sono solo costanti, non possono essere delle espressioni da calcolare. Cioè, il seguente programma è sintatticamente valido, ma non porterà al risultato desiderato:

(case n
   (a "n is equal to a")
   ((+ a 1) "n is one more than the value of a"))

Il vantaggio di questo comportamento è l'aumento di velocità della funzione "case".

Ma cosa succede se la convenienza è più importante? È molto semplice scrivere una macro:

(define-macro (ecase _v)
   (eval (append
           (list 'case _v)
           (map (fn (_i) (set-nth 0 _i (eval (_i 0))))
                (args))))))
Proviamo:

(setq a 1 n 2)
; assegna a = 1, n = 2

(ecase n
  (a "n is equal to a")
  ((+ a 1) "n is one more than the value of a"))

-> "n is one greater than the value of a"

La funzione macro ecase funziona nel seguente modo: nella lista dei suoi argomenti, che è lo stessa di quella della funzione "case", sostituisce tutte le espressioni che sono al posto delle "costanti di prova" con il risultato del loro calcolo - cioè, con altre costanti.
Poi il simbolo case e il nome della variabile testata vengono aggiunti in cima alla lista convertita.
Poi l'espressione risultante viene valutata utilizzando la funzione eval.

Il testo di questa macro è ancora un po 'complicato - sarà chiaro dopo i capitoli "Conversione di liste" e "Funzioni anonime".

ASSEGNAZIONE FUNZIONALE TALMENTE "SCOMODA".
-------------------------------------------

Espressione semplice:

a = 1 + 2;

con newLISP può essere scritta come:

(setq a (+ 1 2)) -> 3

Sembra insolito? Non è ovvia la convenienza di questo metodo?
Dai un'occhiata a questo:

(setq a (+ 1 2 3 4 5)) -> 15

Molte delle funzioni LISP standard possono gestire un numero arbitrario di argomenti Qui, naturalmente, si può dire che il vantaggio non è grande - la capacità di indicare in modo statico un elenco arbitrario di argomenti. Tuttavia, non abbiate fretta...
È facile notare che gli argomenti della funzione "+" sono una lista. Scriviamo sotto:

(setq L '(1 2 3 4 5)) -> (1 2 3 4 5)

L -> (1 2 3 4 5)

Ora abbiamo una lista. Se potessimo costruire un'espressione dal nome della funzione desiderata e la nostra lista, e potessimo calcolarla, allora l'elaborazione di funzioni di un numero arbitrario di argomenti avrebbe più senso...

(define-macro (my-apply fun lst)
  (eval (cons fun (eval lst))))

(my-apply + L) -> 15

La funzione "cons", nuova per noi, crea una lista con l'aggiunta di un nuovo elemento (primo argomento) all'inizio di quella esistente (secondo argomento). In realtà, abbiamo già visto la funzione built-in "apply", che fa la stessa come la nostra macro.

(setq a (a + L)) -> 15

La funzione "applica" valuta la funzione indicata dal primo argomento, passando come argomenti la lista del secondo argomento.
Naturalemente, al posto della funzione "+" ci può essere una qualsiasi altra funzione, compresa una definita dall'utente:

(define (average) (div (apply add (args)) (length (args))))
-> (lambda () (div (apply add (args)) (length (args))))

(apply average L) -> 3

"add" e "div" sono analoghi delle funzioni e "+" "/", ma funzionano con i numeri in virgola mobile. "args" è una funzione che restituisce tutti gli argomenti non collegati passati alla funzione.
Così:

(define (f x y) (println "x =" x "y =" y "args =" (args)))
-> (lambda (x y) (println "x =" x "y =" y "args =" (args)))

(f 1 2 3 4) -> x = 1 y = 2 args = (3 4)

CARATTERISTICHE ANONIME.
------------------------

In LISP ci sono un sacco di funzioni che, come "apply", prendono altre funzioni come argomenti. Puoi anche scriverne una.

Uno dei più notevoli esempi built-in è la funzione "map".

(map pow '(1 2 3 4)) -> (1 4 9 16)
; pow – elevamento a potenza

(map first '((1 2 3) (4 5 6) (7 8 9))) ->' (1 4 7)
; first - restituisce il primo elemento della lista

La funzione "map" viene utilizzata per convertire gli elementi delle lista. La funzione specificata come primo argomento di "map" viene applicata in sequenza (uno per uno) a tutti gli elementi della lista specificata nel secondo argomento. I risultati del calcolo vengono inseriti in una nuova lista, che viene restituita dalla funzione.
Comunque "map", non sembra molto conveniente nel caso seguente:

(define (third lst) (lst 2))
 ; there is no third function

(map third '((1 2 3) (4 5 6) (7 8 9))) ->' (3 6 9)
Abbiamo solo voluto prendere il terzo elemento di ogni sottolista, e per questo abbiamo dovuto pre-definire la funzione. Anche se a volte questo non è affatto dannoso, in generale, mi piacerebbe essere in grado di farne a meno. La funzione "fn" viene in soccorso - il costruttore di liste lambda anonimi:

(map (fn (lst) (lst 2))
     '((1 2 3) (4 5 6) (7 8 9))) ->' (3 6 9)

La funzione "fn" funziona in modo simile alla funzione di "define", ma e "fn" non assegna la lista lambda creata ad una nome/variabile:

(define (third lst) (lst 2)) -> (lambda (lst) (lst 2))
; in addition, the symbol "third" received a value
; the same of lambda list

(fn (lst) (lst 2)) -> (lambda (lst) (lst 2))
; only lambda list as a result
; no additional effect

Oltre alla funzione di "fn", c'è un "fn-macro" progettato per creare macro anonime.

Abbiamo già visto una tecnica simile al capitolo "(Perché? (Tutte (queste parentesi)))", ma negli esempi non veniva utilizzata la funzione "fn", ma direttamente la lista lambda, protetta dal simbolo apostrofo:

(fn (lst) (lst 2)) -> (lambda (lst) (lst 2))
'(lambda (lst) (lst 2)) -> (lambda (lst) (lst 2))

Di conseguenza, queste espressioni sono equivalenti. L'unica differenza è la brevità.

CONVERTIRE LISTE.
-----------------

Nell'esempio con il "ecase" macro, che abbiamo già incontrato la funzione "lista", che permette di creare liste di singoli elementi:

(setq a 25)
(list 1 2 3 a) -> (1 2 3 25)

Abbiamo visto anche la funzione di "append", che unisce le liste:

(append '(1 2 3)' (4 5 6)) -> (1 2 3 4 5 6)

E l'esempio con il "my-append" - la funzione "cons", che aggiunge un elemento in cima alla lista:

(cons 1 '(2 3 4)) -> (1 2 3 4)
(cons '(1 2)' (3 4)) -> ((1 2) 3 4)

In un LISP tradizionale, dove le liste sono rappresentate come una testa e una coda, "cons" svolge un ruolo molto più significativo combinando questi due componenti. In newLISP, le liste sono costruiti su una base "lineare".

Di maggiore interesse sono funzioni progettate per convertire una lista in un’altra. La più semplice e più attesa è la funzione "filter", che filtra la lista, lasciando in essa solo i valori​ ​che soddisfano la condizione data:

; (filter test_function list)

(filter (fn (x) (not (empty? x))) '("abc" "" "def" "jhi" ""))
  -> ("abc" "def" "jhi")

"empty?" - Una funzione che restituisce "true" se argomento non è una stringa vuota o una lista non vuota. "filter" restituisce una lista in cui rimangono solo gli elementi per cui la funzione di test restituirà true.
La funzione inversa è "clean":

(clean empty? '("abc" "" "def" "jhi" "")) -> ("abc" "def" "jhi")

Un’altra semplice, ma utile funzione, "join", combina una lista di stringhe in una singola stringa.

(join '("abc" "" "def" "jhi") ":") -> "abc :: def: jhi"
(join '("abc" 123 "def" "jhi") ":") -> Error! - 123 is not a string
(join (map string '("abc" 123 "def" "jhi")) ":") -> "abc: 123: def: jhi"

Il primo parametro "join" è un elenco di stringhe, il secondo (opzionale) è un delimitatore di stringa. La funzione utilizzata converte qualsiasi tipo di dati in una rappresentazione di testo.

E, naturalmente, "la più meravigliosa" è la funzione "mappa" discussa nel capitolo precedente. Inoltre, essa può gestire più liste.

(map (fn (x y) (+ x y)) '(1 2 3 4)' (5 6 7 8)) -> (6 8 10 12)

E, data la ben nota funzione "+", è possibile scriverla in modo ancora più semplice:

(map + '(1 2 3 4)' (5 6 7 8)) -> (6 8 10 12)

Ora sapete abbastanza per tornare alla macro "ecase" e vedere come funziona.

METODI DI PROGRAMMAZIONE.
-------------------------

Se siete armati con competenze di programmazione procedurale, e si tenta di scrivere in LISP (e, in particolare, in newLISP), allora si avrà successo molto presto. Tuttavia, è improbabile che il risultato finale sia superiore agli analoghi in linguaggi ordinari. LISP è un linguaggio funzionale, in cui troviamo le sue leggi di efficienza e i propri metodi di programmazione confortevole.

Caratteristiche di autocontenimento.
------------------------------------

La accademicamente corretta programmazione funzionale "pura" richiede che le funzioni utilizzate non abbiano "effetti collaterali (side effect)". Cioè, la funzione può elaborare solo i dati che riceve come parametri e l'unico risultato del suo funzionamento deve essere il valore restituito. La funzione non deve utilizzare o modificare le variabili "globali".

Nonostante il fatto che, nella pratica reale, un tale stile non è sempre possibile ed efficace, cercare di avvicinarsi ad essa permette di scrivere il programma in modo più trasparente e rendere gli errori logici più visibili.

Registrazione funzionale.
-------------------------

Ridurre l'uso di effetti collaterali consente, a sua volta, di aumentare le capacità di registrazione funzionale - quello che normalmente è scritto sotto forma di diverse espressioni in un linguaggio procedurale spesso può essere messo in una sola espressione in LISP. Inoltre, la struttura annidata dell'espressione LISP rivela le connessioni logiche dei suoi componenti. L’aspetto di una notazione funzionale è più simile a un linguaggio naturale, mentre una notazione procedurale non è altro che un elenco di azioni sequenziali (come l’assembler).

Sviluppo dal basso verso l'alto (bottom-up).
--------------------------------------------

Naturalmente, non si deve aspettare "trasparenza" da un'espressione funzionale di due pagine. Tutti sanno che il codice che è troppo grande può essere diviso in funzioni. L'approccio usuale per linguaggi procedurali ​​è quello di definire un compito, isolare i sottocompiti, e dividerli fino a quando diventa possibile scrivere funzioni separate per la loro soluzione. Se alla fine dello sviluppo le funzioni risultano ancora grandi e complesse, si capisce che era necessario risolvere il problema in modo leggermente diverso ... Questo metodo è chiamato sviluppo top-down.
In LISP, grazie alle sue proprietà di meta-linguaggio, tutto è fatto al contrario. Per risolvere il problema, l'argomento da risolvere viene indagato e, in base alle capacità di LISP, viene creato un nuovo linguaggio. Quindi, la soluzione del problema viene scritta in questo linguaggio. Se "improvvisamente" si scopre che il piano originale ha subito cambiamenti significativi, questo non è un problema - in un linguaggio ad-hoc non è difficile scrivere qualcosa di nuovo. Questo metodo viene chiamato sviluppo bottom-up.

Un conseguenza particolarmente piacevole dello sviluppo bottom-up è la capacità di usare il linguaggio più appropriato a ciascun livello di risoluzione del problema, che, ancora una volta, può essere facilmente tradotto nella logica del linguaggio naturale.

Auto documentante.
------------------

A tutto quanto sopra, occorre aggiungere due osservazioni: - non lesinare sui nomi "auto-documentanti" delle funzioni e delle variabili. I nomi "t", "tmp", "ex", ecc sono buoni in sezioni locali di codice. Tuttavia, per i nomi a livello globale, qualcosa come "exit-state" è molto meglio (e non dire che tu digiti lentamente!). A volte per designare un'azione da svolgere solo una volta è meglio scrivere una funzione separata.

Non privatevi della possibilità di scrivere in questo modo:

(do-select ((CustomerName CustomerEmail)
            : from Customers
            : where (> CustomerAge 100))
  (send-email CustomerEmail
              : subject "Congratulations!"
              : body (format nil
                            "Dear ~ A, you won a prize! Call ~ A."
                            CustomerName company-phone)))

I commenti sono superflui, non è vero?

Questo esempio è scritto in sintassi Common Lisp. Preso da un forum su http://linux.org.ru.

Elaborazione liste.
-------------------

E, infine, occorre ricordare che LISP è progettato per elaborare liste. Maggiori sono le opportunità di applicare le liste nel problema, maggiori sono le possibilità che l'elaborazione dei dati sia più facile (for free).

FORMATTAZIONE DEL CODICE.
-------------------------

Ci sono opinioni diverse su come formattare meglio il codice LISP e newLISP. Un metodo abbastanza comodo e "canonico" è descritto qui:

Indentazione.
-------------

Il rientro standard per l’annidamento delle espressioni è impostato su due spazi.

Il rientro per liste di dati annidate è uno spazio (dal momento che le parentesi di apertura sulla linea precedente possono seguire una dopo l'altra).

Se una funzione ha molti argomenti e il primo si trova sulla stessa riga del nome della funzione, il resto degli argomenti sono convenientemente scritti sotto il primo "in una colonna" (come nell'esempio precedente).

Per funzioni speciali, come "let" o "se", in cui il primo parametro ha un significato speciale, il primo parametro di solito inizia sulla stessa riga del nome della funzione, e il resto su altre linee con una indentazione standard di due spazi:

(if (= ab)
  (println "equality")
  (println "inequality"))

Chiusura parentesi.
-------------------

Le parentesi di chiusura di solito non compaiono su righe separate, come avviene nel linguaggio "C" e simili. Questo è inutile per mettere in evidenza la struttura del programma, dal momento che l’indentazione (i rientri) porta già tutte le informazioni necessarie.

Per controllare l'equilibrio (bilanciamento) delle parentesi, è meglio utilizzare un editor di testo che offre la possibilità di visualizzare automaticamente le coppie di parentesi - tutti i moderni editor per "programmatori" sono in  grado di farlo.

In assenza di un editor "corretto", è conveniente per chiudere le parentesi "alla cieca" - usare gli occhi per contare il rientro del codice dal più interno al livello che deve essere completato, per ogni volta che premete ciecamente la parentesi di chiusura sulla tastiera.

SCRIPTING PRATICO.
------------------

Il compito più comune di scripting è, naturalmente, elaborare file di testo. Il leader assoluto in termini di convenienza qui è AWK - non esiste un linguaggio che potrebbe essere scritto in modo più conciso. Purtroppo, questo è un linguaggio piuttosto debole, che perde rapidamente terreno quando c'è la necessità di elaborare dati complessi. In questa area, Perl ha tradizionalmente dominato.

Per gli stessi compiti, newLISP è una buona scelta. Questo linguaggio supporta anche le espressioni regolari Perl-compatibili (PCRE) e permette l'analisi (parsing) di documenti di testo. La peculiarità dell'uso di newLISP è il suo orientamento per l’elaborazione di liste (mentre lo stile Perl tende all’elaborazione del flusso – stream processing). Ciò significa che quando usiamo newLISP, di solito è più vantaggioso non processare il testo linea per linea, ma di leggere tutto il file, dividerlo in una lista che contiene le sue parti (linee, parole, righe) e quindi elaborarle utilizzando tutta la potenza del LISP.

Ad esempio, si consideri un compito semplice: Supponiamo che il file "report.txt" contenga un rapporto nella forma seguente:

+ ---------------------------- +
 | Sample Text Report |
+ ---------------------------- +
 |uid | balance | volume |
+ ---------------------------- +
 |user1 | 100,000 | 1000 |
 |user2 | 200,000 | 1234 |
 ...

e si desidera conoscere l'importo per totale della colonna balance:

(apply +
  (map (fn (x) (int (x 3) 10))
       (filter (fn (x) (and (> (length x) 3) (regex "^ [0-9] + $" (x 3))))
               (map (fn (x) (parse x "* \\ | *" 0))
                    (parse (read-file "report.txt") "\ n")))))

Nuove funzionalità:

"Read-file" - legge in un file come una unica stringa.

"parse" - divide la linea in una lista di linee in base ai delimitatori specificati. Quando si specificano le opzioni aggiuntive, è possibile utilizzare le espressioni regolari (PCRE).

"\n" è il carattere di fine linea.

"regex" - Ricerca per una corrispondenza della espressione regolare.... Se non la trova, restituisce nil

"int" - converte una stringa in un intero con la base specificata dal secondo parametro.

Per capire come funziona, scriviamo la stessa cosa, ma più accuratamente:

(define (split-report-line str)
  (map (fn (x) (parse x "* \\ | *" 0))
       str))

(define (line-has-data? lst)
  (and (> (length lst) 3) (regex "^ [0-9] + $" (lst 3))))

(apply +
  (map (fn (x) (int (x 3) 10))
       (filter line-has-data?
               (map split-report-line
                    (parse (read-file "report.txt") "\ n")))))

Ora il codice principale praticamente non ha bisogno di commenti. In breve:
1) il file di report viene letto (nella sua interezza),
suddiviso in una lista di righe,
2) le linee sono divise in elementi,
3) le linee contenenti dati per l'analisi vengono filtrate,
4) il quarto elemento viene preso da ogni riga (indice -3) e convertito in un numero,
5) la lista risultante viene sommmata.

Due funzioni ausiliarie sono evidenti: la prima separa la stringa con una espressione regolare (e rimuove tutti gli spazi aggiuntivi in ​​uno), la seconda cerca nella lista divisa in stringhe il valore numerico nel quarto elemento (quello che interessa a noi).

Forse in Perl è possibile scrivere un programma più compatto. Tuttavia, non bisogna dimenticare che il risultato principale di questo script è quello di ottenere una lista di tutti gli elementi del report che possono poi essere raggruppati, filtrati, correlati e manipolati con tutta la ricchezza delle funzioni per l’elaborazione delle liste.

-------------------
Qui mi permetto di interrompere il racconto, visto che è stato scritto abbastanza, e si può cedere al desiderio di vedere cosa si può fare con questo linguaggio ...
-------------------

IN CONCLUSIONE, QUALCHE PAROLA SULLE CARATTERISTICHE DEL LINGUAGGIO newLISP.
----------------------------------------------------------------------------

newLISP è stato creato ed è attivamente sviluppato grazie agli sforzi di Lutz Mueller. Si tratta di un interprete scritto in puro C, utilizzando solo la libreria standard libc. Questa implementazione ha reso newLISP un linguaggio multipiattaforma che funziona allo stesso modo in molti sistemi Unix, tutte le versioni di M$ di Windows, e sotto MacOS X.
Nonostante le sue dimensioni in miniatura - un file binario di circa 300k, newLISP ha molte caratteristiche, tra cui:

• TCP/IP, uso di network deamon e supporto HTTP
• Spawn dei processi, semafori, segnali, timer
• Utilizzo di funzioni da librerie dinamiche (.so, .dll, etc.)
• PCRE espressioni regolari
• parser XML
• Interfaccia per TCL/Tk (distribuzione di Windows include Tk Graphics Library)
• sistema di unificazione che permette di implementare la logica in stile Prolog
• classificatori bayesiani (utilizzando librerie aggiuntive dal kit di distribuzione)
• Supporto Unicode
• Molte funzioni matematiche

newLISP è pubblicato con licenza GNU GPL con sorgenti e binari disponibili presso http://newlisp.org. Sullo stesso sito avrete accesso a una eccellente documentazione (in inglese), link utili, suggerimenti e un forum accogliente (in inglese).
Tra la documentazione, vale la pena evidenziare i documenti "ufficiali" estremamente utili:
"newLISP Manual and Reference" - un riferimento alla lingua e alla
"Code Patterns in newLISP" - una descrizione delle tecniche di programmazione per tutte le principali aree di applicazione del linguaggio.

Il sito dell'autore di questo articolo si trova a http://en.feautec.pp.ru. Si possono trovare diverse librerie utili e un repository non ufficiale Debian.


RINGRAZIAMENTI
--------------

Ai visitatori di linux.org.ru alcuni dei loro commenti sono stati molto interessanti.

Alex dal forum di newLISP per i commenti sullo stile.


LICENZA
-------

This text may be freely distributed in whole or in part on electronic networks, provided that information about the author and the original site is stored - http://en.feautec.pp.ru.

Any modification of the text is allowed under the following conditions:
- reflection of the fact of modification in the line with the version number at the beginning of the document,
- notification of the author by e-mail specified in the Copyright document,
- unconditional consent to include any fragments of the changes in the original version of the document (with reflection authorship in the Acknowledgments section).

Any reproduction of this document in the form of hard copies (on paper or electronic media), with the exception of newLISP distributions and distributions of free operating systems, is allowed only with the written consent of the author.

(C) 2006, Dmitry Chernyak losthost@narod.ru.


============================================================================
Notepad++ bundle
============================================================================

How to use notepad++ with newLISP.

Download: https://github.com/cameyo42/notepadpp-newLISP

Add newLISP syntax highlighting
-------------------------------
Copy all the text of the file: newLISP-udl.xml
and paste it inside the section:<NotepadPlus> ... </NotepadPlus>
of the file: userDefineLang.xml (located at: c:\Users\<username>\AppData\Roaming\Notepad++\)

Example
<NotepadPlus>
    <UserLang name="newLISP" ext="lsp" udlVersion="2.1">
    ...
    </UserLang>
</NotepadPlus>

The newLISP keywords are from primes.h (newLISP source).
The actual highlight colors are for "obsidiane" theme of notepad++.
You can change (easily) the colors as you like.

Open newLISP help from notepad++
--------------------------------

Add the line:

<Command name="newLISP Help" Ctrl="yes" Alt="yes" Shift="no" Key="112">chrome file:///C:/Program%20Files%20(x86)/newLISP/newLISP_manual.html#$(CURRENT_WORD)</Command>

inside the section: <UserDefinedCommands> ... </UserDefinedCommands>
of the file: shortcut.xml (located at: c:\Users\<username>\AppData\Roaming\Notepad++\)

Example:
<UserDefinedCommands>
    <Command name="newLISP Help" Ctrl="yes" Alt="yes" Shift="no" Key="112">chrome file:///C:/Program%20Files%20(x86)/newLISP/newLISP_manual.html#$(CURRENT_WORD)</Command>

</UserDefinedCommands>

Note: change the path to point to your newLISP help file

Now you can select a word and press Ctrl+Alt+F1 to open newLISP help file.

The shortcut is Ctrl + Alt + F1, but you can change it.

Execute newLISP code from notepad++
-----------------------------------

Download and install autohotkey (http://www.autohotkey.com).

Run the script "npp-newLISP.ahk" (double click it).

Run notepad++

Press Win+F12 to start newLISP REPL (la cartella di default di newLISP è quella dove si trova  lo script "npp-newLISP.ahk")

Now, from notepad++, you can:

1) Execute the expression of current line pressing: Left-Shift + Enter

2) Execute a selected block of expression pressing: Right-Shift + Enter

After the execution of the expressions, notepad++ is the active application.

3) Shortcut (Ctrl + F8) to evaluate expression inside notepad ++ (get the result in notepad++ console)

4) Shortcut (Ctrl + Alt + =) to insert:
[cmd]

[/cmd]

Note:
When selecting a block of expression be sure to begin and end the selection
with a blank line (or use [cmd] [/cmd]).

Note:
The script npp-newLISP.ahk exchange the brackets () and [] in the keyboard.
You can edit the file to disable this (you must comment two lines).
The script also enable other shortcuts... see the source.


============================================================================
Visual Studio Code e newLISP
============================================================================

You can use VSCode with newLISP.

Add these lines to the file "keybindings.json":

1. Shift+Enter to run selected text or current line

{ "key": "shift+enter",
  "command": "workbench.action.terminal.runSelectedText, "when": "editorTextFocus"}

2. switch editor <--> terminal

{ "key": "ctrl+`", "command": "workbench.action.focusActiveEditorGroup", "when": "terminalFocus" },
{ "key": "ctrl+`", "command": "workbench.action.terminal.focus", "when": "!terminalFocus" },

Now, open Terminal and run newlisp.exe (type newlisp.exe)

Now type (+ 1 2 3) and press Shift+Enter:
;-> 6

(define (sum a b) (add a b))
;-> (lambda (a b) (add a b))

(sum 2 3)
;-> 5

To move the Terminal window to the right, right click on Terminal menu bar and select "Move Panel to Right".

You can use the autohotkey script "vscode.ahk":

Ctrl-Alt-q insert:
;->

Ctrl-Alt-w insert:
[cmd]

[/cmd]


============================================================================
Debugger
============================================================================

Il debugger in newLISP è molto spartano, ma è comunque un aiuto indispensabile nello sviluppo dei programmi.

La funzione principale è "trace".
Per fa partire o terminare  il debugger, usare il paraemtro true o nil:

Per iniziare la sessione di debugging: (trace true)

Per terminare la sessione di debugging: (trace nil)

Per verificare lo stato del debugger (nessun argomento):
(trace) ; Senza argomento, ritorna true se la sessione è attiva.
;-> true

Il comando trace-highlight permette di controllare alcune modalità di visualizzazione dell'espressione che è attualmente in fase di valutazione. Se utilizziamo un terminale che supporta i codici ANSI possiamo modificare anche il colore e altri parametri (grassetto, sottolineato, ecc.)
Questo rende l'espressione da valutare di colore rosso:

(trace-highlight "\027[0;31m" "\027[0;0m") ;red text color

Questo usa il colore verde: 

(trace-highlight "\027[0;32m" "\027[0;0m") 

Questo rende l'espressione di colore negativo:

(trace-highlight "\027[0;7m" "\027[0;0m")  ;negative

Nota: \027 = ESC

Nota: per attivare i codici ANSI in windows 10 occorre creare nella chiave di registro [HKEY_CURRENT_USER\Console] la variabile "VirtualTerminalLevel" di tipo DWORD e porre il suo valore a 1 (uno).
Dal prompt della console (cmd.exe):
reg add HKCU\Console /v VirtualTerminalLevel /t REG_DWORD /d 1
Per disattivare i codici ANSI impostare il valore della variabile "VirtualTerminalLevel" a 0 (zero).

Se il terminale non supporta i codici ANSI, allora potete modificare solo il prompt con dei caratteri:

(trace-highlight ">>>" "<<<")

Potete inserire questo comando nel file init.lsp che viene eseguito quando eseguiamo newLISP.

Per fare un esempio definiamo una funzione ricorsiva che calcola la potenza di un numero x^n:

(define (expn x n)
  (if (= n 0) 1 (mul x (expn x (- n 1))))
)

(expn 3 3)
;-> 27

Per fare il debug di una funzione attiviamo la funzione "trace":

(trace true)

(trace (expn 2 3))

(define (expn x n)
  #(if (= n 0) 1 (mul x (expn x (- n 1))))#
)

[-> 2 ] s|tep n|ext c|ont q|uit >

Vediamo come interpretare l'output:

L'espressione attualmente tracciata (cioè quella in attesa di valutazione) e' quella compresa tra i caratteri "#" e "#":

 #(if (= n 0) 1 (mul x (expn x (- n 1))))#

[-> 2]: indica la direzione (avanti o indietro) e il numero della chiamata

s|tep: valuta ogni subespressione dell'espressione e si ferma

n|ext: valuta tutta l'espressione e si ferma

c|ont: valuta tutte le espressioni della funzione fino al termine

q|uit: esce dal comando "trace"

Nota: Durante il tracciamento, l'espressione tracciata cambia a seconda delle scelte dell'utente.

Per disabilitare la funzione "trace" occorre chiamarla con un valore nil:

(trace nil)

La funzione "debug" è una semplificazione dell'uso di "trace". Passiamo la funzione da tracciare a "debug" che si occupa di attivare e terminare la sessione di debug:

(debug (expn 2 3))

-----

(define (expn x n)
  #(if (= n 0)
   1
   (mul x (expn x (- n 1))))#)


[-> 3 ] s|tep n|ext c|ont q|uit >

Vediamo una sessione completa di debug con delle funzioni annidate. Definiamo le funzioni "pari" e "dispari" (in stile LISP):

(define (pari n)
  (if (= n 0) true (dispari (- n 1)))
)

(define (dispari n)
  (if (= n 0) nil (pari (- n 1)))
)

(pari 8)
;-> true

(dispari 11)
;-> true

(pari 11)
;-> nil

(dispari 8)
;-> nil

Per fare il debug (tracciamento) della funzione pari dobbiamo attivare la funzione "trace" e poi chiamare la funzione da tracciare (oppure (debug (pari 3))):

(trace true)
;-> true

(pari 3)

-----

(define (pari n)
  #(if (= n 0)
   true
   (dispari (- n 1)))#)

[-> 2 ] s|tep n|ext c|ont q|uit >

s

(define (pari n)
  (if #(= n 0)#
   true
   (dispari (- n 1))))

[-> 3 ] s|tep n|ext c|ont q|uit >

s

(define (pari n)
  (if #(= n 0)#
   true
   (dispari (- n 1))))

RESULT: nil ; risultato dell'espressione: (= n 0)

[<- 3 ] s|tep n|ext c|ont q|uit >

s

(define (pari n)
  (if (= n 0)
   true
   #(dispari (- n 1))#))

[-> 3 ] s|tep n|ext c|ont q|uit >

n

(define (pari n)
  (if (= n 0)
   true
   #(dispari (- n 1))#))

RESULT: nil ; risultato dell'espressione: (dispari (- n 1))

[<- 3 ] s|tep n|ext c|ont q|uit >

s

(define (pari n)
  #(if (= n 0)
   true
   (dispari (- n 1)))#)

RESULT: nil

[<- 2 ] s|tep n|ext c|ont q|uit >

c

;-> nil

Questo è il risultato finale della funzione (il numero 3 non è pari) e la sessione di debug è terminata.

Durante il debug possiamo usare la REPL per verificare il valore delle variabili, scrivere funzioni o altro codice necessario (si consiglia di non ridefinire la funzione attualmente in fase di debug).

Vediamo un altro esempio:

(define (conta n)
  (dotimes (i n)
    (setq somma (+ somma i))
    (println n))
)

(debug (conta 5))

-----

(define (conta n)
  #(dotimes (i n)
   (setq somma (+ somma i))
   (println n))#)

[-> 3 ] s|tep n|ext c|ont q|uit >

s ; valuta (dotimes (i n) --> dotimes (0 5)) e avanza alla prossima subespressione

(define (conta n)
  (dotimes (i n)
   #(setq somma (+ somma i))#
   (println n)))

[-> 4 ] s|tep n|ext c|ont q|uit >

s; valuta (somma) e avanza alla prossima subespressione

(define (conta n)
  (dotimes (i n)
   (setq somma #(+ somma i)#)
   (println n)))

[-> 5 ] s|tep n|ext c|ont q|uit >

s ; valuta il risultato della subespressione

(define (conta n)
  (dotimes (i n)
   (setq somma #(+ somma i)#)
   (println n)))

RESULT: 0 ; risultato di (+ somma i)

[<- 5 ] s|tep n|ext c|ont q|uit >

i ; vediamo il valore di i
;-> 0

[<- 5 ] s|tep n|ext c|ont q|uit >

s ; la subespressione è stata valutata quindi valuta l'intera espressione

(define (conta n)
  (dotimes (i n)
   #(setq somma (+ somma i))#
   (println n)))

RESULT: 0 ; risultato di (setq somma (+ somma i))

[<- 4 ] s|tep n|ext c|ont q|uit >

s ;

(define (conta n)
  (dotimes (i n)
   (setq somma (+ somma i))
   #(println n)#))

RESULT: 0

[<- 4 ] s|tep n|ext c|ont q|uit >

s ; avanza alla prossima espressione da tracciare

(define (conta n)
  (dotimes (i n)
   #(setq somma (+ somma i))#
   (println n)))

[-> 4 ] s|tep n|ext c|ont q|uit >

n ; valuta tutta l'espressione attiva (valutando tutte le subespressioni)

(define (conta n)
  (dotimes (i n)
   #(setq somma (+ somma i))#
   (println n)))

RESULT: 1 ; risultato di (setq somma (+ somma i))

[<- 4 ] s|tep n|ext c|ont q|uit >

i ; vediamo il valore di i
;-> 1

[<- 4 ] s|tep n|ext c|ont q|uit >

n ; valuta tutta l'espressione che segue
;-> 5

(define (conta n)
  (dotimes (i n)
   (setq somma (+ somma i))
   #(println n)#))

RESULT: 5 ; risultato di (println n)

[<- 4 ] s|tep n|ext c|ont q|uit >

c ; valuta tutta la funzione fino al termine
;-> 5
;-> 5
;-> 5
;-> 5
;-> 5

Occorre fare molta pratica per utilizzare proficuamente il debugger.

Nota: Poichè il debugger usa i caratteri "s", "n", "c" e "q" come tasti scorciatoia per le azioni di "s|tep n|ext c|ont q|uit" è consigliabile non usare questi caratteri come nomi delle variabili nelle funzioni (altrimenti sulla REPL dovreste usare "print" per conoscere il loro valore).

Per fare il debug di un file (es. test.lsp) possiamo scrivere:

(debug (load "test.lsp"))

In questo caso il file deve terminare con delle espressioni che devono essere valutate immediatamente appena il file viene caricato. In altre parole, il file deve terminare con una chiamata di funzione.

Al fine di evitare la valutazione completa di una funzione, possiamo inserire il comando trace all'interno della funzione stessa. In questo modo il debug può essere attivato nel punto desiderato.
Vediamo un modo per far partire il debug a metà di un ciclo. Prima salvate le seguenti linee di codice in un file (es. test-debug.lsp)

(setq i 0)

(define (f1) (inc i))

(define (f2)
  (dotimes (x 100)
    (f1)
    (if (= i 50) (trace true))))

(f2)

Poi eseguite dalla console:

(load "test-debug.lsp")

-----

(define (f1)
  (inc i))

[-> 5 ] s|tep n|ext c|ont q|uit >

i
;-> 50

[-> 5 ] s|tep n|ext c|ont q|uit >

(setq i 60) ; possiamo anche modificare il valore di i
;-> 60

[-> 5 ] s|tep n|ext c|ont q|uit > n

(define (f1 ) (inc i))

RESULT: 61

[<- 5 ] s|tep n|ext c|ont q|uit >

Come potete notare il tracciamento appare quando i vale 50 (che abbiamo verificato visualizzando il valore di i).

Il debugger non visualizza i commenti che si trovano nelle funzioni. Per fare apparire un testo durante la sessione di debug possiamo utilizzare il marcatore [text] [/text]:

(define (f1)
  [text]Questo testo appare nel debugger.[/text]
  ; Questo testo no appare nel debugger.
  (inc i))

Nota: modificare la funzione di cui si sta effettuandoo il debug genera sempre un crash della REPL.

Per finire riportiamo la traduzione del manuale di riferimento delle funzioni "trace", "trace-highlight" e "debug".

Funzione DEBUG
--------------
sintassi: (debug func)

Chiama la funzione "trace" e inizia la valutazione della funzione definita dall'utente "func".
"debug" è una scorciatoia per eseguire (trace true) ed entrare nella funzione da tracciare ("func").

; Invece di digitare...
(trace true)
(my-func a b c)
(trace nil)

; Possiamo utilizzare "debug"...
(debug (my-func a b c))

Durante il tracciamento con "trace" o "debug" i messaggi di errore vengono stampati. La funzione che ha causato l'eccezione ritorna zero o nil e l'esecuzione continua. In questo modo le variabili e lo stato del programma può essere ispezionato durante il debugging.

Funzione TRACE
--------------
sintassi: (trace int-device)
sintassi: (trace true)
sintassi: (trace nil)
sintassi: (trace)

Nella prima sintassi il parametro è un intero associato ad un dispositivo (es. un file aperto). L'output viene scritto continuamente su quel dispositivo. Se "int-device" vale 1, allora l'output è scritto su stdout.

; write all entries and exits from expressions to trace.txt
(trace (open "trace.txt"))

; write all entries and exits from expressions to trace.txt
(foo x y)
(bar x)

; close the trace.txt file
(trace nil)

Nella seconda sintassi il debugger diviene attivo quando il parametro vale true.
In modalità di debug newLISP si arresta all'ingresso e all'uscita di ogni espressione e attende eventuali input dell'utente.
L'espressione attiva viene visualizzata tra due caratteri "#" (number sign). I caratteri possono essere modificati con la funzione "trace-highlight".
Ad ogni prompt del debugger:

[-> 2] s|tep n|ext c|ont q|uit >

possiamo inserire "s", "n", "c" o "q" per proseguire la valutazione in modi diversi (es. valutare ogni subespressione o valutare tutta l'espressione). Al prompt possiamo anche inserire una espressione qualsiasi da valutare. Ad esempio se inseriamo il nome di una variabile, allora verrà restituito il suo valore. In questo modo possiamo verificare il contenuto delle variabili e possiamo anche modificarlo.

; Imposta newLISP in modalità di debug
(trace true)
;-> true

; il debugger mostra ogni passo
(my-func a b c)

; Imposta newLISP in modalità normale (esce dalla modalità di debug)
(trace nil)
;-> nil

Per inserire dei break point dove newLISP dovrebbe interrompere l'esecuzione normale del programma ed entrare in modalità di debug, possiamo inserire l'espression (trace true) prima delle espressioni che devono essere tracciate.
To set break points where newLISP should interrupt normal execution and go into debugging mode, put
(trace true) statements into the newLISP code where execution should switch on the debugger.
Puoi usare la funzione "debug" come scorciatoia per l'esempio sopra:

(debug (my-func a b c))

La terza sintassi chiude la modalità di debug o il file usato per il tracciamento.

La quarta e ultima sintassi riporta il valore corrente della modalità di debug (true o nil).

Funzione TRACE-HIGHLIGHT
------------------------
sintassi: (trace-highlight str-pre str-post [str-header str-footer])

Imposta i caratteri o la stringa di caratteri che racchiude l'espressione attiva durante il tracciamento. Il valore di default che racchide l'espressione è "#" (number sign). Questo può essere cambiato con una stringa lunga fino a sette caratteri. Se il tterminale accetta caratteri di controllo (ANSI sequenze di Esc), possiamo utilizzarli per cambiare il colore dell'espressione, visualizzarla in grassetto o reverse, ecc.
Due ulteriori stringhe opzionali "str-header" e "str-footer" che controllano il separatore e il prompt del debugger. Un massimo di 15 caratteri è consentito per "str-header" e 31 caratteri per "str-footer".

;; l'espressione attiva è racchiusa con ">>" e "<<"
(trace-highlight ">>" "<<")

;; colore brillante ('bright') su terminali VT-100 o compatibili
(trace-highlight ">>\027[1m" "\027[0m")

Nota: looks like old "print" function never dies.


============================================================================
newLISPdoc - Il programma per la documentazione newLISP
============================================================================

I commenti nei file sorgenti di newLISP possono essere convertiti in documentazione HTML utilizzando solo pochi tag nei commenti. Il sistema newLISPdoc è progettato per utilizzare un minimo di tag e lasciare ancora leggibili i commenti con tag.

newLISPdoc genera anche una pagina indice per tutti i file sorgente newLISP generati.

Potete leggere il sorgente del file "newLISPdoc" nella cartella "util" dell'installazione di newLISP ((es. c:\newlisp\util). Il programma e questa documentazione fanno anche parte della distribuzione di newLISP dalla versione 9.0. Poiché l'evidenziazione della sintassi di newLISP versione 9.1 è integrata in newlispdoc, che è installato nella stessa cartella del programma eseguibile newLISP. Lo script syntax.cgi è ancora disponibile per le installazioni di siti Web, ma non è più necessario per newLISPdoc.

Utilizzo
Dall'interno della cartella in cui si trovano i tuoi moduli, eseguire "newlispdoc" dalla linea di comando passando tutti i nomi dei file dei moduli. Ad esempio, per elaborare i file mysql.lsp, odbc.lsp e sqlite3.lsp eseguire:

Linux, OSX:
newlispdoc mysql.lsp odbc.lsp sqlite.lsp

Windows:
newlisp newlispdoc mysql.lsp odbc.lsp sqlite.lsp

Questo genera i file index.html, mysql.lsp.html, odbc.lsp.html e sqlite.lsp.html tutti nella stessa cartella da dove è stato eseguito il comando. La pagina index.html contiene i collegamenti a tutte le altre pagine.

Se la cartella di lavoro contiene il file newlispdoc.css, l'output HTML verrà formattato di conseguenza. Per un esempio, consultare il file "util/newlispdoc.css" nella cartella di installazione.

Possiamo usare il flag -s della riga di comando per generare anche file HTML separati con evidenzazione dei sorgenti e inserire un collegamento alla versione evidenziata del file nella pagina della documentazione:

newlispdoc -s mysql.lsp odbc.lsp sqlite.lsp
newlispdoc -s *.lsp

Il flag -d fornisce un collegamento per il download dei sorgenti originali:

Linux, OSX:
newlispdoc -d *.lsp
newlispdoc -s -d *.lsp

È possibile fornire una o entrambe le opzioni.

Windows:
newlisp newlispdoc -s mysql.lsp odbc.lsp sqlite.lsp

Possiamo specificare anche la posizione del file sorgente con un indirizzo URL. Ciò consente l'indicizzazione e la documentazione di sorgenti newLISP distribuiti su diversi siti:

Linux, OSX:
newlispdoc -url file-with-urls.txt
newlispdoc -s -url file-with-urls.txt

Windows:
newlisp newlispdoc -url file-with-urls.txt
newlisp newlispdoc -s -url file-with-urls.txt

L'indirizzo URL può utilizzare http:// e file://
Come per i singoli file, l'opzione -s può essere specificata per generare anche file sorgente con sintassi evidenziata. Un file URL contiene un URL per riga. Non sono consentite altre informazioni nel file. Di seguito è riportato un file URL di esempio:

http://asite.com/code/afile.lsp
http://othersite.org/somefile.lsp
file:///usr/home/joe/program.lsp

L'ultima riga mostra un URL di file locale.

Tutti i file generati verranno scritti nella cartella corrente.

Lista "tag"
-----------

I tag hanno la seguente sintassi:

;; @<tag-name>

Con le seguenti funzionalità:

;; @module una parola per il nome del modulo
;; @index Titolo e URL per la pagina indice
;; @description una riga per la descrizione del modulo
;; @location la posizione dell'URL originale del file sorgente
;; @version una riga per le informazioni sulla versione
;; @author una riga per le informazioni sull'autore
;; @syntax una riga per il modello di sintassi (syntax pattern)
;; @param una riga per il nome e la descrizione del parametro
;; @return una riga per descrizione del risultato (output)
;; @example esempio di codice multilinea a partire dalla riga successiva

L'unico tag richiesto è il tag @module o in alternativa il tag @index. Se nessuno di questi tag è presente nel file, allora non verrà elaborato. Tutti gli altri tag sono opzionali. Solo le righe che iniziano con ";;" (2 punti e virgola) vengono elaborate. Il testo del commento del programma che non dovrebbe apparire nella documentazione dovrebbe iniziare con un solo punto e virgola.

La descrizione di una riga del tag @description verrà inserita sotto il nome del modulo nella pagina dell'indice e del documento del modulo.

Una funzione può avere più tag @syntax ciascuno su righe consecutive.

Quello che segue è l'unico tag, che può essere incorporato ovunque nel testo. Tra la specifica e la descrizione del collegamento tag c'è esattamente uno spazio:

@link link descrizione

Tag personalizzati possono essere creati semplicemente anteponendo il nome personalizzato con una @. Il testo dopo il tag personalizzato verrà tradotto come al solito, ad es. può contenere un tag @link. Come nella maggior parte degli altri tag, il testo da inserire è limitato alla stessa riga.

Tutte le parole tra <...> (parentesi angolari) sono visualizzate in corsivo. Internamente newLISPdoc utilizza i tag <em>, </em> per la formattazione. Dovrebbero essere utilizzati per le specifiche dei parametri dopo il tag @param e nel testo che si riferisce a tali parametri.

Tutte le parole tra virgolette singole '...' sono stampate in monospace. Internamente newLISPdoc utilizza i tag <tt>, </tt> per la formattazione.

Tutte le altre righe che iniziano con 2 punti e virgola contengono testo descrittivo. Una riga vuota con solo 2 punti e virgola all'inizio è un'interruzione tra paragrafi di testo.

Le righe che non iniziano con 2 punti e virgola vengono ignorate da newLISPdoc. Ciò consente di scrivere commenti sul codice con un solo punto e virgola.

Se è richiesta una formattazione maggiore di quella offerta da newLISPdoc, è possibile utilizzare anche i seguenti semplici tag HTML e i relativi moduli di chiusura: <h1>, <h2>, <h3>, <h4>, <i>, <em>, <b>, <tt>, <p>, <br>, <pre>, <center>, <blockquote> e <hr>.

Collegamento ad altre raccolte di moduli
----------------------------------------
newLISPdoc genera e indicizza la pagina per tutti i moduli documentati. È possibile utilizzare un tag speciale @index per mostrare un collegamento nella pagina dell'indice a un indice di altre raccolte di moduli. In questo modo è possibile creare indici multilivello dei moduli. Per visualizzare un collegamento a un'altra raccolta di moduli nella pagina dell'indice, creare un file contenente il tag @index e il tag @description nel modo seguente:

; - other-collection.txt -
;; @index OtherCollection http://example.com/modules
;; @description Modules from OtherCollection

Utilizzare uno o più di questi file nella riga di comando newLISPdoc come qualsiasi altro file di origine:

newlispdoc -s other-collection.txt *.lsp

Questo mostrerà la voce di indice per OtherCollection sull'indice del modulo prima di elencare tutti i moduli in *.lsp.

Esempi

Quella che segue è il sorgente commentato del programma newLISP di esempio:

;; @syntax (example:foo <num-repeat> <str-message>)
;; @param <num-repeat> The number of times to repeat.
;; @param <str-message> The message string to be printed.
;; @return Returns the message in <str-message>
;;
;; The function 'foo' repeatedly prints a string to
;; standard out terminated by a line feed.
;;
;; @example
;; (example:foo 5 "hello world")
;; =>
;; "hello world"
;; "hello world"
;; "hello world"
;; "hello world"
;; "hello world"

(context 'example)

(define (foo n msg)
	(dotimes (i n)
		(println msg))
)

;; See the @link http://example.com/example.lsp source .

Di seguito vengono riportate le pagine "example.lsp.html" e "index.html" generate:

"example.lsp.html"
-------------------------------------------------
Module index(link)

Module: example.lsp
Author: John Doe, johndoe@example.com
Version: 1.0

This module is an example module for the newlispdoc program, which generates automatic newLISP module documentation.

                        - § -

Syntax: (example:foo num-repeat str-message)

parameter: num-repeat - The number of times to repeat.
parameter: str-message - The message string to be printed.

return: Returns the message in str-message

The function foo repeatedly prints a string to standard out terminated by a line feed.

example:
 (example:foo 5 "hello world")
 =>
 "hello world"
 "hello world"
 "hello world"
 "hello world"
 "hello world"

See the source(link).
-------------------------------------------------

"index.html"
-------------------------------------------------
        Index
Module: example.lsp(link)
foo(link)
-------------------------------------------------

Quando viene specificato più di un modulo sulla riga di comando, la pagina dell'indice mostrerà una riga di collegamento per ciascun modulo.


============================================================================
Compilare i sorgenti di newLISP
============================================================================

In questa appendice vediamo i passi necessari per compilare newLISP con windows 10 partendo dai sorgenti. In particolare compileremo la versione di newLISP a 64 bit con estensioni UTF8 e FFI.

Scaricare i sorgenti di newLISP (newLISP-10.7.5.tgz) da:

http://www.newLISP.org/downloads/development/inprogress/

Attualmente la versione è la 10.7.5

Scompattare il file nella cartella: c:\newLISP-10.7.5

Scaricare il compilatore gcc 5.1 "TDM64 Bundle" da: http://tdm-gcc.tdragon.net/

Installare il programma nella cartella: c:\TDM-GCC-64

Scaricare la libreria "libffi" versione 3.2.1 (precompilata per windows) da:

https://proj.goldencode.com/downloads/libffi/libffi_3.2.1_prebuilt_mingw_4.9.0_64bit.zip

Scompattare il file nella cartella: c:\newLISP-10.7.5\libffi-3.2.1-prebuilt_mingw490_64bit

Copiare i file "libffi.a" e "libffi.dll.a" nella cartella:

c:\TDM-GCC-64\lib\gcc\x86_64-w64-mingw32\5.1.0\

(c:\TDM-GCC-64\lib\gcc\x86_64-w64-mingw32\5.1.0\libffi.a)
(c:\TDM-GCC-64\lib\gcc\x86_64-w64-mingw32\5.1.0\libffi.dll.a)

Adesso dobbiamo modificare un makefile che si trova nella cartella dei sorgenti.

Spostarsi nella cartella c:\newLISP-10.7.5 e aprire il file "makefile_mingw64dll_utf8_ffi" con un editor di testo.

Sostituire la riga:   $(CC) -m64 -shared *.o -Wl,--kill-at -lffi -lws2_32 -o newLISP.dll
Con la riga:          $(CC) -m64 -shared $(OBJS) -Wl,--kill-at -lffi -lws2_32 -o newLISP.dll

Salvare e chiudere il makefile.

Aprire una finestra DOS (command prompt - cmd.exe) e dalla cartella dei sorgenti digitare:

make -f makefile_mingw64_utf8_ffi

Se tutto va bene, dopo alcuni secondi avrete il vostro file "newLISP.exe" insieme a diversi altri file che  hanno estensione ".o".

Prima di creare la dll di newLISP dobbiamo eliminare tutti i file ".o" che sono stati creati.

Una volta eliminati i file ".o" digitare:

make -f "makefile_mingw64dll_utf8_ffi"

Questa volta avrete il vostro file "newLISP.dll" insieme a diversi altri file che  hanno estensione ".o".

Cancellate i file ".o" e copiate "newLISP.exe" e "newLISP.dll" nella cartella che preferite (la cartella deve trovarsi nella variabile di ambiente PATH).

Complimenti, avete creato la vostra versione di newLISP !!!

Nota: nelle versioni ffi di newLISP occorre copiare la libreria "libffi-6.dll" nella cartella dove si trova newLISP.exe e newLISP.dll

Nota: l'installazione completa di newLISP comprende anche altri file. Comunque questi file devono semplicemente essere copiati dalla cartella dei sorgenti (moduli, manuali, util, ecc.).
Puoi vedere la cartella dove è installato newLISP per capire quali file sono necessari.

Nota: In questo modo abbiamo solamente installato la REPL di newLISP, tralasciando la versione GUI.


============================================================================
Ricorsione e ottimizzazione della chiamata di coda (Tail Call Optimization)
============================================================================

Questo è un concetto molto importante quando utilizziamo funzioni ricorsive.
Parliamo di "ottimizzazione della chiamata di coda" (TCO - Tail Call Optimization) quando è possibile evitare di allocare un nuovo stack frame per una funzione poichè la funzione chiamante restituirà semplicemente il valore che ottiene dalla funzione chiamata.
L'uso più comune è la "ricorsione in coda" (tail recursion), quando una funzione ricorsiva è in grado di utilizzare una dimensione costante dello stack.

Scheme (o Javascript ES6) è uno dei pochi linguaggi che garantisce nelle specifiche di essere in grado di effettuare questa ottimizzazione.
Vediamo due esempi in Scheme (con sintassi newLISP)

(define (fact x)
  (if (= x 0) 1
      (mul x (fact (- x 1)))))

(fact 10)
;-> 3628800

(fact 2500)
;-> ERR: call or result stack overflow

(define (fact x)
  (define (fact-tail x accum)
    (if (= x 0) accum
      (fact-tail (- x 1) (mul x accum))))
  (fact-tail x 1))

La prima funzione non ha la ricorsione di coda perchè quando viene effettuata la chiamata ricorsiva la funzione deve tenere traccia della moltiplicazione necessaria per ottenere il risultato dopo che è ritornata la chiamata.
Quindi lo stack è simile al seguente:

(fact 3)
(* 3 (fact 2))
(* 3 (* 2 (fact 1)))
(* 3 (* 2 (* 1 (fact 0))))
(* 3 (* 2 (* 1 1)))
(* 3 (* 2 1))
(* 3 2)
6

In contrasto lo stack per la seconda funzione si comporta nel modo seguente:

(fact 3)
(fact-tail 3 1)
(fact-tail 2 3)
(fact-tail 1 6)
(fact-tail 0 6)
6

Come puoi vedere, abbiamo soltanto bisogno di memorizzare la stessa quantità di dati per ogni chiamata perchè dobbiamo semplicemente restituire il valore che otteniamo dalla chiamata superiore. Questo significa che anche la chiamata (fact 1000000) ha bisogno della stessa quantità di spazio della chiamata (fact 3).
Questo non accade nelle funzioni senza ottimizzazione della chiamata di coda (non-tail recursive), infatti valori elevati dell'argomento possono causare l'errore di esaurimento dello stack (stack overflow).

A rigor di termini, l'ottimizzazione della chiamata di coda non sostituisce necessariamente lo stack frame del chiamante con i chimati, ma, piuttosto, garantisce che un numero illimitato di chiamate nella posizione di coda richieda solo una quantità limitata di spazio.

In altre parole la TCO (Tail Call Optimization) è il processo mediante il quale un compilatore intelligente può effettuare una chiamata a una funzione e non occupare ulteriore spazio di stack. L'unica situazione in cui ciò accade è se l'ultima istruzione eseguita in una funzione f è una chiamata a una funzione g (Nota: g può essere f). Il punto è che f non ha più bisogno di spazio nello stack - semplicemente chiama g e restituisce qualsiasi cosa restituisca g. In questo caso si può fare l'ottimizzazione: la funzione g viene eseguita e ritorna il suo valore a quello che ha chiamato f.

Questa ottimizzazione può far sì che le chiamate ricorsive occupino uno spazio di stack costante, anziché facciano esplodere lo stack.

Esempio: questa funzione fattoriale non è TCOttimizzabile:

def fact(n):
    if n == 0:
        return 1
    return n * fact(n-1)

Questa funzione fa anche altre cose oltre a chiamare un'altra funzione nella sua ultima istruzione (dichiarazione di ritorno).

Esempio: questa funzione fattoriale non è TCOttimizzabile:

def fact_h(n, acc):
    if n == 0:
        return acc
    return fact_h(n-1, acc*n)

def fact(n):
    return fact_h(n, 1)

Questo perché l'ultima istruzione in una di queste funzioni è la chiamata un'altra funzione.
Il TCO riguarda l'ottimizzazione dello spazio utilizzato nello stack di chiamate (da O(n) a costante).

Purtroppo newLISP non supporta Tail Call Optimization (TCO), ma è possibile superare il problema dell'esplosione dello stack delle funzioni ricorsive tramite la tecnica di "memoization".
Questa tecnica viene spiegata nell'articolo "Advanced Recursion in newLISP":
https://weblambdazero.blogspot.com/2010/07/advanced-recursion-in-newLISP.html di Krzysztof Kliś che trovate tradotto più avanti.


============================================================================
F-expression - FEXPR
============================================================================

Nei linguaggi di programmazione Lisp, una FEXPR è una funzione i cui operandi/parametri vengono passati ad essa senza essere valutati. Quando viene chiamato una FEXPR, viene valutato solo il corpo di FEXPR: non si effettuano altre valutazioni se non quando esplicitamente avviato/richiesto dalla FEXPR.

Al contrario, quando viene chiamata una normale funzione Lisp, gli operandi vengono valutati automaticamente e solo i risultati di queste valutazioni vengono passati alla funzione.

Quando viene chiamata una macro Lisp (tradizionale), gli operandi vengono passati in modo non valutato, ma qualunque sia il risultato ritornato dalla macro, questo viene valutato automaticamente.

Nel rigoroso utilizzo originale, una FEXPR è quindi una funzione definita dall'utente i cui operandi vengono passati senza essere valutati. Tuttavia, nell'uso successivo, il termine FEXPR descrive qualsiasi funzione di prima classe/ordine i cui operandi vengono passati non valutati, indipendentemente dal fatto che la funzione sia primitiva o definita dall'utente.

Il supporto delle Fexpr è continuato in Lisp 1.5, l'ultimo dialetto sostanzialmente standard di Lisp prima che si frammentasse in più linguaggi. Negli anni '70, i due linguaggi dominanti, MacLisp e Interlisp, supportarono entrambi le fexprs.

Alla conferenza del 1980 sul Lisp e la programmazione funzionale, Kent Pitman presentò un documento "Special Forms in Lisp" in cui discuteva dei vantaggi e degli svantaggi delle macro e delle fexprs e, infine, condannò le fexprs. La sua obiezione centrale era che, in un dialetto di Lisp che consente fexprs, l'analisi statica non può determinare in generale se un operatore rappresenti una funzione ordinaria o un fexpr - pertanto l'analisi statica non può determinare se gli operandi saranno valutati o meno. In particolare, il compilatore non può dire se una sottoespressione può essere ottimizzata in modo sicuro, poiché la sottoespressione potrebbe essere trattata come dati non valutati in fase di esecuzione.

"Le MACRO offrono un meccanismo adeguato per specificare definizioni di moduli speciali e ... le FEXPR no. ... Si suggerisce che, nella progettazione dei futuri dialetti del Lisp, si dovrebbe prendere in seria considerazione la proposizione che le FEXPR dovrebbero essere del tutto escluse dal linguaggio"
Kent M. Pitman, "Special Forms in Lisp", Proceedings of the 1980 ACM Conference on Lisp and Functional Programming, 1980, pag. 179–187.

Le macro di newLISP sono FEXPR. Perchè?

Il problema evidenziato da Pitman è valido solo per i linguaggi compilati, infatti nei linguaggi interpretati (come newLISP) le fexpr non hanno effetti indesiderati, anzi rendono la meta-programmazione più semplice ed elegante.

Con le fexpr viene aggiunta "generalità" al linguaggio, in quanto permette di trattare i più importanti elementi del Lisp come oggetti di prima classe durante il runtime.

Per un'analisi approfondita potete consultare l'articolo "On Pitman's 'Special Forms in Lisp'" di Kazimir Majorinc all'indirizzo:

http://kazimirmajorinc.com/Documents/On-Pitmans-Special-forms-in-Lisp/index.html

Riportiamo le conclusioni dell'articolo citato sopra:

"Sebbene l'articolo di Pitman contenga un numero di argomenti validi, inclusi alcuni a favore delle fexprs, tre argomenti importanti sembrano essere stati omessi:

1. Lisp con fexprs ha una semantica più semplice, più regolare ed espressiva di Lisp con funzioni, con o senza macro.

2. L'esistenza di fexprs espandibili simili a macro non è riconosciuta. Per ogni macro esiste un equivalente fexpr espandibile simile a una macro con le stesse proprietà desiderabili. In particolare, se viene applicata una semplice ottimizzazione di fexprs espandibili, per ogni programma che utilizza macro esiste un programma equivalente altrettanto veloce che utilizza fexprs.

3. In alcuni casi, i programmi che usano fexprs sono molto più veloci dei programmi che usano macro.

Queste affermazioni costituiscono un valido motivo per i fexprs, in particolare perché uno dei principali argomenti contro i fexprs era la loro influenza sulla velocità dei programmi."


============================================================================
newLISP - Lisp per tutti (Krzysztof Kliś)
============================================================================

Traduzione dell'articolo "newLISP - Lisp for the masses" di Krzysztof Kliś

https://weblambdazero.blogspot.com/2010/06/newLISP-lisp-for-masses.html

Esiste un detto popolare tra gli hacker Lisp: pianta un albero, scrivi un libro e crea un dialetto personale del Lisp. Sebbene non ci siano in giro molti Lisp popolari (persino il Common Lisp non è mai stato usato in maniera massiccia) sembra proprio che nel caso di varie distribuzioni Linux, spesso "di più" significa semplicemente "migliore". Un buon esempio di questa storia di successo è Clojure, e adesso arriva un altro candidato a prendere il comando.
newLISP è un dialetto moderno del Lisp, progettato da Lutz Mueller per essere (come dice lui stesso) "veloce da imparare e per finire il lavoro". Devo dire che questa frase non potrebbe essere più vera - risolvere il problema 10 di ProjectEuler (trovare la somma di tutti i numeri primi sotto 2 milioni) dopo soli due giorni di manipolazione con newLISP mi ci sono voluti meno di 3 minuti, tra cui progettazione, scrittura, test per eseguire il seguente codice:

(println (apply + (filter (fn (n) (= 1 (length (factor n)))) (sequence 2 2000000))))

Nonostante sia un linguaggio interpretato, i programmi creati con newLISP girano in modo incredibilmente veloce. Il codice sopra è una soluzione che utilizza la forza bruta, ma viene eseguito in meno di 10 secondi su Core 2 Duo a 1,66 GHz (2931 ms su Core i5 3.4 GHz).
Tuttavia, la semplicità ha un prezzo. Se cerchi di utilizzare un approccio più sofisticato, come il classico setaccio di Eratostene, potresti rimanere un pò sorpreso:

(define (sieve seq out)
  (let ((n (first seq)))
    (setf seq (filter (fn (x) (!= 0 (mod x n))) seq))
    (push n out)
    (if (not seq) out (sieve seq out))))

(print (apply + (sieve (sequence 2 2000000))))

Con questa funzione, sebbene sia correttamente ricorsiva in coda, newLISP consuma rapidamente tutto lo stack oppure, se si fornisce abbastanza spazio per lo stack, consuma tutta la memoria disponibile. Questo avviene perché newLISP non ottimizza la ricorsione in coda. Se per qualche motivo non puoi convivere con questa limitazione, puoi comunque utilizzare il Common Lisp per implementare tali ricorsioni:

(defun range (min max) (loop for i from min to max collect i))

(defun sieve (seq &optional out)
  (let ((n (car seq)))
    (setf seq (delete-if #'(lambda (x) (= 0 (mod x n))) seq))
    (push n out)
    (if (not seq) out (sieve seq out))))

(print (apply #'+ (sieve (range 2 2000000))))

Come puoi vedere, il codice delle due funzioni 'sieve' è molto simile, quindi è abbastanza facile passare a newLISP se conosci il Common Lisp. Le differenze con altri dialetti Lisp sono ben documentate, così come il linguaggio stesso. La documentazione è un altro punto di forza di newLISP: puoi imparare come risolvere diversi problemi reali usando i "code patterns" di newLISP oppure curiosare tra i molti frammenti di codice interessanti.
Quello che personalmente apprezzo di newLISP rispetto ad altri Lisp è il suo piccolo ingombro (davvero minuscolo). È possibile creare un eseguibile standalone contenente il motore newLISP (circa 300kB) e il vostro programma con un semplice comando dal terminale:

newLISP -x "mycode.lsp" "mycode.exe"

Nonostante sia così piccolo, il nuovo LISP offre una sorprendente quantità di funzionalità "out of the box": espressioni regolari, networking TCP/IP (inclusi i protocolli FTP e HTTP), accesso a database (tramite librerie esterne), OpenGL, XML e gestione XML-RPC, matrici, statistica (comprese formule bayesiane), supporto per Unicode e un insieme di moduli C/C++ che ne estendono ancora di più le capacità.
newLISP supporta anche l'elaborazione parallela tramite le API Cilk-like e l'elaborazione distribuita tramite la funzione integrata "net-eval".
newLISP non è sicuramente un Nuovo Common Lisp, e in alcuni punti (come ad esempio la ricorsione di coda) è ancora inferiore. Ma newLISP è un esempio perfetto che nel settore IT: a volte peggio è meglio  (sometimes worse is better).

Commento di Kazimir Majorinc:
newLISP insiste sull'idea di "codice = dati" di più della maggior parte dei dialetti Lisp non attivamente sperimentati e attivamente mantenuti.

(1) A causa di alcuni motivi, newLISP sfrutta molto di più la funzione "eval" della maggior parte degli altri dialetti Lisp. Una delle ragioni è che "eval" è veloce, solo Eligis OpenLisp e Picolisp hanno delle funzioni "eval" ancora più veloci.

(2) newLISP ha uno ambito (scope) dinamico e non lessicale. L'ambito dinamico funziona meglio con la funzione "eval".
Per esempio,

(let ((x 1)) (eval 'x))

è legale nell'ambito dinamico e restituisce l'errore "x not defined" in ambito lessicale. Emacs Lisp, Picolisp e newLISP supportano l'ambito dinamico, CL supporta entrambi, altri dialetti supportano solo l'ambito lessicale.

(3) Le macro in newLISP sono in realtà di FEXPR: vale a dire qualcosa come macro del primo ordine (first-class) definite a runtime (durante l'esecuzione). A differenza delle macro, è possibile assegnare FEXPR come valori, applicate, mappate e utilizzate come dati durante il runtime. Le FEXPRS esistevano nelle prime implementazioni del Lisp, ma sono state abbandonate perché si supponeva che renderessero impossibili alcune ottimizzazioni del compilatore. Questa affermazione è, a mio avviso, fuorviante, ma è irrilevante per i linguaggi interpretati. Attualmente nessun altro dialetto Lisp supporta le fexprs. (newLISP supporta anche reader-macro e alcune macro tradizionali - ma attraverso librerie.)

(4) A differenza delle macro, FEXPRS collabora bene con "eval", quindi se il programma combina (fexprs o macros) ed "eval", è probabile che sarà molto più veloce in newLISP rispetto ad altri dialoghi Lisp.

(5) Funzioni e macro (es. FEXPRS) in newLISP sono *espressioni*, non i risultati della valutazione delle espressioni. Quindi, queste possono essere (comprese quelle anonime) analizzate e modificate durante il runtime.


============================================================================
Ricorsione avanzata in newLISP (Krzysztof Kliś)
============================================================================

Traduzione dell'articolo "Advanced Recursion in newLISP" di Krzysztof Kliś

https://weblambdazero.blogspot.com/2010/07/advanced-recursion-in-newLISP.html

Nel precedente post su newLISP ho menzionato che non supporta l'ottimizzazione delle chiamate di coda. In realtà, molti Lisp non lo fanno. Come indicato da Bill Six, anche lo standard ANSI del Common Lisp non impone (a differenza dello Scheme) un'eliminazione delle chiamate di coda fornita dall'implementazione del linguaggio, anche se sembra che tutti i maggiori compilatori ANSI Common Lisp lo facciano comunque.

Mi chiedevo se esiste un modo per aggirare questo problema e la prima soluzione che ho trovato è stata l'utilizzo della macro "memoize" descritta nell'eccellente documentazione online di newLISP, "Code Pattern in newLISP":

(define-macro (memoize mem-func func)
  (set (sym mem-func mem-func)
    (letex (f func c mem-func)
      (lambda ()
        (or (context c (string (args)))
        (context c (string (args)) (apply f (args))))))))

È possibile applicare questa macro a qualsiasi funzione con qualsiasi numero di argomenti. Il trucco qui è che ogni volta che viene chiamata una funzione, il suo risultato viene scritto in memoria per un'altra chiamata. Questo può velocizzare enormemente la tua applicazione, e può essere osservato confrontando il tempo di esecuzione di queste funzioni di Fibonacci:

(define (fibo n)
  (if (< n 2) 1
    (+ (fibo (- n 1)) (fibo (- n 2)))))

(memoize fibo-m
  (lambda (n)
    (if (< n 2) 1
      (+ (fibo-m (- n 1)) (fibo-m (- n 2))))))

(time (fibo 35))
;-> 4479 msec
(time (fibo-m 35))
;-> 0.016

Sul mio portatile (fibo 35) impiega 12.98 secondi, mentre (fibo-m 35) viene eseguita in 0.016 millisecondi.

Sfortunatamente la macro memoize non può gestire la ricorsione reciproca. Un classico esempio di tale ricorsione appare come segue:

(define (f1 n)
  (println n)
    (if (= n 0)
      (println "Blastoff!")
      (f2 n)))

(define (f2 n)
  (f1 (- n 1)))

newLISP esaurisce rapidamente lo spazio dello stack se eseguiamo (f1 1000), per non parlare di numeri più grandi. Cosa succede se definiamo una versione "memoized" di f1 e f2 ? Vediamo:

(memoize f1
  (lambda (n)
    (println n)
    (if (= n 0)
      (println "Blastoff!")
      (f2 n))))

(memoize f2
  (lambda (n)
    (f1 (- n 1))))

Ancora una volta, l'esecuzione di (f1 1000) esaurisce immediatamente lo stack di newLISP.

Una soluzione a questo problema si ottiene utilizzando una tecnica chiamata "trampolining" (trampolino). Bill Clementson sul suo blog non solo ha spiegato in modo eccellente il concetto di usare i trampolini, ma ha anche fornito un'implementazione in Common Lisp, che è diventata la mia ispirazione per scrivere una versione in newLISP:

(define (trampoline fun arg)
  (catch
    (while true
      (let ((run (apply fun arg)))
        (setf fun (first run) arg (rest run)))) 'result)
  result)

Un trampolino esegue iterativamente i "thunk" [1] di codice restituiti da una funzione e in questo modo evita di far esplodere lo stack di applicazioni. Tuttavia, per utilizzare il trampolino, la funzione deve restituire la continuazione (un puntatore al passaggio successivo) anziché il valore. Di seguito è riportata una versione delle funzioni di cui sopra modificate per utilizzare il trampolino:

(define (f1 n)
  (println n)
  (if (= n 0)
    (throw "Blastoff!")
    (list f2 n)))

(define (f2 n)
  (list f1 (- n 1)))

Ora puoi testarlo con:

(trampoline f1 '(1000))
(trampoline f1 '(10000))
(trampoline f1 '(100000))
...

Buon divertimento!

[1]
Un "thunk" è una subroutine usata per iniettare un calcolo addizionale in un'altra subroutine. I thunk vengono principalmente utilizzati per ritardare un calcolo finché non è necessario il risultato o per inserire operazioni all'inizio o alla fine di un'altra subroutine. Può semplicemente essere pensato come una funzione che non accetta argomenti, in attesa di essere chiamata a fare il suo lavoro.


============================================================================
Differenze tra newLISP, Scheme e Common LISP (Lutz Mueller)
============================================================================

Cerchiamo di capire quali sono le differenze tra newLISP, Scheme e Common LISP.
Lo scopo di questo confronto non è quello di dimostrare che un linguaggio è migliore di un altro.
Diversi stili di programmazione si adattano a personalità diverse. Ogni approccio ha differenti punti di forza e di debolezza. L'idea che si possa progettare un unico linguaggio per tutti gli usi è una illusione. L'autore di newLISP utilizza 'C' e Java contemporaneamente a newLISP. Altri usano un diverso set di strumenti adatto al loro stile di programmazione e ai progetti che devono realizzare.
L'estetica di newLISP, che ha uno stile disinvolto e flessibile, ha attirato non solo il tradizionale programmatore, ma anche molte persone di altre professioni. Molti contributi alla progettazione di newLISP provengono da persone che non sono programmatori di professione. Per molti, newLISP non è solo un linguaggio di programmazione, ma anche uno strumento per modellare e organizzare il pensiero creativo.

Linguaggi di scripting contro linguaggi compilati
-------------------------------------------------
newLISP è un linguaggio di scripting progettato per non essere compilato ma per essere completamente dinamico e introspettivo. Molte delle differenze con altri LISP derivano da questa distinzione.
Entrambi gli approcci hanno il loro posto nell'informatica moderna. Per una discussione su questo argomento vedi:

"In Praise of Scripting: Real Programming Pragmatics" di Ronald P. Loui

http://web.cs.mun.ca/~harold/Courses/Old/CS2500.F09/Diary/04563874.pdf

Per ulteriori informazioni su storia, critica e altri aspetti del Lisp, consultare la pagina web:

http://www.newLISP.org/index.cgi?page=Links

Apertura e trasparenza
----------------------
newLISP è completamente aperto. Non ci sono stati nascosti. Tutti gli oggetti del linguaggio e i dati sono di primo ordine (classe). Sebbene newLISP inizialmente compili il sorgente del programma in un albero di s-espressioni, ogni oggetto può essere riportato in ogni momento in una forma comprensibile. Questo vale sia per gli spazi dei nomi (namespaces/context) sia per le espressioni lambda. Questa apertura facilita il funzionamento e il debug interattivo e facilita la comprensione del linguaggiolingua. I programmi newLISP sono completamente auto-riflessivi e possono essere ispezionati e modificati in ogni momento (anche a quando sono in esecuzione).
newLISP è in grado di gestire le risorse di rete per quanto riguarda i file in modo trasparente. Nella maggior parte dei casi dove vengono usati dei file, si possono usare anche gli indirizzi URL.
I file possono essere letti, scritti e aggiornati, i programmi possono essere caricati o salvato utilizzando lo stesso codice per sia per l'accesso locale che quello di rete. Questo facilita la scrittura di applicazioni distribuite.

Applicazione delle funzioni come in Scheme
------------------------------------------
A differenza di Common Lisp, newLISP e Scheme valutano prima l'operatore di un'espressione e poi lo applicano ai suoi argomenti.

Espressioni Lambda
------------------
In newLISP, le espressioni lambda sono costanti che valutano su se stesse. Sono un sottotipo del tipo di dati lista, quindi un oggetto dati di primo ordine che può essere manipolato come qualsiasi altra lista. In Common Lisp e Scheme, le espressioni lambda, una volta valutate, restituiscono come tipo di dati, una funzione speciale che formano un chiusura lessicale dopo aver vincolato (associato) le sue variabili libere all'ambiente corrente.
In newLISP, il binding delle variabili libere nelle espressioni lambda avviene durante l'applicazione dell'espressione lambda senza creare una chiusura.
Le espressioni Lambda in newLISP possono essere trattate come dati in ogni momento, anche dopo essere state associate ad una  definizione di funzione:

(define (foo x) (+ x x))
;-> (lambda (x) (+ x x))

(last foo)
;-> (+ x x)

Altri LISP usano le chiusure lambda per creare funzioni con stato (memoria). Mantenere lo stato è una condizione necessaria per un linguaggio di programmazione per permettere la programmazione orientata agli oggetti. In newLISP, i contesti (spazi dei nomi)chiusi lessicalmente possono essere usati per scrivere funzioni con stato. Come le espressioni lambda, i contesti in newLISP sono oggetti di primo ordine. I contesti possono essere creati e distrutti durante il runtime, passati come parametri, e referenziati con dei simboli.
Vedi l'appendice "Chiusure, contesti e funzioni con stato" per un confronto tra le chiusure di Scheme e i contesti di newLISP.
Vedi anche l'appendice "Creazione di funzioni con ambito lessicale in newLISP".

Un solo spazio dei simboli
--------------------------
In newLISP e Scheme, le variabili, le primitive e le funzioni definite dall'utente condividono lo stesso spazio dei simboli. In Common Lisp, i simboli di funzione e i simboli delle variabili utilizzano ciascuno uno spazio di nomi dedicato.
Questo è il motivo per cui a volte i simboli di funzione Common Lisp devono essere preceduti dal carattere #'.
I simboli in newLISP distinguono tra maiuscole e minuscole.

Ambito dinamico all'interno di spazi di nomi isolati
-----------------------------------------------------
newLISP a volte viene criticato per l'utilizzo di ambiti (scope) dinamici e di fexprs. Queste critiche ignorano che
i contesti (namespace) di newLISP proteggono i simboli delle funzioni dagli svantaggi tradizionali dell'ambito dinamico e delle fexprs.
In newLISP, tutte le variabili hanno un ambito dinamico come impostazione predefinita. Tuttavia, definendo una funzione nel proprio contesto, può essere utilizzato l'ambito statico/lessicale. I nomi dei parametri usati nelle fexprs sono inseriti con il loro valore su una pila all'entrata della funzione e vengono ripristinati al ritorno della funzione. In newLISP, diverse funzioni e dati possono condividere uno spazio dei nomi. Includendo le funzioni nel proprio spazio dei nomi, si ottiene un meccanismo di chiusura lessicale. Common Lisp e Scheme hanno un ambito lessicamente predefinito e utilizzano le espressioni lambda come meccanismo di chiusura. Common Lisp offre anche speciali variabili per l'ambito dinamico.
I problemi delle variabili libere in ambito dinamico possono essere evitati. Nei rari casi in cui devono essere utilizzate variabili libere, è possibile suddividere il codice in moduli di spazi di nomi per un controllo più semplice delle variabili libere. È quindi possibile sfruttare i vantaggi dell'ambito dinamico. Con un ambito dinamico all'interno di spazi di nomi chiusi lessicamente, newLISP combina il meglio di entrambi i mondi degli ambiti (scoping).
newLISP non ha problemi di funarg perché segue una semplice regola: le variabili mostrano sempre l'associazione (binding) del loro ambiente attuale. Quando vengono inserite espressioni con variabili locali, newLISP salva lo stato delle variabili in una pila e lo ripristina al termine dell'espressione. In newLISP sono espressioni locali, oltre ai parametri delle funzioni e alle variabili definite con let, anche le variabili di loop di tutti i cicli.

La cella LISP e cons
--------------------
In Common Lisp e Scheme, la parte cdr (rest) della cella Lisp può essere utilizzata per contenere un altro oggetto LISP, nel qual caso abbiamo una coppia puntata. In newLISP, non ci sono coppie puntate. Invece, ciascuna cella di newLISP contiene un oggetto e un puntatore ad un altro oggetto se la cella fa parte di una lista. Come risultato in newLISP la funzione "cons" si comporta diversamente dagli altri LISP.

Common Lisp e Scheme
(cons 'a' b) => (a . b)  ;una coppia puntata
[a | b]

newLISP
(cons 'a' b) => (a b)   ;una lista
[ ]
 \
 [a] -> [b]

La cella LISP in in newLISP
(+ 2 3 (* 4 3))
[ ]
 \
 [+] -> [2] -> [3] -> [ ]
                       \
                       [*] -> [4] -> [3]

Gli argomenti di una funzione sono opzionali
--------------------------------------------
In newLISP, tutti gli argomenti relativi a una funzione definita dall'utente sono facoltativi. Le variabili degli argomenti non assegnati assumeranno il valore nil all'interno della funzione.

Creazione di simboli impliciti
------------------------------
Logicamente, non ci sono simboli non associati o non esistenti in newLISP. Qualsiasi simbolo non associato o non esistente viene creato ed associato a nil nello spazio di nomi corrente quando viene visualizzato per la prima volta da newLISP.

nil e true sono costanti booleane
---------------------------------
nil e true sono costanti booleane in newLISP.
In Common Lisp, nil ha un ruolo aggiuntivo come terminatore di lista:

newLISP
(cons 'x nil) => (x nil)

Scheme
(cons 'x #f) => (x . #f)

Common Lisp
(cons 'x nil) => (x)

Scheme ha due costanti booleane #t e #f per vero e falso.
In newLISP la funzione first e in Scheme la funzione car generano un errore quando vengono usate su una lista vuota.
Il Common Lisp, la funzione car restituisce nil:

newLISP
(first '()) => error

Scheme
(car '()) => error

Common Lisp
(car '()) => nil

Gestione della memoria con un unico riferimento (ORO)
-----------------------------------------------------
In newLISP, ogni oggetto viene referenziato una sola volta (ORO), ad eccezione dei simboli e dei contesti. La regola ORO di newLISP consente la gestione automatica della memoria, basata su stack, senza i problemi degli algoritmi di garbage collection tradizionali usati in altri linguaggi di scripting.
La gestione della memoria ORO di newLISP è più veloce e utilizza meno risorse.
newLISP passa i parametri per valore-copia (pass by value) e memorizza i risultati intermedi su uno stack di risultati. La memoria creata per i risultati intermedi viene riciclata dopo il ritorno della funzione. Come la tradizionale garbage collection, la gestione della memoria ORO libera il programmatore dal gestire l'allocazione e la riallocazione della memoria.
Per evitare di copiare gli oggetti di dati quando si passa per valore-copia, possiamo passare questi dati per riferimento (by reference) racchiudendoli in contesti (context).
Il seguente frammento di codice mostra il passaggio per riferimento utilizzando il funtore di predefinito di uno spazio di nomi:

(define (modify data value)
  (push value data))

(set 'reflist:reflist '(b c d e f g))

(modify reflist 'a) ; passato per riferimento

reflist:reflist => (a b c d e f g)

La gestione automatica della memoria di newLISP è completamente trasparente per il programmatore, ma più veloce e
è richiede meno risorse rispetto ai classici algoritmi di garbage collection.
Poiché la gestione della memoria ORO è sincrona, il codice newLISP ha un tempo di esecuzione è costante e ripetibile. I linguaggi di programmazione che utilizzano la garbage collection tradizionale mostrano ritardi e pause improvvis.
La combinazione tra il passaggio per valore-copia e la gestione unica della memoria rendono newLISP il linguaggio di scripting interattivo (non compilato) più veloce in generale tra quelli disponibili. Come mostrato sopra, è comunque possibile anche il passaggio per riferimento. Per le funzioni integrate il passaggio per riferimento è quello predefinito.
Come sottoprodotto della gestione della memoria ORO di newLISP, è necessario solo il segno di uguale "=" per verificare l'uguaglianza tra due oggetti. Common Lisp richiede eq, eql, equal, equalp, =, string=, string-equal, char= e char-eq per i test di uguaglianza di espressioni, tipi di dati, oggetti identici e oggetti referenziati.

Macro Fexpr e macro di riscrittura
----------------------------------
In newLISP, le forme speciali (special form) vengono create usando fexprs definite con la funzione define-macro. Il Common Lisp utilizza dei template di espansione e compilazione per creare le forme speciali. Le forme speciali non valutano i loro argomenti o li valutano solo in condizioni speciali. In newLISP, le fexprs sono chiamate macro perché servono allo stesso scopo delle macro utilizzate in altri dialetti LISP: esse consentono la definizione di forme speciali.
Le fexpr create con define-macro controllano completamente quando gli argomenti vengono valutati. Come risultato, le macro di newLISP possono funzionare come forme speciali integrate:

(define-macro (my-setq x y) (set x (eval y)))

; come macro igienica evitando la cattura delle variabili
(define-macro (my-setq) (set (args 0) (eval (args 1)))))

newLISP può avviare l'espansione delle variabili esplicitamente usando le funzioni expand e letex:

(define (raise-to power)

(expand (fn (base) (pow base power)) 'power))

(define square (raise-to 2))

(define cube (raise-to 3))

(quadrato 5) => 25

(cubo 5) => 125

L'espansione delle variabili può essere utilizzata per catturare lo stato di variabili libere. Vedi un'applicazione di questo concetto nell'appendice: "The Y of Why in newLISP". newLISP combina frequentemente define-macro e i template di espansione usando expand o letex.
In newLISP la cattura delle variabili nelle fexpr può essere evitata racchiudendole in uno spazio di nomi, oppure usando la funzione args per recuperare i parametri passati, cioè (args 0) per il primo (args 1) per il secondo e così via. In entrambi i casi, le fexpr risultanti sono completamente igieniche senza pericolo di cattura delle variabili.
Nella versione 10.1.6, newLISP ha introdotto macro di riscrittura-espansione in un modulo caricabile. Dalla versione 10.6.0, la stessa funzionalità è disponibile con una funzione macro nativa integrata che funziona in modo identico:

; registra un template macro
(macro (cubo X) (pow X 3))

; durante il caricamento del codice, le macro vengono espanse.
(cubo 3) => 27

La funzione di espansione delle macro si aggancia tra il processo di lettura/traduzione del sorgente e il processo di valutazione. Nell'esempio, ogni occorrenza di (cubo n) verrebbe tradotta in (pow n 3). In questo modo si evita il sovraccarico di lavoro delle fexpr.

Indicizzazione implicita (Implicit Indexing)
-------------------------------------------
newLISP ha la capacità di indicizzazione implicita. Questa è un'estensione logica delle regole di valutazione LISP che permette di indicizzare implicitamente le liste e le stringhe in aggiunta alle normali funzionalità di indicizzazione integrate disponibili (nth, rest, slice):

(set 'myList '(a b c (d e) f g))

; utilizzando la funzione  nth
(nth 2 myList) => c

; con un vettore di indici
(nth '(3 1) myList) => e
(nth '(3 0) myList) => d

; utilizzando l'indicizzazione implicita
(myList 2) => c
(myList 3 1) => e
(myList -3 0) => d

; con un vettore di indici
(set 'v '(3 1))
(myList v) => e

; rest implicito, slice
(1 myList) => (b c (d e) f g)
(-3 myList) => ((d e) f g)
(1 2 myList) => (b c)

L'utilizzo dell'indicizzazione implicita è opzionale. In parecchi casi permette di aumentare la velocità e la leggibilità dei programmi.


============================================================================
Chiusure, contesti e funzioni con stato (Lutz Mueller)
============================================================================

Scheme utilizza le chiusure per scrivere funzioni generatrici, funzioni con stato e oggetti software. newLISP usa l'espansione delle variabili e spazi di nomi chiamati contesti (context) per fare lo stesso.
Gli spazi di nomi di newLISP sono sempre aperti all'ispezione. Sono oggetti di primo ordine che possono essere copiati e passati come parametri alle primitive di newLISP o alle funzioni lambda definite dall'utente.
Un contesto newLISP può contenere più funzioni contemporaneamente. Questo è il metodo usato da newLISP per costruire moduli software.
Come una chiusura Scheme, un contesto newLISP è uno spazio lessicamente chiuso. In newLISP all'interno di tale spazio di nomi l'ambito è dinamico. newLISP consente di combinare l'ambito (scope) lessicale e quello dinamico in modo flessibile.

Funzioni generatrici (Function factories)
-----------------------------------------
Il primo è un semplice esempio di una funzione generatrice. La funzione crea una funzione somma (adder) specifica per ogni numero da aggiungere. Mentre Scheme utilizza una chiusura di funzione per acquisire il numero in una variabile statica, newLISP utilizza la funzione expand per creare una funzione lambda specifica che contiene il numero come costante:

; Chiusura in Scheme

(definire make-adder
    (lambda (n)
        (lambda (x) (+ x n))))

(definire add3 (make-adder 3)) => # <procedure add3>

(add3 10) => 13

newLISP usa exp o letex per rendere il numero n una parte dell'espressione lambda come costante, oppure usa la funzione curry:

; newLISP usando expand

(define (make-adder n)
    (expand (lambda (x) (+ x n)) 'n))

(define add3 (make-adder 3))

(add3 10) => 13

; newLISP usando letex

(define (make-adder n)
    (letex (c n) (lambda (x) (+ x c))))

; oppure letex sullo stesso simbolo

(define (make-adder n)
    (letex (n n) (lambda (x) (+ x n)))))

(define add3 (make-adder 3))

(add3 10) => 13

; newLISP usando curry

(define add3 (curry + 3))

(add3 10) => 13

In entrambi i casi creiamo un'espressione lambda con il numero 3 contenuto come costante.

Funzioni con memoria
--------------------
Il prossimo esempio usa una chiusura per scrivere una funzione generatore. Produce un risultato diverso ogni volta che viene chiamata e ricorda uno stato interno:

; generatore in Scheme

(define gen
    (let ((acc 0))
         (lambda () (set! acc (+ acc 1)))))

(gen) => 1
(gen) => 2

In newLISP creiamo una variabile di stato locale usando un contesto come spazio di nomi:

; generatore newLISP

(define (gen:gen)
   (setq gen:sum
       (if gen:sum (inc gen:sum) 1)))

; Possiamo scriverlo più concisamente perchè "inc" tratta nil come zero

(define (gen:gen)
    (inc gen:sum))

(gen) => 1
(gen) => 2

Quando scriviamo gen:gen, viene creato un contesto chiamato gen. gen è uno psazio di nomi lessicale contenente i propri simboli usati come variabili e funzioni. In questo caso il lo spazio di nomi gen ha le variabili gen e sum.
Il primo simbolo gen ha lo stesso nome del gen del contesto genitore. Questo tipo di simbolo è chiamato un funtore predefinito in newLISP.
Quando si utilizza un nome di contesto al posto di un nome di funzione, newLISP assume il functor predefinito. Possiamo chiamare la nostra funzione generatore usando (gen). Non è necessario chiamare la funzione usando (gen:gen), (gen) viene riferito a (gen:gen) per default.
Vedi anche l'appendice successiva che crea la funzione "def-static" per automatizzare il processo di creazione di funzioni con ambito lessicale.

Introspezione
-------------
In newLISP è sempre possibile interrogare lo stato interno di una funzione. In Scheme lo stato di una chiusura è nascosto e non aperto all'introspezione senza codice aggiuntivo:

; in Scheme gli stati sono nascosti

add3 #<procedure add3>

gen => #<procedure gen>

; in newLISP gli stati sono visibili

add3 => (lambda (x) (+ x 3))

gen:sum => 2

gen:gen => (lambda () (inc gen:sum))

In Scheme la chiusura lambda è nascosta dall'ispezione, una volta che è stata valutata e assegnata.

Le funzioni in newLISP sono liste di primo ordine
-------------------------------------------------

(define (double x) (+ x x)))
(setf (nth 1 double) '(mul 2 x))

double => (lambda (x) (mul 2 x))

La natura di prima classe delle espressioni lambda in newLISP consente di scrivere codice auto-modificante.

Funzioni con memoria (stateful) che utilizzano la modifica in-place
-------------------------------------------------------------------

;; sum accumulator
(define (sum (x 0)) (inc 0 x))

(sum 1) ;=> 1
(sum 2) ;=> 3

sum ;=> (lambda ((x 0)) (inc 3 x))

;; self incrementer
(define (incre) (inc 0))

(incre) ;=> 1
(incre) ;=> 2
(incre) ;=> 3

incre ;=> (lambda () (inc 3)

;; make stream function with expansion closure

(define (make-stream lst)
    (letex (stream lst)
        (lambda () (pop 'stream))))

(set 'lst '(a b c d e f g h))
(define mystream (make-stream lst))

(mystream) ;=> a
(mystream) ;=> b
(mystream) ;=> c

(set 'str "abcddefgh")
(define mystream (make-stream str))

(mystream) ;=> "a"
(mystream) ;=> "c"

Un altro interessante pattern automodificante è mostrato da Kazimir Majorinc all'indirizzo:
http://kazimirmajorinc.com/Documents/Crawler-tractor/index.html

(define (f)
  (begin
    (println (inc cnt))
    (push (last f) f -1)
    (if (> (length f) 3) (pop f 1))))

Il pattern chiamato "Crawler tractor" (trattore cingolato) verrà eseguito per sempre senza utilizzare iterazione o ricorsione. Il nuovo codice da eseguire viene copiato dal vecchio codice e aggiunto alla fine della funzione. Il vecchio codice eseguito viene estratto dall'inizio della funzione.
newLISP ha la possibilità unica di scrivere funzioni auto-modificanti.


============================================================================
Creazione di funzioni con ambito lessicale in newLISP (Lutz Mueller)
============================================================================

Una funzione predefinita appare e si comporta in modo analogo alle funzioni con ambito statico trovate in altri linguaggi di programmazione. Diverse funzioni possono condividere uno spazio di nomi.

Utilizzando la primitiva integrata "def-new", è possibile definire una funzione o una macro per creare altre funzioni racchiuse nel proprio spazio di nomi:

(define (def-static s body)
    (def-new 'body (sym s s)))

(setq sum 0)

(def-static 'acc (lambda (x)
        (inc sum x)))

(acc 5)  → 5
(acc 5)  → 10
(acc 2)  → 12

acc:sum  → 12
acc:x    → nil

acc:acc  → (lambda (acc:x) (inc acc:sum acc:x))

sum      → 0

La funzione lavora creando un contesto e un functor predefinito dal nome della funzione. Il valore di acc:sum viene inizializzato a 0 copiando il valore di MAIN:sum.

Utilizzando acc come prototipo, è possibile creare nuove funzioni con ambito statico:

  (new 'acc 'myacc)

  (myacc 3) → 15

La nuova funzione inizierà con myacc:sum come presente in acc:sum quando viene copiato con new.

Utilizzando un metodo più complesso, una def-static può essere definita come una macro che può essere utilizzata come la normale funzione di definizione:

;; define static functions (use only in context MAIN)
;;
;; Example:
;;
;; (def-static (foo x) (+ x x))
;;
;; foo:foo   → (lambda (foo:x) (+ foo:x foo:x))
;;
;; (foo 10)  → 20
;;
(define-macro (def-static)
   (let (temp (append (lambda) (list (1 (args 0)) (args 1))))
       (def-new 'temp (sym (args 0 0) (args 0 0)))))

(def-static (acc x)
       (inc sum x))

(acc 5)  → 5
(acc 5)  → 10
(acc 2)  → 12

acc:sum  → 12
acc:x    → nil

La macro def-static crea innanzitutto un'espressione lambda della funzione da definire nello spazio di nomi attuale e la assegna alla variabile temp. In una seconda fase, la funzione lambda in temp viene copiata nel proprio spazio di nomi. Ciò accade assegnandolo al functor predefinito acc:acc costruito partendo dal nome della funzione.


============================================================================
The Y of Why in newLISP (Lutz Mueller)
============================================================================

Il compito è trovare una funzione Y, che può trasformare una funzione ricorsiva in una funzione veramente funzionale senza effetti collaterali, senza variabili libere e con la proprietà del punto fisso (fixed point). Quanto segue è una versione di "The Why of Y" [1] di Richard P. Gabriel modificata per newLISP.

Trovare Y
---------
Questa è la definizione ricorsiva originale del fattoriale:

  (define fact (lambda (n) (if (< n 2) 1 (* n (fact (- n 1))))))

L'originale fattoriale ridefinito come funzione anonima e prendendo il vero fattoriale in h:

  (lambda (h) (lambda (n) (if (< n 2) 1 (* n (h (- n 1))))))

Se questa funzione è chiamata F e il fattoriale vero è f allora ((F f) n) = (F n), f è un punto fisso di F.

Stiamo cercando una funzione Y con la proprietà: ((F (Y F)) x) = ((Y F) x)

Questa funzione è chiamata "Applicative-order Y fixed point operator" per i funzionali. Per ottenere ciò, trasformiamo la forma base della funzione fattoriale:

Il fattoriale base con il vero fattoriale:

  (lambda (n) (if (< n 2) 1 (* n (h (- n 1)))))

Passiamo la funzione fattoriale come parametro:

  (lambda (h n) (if (< n 2) 1 (* n (h h (- n 1)))))

Impacchettiamo come espressione anonima e proviamo:

  (let ((g (lambda (h n)
           (if (< n 2) 1 (* n (h h (- n 1)))))))
    (g g 10)); => 3628800

Fino a questo punto le espressioni sono identiche a quelle trovate in "The Why of Y" di Richard P. Gabriel. Il resto delle trasformazioni segue Gabriel, ma inserisce la funzione newLISP "expand" dove richiesto per ottenere un effetto di chiusura per la funzione passata come parametro nell'espressione (lambda (h) ...).

Curry (g g 10) a ((g g) 10):

  (let ((g (lambda (h)
          (espandi (lambda (n) (if (< n 2) 1 (* n ((h h) (- n 1))))) 'h))))
      ((g g) 10))

Estraiamo (h h) come f:

  (let ((g (lambda (h)
            (espandi (lambda (n)
              (let ((f (lambda (f n)
                      (if (< n 2) 1 (* n (f (- n 1)))))))
              (f (h h) n))) 'h))))
           ((g g) 10))

Curry la definizione di f per f interna a (lambda (f n) ...):

  (let ((g (lambda (h)
           (espandi (lambda (n)
            (let ((f (lambda (q)
                   (espandi (lambda (n)
                     (se (< n 2) 1 (* n (q (- n 1))))) 'q)))); in Schema
             ((f (h h)) n))) 'h))))
    ((g g) 10))

Riscriviamo per portare f in cima:

  (let ((f (lambda (q) (expand (lambda (n) (if (< n 2) 1 (* n (q (- n 1))))) 'q))))
    (let ((g (lambda (h) (expand (lambda (n) ((f (h h)) n)) 'h))))
       ((g g) 10)))

La funzione Y
-------------
Ora definiamo Y come la corretta espansione e sostituzione di h e f:

  (define Y (lambda (f) (expand
      (let ((g (lambda (h) (expand (lambda (x) ((f (h h)) x)) 'h))))
            (g g)) 'f)))

Evitando il let e portando fuori l'espressione (g g) si ottiene:

  (define  Y (lambda (f) (expand
      ((lambda (h) (expand (lambda (x) ((f (h h)) x)) 'h))
       (lambda (h) (expand (lambda (x) ((f (h h)) x)) 'h))) 'f)) )

newLISP deve applicare expand per ottenere l'effetto di chiusura per la procedura passata q:

  (define f
    (lambda (q) (expand (lambda (n) (if (< n 2) 1 (* n (q (- n 1))))) 'q)))

  ((Y f) 10) ;=> 3628800

Mostriamo la proprietà del punto fisso:

  (= ((Y f) 10) ((f (Y f)) 10) ) ;=> true

  ((f (Y f)) 10) ;=> 3628800

  ((f (f (Y f))) 10) ;=> 3628800

Il valore di ritorno di (Y f) mostra che (Y f) è puramente funzionale, senza effetti collaterali e senza variabili libere:

  (lambda (x)
  (((lambda (q) (expand (lambda (n) (if (< n 2) 1 (* n (q (- n 1))))) 'q))
    ((lambda (h) (expand (lambda (x) (((lambda (q) (expand
       (lambda (n) (if (< n 2) 1 (* n (q (- n 1))))) 'q)) (h h)) x)) 'h))
     (lambda (h) (expand (lambda (x) (((lambda (q) (expand
       (lambda (n) (if (< n 2) 1 (* n (q (- n 1))))) 'q)) (h h)) x)) 'h)))) x))

Controlla un'altra funzione ricorsiva fibo:

  (define f (lambda (q) (expand
           (lambda(n) (if(< n 2) 1 (+  (q (- n 1)) (q (- n 2))))) 'q)) )

  (define fibo (Y f))

  (fibo 10) ;=> 89

[1] "The Why of Y" di Richard P. Gabriel - 2001
http://www.dreamsongs.com/NewFiles/WhyOfY.pdf


Note
----
Il Lambda calcolo in newLISP è basato sulla ridefinizione di Lambda - expand espande le variabili maiuscole:

    (define-macro (LAMBDA)
      (append (lambda ) (expand (args))))

Per una differente versione di Y, ma con identiche funzionalità, vedi: "The Y Combinator (Slight Return)" di Mike Vanier
https://mvanier.livejournal.com/2897.html


============================================================================
Valutazione delle espressioni, Indicizzazione Implicita, Contesti e Funtori di Default (Lutz Mueller)
============================================================================

L'indicizzazione esplicita e i funtori di default sono una estensione delle normali regole di valutazione delle espressioni in LISP. I contesti forniscono spazi di nomi lessicamente chiusi (con stato) in un linguaggio di programmazione con ambito (scope) dinamico.

Valutazione delle S-espressioni e indicizzazione implicita
----------------------------------------------------------
In un altro articolo viene spiegato come la valutazione delle S-espressioni si interfaccia con il metodo di gestione automatica della memoria ORO (One Reference Only) [1]. Il seguente pseudo-code della funzione di valutazione di newLISP mostra come l'indicizzazione implicita sia un'estensione delle regole di valutazione delle S-espressioni in LISP:

function evaluateExpression(expr)
    {
    if typeOf(expr) is constant (BOOLEAN, NUMBER, STRING, CONTEXT)
        return(expr)

    if typeOf(expr) is SYMBOL
        return(symbolContents(expr))

    if typeOf(expr) is QUOTED
        return(unQuotedContents(expr))

    if typeOf(expr) is LIST
        {
        func = evaluateExpression(firstOf(expr))
        args = rest(expr)
        if typeOf(func) is BUILTIN_FUNCTION
            result = evaluateFunc(func, args)
        else if typeOf(func) = LAMBDA_FUNCTION
            result = evaluateLambda(func, args)
    /* extensions for default functor */
        if typeOf(func) is CONTEXT
            func = defaultFunctor(func)
                if typeOf(func) = LAMBDA_FUNCTION
                    result = evaluateLambda(defaultFunctor(func), args)
        /* extensions for implicit indexing */
        else if typeOf(func) = LIST
            result = implicitIndexList(func, args)
        else if typeOf(func) = STRING
            result = implicitIndexString(func, args)
        else if typeOf(func) = ARRAY
            result = implicitIndexArray(func, args)
        else if typeOf(func) = NUMBER
            result = implicitNrestSlice(func, args)
        }
    }

    return(result)
    }

Il funzionamento generale della funzione riflette la struttura generale della funzione eval descritta da John McCarthy nel 1960, [2].

La funzione first elabora le espressione atomiche. Le costanti valutano su se stesse e vengono restituite. I simboli valutano al loro contenuto.

Se l'espressione è una lista, il primo elemento (first) viene applicato al resto della lista (rest). Come in Scheme, newLISP valuta il primo elemento prima di applicarlo ai suoi argomenti.

Lisp o Scheme tradizionali consentono solo una funzioni built-in, un operatore o una funzione lambda definita dall'utente come prima posizione (funtore) nella lista S-espression da valutare. In newLISP un simbolo del contesto, una lista, un vettore e un numero possono agire come funzioni se si trovano nella posizione del funtore (prima posizione).

Le funzioni built-in vengono valutate chiamando evaluateFunc(func, args), i funtori, che sono espressioni lambda, chiamano la funzione evaluateLambda(func, args). Entrambe le funzioni a loro volta chiameranno evaluateExpression(expr) di nuovo per la valutazione degli argomenti della funzione.

Il funzionamento di un simbolo di contesto nella posizione del functor di una 'S-espressione sarà spiegato più in basso nel capitolo sugli spazi di nomi (namespace) e i funtori predefiniti.

Il tipo lista fa sì che newLISP valuti l'intera S-espressione come l'elemento indicizzato dal numero/i che segue l'elenco e interpretato come indice o indici (in newLISP gli elementi nidificati possono essere indicizzati usando indici multipli).

(set 'lst '(a b (c d e) f g))
(lst 2)  → (c d e)
(lst 2 1)  → d

(set 'str "abcdefg")
(str 2)  → "c"

Un numero nella posizione del funtore assumerà funzionalità di slicing e applicherà la funzione slice alla lista seguente utilizzando come offset quel numero. Quando abbiamo due numeri, allora il secondo specifica la lunghezza dello slice della lista:

(1 lst)  → (b (c d e) f g)
(1 2 lst)  → (b (c d e))

(1 2 str)  → "bc"

A prima vista sembra logico estendere questo fuznionamento anche ai dati di tipo booleano. Un espressione condizionale ternaria potrebbe essere realizzata sernza utilizzare l'operatore if, ma in pratica questo porta a difficoltà nella lettura del codicee causa troppe ambiguità nei messaggi di errore. Nella maggior parte dei casi, l'indicizzazione implicita genera un codice più leggibile, poichè l'oggetto dati viene raggruppato insieme ai suoi indici. L'indicizzazione implicita è molto veloce, ma è opzionale. Le parole chiave "nth", "first", "last", "rest" e "slice" possono essere usate in quei pochi casi in cui la leggibilità è migliore con l'utilizzo di forme esplicite di indicizzazione.

Lo stack dell'ambiente e l'ambito dinamico (dynamic scoping)
------------------------------------------------------------
Nella funzione eval del Lisp originale, un variabile  d'ambiente viene implementata come una lista di associazioni di simboli e i loro valori. In newLISP un simbolo viene implementato come una struttura dati con uno slot per il valore e la variabile d'ambiente non è una lista di asssocizioni, ma un albero binario per i simboli e uno stack fi ambiente che memorizza i valori precedenti dei simboli nei livelli di valutazione più alti.

Quando incontriamo una funzione lambda, i parametri dei simboli e i loro valori correnti sono inseriti sullo stack d'ambiente. Qando lasciamo la funzione, i parametri dei simboli sono ripristinati ai valori precedenti, cioè ai valori che avevano immediatamente prima di entrare nello stack. Qualuqnque chiamata ad un'altra funzione vedrà il valore del simbolo così come definito nell'ambito della funzione chiamante. Le variabili d'ambiente cambiano dinamicamente durante le chiamate e il ritorno delle funzioni. L'ambito dei una variabile viene esteso dinamicamente nei livelli inferiori di chiamate.

Il seguente esempio imposta due mvariabili e definisce due funzioni lambda. Dopo la loro definizione, le funzioni vengono utilizzate in modo nidificato. La parte delle variabili d'ambiente che si modifica viene evidenziata con una freccia (==>):

; x  → nil, y  → nil;
; foo  → nil
; double  → nil
; environment stack: [ ]

(define (foo x y)
  (+ (double (+ x 1)) y))

; x → nil, y  → nil,
==> ; foo  → (lambda (x y) (+ (double (+ x 1)) y))
; double  → nil
; environment stack: [ ]

(define (double x)
  (* 2 x))

; x  → nil, y  → nil
; foo  → (lambda (x y) (+ (double (+ x 1)) y))
==> ; double  → (lambda (x) (* 2 x)))
; environment stack: [ ]

(set 'x 10) (set 'y 20)

==> ; x  → 10, y  → 20
; foo  → (lambda (x y) (+ (double (+ x 1)) y))
; double  → (lambda (x) (* 2 x)))
; environment stack: [ ]

In maniera simile a Scheme, newLISP utilizza lo stesso spazio di nomi (namespace) per memorizzare i simboli delle variabili e i simboli delle funzioni lambda definite dall'utente. La funzione "define" è solo un trucco per scrivere:

(set 'foo (lambda (x y) (+ (double (+ x 1)) y)))

Durante tutte queste operazioni lo stack d'ambiente rimane vuoto [ ]. I simboli che rappresentano espressioni lambda fanno parte dello stesso spazio di nomi dei simboli che contengono dati e vengono trattati allo stesso modo. Adesso la prima funzione "foo" viene chiamata:

(foo 2 4)

; after entering the function foo
==> ; x → 2, y → 4
; foo → (lambda (x y) (+ (double (+ x 1)) y))
; double → (lambda (x) (* 2 x)))
==> ; environment stack: [x -> 10, y -> 20]

Dopo essere entrati nella funzione, i vecchi valori di x e y vengono inseriti nello stack d'ambiente. Questa operazione di push è iniziata dalla funzione evaluateLambda(func, args), che verrà discussa in seguito in questo articolo. Internamente a "foo" viene chiamata la funzone "double":

(double 3)
; after entering the function double
==> ; x -> 3, y -> 4
; foo → (lambda (x y) (+ (double (+ x 1)) y))
; double → (lambda (x) (* 2 x)))
==> ; environment stack: [x -> 10, y -> 20, x -> 2]

; after return from double
==> ; x → 2, y → 4
; foo → (lambda (x y) (+ (double (+ x 1)) y))
; double → (lambda (x) (* 2 x)))
==> ; environment stack: [x -> 10, y -> 20]

; after return from foo
==> ; x → 10, y → 20
; foo → (lambda (x y) (+ (double (+ x 1)) y))
; double → (lambda (x) (* 2 x)))
==> ; environment stack: [ ]

Si noti che in newLISP l'ambito (scope) dinamico dei simboli dei parametri nelle espressioni lambda non crea chiusure di stato lessicale attorno a quei simboli come nel linguaggio Scheme (dialetto del Lisp). Al ritorno dalla funzione lambda il contenuto del simbolo viene distrutto e la memoria viene recuperata. I simboli dei parametri recuperano i loro vecchi valori all'uscita dalla funzione lambda prendendoli dallo stack d'ambiente.

In newLISP le chiusure lessicali con stato (lexical state-full closures) non vengono con le chiusure lambda, ma utilizzando spazi di nomi lessicali. Le funzioni lambda in newLISP non creano chiusure ma possono creare un nuovo ambito e un nuovo contenuto temporaneo per i simboli esistenti durante l'esecuzione della funzione lambda.

Valutazione delle funzioni lambda
---------------------------------
Tutti i processi appena descritti avvengono nella funzione evaluateLambda(func, args). Il seguente pseudo-codice mostra alcuni dettagli:

function evaluateLambda(lambda-func, args)
    {
    for each parameter symbol in lambda-func
        pushEnvironmentStack(symbol, value)

    for each arg in args and the symbol belonging to arg
        ; evaluation of arg happens in old symbol environment
        assignSymbolValue(symbol, evaluateExpression(arg))

    for each body expression expr in lambda-func
        result = evaluateExpression(expr)

    for each parameter symbol in lambda-func
        popEnvironmentStack()

    return(result)
    }

Le funzioni evaluateExpression(args) e evaluateLambda(func, args) si chiamano in modo reciproco in un ciclo  ricorsivo.

Si noti che gli argomenti delle funzioni lambda vengono valutati nell'ambiente delle variabili come definito precedentemente alla chiamata della funzione lambda. Le assegnazioni ai simboli dei parametri avvengono dopo tutte le valutazioni degli argomenti. Vengono valutati solo gli argomenti che hanno un simbolo di parametro corrispondente. Se sono presenti più simboli di parametro rispetto agli argomenti passati, i simboli dei parametri vengono assegnati a nil o a un valore predefinito.

Spazi di nomi (namespace) e il ciclo di traduzione e valutazione
----------------------------------------------------------------
Tutti gli oggetti dati di memoria in newLISP sono collegati direttamente o indirettamente a un simbolo. Gli oggetti di memoria sono referenziati direttamente da un simbolo o fanno parte di una S-espressione che li racchiude a cui fa riferimento un simbolo. Gli oggetti non legati (unbound) esistono solo come oggetti transitori come valori restituiti dalle valutazioni e sono referenziati sullo stack dei risultati per una eliminazione successiva [1].

Tranne che per i simboli, tutti i dati e gli oggetti del programma sono referenziati una sola volta. I simboli sono creati e organizzati in una struttura ad albero binario. Gli spazi di nomi (namespace), chiamati "context" in newLISP, sono sotto-rami in questo albero binario. Un contesto è associato a un simbolo nel contesto principale MAIN, che a sua volta è un simbolo nel contesto radice.

Con poche eccezioni, tutti i simboli vengono creati durante il caricamento del codice e la fase di traduzione dell'interprete newLISP. Solo le funzioni load, sym, eval-string e una speciale sintassi dei context creano simboli durante l'esecuzione del runtime.

I due simboli MAIN: x e CTX: x sono due simboli diversi in ogni momento. Un simbolo in nessun caso può cambiare il contesto dopo che è stato creato. Un contesto, ad esempio CTX, è di per sé un simbolo in MAIN contenente il puntatore di root a un sotto-ramo nell'albero dei simboli.

Il funzionamento del cambio di contesto è spiegato usando i seguenti due pezzi di codice:

(set 'var 123)
(define (foo x y)
    (context 'CTX)
    (println var " " x " " y))

L'istruzione (context 'CTX) è stata inclusa solo qui per mostrare, non ha alcun effetto in questa posizione. Un passaggio a un contesto di namespace diverso avrà influenza solo sulle successive creazione di simboli usando sym o eval-string. Nel momento in cui (context 'CTX) è eseguito, la funzione foo è già stata definita e tutti i simboli utilizzati in esso sono stati cercati e tradotti. Solo quando si utilizza (context ...) sul livello superiore influenzerà la creazione del simbolo con il codice che la segue:

(context 'CTX)
(set 'var 123)
(define (foo x y)
    (println var " " x " " y))
(context MAIN)

Adesso il contesto viene creato e passato al livello più alto. Quando newLISP traduce la successiva istruzione set e la definizione di funzione, tutti i simboli faranno parte di CTX come CTX:var, CTX:foo, CTX:x e CTX:y.

Durante il caricamento del codice newLISP legge un'espressione di livello superiore che traduce e poi valuta. Questo ciclo viene ripetuto fino a quando tutte le espressioni di livello superiore vengono lette e valutate.

(set 'var 123)
(define (foo x y)
    (println var " " x " " y))

Nello snippet di codice precedente due espressioni di livello superiore sono tradotte e valutate con conseguente creazione dei tre simboli: MAIN:var, MAIN:foo, MAIN:x, MAIN:y e MAIN:CTX.

Il simbolo MAIN:var conterrà il numero 123 e il simbolo MAIN:foo conterrà l'espressione lambda (lambda (x y) (println var " " x " " y)). I simboli MAIN:x e MAIN:y entrambi conterranno nil. La var all'interno della definizione di foo è la stessa della var precedentemente impostata a 123 e verrà stampata come 123 durante l'esecuzione di foo.

In dettaglio vengono eseguiti i seguenti passi:

1. il contesto attuale è MAIN

2. legge la parentesi di apertura di primo livello e crea una cella Lisp di tipo EXPRESSION.

3. legge e cerca set in MAIN e trova che è una primitiva built-in di MAIN, quindi lo traduce nell'indirizzo di memoria di questa funzione primitiva. Crea una cella Lisp di tipo PRIMITIVE che contiene internamente l'indirizzo della funzione.

4. legge il simbolo quote ' e crea una cella Lisp di tipo QUOTE.

5. Legge e cerca la variabile var in MAIN, non si trova in MAIN, lo crea in MAIN e lo traduce nell'indirizzo dell'albero binario dei simboli. Crea una cella Lisp di tipo SYMBOL contenente internamente l'indirizzo del simbolo. La cella di QUOTE precedentemente creata funge da inviluppo per la cella dei simboli.

6. Legge 123 e crea una cella Lisp di tipo INTEGER con 123 nello slot del contenuto.

7. legge la parentesi chiusa che chiude il primo livello e termina la seguente struttura di lista in memoria:

[ ]                          ; cell of type: EXPRESSION
  \
 [MAIN:set]  → [']  → [123]  ; three cells of type: PRIMITIVE, QUOTE, INTEGER
                 \
               [MAIN:var]    ; cell of type: SYMBOL

Il diagramma sopra mostra le cinque celle Lisp, che sono state create. Le celle List e quote sono celle di inviluppo che contengono una lista o un'espressione quotata.

L'istruzione (set 'var 123) non è ancora stata eseguita, ma la traduzione e la creazione dei simboli sono finite e l'istruzione esiste come una struttura di lista in memoria. L'intera struttura della lista può essere referenziata con un indirizzo di memoria, l'indirizzo della prima cella creata di tipo EXPRESSION.

8. Valutazione delle istruzioni
In modo simile newLISP leggerà e tradurrà la successiva espressione di primo livello, che è la definizione di funzione di foo. La valutazione di questa espressione di livello superiore comporterà un assegnamento di una espressione lambda al simbolo foo.

Nel codice sopra riportato, entrambe le istanze di var si riferiscono a MAIN:var. L'istruzione (context 'CTX) cambia solo il contesto, lo spazio di nomi per i nuovi simboli creati. Il simbolo var è stato creato durante il caricamento e la traduzione della funzione foo. Nel momento in cui foo viene chiamata ed eseguitola variabile var esiste già all'interno della funzione foo come MAIN:var. L'istruzione (context 'CTX) non ha alcun effetto sulla succesiva esecuzione di (println var).

Le istruzioni context come (context 'CTX) sopra, cambiano il contesto corrente per la creazione del simbolo durante la fase di caricamento e traduzione. Il contesto corrente definisce sotto quale ramo nell'albero dei simboli vengono creati nuovi simboli. Questo riguarda solo le funzioni sym, eval-string e una speciale sintassi di context per creare simboli. Una volta che un simbolo appartiene a un contesto, rimane lì.

Cambiamento di spazi di nomi (namespaces context)
-------------------------------------------------
I capitoli precedenti hanno mostrato come utilizzare il cambio di contesto al livello principale [top-level] di un  file sorgente newLISP per influenzare la creazione e la traduzione dei simboli durante il processo di caricamento della sorgente. Una volta che esistono spazi dei nomi diversi, chiamando una funzione che appartiene a un contesto diverso, si verificherà un cambio di contesto nello spazio dei nomi dove si trova la funzione lambda chiamata. Se la funzione chiamata non esegue alcuna istruzione sym o eval-string, allora questo cambio di contesto non hanno alcun effetto. Anche il comando load avvia sempre il caricamento del file relativamente al contesto MAIN, a meno che non venga specificato un contesto diverso come parametro speciale nellas funzione load. All'interno del file caricato i cambiamenti di contesto produrranno la creazioni di simboli durante il processo di load come spiegato precedentemente.

Ciò che causa i cambio di contesto è il simbolo che contiene la funzione lambda. Negli esempi di codice seguenti, la freccia ==> viene utilizzata per l'output generato dalle istruzioni println:

(context 'Foo)
(set 'var 123)
(define (func)
    (println "current context: " (context))
    (println "var: " var))
(context 'MAIN)

(Foo:func)
==> current context: Foo
==> var: 123

(set 'aFunc Foo:func)
(set 'var 999)

(aFunc)
==> current context: MAIN
==> var: 123

Si noti che la chiamata a aFunc fa sì che il contesto corrente venga visualizzato come MAIN, perché il simbolo aFunc appartiene al contesto MAIN. In entrambi i casi la variabile var viene stampata come 123. Il simbolo var è stato inserito nello spazio dei nomi di Foo durante la traduzione di func e resterà sempre lì, anche se una copia della funzione lambda viene creata e assegnata ad un simbolo in un contesto diverso.

Questo comportamento di cambio del contesto segue le stesse regole quando si applicano o si mappano le funzioni:

(apply 'Foo:func)
==> current context: Foo
==> var: 123

(apply Foo:func)
==> current context: MAIN
==> var: 123

La prima volta che Foo: func viene applicato come simbolo - quotato, la seconda volta la funzione lambda contenuta in Foo:func viene applicata direttamente, perchè apply valuta prima il suo primo argomento.

Spazi di nomi e il funtore di default
-------------------------------------
In newLISP, un simbolo è un funtore predefinito (default functor) se ha lo stesso nome del contesto a cui appartiene, es. Foo:Foo è il simbolo del funtore predefinito nel contesto Foo. In newLISP quando si utilizza un simbolo di contesto nella posizione del funtore, viene preso come il funtore predefinito:

(define (double:double x) (* 2 x))
(double 3)  → 6

(set 'my-list:my-list '(a b c d e f))
(my-list 3)  → d

Il secondo esempio combina l'indicizzazione implicita con l'uso di un funtore predefinito.

I funtori predefiniti possono essere applicati e mappati usando apply e map come qualsiasi altra funzione o simbolo di funtore:

(map my-list '(3 2 1 2))  → (d c b c)

(apply double '(10))  → 20

I funtori predefiniti sono un modo conveniente in newLISP per passare liste o altri oggetti big data per riferimento:

(set 'my-list:my-list '(a b c d e f))

(define (set-last ctx val)
  (setf (ctx -1) val))

(set-last my-list 99)  → f

my-list:my-list  → (a b c d e 99)

I funtori predefiniti sono anche un modo conveniente per definire funzioni full-state in uno spazio di nomi (functions with a closed state-full name space):

(context 'accumulator)
(define (accumulator:accumulator x)
  (if (not value)
    (set 'value x)
    (inc 'value x)))
(context MAIN)

(accumulator 10)  → 10
(accumulator 2)  → 12
(accumulator 3)  → 15

Nota che i simboli x e value appartengono entrambi allo spazio dei nomi accumulator. Poichè (context 'accumulator) è al livello più alto, la traduzione della seguente definizione di funzione accumulator:accumulator avviene all'interno dello spazio dei nomi corrente accumulator.

I namespace in newLISP possono essere passati per riferimento e possono essere utilizzati per creare chiusure lessicali full-state.

Il funtore di default usato come funzione pseudo-hash
-----------------------------------------------------
Un funtore predefinito che contiene nil e si trova nella posizione di operatore funzionerà in modo simile a una funzione di hash per la costruzione di dizionari con chiave associativa → accesso al valore:

(define aHash:aHash) ; create namespace and default functor containing nil

(aHash "var" 123) ; create and set a key "var" to 123

(aHash "var")  → 123 ; retrieve value from key

Riferimenti
-----------

[1] Lutz Mueller, 2004-2013
Automatic Memory Management in newLISP.

[2] John McCarthy, 1960
Recursive Functions of Symbolic Expressions and their Computation by Machine.


============================================================================
Gestione Automatica della Memoria in newLISP (Lutz Mueller)
============================================================================

ORO (One Reference Only) La gestione automatica della memoria sviluppata per newLISP è un'alternativa rapida e in grado di risparmiare risorse rispetto ai classici algoritmi di garbage collection dei linguaggi di programmazione dinamici e interattivi. Questo articolo spiega come funziona la gestione della memoria di tipo ORO.

newLISP e qualsiasi altro sistema di linguaggio interattivo genererano costantemente nuovi oggetti in memoria durante la valutazione delle espressioni. I nuovi oggetti in memoria sono il risultato delle valutazioni intermedie, della riassegnazione di oggetti in memoria o della modifica di oggetti in memoria il cui contenuto è stato modificato. Se newLISP non eliminasse alcuni degli oggetti creati, alla fine esaurirebbe la memoria disponibile.

Per comprendere la gestione automatica della memoria in newLISP, è necessario prima rivedere i metodi tradizionali utilizzati da altri linguaggi.

Metodi tradizionali di gestione automatica della memoria (Garbage Collection)
-----------------------------------------------------------------------------
Nella maggior parte dei linguaggi di programmazione, un processo registra la memoria allocata e un altro processo trova e ricicla le parti inutilizzate del pool di memoria allocato. Il processo di riciclaggio può essere attivato da un limite di allocazione della memoria o può essere programmato tra una fase di valutazione e l'altra. Questa forma di gestione automatica della memoria si chiama Garbage Collection.

Gli schemi di garbage collection tradizionali sviluppati per LISP utilizzavano uno dei due seguenti algoritmi:¹

(1) L'algoritmo mark-and-sweep registra ogni oggetto di memoria allocato. Una fase mark contrassegna periodicamente ciascun oggetto nel pool di memoria allocato. Un oggetto con nome (un simbolo di variabile) fa riferimento direttamente o indirettamente a ciascun oggetto di memoria nel sistema. La fase di sweep libera la memoria degli oggetti contrassegnati quando non sono più in uso.

(2) Uno schema di conteggio di riferimento registra ogni oggetto di memoria allocato insieme con un conteggio di riferimenti all'oggetto. Questo conteggio dei riferimenti viene incrementato o decrementato durante la valutazione dell'espressione. Ogni volta che il conteggio dei riferimenti di un oggetto raggiunge lo zero, la memoria allocata dell'oggetto viene liberata.

Nel corso del tempo, sono stati elaborati molti schemi di garbage collection basati su queste tecniche. I primi algoritmi di garbage collection sono apparsi in LISP. Gli inventori del linguaggio Smalltalk utilizzavano schemi garbage collection più elaborati. La storia di Smalltalk-80 è un resoconto entusiasmante delle sfide poste dall'implementazione di metodi di gestione della memoria in linguaggi di programmazione interattivi, vedi [Glenn Krasner, 1983: Smalltalk-80, Bits of History, Words of Advice]. Una panoramica più recente dei metodi di garbage collection è disponibile in [Richard Jones, Rafael Lins, 1996: Garbage Collection, Algorithms for Automatic Dynamic Memory Management].

One reference only, (ORO) memory management
-------------------------------------------
La gestione della memoria in newLISP non si basa su un algoritmo di garbage collection. La memoria non è marcata o referenziata per conteggio. Invece, una decisione se eliminare un oggetto di memoria appena creato viene effettuata subito dopo la creazione dell'oggetto.

Studi empirici su LISP hanno dimostrato che la maggior parte delle celle LISP non sono condivise e quindi possono essere recuperate durante il processo di valutazione. A parte alcune ottimizzazioni per parte delle funzioni integrate, newLISP cancella la memoria di nuovi oggetti contenenti risultati di valutazione intermedi una volta raggiunto un livello di valutazione più alto. newLISP fa ciò spingendo un riferimento ad ogni oggetto di memoria creato su uno stack di risultati. Quando newLISP raggiunge un livello di valutazione superiore, rimuove il riferimento del risultato dell'ultima valutazione dallo stack dei risultati ed elimina l'oggetto di memoria del risultato della valutazione. Questo non dovrebbe essere confuso con il conteggio dei riferimenti a un bit. La gestione della memoria ORO non imposta bit come adesivi per contrassegnare gli oggetti.

newLISP segue la regola di un solo riferimento (ORO). Ogni oggetto di memoria non referenziato da un simbolo è obsoleto quando newLISP raggiunge un livello di valutazione più alto durante la valutazione dell'espressione. Gli oggetti in newLISP (esclusi simboli e contesti) vengono passati per copia del valore ad altre funzioni definite dall'utente. Di conseguenza, ogni nuovo oggetto LISP richiede solo un riferimento.

La regola ORO di newLISP ha dei vantaggi. Semplifica non solo la gestione della memoria, ma anche altri aspetti del nuovo linguaggio LISP. Ad esempio, mentre gli utenti di LISP tradizionali devono distinguere tra l'uguaglianza degli oggetti di memoria copiati e l'uguaglianza dei riferimenti agli oggetti di memoria, gli utenti newLISP non ne hanno bisogno.

La regola ORO di newLISP forza newLISP ad allocare e liberare celle LISP costantemente. newLISP ottimizza questo processo allocando grandi blocchi di memoria per le celle dal sistema operativo. newLISP richiederà celle LISP da un elenco di celle libere e quindi le riciclerà nuovamente in quell'elenco. Di conseguenza, sono necessarie solo alcune istruzioni della CPU (assegnazioni di puntatori) per scollegare una cella libera o per reinserire una cella eliminata.

L'effetto complessivo della gestione della memoria ORO è un tempo di valutazione più rapido e una memoria e un ingombro del disco più contenuti rispetto a quelli offerti dal tradizionale LISP interpretato. Il tempo impiegato per collegare e scollegare gli oggetti di memoria è più che compensato dalla mancanza di tempo di elaborazione causata dai metodi tradizionali di garbage collection. La gestione della memoria ORO evita anche le pause occasionali di elaborazione nei linguaggii che utilizzano la tradizionale garbage collection e l'ottimizzazione dei parametri di garbage collection richiesti durante l'esecuzione di programmi che fanno uso intensivo di memoria.

La gestione della memoria ORO avviene in modo sincrono rispetto ad altre elaborazioni nell'interprete, il che si traduce in tempi di elaborazione deterministici.

Nelle versioni precedenti alla 10.1.3, newLISP utilizzava un classico algoritmo di mark e sweep per liberare celle non referenziate in condizioni di errore. A partire dalla versione 10.1.3, questo è stato eliminato e sostituito da una corretta pulizia dello stack dei risultati in condizioni di errore.

Considerazioni sulle prestazioni con i parametri di copia
---------------------------------------------------------
In teoria, il passaggio dei parametri alle funzioni definite dall'utente in base al valore (by-value, copia della memoria) anziché al riferimento pone un potenziale svantaggio quando si gestiscono liste, matrici o stringhe di grandi dimensioni. Ma in pratica newLISP è più veloce o veloce come altri linguaggi di scripting e offre speciali sintassi per passare oggetti di memoria molto grandi per riferimento.

Poiché le funzioni newLISP versione 9.4.5 possono passare parametri di tipo list, array e string come riferimenti utilizzando gli identificativi dei funtori predefiniti ​​degli spazi dei nomi. I namespace (chiamati contesti in newLISP) hanno un overhead molto piccolo e possono essere utilizzati per avvolgere funzioni e dati. Ciò consente il passaggio di riferimento di un grande oggetto di memoria nelle funzioni definite dall'utente.

Dalla versione 10.2, FOOP (Functional Object Oriented Programming) in newLISP passa per riferimento anche l'oggetto target di una chiamata di metodo.

Ma anche nei casi in cui il passaggio di riferimento e altre ottimizzazioni non sono presenti, la velocità della gestione della memoria ORO compensa ampiamente il sovraccarico necessario per copiare ed eliminare oggetti.

Ottimizzazioni per la gestione della memoria ORO ²
------------------------------------------------
Dalla versione 10.1 di newLISP, tutte le liste, i vettori (array) e le stringhe vengono passati in e out dalle funzioni predefinite per riferimento. Tutte le funzioni integrate funzionano direttamente sugli oggetti di memoria restituiti per riferimento da altre funzioni incorporate. Ciò ha sostanzialmente ridotto la necessità di copiare ed eliminare oggetti di memoria e aumentato la velocità di alcune funzioni incorporate. Ora solo i parametri in funzioni definite dall'utente e i valori di ritorno passati da funzioni definite dall'utente sono gestiti da ORO.

Dalla versione 10.3.2, newLISP controlla lo stack dei risultati prima di copiare le celle LISP. Ciò ha ridotto la quantità di celle copiate di circa l'83% e ha aumentato significativamente la velocità di molte operazioni su liste più grandi.

Memoria e tipi di dati in newLISP
-------------------------------
Gli oggetti di memoria delle stringhe newLISP vengono allocati e liberati sul sistema operativo host, ogni volta che newLISP ricicla le celle dai suoi blocchi di allocazione delle celle di memoria. Ciò significa che newLISP gestisce la memoria delle celle in modo più efficiente rispetto alla memoria delle stringhe. Di conseguenza, è spesso preferibile utilizzare simboli anziché stringhe per un'elaborazione efficiente. Ad esempio, quando si gestisce il linguaggio naturale è più efficiente gestire le parole del linguaggio naturale come singoli simboli in uno spazio dei nomi separato, quindi come singole stringhe. La funzione bayes-train in newLISP utilizza questo metodo. newLISP può gestire milioni di simboli senza compromettere le prestazioni.

I programmatori provenienti da altri linguaggi di programmazione spesso trascurano che i simboli in LISP possono comportarsi come qualcosa di più di semplici variabili o riferimenti a oggetti. Il simbolo è un tipo di dati utile in sé, che in molti casi può sostituire il tipo di dati stringa.

I numeri interi e i numeri a virgola mobile (double) sono memorizzati direttamente nelle celle LISP di newLISP e non richiedono un ciclo di allocazione della memoria separato.

Per l'efficienza durante operazioni con matrici come la moltiplicazione o l'inversione della matrice, newLISP assegna oggetti di memoria non-cella per matrici, converte i risultati in celle LISP e quindi libera gli oggetti di memoria matrice.

newLISP alloca un array come un gruppo di celle LISP. Le celle LISP sono allocate in modo lineare. Di conseguenza, gli indici di array hanno un accesso casuale più rapido alle celle LISP. Solo un sottoinsieme delle funzioni di newLISP disponibilki per le liste può essere utilizzato sugli array. La gestione automatica della memoria in newLISP gestisce gli array in modo simile a come gestisce le liste.

Implementazione della gestione della memoria ORO
------------------------------------------------
Il seguente pseudo codice illustra l'algoritmo implementato in newLISP nel contesto della valutazione dell'espressione LISP. Sono necessarie solo due funzioni e una struttura dati per implementare la gestione della memoria ORO:

function pushResultStack(evalationResult)

function popResultStack() ; implies deleting

array resultStack[] ; preallocated stack area

Le prime due funzioni pushResultStack e popResultStack spingono (push) o estraggono (pop) un handle di un oggetto LISP avanti e indietro da una pila. pushResultStack aumenta il valore resultStackIndex mentre popResultStack lo diminuisce. In newLISP ogni oggetto è contenuto in una struttura di celle LISP. L'handle di oggetto di quella struttura è semplicemente il puntatore di memoria alla struttura della cella. La cella stessa può contenere indirizzi puntatore ad altri oggetti di memoria come buffer di stringa o altre celle LISP collegate all'oggetto originale. Oggetti piccoli come numeri vengono memorizzati direttamente. In questa funzione popResultStack() implica anche che l'oggetto estratto venga eliminato.

Le due funzioni di gestione resultStack descritte sono chiamate dalla funzione evaluateExpression di newLISP:³

;; function evaluateExpression(expr)
;;     {
;;     resultStackIndexSave = resultStackIndex
;;
;;     if typeOf(expr) is BOOLEAN or NUMBER or STRING
;;     return(expr)
;;
;;     if typeOf(expr) is SYMBOL
;;         return(symbolContents(expr))
;;
;;     if typeOf(expr) is QUOTE
;;         return(quoteContents(expr))
;;
;;     if typeOf(expr) is LIST
;;         {
;;         func = evaluateExpression(firstOf(expr))
;;         args = rest(expr)
;;         if typeOf(func) is BUILTIN_FUNCTION
;;                 result = evaluateFunc(func, args)
;;         else if typeOf(func) = LAMBDA_FUNCTION
;;                 result = evaluateLambda(func, args)
;;         }
;;     }
;;
;;     while (resultStackIndex > resultStackIndexSave)
;;         deleteList(popResultStack())
;;
;;     pushResultStack(result)
;;
;;     return(result)
;;     }

La funzione evaluateExpression introduce le due variabili resultStackIndexSave e resultStackIndex e alcune altre funzioni:

resultStackIndex è un indice che punta all'elemento superiore di resultStack. Maggiore è il livello di valutazione, maggiore è il valore di resultStackIndex.

resultStackIndexSave funge da memoria temporanea per il valore di resultStackIndex all'entrata della funzione evaluateExpression(func, args). Prima di uscire, il resultStack viene visualizzato al livello salvato di resultStackIndex. Estrarre il resultStack implica l'eliminazione degli oggetti di memoria indicati dalle voci nel resultStack.

resultStack[] è un'area di stack preallocata per il salvataggio di puntatori a celle LISP che sono indicizzate da resultStackIndex.

symbolContents(expr) e quoteContents(expr) estraggono il contenuto da simboli o da celle di memoria quotate (inviluppate con quote).

typeOf(expr) estrae il tipo di un'espressione, che è una costante BOOLEAN come nil o true o un NUMBER o STRING, oppure una variabile SYMBOL contenente alcuni contenuti, o un QUOTE che serve come una busta di inviluppo per un'altra espressione LIST expr.

evaluateFunc(func, args) è l'applicazione di una funzione built-in ai suoi argomenti. La funzione built-in è il primo membro valutato di una lista in expr e gli argomenti sono il resto della lista in expr. La funzione func viene estratta chiamando evaluateExpression(first (expr)) in modo ricorsivo. Ad esempio se l'espressione expr vale (foo x y) allora foo è una funzione built-in e x e y sono gli argomenti o parametri della funzione.

evaluateLambda(func, args) funziona in modo simile a evaluateFunc(func, args), applicando una funzione definita dall'utente first(expr) ai suoi argomenti definiti in rest(expr). Nel caso di una funzione definita dall'utente abbiamo due tipi di argomenti in rest(expr), un elenco di parametri locali seguiti da una o più espressioni del corpo valutate in sequenza.
Sia, evaluateFunc(func, args) e evaluateLambda(func, args) restituiranno un oggetto cella LISP appena creato o copiato, che può essere qualsiasi tipo di espressione sopra menzionata. Dalla versione 10.0, molte funzioni built-in elaborate con evaluateFunc(func, args) sono ottimizzate e restituiscono riferimenti invece di oggetti appena creati o copiati. Fatta eccezione per queste ottimizzazioni, i valori dei risultati saranno sempre gli oggetti di cella LISP appena creati destinati a essere distrutti al successivo livello di valutazione più alto, dopo che la funzione evaluateExpression (expr) corrente è stata eseguita.

Entrambe le funzioni chiamano ricorsivamente evaluateExpression(expr) per valutare i loro argomenti. Con l'aumentare della ricorsione, aumenta il livello di ricorsione della funzione.

Prima del ritorno di evaluateExpression(func, args), questa popolerà il resultStack eliminando i valori del risultato dal livello più profondo di valutazione e restituito da una delle due funzioni, evaluateFunc o evaluateLambda.

Qualsiasi espressione di risultato appena creata è destinata a essere distrutta in seguito, ma la sua cancellazione viene ritardata fino a raggiungere un livello di valutazione più alto, meno profondo. Ciò consente di utilizzare e/o copiare i risultati richiamando le funzioni.

L'esempio seguente mostra la valutazione di una piccola funzione LISP sum-of-squares definita dall'utente e la creazione e l'eliminazione di oggetti di memoria associati:

(define (sum-of-squares x y)
  (+ (* x x) (* y y)))

(sum-of-squares 3 4) => 25

sum-of-squares è una funzione lambda definita dall'utente che chiama le funzioni built-in + e *.

Il seguente trace mostra i passaggi rilevanti quando si definisce la funzione somma dei quadrati e quando si esegue con gli argomenti 3 e 4.

> (define (sum-of-squares x y) (+ (* x x) (* y y)))

level 0: evaluateExpression( (define (sum-of-squares x y)
 (+ (* x x) (* y y))) )
level 1: evaluateFunc( define <6598> )
level 1: return( (lambda (x y) (+ (* x x) (* y y))) )

→ (lambda (x y) (+ (* x x) (* y y)))

> (sum-of-squares 3 4)

level 0: evaluateExpression( (sum-of-squares 3 4) )
level 1:   evaluateLambda( (lambda (x y) (+ (* x x) (* y y))), (3 4) )
level 1:   evaluateExpression( (+ (* x x) (* y y)) )
level 2:     evaluateFunc( +, ((* x x) (* y y)) )
level 2:     evaluateExpression( (* x x) )
level 3:       evaluateFunc( *, (x x) )
level 3:       pushResultStack( 9 )
level 3:       return( 9 )
level 2:     evaluateExpression( (* y y) )
level 3:       evaluateFunc( *, (y y) )
level 3:       pushResultStack( 16 )
level 3:       return( 16 )
level 2:     popResultStack() → 16
level 2:     popResultStack() → 9
level 2:     pushResultStack( 25 )
level 2:     return( 25 )
level 1:   return( 25 )

→ 25

L'attuale implementazione del linguaggio C è ottimizzata in alcuni punti per evitare di inserire (pop) il resultStack ed evitare di chiamare evaluateExpression (expr). Vengono mostrati solo i passi più rilevanti. La funzione evaluateLambda (func, args) non ha bisogno di valutare i suoi argomenti 3 e 4 perché sono costanti, ma evaluateLambda(func, args) chiamerà evaluateExpression(expr) due volte per valutare le due espressioni del corpo (+ (* xx) e (+ (* xx). Linee precedute dal prompt > mostrano l'input della riga di comando.

evaluateLambda(func, args) salva anche l'ambiente per i simboli variabili x e y, copia i parametri in variabili locali e ripristina il vecchio ambiente all'uscita. Anche queste azioni comportano la creazione e la cancellazione di oggetti di memoria. I dettagli sono omessi perché sono simili ai metodi in altri linguaggi dinamici.

Riferimenti
– Glenn Krasner, 1983: Smalltalk-80, Bits of History, Words of Advice
Addison Wesley Publishing Company

– Richard Jones, Rafael Lins, 1996: Garbage Collection, Algorithms for Automatic Dynamic Memory Management
John Wiley & Sons

¹ Gli algoritmi Reference counting and mark-and-sweep sono stati  sviluppati appositamente per il LISP. Altri schemi come la copia o gli algoritmi generazionali sono stati sviluppati per altri linguaggi come Smalltalk e successivamente anche in LISP.

² Questo capitolo è stato aggiunto nell'ottobre 2008 ed è stato esteso ad agosto 2011.

³ Questa è una versione abbreviata della valutazione delle espressioni che non include la gestione dei funtori predefiniti e l'indicizzazione implicita. Per ulteriori informazioni sulla valutazione delle espressioni, consultare: "Valutazione dell'espressione, Indicizzazione implicita, Contesti e Funtori di default"


====================
Benchmarking newLISP
====================

Questo documento contiene tutte le funzioni utilizzate da Lutz Mueller per il Benckmark di newLISP. Le funzioni sono state leggermente modificate per il sistema operativo Windows.

Lista delle funzioni:

 1) Ackerman
 2) Array Access
 3) Concatenate
 4) Count Words
 5) Deque Lists
 6) Echo Client/Server
 7) Exceptions
 8) Fannkuch
 9) Fibonacci Numbers
10) Hash Access
11) Hash Update
12) Heap Sort
13) Matrix Multiplication
14) Method Calls
15) Nested Loops
16) Nsieve
17) Object Instantiation
18) Prime
19) Random Numbers
20) Regular Expressions
21) Reverse a File
22) Spell Checker
23) Startup
24) Statistical Moments
25) Sum a File of Numbers
26) Synchronize
27) Takfp
28) Word Frequency

---------------------------------------------------------------------
;;
;; Ackermann's Function
;; by Brent Fulgham
;;

(define (ack m n)
    (cond ((= m 0) (+ n 1))
          ((= n 0) (ack (- m 1) 1))
	  (true    (ack (- m 1) (ack m (- n 1))))))

(define (main)
    (set 'N (integer (last (main-args))))
    (println
        (format "Ack(3,%d): %d" N (ack 3 N))))

---------------------------------------------------------------------
;;
;; Array Access
;; (requires newLISP 9.0)
;;

(define (main)
	(set 'n (integer (main-args 2)))
	(set 'x (array n (sequence 1 n)))
	(set 'y (array n '(0)))
	(dotimes (k 1000)
		(for (i (- n 1) 0)
			(nth-set (y i) (+ (y i) (x i)) )))
	(println (y 0) " " (y (- n 1) )))

---------------------------------------------------------------------
;;
;; Concatenate Strings
;; (requires newLISP 8.3.0)
;;

(set 'n (integer (main-args 2)))
(set 'str "")
(dotimes (i n) (write-buffer str "hello\n"))
(println (length str))

---------------------------------------------------------------------
;;
;; Count Words
;;

(set 'lc 0 'wc 0 'cc 0)
(while (set 'line (read-line))
	(inc 'lc)
	(inc 'wc (length (parse (trim line) "\\s+" 0)))
	(inc 'cc (+ (length line) 1))) ;; add back the line feed
(println lc " " wc " " cc)

---------------------------------------------------------------------
;;
;; Deque Lists
;; (requires newLISP 8.3.0)
;; (mimics Python's way)
;;

(set 'SIZE 10000)
(define (test-lists)
	(set 'Li1  (sequence 1 SIZE))
	(set 'Li2 Li1)
	(set 'Li3 '())
	; remove each item from left of Li2 and append to Li3
	(reverse Li2)
	(while Li2 (push (pop Li2) Li3 -1))
	(while Li3 (push (pop Li3) Li2 -1))
	(reverse Li1)
	(if 	(!= (first Li1) SIZE) 0
		(= Li1 Li2) (length Li1)
		0))
(set 'n (integer (main-args 2)))
(dotimes (i n)
	(set 'result (test-lists)))
(println result)

---------------------------------------------------------------------
;;
;; Echo Client/Server
;; (requires newLISP 9.0.0)
;; do not work on Windows
;;

(set 'DATA "Hello there sailor\n");
(set 'bufferSize (length DATA))
(define (server port)
	(set 'listen (net-listen port))
	(set 'connection (net-accept listen))
	(set 'N 0)
	(while (net-receive connection 'buff bufferSize)
		(inc 'N (length buff))
		(net-send connection buff))
	(net-close connection)
	(net-close listen)
	(println "server processed " N " bytes"))

(define (client port n)
	(set 'connection (net-connect "127.0.0.1" port))
	(dotimes (x n)
		(net-send connection DATA)
		(net-receive connection 'buff bufferSize)
		(if (!= buff DATA) (println "Received different message: " buff)))
	(net-close connection))

(set 'n (integer (main-args 2)))

(fork (server 100001))
(sleep 100)
(client 100001 n)

---------------------------------------------------------------------
;;
;; Exceptions
;; (requires newLISP 7.5.1)
;;

(context 'MAIN)

(set 'HI 0 'LO 0)

(define (some_function num)
	(catch (hi_function num) 'result)
	(if (not (integer? result))
		(println "we never get here")))

(define (hi_function num)
	(catch (lo_function num) 'result)
	(if (= result 'HI_exception)
		(inc 'HI)
		(throw result)))

(define (lo_function num)
	(catch (blowup num) 'result)
	(if (= result 'LO_exception)
		(inc 'LO)
		(throw result)))

(define (blowup num)
	(if (= (& num 1) 1)
		(throw 'HI_exception)
		(throw 'LO_exception)))

(define (main)
	(dotimes (i n)
		(some_function i))
	(println "Exceptions: HI=" HI " / LO=" LO))

(set 'n (integer (nth 2 (main-args))))

(main)

---------------------------------------------------------------------
;;
;; Fannkuch 9.0
;; by Lutz Mueller 2004-12-11
;;

(define MaxCount 0)

(define (permute left right)
    (let (j (length right))
        (if (< j 2)
            (permCount (append left right))
            (dotimes (i j)
                (permute (append left (slice right i 1))
                         (append (slice right 0 i) (slice right (+ i 1))))))))

(define (permCount perm , myCount perm0)
        (set 'myCount 0)
        (while (!= (set 'perm0 (first perm)) 1)
            (inc 'myCount)
            (set 'perm (append (reverse (slice perm 0 perm0)) (slice perm perm0))))
        (if (> myCount MaxCount) (set 'MaxCount myCount)))

(define (fannkuch n)
    (permute '() (sequence 1 n))
    MaxCount)

(define (main)
    (set 'n (integer (main-args 2)))
    (println (format "Pfannkuchen(%d) = %d" n (fannkuch n))))

(main)

---------------------------------------------------------------------
;;
;; Fibonacci Numbers
;;

(define (fibo n)
	(if(< n 2) 1
	(+  (fibo (- n 1))
	    (fibo (- n 2)))))

(println (fibo (integer (main-args 2))))

---------------------------------------------------------------------
;;
;; Hash Access
;; create i = 1..n symbols with value i
;; count all exsiting symbols in reverse
;;
;; newLISP does not have hashtables but can
;; simulate hashes with symbols
;;

(context 'HASH) ; create hash container
(context 'MAIN) ; go back to MAIN context

(set 'n (integer (main-args 2)))

(for (i 1 n)
	(set (sym (format "_%x" i) HASH) i) )

(set 'cnt 0)
(for (i n 1)
	(if (sym (format "_%d"  i) HASH nil) (inc 'cnt)))

(println cnt)

---------------------------------------------------------------------
;;
;; Hash update
;;
;; newLISP does not have hashtables but can
;; simulate hashes efficient with symbols
;;

(context 'Hash1) ; create hash container
(context 'MAIN) ; go back to MAIN context
(context 'Hash2) ; create hash container
(context 'MAIN) ; go back to MAIN context

(set 'n (integer (main-args 2)))

(dotimes (i 10000)
	(set (sym (format "foo_%d" i) Hash1) i) )

(dotimes (i n)
	(dotree (k Hash1)
		(set 'key (sym (name k) Hash2 nil))
		(if key
			(inc key (eval k))
			(set (sym (name k) Hash2) (eval k)))))

(println Hash1:foo_1 " " Hash1:foo_9999 " " Hash2:foo_1 " " Hash2:foo_9999)

---------------------------------------------------------------------
;;
;; Heap Sort
;;
;; newLISP has fast built-in sort and random algorithms
;; not used in this benchmark
;;

(set 'IM 139968)
(set 'IA 3877)
(set 'IC 29573)

(set 'LAST 42)

(define (gen_random maximum)
	(set 'LAST (mod (add (mul LAST IA) IC) IM))
	(div (mul maximum LAST) IM))

(define (heapsort n ra)
	(set 'rra 0 'i 0 'j 0)
	(set 'l (+ (>> n 1) 1))
	(set 'ir n)

	(while (not done)
		(if (> l 1)
			(begin
				(dec 'l)
				(set 'rra (ra l)))
			(begin
				(set 'rra (ra ir))
				(nth-set ir ra (ra 1))
				(dec 'ir)
				(if (= ir 1)
					(begin
						(nth-set (ra 1) rra)
						(set 'done true)
						; return
						ra))))
		(set 'i l)
		(set 'j (<< l 1))
		(if (not done) (begin
			(while (<= j ir)
				(if (and (< j ir) (< (ra j) (ra (+ j 1))))
					(inc ' j))
				(if (< rra (ra j))
					(begin
						(nth-set (ra i) (ra j))
						(set 'i j)
						(inc 'j i))
					(set 'j (+ ir 1))))
			(nth-set (ra i) rra))
		) ra))

(define (main)
	(set 'N (integer (last (main-args))))

	(set 'ary (array (+ N 1)))

	(for (i 1 N) (nth-set (ary i) (gen_random 1.0)))

	(set 'ary (heapsort N ary))

	(println (format "%.10f" (ary N)))
)

(main)

---------------------------------------------------------------------
;;
;; Matrix Multiplication
;; since version 9.0 matrix finctions can also be used
;; on array types, additionally to lists.
;;

(set 'size 30)

(define (mkmatrix rows cols)
 	(map (fn (i) (sequence (+ (* i cols) 1)  (+ (* i cols) cols))) (sequence 0 (- rows 1))))

(define (main n)
	(set 'm1 (mkmatrix size size))
	(set 'm2 m1)
	(dotimes (i n)
		(set 'm3 (multiply m1 m2)))
	(println (m3 0 0) " " (m3 2 3) " " (m3 3 2) " " (m3 4 4)))

(set 'n (integer (main-args 2)))

(main n)

---------------------------------------------------------------------
;;
;; Method Calls
;;
;; this is almost identical Object Instantiation
;; but here method call is measured instead of
;; object creation/instantiation
;;

; define class Toggle

(context 'Toggle)

(define (init start_state)
	(set 'bool start_state))

(define (value)
	bool)

(define (activate)
	(set 'bool (not bool)))

(context 'MAIN)

; subclass Toggle to NthToggle and overwrite methods

(new Toggle 'NthToggle)

(context NthToggle)

(define (init start_state max_counter)
	(set 'bool start_state)
	(set 'count_max max_counter)
	(set 'counter 0))

(define (activate)
	(inc 'counter)
	(if (>= counter count_max)
		(begin
			(set 'bool (not bool))
			(set 'counter 0))
                counter ))

(context 'MAIN)

; Method calls
; get n from command line

(set 'n (integer (main-args 2)))

(define (main)
	(new Toggle 'toggle)
	(toggle:init true)

	(dotimes (x n)
		(toggle:activate)
		(set 'val toggle:value))

	(if (toggle:value) (println "true") (println "false"))

	(new NthToggle 'ntoggle)
	(ntoggle:init true 3)

	(dotimes (x n)
		(ntoggle:activate)
		(set 'val ntoggle:value))

	(if (ntoggle:value) (println "true") (println "false"))
	)

(main)

---------------------------------------------------------------------
;;
;; Nested Loops
;;
;; newLISP also has a 'for' which takes an initializer
;; for the looping variable and is a bit slower
;;

(set 'n (integer (main-args 2)))
(set 'x 0)
(dotimes (a n)
	(dotimes (b n)
		(dotimes (c n)
			(dotimes (d n)
				(dotimes (e n)
					(dotimes (f n)
						(inc 'x)))))))
(println x)

(set 'n (integer (main-args 2)))
(set 'x 0)
(for (a 1 n)
	(for (b 1 n)
		(for (c 1 n)
			(for (d 1 n)
				(for (e 1 n)
					(for (f 1 n)
						(inc 'x)))))))
(println x)

---------------------------------------------------------------------
;;
;; Nsieve
;;
;; by Lutz Mueller 2004-12-11
;;
;; A solution with a newLISP array for flags is about the same
;; speed but uses much more memory. Here a character vector is
;; manipulated directly.
;;

(define (nsieve m f, cnt)
	(set 'cnt 0)

        (for (i 2 m)
            (if (= (char f:isPrime i) 1)
                (begin
                    (set 'k (+ i i))
                    (while (<= k m)
                        (cpymem "\000" (+ k (address f:isPrime)) 1)
                        (inc 'k i))
	        (inc 'cnt))))
         cnt)

(define (main)
    (set 'n (integer (main-args 2)))

    (set 'm (* (pow 2 n) 10000))
    (set 'flags:isPrime (dup "\001" (+ m 1) ))

    (println (format "Primes up to %8d%8d" m (nsieve m flags)))

    (set 'm (* (pow 2 (- n 1)) 10000))
    (println (format "Primes up to %8d%8d" m (nsieve m flags)))

    (set 'm (* (pow 2 (- n 2)) 10000))
    (println (format "Primes up to %8d%8d" m (nsieve m flags)))
    )

(main)

---------------------------------------------------------------------
;;
;; Object Instantiation
;;

; define class Toggle

(context 'Toggle)

(define (init start_state)
	(set 'bool start_state))

(define (value)
	bool)

(define (activate)
	(set 'bool (not bool)))

(context 'MAIN)

; subclass Toggle to NthToggle and overwrite methods

(new Toggle 'NthToggle)

(context NthToggle)

(define (init start_state max_counter)
	(set 'bool start_state)
	(set 'count_max max_counter)
	(set 'counter 0))

(define (activate)
	(inc 'counter)
	(if (>= counter count_max)
		(begin
			(set 'bool (not bool))
			(set 'counter 0))
                counter ))

(context 'MAIN)

; get n from command line

(set 'n (integer (main-args 2)))

(define (main)
	(new Toggle 'toggle)
	(toggle:init true)

	(dotimes (x 5)
		(toggle:activate)
		(if (toggle:value) (println "true") (println "false")))

	(dotimes (x n)
		(new Toggle 'toggle)
		(toggle:init true))

	(println)

	(new NthToggle 'ntoggle)
	(ntoggle:init true 3)

	(dotimes (x 8)
		(ntoggle:activate)
		(if (ntoggle:value) (println "true") (println "false")))

	(dotimes (x n)
		(new NthToggle 'ntoggle)
		(ntoggle:init true 3))
	)

(main)

---------------------------------------------------------------------
;;
;; Prime
;; (requires newLISP 7.5.2)
;;

(define (main)
	(set 'NUM (integer (main-args 2)))

	(dotimes (p NUM)
		(set 'flags (array 8193 '(1)))
		(set 'cnt 0)

		(for (i 2 8192)
			(if (= (nth i flags) 1)
				(begin
					(set 'k (+ i i))
					(while (<= k 8192)
						(nth-set k flags 0)
						(inc 'k i))
					(inc 'cnt)))))

	(println "Count: " cnt))

(main)

---------------------------------------------------------------------
;;
;; Random Numbers
;;
;; note, that newLISP has various fast built-in random
;; functions which are not used here
;;

(set 'IM 139968)
(set 'IA 3877)
(set 'IC 29573)

(set 'LAST 42)

(define (gen_random maximum)
	(set 'LAST (mod (add (mul LAST IA) IC) IM))
	(div (mul maximum LAST) IM))


(define (main)
	(set 'N (integer (main-args 2)))
	(dotimes (i (- N 1)) (gen_random 100.0))

	(println (format "%.9f" (gen_random 100.0))) )

(main)

---------------------------------------------------------------------
;;
;; Regular Expressions
;; get phone data from stdin
;;

(while (read-line) (push (append (current-line) "\n") phones))
(reverse phones)

;; patterns
(set 'pattern (append
    {(?:^|[^\d\(])}		; must be preceeded by non-digit
    {(\()?}				; match 1: possible initial left paren
    {(\d\d\d)}			; match 2: area code is 3 digits
    {(?(1)\))}			; if match1 then match right paren
    {[ ]}				; area code followed by one space
    {(\d\d\d)}			; match 3: prefix of 3 digits
    {[ -]}			      ; separator is either space or dash
    {(\d\d\d\d)}			; match 4: last 4 digits
    {\D}				; must be followed by a non-digit
))

;; get N
(set 'N (integer (last (main-args))))
(set 'cnt 0)

(dotimes (i N)
  (dolist (phone phones)
    (if (regex pattern phone)
        (if (= i 0)
          (begin
            (inc 'cnt)
            (println (string cnt ": (" $2 ") " $3 "-" $4)))))))

---------------------------------------------------------------------
;;
;; Reverse a File
;;

(while (read-line) (push (current-line) file))
(println (join file "\n"))

---------------------------------------------------------------------
;;
;; Spell Checker
;; (requires newLISP 8.3.0)

(context 'MAIN)

(define (main)
	(set 'infile (open "Usr.Dict.Words" "read"))
	(while (set 'word (read-line infile))
		(sym word 'Dictionary))
	(close infile)

	(while (set 'word (read-line))
		(if (not (sym word 'Dictionary nil))
			(println word))))

(main)

---------------------------------------------------------------------
;;
;; Startup
;;

(println "Hello World")

---------------------------------------------------------------------
;;
;; Statistical Moments
;; read file filter empty lines
;;

(define (main)
  (while (read-line) (push (float (current-line)) nums))
  (set 'nums (reverse (filter float? nums)))
  (set 'n (length nums))
  (set 'sum (apply add nums))
  (set 'mean (div sum n))
  (set 'avg-dev 0 'std-dev 0 'var 0 'skew 0 'kurtosis 0)
  (set 'dev (map sub nums (dup mean n)))
  (set 'avg-dev (div (apply add (map abs dev)) n))
  (set 'var (div (apply add (map mul dev dev)) (- n 1)))
  (set 'skew (apply add (map mul dev dev dev)))
  (set 'kurtosis (apply add (map  mul dev dev dev dev)))
  (set 'std-dev (sqrt var))
  (if (> var 0.0)
    (begin
	(set 'skew (div skew (mul n var std-dev)))
	(set 'kurtosis (sub (div kurtosis (mul n var var)) 3.0))))
  (sort nums)
  (set 'mid (/ n 2))
  (if (= 0 (% n 2))
	(set 'median (div (add (nums mid) (nums (- mid 1))) 2))
	(set 'median (nums mid)))
  (println (format "n:                  %d" n))
  (println (format "median:             %f" median))
  (println (format "mean:               %f" mean))
  (println (format "average_deviation:  %f" avg-dev))
  (println (format "standard_deviation: %f" std-dev))
  (println (format "variance:           %f" var))
  (println (format "skew:               %f" skew))
  (println (format "kurtosis:           %f" kurtosis))
)

(main)

---------------------------------------------------------------------
;;
;; Sum a File of Numbers
;;

(set 'sum 0)
(while (read-line) (inc 'sum (integer (current-line))))
(println sum)

---------------------------------------------------------------------
;;
;; Synchronize
;; producer/consumer
;; (requires newLISP 8.3.0)
;; Note that newLISP does not use Pthreads,
;; but classic UNIX/fork() processes
;; therefore no mutexes amd condition variables,
;; but semaphores and shared memory
;;

(constant 'wait -1 'sig 1)

(define (consumer n)
	(set 'i 0)
	(while (< i n)
		(semaphore cons-sem wait)
		(set 'i (share data))
		(share consumed (+ (share consumed) 1))
		(semaphore prod-sem sig))
	(exit))

(define (producer n)
	(for (i 1 n)
		(semaphore prod-sem wait)
		(share data i)
		(share produced (+ (share produced) 1))
		(semaphore cons-sem sig))
	(exit))

(define (main n)
	(set 'produced (share)) ; get shared mem addresses
	(set 'consumed (share))
	(set 'data (share))

	(share produced 0) ; init shared memory
	(share consumed 0)
	(share data 0)

	(set 'prod-sem (semaphore)) ; get semaphores
	(set 'cons-sem (semaphore))

	(set 'prod-pid (fork (producer n))) ; start processes
	(set 'cons-pid (fork (consumer n)))
	(semaphore prod-sem sig) ; get producer started

	(wait-pid prod-pid) ; wait for processe to finish
	(wait-pid cons-pid)
	(semaphore cons-sem 0) ; release semaphore
	(semaphore prod-sem 0) ; release semaphore

	(println (share produced) " " (share consumed)))

(main (integer (last (main-args))))

(exit)

---------------------------------------------------------------------
;;
;; -*- mode: lisp -*-
;; $Id: takfp-newlisp.code,v 1.1 2004/12/05 21:22:46 bfulgham Exp $
;; http://shootout.alioth.debian.org/
;; Contributed by Brent Fulgham
;; changes L.M. 2004/12/13
;;

;;; switch int-ops to float-ops
(constant '- sub '* mul)

(define (tak x y z)
  (if (>= y x)
      z
      (tak (tak (- x 1) y z) (tak (- y 1) z x) (tak (- z 1) x y))))

(define (main)
  (set 'n (integer (last (main-args))))
  (println
    (format "%.1f" (tak (* n 3.0) (* n 2.0) (* n 1.0) ))))

(main)

---------------------------------------------------------------------
;;
;; Word Frequency
;; create a context/namespace to hold words
;; since version 8.8 newLISP has a built in function
;; bayes-query, which will do the counting in just
;; one statement and much faster
;;

(context 'wc)
(context MAIN)

(define (main)
;;	(HASH:make 'wc)
	(while (read-line)
		(set 'data (parse (lower-case (current-line)) "[^a-z]+" 0))
		(dolist (w data)
			(if (set 'result (eval (symbol (append "_" w) wc) ))
				(set (symbol (append "_" w) wc) (+ result 1))
				(set (symbol (append "_" w) wc) 1))))
	(dolist (w (symbols wc))
		(set 'wrd (name w))
		(if (and (starts-with wrd "_") (!= "_" wrd))
			(push (list (eval w) (slice wrd 1) ) words) ))
	(dolist (w (reverse (sort words)))
		(println (format "%7d %s" (first w) (last w))))
	)

(main)

---------------------------------------------------------------------


============================================================================
Frasi Famose sulla Programmazione e sul Linguaggio Lisp
============================================================================

"Programs must be written for people to read, and only incidentally for machines to execute."
- Abelson & Sussman, SICP, preface to the first edition

"Lisp is a programmable programming language."
- John Foderaro, CACM, September 1991

"Lisp is worth learning for the profound enlightenment experience you will have when you finally get it; that experience will make you a better programmer for the rest of your days, even if you never actually use Lisp itself a lot."
- Eric Raymond, "How to Become a Hacker"

"Lisp has jokingly been called: 'the most intelligent way to misuse a computer'. I think that description is a great compliment because it transmits the full flavor of liberation: it has assisted a number of our most gifted fellow humans in thinking previously impossible thoughts."
- Edsger Dijkstra, CACM, 15:10

"Lisp isn't a language, it's a building material."
- Alan Kay

"Lisp was far more powerful and flexible than any other language of its day; in fact, it is still a better design than most languages of today, twenty-five years later. Lisp freed ITS's hackers to think in unusual and creative ways. It was a major factor in their successes, and remains one of hackerdom's favorite languages."
- Eric Raymond, in "Open Sources: Voices from the Open Source Revolution", 1999

"I suppose I should learn Lisp, but it seems so foreign."
- Paul Graham, Nov 1983

"The only way to learn a new programming language is by writing programs in it."
- Kernighan and Ritchie

"Most languages in computer science describe how their author learned what someone else already developed."
- unknown

"It is better to first strive for clarity and correctness and to make programs efficient only if really needed."
- "Getting Started with Erlang" by Ericsson

"Rules of optimization: Rule #1: Don't do it. Rule #2 (for experts only): Don't do it yet."
- Michael A. Jackson

"Cavemen in bearskins invaded the ivory towers of Artificial Intelligence. Nine months later, they left with a baby named newLISP. The women of the ivory towers wept and wailed. 'Abomination!' they cried."
- TedWalther

"On every new project/problem, newLISP behave like a chameleon. It changed to a new language (of the Lisp-family) for solving that problem."
- Hans-Peter

"All profound and true things are simple. Complexity is vanity."
- Lutz Mueller  (creator of newLISP)

"It pays to know the dark corners of your language."
- unknown

"Learning from your mistakes is one of the best ways to learn."
- unknown

" The secret to creativity is knowing how to hide your sources."
- Albert Einstein


============================================================================
Codice ASCII
============================================================================
L'American Standard Code for Information Interchange, o codice ASCII, è stato creato nel 1963 dal Comitato "American Standards Association" o "ASA", l'agenzia ha cambiato il suo nome nel 1969 in "American National Standards Institute" o "ANSI" così com'è conosciuto da allora.
Questo codice nasce dal riordino e dall'espansione del set di simboli e caratteri già utilizzati in telegrafia a quel tempo dalla società Bell.
All'inizio includeva solo lettere maiuscole e numeri, ma nel 1967 furono aggiunte le lettere minuscole e alcuni caratteri di controllo, formando ciò che è noto come US-ASCII, cioè i caratteri da 0 a 127.
Quindi con questo set di soli 128 caratteri è stato pubblicato nel 1967 come standard, contenente tutto il necessario per scrivere in lingua inglese.
Nel 1981 IBM sviluppò un'estensione del codice ASCII a 8 bit, chiamata "code page 437", in questa versione furono sostituiti alcuni caratteri di controllo obsoleti con i caratteri grafici. Inoltre sono stati aggiunti 128 caratteri, con nuovi simboli, segni, grafici e lettere latine, tutti i segni di punteggiatura e i caratteri necessari per scrivere testi in altre lingue, come lo spagnolo. In questo modo sono stati aggiunti i caratteri ASCII compresi tra 128 e 255.
IBM include il supporto per questa tabella codici nell'hardware del suo modello 5150, noto come "IBM-PC", considerato il primo personal computer. Anche il sistema operativo di questo modello, "MS-DOS", utilizzava questo codice ASCII esteso.
Quasi tutti i sistemi informatici di oggi utilizzano il codice ASCII per rappresentare caratteri e testi.

ASCII control characters
-------------------------------------------
00   |   NULL   |  (Null character)       |
01   |   SOH    |  (Start of Header)      |
02   |   STX    |  (Start of Text)        |
03   |   ETX    |  (End of Text)          |
04   |   EOT    |  (End of Trans.)        |
05   |   ENQ    |  (Enquiry)              |
06   |   ACK    |  (Acknowledgement)      |
07   |   BEL    |  (Bell)                 |
08   |   BS     |  (Backspace)            |
09   |   HT     |  (Horizontal Tab)       |
10   |   LF     |  (Line feed)            |
11   |   VT     |  (Vertical Tab)         |
12   |   FF     |  (Form feed)            |
13   |   CR     |  (Carriage return)      |
14   |   SO     |  (Shift Out)            |
15   |   SI     |  (Shift In)             |
16   |   DLE    |  (Data link escape)     |
17   |   DC1    |  (Device control 1)     |
18   |   DC2    |  (Device control 2)     |
19   |   DC3    |  (Device control 3)     |
20   |   DC4    |  (Device control 4)     |
21   |   NAK    |  (Negative acknowl.)    |
22   |   SYN    |  (Synchronous idle)     |
23   |   ETB    |  (End of trans. block)  |
24   |   CAN    |  (Cancel)               |
25   |   EM     |  (End of medium)        |
26   |   SUB    |  (Substitute)           |
27   |   ESC    |  (Escape)               |
28   |   FS     |  (File separator)       |
29   |   GS     |  (Group separator)      |
30   |   RS     |  (Record separator)     |
31   |   US     |  (Unit separator)       |
127  |   DEL    |  (Delete)               |

ASCII printable characters
------------------------------------------
|  32  | space |  64  |  @  |  96  |  `  |
|  33  |   !   |  65  |  A  |  97  |  a  |
|  34  |   "   |  66  |  B  |  98  |  b  |
|  35  |   #   |  67  |  C  |  99  |  c  |
|  36  |   $   |  68  |  D  |  100 |  d  |
|  37  |   %   |  69  |  E  |  101 |  e  |
|  38  |   &   |  70  |  F  |  102 |  f  |
|  39  |   '   |  71  |  G  |  103 |  g  |
|  40  |   (   |  72  |  H  |  104 |  h  |
|  41  |   )   |  73  |  I  |  105 |  i  |
|  42  |   *   |  74  |  J  |  106 |  j  |
|  43  |   +   |  75  |  K  |  107 |  k  |
|  44  |   ,   |  76  |  L  |  108 |  l  |
|  45  |   -   |  77  |  M  |  109 |  m  |
|  46  |   .   |  78  |  N  |  110 |  n  |
|  47  |   /   |  79  |  O  |  111 |  o  |
|  48  |   0   |  80  |  P  |  112 |  p  |
|  49  |   1   |  81  |  Q  |  113 |  q  |
|  50  |   2   |  82  |  R  |  114 |  r  |
|  51  |   3   |  83  |  S  |  115 |  s  |
|  52  |   4   |  84  |  T  |  116 |  t  |
|  53  |   5   |  85  |  U  |  117 |  u  |
|  54  |   6   |  86  |  V  |  118 |  v  |
|  55  |   7   |  87  |  W  |  119 |  w  |
|  56  |   8   |  88  |  X  |  120 |  x  |
|  57  |   9   |  89  |  Y  |  121 |  y  |
|  58  |   :   |  90  |  Z  |  122 |  z  |
|  59  |   ;   |  91  |  [  |  123 |  {  |
|  60  |   <   |  92  |  \  |  124 |  |  |
|  61  |   =   |  93  |  ]  |  125 |  }  |
|  62  |   >   |  94  |  ^  |  126 |  ~  |
|  63  |   ?   |  95  |  _  |

Extended ASCII characters
--------------------------------------------
|  128  |  Ç  |  171  |  ½  |  214  |   Í  |
|  129  |  ü  |  172  |  ¼  |  215  |   Î  |
|  130  |  é  |  173  |  ¡  |  216  |   Ï  |
|  131  |  â  |  174  |  «  |  217  |   ┘  |
|  132  |  ä  |  175  |  »  |  218  |   ┌  |
|  133  |  à  |  176  |  ░  |  219  |   █  |
|  134  |  å  |  177  |  ▒  |  220  |   ▄  |
|  135  |  ç  |  178  |  ▓  |  221  |   ¦  |
|  136  |  ê  |  179  |  │  |  222  |   Ì  |
|  137  |  ë  |  180  |  ┤  |  223  |   ▀  |
|  138  |  è  |  181  |  Á  |  224  |   Ó  |
|  139  |  ï  |  182  |  Â  |  225  |   ß  |
|  140  |  î  |  183  |  À  |  226  |   Ô  |
|  141  |  ì  |  184  |  ©  |  227  |   Ò  |
|  142  |  Ä  |  185  |  ╣  |  228  |   õ  |
|  143  |  Å  |  186  |  ║  |  229  |   Õ  |
|  144  |  É  |  187  |  ╗  |  230  |   µ  |
|  145  |  æ  |  188  |  ╝  |  231  |   þ  |
|  146  |  Æ  |  189  |  ¢  |  232  |   Þ  |
|  147  |  ô  |  190  |  ¥  |  233  |   Ú  |
|  148  |  ö  |  191  |  ┐  |  234  |   Û  |
|  149  |  ò  |  192  |  └  |  235  |   Ù  |
|  150  |  û  |  193  |  ┴  |  236  |   ý  |
|  151  |  ù  |  194  |  ┬  |  237  |   Ý  |
|  152  |  ÿ  |  195  |  ├  |  238  |   ¯  |
|  153  |  Ö  |  196  |  ─  |  239  |   ´  |
|  154  |  Ü  |  197  |  ┼  |  240  |   ≡  |
|  155  |  ø  |  198  |  ã  |  241  |   ±  |
|  156  |  £  |  199  |  Ã  |  242  |   ‗  |
|  157  |  Ø  |  200  |  ╚  |  243  |   ¾  |
|  158  |  ×  |  201  |  ╔  |  244  |   ¶  |
|  159  |  ƒ  |  202  |  ╩  |  245  |   §  |
|  160  |  á  |  203  |  ╦  |  246  |   ÷  |
|  161  |  í  |  204  |  ╠  |  247  |   ¸  |
|  162  |  ó  |  205  |  ═  |  248  |   °  |
|  163  |  ú  |  206  |  ╬  |  249  |   ¨  |
|  164  |  ñ  |  207  |  ¤  |  250  |   ·  |
|  165  |  Ñ  |  208  |  ð  |  251  |   ¹  |
|  166  |  ª  |  209  |  Ð  |  252  |   ³  |
|  167  |  º  |  210  |  Ê  |  253  |   ²  |
|  168  |  ¿  |  211  |  Ë  |  254  |   ■  |
|  169  |  ®  |  212  |  È  |  255  | nbsp |
|  170  |  ¬  |  213  |  ı  |

Print characters in Windows
---------------------------

Vowels grave accent      Vowels acute accent      Vowels with diaresis
---------------------    ---------------------    ---------------------
|  à  |  alt + 133  |    |  á  |  alt + 160  |    |  ä  |  alt + 132  |
|  è  |  alt + 138  |    |  é  |  alt + 130  |    |  ë  |  alt + 137  |
|  ì  |  alt + 141  |    |  í  |  alt + 161  |    |  ï  |  alt + 139  |
|  ò  |  alt + 149  |    |  ó  |  alt + 162  |    |  ö  |  alt + 148  |
|  ù  |  alt + 151  |    |  ú  |  alt + 163  |    |  ü  |  alt + 129  |
|  À  |  alt + 0192 |    |  Á  |  alt + 181  |    |  Ä  |  alt + 142  |
|  È  |  alt + 0200 |    |  É  |  alt + 144  |    |  Ë  |  alt + 211  |
|  Ì  |  alt + 0204 |    |  Í  |  alt + 214  |    |  Ï  |  alt + 216  |
|  Ò  |  alt + 0210 |    |  Ó  |  alt + 224  |    |  Ö  |  alt + 153  |
|  Ù  |  alt + 0217 |    |  Ú  |  alt + 233  |    |  Ü  |  alt + 154  |

Mathematical symbols     Commercial symbols       Quotes and parenthesis
---------------------    ---------------------    ----------------------
|  ½  |  alt + 171  |    |  @  |  alt + 64   |    |  "  |  alt + 34   |
|  ¼  |  alt + 172  |    |  $  |  alt + 36   |    |  '  |  alt + 39   |
|  ¾  |  alt + 243  |    |  £  |  alt + 156  |    |  (  |  alt + 40   |
|  ¹  |  alt + 251  |    |  ¥  |  alt + 190  |    |  )  |  alt + 41   |
|  ³  |  alt + 252  |    |  ¢  |  alt + 189  |    |  [  |  alt + 91   |
|  ²  |  alt + 253  |    |  ¤  |  alt + 207  |    |  ]  |  alt + 93   |
|  ƒ  |  alt + 159  |    |  ®  |  alt + 169  |    |  {  |  alt + 123  |
|  ±  |  alt + 241  |    |  ©  |  alt + 184  |    |  }  |  alt + 125  |
|  ×  |  alt + 158  |    |  ª  |  alt + 166  |    |  «  |  alt + 174  |
|  ÷  |  alt + 246  |    |  º  |  alt + 167  |    |  »  |  alt + 175  |
|  ≡  |  alt + 240  |    |  °  |  alt + 248  |


============================================================================
 TRUE? or NIL?
============================================================================

Non sei roba tua
Non sei il tuo lavoro
Non sei il tuo patrimonio
Non sei i tuoi successi
Non sei la tua età
Non sei la tua salute
Non sei il tuo corpo
Non sei le tue opinioni
Non sei la tua conoscenza
Non sei i tuoi ricordi
Non sei i tuoi pensieri
Non sei le tue emozioni
Non sei la tua personalità
Non sei quello che pensi di essere...

=============================================================================

====================

 BIBLIOGRAFIA / WEB

====================

  Documentazione ufficiale:
  http://www.newLISP.org/index.cgi?Documentation

  Tutorial "Introduction to newLISP" su WikiBooks:
  http://en.wikibooks.org/wiki/Introduction_to_newLISP

  "newLISP in 21 minutes" di John W. Small
  http://www.newLISP.org/newLISP_in_21_minutes.html

  Forum ufficiale di newLISP
  http://www.newLISPfanclub.alh.net/forum/

  Johu's Blog
  https://johu02.wordpress.com/

  Cormullion's Blog
  https://newLISPer.wordpress.com/

  Kazimir Majorinc's Blog
  http://kazimirmajorinc.com/

  "A Practical Introduction to Fuzzy Logic using Lisp", Luis Arguelles Mendez, 2015

  Informazioni sui numeri Floating Point:
  https://floating-point-gui.de
  http://pages.cs.wisc.edu/~david/courses/cs552/S12/handouts/goldberg-floating-point.pdf

  "Numerical Computing with IEEE Floating Point Arithmetic", Michael Overton

  "Handbook of Floating-Point Arithmetic" AA.VV.

  Articoli su newLISP:
  "Crawler Tractor" di Kazimir Majorinc
  http://kazimirmajorinc.com/Documents/Crawler-tractor/index.html

  "newLISP - Lisp for the masses" di Krzysztof Kliś
  https://weblambdazero.blogspot.com/2010/06/newLISP-lisp-for-masses.html

  "Advanced Recursion in newLISP" di Krzysztof Kliś
  https://weblambdazero.blogspot.com/2010/07/advanced-recursion-in-newLISP.html

  "The Art of Computer Programming", Donald Knuth, 4 volumi, 1968..2015

  "Introduction to Algorithms", Cormen-Leiserson-Rivest-Stein, 3ed, 2009

  "Algorithms", Sedgewick-Wayne, 4ed, 2011

  "Teoria e Progetto di Algoritmi Fondamentali", Ausiello-Marchetti-Spaccamela-Protasi, 1985

  "Primality Testing in Polynomial Time" di Martin Dietzfelbinger, 2004

  "Land of Lisp", Conrad Barsky, 2011

  "Structure and Interpretation of Computer Programs", Abelson-Sussman, 2ed, 1996

  "Numerical Recipes in C: The Art of Scientific Computing", 2ed, Press-Teukolsky-Vetterling-Flannery

  "Il Libro dei Numeri" di Conway-Guy, 1999
  
  "Winning Ways for Your Mathematical Plays: Volume 1", Berlekamp-Conway-Guy
  "Winning Ways for Your Mathematical Plays: Volume 2", Berlekamp-Conway-Guy
  "Winning Ways for Your Mathematical Plays: Volume 3", Berlekamp-Conway-Guy
  "Winning Ways for Your Mathematical Plays: Volume 4", Berlekamp-Conway-Guy

  "Special Forms in Lisp" Kent Pitman, Conference Record of the 1980 Lisp Conference, Stanford University, August 25-27, 1980
  http://www.nhplace.com/kent/Papers/Special-Forms.html

  Cut-the-knot è un sito web dedicato alla divulgazione di una grande varietà di argomenti matematici amministrato da Alexander Bogomolny fino alla sua scomparsa l'8 luglio 2018
  https://www.cut-the-knot.org/

  Computer e Matematica:
  https://www.nayuki.io

  Mathematica on-line:
  https://www.wolframalpha.com

  La più grande risorsa sulla matematica nel web
  https://mathworld.wolfram.com/

  Enciclopedia on-line delle sequenze dei numeri interi:
  https://oeis.org

  StackOverflow è una sito web in cui studenti e professionisti inviano richieste e rispondono a domande sulla programmazione:
  https://stackoverflow.com

  Mathematics Stack Exchange è un sito di domande e risposte per persone che studiano matematica a qualsiasi livello.
  https://math.stackexchange.com/

  Enciclopedia libera:
  https://www.wikipedia.org/

  Programming Praxis - La programmazione, come qualsiasi attività creativa, richiede costante studio e pratica:
  https://programmingpraxis.com/

  LeetCode - La piattaforma leader nel mondo per l'apprendimento online della programmazione:
  https://leetcode.com/

  GeeksforGeeks - Un portale di computer science per "geeks"
  https://www.geeksforgeeks.org/

  MathBlog.dk è un blog che tratta la risoluzione di problemi di programmazione utilizzando la matematica
  https://www.mathblog.dk/

  Fermat's Library: a platform for illuminating academic papers. Publish an annotated paper every week.
  https://twitter.com/fermatslibrary?lang=en

  Search the history of over 468 billion web pages on the Internet.
  Internet Archive is a non-profit library of millions of free books, movies, software, music, websites, and more.
  https://archive.org/

=============================================================================

