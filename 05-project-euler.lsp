================

 PROJECT EULERO

================

                                Intel i5     Intel i7     Intel i7
  Problema    Soluzione         Tempo (msec) Tempo (msec) Tempo (msec)
                                Algorithm 1  Algorithm 1  Algorithm 2
|    1     |  233168            |         0  |         0  |         0  |
|    2     |  4613732           |         0  |         0  |         0  |
|    3     |  6857              |         0  |         0  |         0  |
|    4     |  906609            |       297  |       203  |         0  |
|    5     |  232792560         |         0  |         0  |         0  |
|    6     |  25164150          |         0  |         0  |         0  |
|    7     |  104743            |        78  |        31  |        16  |
|    8     |  23514624000       |       110  |        62  |         0  |
|    9     |  31875000          |        62  |        31  |         0  |
|    10    |  142913828         |      1563  |      1078  |       546  |
|    11    |  70600674          |         0  |         0  |         3  |
|    12    |  76576500          |      5445  |      4022  |         0  |
|    13    |  5537376230        |         0  |         0  |         -  |
|    14    |  837799            |     22487  |     15408  |      7563  |
|    15    |  137846528         |         0  |         0  |         0  |
|    16    |  1366              |         0  |         0  |        32  |
|    17    |  21124             |         0  |         0  |         -  |
|    18    |  1074              |        32  |         7  |         0  |
|    19    |  171               |         3  |         1  |         1  |
|    20    |  648               |         0  |         0  |         -  |
|    21    |  31626             |       220  |       134  |        87  |
<<<<<<< HEAD
|    22    |  871198282         |        20  |        10  |         -  |
|    23    |  4179871           |     40900  |     27534  |         -  |
|    24    |  278391546         |     25309  |     12282  |         -  |
|    25    |  4782              |      4926  |      3469  |         -  |
|    26    |  983               |       488  |       266  |         -  |
|    27    |  -59231            |      2000  |      1532  |         -  |
|    28    |  669171001         |         0  |         0  |         -  |
|    29    |  9183              |       141  |        94  |         -  |
|    30    |  443839            |       516  |       344  |         -  |
|    31    |  73682             |         1  |         0  |         -  |
|    32    |  45228             |      1625  |      1079  |         -  |
|    33    |  100               |         0  |         0  |         -  |
|    34    |  40730             |      3797  |      2625  |         -  |
|    35    |  55                |      1267  |       902  |         -  |
|    36    |  872187            |      1443  |       945  |         -  |
|    37    |  748317            |       778  |       651  |         -  |
|    38    |  932718654         |        94  |        48  |         -  |
|    39    |  840               |     13486  |      9561  |         -  |
|    40    |  210               |       141  |       433  |         -  |
|    41    |  7652413           |       125  |        64  |         -  |
|    42    |  162               |        31  |         4  |         -  |
|    43    |  16695334890       |      1749  |      1321  |         -  |
|    44    |  5482660           |      5589  |      4182  |         -  |
|    45    |  1533776805        |       115  |        63  |         -  |
|    46    |  5777              |        31  |         5  |         -  |
|    47    |  134043            |         0  |         0  |         -  |
|    48    |  9110846700        |       266  |       186  |         -  |
|    49    |  296962999629      |        19  |         5  |         -  |
|    50    |  997651            |     27113  |     18871  |         -  |
|    51    |  121313            |       269  |       180  |         -  |
|    52    |  142857            |       313  |       204  |         -  |
|    53    |  4075              |        25  |         5  |         -  |
|    54    |  376               |       154  |        91  |         -  |
|    55    |  249               |       116  |        69  |         -  |
|    56    |  972               |       186  |       119  |         -  |
|    57    |  153               |        10  |         1  |         -  |
|    58    |  26241             |       630  |       432  |         -  |
|    59    |  107359            |        15  |         1  |         -  |
|    60    |  26033             |     55055  |     38926  |         -  |
=======
|    22    |  871198282         |        20  |        10  |            |
|    23    |  4179871           |     40900  |     27534  |            |
|    24    |  278391546         |     25309  |     12282  |            |
|    25    |  4782              |      4926  |      3469  |            |
|    26    |  983               |       488  |       266  |            |
|    27    |  -59231            |      2000  |      1532  |            |
|    28    |  669171001         |         0  |         0  |            |
|    29    |  9183              |       141  |        94  |            |
|    30    |  443839            |       516  |       344  |            |
|    31    |  73682             |         1  |         0  |            |
|    32    |  45228             |      1625  |      1079  |            |
|    33    |  100               |         0  |         0  |            |
|    34    |  40730             |      3797  |      2625  |            |
|    35    |  55                |      1267  |       902  |            |
|    36    |  872187            |      1443  |       945  |            |
|    37    |  748317            |       778  |       651  |            |
|    38    |  932718654         |        94  |        48  |            |
|    39    |  840               |     13486  |      9561  |            |
|    40    |  210               |       141  |       433  |            |
|    41    |  7652413           |       125  |        64  |            |
|    42    |  162               |        31  |         4  |            |
|    43    |  16695334890       |      1749  |      1321  |            |
|    44    |  5482660           |      5589  |      4182  |            |
|    45    |  1533776805        |       115  |        63  |            |
|    46    |  5777              |        31  |         5  |            |
|    47    |  134043            |         0  |         0  |            |
|    48    |  9110846700        |       266  |       186  |            |
|    49    |  296962999629      |        19  |         5  |            |
|    50    |  997651            |     27113  |     18871  |            |
|    51    |  121313            |       269  |       180  |            |
|    52    |  142857            |       313  |       204  |            |
|    53    |  4075              |        25  |         5  |            |
|    54    |  376               |       154  |        91  |            |
|    55    |  249               |       116  |        69  |            |
|    56    |  972               |       186  |       119  |            |
|    57    |  153               |        10  |         1  |            |
|    58    |  26241             |       630  |       432  |            |
|    59    |  107359            |        15  |         1  |            |
|    60    |  26033             |     55055  |     38926  |            |
>>>>>>> f2acca20c0b15972390864b1078897d6e663f0b3
|    61    |  28684             |         -  |        85  |         -  |
|    62    |  127035954683      |         -  |      6348  |        83  |
|    63    |  49                |         -  |         0  |         0  |
|    64    |  1322              |         -  |        81  |         -  |
|    65    |  272               |         -  |         0  |         -  |
|    66    |  661               |         -  |         0  |         -  |
|    67    |  7273              |         -  |         1  |         -  |
|    68    |  6531031914842725  |         -  |        21  |         -  |
<<<<<<< HEAD
|    69    |  510510            |         -  |       642  |         -  |
=======
>>>>>>> f2acca20c0b15972390864b1078897d6e663f0b3
|    70    |  8319823           |         -  |      9621  |         7  |
|    71    |  428570            |         -  |       191  |         -  |
|    72    |  303963552391      |         -  |      2060  |         -  |
|    76    |  190569291         |         -  |         0  |         -  |
<<<<<<< HEAD
|    78    |  55374             |         -  |      7918  |         -  |
=======
>>>>>>> f2acca20c0b15972390864b1078897d6e663f0b3
|    87    |  1097343           |         -  |      1153  |         -  |
|    89    |  743               |         -  |         0  |         -  |
|    92    |  8581146           |         -  |     51582  |        16  |
|    96    |  24702             |         -  |     27084  |         -  |
|    97    |  8739992577        |         -  |       497  |         -  |
<<<<<<< HEAD
|    99    |  709               |         -  |         0  |         -  |
|   100    |  756872327473      |         -  |         0  |         -  |
=======
>>>>>>> f2acca20c0b15972390864b1078897d6e663f0b3

Sito web: https://projecteuler.net/archives

Cos'è Project Euler?
Project Euler è una serie di stimolanti problemi di programmazione matematica/informatica che richiedono molto più di semplici approfondimenti matematici per essere risolti. Sebbene la matematica aiuti ad arrivare a metodi eleganti ed efficienti, per risolvere la maggior parte dei problemi sarà necessario l'uso di un computer e competenze di programmazione.

La motivazione per l'avvio di Project Euler, e la sua continuazione, è di fornire una piattaforma per la mente indagatrice per addentrarsi in aree non familiari e apprendere nuovi concetti in un contesto divertente e ricreativo.

A chi sono rivolti i problemi?
Il pubblico previsto comprende studenti per i quali il curriculum di base non alimenta la loro fame per imparare, adulti il ​​cui background non era principalmente la matematica ma aveva un interesse per le cose matematiche, e professionisti che vogliono mantenere le loro capacità di solving e la matematica all'avanguardia.

Chiunque può risolvere i problemi?
I problemi sono di diversa difficoltà e per molti l'esperienza è l'apprendimento a catena induttivo. Cioè, risolvendo un problema ti esporrà ad un nuovo concetto che ti permette di intraprendere un problema precedentemente inaccessibile. Quindi il partecipante determinato lentamente ma sicuramente farà il suo lavoro attraverso ogni problema.

Cosa fare in seguito?
Per tenere traccia dei tuoi progressi è necessario impostare un account e abilitare i cookie. Se hai già un account puoi accedere senza problemi, altrimenti devi registrati - è completamente gratuito!

Tuttavia, poiché alcuni problemi sono difficili, potresti voler visualizzare i problemi prima di registrarti.

"Il progetto Eulero esiste per incoraggiare, sfidare e sviluppare le capacità e il divertimento di chiunque abbia un interesse per l'affascinante mondo della matematica."

Nota: i problemi devono essere risolti con la "regola del minuto", cioè i programmi devono trovare la soluzione entro un minuto.

In questo paragrafo affronteremo e risolveremo alcuni di questi problemi. Comunque prima di vedere la soluzione dovresti provare a risolverli per conto proprio in modo da migliorare le tue capacità di problem-solver e di programmatore.

Nota: La maggior parte delle soluzioni contiene una spiegazione dell'algoritmo utilizzato e alcuni problemi sono risolti con due algoritmi diversi. In genere il secondo algoritmo ha un approccio più matematico ed è più veloce.

Vengono prima presentate alcune funzioni comuni che servono per la soluzione di diversi problemi.

;=============================================
; (isprime? n)
; Controlla se n è un numero primo
; Non funziona con i big integer
; numero massimo (int64): 9223372036854775807
;=============================================
(define (isprime? n)
   (if (< n 2) nil
       (= 1 (length (factor n)))))
;=============================================

;=============================================
; (factor-group n)
; fattorizza il numero x raggruppando i termini uguali
; Non funziona con i big integer
; numero massimo (int64): 9223372036854775807
;=============================================
(define (factor-group x)
  (if (= x 1) '(1 1)
    (letn (fattori (factor x)
          unici (unique fattori))
      (transpose (list unici (count unici fattori)))
    )
  )
)

(factor-group 1)
;-> (1 1)

(factor-group 2000)
;-> ((2 4) (5 3))

(factor-group 232792560)
;-> ((2 4) (3 2) (5 1) (7 1) (11 1) (13 1) (17 1) (19 1))

E la funzione inversa a factor-group che genera il numero partendo dalla fattorizzazione:

(define (inv-factor-group lst)
      (apply * (map (lambda (x) (pow (first x) (last x))) lst))
)

(inv-factor-group (factor-group 232792560))
;-> 232792560

==========
Problema 1
==========

Multipli di 3 e di 5

Se elenchiamo i numeri sotto a 10 che sono multipli di 3 o di 5, otteniamo 3, 5, 6 e 9.
La loro somma vale 23.

Trova la somma di tutti i multipli di 3 o di 5 sotto a 1000.
============================================================================

La funzione "sequence" genera una lista di numeri:

(sequence 1 10)
;-> (1 2 3 4 5 6 7 8 9 10)

(sequence 1 10 2)
;-> (1 3 5 7 9)

Possiamo anche scrivere una funzione che si comporta come "sequence":

(define (seq start end (step 1))
  (cond ((= start end) (list end))
        ((> start end) '())
        (true (cons start (seq (+ start step) end step)))
  )
)

(seq 1 10)
;-> (1 2 3 4 5 6 7 8 9 10)

(seq 1 10 2)
;-> (1 3 5 7 9)

Un numero n è divisibile esattamente per m se risulta (n mod m == 0),
cioè il resto della divisione tra n e m vale zero.
In newLISP "%" è la funzione mod per i numeri interi.

(zero? (% 10 2))
;-> true
(zero? (% 130 11))
;-> nil

La funzione "filter" seleziona tutti i valori che soddisfano un predicato:
(filter (fn(x) (> x 5)) '(6 4 5 2 6 7 3 4 8 9))
;-> (6 6 7 8 9)

La funzione "apply" applica una funzione utilizzando tutti gli argomenti:
(apply + '(1 3 5))
;-> 9

Adesso possiamo scrivere la funzione:

(define (e001)
  (apply + (filter (fn(x) (or (zero? (% x 3)) (zero? (% x 5)))) (sequence 1 999)))
)

(e001)
;-> 233168

(time (e001))
;-> 0

(time (e001) 10000)
;-> 2453.466

Soluzione alternativa:

generiamo due sequenze (una con i multipli di 3 e l'altra con i multipli di 5)
(setq a (sequence 3 20 3))
;-> (3 6 9 12 15 18)
(setq b (sequence 5 20 5))
;-> (5 10 15 20)

uniamo le sequenze (la funzione union mantiene solo valori unici)
(setq c (union a b))
;-> (3 6 9 12 15 18 5 10 20)

infine sommiamo tutti i numeri:
(apply + c)
;-> 18

Ed ecco la funzione:

(define (e001)
    (apply + (union (sequence 3 999 3) (sequence 5 999 5)))
)

(e001)
;-> 233168

(time (e001))
;-> 0

(time (e001) 10000)
;-> 796.682

Dal punto di vista matematico possiamo notare che:

Sum[1..n] (i) = (1/2)*n*(n + 1) (Formula di Gauss)

Se vogliamo sapere quanti numeri sono divisibili per 3 possiamo scrivere:

D(n 3) = 3 * Sum[1 (floor n/3)] (i) = 3*(1/2)*(floor n/3)*((floor n/3) + 1)

Perchè contiamo fino a (floor n/3)? Applichiamo la formula:

(3) * (1 + 2 + 3 + ... 999) ==> (3 6 9 12 ... 2997)

Quanti sono i divisori di 3 fino a 999:

(for (i 1 999) (if (zero? (% i 3)) (++ d))) d
;-> 333

Quindi:

(floor (div 999 3))
;-> 333

E per un generico valore k (invece di 3):

D(n k) = k*Sum[1 (floor n/k)] (i) = k*(1/2)*(floor n/k)*((floor n/k) + 1)

Adesso sommiamo i divisori di 3 e i divisori di 5 e sottraiamo i divisori 15 (perchè (lcm 5 3 = 15)):

sol = D(999 3) + D(999 5) - D(999 15)

(define (e001-2 n)
  (local (a b c)
    (setq a (floor (div n 3)))
    (setq b (floor (div n 5)))
    (setq c (floor (div n 15)))
    (div (- (+ (* 3 a (+ a 1)) (* 5 b (+ b 1))) (* 15 c (+ c 1))) 2)))

(e001-2 999)
;-> 233168

(time (e001-2 999))
;-> 0

(time (e001-2 999) 10000)
;-> 15.586

Il tempo di questa funzione non dipende da n (diversamente dalle prime due funzioni).

(time (e001-2 10000) 10000)
;-> 15.587


==========
Problema 2
==========

I numeri di Fibonacci pari

Ciascun nuovo termine della sequenza di Fibonacci viene generato addizionando i due termini precedenti.
Partendo da 1 e 2, i primi 10 termini valgono:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

Considerando i termini della sequenza di Fibonacci i cui valori non superano quattro milioni, trovare la somma dei termini pari.
============================================================================

Questa è la funzione per il calcolo dei numeri di fibonacci:

(define (fibonacci n)
  (let (L '(0 1))
    (dotimes (i n)
      (setq L (list (L 1) (apply + L)))
    )
    ;(L 1)
    (last L)
  )
)

Il numero 32 è quello che genera l'ultimo valore utile (minore di 4.000.000):

(fibonacci 32)
;-> 3524578

(fibonacci 33)
;-> 5702887

Modifichiamo l'espressione "dotimes" con "while" per controllare il valore ottenuto.
Inoltre aggiorniamo il valore del risultato (res) quando il numero calcolato è dispari.

(define (e002)
  (let (L '(0 1) res 0)
    ;(dotimes (i n)
    (while (< (last L) 4000000)
      (setq L (list (L 1) (apply add L)))
      (if (even? (last L)) (inc res (last L)))
    )
    ;(last L)
    res
  )
)

(e002)
;-> 4613732

(time (e002))
;-> 0

(time (e002) 100000)
;-> 671.918

Soluzione alternativa:

(define (e002)
  (let (a 2 b 1 ans 0)
    (until (> b 4000000)
      (if (even? a)
        (inc ans a))
      (inc b a)
      (swap a b))
     ans))

(e002)
;-> 4613732

(time (e002))
;-> 0

(time (e002) 100000)
;-> 343.627

Dal punto di vista matematico:

Formula di Binet (relazione tra i numeri di fibonacci e il rapporto aureo):

Fib(n) = (phi^n - psi^n)/sqrt(5)

dove: phi = (1 + sqrt(5))/2 e psi = (1 - sqrt(5))/2

Invertendo la formula troviamo l'indice n per il numero di fibonacci Fib(n) dato:

n = floor (log[phi](F*sqrt(5) + (1/2)))

Inoltre utilizziamo la seguente identità (la somma dei primi n numeri di fibonacci vale (F(n+2) - 1):

Sum[0 n] F(i) = F(n+2) - 1

Usiamo queste formule per scrivere la funzione:

(define (setval)
  (setq sr (sqrt 5))
  (setq phi (div (add 1 sr) 2))
  (setq psi (div (sub 1 sr) 2)))

(define (f n) (div (sub (pow phi n) (pow psi n)) sr))
(define (idx fib) (floor (div (log (add (mul fib sr) 0.5)) (log phi))))
(define (sumfib n) (sub (f (+ n 2)) 1))

(define (e002-2 n)
    (setval)
    (round (div (sumfib (idx n)) 2)))

(e002-2 3999999)
;-> 4613732

(time (e002-2 3999999))
;-> 0

(time (e002-2 3999999) 100000)
;-> 78.098

Il tempo di questa funzione non dipende da n (diversamente dalle prime due funzioni).

(time (e002-2 9999999) 100000)
;-> 78.096


==========
Problema 3
==========

Il più grande fattore primo

I fattori primi di 13195 sono 5, 7, 13 e 29.

Qual'è il fattore primo più grande del numero 600851475143 ?
============================================================================

La funzione "factor" di newLISP restituisce tutti i fattori di un numero:

(factor 600851475143)
;-> (71 839 1471 6857)

Non resta che trovare il valore massimo:

(apply max (factor 600851475143))
;-> 6857

Definiamo la funzione:

(define (e003)
  (apply max (factor 600851475143))
)

(e003)
;-> 6857

(time (e003))
;-> 0

(time (e003) 100000)
;-> 496.8

Se vogliamo implementare la fattorizzazione, possiamo scrivere:

(define (e003-2 n)
  (let (i 2)
    (while (<= (* i i) n)
      (while (= (% n i) 0)
        (setq n (/ n i))
      )
      (++ i)
    )
    n))

(e003-2 600851475143)
;-> 6857

(time (e003-2 600851475143))
;-> 0

(time (e003-2 600851475143) 100000)
;-> 18174.285


==========
Problema 4
==========

Il più grande prodotto palindromo

Un numero palindromo ha lo stesso valore leggendo da sinistra a destra o da destra a sinistra.
Il più grande numero palindromo ottenuto dal prodotto di due numeri da due cifre vale 9009 = 91 * 99.

Trova il più grande numero palindromo ottenuto dal prodotto di due numeri da tre cifre.
============================================================================

(define (e004)
    (let (out 0  val 0)
        (for (i 100 999)
          (for (j i 999)
            (setq val (string (* i j)))
            (when (= val (reverse (copy val)))
                (setq out (max out (int val)))
            )
          )
        )
 out)
)

(e004)
;-> 906609

(time (e004))
;-> 204.069

(time (e004) 100)
;-> 19220.569

Dal punto di vista matematico:

La prima osservazione è che il numero deve essere compreso tra 100^2 e 999^2 o nell'intervallo (10000, 998001). 1]. Poiché la maggior parte dei numeri ha 6 cifre e stiamo cercando il più grande, ignoriamo i numeri a 5 cifre. Sulla base di questo, possiamo costruire un numero palindromo come:

'abccba' = 100000a + 10000b + 1000c + 100c + 10b + a
         = 100001a + 10010b + 1100c
         11*(9091a + 910b + 100c)

Pertanto, stiamo cercando i due numeri più grandi p, q:

p*q = 11*(9091a + 910b + 100c) ≤ 999^2

Questa equazione ci mostra che p o q, ma non entrambi, devono avere un fattore 11. Per massimizzare le due incognite, iniziamo la ricerca con p = 9 e per ogni p decrescente cerchiamo un massimo q per costruire un palindromo. Possiamo fare un'ottimizzazione basata sull'osservazione precedente: se p non è divisibile per 11, q lo deve essere, e come tale possiamo iniziare la ricerca con 990 come maggior multiplo di 11 e cercare solo multipli di 11. Un'altra ottimizzazione è, che non abbiamo bisogno di lasciare che q vadaal di sotto di p poiché possiamo scambiare i numeri. Vediamo un'implementazione:

(define (palindromo? num)
  (let (str (string num))
    (= str (reverse (copy str)))))

(define (e004-2)
  (local (r s t q p found)
    (setq r 0)
    (setq p 999)
    (while (>= p 100)
      (if (zero? (% p 11))
          (setq q 999 s 1)
          (setq q 990 s 11)
      )
      (setq found nil)
      (while (and (> q 99) (not found))
        (setq t (* p q))
        (if (and (< r t) (palindromo? t))
            (setq r t found true)
            ;(begin (println p { } q { } t) (setq r t found true))
        )
        (setq q (- q s))
      )
      (-- p)
    )
    r))

(e004-2)
;-> 906609

993 * 913 = 906609

(time (e004-2))
31.237

(time (e004-2) 100)
;-> 2187.681

Questa funzione è circe 10 volte più veloce della prima funzione.

Possiamo migliorare la funzione invertendo di nuovo p e q. In questo modo possiamo usare un ciclo con p da 990 attraverso i multipli di 11 e usare q per trovare un palindromo.

(define (e004-2)
  (local (r t q p found)
    (setq r 0)
    (for (p 990 100 -11)
      (setq found nil)
      (for (q 999 100 -1 found)
        (setq t (* p q))
        (if (and (< r t) (palindromo? t))
            (setq r t found true)
            (if (< t r) (setq found true))
        )
      )
    )
    r))

(e004-2)
;-> 906609

(time (e004-2))
;-> 0

(time (e004-2) 100)
;-> 109.373

Quest'ultima funzione è 20 volte più veloce della precedente (seconda) funzione.
(div 2187.681 109.373)
;-> 20.002

Quest'ultima funzione è 175 volte più veloce della prima funzione.
(div 19220.569 109.373)
;-> 175.734


==========
Problema 5
==========

Il multiplo minore

2520 è il più piccolo numero che può essere diviso esattamente (senza resto) da tutti i numeri da 1 a 10.

Qual'è il più piccolo numero positivo che è divisibile esattamente per tutti i numeri da 1 a 20 ?
============================================================================

La soluzione non vale 1*2*3*4*5*6*7*8*9*10*11*12*13*14*15*16*17*18*19*20 perchè, per esempio, quando il numero cercato è divisibile per 3 e per 5 è anche divisibile per 15.

La soluzione consiste nel trovare tutti i numeri che sono fattori unici con gli esponenti massimi e moltiplicarli tra loro.

Proviamo con il numero 10:

Troviamo tutte scomposizioni in fattori:

2  -> (2)
3  -> (3)
4  -> (2 2)
5  -> (5)
6  -> (2 3)
7  -> (7)
8  -> (2 2 2)
9  -> (3 3)
10 -> (2 5)

I fattori unici sono: 2, 3, 5, e 7.

Questi hanno esponenete massimo rispettivamente: 3 2 1 1.

Quindi i numeri da moltiplicare sono: 2^3, 3^2, 5^1 e 7^1.

Otteniamo: 8 * 9 * 5 * 7 = 2520.

; lista con le fattorizzazioni dei numeri da 2 a 10
(setq a (map factor (sequence 2 10)))
;-> ((2) (3) (2 2) (5) (2 3) (7) (2 2 2) (3 3) (2 5))

; lista con tutti i numeri dei fattori
(setq b (flat (map factor (sequence 2 10))))
;-> (2 3 2 2 5 2 3 7 2 2 2 3 3 2 5)

; lista con tutti i numeri dei fattori presi una sola volta
(setq c (unique (flat (map factor (sequence 2 10)))))
;-> (2 3 5 7)

Adesso dobbiamo trovare gli esponenti massimi di 2,3,5 e 7 nella lista con le fattorizzazioni dei numeri da 2 a 10.

Vediamo prima come funziona funzione "count":

(setq a '((1 2) (5 5) (2 3)))
(setq c '(2 3 5))

Vogliamo trovare quante volte gli elementi di c compaiono in a:

(map (curry count c) a)
;-> ((1 0 0) (0 0 2) (1 1 0)

cosa significa il risultato?

(1 0 0) -> conto il 2 una  volta su (1 2)
        -> conto il 3 zero volte su (1 2)
        -> conto il 5 zero volte su (1 2)

(0 0 2) -> conto il 2 zero volte su (5 5)
        -> conto il 3 zero volte su (5 5)
        -> conto il 5 due  volte su (5 5)

(1 1 0) -> conto il 2 una  volta su (2 3)
        -> conto il 3 una  volta su (2 3)
        -> conto il 5 zero volte su (2 3)

Se trasponiamo la lista:

(transpose(map (curry count c) a))
;-> ((1 0 1) (0 0 1) (0 2 0))

Che significa:

(1 0 1) -> conto il 2 una  volta su (1 2)
        -> conto il 2 zero volte su (5 5)
        -> conto il 2 una  volta su (2 3)
(0 0 1) -> conto il 3 zero volte su (1 2)
        -> conto il 3 zero volte su (5 5)
        -> conto il 3 una  volta su (2 3)
(0 2 0) -> conto il 5 zero volte su (1 2)
        -> conto il 5 due  volte su (5 5)
        -> conto il 5 zero volte su (2 3)

Nel nostro caso:

; lista con le fattorizzazioni dei numeri da 2 a 10
(setq a (map factor (sequence 2 10)))
;-> ((2) (3) (2 2) (5) (2 3) (7) (2 2 2) (3 3) (2 5))

; lista con tutti i numeri dei fattori
(setq b (flat (map factor (sequence 2 10))))
;-> (2 3 2 2 5 2 3 7 2 2 2 3 3 2 5)

; lista con tutti i numeri dei fattori presi una sola volta
(setq c (unique (flat (map factor (sequence 2 10)))))
;-> (2 3 5 7)

Adesso troviamo quante volte gli elementi di c compaiono in a:

(setq d (transpose(map (curry count c) a)))
;-> ((1 0 2 0 1 0 3 0 1) (0 1 0 0 1 0 0 2 0) (0 0 0 1 0 0 0 0 1) (0 0 0 0 0 1 0 0 0))

Adesso dobbiamo trovare il valore massimo di ogni sottolista (che sono gli esponenti massimi rispettivamente di 2,3,5 e 7).

(setq e (map (curry apply max)
            (transpose(map (curry count c) a))))
;-> (3 2 1 1)

Per capire meglio come funziona l'ultima espressione vediamo un esempio.

Se vogliamo applicare la funzione "sin" ad una lista di valori possiamo usare la funzione "map":

(map sin '(10 20 30))
;-> (-0.5440211108893698 0.9129452507276277 -0.9880316240928618)

Ma se i valori sono in sottoliste questo non funziona:

(map sin '((10) (20) (30)))
;-> ERR: value expected in function sin : '(10)

La soluzione si ottiene utilizzando la funzione "curry" e "apply":

(map (curry apply sin) '((10) (20) (30)))
;-> (-0.5440211108893698 0.9129452507276277 -0.9880316240928618)

Oppure in modo equivalente:

(map (lambda (x) (apply sin x)) '((10) (20) (30)))

"curry" transforma una funzione f(x, y) che prende due argomenti in una funzione fx(y) che prende un singolo argomento.
In questo modo "curry" dice ad "apply" di applicare la funzione "sin" solo alla sottolista.

Tornando al problema abbiamo:

; lista con tutti i numeri dei fattori presi una sola volta
(setq c (unique (flat (map factor (sequence 2 10)))))
;-> (2 3 5 7)

; lista con gli esponenti massimi rispettivamente di 2,3,5 e 7).
(setq e (map (curry apply max)
            (transpose(map (curry count c) a))))
;-> (3 2 1 1)

Adesso calcoliamo i numeri con la funzione "pow" e li moltiplichiamo tra loro:

(apply * (map pow c e))
;-> 2520

Scriviamo la funzione finale:

(define (e005)
  (setq a (map factor (sequence 2 20)))
  (setq b (flat a))
  (setq c (unique b))
  (setq e (map (curry apply max)
               (transpose(map (curry count c) a))))
  (apply * (map pow c e))
)

(e005)
;-> 232792560

(time (e005))
;-> 0

Dal punto di vista matematico, dopo tutti questi ragionamenti per trovare la soluzione notiamo che il problema richiedeva semplicemente di trovare il minimo comune multiplo dei primi venti numeri interi...

Quindi utilizzando la seguente funzione che calcola il Minimo Comune Multiplo di una serie di numeri:

(define-macro (mcm)
  (apply (fn (x y) (/ (* x y) (gcd x y))) (args) 2))

Potevamo calcolare la soluzione con:

(mcm 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20)
;-> 232792560

(define (e005-2) (apply mcm (sequence 2 20)))

(e005-2)
;-> 232792560

(time (e005-2))
;-> 0


==========
Problema 6
==========

Somma quadrati differenza

La somma dei quadrati dei primi dieci numeri naturali vale,

1^2 + 2^2 + ... + 10^2 = 385

Il quadrato della somma dei primi dieci numeri naturali vale,

(1 + 2 + ... + 10)^2 = 55^2 = 3025

Quindi la differenza tra la somma dei quadrati e il quadrato della somma dei primi dieci numeri naturali vale 3025 − 385 = 2640.

Trovare la differenza tra la somma dei quadrati e il quadrato della somma dei primi cento numeri naturali.
============================================================================

I primi dieci numeri li otteniamo da:

(setq num (sequence 1 10))
;-> (1 2 3 4 5 6 7 8 9 10)

La loro somma vale:

(setq sum (apply add num))
;-> 55

Il quadrato della somma vale:

(setq qs (* sum sum))
;-> 3025

La somma dei quadrati vale:

(setq sq (apply add (map * num num)))

Nota che:

(setq lst (sequence 1 10))
(map * lst lst)
;-> (1 4 9 16 25 36 49 64 81 100)
(map * lst lst lst)
;-> (1 8 27 64 125 216 343 512 729 1000)

La loro differenza vale:

(sub qs sq)
;-> 2640

Scriviamo la funzione:

(define (e006)
  (setq num (sequence 1 100))
  (setq sum (apply add num))
  (setq qs (* sum sum))
  (setq sq (apply add (map * num num)))
  (sub qs sq)
)

(e006)
;-> 25164150

(time (e006))
;-> 0

(time (e006) 100000)
;-> 640.678

Soluzione alternativa:

(define (e006)
    (let (lst (sequence 1 100))
        (- (pow (apply + lst)) (apply + (map * lst lst))) )
)

(e006)
;-> 25164150

(time (e006))
;-> 0

(time (e006) 100000)
;-> 640.467

Dal punto di vista matematico abbiamo:

Somma dei Quadrati

f(n) = Sum[1..n] i^2 = (1/6)*n*(n - 1)*(2*n - 1)

Quadrato della Somma

g(n) = (Sum[1..n] i)^2 = (1/4)*n^2*(n + 1)^2

La loro differenza:

g(n) - f(n) = (1/12)*n*(n + 1)*(3*n^2 - n - 2)

Possiamo scrivere la funzione:

(define (e006-2 n)
  (/ (* n (+ n 1) (sub (* 3 (pow n)) n 2)) 12))

(e006-2 100)
;-> 25164150

(time (e006-2 100))
;-> 0

(time (e006-2 100) 100000)
;-> 31.237

Il tempo di questa funzione non dipende da n (diversamente dalle prime due funzioni).

(time (e006-2 10000) 100000)
;-> 31.235


==========
Problema 7
==========

Il 10001-esimo numero primo

Elencando i primi sei numeri primi: 2, 3, 5, 7, 11, e 13, si nota che il sesto primo è 13.

Qual'è il 10001-esimo numero primo?
============================================================================

La soluzione con la forza bruta è semplice, cerchiamo progressivamente tutti i numeri primi partendo dal primo fino ad arrivare al 10001 numero primo:

(define (e007)
  (setq cnt 1 n 3) ; partiamo da 3 (il numero 2 è primo)
  (while (!= 10001 cnt)
      (if (isprime? n) (setq cnt (+ cnt 1))) ; se è un numero primo incrementiamo il conto
      (setq n (+ n 2)) ; non consideriamo i numeri pari
  )
  (- n 2)
)

(e007)
;-> 104743

(time (e007))
;-> 31.235

(time (e007) 100)
;-> 2625.219

Dal punto di vista matematico possiamo sfruttare il fatto che tutti i numeri primi (tranne il 2 e il 3) sono nella forma (6*k ± 1):

(define (e007-2 n)
  (local (conta i)
    (setq conta 2 i 0)
    (while (< conta n)
      (++ i 6)
      (if (isprime? (+ i 1)) (++ conta))
      (if (isprime? (- i 1)) (++ conta))
    )
    ; l'aggiungo l'ultimo primo che è nella forma 6*k + 1
    (+ i 1)))

(e007-2 10001)
;-> 104743

(time (e007-2 10001))
;-> 15.587

(time (e007-2 10001) 100)
;-> 1875.206


==========
Problema 8
==========

Il maggior prodotto in una serie

Le quattro cifre adiacenti che hanno il più grande prodotto nel numero da 1000 cifre riportato di seguito sono 9 × 9 × 8 × 9 = 5832.

73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450

Trovare, nel numero da 1000 cifre, le tredici cifre adiacenti che hanno il più grande prodotto. Qual'è il valore di questo numero ?
============================================================================

Assegniamo il numero ad una variabile di tipo stringa:

(setq x
"7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450")

(length x)
;-> 1000

Possiamo anche assegnare la variabile in un altro modo:

; elimina gli spazi (line-feeds)
(setq x (replace "\\s+" [text]
73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450
[/text] "" 0))

(length x)
;-> 1000

Dividiamo la stringa in blocchi da 13 caratteri (con passo 1 da 0 a 987):

(slice (explode x) 0 5) ; 5 al posto di 13
;-> ("7" "3" "1" "6" "7")

(setq a (map (fn (i) (slice (explode x) i 5))
             (sequence 0 4))) ; 4 al posto di 987

;-> (("7" "3" "1" "6" "7")
;->  ("3" "1" "6" "7" "1")
;->  ("1" "6" "7" "1" "7")
;->  ("6" "7" "1" "7" "6")
;->  ("7" "1" "7" "6" "5"))

(setq b (map join a))
;-> ("73167" "31671" "16717" "67176" "71765")

Mettiamo tutto insieme:

(setq c (map join (map (fn (i) (slice (explode x) i 5))
                       (sequence 0 4))))

;-> ("73167" "31671" "16717" "67176" "71765")

Convertiamo ogni carattere del blocco in integer:

(map explode c)
;-> (("7" "3" "1" "6" "7")
;->  ("3" "1" "6" "7" "1")
;->  ("1" "6" "7" "1" "7")
;->  ("6" "7" "1" "7" "6")
;->  ("7" "1" "7" "6" "5"))

(setq d (map (fn (i) (map int i)) (map explode c)))
;-> ((7 3 1 6 7) (3 1 6 7 1) (1 6 7 1 7) (6 7 1 7 6) (7 1 7 6 5))

Adesso moltiplichiamo tra loro i numeri in ogni sottolista:

(setq e (map (fn (i) (apply * i)) d))
;-> (882 126 294 1764 1470)

Infine troviamo il valore massimo delle moltiplicazioni:

(apply max e)
;-> 1764

Possiamo scrivere la funzione:

(setq x
"7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450")

(define (e008)
  ;(setq a (map join (map (fn (i) (slice (explode x) i 4)) ; for test: 5832
  ;                       (sequence 0 996))))
  (setq a (map join (map (fn (i) (slice (explode x) i 13)); for final result
                         (sequence 0 987))))
  (setq b (map (fn (i) (map int i)) (map explode a)))
  (setq c (map (fn (i) (apply * i)) b))
  (setq _res (apply max c))
  ;(println (nth (ref _res c) b)) ;-> (5 5 7 6 6 8 9 6 6 4 8 9 5)
  ;(println (last b)) ;-> (0 4 2 0 7 5 2 9 6 3 4 5 0)
  _res
)

(e008) ; con il valore 4 di test
;-> 5832

(e008) ; con il valore 13
;-> (5 5 7 6 6 8 9 6 6 4 8 9 5)
;-> 23514624000

(* 5 5 7 6 6 8 9 6 6 4 8 9 5)
;-> 23514624000

(time (e008))
;-> 62.476

(time (e008) 500)
;-> 27315.46

Possiamo scrivere la funzione utilizzando la tecnica "window sliding". La finestra di 13 caratteri simuove lungo la stringa il nuovo valore della moltiplicazione dei 13 caratteri è data dal valore precedente moltiplicato per l'ultimo carattere della nuova finestra e diviso per il primo carattere della finestra precedente. L'unico problema è quando tgroviamo il valore 0 come prima cifra della finestra precedente (non è possibile dividere per zero): questo caso deve essere trattato a parte.

(define (e008-2 str n)
  (local (vet prod maxp pre cur)
    ; trasformo la stringa in un vettore
    (setq vet (array (length str) (map int (explode str))))
    ; il primo prodotto è il prodotto dei primi n numeri
    (setq prod (apply * (slice vet 0 n)))
    (setq maxp prod)
    (for (i n (- (length vet) 1))
      (setq pre (vet (- i n)))
      (setq cur (vet i))
      (if (= pre 0)
          ; se la prima cifra 0, allora calcolo il prodotto esteso
          (setq prod (apply * (slice vet (+ i 1 (- n)) n)))
          ; altrimenti moltiplico e divido
          (setq prod (/ (* prod cur) pre))
      )
      (setq maxp (max prod maxp))
    )
    maxp))

(setq x
"7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450")

(e008-2 x 13)
;-> 23514624000

(time (e008-2 x 13))
;-> 0

(time (e008-2 x 13) 500)
;-> 218.696

Quest'ultima funzione è 125 volte più veloce della prima:

(div 27315.46 218.696)
;-> 124.9015071148992

==========
Problema 9
==========

Triple Pitagoriche speciali

Una tripla pitagorica è un insieme di tre numeri naturali, a < b < c, per cui risulta,

a^2 + b^2 = c^2

Per esempio, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.

Esiste solo una tripla pitagorica per cui risulta: a + b + c = 1000.

Trovare il prodotto a*b*c.
============================================================================

(define (e009)
    (catch
      (for (a 1 1000)
        (for (b a 1000)
            (let (c (sqrt (+ (pow a) (pow b))))
                (when (and
                      (= (add a b c) 1000)
                      (< a b c)) ; a < b < c
                    ;(println a { } b { } c)
                    (throw (* a b c))
                 )
             )
         )
      )
    )
)

(e009)
;-> 200 375 425
;-> 31875000

(time (e009))
;-> 31.208

(time (e009) 1000)
;-> 30908.208

Dal punto di vista matematico, poniamo c = n - a - b.

Poichè (a < b < c) e (a + b + c = n), possiamo concludere che:

valore massimo per a: a < (n/3) - 1
valore massimo per b: b < (n/2) - 1

Adesso partendo da (a + b) = (n - c) e (a^2 + b^2 = c^2):

      a^2 + b^2 = c^2
a^2 + b^2 + 2ab = c^2 + 2ab
      (a + b)^2 = c^2 + 2ab
      (n - c)^2 = c^2 + 2ab  ==>  2ab = (n - c)^2 - c^2

Sottraiamo 2ab dalla prima equazione (a^2 + b^2 = c^2):

      a^2 + b^2 = c^2
a^2 + b^2 - 2ab = c^2 - 2ab
(a - b)^2 = c^2 - (n - c)^2 + c^2
(a - b)^2 = c^2 - n^2 - c^2 + 2nc + c^2
(a - b)^2 = c^2 - n^2 + 2nc

Poichè (c^2 - n^2 + 2nc) deve essere un quadrato perfetto, possiamo ignorare a e b e verificare solo se è un quadrato perfetto.

Una possibile implementazione è la seguente:

(define (e009-2 n)
  (local (a b ab sq-ab res found)
    (setq found nil)
    (setq res nil)
    (for (c (floor (+ (/ n 3) 1)) (- (/ n 2) 1) 1 found)
      (setq sq-ab (- (+ (* c c) (* 2 n c)) (* n n)))
      (setq ab (floor (sqrt sq-ab)))
      (if (= (* ab ab) sq-ab)
          (setq b (/ (- n (+ c ab)) 2)
                a (- n b c)
                found true
                res (list (sort (list a b c)) (+ a b c) (* a b c)))
      )
    )
    res))

(e009-2 1000)
;-> ((200 375 425) 1000 31875000)

(time (e009-2 1000))
;-> 0

(time (e009-2 1000) 1000)
;-> 31.208

Quest'ultima funzione è 990 volte più veloce della prima:

(div 30908.208 31.208)
;-> 990.3937451935401


===========
Problema 10
===========

Sommatoria dei numeri primi

La somma dei numeri primi minori di 10 vale 2 + 3 + 5 + 7 = 17.

Trovare la somma di tutti i primi minori di 2 milioni.
============================================================================

(sequence 2 10)
;-> (2 3 4 5 6 7 8 9 10)

(isprime? 2)
;-> true

(filter isprime? (sequence 2 10))
;-> (2 3 5 7)

(filter isprime? (sequence 2 1000))
;-> (2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107
;->  109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223
;->  227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337
;->  347 349 353 359 367 373 379 383 389 397 401 409 419 421 431 433 439 443 449 457
;->  461 463 467 479 487 491 499 503 509 521 523 541 547 557 563 569 571 577 587 593
;->  599 601 607 613 617 619 631 641 643 647 653 659 661 673 677 683 691 701 709 719
;->  727 733 739 743 751 757 761 769 773 787 797 809 811 821 823 827 829 839 853 857
;->  859 863 877 881 883 887 907 911 919 929 937 941 947 953 967 971 977 983 991 997)

(apply add (filter isprime? (sequence 2 10)))
;-> 17

(apply add (filter isprime? (sequence 2 10000)))
;-> 5736396

(apply add (filter isprime? (sequence 2 2000000)))
;-> 142913828922

(time (apply add (filter isprime? (sequence 2 2000000))))
;-> 2265.831

(+ 2 (apply + (filter isprime? (sequence 3 2000000 2 ))))
;-> 142913828922

(time (+ 2 (apply + (filter isprime? (sequence 3 2000000 2 )))))
;-> 1893.077

Proviamo con una funzione iterativa:

(define (e010)
    (let (somma 2)
        (for (i 3 1999999 2)
            (if (= 1 (length (factor i)))
                (setq somma (+ somma i)))
        )
        somma
    )
)

(e010)
;-> 142913828922

(time (e010))
;-> 1077.866

Dal punto di vista matematico possiamo implementare una versione del crivello di eratostene ottimizzata per questo problema, inoltre calcoliamo la somma dei numeri primi fino a n come la differenza tra la somma di tutti i numeri primi fino a n e la somma di tutti i numeri composti (non-primi) fino a n:

Sum[1..n]primi(i) = Sum[1..n](i) - Sum[1..n]composti(i)

dove: Sum[1..n](i) = n*(n + 1)/2

(define (e010-2 n)
  (local (sum bound data start step)
    (setq sum 0)
    (setq bound (floor (sqrt n)))
    (setq data (array (+ n 1) '(0)))
    (setf (data 1) 1)
    (setf (data 0) 1)
    (for (i 2 bound)
      (if (zero? (data i))
          (for (j (+ i i) n i)
            (if (zero? (data j))
              (begin
              (setf (data j) 1)
              (++ sum j))
            )
          )
       )
    )
    (- (/ (* n (+ n 1)) 2) sum 1)))

(e010-2 1999999)
;-> 142913828922

(time (e010-2 1999999))
;-> 546.907


===========
Problema 11
===========

Il più grande prodotto in una griglia

Nella griglia 20 × 20 seguente, quattro numeri lungo una linea diagonale sono stati racchiusi con i caratteri > < (es. >26<).

08  02  22  97  38  15  00  40  00  75  04  05  07  78  52  12  50  77  91  08
49  49  99  40  17  81  18  57  60  87  17  40  98  43  69  48  04  56  62  00
81  49  31  73  55  79  14  29  93  71  40  67  53  88  30  03  49  13  36  65
52  70  95  23  04  60  11  42  69  24  68  56  01  32  56  71  37  02  36  91
22  31  16  71  51  67  63  89  41  92  36  54  22  40  40  28  66  33  13  80
24  47  32  60  99  03  45  02  44  75  33  53  78  36  84  20  35  17  12  50
32  98  81  28  64  23  67  10 >26< 38  40  67  59  54  70  66  18  38  64  70
67  26  20  68  02  62  12  20  95 >63< 94  39  63  08  40  91  66  49  94  21
24  55  58  05  66  73  99  26  97  17 >78< 78  96  83  14  88  34  89  63  72
21  36  23  09  75  00  76  44  20  45  35 >14< 00  61  33  97  34  31  33  95
78  17  53  28  22  75  31  67  15  94  03  80  04  62  16  14  09  53  56  92
16  39  05  42  96  35  31  47  55  58  88  24  00  17  54  24  36  29  85  57
86  56  00  48  35  71  89  07  05  44  44  37  44  60  21  58  51  54  17  58
19  80  81  68  05  94  47  69  28  73  92  13  86  52  17  77  04  89  55  40
04  52  08  83  97  35  99  16  07  97  57  32  16  26  26  79  33  27  98  66
88  36  68  87  57  62  20  72  03  46  33  67  46  55  12  32  63  93  53  69
04  42  16  73  38  25  39  11  24  94  72  18  08  46  29  32  40  62  76  36
20  69  36  41  72  30  23  88  34  62  99  69  82  67  59  85  74  04  36  16
20  73  35  29  78  31  90  01  74  31  49  71  48  86  81  16  23  57  05  54
01  70  54  71  83  51  54  69  16  92  33  48  61  43  52  01  89  19  67  48

Il prodotto di questi numeri vale 26 × 63 × 78 × 14 = 1788696.

Qual'è il valore più grande del prodotto di quattro numeri adiacenti nella stessa direzione (su, giù, sinistra, destra o diagonalmente) nella griglia 20 × 20?
============================================================================

(setq grid
'( 8  2 22 97 38 15  0 40  0 75  4  5  7 78 52 12 50 77 91  8
  49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48  4 56 62  0
  81 49 31 73 55 79 14 29 93 71 40 67 53 88 30  3 49 13 36 65
  52 70 95 23  4 60 11 42 69 24 68 56  1 32 56 71 37  2 36 91
  22 31 16 71 51 67 63 89 41 92 36 54 22 4  40 28 66 33 13 80
  24 47 32 60 99  3 45  2 44 75 33 53 78 36 84 20 35 17 12 50
  32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70
  67 26 20 68  2 62 12 20 95 63 94 39 63  8 40 91 66 49 94 21
  24 55 58  5 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72
  21 36 23  9 75  0 76 44 20 45 35 14  0 61 33 97 34 31 33 95
  78 17 53 28 22 75 31 67 15 94  3 80  4 62 16 14  9 53 56 92
  16 39  5 42 96 35 31 47 55 58 88 24  0 17 54 24 36 29 85 57
  86 56  0 48 35 71 89  7  5 44 44 37 44 60 21 58 51 54 17 58
  19 80 81 68  5 94 47 69 28 73 92 13 86 52 17 77  4 89 55 40
   4 52  8 83 97 35 99 16  7 97 57 32 16 26 26 79 33 27 98 66
  88 36 68 87 57 62 20 72  3 46 33 67 46 55 12 32 63 93 53 69
   4 42 16 73 38 25 39 11 24 94 72 18  8 46 29 32 40 62 76 36
  20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74  4 36 16
  20 73 35 29 78 31 90  1 74 31 49 71 48 86 81 16 23 57  5 54
   1 70 54 71 83 51 54 69 16 92 33 48 61 43 52  1 89 19 67 48))

(length grid)
;-> 400

(define (right i)
  (setq r (slice grid i 4))
  (apply * r))

(define (down i)
  (setq d (select grid i (+ i 20) (+ i 40) (+ i 60)))
  (apply * d))

(define (diag-down-right i)
  (setq dr (select grid i (+ i 21) (+ i 42) (+ i 63)))
  (apply * dr))

(define (diag-down-left i)
  (setq dl (select grid i (+ i 19) (+ i 38) (+ i 57)))
  (apply * dl))

(define (e011)
  (setq down-max (apply max (map (fn (x) (down x)) (sequence 0 339))))
  (setq diag-down-left-max (apply max (map (fn (x) (diag-down-left x)) (sequence 3 339))))
  (setq diag-down-right-max (apply max (map (fn (x) (diag-down-right x)) (sequence 0 333))))
  (max down-max diag-down-left-max diag-down-left-max)
)

(e011)
;-> 70600674

(time (e011))
;-> 0

(time (e011) 1000)
;-> 501.021

Per migliorare la velocità proviamo ad utilizzare un vettore al posto di una lista, cicli "for" al posto di "map" e moltiplicazioni dirette al posto di "apply":

(setq arr (array 20 20 grid))
;-> ((8 2 22 97 38 15 0 40 0 75 4 5 7 78 52 12 50 77 91 8)
;->  (49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 4 56 62 0)
;->  (81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 3 49 13 36 65)
;->  (52 70 95 23 4 60 11 42 69 24 68 56 1 32 56 71 37 2 36 91)
;->  (22 31 16 71 51 67 63 89 41 92 36 54 22 4 40 28 66 33 13 80)
;->  (24 47 32 60 99 3 45 2 44 75 33 53 78 36 84 20 35 17 12 50)
;->  (32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70)
;->  (67 26 20 68 2 62 12 20 95 63 94 39 63 8 40 91 66 49 94 21)
;->  (24 55 58 5 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72)
;->  (21 36 23 9 75 0 76 44 20 45 35 14 0 61 33 97 34 31 33 95)
;->  (78 17 53 28 22 75 31 67 15 94 3 80 4 62 16 14 9 53 56 92)
;->  (16 39 5 42 96 35 31 47 55 58 88 24 0 17 54 24 36 29 85 57)
;->  (86 56 0 48 35 71 89 7 5 44 44 37 44 60 21 58 51 54 17 58)
;->  (19 80 81 68 5 94 47 69 28 73 92 13 86 52 17 77 4 89 55 40)
;->  (4 52 8 83 97 35 99 16 7 97 57 32 16 26 26 79 33 27 98 66)
;->  (88 36 68 87 57 62 20 72 3 46 33 67 46 55 12 32 63 93 53 69)
;->  (4 42 16 73 38 25 39 11 24 94 72 18 8 46 29 32 40 62 76 36)
;->  (20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 4 36 16)
;->  (20 73 35 29 78 31 90 1 74 31 49 71 48 86 81 16 23 57 5 54)
;->  (1 70 54 71 83 51 54 69 16 92 33 48 61 43 52 1 89 19 67 48))

(define (get-el y x)
  (if (and (>= y 0) (< y 20) (>= x 0) (< x 20))
      (arr y x)
      0))

(get-el 2 2)
;-> 31

(define (e011-2)
  (local (dx dy val max-val)
    (setq max-val 0)
    (setq dx '(1 0 1 -1))
    (setq dy '(0 1 1  1))
    (for (y 0 19)
      (for (x 0 19)
        (for (d 0 3)
          (setq val 1)
          (for (i 0 3)
            (setq val (* val (get-el (+ y (* i (dy d))) (+ x (* i (dx d))))))
          )
          (setq max-val (max val max-val))
        )
      )
    )
    max-val))

(e011-2)
;-> 70600674

(time (e011-2))
;-> 2.992

(time (e011-2) 1000)
;-> 2496.241

Questa volta la velocità è peggiorata (probabilmente la funzione "get-el" è la responsabile).


===========
Problema 12
===========

Numero triangolare altamente divisibile

La sequenza di numeri triangolari viene generata aggiungendo i numeri naturali. Quindi il settimo numero di triangolo sarebbe 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. I primi dieci termini sarebbero:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Cerchiamo di elencare i fattori dei primi sette numeri triangolare:

  1: 1
  3: 1,3
  6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28

Possiamo vedere che 28 è il primo numero triangolare ad avere più di cinque divisori.

Qual'è il valore del primo numero triangolare che ha oltre cinquecento divisori?
============================================================================

Funzione che calcola l'n-esimo numero triangolare:

(define (numtri n) (/ (+ (* n n) n) 2))
;-> (numtri 1)
;-> 1
;-> (numtri 2)
;-> 3
;-> (numtri 3)
;-> 6
;-> (numtri 4)
;-> 10

Funzione cha calcola il numero di divisori di un numero n:

(define (numdivisors n)
  (local (ndiv)
    (setq ndiv 0)
    (for (i 1 (+ n 1))
      (if (zero? (% n i)) (++ ndiv))
    )
    ndiv
  )
)

(numdivisors 10) ;(1 2 5 10)
;-> 4

(numdivisors 64) ;(1 2 4 8 16 32 64)
;-> 7

(numdivisors 76576500)
;-> 576

(define (e012)
  (let (look true)
    (for (i 1 99999 2 (not look))
      (if (> (* (numdivisors i) (numdivisors (div (numtri i) i))) 500)
        (begin
          (println "i = " i {; }
                   "tri = " (numtri i) {; }
                   "divisori = " (* (numdivisors i) (numdivisors (div (numtri i) i))))
          (setq look false)
        )
      )
    )
  )
)

(e012)
;-> i = 12375; tri = 76576500; divisori = 576
;-> true

(time (e012))
;-> 5444.521

Dal punto di vista matematico, il numero di divisori di un numero naturale n è dato da tau(n) o τ(n) o talvolta  delta(n) o δ(n). Ogni numero naturale può essere espresso come il prodotto dei loro fattori primi k in questo modo:

n = Prod[1..k] p(i)^e(i)
​
Quindi il numero di divisori è dato da:

tau(n) = Prod[1..k] e(i) + 1

Quindi abbiamo bisogno della scomposizione in fattori primi e del prodotto dei suoi esponenti.

Prima scriviamo la funzione che calcola tau(n):

(define (tau num)
  (local (n i p c)
    (setq n num i 2 p 1)
    (cond ((= num 1) (setq p 1))
          (true
            (while (<= (* i i) n)
              (setq c 1)
              (while (zero? (% n i))
                (setq n (/ n i))
                (++ c)
              )
              (++ i)
              (setq p (* p c))
            )
            (if (or (= n num) (> n 1)) (setq p (* p 2)))
          )
     )
     p))

(tau 20)
;-> 6

Vediamo se la funzione "tau" e "numdivisors" danno gli stessi risultati:
(for (i 1 10000)
  (if (!= (numdivisors i) (tau i)) (println i { } (numdivisors i) { } (tau i))))
  ;-> nil

Inoltre occorre la seguente funzione che calcola i numeri triangolari fino ad un certo valore num:

(define (tri num)
  (setq n 1)
  (setq d 1)
  (println d)
  (while (< d num)
    (++ n)
    (++ d n)
    (println d)
  )
  d)

(tri 21)
;-> 1
;-> 3
;-> 6
;-> 10
;-> 15
;-> 21

La funzione finale è la seguente:

(define (e012-2 x)
  (let ((n 1) (d 1))
    (while (<= (tau d) x)
      (++ n)
      (++ d n)
    )
    d))

(e012-2 500)
;-> 76576500

(time (e012-2))
;-> 0


===========
Problema 13
===========

Grande somma

Calcolare le prime dieci cifre della somma dei seguenti cento numeri di 50 cifre ognuno.
============================================================================

Suddividiamo la lista da 100 numeri in due liste da 50 numeri per evitare il limite dei 2048 caratteri che newLISP pone alla lunghezza di una espressione.

(setq numeriA '(
 37107287533902102798797998220837590246510135740250L
 46376937677490009712648124896970078050417018260538L
 74324986199524741059474233309513058123726617309629L
 91942213363574161572522430563301811072406154908250L
 23067588207539346171171980310421047513778063246676L
 89261670696623633820136378418383684178734361726757L
 28112879812849979408065481931592621691275889832738L
 44274228917432520321923589422876796487670272189318L
 47451445736001306439091167216856844588711603153276L
 70386486105843025439939619828917593665686757934951L
 62176457141856560629502157223196586755079324193331L
 64906352462741904929101432445813822663347944758178L
 92575867718337217661963751590579239728245598838407L
 58203565325359399008402633568948830189458628227828L
 80181199384826282014278194139940567587151170094390L
 35398664372827112653829987240784473053190104293586L
 86515506006295864861532075273371959191420517255829L
 71693888707715466499115593487603532921714970056938L
 54370070576826684624621495650076471787294438377604L
 53282654108756828443191190634694037855217779295145L
 36123272525000296071075082563815656710885258350721L
 45876576172410976447339110607218265236877223636045L
 17423706905851860660448207621209813287860733969412L
 81142660418086830619328460811191061556940512689692L
 51934325451728388641918047049293215058642563049483L
 62467221648435076201727918039944693004732956340691L
 15732444386908125794514089057706229429197107928209L
 55037687525678773091862540744969844508330393682126L
 18336384825330154686196124348767681297534375946515L
 80386287592878490201521685554828717201219257766954L
 78182833757993103614740356856449095527097864797581L
 16726320100436897842553539920931837441497806860984L
 48403098129077791799088218795327364475675590848030L
 87086987551392711854517078544161852424320693150332L
 59959406895756536782107074926966537676326235447210L
 69793950679652694742597709739166693763042633987085L
 41052684708299085211399427365734116182760315001271L
 65378607361501080857009149939512557028198746004375L
 35829035317434717326932123578154982629742552737307L
 94953759765105305946966067683156574377167401875275L
 88902802571733229619176668713819931811048770190271L
 25267680276078003013678680992525463401061632866526L
 36270218540497705585629946580636237993140746255962L
 24074486908231174977792365466257246923322810917141L
 91430288197103288597806669760892938638285025333403L
 34413065578016127815921815005561868836468420090470L
 23053081172816430487623791969842487255036638784583L
 11487696932154902810424020138335124462181441773470L
 63783299490636259666498587618221225225512486764533L
 67720186971698544312419572409913959008952310058822L ))

(setq numeriB '(
 95548255300263520781532296796249481641953868218774L
 76085327132285723110424803456124867697064507995236L
 37774242535411291684276865538926205024910326572967L
 23701913275725675285653248258265463092207058596522L
 29798860272258331913126375147341994889534765745501L
 18495701454879288984856827726077713721403798879715L
 38298203783031473527721580348144513491373226651381L
 34829543829199918180278916522431027392251122869539L
 40957953066405232632538044100059654939159879593635L
 29746152185502371307642255121183693803580388584903L
 41698116222072977186158236678424689157993532961922L
 62467957194401269043877107275048102390895523597457L
 23189706772547915061505504953922979530901129967519L
 86188088225875314529584099251203829009407770775672L
 11306739708304724483816533873502340845647058077308L
 82959174767140363198008187129011875491310547126581L
 97623331044818386269515456334926366572897563400500L
 42846280183517070527831839425882145521227251250327L
 55121603546981200581762165212827652751691296897789L
 32238195734329339946437501907836945765883352399886L
 75506164965184775180738168837861091527357929701337L
 62177842752192623401942399639168044983993173312731L
 32924185707147349566916674687634660915035914677504L
 99518671430235219628894890102423325116913619626622L
 73267460800591547471830798392868535206946944540724L
 76841822524674417161514036427982273348055556214818L
 97142617910342598647204516893989422179826088076852L
 87783646182799346313767754307809363333018982642090L
 10848802521674670883215120185883543223812876952786L
 71329612474782464538636993009049310363619763878039L
 62184073572399794223406235393808339651327408011116L
 66627891981488087797941876876144230030984490851411L
 60661826293682836764744779239180335110989069790714L
 85786944089552990653640447425576083659976645795096L
 66024396409905389607120198219976047599490197230297L
 64913982680032973156037120041377903785566085089252L
 16730939319872750275468906903707539413042652315011L
 94809377245048795150954100921645863754710598436791L
 78639167021187492431995700641917969777599028300699L
 15368713711936614952811305876380278410754449733078L
 40789923115535562561142322423255033685442488917353L
 44889911501440648020369068063960672322193204149535L
 41503128880339536053299340368006977710650566631954L
 81234880673210146739058568557934581403627822703280L
 82616570773948327592232845941706525094512325230608L
 22918802058777319719839450180888072429661980811197L
 77158542502016545090413245809786882778948721859617L
 72107838435069186155435662884062257473692284509516L
 20849603980134001723930671666823555245252804609722L
 53503534226472524250874054075591789781264330331690L ))

(length numeriA)
;-> 50
(length numeriB)
;-> 50

(apply + numeriA)
;-> 2739840008414248713350123647779193919724097856798098L

(apply + numeriB)
;-> 2797536221976627923951925099053792052049561975094574L

(+ (apply + numeriA) (apply + numeriB))

(define (e013)
  (slice (string (+ (apply + numeriA) (apply + numeriB))) 0 10))

(e013)
;-> "5537376230"

Il numero  completo vale:
5537376230390876637302048746832985971773659831892672L

(time (e013))
;-> 0


===========
Problema 14
===========

La sequenza di Collatz più lunga

La seguente sequenza iterativa è definita per l'insieme di numeri interi positivi:

n = 1 -> stop
n -> n / 2 (n è pari)
n -> 3 * n + 1 (n è dispari)

Usando la regola sopra e iniziando con 13, generiamo la seguente sequenza:
13 40 20 10 5 16 8 4 2 1
Si può vedere che questa sequenza (che inizia a 13 e finisce a 1) contiene 10 termini.
Anche se non è stato ancora dimostrato (Collatz Problem), si ritiene che tutti i numeri iniziali conducano al numero 1.

Quale numero iniziale, inferiore a un milione, produce la catena più lunga?

NOTA: una volta avviata la sequenza, i termini possono superare il milione.
============================================================================

Scriviamo una funzione che costruisce la sequenza di Collatz per un numero n:

(define (collatz n)
  (if (= n 1) '(1)
    (cons n (collatz (if (even? n) (/ n 2) (+ 1 (* 3 n)))))))

Poi scriviamo una funzione che calcola la lunghezza della sequenza di Collatz di un numero n:

(define (collatz-lenght n)
  (length (collatz n))
)

(collatz 24)
;-> (24 12 6 3 10 5 16 8 4 2 1)

(collatz-lenght 24)
;-> 11

Utilizzando le due funzioni direttamente (senza alcun tipo di ottimizzazione) possiamo scrivere la seguente soluzione:

(define (e014)
  (local (maxlun out num)
    (setq maxlun 0)
    (setq out '())
    (setq num 0)
    (for (i 1 1000000)
      (if (> (length (collatz i)) maxlun)
          (begin
            (setq maxlun (length (collatz i)))
            (setq num i)
          )
      )
    )
    (list num maxlun)
  )
)

Questa funzione è molto lenta...

(e014)
;-> (837799 525)

(time (e014))
;-> 107039.434 ; 107 secondi

Proviamo a scrivere una funzione unica che calcola la lunghezza di collatz senza costruire la lista:

(define (e014)
  (local (maxlun lun num c)
    (setq maxlun 0)
    (setq num 0)
    (for (i 1 1000000)
      (setq c i)
      (setq lun 1)
      ; calcolo della lunghezza della sequenza
      (while (!= c 1)
         (if (even? c) (setq c (/ c 2))
                       (setq c (+ 1 (* 3 c)))
         )
         (++ lun)
      )
      (if (> lun maxlun) ; se la sequenza è più lunga di quella massima,
          (begin         ; allora aggiorno il valore massimo e il relativo numero di collatz
            (setq maxlun lun)
            (setq num i)
          )
      )
    )
    (list num maxlun)
  )
)

(e014)
;-> (837799 525)

(time (e014))
;-> 15376.695 ; 15.4 secondi

Possiamo riscrivere la funzione in modo diverso:

(define (len-collatz n)
  (let (c 1)
    (while (> n 1)
      (if (even? n)
          (setq n (/ n 2))
          (setq n (+ (* 3 n) 1))
      )
      (++ c)
    )
    c))

(len-collatz 24)
;-> 11

(define (e014 n)
  (local (max-len max-num)
    (setq max-len 0 max-num 0)
    (for (i 1 n)
      (setq c (len-collatz i))
      (if (> c max-len)
          (setq max-len c max-num i)
      )
    )
    (list max-num max-len)))

(e014 999999)
;-> (837799 525)

(time (e014 999999))
;-> 15157.284

Non abbiamo migliorato la velocità...

Allora proviamo ad utilizzare una hash-map per contenere i valori delle lunghezze di Collatz di ogni numero:

; crea hash
(new Tree 'hash)

; assegna hash (hash chiave valore)
(hash 4 2)
;-> 2

; recupero valore con chiave
(hash 4)
;-> 2

; valore nil se non esiste la chiave
(hash 3)
;-> nil

; elimina hash
(delete 'hash)

Scriviamo la funzione:

(define (e014-2 n)
  (local (maxlun lun num c found)
    ;(delete 'hash)
    (new Tree 'hash)
    (setq maxlun 0)
    (setq num 0)
    (for (i 1 n)
      (if (= (length (hash)) n) (println i { } n))
      (setq c i)
      (setq lun 1)
      ; calcolo della lunghezza della sequenza
      (setq found nil)
      (while (and (!= c 1) (not found))
        ; se non trovo il valore della lunghezza nella hashmap
        (if (nil? (hash (string c)))
            ; calcolo la lunghezza normalmente
            (begin
            (if (even? c)
                (setq c (/ c 2))

                (setq c (+ 1 (* 3 c)))
            )
            (++ lun))
            ;else
            ; altrimenti la recupero dalla hashmap
            (begin
            (setq found true)
            (setq lun (+ lun (hash (string c)) (- 1))))
        )
      )
      ; inserisco nella hashmap il valore della lunghezza trovata
      (hash i lun)
      (if (> lun maxlun) ; se la sequenza è più lunga di quella massima,
          (begin         ; allora aggiorno il valore massimo e il relativo numero di collatz
            (setq maxlun lun)
            (setq num i)
          )
      )
    )
    (list num maxlun (length (hash)))
  )
)

(e014-2 999999)
;-> (837799 525)

Per calcolare la velocità della funzione occorre eliminare l'hashmap perchè contiene tutti i valori delle lunghezze fino al numero 999999:

(delete 'hash)

(time (e014-2 999999))
;-> 7563.103

Se non eliminiamo l'hashmap:

(time (e014-2 999999))
;-> 2015.606


===========
Problema 15
===========

Percorsi in una griglia

Partendo dall'angolo in alto a sinistra di una griglia 2 × 2, e potendo solo spostarsi verso destra e verso il basso, ci sono esattamente 6 percorsi diversi per raggiungere l'angolo in basso a destra.

Quanti percorsi ci sono attraverso una griglia 20 × 20?
==============

Quello che ci interessa è la distanza tra le coordinate di inizio e fine, cioè la dimensione della griglia: 20.

Possiamo scrivere una funzione ricorsiva che utilizza questo valore di distanza per calcolare il numero totale dei percorsi (minimi) tra i due punti.
Poichè ogni volta ci dobbiamo muovere a destra o verso il basso possiamo richiamare la stesse funzioni con uno dei parametri (destra o basso) diminuito di 1. Queste funzioni vengono richiamate tante volte quanto vale la distanza tra le coordinate. Facendo la somma dei risultati di queste funzioni otteniamo il numero di percorsi (minimi) tra le coordinate di inizio e fine della griglia.

La funzione ricorsiva per il calcolo dei percorsi è la seguente:

(define (numPercorsi basso destra);
    (if (or (= basso 0) (= destra 0)) 1
        (+ (numPercorsi (- basso 1) destra)
           (numPercorsi basso (- destra 1)))
    )
)

(numPercorsi 2 2)
;-> 6

(numPercorsi 10 10)
;-> 184756

(time (numPercorsi 20 20))

Purtroppo questa funzione è molto lenta (O(2^n)) quindi dobbiamo utilizzare un'altro metodo. Dal punto di vista matematico, il numero di percorsi in una griglia dal punto (0,0) al punto (n,m) è uguale al coefficiente binomiale:

(n + m)      (n + m)!
        = -------------
(  n  )      n! * m!
                          (2*n)    (2*n)!    (40)      40!
Nel nostro caso diventa:        = -------- =      = ---------
                          ( n )    (n!)^2    (20)    (20!)^2

Definiamo la funzione fattoriale:

(define (fact n) (apply * (map bigint (sequence 1 n))))

Calcoliamo il numero di percorsi:

(define (e015 n)
  (/ (fact (+ n n)) (* (fact n) (fact n)))
)

(e015 20)
;-> 137846528820L

(time (e015 20))
;-> 0

(time (e015 20) 10000)
;-> 180.548

Dal punto di vista non-matematico, notiamo che:

(for (i 1 10) (print (e015 i) { }))
;-> 2L 6L 20L 70L 252L 924L 3432L 12870L 48620L 184756L

Guardando su oesis.org si trova che questa sequenza è la A000984 (Central binomial coefficients).
Questa sequenza può essere calcolata nel modo seguente:

(define (e015-2 n)
  (let (c 1)
    (for (i 1 n)
      (setq c (/ (* c (+ n i)) i)))))

(e015-2 20)
;-> 137846528820

(time (e015-2 20))
;-> 0

(time (e015-2 20) 10000)
;-> 18.95

Questa funzione è 10 volte più veloce della precedente.


===========
Problema 16
===========

Somma cifre di una potenza

2^15 = 32768 e la somma delle sue cifre vale 3 + 2 + 7 + 6 + 8 = 26.

Quanto vale la somma delle cifre del numero 2^1000?
============================================================================

(Definiamo una funzione che calcola la potenza di un numero intero (big integer):

(define (potenza n m)
  (setq pot 1L)
  (dotimes (x m)
    (setq pot (* pot n))
  )
)

(potenza 3 50)
;-> 717897987691852588770249L

(define (e016)
  (setq num (potenza 2 1000))
  (setq n$ (string num))
  (setq n$ (slice n$ 0 (- (length n$) 1)))
  (apply + (map int (explode n$)))
)

(e016)
;-> 1366

(time (e016))
;-> 0

Dal punto di vista matematico possiamo utilizzare la formula per la lunghezza di un numero intero n:

L(n) = floor(1 + log10(n))

Quindi il numero 2^1000 è lungo:

d = 1 + floor(log10(2^1000)) = 1 + floor(1000*log10(2))

(add 1 (floor (mul 1000 (log 2 10))))
;-> 302

Quindi possiamo moltiplicare il numero 2 per 1000 volte utilizzando il normale algoritmo per la moltiplicazione e memorizzare il risultato in un vettore di 320 elementi. Potremmo usare una lista per memorizzare il risultato, ma un vettore è più veloce.

(define (e016-2 esp)
  (local (product carry order digits number)
    (setq order 0)
    (setq digits (add 1 (floor (mul 1000 (log 2 10)))))
    (setq number (array digits '(1)))
    (setf (number 0) 1)
    (for (i 0 (- esp 1))
      (setq carry 0)
      (for (j 0 order)
        (setq product (+ (* 2 (number j)) carry))
        (setf (number j) (% product 10))
        (setq carry (/ product 10))
        (if (and (= j order) (> carry 0))
          (++ order)
        )
      )
    )
    (apply + (array-list number))))

(e016-2 1000)
;-> 1366

(time (e016-2 1000))
;-> 31.947


===========
Problema 17
===========

Contare il numero di lettere

Se i numeri da 1 a 5 sono scritti con le parole inglesi:
one, two, three, four, five allora sono state usate
 3  +  3  +  5  +  4  +  4 = 19 lettere in totale.

Se tutti i numeri da 1 a 1000 (one thousand) incluso fossero scritti con le parole inglesi, quante lettere occorrerebbe usare?

NOTA: non contare spazi o trattini. Ad esempio, 342 (three hundred and forty-two) contiene 23 lettere e 115 (one hundred and fifteen) contiene 20 lettere. L'uso di "and" quando si scrivono numeri è conforme all'uso britannico.
============================================================================

La soluzione è tediosa.

(setq n1-19 '("" "one" "two" "three" "four" "five" "six" "seven" "eight" "nine" "ten" "eleven" "twelve" "thirteen" "fourteen" "fifteen" "sixteen" "seventeen" "eighteen" "nineteen"))

(setq n20-90 '("" "" "twenty" "thirty" "forty" "fifty" "sixty" "seventy" "eighty" "ninety"))

(setq n100 "hundred")

; gli spazi non contano
(setq n100and "hundredand")

(setq n1000 "onethousand")

(define (e017)
  (local (n1-9 n10-19 n20-99 n100-999)
    (setq n1-9 (apply + (map length (1 9 n1-19))))
    (setq n10-19 (apply + (map length (10 19 n1-19))))
    (setq n20-99 (+ (* 10 (apply + (map length (2 9 n20-90))))
                    (* 8 n1-9)))
    (setq n100-999 (+ (* 100 (+ n1-9))
                      (* 9 (+ n1-9 n10-19 n20-99))
                            (* 9 (length n100))
                            (* 9 99 (length n100and))))
    (+ n1-9 n10-19 n20-99 n100-999 (length n1000))
  )
)

(e017)
;-> 21124

(time (e017))
;-> 0


===========
Problema 18
===========

Percorso con somma massima

Iniziando dalla parte superiore del triangolo in basso e passando ai numeri adiacenti sulla riga sottostante, il totale massimo dall'alto verso il basso è 23.

   3
  7 4
 2 4 6
8 5 9 3

Cioè, 3 + 7 + 4 + 9 = 23.

Trova il totale massimo dall'alto al basso del triangolo sottostante:

                            75
                          95 64
                        17 47 82
                      18 35 87 10
                    20 04 82 47 65
                  19 01 23 75 03 34
                88 02 77 73 07 63 67
              99 65 04 28 06 16 70 92
            41 41 26 56 83 40 80 70 33
          41 48 72 33 47 32 37 16 94 29
        53 71 44 65 25 43 91 52 97 51 14
      70 11 33 28 77 73 17 78 39 68 17 57
    91 71 52 38 17 14 91 43 58 50 27 29 48
  63 66 04 68 89 53 67 30 73 16 69 87 40 31
04 62 98 27 23 09 70 98 73 93 38 53 60 04 23

NOTA: poiché ci sono solo 16384 percorsi, è possibile risolvere questo problema provando ogni percorso.
============================================================================

La seguente soluzione è veramente "brutale".

(define (e018)
  (local (a aa b bb c cc d dd e ee f ff g gg h hh i ii j jj k kk l ll m mm n nn o oo somma sommaMax)
    (setq triangle '((75) (95 64) (17 47 82) (18 35 87 10) (20 4 82 47 65) (19 1 23 75 3 34) (88 2 77 73 7 63 67) (99 65 4 28 6 16 70 92) (41 41 26 56 83 40 80 70 33) (41 48 72 33 47 32 37 16 94 29) (53 71 44 65 25 43 91 52 97 51 14) (70 11 33 28 77 73 17 78 39 68 17 57) (91 71 52 38 17 14 91 43 58 50 27 29 48) (63 66 4 68 89 53 67 30 73 16 69 87 40 31) (4 62 98 27 23 9 70 98 73 93 38 53 60 4 23)))
    (setq a (triangle 0))
    (setq b (triangle 1))
    (setq c (triangle 2))
    (setq d (triangle 3))
    (setq e (triangle 4))
    (setq f (triangle 5))
    (setq g (triangle 6))
    (setq h (triangle 7))
    (setq i (triangle 8))
    (setq j (triangle 9))
    (setq k (triangle 10))
    (setq l (triangle 11))
    (setq m (triangle 12))
    (setq n (triangle 13))
    (setq o (triangle 14))
    (setq sommaMax 0)
    (setq somma 0)
    (for (bb 0 (- (length b) 1))
     (for (cc bb (+ bb 1))
       (for (dd cc (+ cc 1))
        (for (ee dd (+ dd 1))
         (for (ff ee (+ ee 1))
          (for (gg ff (+ ff 1))
           (for (hh gg (+ gg 1))
            (for (ii hh (+ hh 1))
             (for (jj ii (+ ii 1))
              (for (kk jj (+ jj 1))
               (for (ll kk (+ kk 1))
                (for (mm ll (+ ll 1))
                 (for (nn mm (+ mm 1))
                  (for (oo nn (+ nn 1))
                   (setq somma (+ (a 0) (b bb) (c cc) (d dd) (e ee) (f ff) (g gg) (h hh)
                                  (i ii) (j jj) (k kk) (l ll) (m mm) (n nn) (o oo)))
                   (if (> somma sommaMax) (swap somma sommaMax))
    ))))))))))))))
    sommaMax
  );local
)

(e018)
;-> 1074

(time (e018))
;-> 31.248

Una soluzione generica può essere ottenuta con la programmazione dinamica. In pratica per trovare la soluzione, ogni riga deve essere aggiunta a qualsiasi riga successiva, dal basso verso l'alto. Poiché ogni cella ha due predecessori, prendiamo il valore massimo delle due. Con questo metodo, la soluzione si trova nella cella superiore del triangolo:

var triangle = [
  [75],
  [95, 64],
  [17, 47, 82],
  [18, 35, 87, 10],
  [20, 04, 82, 47, 65],
  [19, 01, 23, 75, 03, 34],
  [88, 02, 77, 73, 07, 63, 67],
  [99, 65, 04, 28, 06, 16, 70, 92],
  [41, 41, 26, 56, 83, 40, 80, 70, 33],
  [41, 48, 72, 33, 47, 32, 37, 16, 94, 29],
  [53, 71, 44, 65, 25, 43, 91, 52, 97, 51, 14],
  [70, 11, 33, 28, 77, 73, 17, 78, 39, 68, 17, 57],
  [91, 71, 52, 38, 17, 14, 91, 43, 58, 50, 27, 29, 48],
  [63, 66, 04, 68, 89, 53, 67, 30, 73, 16, 69, 87, 40, 31],
  [04, 62, 98, 27, 23, 09, 70, 98, 73, 93, 38, 53, 60, 04, 23],
];

(define (e018-2)
  (let (tri '(
             (75)
             (95 64)
             (17 47 82)
             (18 35 87 10)
             (20 4 82 47 65)
             (19 1 23 75 3 34)
             (88 2 77 73 7 63 67)
             (99 65 4 28 6 16 70 92)
             (41 41 26 56 83 40 80 70 33)
             (41 48 72 33 47 32 37 16 94 29)
             (53 71 44 65 25 43 91 52 97 51 14)
             (70 11 33 28 77 73 17 78 39 68 17 57)
             (91 71 52 38 17 14 91 43 58 50 27 29 48)
             (63 66 4 68 89 53 67 30 73 16 69 87 40 31)
             (4 62 98 27 23 9 70 98 73 93 38 53 60 4 23)))
  (for (i (- (length tri) 2) 0 -1)
    (for (j 0 i)
      (setf (tri i j) (+ (tri i j) (max (tri (+ i 1) j) (tri (+ i 1) (+ j 1)))))
    )
  )
  (tri 0 0)))

(e018-2)
;-> 1074

(time (e018) 100)
;-> 655.032

(time (e018-2) 100)
;-> 3.021

La seconda funzione è 200 volte più veloce.


===========
Problema 19
===========

Conteggio delle domeniche

Ti vengono fornite le seguenti informazioni, ma potresti ricercare altre informazioni per te stesso.

- Il 1 gennaio 1900 era un lunedì.
- Trenta dì conta Novembre
  con April, Giugno e Settembre.
  Di ventotto ce n'è uno,
  Tutti gli altri ne han trentuno.

Un anno bisestile si verifica quando è divisibile per 4, ma non per un secolo (00) a meno che non sia divisibile per 400.

Quante domeniche caddero il primo del mese durante il ventesimo secolo (dal 1° gennaio 1901 al 31 dicembre 2000)?
============================================================================

Usiamo l'algoritmo di Gauss per determinare il giorno della settimana:

(define (day-of-week year month day) ; 0..6 --> Sun..Sat
    (letn ( d day
            m (+ (% (- month 3) 12) 1)
            Y (if (> m 10) (- year 1) year)
            y (% Y 100)
            c (/ (- Y y) 100)
            w (add d (floor (sub (mul 2.6 m) 0.2)) y (floor (div y 4)) (floor (div c 4)) (- (mul c 2)))
            w (% w 7)
          )
       (if (< w 0) (inc w 7) w))
)

Adesso la soluzione è abbastanza semplice:

(define (e019)
  (local (somma)
    (setq somma 0)
    (for (anno 1901 1999)
      (for (mese 1 12)
        (if (zero? (day-of-week anno mese 1)) (++ somma))
      )
    )
    somma
  )
)

(e019)
;-> 171

(time (e019))
;-> 2.997

Adesso utilizziamo l'algoritmo di Zeller per calcolare il giorno della settimana di una certa data:

(define (dayZ year month day)
  (local (adjust mm yy d)
    (setq adjust (/ (- 14 month) 12))
    (setq mm (+ month (* 12 adjust) (- 2)))
    (setq yy (- year adjust))
    (setq d (% (+ day (/ (- (* 13 mm) 1) 5) yy (/ yy 4) (- (/ yy 100)) (/ yy 400)) 7))
  )
)

(define (e019-2)
  (local (somma)
    (setq somma 0)
    (for (anno 1901 2000)
      (for (mese 1 12)
        (if (zero? (dayZ anno mese 1)) (++ somma))
      )
    )
    somma
  )
)

(e019-2)
;-> 171

(time (e019-2))
;-> 1.021

(time (e019) 1000)
;-> 854.296

(time (e019-2) 1000)
;-> 816.062


===========
Problema 20
===========

Somma di cifre fattoriali

n! significa n × (n - 1) × ... × 3 × 2 × 1

Ad esempio, 10! = 10 × 9 × ... × 3 × 2 × 1 = 3628800,
e la somma delle cifre nel numero 10! vale 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.

Trova la somma delle cifre nel numero 100!
============================================================================

Funzione fattoriale

(define (fact n) (apply * (map bigint (sequence 1 n))))

(explode (string (fact 10)))
;-> ("3" "6" "2" "8" "8" "0" "0" "L")

(map int (explode (string (fact 10))))
;-> (3 6 2 8 8 0 0 nil)

(define (e020)
  (apply + (map (fn (x) (int x 0)) (explode (string (fact 100)))))
)

(e020)
;-> 648

(time (e020))
;-> 0

Il creatore di newLISP (Lutz Mueller) ha scritto la seguente funzione che moltiplica due numeri interi passati come stringhe (è valida anche per numeri big-integer).

(define (big* x y) ; a and b are strings of decimal digits
    (letn ( nx (length x)
            ny (length y)
            np (+ nx ny)
            X (array nx (reverse (map int (explode x))))
            Y (array ny (reverse (map int (explode y))))
            Q (array (+ nx 1) (dup 0 (+ nx 1)))
            P (array np (dup 0 np))
            carry 0
            digit 0 )
        (dotimes (i ny) ; for each digit of the multiplier
            (dotimes (j nx) ; for each digit of the multiplicant
                (setq digit (+ (* (Y i) (X j)) carry) )
                (setq carry (/ digit 10))
                (setf (Q j) (% digit 10)) )
            (setf (Q nx ) carry)
            ; add Q to P shifted by i
            (setq carry 0)
            (dotimes (j (+ nx 1))
                (setq digit (+ (P (+ j i)) (Q j) carry))
                (setq carry (/ digit 10))
                (setf (P (+ j i)) (% digit 10)) )
        )
    ; translate P to string and return
    (setq P (reverse (array-list P)))
    (if (zero? (P 0)) (pop P))
    (join (map string P))
    )
)

Con la seguente soluzione al problema:

(define (e020-Lutz)
    (let (result "1")
        (for (i 2 100)
            (setq result (big* result (string i))))
        (apply + (map int (explode result))))
)

(e020-Lutz)
;-> 648

(time (e020-Lutz))
;-> 32.948


===========
Problema 21
===========

Numeri Amicabili

Definiamo d(n) come la somma dei divisori propri di n (tutti i numeri minori di n che dividono esattamente n).

Se d(a) = b e d(b) = a, dove a ≠ b,, allora a e b sono una coppia amicabile e a e b sono chiamati singolarmente numeri amicabili.

Per esempio, i divisori propri di 220 sono 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 e 110: quindi d(n) = 284. I divisori propri di 284 sono 1, 2, 4, 71 e 142: così d(284) = 220.

Calcolare la somma di tutti i numeri amicabili inferiori a 10000.
============================================================================

Definiamo la funzione che calcola la somma dei divisori di un numero:

(define (sum-divisors n)
  (setq res 0)
  (setq m (sqrt n))
  (setq i 2)
  (while (<= i m)
      (if (zero? (% n i))   ; se 'i' è divisore di 'n'
          (if (= i (/ n i))              ; se entrambi i divisori sono uguali...
            (setq res (+ res i))         ; allora aggiungilo una volta,
            (setq res (+ res i (/ n i))) ; altrimenti aggiungili entrambi.
          )
      )
      (setq i (+ i 1))
  )
  res
)

(sum-divisors 10)
;-> 7

Adesso dobbiamo definire la funzione che calcola i divisori propri:

(define (sum-proper-divisors n)
  (+ 1 (sum-divisors n))
)

(sum-proper-divisors 10)
;-> 8
(sum-proper-divisors 3)
;-> 1

(sum-proper-divisors 18)
;-> 21

(sum-proper-divisors 220)
;-> 284
(sum-proper-divisors 284)
;-> 220

Adesso scriviamo la funzione che calcola i numeri amicabili:

(define (e021)
  (setq _res 0)
  (for (j 1 9999)
      (setq spd (sum-proper-divisors j))
      (setq spd2 (sum-proper-divisors spd))
      (if (and (= j spd2) (!= spd spd2))
            (begin
              (setq _res (+ _res spd spd2))
              ;(println j { } spd { } spd2)
            )
      )
  )
  (/ _res 2)
)

(e021)
;-> 220 284 220
;-> 284 220 284
;-> 1184 1210 1184
;-> 1210 1184 1210
;-> 2620 2924 2620
;-> 2924 2620 2924
;-> 5020 5564 5020
;-> 5564 5020 5564
;-> 6232 6368 6232
;-> 6368 6232 6368
;-> 31626

(time (e021))
;-> 220.022

Una soluzione più efficiente si ottiene usando la seguente formula:
Siano p1, p2, ..., pk i fattori primi del numero n.
Siano a1, a2, ..., ak le potenze massime rispettivamente di p1, p2, ..., pk che dividono n (es. n = (p1^a1)*(p2^a2)*...*(pk^ak)).

Somma dei divisori = (1 + p1 + p1^2 ... p1^a1) *
                     (1 + p2 + p2^2 ... p2^a2) *
                     ......................... *
                     (1 + pk + pk^2 ... pk^ak)

Notiamo che i termini individuali di questa formula sono progressioni geometriche.
Possiamo riscrivere la formula come:

Somma dei divisori = (p1^(a1+1) - 1)/(p1 - 1) *
                     (p2^(a2+1) - 1)/(p2 - 1) *
                     ........................ *
                     (pk^(ak+1) - 1)/(pk - 1)

Vediamo un'applicazione della formula:

Consideriamo il numero 18.

(factor 18)
;-> (2 3 3)

Somma dei divisori = 1 + 2 + 3 + 6 + 9 + 18
(+ 1 2 3 6 9 18)
;-> 39

Scrivendo i divisori come potenze dei fattori primi otteniamo:

Somma di divisori = (2^0)(3^0) + (2^1)(3^0) + (2^0)(3^1) +
                    (2^1)(3^1) + (2^0)(3^2) + (2^1)(3^2)
                  = (2^0)(3^0) + (2^0)(3^1) + (2^0)(3^2) +
                    (2^1)(3^0) + (2^1)(3^1) + (2^1)(3^2)
                  = (2^0)(3^0 + 3^1 + 3^2) +
                    (2^1)(3^0 + 3^1 + 3^2)
                  = (2^0 + 2^1)(3^0 + 3^1 + 3^2)

Guardando attentamente, possiamo notare che l'ultima espressione è del tipo:

(1 + p1) * (1 + p2 + p2^2)

dove p1 = 2, p2 = 3.

Quindi: (1 + 2) * (1 + 3 + 9) = 3*13 = 39

Per trovare la somma dei divisori di un numero è sufficiente conoscere la sua scomposizione in fattori primi e applicare la seguente formula:

Somma dei divisori = Prod [(1 + f(i)^1 + ... + f(i)^k(i)]

dove [f(i), k(i)] è il fattore i-esimo con f = valore del fattore e k = potenza del fattore
e l'indice i varia da 1 al numero dei fattori.

Per trovare la somma dei divisori propria di un numero, basta sottrarre il numero stesso alla somma dei divisori ottenuta con la formula.

Esempio:

(fattorizza 18)
;-> ((2 1) (3 2))

somma dei divisori = (1 + p1 + p1^2 ... p1^a1) * (1 + p2 + p2^2 ... p2^a2) =
= (1 + 2) * (1 + 3 + 3^2) = 3 * 13 = 39

somma dei divisori propri = somma dei divisori - n = 39 - 18 = 21

Esempio:

(fattorizza 220)
;-> ((2 2) (5 1) (11 1))

p1 = 2  a1 = 2
p2 = 5  a2 = 1
p3 = 11 a3 = 1

(p1^(a1+1) - 1)/(p1 - 1) = (2^3 - 1)/(2 - 1) = 7
(p2^(a2+1) - 1)/(p2 - 1) = (5^2 - 1)/(5 - 1) = 6
(p3^(a3+1) - 1)/(p3 - 1) = (11^2 - 1)/(11 - 1) = 12

(* 6 7 12)
;-> 504

(- 504 220)
;-> 284 ; somma dei divisori propri di 220

Adesso possiamo scrivere la funzione che calcola i numeri amicabili:

(define (factor-group x)
  (if (= x 1) '(1 1)
    (letn (fattori (factor x)
          unici (unique fattori))
      (transpose (list unici (count unici fattori)))
    )
  )
)

(factor-group 220)
;-> ((2 2) (5 1) (11 1))

(factor-group 1)
;-> (1 1)

(define (somma-divisori-propri-fast n)
  (if (= n 1) '0
    (begin (setq res 1)
     (setq lst (factor-group n))
     (dolist (el lst)
       (setq somma-el 0)
       (for (i 0 (last el))
         (setq somma-el (+ somma-el (pow (first el) i)))
       )
       (setq res (* res somma-el))
     )
     (- res n)) ;somma divisori propri (tutti tranne se stesso)
  )
)

(somma-divisori-propri-fast 220)
;-> 284

(somma-divisori-propri-fast 284)
;-> 220

(somma-divisori-propri-fast 1)
;-> 0

Scriviamo la funzione richiesta dal problema:

(define (e021-2)
  (setq _res 0)
  (for (j 2 9999)
      (setq spd (somma-divisori-propri-fast j))
      (setq spd2 (somma-divisori-propri-fast spd))
      (if (and (= j spd2) (!= spd spd2))
            (begin
              (setq _res (+ _res spd spd2))
              ;(println j { } spd { } spd2)
            )
      )
  )
  (/ _res 2)
)

(e021-2)
;-> 31626

(time (e021-2))
;-> 122.883

la funzione "e021-fast" è tre volte più veloce della funzione "e021".


===========
Problema 22
===========

Punteggio dei nomi

Usando "names.txt", un file di testo 46K contenente oltre cinquemila nomi, inizia crando una lista dei nomi in ordine alfabetico. Quindi, calcolando il valore alfabetico per ciascun nome, moltiplica questo valore per la sua posizione alfabetica nella lista per ottenere un punteggio del nome.

Ad esempio, quando la lista è ordinata in ordine alfabetico, COLIN, che vale 3 + 15 + 12 + 9 + 14 = 53, è il 938-esimo nome nell'elenco. Quindi, COLIN otterrebbe un punteggio di 938 × 53 = 49714.

Qual è il totale di tutti i punteggi dei nomi contenuti nel file?
============================================================================

Il file ha questa struttura:
"MARY","PATRICIA","LINDA",...

Rimuoviamo tutti i caratteri doppio-apice "":

(define (remove-char c from-file to-file)
    (set 'in-file (open from-file "read"))
    (set 'out-file (open to-file "write"))
    (while (set 'chr (read-char in-file))
        (if (!= chr c)
          (write-char out-file chr)))
    (close in-file)
    (close out-file)
    "fatto")

(char {"})
;-> 34

(char 34)
;-> "\""

(remove-char 34 "p022_nomi.txt" "nomi22.txt")

Il file adesso ha questa struttura:

MARY,PATRICIA,LINDA,...

Importiamo il file in una lista di stringhe:

(silent (setq nomi (parse (read-file "nomi22.txt") ",")))

Vediamo i primi cinque nomi:

(slice nomi 0 5)
;-> ("MARY" "PATRICIA" "LINDA" "BARBARA" "ELIZABETH")

Ordiniamo la lista:

(silent (sort nomi))

Vediamo i primi cinque nomi:

(slice nomi 0 5)
;-> ("AARON" "ABBEY" "ABBIE" "ABBY" "ABDUL")

Vediamo dove si trova "COLIN":

(ref "COLIN" nomi )
;-> 937

Quindi dobbiamo aggiungere 1 all'indice della lista (+ $idx 1).
Adesso creiamo una lista associativa (association list) tra i caratteri e il numero del relativo ordine.

(setq alfa  '(("A" 1) ("B" 2) ("C" 3) ("D" 4) ("E" 5) ("F" 6) ("G" 7) ("H" 8) ("I" 9) ("J" 10) ("K" 11) ("L" 12) ("M" 13) ("N" 14) ("O" 15) ("P" 16) ("Q" 17) ("R" 18) ("S" 19) ("T" 20) ("U" 21) ("V" 22) ("W" 23) ("X" 24) ("Y" 25) ("Z" 26)))

(lookup '"A" alfa)
;-> 1

(define (e022)
  (local (somma nomesomma nome$)
    (setq somma 0)
    (dolist (el nomi)
      (setq nome$ (explode el))
      (setq nomesomma 0)
      (dolist (c nome$)
        (setq nomesomma (add nomesomma (lookup c alfa)))
      )
      (setq nomesomma (mul nomesomma (+ $idx 1)))
      (setq somma (add somma nomesomma))
    )
  )
)

(e022)
;-> 871198282

(time (e022))
;-> 20.016


===========
Problema 23
===========

Somma numeri non abbondanti

Un numero perfetto è un numero per il quale la somma dei relativi divisori è esattamente uguale al numero. Ad esempio, la somma dei divisori propri di 28 sarebbe 1 + 2 + 4 + 7 + 14 = 28, il che in dica che 28 è un numero perfetto.

Un numero n è chiamato carente se la somma dei suoi divisori è inferiore a n e viene chiamato abbondante se questa somma supera n.

Dato che 12 è il numero abbondante più piccolo, 1 + 2 + 3 + 4 + 6 = 12, il numero più piccolo che può essere scritto come somma di due numeri abbondanti è 24. Con l'analisi matematica, si può dimostrare che tutti gli interi superiori a 28123 possono essere scritti come somma di due numeri abbondanti. Tuttavia, questo limite superiore non può essere ulteriormente ridotto dall'analisi anche se è noto che il più grande numero che non può essere espresso come somma di due numeri abbondanti è inferiore a questo limite.

Trovare la somma di tutti i numeri interi positivi che non possono essere scritti come la somma di due numeri abbondanti.
============================================================================

Funzione che calcola la somma di tutti i divisori propri (tutti i divisori tranne se stesso) di un numero :
(vedi problema 21)

(define (factor-group x)
  (if (= x 1) '(1 1)
    (letn (fattori (factor x)
          unici (unique fattori))
      (transpose (list unici (count unici fattori)))
    )
  )
)

(define (somma-divisori-propri-fast n)
  (if (= n 1) '0
    (begin (setq res 1)
     (setq lst (factor-group n))
     (dolist (el lst)
       (setq somma-el 0)
       (for (i 0 (last el))
         (setq somma-el (+ somma-el (pow (first el) i)))
       )
       (setq res (* res somma-el))
     )
     (- res n)) ;somma divisori propri (tutti tranne se stesso)
  )
)

(somma-divisori-propri-fast 284235235345)
;-> 59865475031

Funzione che cerca una coppia di numeri in un vettore che sommano a num.
Questa funzione ha complessità temporale O(nlog(n)).

(define (trovaCoppia vec num)
  (local (low high a b out)
    ; ordina il vettore in ordine crescente
    (sort vec)
    ; indici che puntano all'inizio e alla fine dell'array
    (setq low 0)
    (setq high (- (length vec) 1))
    (while (and (< low high) (= out nil))
      (setq a (vec low))
      (setq b (vec high))
      ; vale anche la coppia formata dallo stesso numero ripetuto
      ; altrimenti il risultato vale: 4179935
      (if (or (= num (add a b)) (= num (add a a)) (= num (add b b)))
          ; coppia trovata
          (setq out true)
      )
      (if (< (add (vec low) (vec high)) num)
          ; incrementa l'indice basso se il totale è minore della somma
          (++ low)
          ; decrementa indice alto se è totale è maggiore della somma
          (-- high)
      )
    )
    out
  );local
)

(setq lst '( 123 73 64 7 8 6 5 4 3 4 5 6 7 ))
(setq v (array (length lst) lst))
(array? v)
;-> true

(trovaCoppia v 130)
;-> true

(trovaCoppia v 230)
;-> nil

(trovaCoppia v 246)
;-> true

Funzione che crea la lista dei numeri abbondanti fino al numero 28123.

(define (creaAbbondanti)
  (local (out)
    (setq out '())
    (for (i 1 28123)
      (if (< i (somma-divisori-propri-fast i))
        (push i out)
      )
    )
    out
  )
)

(silent (setq abbo (creaAbbondanti)))
(time (setq abbo (creaAbbondanti)))

(length abbo)
;-> 6965
(sort abbo)

(slice abbo 0 30)
;-> (12 18 20 24 30 36 40 42 48 54 56 60 66 70 72 78 80 84 88 90 96 100 102 104 108 112 114 120 126 132)

Adesso possiamo scrivere la funzione che trova i numeri richiesti dal problema:

(define (e023)
  (local (abbo-lst abbo somma out)
    (setq out '())
    (setq somma 0)
    (setq abbo-lst (creaAbbondanti))
    (setq abbo (array (length abbo-lst) abbo-lst))
    (for (i 1 28123)
      (if (not (trovaCoppia abbo i))
        (begin
          (setq somma (add somma i))
          (push i out -1)
        )
      )
    )
    (println somma)
    out
  )
)

(silent (setq res (e023)))
;-> 4179871

(slice res 0 100)
;-> (1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 25 26 27 28 29 31 33
;->  34 35 37 39 41 43 45 46 47 49 51 53 55 57 59 61 63 65 67 69 71 73 75 77 79 81 83
;->  85 87 89 91 93 95 97 99 101 103 105 107 109 111 113 115 117 119 121 123 125 127
;->  129 131 133 135 137 139 141 143 145 147 149 151 153 155 157 159 161 163 165 167
;->  169)

Sopra a 50 i numeri della somma sono tutti dispari, quindi dividiamo il ciclo for in due parti:

(define (e023)
  (local (abbo-lst abbo somma)
    (setq somma 0)
    (setq abbo-lst (creaAbbondanti))
    (setq abbo (array (length abbo-lst) abbo-lst))
    (for (i 1 50)
      (if (not (trovaCoppia abbo i))
          (setq somma (add somma i))
      )
    )
    (for (i 51 28123 2)
      (if (not (trovaCoppia abbo i))
          (setq somma (add somma i))
      )
    )
    somma
  )
)

(e023)
;-> 4179871

(time (e023))
;-> 40900.186 ; circa 41 secondi


===========
Problema 24
===========

Permutazioni lessicografiche

Una permutazione è una disposizione ordinata di oggetti. Ad esempio, 3124 è una possibile permutazione delle cifre 1, 2, 3 e 4. Se tutte le permutazioni sono ordinate numericamente o alfabeticamente, vengono chiamate in ordine lessicografico. Le permutazioni lessicografiche di 0, 1 e 2 sono:

012 021 102 120 201 210

Qual è la milionesima permutazione lessicografica delle cifre 0, 1, 2, 3, 4, 5, 6, 7, 8 e 9?
============================================================================

Definiamo la funzione che genera le permutazioni:

(define (seq start end)
  (if (= start end)
      (list end)
      (cons start (seq (+ start 1) end))))

(define (insert l n e)
  (if (= 0 n)
      (cons e l)
      (cons (first l)
            (insert (rest l) (- n 1) e))))

(define (permute l)
  (if (null? l) '(())
      (apply append (map (lambda (p)
                           (map (lambda (n) (insert p n (first l))) (seq 0 (length p))))
                         (permute (rest l))))))

Scriviamo la funzione finale:

(define (e024)
  (setq p (sort (permute '(0 1 2 3 4 5 6 7 8 9))))
  (int (join (map string (p 999999))))
)

Abbiamo ordinato le permutazioni poichè non vengono create in ordine lessicografico.

(e024)
;-> 2783915460

(time (e024))
;-> 25309.091  ;circa 25 secondi


===========
Problema 25
===========

Numero di Fibonacci a 1000 cifre

La sequenza di Fibonacci è definita dalla relazione di ricorrenza:

Fn = Fn-1 + Fn-2, dove F1 = 1 e F2 = 1.
Quindi i primi 12 termini saranno:

F1 = 1
F2 = 1
F3 = 2
F4 = 3
F5 = 5
F6 = 8
F7 = 13
F8 = 21
F9 = 34
F10 = 55
F11 = 89
F12 = 144

Il dodicesimo termine, F12, è il primo termine a contenere tre cifre.

Qual è l'indice del primo termine nella sequenza di Fibonacci che contiene 1000 cifre?
============================================================================

Funzione per calcolare i numeri di Fibonacci:

(define (fibo-i n)
  (local (a b c)
    (setq a 0L b 1L c 0L)
    (for (i 0 (- n 1))
      (setq c (+ a b))
      (setq a b)
      (setq b c)
    )
    a
  )
)

(fibo-i 12)
;-> 144L
(length (fibo-i 12))
;-> 3

(define (e025)
  (local (trovato num)
    (setq num 1)
    (while (not trovato)
      (if (> (length (fibo-i num)) 999)
        (setq trovato true)
      )
      (++ num)
    )
    (-- num)
  )
)

(e025)
;-> 4782

(time (e025))
;-> 4925.875


===========
Problema 26
===========

Periodo dei numeri reciproci

Una frazione unitaria contiene 1 nel numeratore. La rappresentazione decimale delle frazioni unitarie con i denominatori da 2 a 10 è data:

1/2 =  0.5
1/3 =  0.(3)
1/4 =  0.25
1/5 =  0.2
1/6 =  0.1(6)
1/7 =  0.(142857)
1/8 =  0.125
1/9 =  0.(1)
1/10 = 0.1

Dove 0.1 (6) significa 0.166666 ... e ha un ciclo ricorrente di 1 cifra. Si può vedere che 1/7 ha un ciclo ricorrente di 6 cifre.

Trova il valore di d <1000 per cui 1 / d contiene il ciclo ricorrente più lungo nella sua parte della frazione decimale.
============================================================================

Calcoliamo i resti della divisione, quando troviamo lo stesso resto per la seconda volta, allora abbiamo trovato un ciclo (se il rsto è diverso da zero.
La lunghezza del ciclo è uguale alla distanza in cui si trovano i due valori uguali di resto.

Esempio: 1/14

(% 1 14)
;-> 1
(% 10 14)
;-> 10
(% 100 14)
;-> 2
(% 1000 14)
;-> 6
(% 10000 14)
;-> 4
(% 100000 14)
;-> 12
(% 1000000 14)
;-> 8
(% 10000000 14)
;-> 10 ; il numero 10 è stato già trovato ==> stop

La lista vale: (1 10 2 6 4 12 8 10)

La distanza tra i due numeri 10 è la differenza tra gli indici: 7 - 1 = 6.
Se i due numeri uguali del resto valgono 0, allora il reciproco non ha cicli.

Adesso possiamo scrivere la funzione che calcola la lunghezza del ciclo del reciproco di un numero:

(define (ciclo n)
  (local (trovato lst resto len-ciclo idx)
    (setq lst '())
    (setq pot 1)
    (while (not trovato)
      (setq resto (% pot n))
      (if (= (find resto lst) nil ) (push resto lst -1)
          (begin
            (setq trovato true)
            (push resto lst -1)
            (setq idx (ref-all resto lst))
            (setq len-ciclo (- (first (last idx)) (first (first idx))))
          )
      )
      (setq pot (* 10L pot))
      ;(println pot)
    )
    ;se i numeri uguali del resto valgono 0, allora il ciclo vale 0.
    (if (= resto 0) (setq len-ciclo 0))
    ;(list len-ciclo lst (div 1 n))
    (list len-ciclo (div 1 n))
  )
)

(ciclo 14)
;-> (6 (1 10 2 6 4 12 8 10) 0.07142857142857143)

(ciclo 7)
;-> (6 (1 3 2 6 4 5 1) 0.1428571428571429)

(ciclo 2)
;-> (0 0.5)

(ciclo 3)
;-> (1 0.3333333333333333)

(ciclo 983)
;-> (982 0.001017293997965412)

(define (e026)
  (local (num maxciclo)
    (setq maxciclo 0)
    (for (i 1 1000)
      (setq c (ciclo i))
      (if (> c maxciclo)
        (setq maxciclo c num i)
      )
    )
    (list num maxciclo)
  )
)

(e026)
;-> (983 (982 0.001017293997965412))

(time (e026))
;-> 488.049


===========
Problema 27
===========

Eulero scoprì la notevole formula quadratica:  n^2 + n + 41

La formula produce 40 numeri primi per i valori interi consecutivi 0≤n≤39. Tuttavia, quando n = 40, 40^2 + 40 + 41 = 40 (40 + 1) + 41 è divisibile per 41, e certamente quando n = 41, 41^2 + 41 + 41 è chiaramente divisibile per 41.

È stata scoperta l'incredibile formula n^2 - 79n + 1601, che produce 80 numeri primi per i valori consecutivi 0≤n≤79. Il prodotto dei coefficienti, -79 e 1601, è -126479.

Considerando forme quadratiche del tipo:

n^2 + a*n + b, dove |a| < 1000 e |b| ≤ 1000

dove |n| è il valore assoluto di n

Per esempio: |11| = 11 e |-4| = 4

Trova il prodotto dei coefficienti, a e b, per l'espressione quadratica che produce il numero massimo di numeri primi per valori consecutivi di n, iniziando con n = 0.
============================================================================

(define (primo? n)
        (if (< n 2) nil
            (= 1 (length (factor n)))))

(define (e027)
  (local (aa bb num min_a max_a min_b max_b max_len primo lst)
    (setq min_a -999)
    (setq max_a 999)
    (setq min_b -1000)
    (setq max_b 1000)
    (for (a min_a max_a)
      (for (b min_b max_b)
        (setq primo true)
        (setq lst '())
        (setq num 1)
        (while primo
          (if (primo? (add (mul num num) (mul a num) b))
            (begin
              (push num lst)
              (if (> (length lst) max_len)
                (begin
                  (setq max_len (length lst))
                  (setq aa a)
                  (setq bb b)
                )
              )
              (++ num)
            )
          ;else
            (setq primo nil)
          );if
        );while
      );for
    );for
    (list (* aa bb) aa bb max_len)
  );local
)

(e027)
;-> (-59231 -61 971 71)

(time (e027))
;-> 2000.151

Proviamo a ricercare in un intervallo più grande (-10000 10000):

(define (test27 min_a max_a min_b max_b)
  (local (aa bb num max_len primo lst)
    (for (a min_a max_a)
      (for (b min_b max_b)
        (setq primo true)
        (setq lst '())
        (setq num 0)
        (while primo
          (if (primo? (add (mul num num) (mul a num) b))
            (begin
              (push num lst)
              (if (> (length lst) max_len)
                (begin
                  (setq max_len (length lst))
                  (setq aa a)
                  (setq bb b)
                )
              )
              (++ num)
            )
          ;else
            (setq primo nil)
          );if
        );while
      );for
    );for
    (list aa bb max_len)
  );local
)

(test27 -10000 10000 -10000 10000)
;-> (-79 1601 80)

Abbiamo trovato l'equazione presentata come esempio nel problema.

Facciamo un controllo:

(define (f n)
  (primo? (+ (* n n) (* (- 79) n) 1601)))

(f 2)

(count '(true) (map f (sequence 0 79)))
;-> (80)

(define (f1 n)
  (list (primo? (+ (* n n) (* (- 79) n) 1601)) (+ (* n n) (* (- 79) n) 1601)))

Proviamo ad eliminare la lista dei numeri primi ed usare solo un contatore per cercare di migliorare la velocità di esecuzione, inoltre :

(define (e027-2)
  (local (aa bb num min_a max_a min_b max_b max_len primo lst_len)
    (setq min_a -999)
    (setq max_a 999)
    (setq min_b -1000)
    (setq max_b 1000)
    (for (a min_a max_a)
      (for (b min_b max_b)
        (setq primo true)
        (setq lst_len 0)
        (setq num 0)
        (while primo
          (if (primo? (add (mul num num) (mul a num) b))
            (begin
              (++ lst_len)
              (if (> lst_len max_len)
                (begin
                  (setq max_len lst_len)
                  (setq aa a)
                  (setq bb b)
                )
              )
              (++ num)
            )
          ;else
            (setq primo nil)
          );if
        );while
      );for
    );for
    (list (* aa bb) aa bb max_len)
  );local
)

(e027-2)
;-> (-59231 -61 971 71)

(time (e027-2))
;-> 2015.211

Non abbiamo migliorato, sembra che il tempo dipenda quasi esclusivamente dai due cicli for :-)


===========
Problema 28
===========

Diagonale di numeri a spirale

Partendo dal numero 1 e spostandosi verso destra in senso orario, si forma una spirale 5 per 5 come segue:

21 22 23 24 25
20  7  8  9 10
19  6  1  2 11
18  5  4  3 12
17 16 15 14 13

Si può verificare che la somma dei numeri sulle diagonali sia 101:
(21 + 7 + 1 + 3 + 13 + 25 + 9 + 5 + 17) = 101 (l'elemento centrale (1) viene contato solo una volta).

Qual è la somma dei numeri sulle diagonali in una spirale 1001 per 1001 formata nello stesso modo?
============================================================================

Disegniamo una matrice più grande per poter individuare una funzione che possa generarer i valori dei numeri sulla diagonale in funzione della grandezza della matrice:

 73                      81
    43                49
       21 22 23 24 25
       20  7  8  9 10
       19  6  1  2 11
       18  5  4  3 12
       17 16 15 14 13
    37                31
 65                      57

(define (e028)
  (local (m somma a_d b_d b_s a_s alto_dx basso_dx basso_sx alto_sx)
    (setq m 1001)
    (setq somma 0)
    (setq a_d '())
    (setq b_d '())
    (setq a_s '())
    (setq b_s '())
    (for (i 1 (/ (- m 1) 2))
      (setq alto_dx (* (+ (* i 2) 1) (+ (* i 2) 1)))
      (setq basso_dx (- alto_dx (* 6 i)))
      (setq basso_sx (- alto_dx (* 4 i)))
      (setq alto_sx (- alto_dx (* 2 i)))
      ;(println alto_dx { } alto_sx { } basso_sx { } basso_dx)
      (push alto_dx a_d)
      (push basso_dx b_d)
      (push basso_sx b_s)
      (push alto_sx a_s)
    )
    (setq somma (+ (apply + a_d) (apply + a_s) (apply + b_d) (apply + b_s) 1))
  )
)

Con m = 5 e con l'espressione print attiva, otteniamo:

;-> 9 7 5 3
;-> 25 21 17 13
;-> 101

(e028)
;-> 669171001

(time (e028))
;-> 0


===========
Problema 29
===========

Potenze distinte

Considerare tutte le combinazioni intere di ab per 2 ≤ a ≤ 5 e 2 ≤ b ≤ 5:

2^2 = 4,  2^3 = 8,   2^4 = 16,  2^5 = 32
3^2 = 9,  3^3 = 27,  3^4 = 81,  3^5 = 243
4^2 = 16, 4^3 = 64,  4^4 = 256, 4^5 = 1024
5^2 = 25, 5^3 = 125, 5^4 = 625, 5^5 = 3125

Se vengono quindi posizionati in ordine numerico, con le eventuali ripetizioni rimosse, otteniamo la seguente sequenza di 15 termini distinti:

4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

Quanti termini distinti sono nella sequenza generata da a^b per 2 ≤ a ≤ 100 e 2 ≤ b ≤ 100?
============================================================================

(define (potenza n m)
  (setq pot 1L)
  (dotimes (x m)
    (setq pot (* pot n))
  )
)

(define (e029)
  ;(local (a b lst)
  (local (a b)
    (setq lst '())
    (for (a 2 100)
      (for (b 2 100)
        (push (potenza a b) lst)
      )
    )
    (setq lst (unique lst))
    (length lst)
  )
)

(e029)
;-> 9183

(time (e029))
;-> 140.608


===========
Problema 30
===========

Quinta potenza delle cifre

Sorprendentemente ci sono solo tre numeri che possono essere scritti come la somma delle quarte potenze delle loro cifre:

1634 = 1^4 + 6^4 + 3^4 + 4^4
8208 = 8^4 + 2^4 + 0^4 + 8^4
9474 = 9^4 + 4^4 + 7^4 + 4^4

La somma di questi numeri è 1634 + 8208 + 9474 = 19316.

Il numero 1 = 1^4 non viene incluso perchè non è una somma.

Trova la somma di tutti i numeri che possono essere scritti come somma delle quinte potenze delle loro cifre.
============================================================================

Funzione che estrae le cifre di un numero da sinistra verso destra:

(define (estraiCifre n)
  (local (cifra)
    (while (!= n 0)
      (setq cifra (% n 10))
      (setq n (/ n 10))
      (print cifra { })
    )
  )
)

(estraiCifre 1234)
;-> 4 3 2 1 " "

Precalcoliamo la quinta potenza di ogni cifra:

(setq pot5 (map (fn (x) (pow x 5)) '(0 1 2 3 4 5 6 7 8 9)))
;-> (0 1 32 243 1024 3125 7776 16807 32768 59049)

Funzione che calcola la somma delle quinte potenze di tutte le cifre di un numero:

(define (pot5Cifre n)
  (local (cifra somma)
    (setq somma 0)
    (while (!= n 0)
      (setq cifra (% n 10))
      (setq somma (+ somma (pot5 cifra)))
      (setq n (/ n 10))
    )
    somma
  )
)

(pot5Cifre 1634)
;-> 9044

Limite superiore:
max numero con 1 cifra = 9^5 = 56049
max numero con 2 cifre = 9^5 + 9^5 = 118098
max numero con 3 cifre = 9^5 + 9^5 + 9^5 = 177147
max numero con 4 cifre = 9^5 + 9^5 + 9^5 + 9^5 = 236196
max numero con 5 cifre = 9^5 + 9^5 + 9^5 + 9^5 + 9^5 = 295245
max numero con 6 cifre = 9^5 + 9^5 + 9^5 + 9^5 + 9^5 + 9^5 = 354294
max numero con 7 cifre = 9^5 + 9^5 + 9^5 + 9^5 + 9^5 + 9^5 + 9^5 = 413343

Quindi per essere sicuri di considerare tutti i numeri di cinque cifre formati dalla somma delle quinte potenze di ogni cifra occorre prendere il numero 295245 (perchè questo numero ha 6 cifre).

(* 5 (pow 9 5))
;-> 295245

(define (e030)
  (local (maxVal tot)
    (setq maxVal 295245)
    (setq tot 0)
    (for (i 2 maxVal)
      (setq x (pot5Cifre i))
      (if (= x i) (setq tot (+ tot x)))
    )
    tot
  )
)

(e030)
;-> 443839

(time (e030))
;-> 515.564


===========
Problema 31
===========

Somme di monete

In Inghilterra la moneta è composta da sterline "£" e pence "p" e ci sono in circolazione otto tipi di monete:

1p, 2p, 5p, 10p, 20p, 50p, £ 1 (100p) e £ 2 (200p)

È possibile arrivare a £ 2 nel modo seguente:

1 × £ 1 + 1 × 50p + 2 × 20p + 1 × 5p + 1 × 2p + 3 × 1p

In quanti modi diversi si può arrivare a £ 2 usando un numero qualsiasi di monete?
============================================================================

Soluzione forza-bruta:

(define (e031)
  (local (A B C D E F G q tot)
    (setq A (sequence 0 200))
    (setq B (sequence 0 200 2))
    (setq C (sequence 0 200 5))
    (setq D (sequence 0 200 10))
    (setq E (sequence 0 200 20))
    (setq F (sequence 0 200 50))
    (setq G (sequence 0 200 100))
    (setq q 1)
    (setq tot 200)
    (dolist (a A)
      (dolist (b B (> (+ a b) tot))
        (dolist (c C (> (+ a b c) tot))
          (dolist (d D (> (+ a b c d) tot))
            (dolist (e E (> (+ a b c d e) tot))
              (dolist (f F (> (+ a b c d e f) tot))
                (dolist (g G)
                  (if (= (+ a b c d e f g) tot) (++ q))
    )))))))
    q
  );local
)

(e031)
;-> 73682

(time (e031))
;-> 3009.901

Soluzione programmazione dinamica:

(define (e031)
  (local (totale monete modi)
    ; valore obiettivo
    (setq totale 200)
    ; lista dei tagli di monete disponibili
    (setq monete '(1 2 5 10 20 50 100 200))
    ; crea un vettore di totale elementi con tutti valori 0 tranne il primo (modi[0]) che vale 1
    (setq modi (array (+ totale 1) (extend '(1) (dup 0 totale))))
    (dolist (el monete)
      (for (i el totale)
        (setq (modi i) (+ (modi i) (modi (- i el))))
      )
    )
    (modi totale)
  )
)

(e031)
;-> 73682

(time (e031))
;-> 0.971


===========
Problema 32
===========

Prodotti Pandigitali

Diciamo che un numero con n cifre è pandigitale se fa uso di tutte le cifre da 1 a n esattamente una volta. Ad esempio, il numero a 5 cifre, 15234, è pandigitale da 1 a 5.

Il prodotto 7254 è inusuale, poiché l'identità 39 × 186 = 7254, contenente moltiplicando, moltiplicatore e prodotto è pandigitale da 1 a 9.

Trovare la somma di tutti i prodotti la cui identità in moltiplicando/moltiplicatore/prodotto è pandigitale da 1 a 9.

SUGGERIMENTO: alcuni prodotti possono essere ottenuti in più di un modo, quindi assicurati di includerlo solo una volta nella somma.
============================================================================

La seguente funzione verifica se un numero è pandigitale (1-9):

(define (pan? n)
  (cond ((or (< n 123456789) (> n 987654321) (!= 0 (% n 9))) nil)
        (true
          (let (lst '(0 -1 -1 -1 -1 -1 -1 -1 -1 -1))
            (while (!= n 0)
              (setf (lst (% n 10)) 1)
              (setq n (/ n 10))
            )
            ;(println lst)
            (if (ref '-1 lst) nil true)
          )
        )
  )
)

(pan? 391867254)
;-> true

(pan? 391877254)
;-> nil

Calcoliamo i limiti dei numeri coinvolti:

(* 999 99)
;-> 98901

(* 9999 9)
;-> 89991

999 * 99 = 98901 => 10 cifre (moltiplicando/moltiplicatore/prodotto)
9999 * 9 = 89991 => 10 cifre (moltiplicando/moltiplicatore/prodotto)

Quindi, il massimo valore del primo indice vale 99 e il massimo valore del secondo indice 9999. Si tratta di una stima grossolana che potrebbe essere migliorata.

Possiamo scrivere la soluzione:

(define (e032)
  (local (somma sol p)
    (setq sol '())
    (for (i 1 99)
      (for (j (+ i 1) 9999)
        (setq p (int (string i j (* i j))))
        (if (pan? p) (push (* i j) sol))
        ;(if (pan? p) (begin (push (* i j) sol) (println i { * } j { = } (* i j))))
      )
    )
    (setq sol (unique sol))
    (apply + sol)
  )
)

(e032)
;-> 45228

(time (e032))
;-> 1625.291

Ecco tutti i prodotti pandigitali:

 4 * 1738 = 6952
 4 * 1963 = 7852
12 *  483 = 5796 (a)
18 *  297 = 5346 (b)
27 *  198 = 5346 (b)
28 *  157 = 4396
39 *  186 = 7254
42 *  138 = 5796 (a)
48 *  159 = 7632

(+ 6952 7852 5796 5346 4396 7254 7632)
;-> 45228

===========
Problema 33
===========

Cancellazione di cifre nelle frazioni

La frazione 49/98 è una frazione curiosa, poiché un matematico inesperto nel tentativo di semplificarlo potrebbe erroneamente credere che 49/98 = 4/8, che è corretto, si ottiene cancellando le due cifre 9.

Considereremo frazioni come, 30/50 = 3/5, come esempi banali.

Esistono esattamente quattro esempi non banali di questo tipo di frazione, che hanno valore minore di 1, e contenenti due cifre nel numeratore e nel denominatore.

Se il prodotto di queste quattro frazioni viene ridotto ai minimi termini (semplificato), trovare il valore del denominatore.
============================================================================

Funzione che converte un numero intero in una lista:

(define (int2list n)
  (let (out '())
    (while (!= n 0)
      (push (% n 10) out)
      (setq n (/ n 10))
    )
    out
  )
)

La soluzione con la forza bruta è abbastanza semplice (e anche veloce):

(define (e033)
  (local (fraction frazione N D num numL den denL d d1 d2 n n1 n2 val)
    (setq fraction '())
    (for (num 11 100)
      (for (den (+ num 1) 100)
        (setq val (div num den))
        (setq frazione 0)
        (setq denL (int2list den))
        (setq d1 (int (denL 0)))
        (setq d2 (int (denL 1)))
        (setq numL (int2list num))
        (setq n1 (int (numL 0)))
        (setq n2 (int (numL 1)))
        (cond ((and (= n1 d2) (!= d1 0))
               (setq frazione (div n2 d1))
               (setq n n2)
               (setq d d1)
              )
              ((and (= n2 d1) (!= d2 0))
               (setq frazione (div n1 d2))
              )
              ((and (= n1 d1) (!= d2 0))
               (setq frazione (div n2 d2))
              )
              ((and (= n2 d2) (!= n2 0) (!= d1 0))
               (setq frazione (div n1 d1))
              )
        )
        (if (= frazione val) (push (list num den) fraction))
      )
    )
    (println fraction)
    (setq N (apply * (map first f)))
    (setq D (apply * (map last f)))
    (div D (gcd N D))
  );local
)

(e033)
;-> ((49 98) (26 65) (19 95) (16 64))
;-> 100

(time (e033))
;-> 31.235

Le quattro frazioni sono: 16/64 (1/4), 26/65 (2/5), 19/95 (1/5) e 49/98 (4/8).

Anche in questo problema possiamo utilizzare la matematica per trovare un algoritmo migliore.
Si può dimostrare che ogni frazione della soluzione deve essere della forma:

10*n + i    n
-------- = ---
10*i + d    d

dove numeratore "n" e denominatore "d" soddisfano la relazione: 1 <= n < d <= 9
e la variabile da eliminare "i" soddisfa la relazione: 1 <= i <= 9

Per evitare di utilizzare divisoni, troveremo le soluzioni verificando se vale l'uguaglianza:

d*(10*n + i) = n*(10*i + d)

(define (e033)
  (local (den num numtot dentot)
    (setq numtot 1 dentot 1)
    (for (i 1 9)
      (setq den 1)
      (while (< den i)
        (setq num 1)
        (while (< num den)
          (if (= (* den (+ (* num 10) i)) (* num (+ (* 10 i) den)))
            (begin
              (setq dentot (* dentot den))
              (setq numtot (* numtot num))
              ;(println num i {/} i den)
            )
          )
          (++ num)
        )
        (++ den)
      )
    )
    (/ dentot (gcd numtot dentot))
  )
)

(e033)
;-> 100

(time (e033))
;-> 0


===========
Problema 34
===========

Cifre fattoriali

145 è un numero curioso, poichè 1! + 4! + 5! = 1 + 24 + 120 = 145.

Trovare la somma di tutti i numeri che sono uguali alla somma del fattoriale delle loro cifre.

Nota: poichè 1! = 1 e 2! = 2 non sono somme, allora non vengono inclusi.
============================================================================

Precalcoliamo il fattoriale delle cifre 0..9:

(define (fact n) (if (= n 0) 1 (apply * (sequence 1 n))))

(setq fact-lst (map (fn(n) (fact n)) (sequence 0 9)))
;-> (1 1 2 6 24 120 720 5040 40320 362880)

Limiti dei numeri
Il numero 3 potrebbe andar bene, ma poiché il fattoriale di un numero di una cifra - eccetto 3 - ha sempre più di una cifra, allora possiamo iniziare con 10.
Il calcolo del limite superiore è un pò più complicato.
Se prendiamo un numero n con "d" cifre, possiamo scrivere:

 10^(d-1) <= n < 10^d

Per formare il numero massimo di "d" cifre dobbiamo utilizzare tutti 9, e la somma delle sue cifre fattoriali sarebbe d*9!, quindi:

 10^(d-1) <= d*9! < 10^d

Provando alcuni valori di "d" notiamo che 9!*7 = 2540160. Non esiste un valore più alto, poiché sia 9!*8 che 9!*9 generano ugualmente numeri di 7 cifre (9!*8 = 2903040, 9!*93265920). Quindi il numero 9999999 genera 7*9! = 2540160.

(define (e034)
  (local (fact-lst somma sol n)
    (setq fact-lst '(1 1 2 6 24 120 720 5040 40320 362880))
    (setq sol '())
    (for (i 10 2540160)
      (setq somma 0)
      (setq n i)
      (while (!= n 0)
        (setq somma (+ somma (fact-lst (% n 10))))
        (setq n (/ n 10))
      )
      (if (= somma i) (push i sol))
    )
    (list (apply + sol) sol)
  )
)

(e034)
;-> (40730 (40585 145))

(time (e034))
;-> 3797.395


===========
Problema 35
===========

Numeri primi circolari

Il numero, 197, è chiamato primo circolare perché tutte le rotazioni delle cifre: 197, 971 e 719, sono esse stesse prime.

Ci sono tredici tali numeri primi sotto 100: 2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79 e 97.

Quanti numeri primi circolari ci sono sotto un milione?
============================================================================

Abbiamo bisogno delle seguenti funzioni ausiliarie:

Verifica se un numero è primo:

(define (primo? n)
        (if (< n 2) nil
            (= 1 (length (factor n)))))

Converte un numero intero in una lista:

(define (int2list n)
  (let (out '())
    (while (!= n 0)
      (push (% n 10) out)
      (setq n (/ n 10))
    )
    out
  )
)

Converte una lista in un numero intero:

(define (list2int lst)
  (let (n 0)
    (for (i 0 (- (length lst) 1))
      (setq n (+ n (* (lst i) (pow 10 (- (length lst) i 1)))))
    )
  )
)

Crea una lista con tutte le rotazioni della lista passata:

(define (creaRotate lst)
  (let (out '())
    ;(for (i 1 (- (length lst) 1))
    (for (i 1 (length lst))
      (push (rotate lst) out)
    )
    out
  )
)

(apply + '(1 2 3 1 2 3) 3)
;-> 15
(creaRotate '(2))
;-> ((2))

(creaRotate '(1 2 3))
;-> ((1 2 3) (2 3 1) (3 1 2))

Adesso definiamo la funzione che risolve il problema:

(define (e035)
  (local (primicirco candidate stop k)
    (setq primicirco '(2)) ;lista risultato
    (setq candidate '())   ;lista rotazioni
    (for (i 3 999999 2)    ;solo numeri pari
      (if (primo? i)
        (begin
          ; creiamo la lista di tutti numeri ruotati del numero i
          (setq candidate (creaRotate (int2list i)))
          (setq stop nil)
          (setq k 0)
          (while (and (< k (length candidate)) (= stop nil))
            (if (!= k 0) ;il primo numero è sempre primo
              ;stop quando un numero della lista candidati non è primo
              (if (not (primo? (list2int (candidate k)))) (setq stop true))
            )
            (++ k)
          )
          ; se tutti i numeri nella lista candidati sono primi
          ; aggiungiamo la lista al risultato
          (if (= stop nil) (push (list2int (candidate (- k 1))) primicirco))
        )
      );if
    );for
    (list (length primicirco) primicirco)
  );local
)

(e035)
;-> (55 (199933 999331 193939 393919 993319 391939 939391 939193 933199 331999 319993
;->      919393 19937 19391 99371 39119 37199 93911 93719 71993 11939 91193 7937 1931 7793
;->      3779 9377 9311 1193 3119 199 197 991 373 971 337 733 131 919 719 113 311 79 97
;->      37 17 73 13 71 31 11 7 5 3 2))

(time (e035))
;-> 1266.715


===========
Problema 36
===========

Palindromi a doppia base

Il numero decimale, 585 = 10010010012 (binario), è palindromo in entrambe le basi.

Trova la somma di tutti i numeri, sotto al milione, che sono palindromi in base 10 e in base 2.

(Si noti che il numero palindromo, in entrambe le basi, non include gli zeri iniziali.)
============================================================================

Funzioni ausiliarie

Questa funzione controlla se un numero è palindromo:

(define (paliN n)
  (= (string n) (reverse (string n))))

(paliN 113311)
;-> true

(paliN 1123311)
;-> nil

Questa funzione controlla se una stringa è palindroma:

(define (paliS s)
  (= s (reverse (copy s))))

(paliS "1234321")
;-> true

(paliS "51234321")
;-> nil

Nota: I numeri pari non sono mai palindromi in base 2, perchè il bit a destra vale sempre 0 e il bit a sinistra vale sempre 1.

Nota: per controllare se un numero in base 2 è palindromo occorre utilizzare una stringa per rappresentarlo, perchè altrimenti il numero dovrebbe essere un big integer (con L alla fine).

La funzione finale è la seguente:

(define (e036)
  (let (somma 0)
    (for (i 1 999999 2) ;nessun numero pari palindromo in base 2
      (if (and (paliN i) (paliS (bits i)))
        (begin
          (setq somma (+ somma i))
          ;(println i { - } (bits i))
        )
      )
    )
    somma
  )
)

(e036)
;-> 872187

(time (e036))
;-> 1442.523

I numeri palindromi in entrambe le basi sono:

1 - 1
3 - 11
5 - 101
7 - 111
9 - 1001
33 - 100001
99 - 1100011
313 - 100111001
585 - 1001001001
717 - 1011001101
7447 - 1110100010111
9009 - 10001100110001
15351 - 11101111110111
32223 - 111110111011111
39993 - 1001110000111001
53235 - 1100111111110011
53835 - 1101001001001011
73737 - 10010000000001001
585585 - 10001110111101110001


===========
Problema 37
===========

Numeri primi troncabili

Il numero 3797 ha una proprietà interessante. Essendo primo se stesso, è possibile rimuovere continuamente i numeri da sinistra a destra, e rimanere primo in ogni fase: 3797, 797, 97 e 7. Allo stesso modo possiamo lavorare da destra a sinistra: 3797, 379, 37 e 3.

Trova la somma degli unici undici numeri primi che sono entrambi troncabili da sinistra a destra e da destra a sinistra.

NOTA: 2, 3, 5 e 7 non sono considerati numeri primi troncabili.
============================================================================

(define (creaTruncate lst)
  (let (out '())
    ; da destra
    (for (i 1 (- (length lst) 1))
      (push (slice lst 0 i) out)
    )
    ; da sinistra
    (for (i 1 (- (length lst) 1))
      (push (slice lst i) out)
    )
    out
  )
)

(setq lst '(3 7 9 7))

(creaTruncate lst)
;-> ((7) (9 7) (7 9 7) (3 7 9) (3 7) (3))

(define (int2list n)
  (let (out '())
    (while (!= n 0)
      (push (% n 10) out)
      (setq n (/ n 10))
    )
    out
  )
)

(define (list2int lst)
  (let (n 0)
    (for (i 0 (- (length lst) 1))
      (setq n (+ n (* (lst i) (pow 10 (- (length lst) i 1)))))
    )
  )
)

(define (primo? n)
  (if (= n 2) true
      (if (even? n) nil
          (if (< n 2) nil
              (= 1 (length (factor n)))))))

(define (e037)
  (local (primitrunca candidate trovati stop k i)
    (setq primitrunca '()) ;lista risultato
    (setq candidate '())   ;lista troncati
    (setq trovati 0)
    (setq i 11)
    (while (< trovati 11)
      (if (primo? i)
        (begin
          (setq candidate (creaTruncate (int2list i)))
          (setq stop nil)
          (setq k 0)
          (while (and (< k (length candidate)) (= stop nil))
            (if (not (primo? (list2int (candidate k)))) (setq stop true))
            (++ k)
          )
          (if (= stop nil)
            (begin
              ;(push (list2int (candidate (- k 1))) primitrunca)
              (push i primitrunca)
              (++ trovati)
            )
          )
        )
      );if
      (setq i (+ i 2))
      (if (= 0 (% i 10000)) (println i))
    );while
    (list (apply + primitrunca) primitrunca)
  );local
)

(e037)
;-> (748317 (739397 3797 3137 797 373 317 313 73 53 37 23))

(time (e037))
;-> 939.055

Proviamo a velocizzare l'algoritmo della funzione.
Considerazioni:
- non abbiamo bisogno di una lista per il risultato: basta usare una variabile (somma).
- non abbiamo bisogno di una lista per i numeri troncati: possiamo testarli appena generati.

Definiamo una funzione che controlla se un numero è truncabile a sinistra:

(define (truncaSX n)
  (local (i stop)
    (setq i 10)
    (while (and (<= i n) (= stop nil))
      (if (not (primo? (% n i))) (setq stop true))
      (setq i (* i 10))
    )
    (not stop)
  )
)

(truncaSX 3797)
;-> true

Definiamo una funzione che controlla se un numero è truncabile a destra:

(define (truncaDX n)
  (local (i stop)
    (setq i n)
    (while (and (!= 0 i) (= stop nil))
      (if (not (primo? i)) (setq stop true))
      (setq i (/ i 10))
    )
    (not stop)
  )
)

(truncaDX 3797)
;-> true

(define (e037)
  (local (trovati somma i)
    (setq somma 0)
    (setq i 11)
    (while (< trovati 11)
      (if (and (truncaDX i) (truncaSX i))
        (begin
          (setq somma (+ somma i))
          (++ trovati)
        )
      )
      (setq i (+ i 2))
    )
    somma
  )
)

(e037)
;-> 748317

(time (e037))
;-> 778.216


===========
Problema 38
===========

Multiplicazioni pandigitali

Prendi il numero 192 e moltiplicalo per i numeri 1, 2 e 3:

192 × 1 = 192
192 × 2 = 384
192 × 3 = 576

Concatenando ogni prodotto otteniamo il numero pandigitale da 1 a 9, 192384576. Chiameremo 192384576 il prodotto concatenato di 192 e (1,2,3)

Lo stesso può essere ottenuto iniziando con 9 e moltiplicando per 1, 2, 3, 4 e 5, che genera il pandigitale, 918273645, che è il prodotto concatenato di 9 e (1,2,3,4,5).

Qual è il più grande numero pandigitale da 1 a 9 (9 cifre) che può essere formato come prodotto concatenato di un numero intero con (1,2, ..., n) dove n > 1?
============================================================================

(define (pan? n)
  (cond ((or (< n 123456789) (> n 987654321) (!= 0 (% n 9))) nil)
        (true
          (let (lst '(0 -1 -1 -1 -1 -1 -1 -1 -1 -1))
            (while (!= n 0)
              (setf (lst (% n 10)) 1)
              (setq n (/ n 10))
            )
            ;(println lst)
            (if (ref '-1 lst) nil true)
          )
        )
  )
)

Per calcolare il limite superiore del ciclo basta considerare che con 10000 arriviamo a considerare numeri con 10 cifre (dobbiamo concatenare le stringhe delle moltiplicazioni), quindi questo valore è sufficiente.

(define (lim n)
  (length (append (string (* n 1)) (string (* n 2))))
)

(lim 9999)
;-> 9

(lim 10000)
;-> 10

(define (e038)
  (local (maxpandi theK theI pandisomma)
    (setq maxpandi 0)
    (setq theK 0)
    (setq theI 0)
    (for (k 1 10000)
      (setq pandisomma "")
      (for (i 1 9)
        (extend pandisomma (string (* k i)))
        (if (and (= (length pandisomma) 9) (> (int pandisomma) maxpandi) (pan? (int pandisomma)))
          (begin
            (setq maxpandi (int pandisomma))
            (setq theK k)
            (setq theI i)
          )
        )
      )
    )
    (list maxpandi theK theI)
  );local
)

(e038)
;-> (932718654 9327 2)

str(9327*1) + str(9327*2) = "932718654"

(time (e038))
;-> 93.757


===========
Problema 39
===========

Triangoli rettangoli interi

Se p è il perimetro di un triangolo rettangolo con lati di lunghezza intera, {a, b, c}, ci sono esattamente tre soluzioni per p = 120.

{20,48,52}, {24,45,51}, {30,40,50}

Per quale valore di p ≤ 1000, il numero di soluzioni è massimizzato?
============================================================================

(define (e039)
  (local (qmax lst a b p q)
    (setq qmax 0)
    (setq lst '())
    (for (p 12 1000 2)
      (setq q 0)
      (setq a 1)
      (while (< a (/ p 3))
        (setq b (+ a 1))
        (setq stop nil)
        (while (and (= stop nil) (< b (- p a)))
          (if (= (pow (- p a b) 2) (+ (* a a) (* b b)))
            (begin
              (++ q)
              (setq stop true)
            )
          )
          (++ b)
        )
        (++ a)
      )
      (if (> q qmax)
        (begin
          (setq lst (list p q))
          (setq qmax q)
        )
      )
    )
    lst
  );local
)

(e039)
;-> (840 8)

(time (e039))
;-> 13485.51


===========
Problema 40
===========

La costante di Champernowne

Una frazione decimale irrazionale viene creata concatenando gli interi positivi:

0.12345678910(1)112131415161718192021 ...

Si può vedere che la dodicesima cifra della parte frazionaria è (1).

Se d(n) rappresenta l'ennesima cifra della parte frazionaria, trovare il valore della seguente espressione:

d(1) × d(10) × d(100) × d(1000) × d(10000) × d(100000) × d(1000000)
============================================================================

La lunghezza della costante di Champernowne supera (di poco) il milione quando si arriva a concatenare il numero 186000:

(length (join (map string (sequence 0 186000))))
;-> 1004896

Quindi usiamo questo valore come limite per la creazione delle cifre del risultato:

(define (e040)
  (local (num cifre val x stop sol)
    (setq lst '())
    (setq stop nil)
    (setq num 1)
    (while (and (< num 186000) (= stop nil))
      (setq cifre (length (string num)))
      (setq val num)
      (for (i cifre 1 -1)
        (setq x (/ val (pow 10 (- i 1))))
        (setq val (- val (* x (pow 10 (- i 1)))))
        (push x lst -1)
      )
      ;(if (> (length lst) 1000000) (setq stop true))
      (++ num)
      ;(if (= (% num 10000) 0) (println num { } (length lst)))
    )
    (* (lst 0) (lst 9) (lst 99) (lst 999) (lst 9999) (lst 99999) (lst 999999))
  )
)

(e040)
;-> 210

(time (e040))
;-> 640.584

Proviamo un altro metodo, creiamo una stringa che contiene almeno 1000000 di cifre e poi calcoliamo il risultato della moltiplicazione:

(define (e040)
  (let (a$ (join (map string (sequence 1 186000))))
    (* (int (a$ 0)) (int (a$ 9)) (int (a$ 99)) (int (a$ 999)) (int (a$ 9999)) (int (a$ 99999)) (int (a$ 999999)))
  )
)

(e040)
;-> 210

(time (e040))
;-> 140.625


===========
Problema 41
===========

Primo Pandigitale

Diremo che un numero a una cifra è pandigitale se fa uso di tutte le cifre da 1 a n esattamente una volta. Ad esempio, 2143 è un pandigitale a 4 cifre ed è anche primo.

Qual è il più grande numero primo pandigitale ad n-cifre esistente?
============================================================================

I numeri pandigitali (0..9), quelli (1..9) e quelli (1..8) non sono primi perchè sono tutti divisibili per 9 (in quanto la somma delle loro cifre vale 9).
Quindi consideriamo solo i numeri pandigitali fino a 7 cifre.

Possiamo iniziare a creare tutte le permutazioni di 7 cifre e cercare il numero primo massimo (se esiste).
Poi potremmo passare ai numeri con 6 cifre, e via di questo passo.

Funzione per le permutazioni:

(define (rimuovi x lst)
  (cond
    ((null? lst) '())
    ((= x (first lst)) (rimuovi x (rest lst)))
    (true (cons (first lst) (rimuovi x (rest lst))))))

(define (permutazioni lst)
  (cond
    ((= (length lst) 1)(list lst))
    (true (apply append(map(lambda (i) (map (lambda (j)(cons i j))
                                            (permutazioni (rimuovi i lst)))) lst)))))

Funzione test numero primo:

(define (primo? n)
   (if (< n 2) nil
       (= 1 (length (factor n)))))

Scriviamo la funzione finale:

(define (e041)
  (local (perm num primi)
    ;crea le permutazioni
    (setq perm (permutazioni '("1" "2" "3" "4" "5" "6" "7")))
    ; crea la lista dei numeri
    (setq num (map (fn (x) (int (join x))) perm))
    ;filtra i numeri primi e poi cerca il valore massimo
    (apply max (filter primo? num))
  )
)

(e041)
;-> 7652413

(time (e041))
;-> 125.004


===========
Problema 42
===========

Numeri triangolari codificati

L'ennesimo termine della sequenza di numeri triangolari è dato da, t(n) = ½*n*(n + 1), quindi i primi dieci numeri di triangolari sono:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Convertendo ogni lettera di una parola in un numero corrispondente alla sua posizione alfabetica e aggiungendo questi valori formiamo un valore della parola. Ad esempio, il valore della parola per SKY è 19 + 11 + 25 = 55 = t10. Se il valore della parola è un numero triangolare, chiameremo la parola triangolo.

Usando il file "words.txt", un file di testo 16K contenente quasi duemila parole inglesi comuni, quante sono le parole triangolari?
============================================================================

Il file ha questa struttura:
"A","ABILITY","ABLE","ABOUT","ABOVE","ABSENCE","ABSOLUTELY",...

Rimuoviamo tutti i caratteri doppio-apice "":

(define (remove-char c from-file to-file)
    (set 'in-file (open from-file "read"))
    (set 'out-file (open to-file "write"))
    (while (set 'chr (read-char in-file))
        (if (!= chr c)
          (write-char out-file chr)))
    (close in-file)
    (close out-file)
    "fatto")

(char {"})
;-> 34

(char 34)
;-> "\""

(remove-char 34 "p042_words.txt" "words42.txt")

Il file adesso ha questa struttura:
A,ABILITY,ABLE,ABOUT,ABOVE,ABSENCE,ABSOLUTELY,

MARY,PATRICIA,LINDA,...

Importiamo il file in una lista di stringhe:

(silent (setq parole (parse (read-file "words42.txt") ",")))

Vediamo i primi cinque nomi:

(slice parole 0 5)
;-> ("A" "ABILITY" "ABLE" "ABOUT" "ABOVE")

Calcoliamo la lunghezza della parola più lunga:

(apply max (map length parole))
;-> 14

Il valore massimo di una parola vale 14 volte "Z";
(* 14 26)
;-> 364

Adesso creiamo una lista associativa (association list) tra i caratteri e il numero del relativo ordine:

(setq alfa  '(("A" 1) ("B" 2) ("C" 3) ("D" 4) ("E" 5) ("F" 6) ("G" 7) ("H" 8) ("I" 9) ("J" 10) ("K" 11) ("L" 12) ("M" 13) ("N" 14) ("O" 15) ("P" 16) ("Q" 17) ("R" 18) ("S" 19) ("T" 20) ("U" 21) ("V" 22) ("W" 23) ("X" 24) ("Y" 25) ("Z" 26)))

(lookup '"A" alfa)
;-> 1

Creiamo una lista di numeri triangolari (almeno fino a 364):

(setq tri (map (fn (n) (/ (* n (+ n 1)) 2)) (sequence 1 27)))
;-> (1 3 6 10 15 21 28 36 45 55 66 78 91 105 120 136 153 171 190 210 231 253 276 300 325 351 378)

Calcoliamo il valore della parola "ABILITY";

(setq valore 0)
(dolist (el (explode "ABILITY"))
  (setq valore (+ valore (lookup el alfa)))
)

;-> 78
A =  1
B =  2
I =  9
L = 12
I =  9
T = 20
Y = 25
   ----
    78

Vediamo se è un numero triangolare:

(ref 78 tri)
;-> (11)

Si tratta dell'undicesimo numero triangolare (se non fosse triangolare avremmo ottenuto nil dalla funzione "ref")

Possiamo scrivere la funzione finale:

(define (e042)
  (local (alfa tri valore out)
    (setq out 0)
    (setq alfa  '(("A" 1) ("B" 2) ("C" 3) ("D" 4) ("E" 5) ("F" 6) ("G" 7) ("H" 8) ("I" 9) ("J" 10) ("K" 11) ("L" 12) ("M" 13) ("N" 14) ("O" 15) ("P" 16) ("Q" 17) ("R" 18) ("S" 19) ("T" 20) ("U" 21) ("V" 22) ("W" 23) ("X" 24) ("Y" 25) ("Z" 26)))
    (setq tri (map (fn (n) (/ (* n (+ n 1)) 2)) (sequence 1 27)))
    (setq parole (parse (read-file "words42.txt") ","))
    (dolist (parola parole)
      (setq valore 0)
      (dolist (el (explode parola))
        (setq valore (+ valore (lookup el alfa)))
      )
      (if (ref valore tri) (++ out))
    )
    out
  )
)

(e042)
;-> 162

(time (e042))
;-> 31.244


===========
Problema 43
===========

Divisibilità sotto-stringhe

Il numero, 1406357289, è un numero da 0 a 9 pandigitale perché è composto da ciascuna delle cifre da 0 a 9 in un certo ordine, ma ha anche una proprietà di divisibilità della sotto-stringhe piuttosto interessante.

Sia d(1) la prima cifra, d(2) la seconda cifra e così via. In questo modo, notiamo quanto segue:

d(2)d(3)d(4) = 406 è divisibile per 2
d(3)d(4)d(5) = 063 è divisibile per 3
d(4)d(5)d(6) = 635 è divisibile per 5
d(5)d(6)d(7) = 357 è divisibile per 7
d(6)d(7)d(8) = 572 è divisibile per 11
d(7)d(8)d(9) = 728 è divisibile per 13
d(8)d(9)d(10) = 289 è divisibile per 17

Trovare la somma di tutti i numeri pandigital da 0 a 9 con questa proprietà.
============================================================================

Se d(4)d(5)d(6) è divisibile per 5, allora d(6) deve valere 5 (d(5) se zero-based).

(define (list2int lst)
  (let (n 0)
    (for (i 0 (- (length lst) 1))
      (setq n (+ n (* (lst i) (pow 10 (- (length lst) i 1)))))
    )
  )
)

(define (insert l n e)
  (if (= 0 n)
      (cons e l)
      (cons (first l)
            (insert (rest l) (- n 1) e))))

(define (seq start end)
  (if (= start end)
      (list end)
      (cons start (seq (+ start 1) end))))

(define (permute l)
  (if (null? l) '(())
      (apply append (map (lambda (p)
                           (map (lambda (n) (insert p n (first l))) (seq 0 (length p))))
                         (permute (rest l))))))

(define (e043)
  (local (numeri p10 a)
    (setq numeri '())
    (setq p10 (permute '(0 1 2 3 4 6 7 8 9)))
    (dolist (p p10)
      (if (!= (p 0) 0) ;scartare le permutazioni che iniziano con 0
        (begin
          (push 5 p 5) ; p(5) deve valere 5
          (setq n1 (+ (* (p 1) 100) (* (p 2) 10) (p 3)))
          (setq n2 (+ (* (p 2) 100) (* (p 3) 10) (p 4)))
          (setq n3 (+ (* (p 3) 100) (* (p 4) 10) (p 5)))
          (setq n4 (+ (* (p 4) 100) (* (p 5) 10) (p 6)))
          (setq n5 (+ (* (p 5) 100) (* (p 6) 10) (p 7)))
          (setq n6 (+ (* (p 6) 100) (* (p 7) 10) (p 8)))
          (setq n7 (+ (* (p 7) 100) (* (p 8) 10) (p 9)))
          (if (and (= (% n1 2) 0) (= (% n2 3) 0) (= (% n3 5) 0) (= (% n4 7) 0)
                   (= (% n5 11) 0) (= (% n6 13) 0) (= (% n7 17) 0))
              (push (list2int p) numeri)
          )
        )
      )
    )
    (list (apply + numeri) numeri)
  )
)

(e043)
;-> (16695334890 (4130952867 1430952867 4160357289 4106357289 1460357289 1406357289))

(time (e043))
;-> 1748.593


===========
Problema 44
===========

Numeri pentagonali

I numeri pentagonali sono generati dalla formula, P(n) = n*(3n-1)/2. I primi dieci numeri pentagonali sono:

1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

Si può vedere che P4 + P7 = 22 + 70 = 92 = P8. Tuttavia, la loro differenza, 70 - 22 = 48, non è pentagonale.

Trovare la coppia di numeri pentagonali, P(j) e P(k), per cui la loro somma e differenza sono pentagonali e D = |P(k) - P(j)| è ridotto al minimo: qual è il valore di D?
============================================================================

P(n) n-esimo numero pentagonale
N = numero dato

Affinchè un numero N sia pentagonale deve risultare:

P(n) = N  ==>  (3*n*n - n - 2*N) = 0  ==>  n = (1 + sqrt(24*N + 1))/6

Prima versione:

(define (penta? n)
  (let (i (div (add (sqrt (add 1 (mul 24 n))) 1) 6))
    (if (= 0 (sub i (int i))) true nil)
  )
)

Seconda versione (più veloce):

(define (penta? n)
; molto più veloce che cercare nella lista dei numeri pentagonali
  (if (= (mod (div (add (sqrt (+ 1 (mul 24 n))) 1) 6) 1) 0) true nil)
)

(penta? 176)
;-> true

(define (e044)
  (local (n penta stop i j out)
    (setq out nil)
    (setq penta (map (fn (n) (/ (* n (- (* 3 n) 1)) 2)) (sequence 1 10000)))
    (setq stop nil)
    (dolist (i penta (= stop true))
      (dolist (j penta (= stop true))
        (if (and (penta? (+ i j)) (penta? (abs (- i j))))
          (begin
            (setq stop true)
            (setq out (list i j (- j i)))
          )
        )
      )
    )
    out
  )
)

(e044)
;-> (1560090 7042750 5482660)

(time (e044))
;-> 5588.505


===========
Problema 45
===========

Triangolari, pentagonali ed esagonali

I numeri triangolari, pentagonali ed esagonali sono generati dalle seguenti formule:

Triangolari T(n) = n*(n + 1)/2 ==> 1, 3, 6, 10, 15, ...
Pentagonala P(n) = n*(3*n-1)/2 ==> 1, 5, 12, 22, 35, ...
Esagonale   H(n) = n*(2*n-1)   ==> 1, 6, 15, 28, 45, ...

Si può verificare che T(285) = P(165) = H(143) = (40755)

Trovare il prossimo numero triangolare che è anche pentagonale ed esagonale.
============================================================================

(define (tri n) (/ (* n (+ n 1)) 2))
(define (pen n) (/ (* n (- (* 3 n) 1)) 2))
(define (esa n) (* n (- (* 2 n) 1)))

(tri 285)
;-> 40755
(pen 165)
;-> 40755
(esa 143)
;-> 40755

Deve risultare:

t*(t + 1)/2 == p*(3*p-1)/2 == x*(2*x-1)

dove t -> indice triangolari
dove p -> indice pentagonali
dove x -> indice esagonali

La soluzione dell'uguaglianza:

t*(t + 1)/2 == x*(2*x-1)

vale: x = (t + 1)/2, t = 2*x - 1

Per t = 285 otteniamo x = (285 + 1)/2 = 143

Definiamo una funzione che genera l'indice del numero esagonale utilizzando l'indice del numero triangolare:

(define (xidx t) (/ (+ t 1) 2))

(xidx 285)
;-> 143

Vediamo come funziona:

(for (i 285 301 2)
  (println (tri i) { } (esa (xidx i))))
;-> 40755 40755
;-> 41328 41328
;-> 41905 41905
;-> 42486 42486
;-> 43071 43071
;-> 43660 43660
;-> 44253 44253
;-> 44850 44850
;-> 45451 45451

Adesso generiamo le tre sequenze di numeri:

(silent (setq trian (map tri (sequence 0 100000))))
(silent (setq penta (map pen (sequence 0 100000))))
(silent (setq esago (map esa (sequence 0 100000))))

Possiamo scrivere la soluzione controllando per ogni valore dell'indice del numero triangolare se esiste quel valore del numero triangolare nella lista dei numeri pentagonali:

(define (e045)
  (local (stop i)
    (setq i 287)
    (setq stop nil)
    (while (= stop nil)
      (setq x (xidx i))
      ;(if (ref (esa x) penta) (begin (println i { } x { } (ref (esa x) penta) { } (esa x)) (setq stop true)))
      (if (ref (tri i) penta) (begin (println i { } x { } (ref (esa x) penta) { } (esa x)) (setq stop true)))
      (if (zero? (% i 1000))  (println i))
      (setq i (+ i 2))
    )
  )
)

(e045)
;-> 55385 27693 (31977) 1533776805

(time (e045))
;-> 19343.289

Possiamo usare la funzione "intersect" di newLISP per trovare il risultato:

(define (e045)
  (local (trian penta esago)
    (setq trian (map tri (sequence 1 100000)))
    (setq penta (map pen (sequence 1 100000)))
    (setq esago (map esa (sequence 1 100000)))
    (intersect (intersect trian penta) esago)
  )
)

(e045)
;-> (1 40755 1533776805)

(time (e045))
;-> 114.465

Questa soluzione è molto più veloce.


===========
Problema 46
===========

L'altra congettura di Goldbach

È stato proposto da Christian Goldbach che ogni numero composito dispari può essere scritto come la somma di un numero primo e due volte un quadrato.

9 = 7 + 2 × 1^2
15 = 7 + 2 × 2^2
21 = 3 + 2 × 3^2
25 = 7 + 2 × 3^2
27 = 19 + 2 × 2^2
33 = 31 + 2 × 1^2

Si scopre che la congettura era falsa.

Qual'è il più piccolo numero composito dispari che non può essere scritto come somma di un numero primo e due volte quadrato?
============================================================================

Per ogni numero dispari x:
- se x è un numero composito (cioè è un numero non primo) ==> non trovato
- per i che va da 1 a (* i i 2) se (x - i * i * 2) è primo ==> non trovato
  altrimenti ==> trovato

Funzione per i numeri primi:

(define (primo? n)
   (if (< n 2) nil
       (= 1 (length (factor n)))))

Funzione che controlla se un numero soddisfa la congettura (se il numero è primo non soddisfa la congettura):

(define (check x)
  (local (out i stop limite)
    (cond ((primo? x) (setq out true))
          (true
            (setq i 1)
            (setq stop nil)
            (setq limite (* i i 2))
            (while (and (<= limite x) (= stop nil))
              (if (primo? (- x (* i i 2))) (begin (setq stop true) (setq out true)))
              (++ i)
              (setq limite (* i i 2))
            )
          )
    )
    out
  )
)

Scriviamo la funzione finale:

(define (e046)
  (local (num trovato)
    (setq num 11)
    (setq trovato false)
    (while (= trovato nil)
      (if (= (check num) nil) (setq trovato true))
      (setq num (+ num 2))
    )
    (- num 2)
  )
)


(e046)
;-> 5777

(time (e046))
;-> 31.247


===========
Problema 47
===========

Fattori primi distinti

I primi due numeri consecutivi con due fattori primi distinti sono:

14 = 2 × 7
15 = 3 × 5

I primi tre numeri consecutivi con tre fattori primi distinti sono:

644 = 2² × 7 × 23
645 = 3 × 5 × 43
646 = 2 × 17 × 19.

Trova i primi quattro numeri interi consecutivi con quattro fattori primi distinti ciascuno. Qual è il primo di questi numeri?
============================================================================

Funzione che calcola il numero di fattori primi distitni di un numero:

(define (numFattDist n) (length (unique (factor n))))

(numFattDist 12345)
;-> 3

Possiamo scrivere la funzione finale:

(define (e047)
  (local (stop i)
    (setq i 134043)
    (while (= stop nil)
      (if (and (= (numFattDist i) 4)
               (= (numFattDist (+ i 1)) 4)
               (= (numFattDist (+ i 2)) 4)
               (= (numFattDist (+ i 3)) 4))
          (setq stop true)
      )
      (++ i)
      (if (= (% i 1000000) 0) (println i))
    )
    (-- i)
  )
)

(e047)
;-> 134043

(time (e047))
;-> 0


===========
Problema 48
===========

Auto potenze

La serie, 1^1 + 2^2 + 3^3 + ... + 10^10 = 10405071317.

Trova le ultime dieci cifre della serie, 1^1 + 2^2 + 3^3 + ... + 1000^1000.
============================================================================

Funzione che calcola la potenza di numeri interi (anche per numeri big integer):

(define (potenza n m)
  (setq pot 1L)
  (dotimes (x m)
    (setq pot (* pot n))
  )
  pot
)

Creiamo una lista con tutti i numeri da 1 a 1000 elevati a se stessi:
(setq a (map (fn (x) (potenza x x)) (sequence 1L 1000L)))

Sommiano tutti i valori della lista:
(setq b (apply + a))

Trasformiano il numero somma in stringa ed estraiamo le ultime 10 cifre (senza la L finale):
(setq c (pop (string b) -11 10))
;-> "9110846700"

Scriviamo la funzione:

(define (e048)
  (pop (string (apply + (map (fn (x) (potenza x x)) (sequence 1L 1000L)))) -11 10)
)

(e048)
;-> "9110846700"

(time (e048))
;-> 265.614


===========
Problema 49
===========

Permutazioni prime

La sequenza aritmetica, 1487, 4817, 8147, in cui ciascun termine aumenta di 3330, è inusuale in due modi: (i) ciascuno dei tre termini è primo, e (ii) ciascuno dei numeri a 4 cifre è una permutazione degli altri.

Non ci sono sequenze aritmetiche composte da tre numeri primi di 1, 2 o 3 cifre, che esibiscono questa proprietà, ma esiste un'altra sequenza crescente di 4 cifre.

Quale numero di 12 cifre si forma concatenando i tre termini in questa sequenza?
============================================================================

Funzione per i numeri primi:

(define (primo? n)
   (if (< n 2) nil
       (= 1 (length (factor n)))))

Funzione che converte un numero in una lista:

(define (int2list n)
  (let (out '())
    (while (!= n 0)
      (push (% n 10) out)
      (setq n (/ n 10))
    )
    out
  )
)

Limiti da considerare nella ricerca della soluzione: da 1001 a 9999

Filtro i numeri primi:

(setq a (filter primo? (sequence 1001 9999)))
(length a)
;-> 1061

Funzione che controlla se due numeri hanno le stesse cifre:

(define (cifreUguali x y)
  (if (= (sort (int2list x)) (sort (int2list y))))
)

(cifreUguali 1234 4231)
;-> true

Controllo tutti gli elementi della lista dei numeri primi per vedere se soddisfano le condizioni del problema:

(dolist (el a)
  (setq a1 el)
  (setq a2 (+ a1 3330))
  (setq a3 (+ a2 3330))
  (if (and (primo? a2) (primo? a3) (cifreUguali a1 a2) (cifreUguali a2 a3))
    (println a1 { } a2 { } a3)
  )
)
;-> 1487 4817 8147
;-> 2969 6299 9629

Possiamo scrivere la funzione finale:

(define (e049)
  (local (primi a1 a2 a3 out)
    (setq primi (filter primo? (sequence 1001 9999)))
    (dolist (el primi)
      (setq a1 el)
      (setq a2 (+ a1 3330))
      (setq a3 (+ a2 3330))
      (if (and (primo? a2) (primo? a3) (cifreUguali a1 a2) (cifreUguali a2 a3))
        (setq out (string a1 a2 a3))
        ;(println a1 { } a2 { } a3)
      )
    )
    out
  )
)

(e049)
;-> "296962999629"

(time (e049))
;-> 9.01


===========
Problema 50
===========

Somma di primi consecutivi

Il primo 41 può essere scritto come la somma di sei numeri primi consecutivi:

41 = 2 + 3 + 5 + 7 + 11 + 13

Questa è la somma più lunga di numeri primi consecutivi che si aggiunge a un numero primo inferiore a cento.

La somma più lunga di numeri primi consecutivi al di sotto di un migliaio che aggiunge un numero primo, contiene 21 termini ed è uguale a 953.

Quale primo, inferiore a un milione, può essere scritto come la somma dei numeri primi più consecutivi?
============================================================================

Funzione per i numeri primi:

(define (primo? n)
   (if (< n 2) nil
       (= 1 (length (factor n)))))

Limiti da considerare nella ricerca della soluzione: da 2 a 1000000

Filtro i numeri primi:

(silent (setq primi (filter primo? (sequence 2 1000000))))
(length primi)
;-> 78490

(slice primi 0 10)

(define (e050)
  (local (primi lenprimi somma sommaMax limite i j stop)
    (setq somma 0)
    (setq limite -1)
    (setq primi (filter primo? (sequence 2 1000000)))
    (setq lenprimi (length primi))
    (setq i 2)
    (while (< i lenprimi)
      (setq somma 0)
      (setq stop nil)
      (setq j i)
      (while (and (< j lenprimi) (= stop nil))
        (setq somma (+ somma (primi j)))
        (if (> somma 1000000) (setq stop true)
        ;else
        (if (and (> (- j i) limite) (> somma sommaMax) (primo? somma))
          (begin
            (setq sommaMax somma)
            (setq limite (- j i))
          )
        ))
        (++ j)
      )
      (++ i)
      ;(if (= (% i 10000)) (println i))
    )
    sommaMax
  )
)

(e050)
;-> 997651

(time (e050))
;-> 27113

I numeri coinvolti nella soluzione sono i seguenti:

(997651 543 (7 11 13 17 19 23 29 31 37 41 43 47 53
59 61 67 71 73 79 83 89 97 101 103 107 109 113 127
131 137 139 149 151 157 163 167 173 179 181 191 193
197 199 211 223 227 229 233 239 241 251 257 263 269
271 277 281 283 293 307 311 313 317 331 337 347 349
353 359 367 373 379 383 389 397 401 409 419 421 431
433 439 443 449 457 461 463 467 479 487 491 499 503
509 521 523 541 547 557 563 569 571 577 587 593 599
601 607 613 617 619 631 641 643 647 653 659 661 673
677 683 691 701 709 719 727 733 739 743 751 757 761
769 773 787 797 809 811 821 823 827 829 839 853 857
859 863 877 881 883 887 907 911 919 929 937 941 947
953 967 971 977 983 991 997 1009 1013 1019 1021 1031
1033 1039 1049 1051 1061 1063 1069 1087 1091 1093 1097
1103 1109 1117 1123 1129 1151 1153 1163 1171 1181 1187
1193 1201 1213 1217 1223 1229 1231 1237 1249 1259 1277
1279 1283 1289 1291 1297 1301 1303 1307 1319 1321 1327
1361 1367 1373 1381 1399 1409 1423 1427 1429 1433 1439
1447 1451 1453 1459 1471 1481 1483 1487 1489 1493 1499
1511 1523 1531 1543 1549 1553 1559 1567 1571 1579 1583
1597 1601 1607 1609 1613 1619 1621 1627 1637 1657 1663
1667 1669 1693 1697 1699 1709 1721 1723 1733 1741 1747
1753 1759 1777 1783 1787 1789 1801 1811 1823 1831 1847
1861 1867 1871 1873 1877 1879 1889 1901 1907 1913 1931
1933 1949 1951 1973 1979 1987 1993 1997 1999 2003 2011
2017 2027 2029 2039 2053 2063 2069 2081 2083 2087 2089
2099 2111 2113 2129 2131 2137 2141 2143 2153 2161 2179
2203 2207 2213 2221 2237 2239 2243 2251 2267 2269 2273
2281 2287 2293 2297 2309 2311 2333 2339 2341 2347 2351
2357 2371 2377 2381 2383 2389 2393 2399 2411 2417 2423
2437 2441 2447 2459 2467 2473 2477 2503 2521 2531 2539
2543 2549 2551 2557 2579 2591 2593 2609 2617 2621 2633
2647 2657 2659 2663 2671 2677 2683 2687 2689 2693 2699
2707 2711 2713 2719 2729 2731 2741 2749 2753 2767 2777
2789 2791 2797 2801 2803 2819 2833 2837 2843 2851 2857
2861 2879 2887 2897 2903 2909 2917 2927 2939 2953 2957
2963 2969 2971 2999 3001 3011 3019 3023 3037 3041 3049
3061 3067 3079 3083 3089 3109 3119 3121 3137 3163 3167
3169 3181 3187 3191 3203 3209 3217 3221 3229 3251 3253
3257 3259 3271 3299 3301 3307 3313 3319 3323 3329 3331
3343 3347 3359 3361 3371 3373 3389 3391 3407 3413 3433
3449 3457 3461 3463 3467 3469 3491 3499 3511 3517 3527
3529 3533 3539 3541 3547 3557 3559 3571 3581 3583 3593
3607 3613 3617 3623 3631 3637 3643 3659 3671 3673 3677
3691 3697 3701 3709 3719 3727 3733 3739 3761 3767 3769
3779 3793 3797 3803 3821 3823 3833 3847 3851 3853 3863
3877 3881 3889 3907 3911 3917 3919 3923 3929 3931))


===========
Problema 51
===========

Sostituzioni di cifre nei numeri primi

Sostituendo la prima cifra del numero a 2 cifre *3, si scopre che sei dei nove valori possibili: 13, 23, 43, 53, 73 e 83, sono tutti primi.

Sostituendo la terza e la quarta cifra di 56**3 con la stessa cifra, questo numero di 5 cifre è il primo esempio con sette numeri primi tra i dieci numeri generati, dando la famiglia: 56003, 56113, 56333, 56443, 56663, 56773 e 56993. Di conseguenza 56003, essendo il primo membro di questa famiglia, è il primo più piccolo con questa proprietà.

Trova il primo più piccolo che, sostituendo parte del numero (non necessariamente cifre adiacenti) con la stessa cifra, fa parte di una famiglia di otto valori primi.
============================================================================

Prima di scrivere la soluzione abbiamo bisogno di alcune funzioni ausiliarie.

Funzione che genera tutti i numeri primi da m a n:

(define (sieve-from-to m n)
  (local (arr lst out)
    (setq out '())
    (setq arr (array (+ n 1)) lst '(2))
    (for (x 3 n 2)
        (when (not (arr x))
          (push x lst -1)
          (for (y (* x x) n (* 2 x) (> y n))
              (setf (arr y) true))))
    (if (<= m 2)
        lst
        (dolist (el lst) (if (>= el m) (push el out -1)))
    )
  )
)

Funzione che conta le occorrenze di un carattere in una stringa:

(define (conta-char stringa carattere)
  (let (out 0)
    (dolist (el (explode stringa))
      (if (= carattere el) (++ out))) out))

(conta-char "451234555" "5")
;-> 4

Funzione che sostituisce caratteri (char-old -> char-new) in una stringa:

(define (cambia-char stringa char-old char-new)
  (let (out "")
    (dolist (el (explode stringa))
      (if (= char-old el)
        (write out char-new)
        (write out el)))
    out))

(cambia-char "12345543215" "5" "0")
;-> "12340043210"

Funzione che verifica la primalità di un numero:

(define (primo? n)
  (if (< n 2) nil
    (if (= 1 (length (factor n))))))

Infine la funzione soluzione (brute-force):

(define (e051 n)
  (local (cycleMaxL primi numS ciclo cycleL uguali newnum found)
    (setq found nil)
    (setq primi (sieve-from-to 100000 n))
    (dolist (num primi found)
      (setq numS (string num))
      (dolist (cifra (explode "1234567890") found)
        (setq ciclo 0)
        (setq cycleL '())
        (setq uguali (conta-char numS cifra))
        (if (= uguali 3)
          ;(dolist (nuovo (explode "1234567890"))
          (dolist (nuovo (explode "1234567890") found)
            (setq newnum (cambia-char numS cifra nuovo))
            (if (= (length newnum) (length numS))
              (if (primo? (int newnum))
                (begin (++ ciclo)
                       (push (int newnum) cycleL -1))
              )
            )
          )
        )
        (if (> (length cycleL) (length cycleMaxL))
          (begin (setq cycleMaxL cycleL)
                 (if (>= (length cycleMaxL) 8)
                   (begin (setq found true)
                    (println "Sol: " numS { } (slice cycleMaxL 0 8)))
                    ;(println "Sol: " numS { } cycleMaxL)))
                 ))
        )
      )
    )
    'end
  )
)

(e051 999999)
;-> Sol: 121313 (121313 222323 323333 424343 525353 626363 828383 929393)
;-> end

(time (e051 999999))
;-> Sol: 121313 (121313 222323 323333 424343 525353 626363 828383 929393)
;-> 269.946


===========
Problema 52
===========

Permutazione di multipli

Si può vedere che il numero 125874 e il suo doppio 251748 contengono esattamente le stesse cifre, ma in un ordine diverso.

Trova il numero intero positivo più piccolo x, tale che 2x, 3x, 4x, 5x e 6x contengano le stesse cifre.
============================================================================

Funzione che verifica se due numeri hanno le stesse cifre:

(define (same-digit m n)
  (if (!= (length m) (length n))
      nil
      (= (sort (explode (string m))) (sort (explode (string n))))))

(same-digit 1234 4321)
;-> true

(same-digit 12341 4321)
;-> nil

(define (e052)
  (let ((i 10)
        (continua true))
    (while continua
      (if (and (same-digit i (* 2 i))
               (same-digit i (* 3 i))
               (same-digit i (* 4 i))
               (same-digit i (* 5 i))
               (same-digit i (* 6 i)))
          (setq continua nil))
      (++ i)
    )
    (- i 1)))

(e052)
;-> 142857

(time (e052))
;-> 313.15


===========
Problema 53
===========

Selezione di combinazioni

Esistono esattamente dieci modi per selezionare tre cifre tra cinque cifre 1, 2, 3, 4 e 5): 123, 124, 125, 134, 135, 145, 234, 235, 245 e 345
                                      (5)
In combinatoria, si usa la notazione, ( ) = 10.
                                      (3)

In generale,

(n)         n!
( ) = --------------- , dove r <= n
(r)    r! * (n - r)!

e n! = 1 * 2 * 3 * ... * (n - 1) * n

Il numero n = 23 ha il primo valore che supera il milione:

(23)
(  ) = 1144066
(10)
                                                (n)
Quanti valori, non necessariamente distinti, di (r) per 1<=n<=100, sono maggiori di un milione?
============================================================================

Formula che calcola il binomiale (big-integer):

(define (binom n k)
  (local (M q)
    (setq M (array (+ n 1) (+ k 1) '(0L)))
    (for (i 0 n)
      (setq q (min i k))
      (for (j 0 q)
        (if (or (= j 0) (= j i))
          (setq (M i j) 1L)
          (setq (M i j) (+ (M (- i 1) (- j 1)) (M (- i 1) j)))
        )
      )
    )
    (M n k)
  );local
)

(binom 23 10)
;-> 1144066L

Funzione soluzione:

(define (e053 n)
  (let (quanti 0)
    (for (i 1 n)
      (for (j 1 i)
        (if (> (binom i j) 1e6) (++ quanti))))
    quanti))

(e053 100)
;-> 4075

(time (e053 100))
;-> 6231.481

Per velocizzare la soluzione, proviamo a non usare i big integer nella funzione che calcola il binomiale.

(define (binom n k)
  (local (M q)
    (setq M (array (+ n 1) (+ k 1) '(0)))
    (for (i 0 n)
      (setq q (min i k))
      (for (j 0 q)
        (if (or (= j 0) (= j i))
          (setq (M i j) 1)
          (setq (M i j) (+ (M (- i 1) (- j 1)) (M (- i 1) j)))
        )
      )
    )
    (M n k)
  );local
)

(binom 23 10)
;-> 1144066

I numeri binomiali che superano il valore massimo per gli int64 diventano negativi, quindi usiamo la funzione "abs" per considerarli maggiori di 10 milioni.

(define (e053 n)
  (let (quanti 0)
    (for (i 1 n)
      (for (j 1 i)
        (if (> (abs (binom i j)) 1e6) (++ quanti))))
    quanti))

(e053 100)
;-> 4075

(time (e053 100))
;-> 3522.499

Abbiamo quasi raddoppiato la velocità, ma il problema è la lentezza della funzione che calcola il binomiale. Proviamo un altro metodo: poichè il numero n arriva solo fino a 100, possiamo precalcolare il fattoriale dei primi 100 numeri e usarli per calcolare il binomiale con la formula originale.

Funzione fattoriale (big-integer):

(define (fact n) (apply * (map bigint (sequence 1 n))))

Funzione binomiale (big-integer):

(define (bino n r) (/ (f n) (* (f r) (f (- n r)))))

Adesso riscriviamo la funzione soluzione:

(define (e053)
  (local (quanti f)
    (setq quanti 0)
    ;precalcolo dei fattoriali da 0 a 100
    (setq f (map fact (sequence 0 100)))
    (for (i 1 100)
      (for (j 1 i)
        ; la differenza tra gli indici deve essere
        ; maggiore di 0 affinchè (bino i j) possa
        ; essere maggiore di un milione.
        ; Infatti (bino x x) = 1
        (if (> (- i j) 0)
          (if (> (bino i j) 1e6) (++ quanti)))))
    quanti))

(e053)
;-> 4075

(time (e053))
;-> 25.013

Questa volta la risposta di newLISP è immediata.


===========
Problema 54
===========

Mani di poker

Nel gioco del poker, una mano è composta da cinque carte e sono classificate, dalla più bassa alla più alta, nel modo seguente:

Carta alta: carta di valore più alto.
Una coppia: due carte dello stesso valore.
Due coppie: due coppie diverse.
Tris: tre carte dello stesso valore.
Scala: tutte le carte hanno valori consecutivi.
Colore: tutte le carte sono dello stesso seme.
Full: un tris e una coppia.
Poker: quattro carte dello stesso valore.
Scala reale: tutte le carte sono valori consecutivi dello stesso seme.
Scala reale massima: dieci, Jack, Queen, King, Asso dello stesso seme.
Le carte sono valutate nell'ordine:
2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, King, Asso

Se due giocatori hanno mani dello stesso valore, allora vince quello che ha il valore composto più alto(per esempio, una coppia di otto batte una coppia di cinque, vedi esempio 1 sotto). Ma se abbiamo un pareggio tra ranghi uguali, ad esempio entrambi i giocatori hanno una coppia di regine, vengono confrontate le carte più alte in ogni mano (vedi esempio 4 di seguito). Se le carte più alte sono uguali, allora vengono confrontate le carte più alte successive e così via.

Considera le seguenti cinque mani distribuite a due giocatori:

Hand   Player 1             Player 2               Winner
1      5H 5C 6S 7S KD       2C 3S 8S 8D TD         Player 2
       Pair of Fives        Pair of Eights

2      5D 8C 9S JS AC       2C 5C 7D 8S QH         Player 1
       Highest card Ace     Highest card Queen

3      2D 9C AS AH AC       3D 6D 7D TD QD         Player 2
       Flush with Diamonds  Three Aces

4      4D 6S 9H QH QC       3D 6D 7H QD QS         Player 1
       Pair of Queens       Pair of Queens
       Highest card Nine    Highest card Seven

5      2H 2D 4C 4D 4S       3C 3D 3S 9S 9D         Player 1
       Full House           Full House
       With Three Fours     with Three Threes

Il file "poker.txt" contiene mille mani casuali distribuite a due giocatori. Ogni riga del file contiene dieci carte (separate da un singolo spazio): le prime cinque sono le carte del giocatore 1 e le ultime cinque sono le carte del giocatore 2. Puoi presumere che tutte le mani siano valide (nessun carattere non valido o carte ripetute), la mano di ogni giocatore non è in un ordine specifico e in ogni mano c'è un chiaro vincitore.

Quante mani vince il giocatore 1?
============================================================================

Vediamo come vengono rappresentati i semi:

H = Hearts (Cuori)
D = Diamonds (Quadri)
C = Clubs (Fiori)
S = Spades (Picche)

Vediamo i passi della soluzione con il file "poker.txt" (che ha solo 10 mani):

(setq raw (read-file "poker.txt"))
"8C TS KC 9H 4S 7D 2S 5D 3S AC\r\n
 5C AD 5D AC 9C 7C 5H 8D TD KS\r\n
 3H 7H 6S KC JS QH TD JC 2D 8S\r\n
 TH 8H 5C QS TC 9H 4D JC KS JS\r\n
 7C 5H KC QH JD AS KH 4C AD 4S\r\n
 5H KS 9C 7D 9H 8D 3S 5D 5C AH\r\n
 6H 4H 5C 3H 2H 3S QH 5S 6S AS\r\n
 TD 8C 4H 7C TC KC 4C 3H 7S KS\r\n
 7C 9C 6D KD 3H 4C QS QC AC KH\r\n
 JC 6S 5H 2H 2D KD 9D 7C AS JS"

Usiamo la funzione "parse" per ottenere solo una stringa che rappresenta una mano:

(setq data (parse raw "\r\n"))
;-> ("8C TS KC 9H 4S 7D 2S 5D 3S AC"
;->  "5C AD 5D AC 9C 7C 5H 8D TD KS"
;->  "3H 7H 6S KC JS QH TD JC 2D 8S"
;->  "TH 8H 5C QS TC 9H 4D JC KS JS"
;->  "7C 5H KC QH JD AS KH 4C AD 4S"
;->  "5H KS 9C 7D 9H 8D 3S 5D 5C AH"
;->  "6H 4H 5C 3H 2H 3S QH 5S 6S AS"
;->  "TD 8C 4H 7C TC KC 4C 3H 7S KS"
;->  "7C 9C 6D KD 3H 4C QS QC AC KH"
;->  "JC 6S 5H 2H 2D KD 9D 7C AS JS")

Adesso se vogliamo ottenere una lista per ogni riga, basta mappare la funzione "list" sugli elementi della lista data:

(setq data (map list data))
;-> (("8C TS KC 9H 4S 7D 2S 5D 3S AC")
;->  ("5C AD 5D AC 9C 7C 5H 8D TD KS")
;->  ("3H 7H 6S KC JS QH TD JC 2D 8S")
;->  ("TH 8H 5C QS TC 9H 4D JC KS JS")
;->  ("7C 5H KC QH JD AS KH 4C AD 4S")
;->  ("5H KS 9C 7D 9H 8D 3S 5D 5C AH")
;->  ("6H 4H 5C 3H 2H 3S QH 5S 6S AS")
;->  ("TD 8C 4H 7C TC KC 4C 3H 7S KS")
;->  ("7C 9C 6D KD 3H 4C QS QC AC KH")
;->  ("JC 6S 5H 2H 2D KD 9D 7C AS JS"))

Dobbiamo cambiare i valori dei caratteri:
('A','14')
('K','13')
('Q','12')
('J','11')
('T','10')

e creiamo la seguente struttura per i dati per ogni mano:

((valori-p1) (semi-p1) (valori-p2) (semi-p2))

(setq mani '())
(dolist (el data)
  (setq row (first el))
  ;(println row)
  (setq val-p1 (explode (select row '(0 3 6 9 12))))
  (replace "A" val-p1 "14")
  (replace "K" val-p1 "13")
  (replace "Q" val-p1 "12")
  (replace "J" val-p1 "11")
  (replace "T" val-p1 "10")
  (setq val-p1 (sort (map int val-p1)))
  (setq val-p2 (explode (select row '(15 18 21 24 27))))
  (replace "A" val-p2 "14")
  (replace "K" val-p2 "13")
  (replace "Q" val-p2 "12")
  (replace "J" val-p2 "11")
  (replace "T" val-p2 "10")
  (setq val-p2 (sort (map int val-p2)))
  ; i semi non vengono ordinati perchè ci servono
  ; solo per calcolare "colore"
  (setq sem-p1 (select row '(1 4 7 10 13)))
  (setq sem-p2 (select row '(16 19 22 25 28)))
  (push (list val-p1 sem-p1 val-p2 sem-p2) mani -1)
  mani
)

;-> (((4 8 9 10 13) "CSCHS" (2 3 5 7 14) "DSDSC")
;->  ((5 5 9 14 14) "CDDCC" (5 7 8 10 13)  "CHDDS")
;->  ((3 6 7 11 13) "HHSCS" (2 8 10 11 12) "HDCDS")
;->  ((5 8 10 10 12) "HHCSC" (4 9 11 11 13) "HDCSS")
;->  ((5 7 11 12 13) "CHCHD" (4 4 13 14 14) "SHCDS")
;->  ((5 7 9 9 13) "HSCDH" (3 5 5 8 14) "DSDCH")
;->  ((2 3 4 5 6) "HHCHH" (3 5 6 12 14) "SHSSS")
;->  ((4 7 8 10 10) "DCHCC" (3 4 7 13 13) "CCHSS")
;->  ((3 6 7 9 13) "CCDDH" (4 12 12 13 14) "CSCCH")
;->  ((2 2 5 6 11) "CSHHD" (7 9 11 13 14) "DDCSS"))

(first mani)
;-> ((4 8 9 10 13) "CSCHS" (2 3 5 7 14) "DSDSC")
(first (first mani))
;-> (4 8 9 10 13)

Adesso scriviamo la funzione che calcola il punteggio di una singola mano con i parametri "numeri" e "semi": (4 8 9 10 13) "CSCHS". Da notare che gli indici dei semi non corrispondono agli indici dei numeri. Questo perchè i semi servono solo per stabilire se sono tutti uguali (es. "CCCCC").

Esempi di utilizzo della funzione "calcola":

Input
  numeri = (2 3 4 8 10) ; numeri è ordinato
  semi = "CHCCC"
Output
  ((1 10 8 4 3 2) "High Card")
  dove 1 è il valore della mano
  e 10,8,4,3,2 sono i valori delle ordinati carte

Input
  numeri = (2 2 2 8 8) ; numeri è ordinato
  semi = "CHCCC"
Output
  ((7 2 8) "Full House")
  dove 7 è il valore della mano
  2 è il valore del tris e
  8 è il valore della coppia

(define (calcola numeri semi)
  (local (valore nome a b c)
    (setq valore '())
    (setq nome "")
    ;
    ; Flush, Straight Flush, Royal Flush
    ; Colore, Scala Reale, Scala Reale Massima
    (if (or (= semi "CCCCC") (= semi "DDDDD") (= semi "HHHHH") (= semi "SSSSS"))
        (begin
         (setq valore '(6)
               nome "Flush") ; Colore
         (if (= 4 (- (numeri 4) (numeri 0)))
             (begin
             (setq valore (list 9 (numeri 4))
                   nome "Straight Flush") ; Scala Reale
             (if (= 14 (numeri 4))
                 (setq valore (list 10 14)
                       nome "Royal Flush") ; Scala Reale Massima
             ))
         )
        )
    )
    ;
    ; Four of a Kind
    ; Poker
    (if (= valore '()) ; non abbiamo ancora catalogato la mano
        (for (i 2 14)
          (if (= (count (list i) numeri) '(4))
              (setq valore (list 8 i)
                    nome "Four of a Kind") ; Poker
          )
        )
    )
    ;
    ; Full House
    ; Full
    (if (= valore '()) ; non abbiamo ancora catalogato la mano
        (for (i 2 14)
          (if (= (count (list i) numeri) '(3))
              (for (j 2 14)
                (if (= (count (list j) numeri) '(2))
                    (setq valore (list 7 i j)
                          nome "Full House") ; Full
                )
              )
          )
        )
    )
    ;
    ; Three of a Kind
    ; Tris
    (if (= valore '()) ; non abbiamo ancora catalogato la mano
        (for (i 2 14)
          (if (= (count (list i) numeri) '(3))
              (begin
                (setq a i)
                (setq valore (list 4 i)
                      nome "Three of a Kind") ; Tris
                (for (k 4 0 -1)
                  (if (!= a (numeri k))
                      (push (numeri k) valore -1)
                  )
                )
              )
          )
        )
    )
    ;
    ; Two Pairs
    ; Doppia Coppia
    (if (= valore '()) ; non abbiamo ancora catalogato la mano
        (for (i 2 14)
          (if (= (count (list i) numeri) '(2))
              (for (j 2 14)
                (if (and (= (count (list j) numeri) '(2)) (!= i j))
                    (begin
                    (setq a (max i j))
                    (setq b (min i j))
                    (for (k 4 0 -1)
                       (if (and (!= a (numeri k)) (!= b (numeri k)))
                           (setq c (numeri k))
                       )
                    )
                    (setq valore (list 3 a b c)
                          nome "Two Pairs") ; Doppia Coppia
                ))
              )
          )
        )
    )
    ;
    ; Straight
    ; Scala
    (if (= valore '()) ; non abbiamo ancora catalogato la mano
        (if (and (= 1 (- (numeri 4) (numeri 3)))
                 (= 1 (- (numeri 3) (numeri 2)))
                 (= 1 (- (numeri 2) (numeri 1)))
                 (= 1 (- (numeri 1) (numeri 0))))
            (setq valore (list 5 (numeri 4))
                  nome "Straight") ; Scala
        )
    )
    ;
    ; One Pair
    ; Coppia
    (if (= valore '()) ; non abbiamo ancora catalogato la mano
        (for (i 2 14)
          (if (= (count (list i) numeri) '(2))
              (begin
              (setq valore (list 2 i)
                    nome "One Pair") ; Coppia
              (for (k 4 0 -1)
                (if (!= i (numeri k))
                    (push (numeri k) valore -1)
                )
              ))
          )
        )
    )
    ;
    ; High Card
    ; Carta maggiore
    (if (= valore '()) ; non abbiamo ancora catalogato la mano
        (setq valore (list 1 (numeri 4) (numeri 3) (numeri 2)
                             (numeri 1) (numeri 0))
              nome "High Card") ; Carta maggiore
    )
    ;
    ; Error: mano unclassified
    ; Errore: mano non catalogata
    (if (= valore '()) ; non abbiamo ancora catalogato la mano
        (println "error")
    )
    (list valore nome)
  )
)

Proviamo la funzione "calcola":

(calcola '(2 3 4 6 8) "CHCCC")
;-> ((1 6 8 4 3 2) "High Card")
(calcola '(2 2 2 10 10) "CHCCC")
;-> ((7 2 10) "Full House")
(calcola '(2 3 4 8 10) "CHCCC")
;-> ((1 8 3 4 2 10) "High Card")
(calcola '(10 2 3 3 8) "CHCCC")
;-> ((2 3 8 2 10) "One Pair")
(calcola '(3 3 3 5 6) "CHCCC")
;-> ((4 3 6 5) "Three of a Kind")
(calcola '(4 8 9 10 13) "CSCHS")
;-> ((1 13 10 9 8 4) "High Card")
(calcola '(2 3 5 4 6) "DDDDD")
;-> ((9 6) "Straight Flush")
(calcola '(10 11 12 13 14) "DDDDD")
;-> ((10 14) "Royal Flush")

Vediamo se funziona correttamente:

(dolist (el mani)
  (setq p1 (calcola (el 0) (el 1)))
  (setq p2 (calcola (el 2) (el 3)))
  (println (el 0) { - } p1)
  (println (el 2) { - } p2)
)

;-> (4 8 9 10 13) - ((1 13 10 9 8 4) "High Card")
;-> (2 3 5 7 14) - ((1 14 7 5 3 2) "High Card")
;-> (5 5 9 14 14) - ((3 14 5 9) "Two Pairs")
;-> (5 7 8 10 13) - ((1 13 10 8 7 5) "High Card")
;-> (3 6 7 11 13) - ((1 13 11 7 6 3) "High Card")
;-> (2 8 10 11 12) - ((1 12 11 10 8 2) "High Card")
;-> (5 8 10 10 12) - ((2 10 12 8 5) "One Pair")
;-> (4 9 11 11 13) - ((2 11 13 9 4) "One Pair")
;-> (5 7 11 12 13) - ((1 13 12 11 7 5) "High Card")
;-> (4 4 13 14 14) - ((3 14 4 13) "Two Pairs")
;-> (5 7 9 9 13) - ((2 9 13 7 5) "One Pair")
;-> (3 5 5 8 14) - ((2 5 14 8 3) "One Pair")
;-> (2 3 4 5 6) - ((5 6) "Straight")
;-> (3 5 6 12 14) - ((1 14 12 6 5 3) "High Card")
;-> (4 7 8 10 10) - ((2 10 8 7 4) "One Pair")
;-> (3 4 7 13 13) - ((2 13 7 4 3) "One Pair")
;-> (3 6 7 9 13) - ((1 13 9 7 6 3) "High Card")
;-> (4 12 12 13 14) - ((2 12 14 13 4) "One Pair")
;-> (2 2 5 6 11) - ((2 2 11 6 5) "One Pair")
;-> (7 9 11 13 14) - ((1 14 13 11 9 7) "High Card")
;-> ((1 14 13 11 9 7) "High Card")

Adesso dobbiamo scrivere una funzione che confronta gli elementi di due liste per trovare quale delle due è maggiore:

Esempi:
(3 4 9) maggiore di (2 3 12)
(3 4 9) maggiore di (3 3 12)
(3 4 9) minore di (5 3 8)
(4 5 2 7) maggiore di (4 5 2 6)

(define (maggiore lst1 lst2)
  (cond ((or (null? lst1) (null? lst2))
         ; se lst1 ha più elementi di lst2
         (if (not (null? lst1))
             true  ;se lst1 ha più elementi di lst2
             nil)) ; altrimenti lst1 = lst2
        ((> (first lst1) (first lst2)) true)
        ((< (first lst1) (first lst2)) nil)
        ((= (first lst1) (first lst2))
         (maggiore (rest lst1) (rest lst2)))))

(maggiore '(3 4 9) '(3 4 9))
;-> nil
(= '(3 4 9) '(3 4 9))
;-> true
(maggiore '(13 10 9 8 7 6) '(13 10 9 8 7 5))
;-> true
(maggiore '(13 10 9 8 7) '(13 10 9 8 7 2))
;-> nil
(maggiore '(13 10 9 8 7 2) '(13 10 9 8 7))
;-> true
(maggiore '(13 10 9 8 7) '(12 10 9 8 7 2))
;-> true
(maggiore '(12 9 9 8 7) '(12 10 9 8 7 2))
;-> nil
(maggiore '(14 4) '(14 3 6 7 8 9))
;-> true
(maggiore '(14 4) '(14 5 6 7 8 9))
;-> nil

Adesso possiamo scrivere la funzione finale:

(define (e054)
  (setq raw (read-file "054_poker.txt"))
  (setq data (parse raw "\r\n"))
  (setq data (map list data))
  (setq mani '())
  (dolist (el data)
    (setq row (first el))
    ;(println row)
    (setq val-p1 (explode (select row '(0 3 6 9 12))))
    (replace "A" val-p1 "14")
    (replace "K" val-p1 "13")
    (replace "Q" val-p1 "12")
    (replace "J" val-p1 "11")
    (replace "T" val-p1 "10")
    (setq val-p1 (sort (map int val-p1)))
    (setq val-p2 (explode (select row '(15 18 21 24 27))))
    (replace "A" val-p2 "14")
    (replace "K" val-p2 "13")
    (replace "Q" val-p2 "12")
    (replace "J" val-p2 "11")
    (replace "T" val-p2 "10")
    (setq val-p2 (sort (map int val-p2)))
    ; i semi non vengono ordinati perchè ci servono
    ; solo per calcolare "colore"
    (setq sem-p1 (select row '(1 4 7 10 13)))
    (setq sem-p2 (select row '(16 19 22 25 28)))
    (push (list val-p1 sem-p1 val-p2 sem-p2) mani -1)
    mani
  )
  ;(println (length mani))
  (setq val-p1 0)
  (setq val-p2 0)
  (dolist (el mani)
    (setq p1 (first (calcola (el 0) (el 1))))
    (setq p2 (first (calcola (el 2) (el 3))))
    (if (maggiore p1 p2)
        (begin
          ;(println (el 0) { } (el 1))
          ;(println (el 2) { } (el 3))
          ;(println p1 { } p2)
          (++ val-p1)
          ;(read-line)
        )
    )
  )
  val-p1
)

Calcoliamo la soluzione:

(e054)
;-> 376

(time (e054))
;-> 154.756


===========
Problema 55
===========

Numeri di Lychrel

Se prendiamo 47, lo invertiamo e lo aggiungiamo, otteniamo 47 + 74 = 121, che è palindromo.

Non tutti i numeri producono palindromi così rapidamente. Per esempio,

349 + 943 = 1292,
1292 + 2921 = 4213
4213 + 3124 = 7337

Cioè, 349 impiega tre iterazioni per arrivare a un palindromo.

Sebbene nessuno lo abbia ancora dimostrato, si ritiene che alcuni numeri, come 196, non producano mai un palindromo. Un numero che non forma mai un palindromo attraverso il processo di inversione e aggiunta si chiama numero Lychrel. A causa della natura teorica di questi numeri e ai fini di questo problema, supponiamo che un numero sia Lychrel fino a prova contraria. Inoltre, ti viene dato che per ogni numero inferiore a diecimila, o (i) diventerà un palindromo in meno di cinquanta iterazioni, o (ii) nessuno, con tutta la potenza di calcolo esistente, è riuscito finora a mapparlo su un palindromo. Infatti, 10677 è il primo numero in cui è stato dimostrato di richiedere oltre cinquanta iterazioni prima di produrre un palindromo: 4668731596684224866951378664 (53 iterazioni, 28 cifre).

Sorprendentemente, ci sono numeri palindromi che sono essi stessi numeri Lychrel (il primo esempio è 4994).

Quanti numeri Lychrel ci sono sotto diecimila?

NOTA: il testo è stato leggermente modificato il 24 aprile 2007 per enfatizzare la natura teorica dei numeri di Lychrel.
============================================================================

Funzione che inverte le cifre un numero:

(define (inverti n)
  (int (reverse (string n)) 0 10))

Da notare che la funzione "int" considera in base ottale il suo argomento se tale numero inizia con uno "0".

(int "055")
;-> 45

Per specificare una conversione decimale occorre specificarlo:

(int "055" 0 10)
;-> 55

(inverti 12345)
;-> 54321

Funzione che controlla se un numero è palindromo:

(define (pali? n) (= n (inverti n)))

(pali? 12344321)
;-> true
(pali? 123454321)
;-> true
(pali? 123211)
;-> nil

Funzione che controlla se un numero è di Lychrel:

(define (lychrel? num)
  (local (a b found lyc zzz)
    (setq zzz num)
    (setq found nil)
    (setq lyc true)
    (for (i 1 50 1 found)
      (setq a num)
      (setq b (inverti a))
      ;(println "num: " zzz { } "i: " i { } "a: " a { } "b: " b { } "a+b: " (+ a b))
      (if (pali? (+ a b))
        (begin
          (setq lyc nil)
          (setq found true)
          ;(println "NUM: " zzz { } "i: " i { } "a: " a { } "b: " b { } "a+b: " (+ a b))
        )
      )
      (setq num (+ a b))
    )
    lyc
  )
)

(lychrel? 47)
;-> nil

Funzione finale (versione 1):

(define (e053 prove)
  (let (out 0)
    (for (i 1 prove)
      (if (lychrel? i) (++ out))
    )
    out))

(e053 10000)
;-> 249
(time (e053 10000))
;-> 116.877

Funzione finale (versione 2):

(define (e053 n)
  (count '(true) (map lychrel? (sequence 1 n))))

(e053 10000)
;-> (249)
(time (e053 10000))
;-> 125.839


===========
Problema 56
===========

Somma di cifre di potenza

Un googol (10^100) è un numero enorme: uno seguito da cento zeri. 100^100 è quasi inimmaginabilmente grande: uno seguito da duecento zeri. Nonostante le loro dimensioni, la somma delle cifre in ciascun numero è solo 1.

Considerando i numeri naturali della forma a^b, dove a, b < 100, qual'è la somma massima delle cifre?
============================================================================

Funzione che calcola la somma delle cifre di un numero:

(define (digit-sum n)
  (let (out 0)
    (while (!= n 0)
      (setq out (+ out (% n 10)))
      (setq n (/ n 10))
    )
    out))

(digit-sum 123456789L)
;-> 45

Funzione che calcola la potenza intera di due numeri interi:

(define (** x p)
    (let (y 1L)
        (dotimes (i p)
            (setq y (* y x)))))

(** 35 21)
;-> 266335422555582049846649169921875L

(digit-sum 266335422555582049846649169921875L)
;-> 161

(+ 2 6 6 3 3 5 4 2 2 5 5 5 5 8 2 0 4 9 8 4 6 6 4 9 1 6 9 9 2 1 8 7 5)
;-> 161

Funzione soluzione:

(define (e056)
  (local (somma somma-max)
    (setq somma-max 0)
    (for (a 75 100)
      (for (b 75 100)
        (setq somma (digit-sum (** a b)))
        (if (> somma somma-max) (setq somma-max somma))
      )
    )
    somma-max))

(e056)
;-> 972

(time (e056))
;-> 199.794

Possiamo scrivere la funzione anche in stile funzionale.

Questa funzione calcola tutte le potenza di ogni elemento della prima lista elevato ad ogni elemento della seconda lista (prodotto cartesiano):

(define (cp lst1 lst2)
  (let (out '())
    (if (or (null? lst1) (null? lst2))
        nil
        (dolist (el1 lst1)
          (dolist (el2 lst2)
            (push (** el1 el2) out -1))))))

Funzione soluzione:

(define (e056)
  (apply max (map digit-sum (cp (map bigint (sequence 75 100))
                                (map bigint (sequence 75 100))))))

(e056)
;-> 972

(time (e056))
;-> 186.794


===========
Problema 57
===========

È possibile dimostrare che la radice quadrata di due può essere espressa come una frazione continua infinita.

sqrt(2) = 1 + 1 / (2 + 1 / (2 + 1 / (2 +...))) = 1.414213...

Espandendo questo per le prime quattro iterazioni, otteniamo:

1 + 1/2 = 3/2 = 1.5
1 + 1 / (2 + 1/2) = 7/5 = 1.4
1 + 1 / (2 + 1 / (2 + 1/2)) = 17/12 = 1.41666...
1 + 1 / (2 + 1 / (2 + 1 / (2 + 1/2))) = 41/29 = 1.41379...

Le tre espansioni successive sono 99/70, 239/169 e 577/408, ma l'ottava espansione, 1393/985, è il primo esempio in cui il numero di cifre nel numeratore supera il numero di cifre nel denominatore.

Nelle prime mille espansioni, quante frazioni contengono un numeratore con più cifre del denominatore?
============================================================================

La sequenza a(k) inizia con a(0) = 1 + 1/2 e a(1) = (1 + (1 / (2 + 1/2))), sostituendo a(0) in a(1) otteniamo a(1) = 1 + (1 / (1 + a(0))). Quindi possiamo scrivere:

                                        1
a(k+1) = 1 + (1 / (1 + a(k))) = 1 + ----------
                                     1 + a(k)

Invece di utilizzare la libreria delle frazioni per calcolare il numeratore e il denominatore di ogni iterazione, possiamo espandere a(k+1):

a(k+1) = 1 + (1 / (1 + a(k))) = 1 + (1 / (1 + nk/dk)) =
       = 1 + (1 / (1 + nk/dk)) = 1 + (1 / (1 + (dk + nk)/dk) =
       = 1 + dk/(dk + nk) = (dk + nk + dk)/(dk + nk) =
       = (2*dk + nk)/(dk + nk)

Usiamo questa formula per calcolare il numeratore e il denominatore per ogni iterazione, poi confrontiamo le loro lunghezze e incrementiamo il contatore:

(define (e057 num)
  (local (n d tn td out)
    (setq out 0)
    (setq n 1L)
    (setq d 1L)
    (for (i 0 num)
      (setq tn n)
      (setq td d)
      (setq n (+ (* 2L td) tn))
      (setq d (+ td tn))
      ;(println n { } d)
      (if (> (length n) (length d)) (++ out))
    )
    out
  )
)

(e057 1000)
;-> 153

(time (e057 1000))
;-> 10.036


===========
Problema 58
===========
Numeri primi a spirale

A partire da 1 e creando una spirale in senso antiorario, si forma una spirale quadrata con lato di lunghezza 7:

37 36 35 34 33 32 31
38 17 16 15 14 13 30
39 18  5  4  3 12 29
40 19  6  1  2 11 28
41 20  7  8  9 10 27
42 21 22 23 24 25 26
43 44 45 46 47 48 49

È interessante notare che i quadrati dispari si trovano lungo la diagonale in basso a destra, ma ciò che è più interessante è che 8 dei 13 numeri che giacciono lungo entrambe le diagonali sono primi (43 7 3 13 31) e (37 17 5). Cioè, un rapporto dell'8/13 ≈ 62%.

Se un nuovo strato completo viene avvolto attorno alla spirale sopra, verrà formata una spirale quadrata con lunghezza laterale 9. Se questo processo continua, qual è la lunghezza laterale della spirale quadrata per la quale il rapporto dei numeri primi lungo entrambe le diagonali scende prima sotto il 10%?
============================================================================

La spirale di lato 9 è la seguente:

 65 64 63 62 61 60 59 58 57
 66 37 36 35 34 33 32 31 56
 67 38 17 16 15 14 13 30 55
 68 39 18  5  4  3 12 29 54
 69 40 19  6  1  2 11 28 53
 70 41 20  7  8  9 10 27 52
 71 42 21 22 23 24 25 26 51
 72 43 44 45 46 47 48 49 50
 73 74 75 76 77 78 79 80 81

Occorre notare che partendo da k=1 i valori che cerchiamo sono:

lato = 2*k + 1
basso-dx = (2*k + 1)^2
alto-dx  = (basso-dx - 6*k)
alto-sx  = (basso-dx - 4*k)
basso-sx = (basso-dx - 2*k)

Quindi ad ogni iterazione/spirale dobbiamo solo controllare se questi quattro numeri sono primi ed eventualmente aggiornare il conteggio dei numeri primi totali.

Iterazione 1:
5  4  3
6  1  2
7  8  9

Iterazione 2:
17 16 15 14 13
18  5  4  3 12
19  6  1  2 11
20  7  8  9 10
21 22 23 24 25

Iterazione 3:
37 36 35 34 33 32 31
38 17 16 15 14 13 30
39 18  5  4  3 12 29
40 19  6  1  2 11 28
41 20  7  8  9 10 27
42 21 22 23 24 25 26

...e così via.

Possiamo scrivere la funzione di soluzione:

(define (primo? n)
   (if (< n 2) nil
       (= 1 (length (factor n)))))

(define (e058 n)
  (local (numeriDiag numeriPrimi perc lato found
          alto-dx alto-sx basso-dx basso-sx)
    (setq found nil)
    (setq numeriDiag 1)
    (setq numeriPrimi 0)
    (setq perc 0)
    (for (side 1 n 1 found)
      (setq lato (+ (* 2 side) 1))
      ;(setq basso-dx (* (+ (* 2 side) 1) (+ (* 2 side) 1)))
      (setq basso-dx (* lato lato))
      (setq alto-dx (- basso-dx (* 6 side)))
      (setq alto-sx (- basso-dx (* 4 side)))
      (setq basso-sx (- basso-dx (* 2 side)))
      ;(println alto-dx { } alto-sx { } basso-sx { } basso-dx)
      (setq numeriDiag (+ (* 2 lato) 1))
      ;(if (primo? basso-dx) (++ numeriPrimi))
      (if (primo? alto-dx) (++ numeriPrimi))
      (if (primo? basso-sx) (++ numeriPrimi))
      (if (primo? alto-sx) (++ numeriPrimi))
      (setq perc (div numeriPrimi numeriDiag))
      ;(println side { } lato { } numeriPrimi { } numeriDiag { } perc)
      (if (< perc 0.1) (setq found true))
    )
    (list lato perc numeriPrimi numeriDiag)
  )
)

(e058 50000)
;-> (26241 0.09999428386334623 5248 52483)

(time (e058 50000))
;-> 630.190


===========
Problema 59
===========

Decodifica XOR

A ciascun carattere di un computer viene assegnato un codice univoco e lo standard preferito è ASCII (American Standard Code for Information Interchange). Ad esempio, A maiuscola = 65, asterisco (*) = 42 e k minuscola = 107.

Un moderno metodo di crittografia è quello di prendere un file di testo, convertire i byte in ASCII, quindi fare lo XOR ad ogni byte con un dato valore, preso da una chiave segreta. Il vantaggio con la funzione XOR è che l'uso della stessa chiave di crittografia sul testo cifrato ripristina il testo normale, ad esempio, 65 XOR 42 = 107, quindi 107 XOR 42 = 65.

Per avere una criptazione inviolabile, la chiave deve avere la stessa lunghezza del messaggio di testo normale e la chiave deve essere composta da byte casuali. Se l'utente tiene il messaggio crittografato e la chiave di crittografia in posti diversi allora è impossibile decrittografare il messaggio senza entrambe le 'metà' (messaggio crittografato e chiave).

Sfortunatamente, questo metodo non è pratico per la maggior parte degli utenti, quindi il metodo modificato è usare una password come chiave. Se la password è più corta del messaggio, il che è probabile, la chiave viene ripetuta ciclicamente in tutto il messaggio. Il giusto bilanciamento è quello di usare una chiave (password) sufficientemente lunga per la sicurezza, ma abbastanza corta per essere ricordata.

Il tuo compito è stata semplificato, poiché la chiave di crittografia è composta da tre caratteri minuscoli. Utilizzando il file "p059_cipher.txt" che contiene i codici ASCII crittografati e sapendo che il testo normale (decifrato) contiene parole inglesi comuni, decodificare il messaggio e trovare la somma dei valori ASCII dei caratteri contenuti nel testo originale.
============================================================================

Assegniamo i valori contenuti nel file "p059_cipher.txt" ad una lista:

(setq tc '(79 59 12 2 79 35 8 28 20 2 3 68 8 9 68 45 0 12 9 67
68 4 7 5 23 27 1 21 79 85 78 79 85 71 38 10 71 27 12 2
79 6 2 8 13 9 1 13 9 8 68 19 7 1 71 56 11 21 11 68
6 3 22 2 14 0 30 79 1 31 6 23 19 10 0 73 79 44 2 79
19 6 28 68 16 6 16 15 79 35 8 11 72 71 14 10 3 79 12 2
79 19 6 28 68 32 0 0 73 79 86 71 39 1 71 24 5 20 79 13
9 79 16 15 10 68 5 10 3 14 1 10 14 1 3 71 24 13 19 7
68 32 0 0 73 79 87 71 39 1 71 12 22 2 14 16 2 11 68 2
25 1 21 22 16 15 6 10 0 79 16 15 10 22 2 79 13 20 65 68
41 0 16 15 6 10 0 79 1 31 6 23 19 28 68 19 7 5 19 79
12 2 79 0 14 11 10 64 27 68 10 14 15 2 65 68 83 79 40 14
9 1 71 6 16 20 10 8 1 79 19 6 28 68 14 1 68 15 6 9
75 79 5 9 11 68 19 7 13 20 79 8 14 9 1 71 8 13 17 10
23 71 3 13 0 7 16 71 27 11 71 10 18 2 29 29 8 1 1 73
79 81 71 59 12 2 79 8 14 8 12 19 79 23 15 6 10 2 28 68
19 7 22 8 26 3 15 79 16 15 10 68 3 14 22 12 1 1 20 28
72 71 14 10 3 79 16 15 10 68 3 14 22 12 1 1 20 28 68 4
14 10 71 1 1 17 10 22 71 10 28 19 6 10 0 26 13 20 7 68
14 27 74 71 89 68 32 0 0 71 28 1 9 27 68 45 0 12 9 79
16 15 10 68 37 14 20 19 6 23 19 79 83 71 27 11 71 27 1 11
3 68 2 25 1 21 22 11 9 10 68 6 13 11 18 27 68 19 7 1
71 3 13 0 7 16 71 28 11 71 27 12 6 27 68 2 25 1 21 22
11 9 10 68 10 6 3 15 27 68 5 10 8 14 10 18 2 79 6 2
12 5 18 28 1 71 0 2 71 7 13 20 79 16 2 28 16 14 2 11
9 22 74 71 87 68 45 0 12 9 79 12 14 2 23 2 3 2 71 24
5 20 79 10 8 27 68 19 7 1 71 3 13 0 7 16 92 79 12 2
79 19 6 28 68 8 1 8 30 79 5 71 24 13 19 1 1 20 28 68
19 0 68 19 7 1 71 3 13 0 7 16 73 79 93 71 59 12 2 79
11 9 10 68 16 7 11 71 6 23 71 27 12 2 79 16 21 26 1 71
3 13 0 7 16 75 79 19 15 0 68 0 6 18 2 28 68 11 6 3
15 27 68 19 0 68 2 25 1 21 22 11 9 10 72 71 24 5 20 79
3 8 6 10 0 79 16 8 79 7 8 2 1 71 6 10 19 0 68 19
7 1 71 24 11 21 3 0 73 79 85 87 79 38 18 27 68 6 3 16
15 0 17 0 7 68 19 7 1 71 24 11 21 3 0 71 24 5 20 79
9 6 11 1 71 27 12 21 0 17 0 7 68 15 6 9 75 79 16 15
10 68 16 0 22 11 11 68 3 6 0 9 72 16 71 29 1 4 0 3
9 6 30 2 79 12 14 2 68 16 7 1 9 79 12 2 79 7 6 2
1 73 79 85 86 79 33 17 10 10 71 6 10 71 7 13 20 79 11 16
1 68 11 14 10 3 79 5 9 11 68 6 2 11 9 8 68 15 6 23
71 0 19 9 79 20 2 0 20 11 10 72 71 7 1 71 24 5 20 79
10 8 27 68 6 12 7 2 31 16 2 11 74 71 94 86 71 45 17 19
79 16 8 79 5 11 3 68 16 7 11 71 13 1 11 6 1 17 10 0
71 7 13 10 79 5 9 11 68 6 12 7 2 31 16 2 11 68 15 6
9 75 79 12 2 79 3 6 25 1 71 27 12 2 79 22 14 8 12 19
79 16 8 79 6 2 12 11 10 10 68 4 7 13 11 11 22 2 1 68
8 9 68 32 0 0 73 79 85 84 79 48 15 10 29 71 14 22 2 79
22 2 13 11 21 1 69 71 59 12 14 28 68 14 28 68 9 0 16 71
14 68 23 7 29 20 6 7 6 3 68 5 6 22 19 7 68 21 10 23
18 3 16 14 1 3 71 9 22 8 2 68 15 26 9 6 1 68 23 14
23 20 6 11 9 79 11 21 79 20 11 14 10 75 79 16 15 6 23 71
29 1 5 6 22 19 7 68 4 0 9 2 28 68 1 29 11 10 79 35
8 11 74 86 91 68 52 0 68 19 7 1 71 56 11 21 11 68 5 10
7 6 2 1 71 7 17 10 14 10 71 14 10 3 79 8 14 25 1 3
79 12 2 29 1 71 0 10 71 10 5 21 27 12 71 14 9 8 1 3
71 26 23 73 79 44 2 79 19 6 28 68 1 26 8 11 79 11 1 79
17 9 9 5 14 3 13 9 8 68 11 0 18 2 79 5 9 11 68 1
14 13 19 7 2 18 3 10 2 28 23 73 79 37 9 11 68 16 10 68
15 14 18 2 79 23 2 10 10 71 7 13 20 79 3 11 0 22 30 67
68 19 7 1 71 8 8 8 29 29 71 0 2 71 27 12 2 79 11 9
3 29 71 60 11 9 79 11 1 79 16 15 10 68 33 14 16 15 10 22 73))

Vediamo come criptare/decriptare un carattere con la funzione XOR:

(char "a")
;-> 97

(char "k")
;-> 107

Cripta il valore (ASCII) del carattere "a" con il valore della chiave "k":
(^ 97 107)
;-> 10

Decripta il valore criptato (10) con il valore della chiave "k":
(^ 10 107)
;-> 97

Funzione di criptazione:

(define (crypt ch key)
  (char (^ (char ch) (char key))))

(crypt "a" "k")
;-> "\n"

Funzione di decriptazione:

(define (decrypt ch key)
  (char (^ (char ch) (char key))))

(decrypt (crypt "a" "k") "k")
;-> "a"

Nota: le funzione di criptazione e decriptazione sono identiche.

Adesso scriviamo una funzione che cripta una stringa con una data password.

(define (crypt ch key)
  (char (^ (char ch) (char key))))

(crypt "a" "k")
;-> "\n"

(define (decrypt ch key)
  (char (^ (char ch) (char key))))

(decrypt (crypt "a" "k") "k")
;-> "a"

Adesso scriviamo una funzione che cripta una stringa con una data password.

(define (crypt-text text pwd)
  (local (k lst len out)
    (setq out '())
    (setq numchar (- (length pwd) 1))
    ;(setq lst (explode text)) ; non UTF-8
    (setq lst (unpack (dup "s" (length text)) text)) ; UTF-8
    (setq k 0)
    (dolist (el lst)
      (push (crypt el (pwd k)) out -1)
      (++ k)
      (if (= k numchar) (setq k 0))
    )
    (join out)))

(crypt-text "Massimo" "pwd")
;-> "=\022\003\004\025\026\031"

(crypt-text "=\022\003\004\025\026\031" "pwd")
;-> Massimo

(crypt-text (crypt-text "cryptomessage" "password") "password")
;-> cryptomessage

Per il nostro scopo è più conveniente avere in input una lista di codici ASCII (la nostra lista tc):

(define (crypt-text text pwd)
  ; text: testo in una lista di numeri ASCII
  (local (k lst len out)
    (setq out '())
    (setq numchar (length pwd))
    (setq k 0)
    (dolist (el text)
      (push (^ el (char (pwd k))) out -1)
      (++ k)
      (if (= k numchar) (setq k 0))
    )
    out
  )
)

(crypt-text (map char (explode "Massimo Eva")) "pwd")
;-> (61 22 23 3 30 9 31 87 33 6 22)

(join (map char (crypt-text '(61 22 23 3 30 9 31 87 33 6 22) "pwd")))
;-> "Massimo Eva"

Adesso dobbiamo trovare la chiave (password) del testo cifrato. Sappiamo che è formata da tre lettere minuscole. Facciamo l'analisi delle frequenze al testo cifrato.

Frequenza dei caratteri nella lingua inglese:
http://www.data-compression.com/english.html

|=========|=========|=========|=========|=========|=========|=========|
|    a    |    b    |    c    |    d    |    e    |    f    |    g    |
|=========|=========|=========|=========|=========|=========|=========|
 0.0651738 0.0124248 0.0217339 0.0349835 0.1041442 0.0197881 0.0158610

|=========|=========|=========|=========|=========|=========|=========|
|    h    |    i    |    j    |    k    |    l    |    m    |    n    |
|=========|=========|=========|=========|=========|=========|=========|
 0.0492888 0.0558094 0.0009033 0.0050529 0.0331490 0.0202124 0.0564513

|=========|=========|=========|=========|=========|=========|=========|
|    o    |    p    |    q    |    r    |    s    |    t    |    u    |
|=========|=========|=========|=========|=========|=========|=========|
 0.0596302 0.0137645 0.0008606 0.0497563 0.0515760 0.0729357 0.0225134

|=========|=========|=========|=========|=========|=========|
|    v    |    w    |    x    |    y    |    z    |  SPACE  |
|=========|=========|=========|=========|=========|=========|
 0.0082903 0.0171272 0.0013692 0.0145984 0.0007836 0.1918182

(setq af '(
 (0.0651738 "a") (0.0124248 "b") (0.0217339 "c") (0.0349835 "d")
 (0.1041442 "e") (0.0197881 "f") (0.0158610 "g") (0.0492888 "h")
 (0.0558094 "i") (0.0009033 "j") (0.0050529 "k") (0.0331490 "l")
 (0.0202124 "m") (0.0564513 "n") (0.0596302 "o") (0.0137645 "p")
 (0.0008606 "q") (0.0497563 "r") (0.0515760 "s") (0.0729357 "t")
 (0.0225134 "u") (0.0082903 "v") (0.0171272 "w") (0.0013692 "x")
 (0.0145984 "y") (0.0007836 "z") (0.1918182 " ")))

(sort af >)
;-> ((0.1918182 " ") (0.1041442 "e") (0.0729357 "t") (0.0651738 "a")
;->  (0.0596302 "o") (0.0564513 "n") (0.0558094 "i") (0.051576 "s")
;->  (0.0497563 "r") (0.0492888 "h") (0.0349835 "d") (0.033149 "l")
;->  (0.0225134 "u") (0.0217339 "c") (0.0202124 "m") (0.0197881 "f")
;->  (0.0171272 "w") (0.015861 "g")  (0.0145984 "y") (0.0137645 "p")
;->  (0.0124248 "b") (0.0082903 "v") (0.0050529 "k") (0.0013692 "x")
;->  (0.0009033 "j") (0.0008606 "q") (0.0007836 "z"))

Quindi il carattere spazio " " è quello di gran lunga più frequente (quasi il 20%). Per il nostro algoritmo sarà sufficiente utilizzare questo carattere.

Vediamo quali sono i valori più frequenti nel testo cifrato:

(apply max tc)
;-> 94
(setq freq (array 95 '(0)))

(dolist (el tc) (setf (freq el) (+ (freq el) 1)))
freq
;-> (49 63 60 37 5 21 49 41 34 41 60 54 31 24 38 26 38 9 10 35
;->  22 15 22 17 9 6 6 21 21 11 4 4 4 2 0 3 0 2 2 2 1 1 0 0 2
;->  4 0 0 1 0 0 0 1 0 0 0 2 0 0 4 1 0 0 0 1 2 0 2 77 1 0 70 5
;->  11 4 5 0 0 1 86 0 1 0 2 1 5 4 3 0 1 0 1 1 1 1)

Converto il vettore in lista:

(setq f (array-list freq))
f

Lista di frequenze ordinata:

(sort (copy f) >)
;-> (86 77 70 63 60 60 54 49 49 41 41 38 38 37 35 34 31 26 24 22 22 21 21 21 17 15 11
;->  11 10 9 9 6 6 5 5 5 5 4 4 4 4 4 4 4 3 3 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1
;->  1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)

Il valore più frequente del testo cifrato è 86.

Posizione (valore ASCII criptato):

(ref 86 f)
;-> (79)

Associo il valore 79 al carattere " " (che è il più frequente in lingua inglese). Quindi trovo il carattere della chiave che restituisce uno spazio " ":

(dolist (el (explode "abcdefghijlklmnopqrstuvwxyz "))
  (if (= " " (char (^ 79 (char el))))
    (println el)))
;-> o

Un carattere della chiave è "o".

Lo stesso ragionamento può essere fatto con il secondo valore più frequente del testo cifrato, cioè 77.
Infatti, poichè ogni carattere della chiave codifica (quasi) lo stesso numero di caratteri

Posizione (valore ASCII criptato):

(ref 77 f)
;-> (68)

(dolist (el (explode "abcdefghijlklmnopqrstuvwxyz "))
  (if (= " " (char (^ 68 (char el))))
    (println el)))
;-> d

Un altro carattere della chiave è "d".

Lo stesso ragionamento può essere fatto con il terzo valore più frequente del testo cifrato, cioè 70.

Posizione (valore ASCII criptato):

(ref 70 f)
;-> (71)

(dolist (el (explode "abcdefghijlklmnopqrstuvwxyz "))
  (if (= " " (char (^ 71 (char el))))
    (println el)))
;-> g

Il terzo carattere della chiave è "g".

La chiave è composta dai caratteri "o", "d" e "g". Proviamo con "dog":

(setq testo (join (map char (crypt-text tc "dog"))))

In questo caso otteniamo un testo illeggibile.

Proviamo con "god":

(setq testo (join (map char (crypt-text tc "god"))))
;-> "(The Gospel of John, chapter 1) 1 In the beginning the Word already existed. He was with God, and he was God. 2 He was in the beginning with God. 3 He created everything there is. Nothing exists that he didn't make. 4 Life itself was in him, and this life gives light to everyone. 5 The light shines through the darkness, and the darkness can never extinguish it. 6 God sent John the Baptist 7 to tell everyone about the light so that everyone might believe because of his testimony. 8 John himself was not the light; he was only a witness to the light. 9 The one who is the true light, who gives light to everyone, was going to come into the world. 10 But although the world was made through him, the world didn't recognize him when he came. 11 Even in his own land and among his own people, he was not accepted. 12 But to all who believed him and accepted him, he gave the right to become children of God. 13 They are reborn! This is not a physical birth resulting from human passion or plan, this rebirth comes from God.14 So the Word became human and lived here on earth among us. He was full of unfailing love and faithfulness. And we have seen his glory, the glory of the only Son of the Father."

Testo decifrato correttamente. Vediamo la somma dei valori ASCII del testo decifrato:

(setq sol (apply + (map char (explode testo))))
;-> 107359

(define (e059)
  (setq testo (join (map char (crypt-text tc "god"))))
  (setq sol (apply + (map char (explode testo)))))

(e059)
;-> 107359

(time (e059))
;-> 15.625

Il tempo registrato non è quello che include tutti i calcoli, ma credo che una funzione completa che utilizza questo metodo non dovrebbe impiegare più di 2/3 secondi per trovare la soluzione.

Sembra che il sito di Project Euler abbia cambiato il contenuto del file "p059_cipher.txt".
Proviamo il nostro metodo con questo nuovo file.

Assegniamo i valori contenuti nel file ad una lista:

(setq tc1 '(
 36 22 80 0 0 4 23 25 19 17 88 4 4 19 21 11 88 22 23 23 29 69
 12 24 0 88 25 11 12 2 10 28 5 6 12 25 10 22 80 10 30 80 10 22
 21 69 23 22 69 61 5 9 29 2 66 11 80 8 23 3 17 88 19 0 20 21
 7 10 17 17 29 20 69 8 17 21 29 2 22 84 80 71 60 21 69 11 5 8
 21 25 22 88 3 0 10 25 0 10 5 8 88 2 0 27 25 21 10 31 6 25
 2 16 21 82 69 35 63 11 88 4 13 29 80 22 13 29 22 88 31 3 88 3
 0 10 25 0 11 80 10 30 80 23 29 19 12 8 2 10 27 17 9 11 45 95
 88 57 69 16 17 19 29 80 23 29 19 0 22 4 9 1 80 3 23 5 11 28
 92 69 9 5 12 12 21 69 13 30 0 0 0 0 27 4 0 28 28 28 84 80
 4 22 80 0 20 21 2 25 30 17 88 21 29 8 2 0 11 3 12 23 30 69
 30 31 23 88 4 13 29 80 0 22 4 12 10 21 69 11 5 8 88 31 3 88
 4 13 17 3 69 11 21 23 17 21 22 88 65 69 83 80 84 87 68 69 83 80
 84 87 73 69 83 80 84 87 65 83 88 91 69 29 4 6 86 92 69 15 24 12
 27 24 69 28 21 21 29 30 1 11 80 10 22 80 17 16 21 69 9 5 4 28
 2 4 12 5 23 29 80 10 30 80 17 16 21 69 27 25 23 27 28 0 84 80
 22 23 80 17 16 17 17 88 25 3 88 4 13 29 80 17 10 5 0 88 3 16
 21 80 10 30 80 17 16 25 22 88 3 0 10 25 0 11 80 12 11 80 10 26
 4 4 17 30 0 28 92 69 30 2 10 21 80 12 12 80 4 12 80 10 22 19
 0 88 4 13 29 80 20 13 17 1 10 17 17 13 2 0 88 31 3 88 4 13
 29 80 6 17 2 6 20 21 69 30 31 9 20 31 18 11 94 69 54 17 8 29
 28 28 84 80 44 88 24 4 14 21 69 30 31 16 22 20 69 12 24 4 12 80
 17 16 21 69 11 5 8 88 31 3 88 4 13 17 3 69 11 21 23 17 21 22
 88 25 22 88 17 69 11 25 29 12 24 69 8 17 23 12 80 10 30 80 17 16
 21 69 11 1 16 25 2 0 88 31 3 88 4 13 29 80 21 29 2 12 21 21
 17 29 2 69 23 22 69 12 24 0 88 19 12 10 19 9 29 80 18 16 31 22
 29 80 1 17 17 8 29 4 0 10 80 12 11 80 84 67 80 10 10 80 7 1
 80 21 13 4 17 17 30 2 88 4 13 29 80 22 13 29 69 23 22 69 12 24
 12 11 80 22 29 2 12 29 3 69 29 1 16 25 28 69 12 31 69 11 92 69
 17 4 69 16 17 22 88 4 13 29 80 23 25 4 12 23 80 22 9 2 17 80
 70 76 88 29 16 20 4 12 8 28 12 29 20 69 26 9 69 11 80 17 23 80
 84 88 31 3 88 4 13 29 80 21 29 2 12 21 21 17 29 2 69 12 31 69
 12 24 0 88 20 12 25 29 0 12 21 23 86 80 44 88 7 12 20 28 69 11
 31 10 22 80 22 16 31 18 88 4 13 25 4 69 12 24 0 88 3 16 21 80
 10 30 80 17 16 25 22 88 3 0 10 25 0 11 80 17 23 80 7 29 80 4
 8 0 23 23 8 12 21 17 17 29 28 28 88 65 75 78 68 81 65 67 81 72
 70 83 64 68 87 74 70 81 75 70 81 67 80 4 22 20 69 30 2 10 21 80
 8 13 28 17 17 0 9 1 25 11 31 80 17 16 25 22 88 30 16 21 18 0
 10 80 7 1 80 22 17 8 73 88 17 11 28 80 17 16 21 11 88 4 4 19
 25 11 31 80 17 16 21 69 11 1 16 25 2 0 88 2 10 23 4 73 88 4
 13 29 80 11 13 29 7 29 2 69 75 94 84 76 65 80 65 66 83 77 67 80
 64 73 82 65 67 87 75 72 69 17 3 69 17 30 1 29 21 1 88 0 23 23
 20 16 27 21 1 84 80 18 16 25 6 16 80 0 0 0 23 29 3 22 29 3
 69 12 24 0 88 0 0 10 25 8 29 4 0 10 80 10 30 80 4 88 19 12
 10 19 9 29 80 18 16 31 22 29 80 1 17 17 8 29 4 0 10 80 12 11
 80 84 86 80 35 23 28 9 23 7 12 22 23 69 25 23 4 17 30 69 12 24
 0 88 3 4 21 21 69 11 4 0 8 3 69 26 9 69 15 24 12 27 24 69
 49 80 13 25 20 69 25 2 23 17 6 0 28 80 4 12 80 17 16 25 22 88
 3 16 21 92 69 49 80 13 25 6 0 88 20 12 11 19 10 14 21 23 29 20
 69 12 24 4 12 80 17 16 21 69 11 5 8 88 31 3 88 4 13 29 80 22
 29 2 12 29 3 69 73 80 78 88 65 74 73 70 69 83 80 84 87 72 84 88
 91 69 73 95 87 77 70 69 83 80 84 87 70 87 77 80 78 88 21 17 27 94
 69 25 28 22 23 80 1 29 0 0 22 20 22 88 31 11 88 4 13 29 80 20
 13 17 1 10 17 17 13 2 0 88 31 3 88 4 13 29 80 6 17 2 6 20
 21 75 88 62 4 21 21 9 1 92 69 12 24 0 88 3 16 21 80 10 30 80
 17 16 25 22 88 29 16 20 4 12 8 28 12 29 20 69 26 9 69 65 64 69
 31 25 19 29 3 69 12 24 0 88 18 12 9 5 4 28 2 4 12 21 69 80
 22 10 13 2 17 16 80 21 23 7 0 10 89 69 23 22 69 12 24 0 88 19
 12 10 19 16 21 22 0 10 21 11 27 21 69 23 22 69 12 24 0 88 0 0
 10 25 8 29 4 0 10 80 10 30 80 4 88 19 12 10 19 9 29 80 18 16
 31 22 29 80 1 17 17 8 29 4 0 10 80 12 11 80 84 86 80 36 22 20
 69 26 9 69 11 25 8 17 28 4 10 80 23 29 17 22 23 30 12 22 23 69
 49 80 13 25 6 0 88 28 12 19 21 18 17 3 0 88 18 0 29 30 69 25
 18 9 29 80 17 23 80 1 29 4 0 10 29 12 22 21 69 12 24 0 88 3
 16 21 3 69 23 22 69 12 24 0 88 3 16 26 3 0 9 5 0 22 4 69
 11 21 23 17 21 22 88 25 11 88 7 13 17 19 13 88 4 13 29 80 0 0
 0 10 22 21 11 12 3 69 25 2 0 88 21 19 29 30 69 22 5 8 26 21 23 11 94))

(apply max tc1)
;-> 95
(setq freq1 (array 96 '(0)))

(dolist (el tc1) (setf (freq1 el) (+ (freq1 el) 1)))
freq1
;-> (75 19 31 36 61 15 11 9 25 20 52 43 65 33 2 2 38 73 11 21 22 65
;->  56 46 21 42 7 10 25 70 26 24 0 0 0 2 2 0 0 0 0 0 0 0 2 1 0 0 0
;->  3 0 0 0 0 1 0 0 1 0 0 1 1 1 1 3 9 2 5 3 86 7 1 3 7 2 5 2 3 3 0
;->  107 4 2 8 16 0 4 9 77 1 0 2 6 0 4 2)

Converto il vettore in lista:

(setq f1 (array-list freq1))
f1

Lista di frequenze ordinata:

(sort (copy f1) >)
;-> (107 86 77 75 73 70 65 65 61 56 52 46 43 42 38 36 33 31 26 25 25 24
;->  22 21 21 20 19 16 15 11 11 10 9 9 9 8 7 7 7 6 5 5 4 4 4 3 3 3 3 3
;->  3 2 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0
;->  0 0 0 0 0 0 0 0 0 0 0 0 0)

Il valore più frequente del testo cifrato è 107.

Posizione (valore ASCII criptato):

(ref 107 f1)
;-> (80)

Associo il valore 80 al carattere " " (che è il più frequente in lingua inglese). Quindi trovo il carattere della chiave che restituisce uno spazio " ":

(dolist (el (explode "abcdefghijlklmnopqrstuvwxyz "))
  (if (= " " (char (^ 80 (char el))))
    (println el)))
;-> p

Un carattere della chiave è "p".

Lo stesso ragionamento può essere fatto con il secondo valore più frequente del testo cifrato, cioè 86.

Posizione (valore ASCII criptato):

(ref 86 f1)
;-> (69)

(dolist (el (explode "abcdefghijlklmnopqrstuvwxyz "))
  (if (= " " (char (^ 69 (char el))))
    (println el)))
;-> e

Un altro carattere della chiave è "e".

Lo stesso ragionamento può essere fatto con il terzo valore più frequente del testo cifrato, cioè 77.

Posizione (valore ASCII criptato):

(ref 77 f1)
;-> (88)

(dolist (el (explode "abcdefghijlklmnopqrstuvwxyz "))
  (if (= " " (char (^ 88 (char el))))
    (println el)))
;-> x

Il terzo carattere della chiave è "x".

La chiave è composta dai caratteri "p", "e" e "x".

Facciamo alcuni tentativi:

(setq testo (join (map char (crypt-text tc1 "xpe"))))
In questo caso otteniamo un testo illeggibile.

(setq testo (join (map char (crypt-text tc1 "pex"))))
In questo caso otteniamo un testo illeggibile.

(setq testo (join (map char (crypt-text tc1 "pxe"))))
In questo caso otteniamo un testo illeggibile.

(setq testo (join (map char (crypt-text tc1 "xep"))))
In questo caso otteniamo un testo illeggibile.

(setq testo (join (map char (crypt-text tc1 "exp"))))
;-> "An extract taken from the introduction of one of Euler's most celebrated papers, \"De summis serierum reciprocarum\" [On the sums of series of reciprocals]: I have recently found, quite unexpectedly, an elegant expression for the entire sum of this series 1 + 1/4 + 1/9 + 1/16 + etc., which depends on the quadrature of the circle, so that if the true sum of this series is obtained, from it at once the quadrature of the circle follows. Namely, I have found that the sum of this series is a sixth part of the square of the perimeter of the circle whose diameter is 1; or by putting the sum of this series equal to s, it has the ratio sqrt(6) multiplied by s to 1 of the perimeter to the diameter. I will soon show that the sum of this series to be approximately 1.644934066842264364; and from multiplying this number by six, and then taking the square root, the number 3.141592653589793238 is indeed produced, which expresses the perimeter of a circle whose diameter is 1. Following again the same steps by which I had arrived at this sum, I have discovered that the sum of the series 1 + 1/16 + 1/81 + 1/256 + 1/625 + etc. also depends on the quadrature of the circle. Namely, the sum of this multiplied by 90 gives the biquadrate (fourth power) of the circumference of the perimeter of a circle whose diameter is 1. And by similar reasoning I have likewise been able to determine the sums of the subsequent series in which the exponents are even numbers."

Testo decifrato correttamente.
La chiave vale "exp".

Vediamo la somma dei valori ASCII del testo decifrato:

(setq sol (apply + (map char (explode testo))))
;-> 129448


===========
Problema 60
===========

Insiemi di coppie di numeri primi

I numeri primi 3, 7, 109 e 673 sono piuttosto notevoli. Prendendo due numeri primi e concatenandoli in qualsiasi ordine, il risultato sarà sempre un numero primo. Ad esempio, prendendo 7 e 109, sia 7109 che 1097 sono primi. La somma di questi quattro numeri primi, 792, rappresenta la somma più bassa per un insieme di quattro numeri primi con questa proprietà.

Trova la somma più bassa per un set di cinque numeri primi per i quali qualunque coppia di numeri primi si concatenano per produrre un altro numero primo.
============================================================================

L'algoritmo di soluzione è del tipo brute-force:

Generare N numeri primi.
Il primo numero della lista dei numeri primi è "a", il secondo numero della lista è "b" (b > a).
Controllare se "ab" e "ba" sono numeri primi,
se sono numeri primi, allora prendere il terzo numero dalla lista "c" (c > b).
   controllare se "ac", "ca", "bc", "ca" sono tutti numeri primi,
   se sono numeri primi, allora prendere un quarto numero dalla lista "d" (d > c).
      controllare se "ad", "da", "bd", "db", "cd", "dc" sono tutti numeri primi,
      se sono tutti numeri primi, prendi il quinto numero dalla lista "e" (e > d)
         controllare se "ae", "ea", "be", "eb", "ce", "ec", "de", "ed" sono tutti numeri primi,
         se sono tutti numeri primi, allora stampa a + b + c + d + e.

Adesso resta il problema di definire il numero N, cioè fino a quale numero primo dobbiamo considerare?
Non possiamo fermarci quando abbiamo trovato una soluzione, perchè non sappiamo se ne esistono altre con un valore di somma minore.
Andremo per tentativi... fino a 5000, fino a 6000, fino a 7000 ecc.

Funzione per verificare se un numero n è primo:

(define (prime? n)
   (if (< n 2) nil
       (= 1 (length (factor n)))))

Funzione per generare tutti i numeri primi fino a n:

(define (sieve n)
   (setq arr (array (+ n 1)) lst '(2))
   (for (x 3 n 2)
      (when (not (arr x))
         (push x lst -1)
         (for (y (* x x) n (* 2 x) (> y n))
            (setf (arr y) true)))) lst)

(sieve 50)
;-> (2 3 5 7 11 13 17 19 23 29 31 37 41 43 47)

Funzione che controlla se la combinazione (come stringa) dei numeri ab e ba sono entrambi primi:

(define (check a b)
  (and (prime? (int (string a b))) (prime? (int (string b a)))))

Questa è più veloce.

(define (check a b)
  (local (len-a len-b)
    (setq len-a (+ (int (log a 10)) 1))
    (setq len-b (+ (int (log b 10)) 1))
    ;(setq len-a (length a))
    ;(setq len-b (length b))
    (and (prime? (int (+ (* a (pow 10 len-b)) b)))
         (prime? (int (+ (* b (pow 10 len-a)) a))))
    ;(and (prime? (int (+ (* a (pow 10 (+ (int (log b 10)) 1))) b)))
    ;     (prime? (int (+ (* b (pow 10 (+ (int (log a 10)) 1))) a))))
  )
)

(check 109 673)
;-> true
(check 3 23)
;-> nil

(define (e060 n)
  (local (primi-lst primi)
    ; (setq primi (sieve n))
    ; Il 2 e il 5 non possono essere nella soluzione perchè
    ; un numero con 2 o 5 come ultima cifra non è primo.
    (pop (setq primi (sieve n)) '(0 2))
    ;(setq primi (array (length primi-lst) primi-lst))
    ; a è il primo numero
    (dolist (a primi)
      ; b è il secondo numero
      (dolist (b primi)
        (cond ((>= a b) nil)
              (true
               (if (check a b)
                   ; c è il terzo numero
                   (dolist (c primi)
                     (cond ((>= b c) nil)
                           (true
                            ; check se (a,c) e (b,c) soddisfano la condizione
                            (if (and (check a c) (check b c))
                                ; d è il quarto numero
                                (dolist (d primi)
                                  (cond ((>= c d) nil)
                                         (true
                                          # check se (a,d), (b,d) e (c,d) soddisfano la condizione
                                          (if (and (check a d) (check b d) (check c d))
                                              ; e è il quinto numero
                                              (dolist (e primi)
                                                (cond ((>= d e) nil)
                                                       (true
                                                        ; check se (a,e), (b,e), (c,e) e (d,e) soddisfano la condizione
                                                        (if (and (check a e) (check b e) (check c e) (check d e))
                                                            (println (+ a b c d e) { } a { } b { } c { } d { } e)
                                                        )))))))))))))))))))


(e060 5000)
;-> nil
(e060 6000)
;-> nil
(e060 7000)
;-> nil
(e060 8000)
;-> nil
(e060 9000)
;-> 26033 13 5197 5701 6733 8389

(time (e060 9000))
;-> 26033 13 5197 5701 6733 8389
;-> 56943.359

La funzione impiega circa 57 secondi per trovare la soluzione (siamo sotto al minuto).

Proviamo ad usare un vettore per i numeri primi. In questo modo possiamo evitare di controllare se un numero primo selezionato è superiore al precedente, ma dobbiamo usare l'indicizzazione per trovare il valore di un numero nel vettore.

(define (e060 n)
  (local (primi primi-lst up)
    ; (setq primi (sieve n))
    ; Il 2 e il 5 non possono essere nella soluzione perchè
    ; un numero con 2 o 5 come ultima cifra non è primo.
    (pop (setq primi-lst (sieve n)) '(0 2))
    (setq primi (array (length primi-lst) primi-lst))
    (setq up (- (length primi) 1))
    ; a è il primo numero
    (for (i 0 (- up 1))
      ; b è il secondo numero
      (for (j (+ i 1) (- up 2))
        ; check se (a,b) soddisfano la condizione
        (if (check (primi i) (primi j))
            ; c è il terzo numero
            (for (k (+ j 1) (- up 3))
              ; check se (a,c) e (b,c) soddisfano la condizione
              (if (and (check (primi i) (primi k))
                       (check (primi j) (primi k)))
                  ; d è il quarto numero
                  (for (x (+ k 1) (- up 4))
                    # check se (a,d), (b,d) e (c,d) soddisfano la condizione
                    (if (and (check (primi i) (primi x))
                             (check (primi j) (primi x))
                             (check (primi k) (primi x)))
                        ; e è il quinto numero
                        (for (y (+ x 1) (- up 5))
                          ; check se (a,e), (b,e), (c,e) e (d,e) soddisfano la condizione
                          (if (and (check (primi i) (primi y))
                                   (check (primi j) (primi y))
                                   (check (primi k) (primi y))
                                   (check (primi x) (primi y)))
                              (println (+ (primi i) (primi j) (primi k) (primi x) (primi y)) { }
                                       (primi i) { } (primi j) { } (primi k) { } (primi x) { } (primi y))
                          )))))))))))

(time (e060 9000))
;-> 26033 13 5197 5701 6733 8389
;-> 55055.913

I tempi di calcolo delle due funzioni sono quasi uguali.


===========
Problema 61
===========

I numeri triangolari, quadrati, pentagonali, esagonali, ettagonali e ottagonali sono tutti numeri figurati (poligonali) e sono generati dalle seguenti formule:

Triangolo   P3,n = n(n + 1)/2     1, 3,  6, 10, 15, ...
Quadrato    P4,n = n^2            1, 4,  9, 16, 25, ...
Pentagonale P5,n = n(3n − 1)/2    1, 5, 12, 22, 35, ...
Esagonale   P6,n = n(2n − 1)      1, 6, 15, 28, 45, ...
Eptagonale  P7,n = n(5n − 3)/2    1, 7, 18, 34, 55, ...
Ottagonale  P8,n = n(3n − 2)      1, 8, 21, 40, 65, ...

L'insieme ordinato di tre numeri a 4 cifre: 8128, 2882, 8281, ha tre proprietà interessanti.

1) Il set è ciclico, in quanto le ultime due cifre di ogni numero sono le prime due cifre del numero successivo (compreso l'ultimo numero con il primo).
2) Ogni tipo poligonale: triangolo (P3,127 = 8128), quadrato (P4,91 = 8281) e pentagonale (P5,44 = 2882), è rappresentato da un numero diverso nell'insieme.
3) Questo è l'unico set di numeri a 4 cifre con questa proprietà.

Trova la somma dell'unico insieme ordinato di sei numeri ciclici a 4 cifre per i quali ogni tipo poligonale: triangolo, quadrato, pentagonale, esagonale, ettagonale e ottagonale, è rappresentato da un numero diverso nell'insieme.
============================================================================

L'algoritmo è abbastanza semplice, ma tedioso:

Creiamo le liste per ogni numero pentagonale (non possiamo avere un numero con lo 0 nella terza cifra ==> no ciclo).
Creiamo una lista totale con elementi univoci e ordinata.
Costruiamo una catena ciclica (valida) di numeri (percorrendo tutta la lista).
Se la catena contiene numeri da tutte le liste di numeri poligonali, allora abbiamo trovato la soluzione.

(define (do-tri)
  (let ((val 0) out '())
    (for (i 45 141)
      (setq val (/ (* i (+ i 1)) 2))
      (if (!= ((string val) 2) "0") (push val out -1)))
    out))

(define (do-square)
  (let ((val 0) out '())
    (for (i 32 99)
      (setq val (* i i))
      (if (!= ((string val) 2) "0") (push val out -1)))
    out))

(define (do-penta)
  (let ((val 0) out '())
    (for (i 26 81)
      (setq val (/ (* i (- (* 3 i) 1)) 2))
      (if (!= ((string val) 2) "0") (push val out -1)))
    out))

(define (do-hexa)
  (let ((val 0) out '())
    (for (i 23 71)
      (setq val (* i (- (* 2 i) 1)))
      (if (!= ((string val) 2) "0") (push val out -1)))
    out))

(define (do-hepta)
  (let ((val 0) out '())
    (for (i 21 63)
      (setq val (/ (* i (- (* 5 i) 3)) 2))
      (if (!= ((string val) 2) "0") (push val out -1)))
    out))

(define (do-octa)
  (let ((val 0) out '())
    (for (i 19 58)
      (setq val (* i (- (* 3 i) 2)))
      (if (!= ((string val) 2) "0") (push val out -1)))
    out))

(define (e061)
(catch
  (local (numeri chain all tri square penta hexa hepta octa
          ax1 ax2 ax3 ax4 ax5 ax6 bx1 bx2 bx3 bx4 bx5 bx6)
    (setq numeri (list 3 4 5 6 7 8))
    (setq chain '() all '())
    (setq tri (do-tri))
    (setq square (do-square))
    (setq penta (do-penta))
    (setq hexa (do-hexa))
    (setq hepta (do-hepta))
    (setq octa (do-octa))
    (setq all (apply extend (list tri square penta hexa hepta octa)))
    (setq all (sort (unique all)))
    ; costruisce la catena di numeri
    (dolist (x1 all)
      (setq ax1 (/ x1 100))
      (setq bx1 (% x1 100))
      (dolist (x2 all)
        (cond ((!= x1 x2)
               (setq ax2 (/ x2 100))
               (setq bx2 (% x2 100))
               (cond ((> ax2 bx1) nil)
                     ((= bx1 ax2)
                      (dolist (x3 all)
                        (cond ((!= x1 x2 x3)
                               (setq ax3 (/ x3 100))
                               (setq bx3 (% x3 100))
                               (cond ((> ax3 bx2) nil)
                                     ((= bx2 ax3)
                                      (dolist (x4 all)
                                        (cond ((!= x1 x2 x3 x4)
                                               (setq ax4 (/ x4 100))
                                               (setq bx4 (% x4 100))
                                               (cond ((> ax4 bx3) nil)
                                                     ((= bx3 ax4)
                                                      (dolist (x5 all)
                                                        (cond ((!= x1 x2 x3 x4 x5 x)
                                                               (setq ax5 (/ x5 100))
                                                               (setq bx5 (% x5 100))
                                                               (cond ((> ax5 bx4) nil)
                                                                     ((= bx4 ax5)
                                                                      (dolist (x6 all)
                                                                        (cond ((!= x1 x2 x3 x4 x5 x6)
                                                                               (setq ax6 (/ x6 100))
                                                                               (setq bx6 (% x6 100))
                                                                               (cond ((> ax6 bx5) nil)
                                                                                     ((and (= bx5 ax6) (= bx6 ax1))
                                                                                      ; creazione e controllo catena corrente
                                                                                      (setq chain (list x1 x2 x3 x4 x5 x6))
                                                                                      (setq lista '())
                                                                                      (dolist (x chain)
                                                                                        (cond ((find x octa) (push 8 lista))
                                                                                              ((find x hepta) (push 7 lista))
                                                                                              ((find x hexa) (push 6 lista))
                                                                                              ((find x penta) (push 5 lista))
                                                                                              ((find x square) (push 4 lista))
                                                                                              ((find x tri) (push 3 lista))
                                                                                        )
                                                                                        (setq lista (sort (unique lista)))
                                                                                        ; catena trovata
                                                                                        (if (= lista numeri) (throw (apply + chain)))
                                                                                      ))))))))))))))))))))))))))))))

(e061)
;-> 28684

(time (e061))
;-> 85.8


===========
Problema 62
===========

Permutazioni cubiche

Il cubo, 41063625 (3453), può essere permutato per produrre altri due cubi: 56623104 (3843) e 66430125 (4053). In effetti, 41063625 è il cubo più piccolo che ha esattamente tre permutazioni delle sue cifre che sono anche cubi.

Trova il cubo più piccolo per il quale esattamente cinque permutazioni delle sue cifre sono cubi.

Concetto di base:
Due liste con gli stessi elementi, ma in ordine diverso, producono le stesse permutazioni.

Esempio:
(setq lst1 '(1 2 3))
(setq lst2 '(2 3 1))

(sort (perm lst1))
;-> ((1 2 3) (1 3 2) (2 1 3) (2 3 1) (3 1 2) (3 2 1))

(sort (perm lst2))
;-> ((1 2 3) (1 3 2) (2 1 3) (2 3 1) (3 1 2) (3 2 1))

I numeri che possono essere permutati per produrre uno o più cubi hanno tutti le stesse cifre. Ordinando in modo decrescente le cifre di questi numeri notiamo che il risultato è lo stesso per i tutti i valori che, elevati al cubo, li generano. Vediamo un esempio:

valore   cubo                  ordinamento/codifica    risultato
3453 --> 3453^3 = 41063625 --> (digit-sort 41063625) = 66543210
3843 --> 3453^3 = 56623104 --> (digit-sort 56623104) = 66543210
4053 --> 4053^3 = 56623104 --> (digit-sort 66430125) = 66543210

In altre parole, i numeri 3453, 3843 e 4053 (che generano tutti un cubo con le stesse cifre) hanno la stessa codifica.  Per risolvere il problema occorre cercare una codifica che si ripete per 5 volte.
Quindi uno pseudo-algoritmo è il seguente:

1. valore = 0
2. codifica il valore.
3. inserisci la codifica in una lista.
4. se la codifica è presente 5 volte nella lista,
   allora il risultato vale (primo indice della codifica)^3. Stop.
   altrimenti aumenta di 1 il valore e vai al passo 3.

La prima codifica che utilizziamo è la seguente:

(setq i 27)
(setq cubo (explode (string (* i i i))))
;-> ("1" "9" "6" "8" "3")
(setq cubo (sort (explode (string (* i i i)))))
;-> ("1" "3" "6" "8" "9")

Quindi la lista contiene elementi del tipo: ("1" "3" "6" "8" "9")

Scriviamo la funzione:

(define (e062)
  (local (cubo lst num found out)
    (setq num 0 found nil)
    (until found
      ; calcoliamo la codifica
      (setq cubo (sort (explode (string (* num num num)))))
      ; inseriamo la codifica nella lista
      (push cubo lst -1)
      ; se la codifica corrente è presente 5 volte nella lista...
      (if (= (count (list cubo) lst) '(5))
          ; allora abbiamo trovato la soluzione
          (setq out (pow (first (ref cubo lst)) 3) found true)
      )
      (++ num)
    )
    out))

(e062)
;-> 127035954683

(time (e062))
;-> 23831.307

Proviamo a semplificare l'elemento della lista utilizzando un'altra codifica:

(setq i 27)
(setq cubo (explode (string (* i i i))))
;-> ("1" "9" "6" "8" "3")
(setq cubo (sort (explode (string (* i i i))) >))
;-> ("9" "8" "6" "3" "1")
(setq num 0)
(dolist (el cubo) (setq num (+ (int el) (* num 10))))
;-> 98631

Quindi la lista contiene elementi del tipo: 98631

Funzione che ordina in modo decrescente (per preservare lo zero) le cifre di un numero:

(define (digit-sort num)
  (let (out 0)
    (dolist (el (sort (explode (string num)) >))
      (setq out (+ (int el) (* out 10))))))

Scriviamo la funzione:

(define (e062)
  (local (cubo lst num found out)
    (setq num 0 found nil)
    (until found
      (setq cubo (digit-sort (* num num num)))
      (push cubo lst -1)
      (if (= (count (list cubo) lst) '(5))
          (setq out (pow (first (ref cubo lst)) 3) found true)
      )
      (++ num)
    )
    out))

(e062)
;-> 127035954683

(time (e062))
;-> 6348.037

Proviamo con un altra funzione "digit-sort" che ordina in modo decrescente (per preservare lo zero) le cifre di un numero:

(define (digit-sort num)
  (local (lst out)
    (setq lst (dup 0 10))
    (setq out 0)
    (while (> num 0)
      (++ (lst (% num 10)))
      (setq num (/ num 10))
    )
    (for (i 9 0 -1)
      (setq out (/ (- (* (pow 10 (lst i)) (+ i (* 9 out))) i) 9))
    )
    out))

(digit-sort 12340)
;-> 43210

(digit-sort 130987345354322)
;-> 987554433332210

Eseguiamo di nuovo la funzione:

(e062)
;-> 127035954683

(time (e062))
;-> 6305.131

I tempi di esecuzione delle due funzioni sono uguali.

Il secondo algoritmo utilizza una hash-map con la seguente struttura:

 chiave                       valore  
((digit-sort (* num num num)) (num ripetizioni))

In questo modo la soluzione si trova quando le ripetizioni di una chiave vale 5. Maggiori spiegazioni nei commenti della funzione.

(define (e062-2)
  (local (cubo lst num found out)
    (new Tree 'myHash)
    (setq num 0 found nil)
    (until found
      ; calcola il valore della chiave
      ; es. num=5 -> num*num*num = 125 -> cubo = 521
      (setq cubo (digit-sort (* num num num)))
      ; se la chiave non esiste nella hashmap...
      (if (null? (myHash cubo))
          ; allora inserisce il cubo (chiave) con la lista (num 1) (valore)
          ; nella lista (num 1), 1 rappresenta il numero di ripetizioni del cubo
          ; mentre num rappresenta il numero da elevare a potenza
          (myHash cubo (list num 1))
          ; altrimenti aggiunge 1 al numero di ripetizioni nella lista (valore)
          (begin
            ; occorre ricostruire tutta la lista associata alla valore di cubo (chiave)
            (myHash cubo (list (first $it) (+ (last $it) 1)))
            ; se il numero di ripetizioni vale 5 
            (if (= 5 (last (myHash cubo)))
                ; allora abbiamo trovato la soluzione
                (setq out (pow (first (myHash cubo)) 3) found true)
            )
          )
      )
      (++ num)
    )
    ; elimina la hash-map
    (delete 'myHash)
    out))

Vediamo come si comporta questa funzione:

(e062-2)
;-> 127035954683

(time (e062-2))
;-> 83.742

L'utilizzo di una hash-map fornisce la soluzione immediatamente.


===========
Problema 63
===========

Conteggio di cifre di potenze

Il numero di 5 cifre, 16807 = 7^5, è anche una quinta potenza. Allo stesso modo, il numero di 9 cifre, 134217728 = 8^9, è una nona potenza.

Quanti numeri interi positivi di n cifre esistono che sono anche un'ennesima potenza?
============================================================================

Cerchiamo un numero n tale che la lunghezza di n elevato a k sia k:  L(n^k) = k

Calcoliamo il limite superiore di n:

k = L(n^k)
k = floor(1 + log10(k^k))
k - 1 <= k*log10(n) < k
log10(n) < 1
n < 10

Quindi il valore massimo per n è 9.

Calcoliamo il limite superiore di k:

L(n^k) > k
floor(1 + k*log10(n^k)) > k
1 + k*log10(n) > k
log10(n) > (k - 1)/k = 1 - 1/k
1/k > 1 - log10(n)
k > 1/(1 - log10(n))

Con n=9 il valore massimo per k è 21:

(div (sub 1 (log 9 10)))
;-> 21.85434532678283

(define (e063)
  (let (c  0)
    (for (n 1 9)
      (for (k 1 21)
        (if (= (floor (add 1 (mul k (log n 10)))) k)
          (++ c)
        )
      )
    )
    c))

(e063)
;-> 49

(time (e063))
;-> 0

Dal punto di vista matematico possiamo notare che dalla definizione della lunghezza di  un numero L risulta:

10^(k-1) <= n^k < 10^k

Poichè n < 10, risulta che 10^(k-1) cresce più velocemente di n^k e ad un certo punto lo sorpasserà. Quindi troviamo il punto in cui queste quantità sono uguali:

10^(k-1) = n^k
(1/10)*10^k = n^k
k*log(10) - log(10) = k*log(n)
k = log(10)/(log(10 - log(n)))

Questa volta k rappresenta il numero di volte in cui le quantità considerate sono uguali (prendiamo floor(k)). La funzione è la seguente:

(define (e063-2)
  (let (res 0)
    (for (i 1 9)
      (setq res (add res (floor (div (log 10) (log (div 10 i))))))
    )
    res))

(e063-2)
;-> 49

(time (e063-2))
;-> 0

Questa seconda soluzione è molto più veloce:

(time (e063) 10000)
;-> 392.976

(time (e063-2) 10000)
;-> 20.965


===========
Problema 64
<<<<<<< HEAD
===========

Ogni radice quadrata può essere rappresentata con una frazione continua.
=======
===========

Ogni radice quadrata può essere rappresentata con una frazione continua.

La frazione continua di sqrt(23) vale [4, (1,3,1,8)]. 
La notazione indica che la frazione continua inizia con 4 e il blocco (1,3,1,8) si ripete indefinitamente.

Le prime dieci rappresentazioni di frazione continua di radici quadrate (irrazionali) sono:

sqrt( 2) = (1, (2)],         periodo = 1
sqrt( 3) = (1, (1,2)],       periodo = 2
sqrt( 4) = (2, (4)],         periodo = 1
sqrt( 6) = (2, (2,4)],       periodo = 2
sqrt( 7) = (2, (1,1,1,1)],   periodo = 4
sqrt( 8) = (2, (1,4)],       periodo = 2
sqrt(10) = (3, (6)],         periodo = 1
sqrt(11) = (3, (3,6)],       periodo = 2
sqrt(12) = (3, (2,6)],       periodo = 2
sqrt(13) = (3, (1,1,1,1,6)], periodo = 5

Esattamente quattro frazioni continue hanno un periodo dispari.

Quante frazioni continue per N <= 10000 hanno un periodo dispari?
============================================================================

L'algoritmo presentato dall'articolo "Methods of computing square roots" di wikipedia è il seguente:

Start:
 m[0] = 0
 d[0] = 1
 a[0] = floor(sqrt(n))
 k = a[0]
Loop:
 m[i] = a[i-1]*d[i-1] - m[i-1]
 d[i] = (n-m[i]*m[i])/d[i-1]
 a[i] = floor((k + m[i])/d[i])
Stop: quando la i-esima tripla è stata generata precedentemente.

Note: m[i],d[i],a[i] sono sempre interi.

L'articolo di Alexandra Ioana Gliga "On continued fractions of the square root of prime numbers" dimostra che per ogni numero intero positivo che non è un quadrato perfetto risulta:

  sqrt(n) = [a1, (a2 a3 ... an 2*a1)]

Questo ci permette di fermare il ciclo quando l'i-esimo valore vale 2*a1.

Scriviamo la funzione:

(define (e064)
  (local (max-val out limite)
    (setq max-val 10000)
    (setq out 0)
    (for (n 2 max-val)
      (setq limite (int (sqrt n)))
      ; l'algortimo non funziona quando abbiamo un quadrato perfetto
      ; quindi saltiamo questi casi che non influenzano il risultato finale
      (if (!= (* limite limite ) n)
          (let ((periodo 0) (d 1) (m 0) (a limite))
            (do-while (!= a (* 2 limite))
              (setq m (- (* d a) m))
              (setq d (/ (- n (* m m)) d))
              (setq a (/ (+ limite m) d))
              (++ periodo)
            )
            (if (odd? periodo) (++ out))
          )
      )
    )
    out))

(e064)
;-> 1322

(time (e064))
;-> 81.294


===========
Problema 65
===========

Convergenti di e

La radice quadrata di 2 può essere scritta come una frazione continua infinita.
                       1
sqrt(2) = 1 + --------------------
                         1
              2 + ----------------
                           1
                  2 + ------------
                             1
                      2 + --------
                          2 + ...

La frazione continua infinita può essere scritta come sqrt(2) = [1, (2)] indica che 2 si ripete all'infinito. In un modo simile, sqrt(23) = [4, (1,3,1,8)].

Risulta che la sequenza dei valori parziali delle frazioni continue per le radici quadrate fornisce le migliori approssimazioni razionali. Consideriamo i convergenti per sqrt(2):

1 + 1/2 = 3/2
1 + 1/(2 + 1/2) = 7/5
1 + 1/(2 + 1/(2 + 1/2)) = 17/12
1 + 1/(2 + 1/(2 + 1/(2 + 1/2))) = 41/29

Quindi la sequenza dei primi dieci convergenti per sqrt(2) sono:

1, 3/2, 7/5, 17/12, 41/29, 99/70 239/169, 577/408, 1393/985, 3363/2378, ...

La cosa più sorprendente è che per l'importante costante matematica "e" risulta:

e = [2,1,2,1,1,4,1,1,6,1...1,2k,1...]

I primi dieci termini nella sequenza di convergenti per e sono:

2, 3, 8/3, 11/4, 19/7, 87/32, 106/39, 193/71, 1264/465, 1457/536, ...

La somma delle cifre al numeratore del decimo convergente è 1 + 4 + 5 + 7 = 17.

Trova la somma delle cifre del numeratore del centesimo convergente della frazione continua per "e".
============================================================================

Calcoliamo i primi n termini della frazione continua del numero tenendo conto che il pattern ...1,2n,1... si ripete all'infinito: cf(e) = [2, 1,2,1, 1,4,1, 1,6,1, 1,8,1, 1,10,1, ...]

(define (cf_e n)
  (let (cfe '(2))
    (for (i 1 (- n 1))
      (extend cfe (list 1 (* 2 i) 1)))
    (slice cfe 0 n)))

(cf_e 20)
;-> (2 1 2 1 1 4 1 1 6 1 1 8 1 1 10 1 1 12 1 1)

Poi scriviamo una funzione che calcola i convergenti partendo da una frazione continua e restituisce l'ultima delle frazioni convergenti Pn/Qn (dobbiamo usare i big-integer perchè il numeratore e il denominatore delle frazioni convergenti crescono velocemente):

(define (cf2conv cf)
  (local (p0 q0 p1 q1 p2 q2)
    (cond ((= (length cf) 1) (setq p2 (first cf) q2 1))
          (true
           (setq p0 1L q0 0L)
           (setq p1 (bigint (cf 0)) q1 1L)
           (for (k 1 (- (length cf) 1))
             (setq p2 (+ (* p1 (cf k)) p0))
             (setq q2 (+ (* q1 (cf k)) q0))
             ; k-esima frazione convergente
             ;(println (list p2 q2 (div p2 q2)))
             (setq p0 p1 q0 q1 p1 p2 q1 q2)
           ))
    )
    (list p2 q2)))

(cf2conv (cf_e 20))
;-> (28245729L 10391023L)

Poi ci serve una funzione che converte un numero in una lista:

(define (int2lst num)
  (let (out '())
    (while (!= num 0)
      (push (% num 10) out)
      (setq num (/ num 10))) out))

Adesso possiamo scrivere la funzione finale:

(define (e065)
  (local (numer)
    (setq numer (first (cf2conv (cf_e 100))))
    (apply + (int2lst numer))))

(e065)
;-> 272L

(time (e065))
;-> 0


===========
Problema 66
===========

# Equazione di Pell
# x^2 - D*y^2 = 1
#
# Espandere sqrt(D) in frazione continua
# sqrt(D) = [q0,q1,q2,...,qn,2*q0]
# Periodo della frazione continua = n
# Calcolare l'n-esimo convergente della frazione continua (Pn/Qn).
# Se n è dispari allora Pn e Qn sono la soluzione.
# Se n è pari occorre:
#    Espandere sqrt(D) in frazione continua fino al termine (2n+1)
#    Calcolare i convergenti fino al termine (2n+1).
#    P(2*n+1) e Q(2*n+1) sono le soluzioni. 
       	
(define (Pell n)
  (local (z r x y e1 e2 f1 f2 A B t1 t2)
    (setq x (bigint (int (sqrt n))))
    (setq y x)
    (setq z 1L)
    (setq r (* x 2))
    (setq e1 1L e2 0L)
    (setq f1 0L f2 1L)
    (catch
      (while true
        (setq y (bigint (- (* r z) y)))
        (setq z (bigint (/ (- n (* y y)) z)))
        (setq r (bigint (/ (+ x y) z)))
        (setq t1 e1) (setq t2 e2)
        (setq e1 t2)
        (setq e2 (bigint (+ (* t2 r) t1)))
        (setq t1 f1) (setq t2 f2)
        (setq f1 t2)
        (setq f2 (bigint (+ (* t2 r) t1)))
        (setq A f2)
        (setq B e2)
        (setq t1 A) (setq t2 B)
        (setq B t1)
        (setq A (bigint (+ (* t1 x) t2)))
        (if (= (- (* A A) (* B B n)) 1) (throw (list A B)))
        ;(println (format "z = %s\nr = %s\nx = %s\ny = %s" (string z) (string r) (string x) (string y)))
        ;(println (format "e1 = %s\ne2 = %s\nf1 = %s\nf2 = %s" (string e1) (string e2) (string f1) (string f2)))
        ;(println (format "A = %s\nB = %s" (string A) (string B)))
        ;(read-line)
      );while
    );catch
  );local
)

(Pell 61)
;-> (1766319049L 226153980L)

(Pell 109)
;-> (158070671986249L 15140424455100L)

(Pell 181)
;-> (2469645423824185801L 183567298683461940L)

(Pell 277)
;-> (159150073798980475849L 9562401173878027020L)

Se passiamo un numero quadrato, otteniamo un errore:

(Pell 4)
;-> ERR: division by zero
;-> called from user function (Pell 4)

Scriviamo la funzione finale per risolvere il problema:

(define (e066)
  (let ((maxval -1) (out 0))
    (for (i 1 1000)
      (if (!= (sqrt i) (int (sqrt i)))
          (if (> (first (Pell i)) maxval)
              (setq maxval (first (Pell i)) out i))))
    out))

(e066)
;-> 661

(time e066)
;-> 0


===========
Problema 67
===========

Percorso con somma massima II

Iniziando dalla parte superiore del triangolo in basso e passando ai numeri adiacenti sulla riga sottostante, il totale massimo dall'alto verso il basso è 23.

   3
  7 4
 2 4 6
8 5 9 3

Cioè, 3 + 7 + 4 + 9 = 23.

Trovare il totale massimo dall'alto verso il basso utilizzando "triangle.txt", un file di testo di 15K contenente un triangolo con cento righe.

NOTA: questa è una versione molto più difficile del problema 18. Non è possibile provare tutti i percorsi per risolvere questo problema, poiché ce ne sono 2^99 in tutto! Potendo controllare un trilione (10^12) di percorsi ogni secondo, ci vorrebbero oltre venti miliardi di anni per controllarli tutti. C'è un algoritmo efficiente per risolverlo.
============================================================================

Il file "triangle.txt" è stato trasformato in "e067.lsp" che ha il seguente formato:

(setq tri (dup 0 100))
(setf (tri 0) '(59)) 
(setf (tri 1) '(73 41)) 
(setf (tri 2) '(52 40 9)) 
(setf (tri 3) '(26 53 6 34)) 
...

Per caricare il file:

(load "e067.lsp")

Una soluzione generica può essere ottenuta con la programmazione dinamica. In pratica per trovare la soluzione, ogni riga deve essere aggiunta a qualsiasi riga successiva, dal basso verso l'alto. Poiché ogni cella ha due predecessori, prendiamo il valore massimo delle due. Con questo metodo, la soluzione si trova nella cella superiore del triangolo:

(load "e067.lsp")

(define (e067)
    (for (i (- (length tri) 2) 0 -1)
      (for (j 0 i)
        (setf (tri i j) (+ (tri i j) (max (tri (+ i 1) j) (tri (+ i 1) (+ j 1)))))
      )
    )
    (tri 0 0))

(e067)
;-> 7273

(time (e067))
;-> 1.995


===========
Problema 68
===========

Considera il seguente anello "magico" 3-gon, riempito con i numeri da 1 a 6 e ogni riga somma a nove.

       4  
        \
         3 
        / \    
       1---2---6
      /
     5
     
Lavorando in senso orario, e partendo dal gruppo di tre con il nodo esterno numericamente più basso (4,3,2 in questo esempio), ogni soluzione può essere descritta in modo univoco. Ad esempio, la soluzione di cui sopra può essere descritta dall'insieme: 4,3,2 - 6,2,1 - 5,1,3.

È possibile completare l'anello con quattro diversi totali: 9, 10, 11 e 12. Ci sono otto soluzioni in totale.

Totale   Soluzioni
   9     4,2,3 - 5,3,1 - 6,1,2
   9     4,3,2 - 6,2,1 - 5,1,3
  10     2,3,5 - 4,5,1 - 6,1,3
  10     2,5,3 - 6,3,1 - 4,1,5
  11     1,4,6 - 3,6,2 - 5,2,4
  11     1,6,4 - 5,4,2 - 3,2,6
  12     1,5,6 - 2,6,4 - 3,4,5
  12     1,6,5 - 3,5,4 - 2,4,6
  
Concatenando ogni gruppo è possibile formare stringhe di 9 cifre: la stringa massima per un anello 3-gon è 432621513.

Utilizzando i numeri da 1 a 10, a seconda degli arrangiamenti, è possibile formare stringhe di 16 e 17 cifre. Qual è il numero massimo di 16 cifre per un anello "magico" 5-gon?
============================================================================

Funzione che calcola le permutazioni:

(define (perm lst)
  (local (i indici out)
    (setq indici (dup 0 (length lst)))
    (setq i 0)
    ; aggiungiamo la lista iniziale alla soluzione
    (setq out (list lst))
    (while (< i (length lst))
      (if (< (indici i) i)
          (begin
            (if (zero? (% i 2))
              (swap (lst 0) (lst i))
              (swap (lst (indici i)) (lst i))
            )
            ;(println lst);
            (push lst out -1)
            (++ (indici i))
            (setq i 0)
          )
          (begin
            (setf (indici i) 0)
            (++ i)
          )
       )
    )
    out))

(define (gon lst)
  (local (is-gon gonL pL6 pL7 pL8 pL9 pL10 p6 p7 p8 p9 p10)
    (setq is-gon nil)
    (setq gonL '() pL6 '() pL7 '() pL8 '() pL9 '() pL10 '())
    (setq p6  (+ (lst 6)  (lst 1) (lst 2)))
    (setq p7  (+ (lst 7)  (lst 2) (lst 3)))
    (setq p8  (+ (lst 8)  (lst 3) (lst 4)))
    (setq p9  (+ (lst 9)  (lst 4) (lst 5)))
    (setq p10 (+ (lst 10) (lst 5) (lst 1)))
    ; Controllo se le somme sono uguali
    (cond ((and (= p6 p7) (= p7 p8) (= p8 p10) (= p9 p10))
           (setq is-gon true)
           ; Cerco l'indice del valore minimo esterno
           ; cioè cerco il numero 6, perchè all'esterno ci devono
           ; stare i numeri 6,7,8,9,10.
           (setq indice (find 6 lst))
           ; Costruisco la lista soluzione
           (setq pL6  (list (lst 6)  (lst 1) (lst 2)))
           (setq pL7  (list (lst 7)  (lst 2) (lst 3)))
           (setq pL8  (list (lst 8)  (lst 3) (lst 4)))
           (setq pL9  (list (lst 9)  (lst 4) (lst 5)))
           (setq pL10 (list (lst 10) (lst 5) (lst 1)))
           (cond ((= indice 6)  (setq gonL (apply extend (list pL6  pL7  pL8  pL9  pL10))))
                 ((= indice 7)  (setq gonL (apply extend (list pL7  pL8  pL9  pL10 pL6))))
                 ((= indice 8)  (setq gonL (apply extend (list pL8  pL9  pL10 pL6  pL7))))
                 ((= indice 9)  (setq gonL (apply extend (list pL9  pL10 pL6  pL7  pL8))))
                 ((= indice 10) (setq gonL (apply extend (list pL10 pL6  pL7  pL8  pL9))))
           ))
    )
    (if is-gon
        (list gonL p6)
        (list '() 0))))

(define (e068)
  (local (vmax pa pb val go x y)
    (setq vmax 0)
    (setq pa (perm '(1 2 3 4 5)))
    (setq pb (perm '(6 7 8 9 10)))
    (dolist (a pa)
      (setq val '())
      (dolist (b pb)
        (setq val (apply extend (list '(0) a b)))
        (setq go (gon val))
        (setq x (first go))
        (setq y (last go))
        (if (!= y 0)
          (begin
           ;(println x { } y)
           (if (> (int (join (map string x))) vmax)
               (setq vmax (int (join (map string x))))
           ))
        )
      )
    )
    vmax))

(e068)
;-> 6531031914842725

(time (e068))
;-> 21.97


===========
Problema 70
===========

Pemutazione toziente

La funzione toziente di Eulero, φ(n) (a volte chiamata funzione phi), è usata per determinare il numero di numeri positivi minori o uguali a n che sono primi relativamente a n. Ad esempio, poiché 1, 2, 4, 5, 7 e 8 sono tutti inferiori a nove e primi relativamente a nove, φ(9) = 6.
Il numero 1 è considerato relativamente primo rispetto a ogni numero positivo, quindi φ(1)= 1.

È interessante notare che φ(87109) = 79180, e si può vedere che 87109 è una permutazione di 79180.

Trova il valore di n, 1 < n < 10^7, per cui φ(n) è una permutazione di ne il rapporto n/φ(n) produce un minimo.
============================================================================

Utilizziamo un approccio con la forza bruta.

Funzione che verifica se due numeri hanno le stesse cifre:

(define (perm? n1 n2)
  (if (!= (length n1) (length n2))
      nil
      (let (ar (array 10 '(0)))
        (while (!= n1 0)
            (++ (ar (% n1 10)))
            (setq n1 (/ n1 10))
        )
        ;(println ar)
        (while (!= n2 0)
            (-- (ar (% n2 10)))
            (setq n2 (/ n2 10))
        )
        ;(println ar)
        (= (count '(0) (array-list ar)) '(10)))))

(perm? 123123 112233)
;-> true

Funzione che calcola il toziente da 0 fino a n numeri:

(define (totients-to num)
  (let (phi (array (+ num 1) '(0)))
    (setf (phi 0) 0)
    (setf (phi 1) 1)
    (for (i 2 num)
      (setf (phi i) i))
    (for (i 2 num)
      (if (= (phi i) i)
          (for (j i num i)
            (setf (phi j) (- (phi j) (/ (phi j) i))))))
     phi))

(totients-to 10)
;-> (0 1 1 2 2 4 2 6 4 6 4)

Scriviamo la funzione finale:

(define (e070)
  (local (t idx cur-val min-val)
    (setq t (totients-to 9999999))
    (setq min-val 999999)
    (setq idx-val nil)
    ; cerca il valore minimo
    (for (i 2 9999999)
      (setq cur-val (t i))
      (if (< (div i cur-val) min-val)
          (if (perm? cur-val i)
                  (setq idx-val i min-val (div i cur-val))
              )
          )
    )
    idx-val))

(e070)
;-> 8319823

(time (e070))
;-> 9621.575

Dal punto di vistta matematico possimo notare che:

1) Rendere minimo n/φ(n) equivale a massimizzare φ(n)/n, che si verifica quando n ha il minor numero di fattori primi possibile.
2) φ(n) = n - 1 dove n è primo, poiché tutti i numeri sotto sono coprimi per definizione
3) φ(n) = φ(pq) = (p - 1) (q - 1) dove n è semiprimo e p e q sono i suoi fattori e p <> q.
4) φ(n) = φ(p2) = (p - 1) p dove n è semiprime ep è il suo unico fattore distinto.
5) n - 1 non può essere una permutazione di n, quindi il nostro n non può essere un primo, ma è probabilmente il prodotto di due numeri primi (semiprimi).

Funzone che calcola tutti i numeri primi da 1 fino a un dato numero:

(define (primes-to num)
  (cond ((= num 1) '())
        ((= num 2) '(2))
        (true
         (let (lst '(2))
          (setq arr (array (+ num 1)))
          (for (x 3 num 2)
                (when (not (arr x))
                  (push x lst -1)
                  (for (y (* x x) num (* 2 x) (> y num))
                      (setf (arr y) true)))) lst))))

Le considerazioni precedenti portano (dopo molti tentativi) alla seguente funzione:

(define (e070)
(catch
  (local (num primi min-q min-n q n totient)
  (setq num 10000000)
  (setq primi (primes-to (int (mul 1.25 (sqrt num)))))
  (setq primi (slice primi (int (mul 0.5 (length primi)))))
  (setq min-q 2 min-n 0 i 0)
  (dolist (p1 primi)
    (dolist (p2 (slice primi i))
      (cond ((!= (% (+ p1 p2) 9) 1) nil)
            (true
             (setq n (* p1 p2))
             (if (> n num) (throw min-n)) ; soluzione trovata
             (setq totient (* (- p1 1) (- p2 1)))
             (setq q (div n totient))
             (if (and (> min-q q) (perm? totient n))
                 (setq min-q q min-n n))))))
  'not-found)))

(e070)
;-> 8319823

(time (e070))
;-> 7.012


===========
Problema 71
===========

Frazioni ordinate

Considera la frazione, n/d, dove n e d sono numeri interi positivi. Se n < d e HCF(n,d) = 1, si parla di frazione propria ridotta.

Se elenchiamo l'insieme delle frazioni proprie ridotte per d ≤ 8 in ordine crescente di dimensione, otteniamo:

1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8

Si può vedere che 2/5 è la frazione immediatamente a sinistra di 3/7.

Elencando l'insieme delle frazioni proprie ridotte per d ≤ 1.000.000 in ordine crescente di dimensione, trova il numeratore della frazione immediatamente a sinistra di 3/7.
============================================================================

Nota: HCF = High Common Factor (fattore comune maggiore)

(define (find-upper n base)
  (let ((a 1) (cont true))
    (while (and (< a n) cont)
      (if (> (div a n) base)
          (setq cont nil)
          (++ a)))
    a))

(find-upper 8 (div 3 7))
;-> 4
(find-upper 1000000 (div 3 7))
;-> 428572

(define (e071)
  (local (n num den minimo base limite a b)
    (setq n 1000000)
    (++ n)
    (setq num 1 den 1)
    (setq minimo 0)
    (setq base (div 3 7))
    (setq limite (find-upper n base))
    (setq a (- limite 2))
    (while (< a limite)
      (setq b (+ a 1))
      (while (< b n)
        (setq v (div a b))
        (if (and (< v base) ( > v minimo))
            (setq num a den b minimo (div num den))
        )
        (++ b)
      )
      (++ a)
    )
    ;(list num den (div num den))
    num))

(e071 1000000)
;-> 428570

(time (e071))
;-> 191.169


===========
Problema 72
===========

Conteggio delle frazioni

Considera la frazione, n/d, dove n e d sono numeri interi positivi. Se n <de HCF (n, d) = 1, si parla di frazione propria ridotta.

Se elenchiamo l'insieme delle frazioni proprie ridotte per d ≤ 8 in ordine crescente di dimensione, otteniamo:

1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8

Si può vedere che ci sono 21 elementi in questo set.

Quanti elementi sarebbero contenuti nell'insieme delle frazioni proprie ridotte per d ≤ 1.000.000?
============================================================================

Ordinando le frazioni in una matrice si ottiene il seguente risultato (n=10):

  1/2   1/3   1/4   1/5   1/6   1/7   1/8   1/9  1/10
    0   2/3   1/2   2/5   1/3   2/7   1/4   2/9   1/5
    0     0   3/4   3/5   1/2   3/7   3/8   1/3  3/10
    0     0     0   4/5   2/3   4/7   1/2   4/9   2/5
    0     0     0     0   5/6   5/7   5/8   5/9   1/2
    0     0     0     0     0   6/7   3/4   2/3   3/5
    0     0     0     0     0     0   7/8   7/9  7/10
    0     0     0     0     0     0     0   8/9   4/5
    0     0     0     0     0     0     0     0  9/10
    0     0     0     0     0     0     0     0     0

(1/2, 1/3, 1/4, 1/5, 1/6, 1/7, 1/8, 1/9, 1/10, 2/3, 2/5, 2/7, 2/9,
3/4, 3/5, 3/7, 3/8, 3/10, 4/5, 4/7, 4/9, 5/6, 5/7, 5/8, 5/9, 6/7,
7/8, 7/9, 7/10, 8/9, 9/10)

Notiamo che:
a) le colonne con denominatore numero primo hanno (denominatore - 1) termini.
b) le colonne con denominatore non primo hanno toziente(denominatore) termini.
(dove toziente(n) è il numero di interi minori di n che sono primi rispetto a n)

Funzione che verifica se un numero è primo:

(define (prime? num)
   (if (< num 2) nil
       (= 1 (length (factor num)))))

Funzione che calcola il toziente di un numero:

(define (toziente num)
  (if (= num 1) 1
    (let (res num)
      (dolist (f (unique (factor num)))
        (setq res (- res (/ res f))))
      res)))

Scriviamo la funzione finale:

(define (e072)
  (let ((num 1000000) (somma 0))
    (for (i 2 num)
      (if (prime? i)
          (setq somma (+ somma (- i 1)))
          (setq somma (+ somma (toziente i)))
      )
    )
    somma))

(e072)
;-> 303963552391

(time (e072))
;-> 2060.973


===========
Problema 76
===========

Conteggio delle somme

È possibile scrivere cinque come somma in esattamente sei modi diversi:

4 + 1
3 + 2
3 + 1 + 1
2 + 2 + 1
2 + 1 + 1 + 1
1 + 1 + 1 + 1 + 1

In quanti modi diversi si può scrivere cento come somma di almeno due numeri interi positivi?
============================================================================

La soluzione è simile a quella del problema 31. Le uniche differenze sono:
1) il totale vale 100 (invece di 200)
2) le monete (gli interi in questo caso) vanno da 1 a 99 (invece che (1 2 5 10 20 50 100 200))

(define (e076)
  (local (totale monete modi)
    ; valore obiettivo
    (setq totale 100)
    ; lista dei tagli di monete disponibili
    (setq monete (sequence 1 99))
    ; crea un vettore di totale elementi con tutti valori 0 tranne il primo (modi[0]) che vale 1
    (setq modi (array (+ totale 1) (extend '(1) (dup 0 totale))))
    (dolist (el monete)
      (for (i el totale)
        (setq (modi i) (+ (modi i) (modi (- i el))))
      )
    )
    (modi totale)))

(e076)
;-> 190569291

(time (e076))
;-> 0


===========
Problema 87
===========

Triple potenze di primi

Il numero più piccolo esprimibile come la somma di un quadrato primo, un cubo primo e una quarta potenza primo è 28. In effetti, ci sono esattamente quattro numeri inferiori a cinquanta che possono essere espressi in questo modo:

28 = 2^2 + 2^3 + 2^4
33 = 3^2 + 2^3 + 2^4
49 = 5^2 + 2^3 + 2^4
47 = 2^2 + 3^3 + 2^4

Quanti numeri inferiori a cinquanta milioni possono essere espressi come la somma di un quadrato primo, un cubo primo e una quarta potenza primo?
============================================================================

Funzione per calcolare i numeri primi fino a n:

(define (primes-to num)
  (cond ((= num 1) '())
        ((= num 2) '(2))
        (true
         (let (lst '(2))
          (setq arr (array (+ num 1)))
          (for (x 3 num 2)
                (when (not (arr x))
                  (push x lst -1)
                  (for (y (* x x) num (* 2 x) (> y num))
                      (setf (arr y) true)))) lst))))

L'algoritmo è abbastanza semplice e può essere estrapolato dai commenti della funzione:

(define (e087)
  (local (val primi primi2 primi3 primi4 limite out)
    (setq out '())
    (setq limite 50000000)
    # calcola i primi fino a sqrt(limite)
    (setq primi (primes-to (int (sqrt limite))))
    ; calcola i quadrati di questi primi (< limite)
    (setq primi2 (filter (fn(x) (< x limite)) (map (fn(x) (* x x)) primi)))
    ; calcola i cubi di questi primi (< limite)
    (setq primi3 (filter (fn(x) (< x limite)) (map (fn(x) (* x x x)) primi)))
    ; calcola le quarte potenze di questi primi (< limite)
    (setq primi4 (filter (fn(x) (< x limite)) (map (fn(x) (* x x x x)) primi)))
    ;(println "p= " primi {-} "p2= " primi2 {-} "p3= " primi3 {-} "p4= " primi4)
    ; crea una lista con le somme di tutti i numeri delle tre liste
    (dolist (a primi2)
      (dolist (b primi3)
        (dolist (c primi4)
          (setq val (+ a b c))
          (if (< val limite) 
              (push val out -1)
          ))))
    ; elimina i numeri multipli dalla lista
    (length (unique out))))

(e087)
;-> 1097343

(time (e087))
;-> 1153.946

Per ottimizzare la funzione potremmo:
1) Generare primi2, primi3 e primi4 fino ai numeri i cui quadrati, cubi e quarte potenze sono inferiori al limite
2) fermare il ciclo b quando (a + b) > limite
3) fermare il ciclo c quando (a + b + c) > limite
4) inserire i valori in una hash-map

Comunque il tempo di esecuzione è soddisfacente.


===========
Problema 89
===========

Numeri romani

Affinché un numero scritto in numeri romani sia considerato valido, ci sono regole di base che devono essere seguite. Anche se le regole consentono di esprimere alcuni numeri in più di un modo, esiste sempre un modo "migliore" per scrivere un numero particolare.

Ad esempio, sembrerebbe che ci siano almeno sei modi per scrivere il numero sedici:

IIIIIIIIIIIIIIII
VIIIIIIIIIII
VVIIIIII
XIIIIII
VVVI
XVI

Tuttavia, secondo le regole sono validi solo XIIIIII e XVI, e l'ultimo esempio è considerato il più efficiente, poiché utilizza il minor numero di numeri.

Il file di testo 11K, roman.txt, contiene mille numeri scritti in numeri romani validi, ma non necessariamente minimi. V`edi Informazioni sui Numeri romani per le regole definitive di questo problema (.

Trova il numero di caratteri salvati scrivendo ciascuno di questi nella loro forma minima.

Nota: si può presumere che tutti i numeri romani nel file non contengano più di quattro unità identiche consecutive.
============================================================================

Funzione di conversione da numero intero a numero romano:

(define (integer2roman num)
  (local (table roman k)
    (setq table '(("M" 1000) ("CM" 900) ("D" 500) ("CD" 400)
          ("C" 100)("XC" 90)("L" 50)("XL" 40) ("X" 10) ("IX" 9) ("V" 5)
          ("IV" 4) ("I" 1)))
    (setq roman "")
    (dolist (el table)
      (setq k (/ num (last el)))
      (setq num (% num (last el)))
      (extend roman (dup (first el) k))
    )
    roman))

(integer2roman 4444)
;-> "MMMMCDXLIV"

(integer2roman 16)
;-> "XVI"

Funzione di conversione da numero romano a numero intero:

(define (roman2integer roman)
  (local (table curr prev num)
    (setq table '(("I" 1) ("V" 5) ("X" 10) ("L" 50) ("C" 100) ("D" 500) ("M" 1000)))
    (setq prev 0 num 0)
    ; iterate through all characters
    (dostring (ch roman)
      ; converts the current character into an integer
      (setq curr (lookup (char ch) table))
      ; pick the right case to add or substract
      (if (>= prev curr) 
          (setq num (+ num prev))
          (setq num (- num prev))
      )
      (setq prev curr)
    )
    ; add the last value
    (setq num (+ num curr))))

(roman2integer "MMMMCDXLIV")
;-> 4444

(roman2integer "XIIIIII")
;-> 16

Il file "roman.txt" è stato trasformato nel file "e089.lsp" che ha la seguente struttura:

(setq roma '("MMMMDCLXXII" "MMDCCCLXXXIII" "MMMDLXVIIII" ...)

Scriviamo la funzione finale:

(define (e089)
  (local (somma len1 len2)
    (setq somma 0)
    (dolist (el roma)
      (setq len1 (length el))
      (setq len2 (length (integer2roman (roman2integer el))))
      (setq somma (+ somma (- len1 len2)))
      ;(println (list el (length el)) { }
      ;         (list (integer2roman (roman2integer el)) (length (integer2roman (roman2integer el)))))
      ;(read-line)
    )
    somma))

Carichiamo il file ed eseguiamo la funzione:

(load "roma.lsp")
(length roma)
;-> 1000

(e089)
;-> 743

(time e089)
;-> 0


===========
Problema 92
===========

Catena del quadrato delle cifre

Una catena di numeri viene creata aggiungendo continuamente il quadrato delle cifre in un numero per formare un nuovo numero fino a quando non è stato visto prima.

Per esempio,

44 → 32 → 13 → 10 → 1 → 1
85 → 89 → 145 → 42 → 20 → 4 → 16 → 37 → 58 → 89

Pertanto qualsiasi catena che arriva a 1 o 89 rimarrà bloccata in un ciclo infinito. La cosa più sorprendente è che OGNI numero di partenza alla fine arriverà a 1 o 89.

Quanti numeri di partenza sotto i dieci milioni arriveranno a 89?
============================================================================

Prima di definire la funzione cha calcola la catena, dobbiamo scrivere la funzione cha calcola la somma dei quadrati delle cifre di un numero:

Prima versione "sum-sq-digit":

(define (int-lst num)
  (let (out '())
    (while (!= num 0)
      (push (% num 10) out)
      (setq num (/ num 10))) out))

(define (sum-sq-digit num)
  (apply + (map (fn(x) (* x x)) (int-lst num))))

(sum-sq-digit 32)
;-> 13
(sum-sq-digit 456)
;-> 77
(time (sum-sq-digit 12345678901234567890) 100000)
;-> 1554.87

Seconda versione "sum-sq-digit":

(define (sum-sq-digit num)
  (let ((cifra 0) (tot 0))
  (while (> num 0)
    (setq cifra (% num 10))
    (setq num (/ (- num cifra) 10))
    (setq tot (+ tot (* cifra cifra)))
  )
  tot))

(sum-sq-digit 32)
;-> 13
(sum-sq-digit 456)
;-> 77
(time (sum-sq-digit 12345678901234567890) 100000)
;-> 1263.057
;-> 140.624

Terza versione "sum-sq-digit":

(define (sum-sq-digit num)
  (let ((cifra 0) (tot 0))
  (while (> num 0)
    (setq cifra (% num 10))
    (setq tot (+ tot (* cifra cifra)))
    (setq num (/ num 10))
  )
  tot))

(sum-sq-digit 32)
;-> 13
(sum-sq-digit 456)
;-> 77
(time (sum-sq-digit 12345678901234567890) 100000)
;-> 1112.057

Quarta versione "sum-sq-digit":

(define (sum-sq-digit num)
  (let ((cifra 0) (tot 0))
  (while (> num 0)
    (setq cifra (% num 10))
    (if cifra
      (setq tot (+ tot (* cifra cifra))))
    (setq num (/ num 10))
  )
  tot))

(sum-sq-digit 32)
;-> 13
(sum-sq-digit 456)
;-> 77
(time (sum-sq-digit 12345678901234567890) 100000)
;-> 1106.45

Adesso scriviamo la funzione che calcola la catena di un numero:

(define (chain num)
  (local (chain-lst num-lst val found out)
    (setq val num found nil)
    (until found
      (setq num (sum-sq-digit num))
      (push num chain-lst -1)
      (if (or (= num 1) (= num 89))
          (setq out (list val num (length chain-lst) chain-lst) found true)
      )
    )
    out))

Vediamo alcuni esempi di catene:

(chain 100)
;-> (100 1 1 (1))
(chain 1)
;-> (1 1 1 (1))
(chain 89)
;-> (89 89 8 (145 42 20 4 16 37 58 89))
(chain 44)
;-> (44 1 4 (32 13 10 1))
(chain 85)
;-> (85 89 1 (89))

(for (i 1 20) (println (chain i)))
;-> (1 1 1 (1))
;-> (2 89 5 (4 16 37 58 89))
;-> (3 89 7 (9 81 65 61 37 58 89))
;-> (4 89 4 (16 37 58 89))
;-> (5 89 4 (25 29 85 89))
;-> (6 89 9 (36 45 41 17 50 25 29 85 89))
;-> (7 1 5 (49 97 130 10 1))
;-> (8 89 5 (64 52 29 85 89))
;-> (9 89 6 (81 65 61 37 58 89))
;-> (10 1 1 (1))
;-> (11 89 6 (2 4 16 37 58 89))
;-> (12 89 5 (5 25 29 85 89))
;-> (13 1 2 (10 1))
;-> (14 89 6 (17 50 25 29 85 89))
;-> (15 89 6 (26 40 16 37 58 89))
;-> (16 89 3 (37 58 89))
;-> (17 89 5 (50 25 29 85 89))
;-> (18 89 5 (65 61 37 58 89))
;-> (19 1 4 (82 68 100 1))
;-> (20 89 5 (4 16 37 58 89))

Scriviamo la funzione che calcola la soluzione con la forza bruta:

(define (e092)
  (local (num n89 found)
    (setq num 9999999 n89 0)
    (for (i 1 num)
      (setq found nil)
      (setq k i)
      (until found
        ;(setq k (apply + (map (fn(x) (* x x)) (int-lst k))))
        (setq k (sum-sq-digit k))
        (if (= k 89) (setq n89 (+ n89 1) found true))
        (if (= k 1)  (setq found true))
      )
    )
    n89))

(e092)
;-> 8581146

(time (e092))
;-> 51582.689

Il tempo di esecuzione non è molto soddisfacente.

Per trovare un algoritmo migliore dobbiamo fare alcune considerazioni.

Notiamo che due numeri che hanno le stesse cifre hanno la stessa catena perchè calcoliamo la somma dei quadrati delle cifre. Per esempio i numeri 4666777 e 6767674 hanno la stessa catena:

(chain 4666777)
;-> (4666777 89 9 (271 54 41 17 50 25 29 85 89))

(chain 6767674)
;-> (6767674 89 9 (271 54 41 17 50 25 29 85 89))

Quindi tutti i numeri che hanno le stesse cifre (non considerando lo 0 perchè facciamo il quadrato di ogni cifra) hanno la stessa catena.

Inoltre, la più grande somma possibile di quadrati è creata dal numero 9999999, che vale 7^9 = 567.
Possiamo usare questo numero come dimensione di una lista che contiene tutti i valori generati dal calcolo della somma dei quadrati delle cifre per i numeri inferiori 10 milioni (questo perchè tutti gli altri numeri inferiori a 10 milioni sono solo permutazioni con una somma minore).

Prima scriviamo una funzione che restituisce true se la catena di un dato numero termina con 89, altrimenti restituisce nil:

(define (end89? n)
  (local (sum x)
    (while (and (!= n 1) (!= n 89))
      (setq sum 0)
      (while (> n 0)
        (setq x (% n 10))
        (setq sum (+ sum (* x x)))
        (setq n (/ n 10))
      )
      (setq n sum)
    )
    (= n 89)))

(end89? 1)
;-> nil
(end89? 89)
;-> true
(end89? 4666777)
;-> true
(end89? 6767674)
;-> true

Poi possiamo creare la lista che contiene le somme:

(setq lst-sum '(0))
(for (i 1 567) (push (end89? i) lst-sum -1))

I valori delle somme non coprono tutti i numeri da 1 a 567:

(count '(true) lst-sum)
;-> 486

Adesso dobbiamo sapere quante volte un dato insieme di cifre può verificarsi sotto i 10 milioni. Questo è semplicemente il fattoriale del numero totale di elementi (cioè quante cifre, 7) diviso per il prodotto dei fattoriali dei conteggi degli elementi unici (quante volte compare ogni cifra):

(numero-elementi-gruppo = 7! / (c1! * c2! * ... * c9!))

Per esempio, per il numero 4666777 otteniamo che il numero di elementi vale (coefficiente multinomiale):

numero-elementi-gruppo(4666777) = 7! / (1! * 3! * 3!) = 140

Vediamo quante combinazioni di cifre univoche ci sono da 1 a 9999999 (combinazioni con ripetizione):

(define (comb-rep k lst)
  (cond ((zero? k 0) '(()))
        ((null? lst) '())
        (true
         (append (map (lambda (x) (cons (first lst) x))
                      (comb-rep (- k 1) lst))
                 (comb-rep k (rest lst))))))

(setq numeri (comb-rep 7 '(1 2 3 4 5 6 7 8 9 0)))
(length numeri)
;-> 11440

Esistono solo 11.440 combinazioni di cifre univoche comprese tra 1 e 9999999.

Quindi dobbiamo trovare un modo per calcolare la catena solo di questi numeri.
Potremmo utilizzare 9 cicli "for" per generare numeri del tipo "abcdefg" e quando le cifre soddisfano a≤b≤c≤d≤e≤f≤g, allora controllare la somma nella lista delle somme (lst-sum). Se la catena termina con 89, dobbiamo aggiungere tutte le possibili combinazioni (calcolate con il coefficiente multinomiale) al risultato.

Per velocizzare i calcoli utilizziamo una lista precalcolata per i fattoriali da 0 a 7:

fact = (1 1 2 6 24 120 720 5040)

Oppure possiamo utilizzare direttamente i numeri della lista "numeri", verificare se la sua catena di ogni termina con 89 ed eventualmente aggiungere al totale il numero degli elementi del suo gruppo (cioè tutti i numeri che conducono a 89) calcolando il relativo coefficiente multinomiale.

Proviamo a scrivere una funzione con quest'ultimo algoritmo.

Funzione che converte una lista in un intero:

(define (lst-int lst)
  (let (num 0)
    (dolist (el lst) (setq num (+ el (* num 10))))))

Funzione finale:

(define (e092)
  (local (fact numeri num out)
    (setq out 0)
    (setq fact '(1 1 2 6 24 120 720 5040))
    ; creazione dei 11440 numeri univoci
    (setq numeri (comb-rep 7 '(1 2 3 4 5 6 7 8 9 0)))
    ;(setq numeri (map lst-int (comb-rep 7 '(1 2 3 4 5 6 7 8 9 0))))
    (dolist (el numeri)
      ;(println $idx { } el)
      (setq num (lst-int el))
      ; se la catena del numero corrente finisce con 89
      (if (and (> num 0) (end89? num))
          ; allora aggiorniamo la somma totale
          ; sommando il coefficiente multinomiale
                 ; contiamo la molteplicità delle cifre del numero
          (letn ((conta (count '(1 2 3 4 5 6 7 8 9 0) el))
                 ; e poi calcoliamo il coefficiente multinomiale
                 (coeff (/ (fact 7) (apply * (map (fn(x) (fact x)) conta)))))
                 ; aggiorniamo il totale
                 (setq out (+ out coeff))
          )
      )
    )
    out))

(e092)
;-> 8581146

(time (e092))
;-> 116.715

La prima soluzione processa 9999999 di numeri, mentre la seconda soluzione processa 11440 numeri. Il rapporto vale: (/ 9999999 11440) = 874.
Per i tempi di esecuzione abbiamo il seguente rapporto: (/ 51582 116) = 444, cioè la seconda funzione è circa 450 volte più veloce.


===========
Problema 96
===========

Su Doku
>>>>>>> f2acca20c0b15972390864b1078897d6e663f0b3

La frazione continua di sqrt(23) vale [4, (1,3,1,8)]. 
La notazione indica che la frazione continua inizia con 4 e il blocco (1,3,1,8) si ripete indefinitamente.

Le prime dieci rappresentazioni di frazione continua di radici quadrate (irrazionali) sono:

sqrt( 2) = (1, (2)],         periodo = 1
sqrt( 3) = (1, (1,2)],       periodo = 2
sqrt( 4) = (2, (4)],         periodo = 1
sqrt( 6) = (2, (2,4)],       periodo = 2
sqrt( 7) = (2, (1,1,1,1)],   periodo = 4
sqrt( 8) = (2, (1,4)],       periodo = 2
sqrt(10) = (3, (6)],         periodo = 1
sqrt(11) = (3, (3,6)],       periodo = 2
sqrt(12) = (3, (2,6)],       periodo = 2
sqrt(13) = (3, (1,1,1,1,6)], periodo = 5

<<<<<<< HEAD
Esattamente quattro frazioni continue hanno un periodo dispari.
=======
Il file di testo 6K, sudoku.txt (e096.lsp), contiene cinquanta diversi puzzle di Su Doku che variano in difficoltà, ma tutti con soluzioni uniche (il primo puzzle nel file è l'esempio sopra).
>>>>>>> f2acca20c0b15972390864b1078897d6e663f0b3

Quante frazioni continue per N <= 10000 hanno un periodo dispari?
============================================================================

L'algoritmo presentato dall'articolo "Methods of computing square roots" di wikipedia è il seguente:

Start:
 m[0] = 0
 d[0] = 1
 a[0] = floor(sqrt(n))
 k = a[0]
Loop:
 m[i] = a[i-1]*d[i-1] - m[i-1]
 d[i] = (n-m[i]*m[i])/d[i-1]
 a[i] = floor((k + m[i])/d[i])
Stop: quando la i-esima tripla è stata generata precedentemente.

Note: m[i],d[i],a[i] sono sempre interi.

L'articolo di Alexandra Ioana Gliga "On continued fractions of the square root of prime numbers" dimostra che per ogni numero intero positivo che non è un quadrato perfetto risulta:

  sqrt(n) = [a1, (a2 a3 ... an 2*a1)]

Questo ci permette di fermare il ciclo quando l'i-esimo valore vale 2*a1.

Scriviamo la funzione:

(define (e064)
  (local (max-val out limite)
    (setq max-val 10000)
    (setq out 0)
    (for (n 2 max-val)
      (setq limite (int (sqrt n)))
      ; l'algortimo non funziona quando abbiamo un quadrato perfetto
      ; quindi saltiamo questi casi che non influenzano il risultato finale
      (if (!= (* limite limite ) n)
          (let ((periodo 0) (d 1) (m 0) (a limite))
            (do-while (!= a (* 2 limite))
              (setq m (- (* d a) m))
              (setq d (/ (- n (* m m)) d))
              (setq a (/ (+ limite m) d))
              (++ periodo)
            )
            (if (odd? periodo) (++ out))
          )
      )
    )
    out))

<<<<<<< HEAD
(e064)
;-> 1322

(time (e064))
;-> 81.294


===========
Problema 65
===========

Convergenti di e

La radice quadrata di 2 può essere scritta come una frazione continua infinita.
                       1
sqrt(2) = 1 + --------------------
                         1
              2 + ----------------
                           1
                  2 + ------------
                             1
                      2 + --------
                          2 + ...

La frazione continua infinita può essere scritta come sqrt(2) = [1, (2)] indica che 2 si ripete all'infinito. In un modo simile, sqrt(23) = [4, (1,3,1,8)].

Risulta che la sequenza dei valori parziali delle frazioni continue per le radici quadrate fornisce le migliori approssimazioni razionali. Consideriamo i convergenti per sqrt(2):

1 + 1/2 = 3/2
1 + 1/(2 + 1/2) = 7/5
1 + 1/(2 + 1/(2 + 1/2)) = 17/12
1 + 1/(2 + 1/(2 + 1/(2 + 1/2))) = 41/29

Quindi la sequenza dei primi dieci convergenti per sqrt(2) sono:

1, 3/2, 7/5, 17/12, 41/29, 99/70 239/169, 577/408, 1393/985, 3363/2378, ...

La cosa più sorprendente è che per l'importante costante matematica "e" risulta:

e = [2,1,2,1,1,4,1,1,6,1...1,2k,1...]

I primi dieci termini nella sequenza di convergenti per e sono:

2, 3, 8/3, 11/4, 19/7, 87/32, 106/39, 193/71, 1264/465, 1457/536, ...

La somma delle cifre al numeratore del decimo convergente è 1 + 4 + 5 + 7 = 17.

Trova la somma delle cifre del numeratore del centesimo convergente della frazione continua per "e".
============================================================================

Calcoliamo i primi n termini della frazione continua del numero tenendo conto che il pattern ...1,2n,1... si ripete all'infinito: cf(e) = [2, 1,2,1, 1,4,1, 1,6,1, 1,8,1, 1,10,1, ...]

(define (cf_e n)
  (let (cfe '(2))
    (for (i 1 (- n 1))
      (extend cfe (list 1 (* 2 i) 1)))
    (slice cfe 0 n)))

(cf_e 20)
;-> (2 1 2 1 1 4 1 1 6 1 1 8 1 1 10 1 1 12 1 1)

Poi scriviamo una funzione che calcola i convergenti partendo da una frazione continua e restituisce l'ultima delle frazioni convergenti Pn/Qn (dobbiamo usare i big-integer perchè il numeratore e il denominatore delle frazioni convergenti crescono velocemente):

(define (cf2conv cf)
  (local (p0 q0 p1 q1 p2 q2)
    (cond ((= (length cf) 1) (setq p2 (first cf) q2 1))
          (true
           (setq p0 1L q0 0L)
           (setq p1 (bigint (cf 0)) q1 1L)
           (for (k 1 (- (length cf) 1))
             (setq p2 (+ (* p1 (cf k)) p0))
             (setq q2 (+ (* q1 (cf k)) q0))
             ; k-esima frazione convergente
             ;(println (list p2 q2 (div p2 q2)))
             (setq p0 p1 q0 q1 p1 p2 q1 q2)
           ))
=======
(define (e096)
  (local (out)
    (setq out 0)
    (load "e096.lsp")
    (setq base "(solveSudoku gridX)")
    (for (i 1 50)
      (setq expr (replace "X" (copy base) (string i)))
      (setq out (+ out (* 100 (*sol* 0 0)) (* 10 (*sol* 0 1)) (*sol* 0 2)))
      ;(println expr)
      (eval-string expr)
      ;(println i { } out)
>>>>>>> f2acca20c0b15972390864b1078897d6e663f0b3
    )
    (list p2 q2)))

(cf2conv (cf_e 20))
;-> (28245729L 10391023L)

Poi ci serve una funzione che converte un numero in una lista:

(define (int2lst num)
  (let (out '())
    (while (!= num 0)
      (push (% num 10) out)
      (setq num (/ num 10))) out))

Adesso possiamo scrivere la funzione finale:

(define (e065)
  (local (numer)
    (setq numer (first (cf2conv (cf_e 100))))
    (apply + (int2lst numer))))

(e065)
;-> 272L

(time (e065))
;-> 0


===========
Problema 66
===========

# Equazione di Pell
# x^2 - D*y^2 = 1
#
# Espandere sqrt(D) in frazione continua
# sqrt(D) = [q0,q1,q2,...,qn,2*q0]
# Periodo della frazione continua = n
# Calcolare l'n-esimo convergente della frazione continua (Pn/Qn).
# Se n è dispari allora Pn e Qn sono la soluzione.
# Se n è pari occorre:
#    Espandere sqrt(D) in frazione continua fino al termine (2n+1)
#    Calcolare i convergenti fino al termine (2n+1).
#    P(2*n+1) e Q(2*n+1) sono le soluzioni. 
       	
(define (Pell n)
  (local (z r x y e1 e2 f1 f2 A B t1 t2)
    (setq x (bigint (int (sqrt n))))
    (setq y x)
    (setq z 1L)
    (setq r (* x 2))
    (setq e1 1L e2 0L)
    (setq f1 0L f2 1L)
    (catch
      (while true
        (setq y (bigint (- (* r z) y)))
        (setq z (bigint (/ (- n (* y y)) z)))
        (setq r (bigint (/ (+ x y) z)))
        (setq t1 e1) (setq t2 e2)
        (setq e1 t2)
        (setq e2 (bigint (+ (* t2 r) t1)))
        (setq t1 f1) (setq t2 f2)
        (setq f1 t2)
        (setq f2 (bigint (+ (* t2 r) t1)))
        (setq A f2)
        (setq B e2)
        (setq t1 A) (setq t2 B)
        (setq B t1)
        (setq A (bigint (+ (* t1 x) t2)))
        (if (= (- (* A A) (* B B n)) 1) (throw (list A B)))
        ;(println (format "z = %s\nr = %s\nx = %s\ny = %s" (string z) (string r) (string x) (string y)))
        ;(println (format "e1 = %s\ne2 = %s\nf1 = %s\nf2 = %s" (string e1) (string e2) (string f1) (string f2)))
        ;(println (format "A = %s\nB = %s" (string A) (string B)))
        ;(read-line)
      );while
    );catch
  );local
)

<<<<<<< HEAD
(Pell 61)
;-> (1766319049L 226153980L)

(Pell 109)
;-> (158070671986249L 15140424455100L)

(Pell 181)
;-> (2469645423824185801L 183567298683461940L)

(Pell 277)
;-> (159150073798980475849L 9562401173878027020L)

Se passiamo un numero quadrato, otteniamo un errore:

(Pell 4)
;-> ERR: division by zero
;-> called from user function (Pell 4)

Scriviamo la funzione finale per risolvere il problema:

(define (e066)
  (let ((maxval -1) (out 0))
    (for (i 1 1000)
      (if (!= (sqrt i) (int (sqrt i)))
          (if (> (first (Pell i)) maxval)
              (setq maxval (first (Pell i)) out i))))
    out))

(e066)
;-> 661

(time e066)
;-> 0


===========
Problema 67
===========

Percorso con somma massima II

Iniziando dalla parte superiore del triangolo in basso e passando ai numeri adiacenti sulla riga sottostante, il totale massimo dall'alto verso il basso è 23.

   3
  7 4
 2 4 6
8 5 9 3

Cioè, 3 + 7 + 4 + 9 = 23.

Trovare il totale massimo dall'alto verso il basso utilizzando "triangle.txt", un file di testo di 15K contenente un triangolo con cento righe.

NOTA: questa è una versione molto più difficile del problema 18. Non è possibile provare tutti i percorsi per risolvere questo problema, poiché ce ne sono 2^99 in tutto! Potendo controllare un trilione (10^12) di percorsi ogni secondo, ci vorrebbero oltre venti miliardi di anni per controllarli tutti. C'è un algoritmo efficiente per risolverlo.
============================================================================

Il file "triangle.txt" è stato trasformato in "e067.lsp" che ha il seguente formato:

(setq tri (dup 0 100))
(setf (tri 0) '(59)) 
(setf (tri 1) '(73 41)) 
(setf (tri 2) '(52 40 9)) 
(setf (tri 3) '(26 53 6 34)) 
...

Per caricare il file:

(load "e067.lsp")

Una soluzione generica può essere ottenuta con la programmazione dinamica. In pratica per trovare la soluzione, ogni riga deve essere aggiunta a qualsiasi riga successiva, dal basso verso l'alto. Poiché ogni cella ha due predecessori, prendiamo il valore massimo delle due. Con questo metodo, la soluzione si trova nella cella superiore del triangolo:

(load "e067.lsp")

(define (e067)
    (for (i (- (length tri) 2) 0 -1)
      (for (j 0 i)
        (setf (tri i j) (+ (tri i j) (max (tri (+ i 1) j) (tri (+ i 1) (+ j 1)))))
      )
    )
    (tri 0 0))

(e067)
;-> 7273

(time (e067))
;-> 1.995


===========
Problema 68
===========

Considera il seguente anello "magico" 3-gon, riempito con i numeri da 1 a 6 e ogni riga somma a nove.

       4  
        \
         3 
        / \    
       1---2---6
      /
     5
     
Lavorando in senso orario, e partendo dal gruppo di tre con il nodo esterno numericamente più basso (4,3,2 in questo esempio), ogni soluzione può essere descritta in modo univoco. Ad esempio, la soluzione di cui sopra può essere descritta dall'insieme: 4,3,2 - 6,2,1 - 5,1,3.

È possibile completare l'anello con quattro diversi totali: 9, 10, 11 e 12. Ci sono otto soluzioni in totale.

Totale   Soluzioni
   9     4,2,3 - 5,3,1 - 6,1,2
   9     4,3,2 - 6,2,1 - 5,1,3
  10     2,3,5 - 4,5,1 - 6,1,3
  10     2,5,3 - 6,3,1 - 4,1,5
  11     1,4,6 - 3,6,2 - 5,2,4
  11     1,6,4 - 5,4,2 - 3,2,6
  12     1,5,6 - 2,6,4 - 3,4,5
  12     1,6,5 - 3,5,4 - 2,4,6
  
Concatenando ogni gruppo è possibile formare stringhe di 9 cifre: la stringa massima per un anello 3-gon è 432621513.

Utilizzando i numeri da 1 a 10, a seconda degli arrangiamenti, è possibile formare stringhe di 16 e 17 cifre. Qual è il numero massimo di 16 cifre per un anello "magico" 5-gon?
============================================================================

Funzione che calcola le permutazioni:

(define (perm lst)
  (local (i indici out)
    (setq indici (dup 0 (length lst)))
    (setq i 0)
    ; aggiungiamo la lista iniziale alla soluzione
    (setq out (list lst))
    (while (< i (length lst))
      (if (< (indici i) i)
          (begin
            (if (zero? (% i 2))
              (swap (lst 0) (lst i))
              (swap (lst (indici i)) (lst i))
            )
            ;(println lst);
            (push lst out -1)
            (++ (indici i))
            (setq i 0)
          )
          (begin
            (setf (indici i) 0)
            (++ i)
          )
       )
    )
    out))

(define (gon lst)
  (local (is-gon gonL pL6 pL7 pL8 pL9 pL10 p6 p7 p8 p9 p10)
    (setq is-gon nil)
    (setq gonL '() pL6 '() pL7 '() pL8 '() pL9 '() pL10 '())
    (setq p6  (+ (lst 6)  (lst 1) (lst 2)))
    (setq p7  (+ (lst 7)  (lst 2) (lst 3)))
    (setq p8  (+ (lst 8)  (lst 3) (lst 4)))
    (setq p9  (+ (lst 9)  (lst 4) (lst 5)))
    (setq p10 (+ (lst 10) (lst 5) (lst 1)))
    ; Controllo se le somme sono uguali
    (cond ((and (= p6 p7) (= p7 p8) (= p8 p10) (= p9 p10))
           (setq is-gon true)
           ; Cerco l'indice del valore minimo esterno
           ; cioè cerco il numero 6, perchè all'esterno ci devono
           ; stare i numeri 6,7,8,9,10.
           (setq indice (find 6 lst))
           ; Costruisco la lista soluzione
           (setq pL6  (list (lst 6)  (lst 1) (lst 2)))
           (setq pL7  (list (lst 7)  (lst 2) (lst 3)))
           (setq pL8  (list (lst 8)  (lst 3) (lst 4)))
           (setq pL9  (list (lst 9)  (lst 4) (lst 5)))
           (setq pL10 (list (lst 10) (lst 5) (lst 1)))
           (cond ((= indice 6)  (setq gonL (apply extend (list pL6  pL7  pL8  pL9  pL10))))
                 ((= indice 7)  (setq gonL (apply extend (list pL7  pL8  pL9  pL10 pL6))))
                 ((= indice 8)  (setq gonL (apply extend (list pL8  pL9  pL10 pL6  pL7))))
                 ((= indice 9)  (setq gonL (apply extend (list pL9  pL10 pL6  pL7  pL8))))
                 ((= indice 10) (setq gonL (apply extend (list pL10 pL6  pL7  pL8  pL9))))
           ))
    )
    (if is-gon
        (list gonL p6)
        (list '() 0))))

(define (e068)
  (local (vmax pa pb val go x y)
    (setq vmax 0)
    (setq pa (perm '(1 2 3 4 5)))
    (setq pb (perm '(6 7 8 9 10)))
    (dolist (a pa)
      (setq val '())
      (dolist (b pb)
        (setq val (apply extend (list '(0) a b)))
        (setq go (gon val))
        (setq x (first go))
        (setq y (last go))
        (if (!= y 0)
          (begin
           ;(println x { } y)
           (if (> (int (join (map string x))) vmax)
               (setq vmax (int (join (map string x))))
           ))
        )
      )
    )
    vmax))

(e068)
;-> 6531031914842725

(time (e068))
;-> 21.97


===========
Problema 69
===========

La funzione toziente di Eulero, φ(n) (a volte chiamata funzione phi), è usata per determinare il numero di numeri positivi minori o uguali a n che sono primi relativamente a n. Ad esempio, poiché 1, 2, 4, 5, 7 e 8 sono tutti inferiori a nove e primi relativamente a nove, φ(9) = 6.
Il numero 1 è considerato relativamente primo rispetto a ogni numero positivo, quindi φ(1)= 1.

 n | Relatively Prime | φ(n) | n/φ(n)    |
 -----------------------------------------
 2 | 1                | 1    | 2         |
 3 | 1,2              | 2    | 1.5       |
 4 | 1,3              | 2    | 2         |
 5 | 1,2,3,4          | 4    | 1.25      |
 6 | 1,5              | 2    | 3         |
 7 | 1,2,3,4,5,6      | 6    | 1.1666... |
 8 | 1,3,5,7          | 4    | 2         |
 9 | 1,2,4,5,7,8      | 6    | 1.5       |
10 | 1,3,7,9          | 4    | 2.5       |

Si può vedere che n = 6 produce un massimo n/φ(n) per n ≤ 10.

Trova il valore di n ≤ 1000000 per cui il rapporto n/φ(n) è massimo.
============================================================================

Utilizziamo un approccio con la forza bruta.

Funzione che calcola il toziente da 0 fino a n numeri:

(define (totients-to num)
  (let (phi (array (+ num 1) '(0)))
    (setf (phi 0) 0)
    (setf (phi 1) 1)
    (for (i 2 num)
      (setf (phi i) i))
    (for (i 2 num)
      (if (= (phi i) i)
          (for (j i num i)
            (setf (phi j) (- (phi j) (/ (phi j) i))))))
     phi))

(totients-to 10)
;-> (0 1 1 2 2 4 2 6 4 6 4)

Scriviamo la funzione finale:

(define (e069)
  (local (t idx cur-val max-val)
    (setq t (totients-to 1000000))
    (setq max-val -1)
    (setq idx-val nil)
    ; cerca il valore massimo
    (for (i 0 1000000)
      (setq cur-val (t i))
      (if (> (div i cur-val) max-val)
          (setq idx-val i max-val (div i cur-val))
      )    
    )
    idx-val))

(e069)
;-> 510510

(time (e069))
;-> 642.279


===========
Problema 70
===========

Pemutazione toziente

La funzione toziente di Eulero, φ(n) (a volte chiamata funzione phi), è usata per determinare il numero di numeri positivi minori o uguali a n che sono primi relativamente a n. Ad esempio, poiché 1, 2, 4, 5, 7 e 8 sono tutti inferiori a nove e primi relativamente a nove, φ(9) = 6.
Il numero 1 è considerato relativamente primo rispetto a ogni numero positivo, quindi φ(1)= 1.

È interessante notare che φ(87109) = 79180, e si può vedere che 87109 è una permutazione di 79180.

Trova il valore di n, 1 < n < 10^7, per cui φ(n) è una permutazione di ne il rapporto n/φ(n) produce un minimo.
============================================================================

Utilizziamo un approccio con la forza bruta.

Funzione che verifica se due numeri hanno le stesse cifre:

(define (perm? n1 n2)
  (if (!= (length n1) (length n2))
      nil
      (let (ar (array 10 '(0)))
        (while (!= n1 0)
            (++ (ar (% n1 10)))
            (setq n1 (/ n1 10))
        )
        ;(println ar)
        (while (!= n2 0)
            (-- (ar (% n2 10)))
            (setq n2 (/ n2 10))
        )
        ;(println ar)
        (= (count '(0) (array-list ar)) '(10)))))

(perm? 123123 112233)
;-> true

Funzione che calcola il toziente da 0 fino a n numeri:

(define (totients-to num)
  (let (phi (array (+ num 1) '(0)))
    (setf (phi 0) 0)
    (setf (phi 1) 1)
    (for (i 2 num)
      (setf (phi i) i))
    (for (i 2 num)
      (if (= (phi i) i)
          (for (j i num i)
            (setf (phi j) (- (phi j) (/ (phi j) i))))))
     phi))

(totients-to 10)
;-> (0 1 1 2 2 4 2 6 4 6 4)

Scriviamo la funzione finale:

(define (e070)
  (local (t idx cur-val min-val)
    (setq t (totients-to 9999999))
    (setq min-val 999999)
    (setq idx-val nil)
    ; cerca il valore minimo
    (for (i 2 9999999)
      (setq cur-val (t i))
      (if (< (div i cur-val) min-val)
          (if (perm? cur-val i)
                  (setq idx-val i min-val (div i cur-val))
              )
          )
    )
    idx-val))

(e070)
;-> 8319823

(time (e070))
;-> 9621.575

Dal punto di vistta matematico possimo notare che:

1) Rendere minimo n/φ(n) equivale a massimizzare φ(n)/n, che si verifica quando n ha il minor numero di fattori primi possibile.
2) φ(n) = n - 1 dove n è primo, poiché tutti i numeri sotto sono coprimi per definizione
3) φ(n) = φ(pq) = (p - 1) (q - 1) dove n è semiprimo e p e q sono i suoi fattori e p <> q.
4) φ(n) = φ(p2) = (p - 1) p dove n è semiprime ep è il suo unico fattore distinto.
5) n - 1 non può essere una permutazione di n, quindi il nostro n non può essere un primo, ma è probabilmente il prodotto di due numeri primi (semiprimi).

Funzone che calcola tutti i numeri primi da 1 fino a un dato numero:

(define (primes-to num)
  (cond ((= num 1) '())
        ((= num 2) '(2))
        (true
         (let (lst '(2))
          (setq arr (array (+ num 1)))
          (for (x 3 num 2)
                (when (not (arr x))
                  (push x lst -1)
                  (for (y (* x x) num (* 2 x) (> y num))
                      (setf (arr y) true)))) lst))))

Le considerazioni precedenti portano (dopo molti tentativi) alla seguente funzione:

(define (e070)
(catch
  (local (num primi min-q min-n q n totient)
  (setq num 10000000)
  (setq primi (primes-to (int (mul 1.25 (sqrt num)))))
  (setq primi (slice primi (int (mul 0.5 (length primi)))))
  (setq min-q 2 min-n 0 i 0)
  (dolist (p1 primi)
    (dolist (p2 (slice primi i))
      (cond ((!= (% (+ p1 p2) 9) 1) nil)
            (true
             (setq n (* p1 p2))
             (if (> n num) (throw min-n)) ; soluzione trovata
             (setq totient (* (- p1 1) (- p2 1)))
             (setq q (div n totient))
             (if (and (> min-q q) (perm? totient n))
                 (setq min-q q min-n n))))))
  'not-found)))

(e070)
;-> 8319823

(time (e070))
;-> 7.012


===========
Problema 71
===========

Frazioni ordinate

Considera la frazione, n/d, dove n e d sono numeri interi positivi. Se n < d e HCF(n,d) = 1, si parla di frazione propria ridotta.

Se elenchiamo l'insieme delle frazioni proprie ridotte per d ≤ 8 in ordine crescente di dimensione, otteniamo:

1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8

Si può vedere che 2/5 è la frazione immediatamente a sinistra di 3/7.

Elencando l'insieme delle frazioni proprie ridotte per d ≤ 1.000.000 in ordine crescente di dimensione, trova il numeratore della frazione immediatamente a sinistra di 3/7.
============================================================================

Nota: HCF = High Common Factor (fattore comune maggiore)

(define (find-upper n base)
  (let ((a 1) (cont true))
    (while (and (< a n) cont)
      (if (> (div a n) base)
          (setq cont nil)
          (++ a)))
    a))

(find-upper 8 (div 3 7))
;-> 4
(find-upper 1000000 (div 3 7))
;-> 428572

(define (e071)
  (local (n num den minimo base limite a b)
    (setq n 1000000)
    (++ n)
    (setq num 1 den 1)
    (setq minimo 0)
    (setq base (div 3 7))
    (setq limite (find-upper n base))
    (setq a (- limite 2))
    (while (< a limite)
      (setq b (+ a 1))
      (while (< b n)
        (setq v (div a b))
        (if (and (< v base) ( > v minimo))
            (setq num a den b minimo (div num den))
        )
        (++ b)
      )
      (++ a)
    )
    ;(list num den (div num den))
    num))

(e071 1000000)
;-> 428570

(time (e071))
;-> 191.169


===========
Problema 72
===========

Conteggio delle frazioni

Considera la frazione, n/d, dove n e d sono numeri interi positivi. Se n <de HCF (n, d) = 1, si parla di frazione propria ridotta.

Se elenchiamo l'insieme delle frazioni proprie ridotte per d ≤ 8 in ordine crescente di dimensione, otteniamo:

1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8

Si può vedere che ci sono 21 elementi in questo set.

Quanti elementi sarebbero contenuti nell'insieme delle frazioni proprie ridotte per d ≤ 1.000.000?
============================================================================

Ordinando le frazioni in una matrice si ottiene il seguente risultato (n=10):

  1/2   1/3   1/4   1/5   1/6   1/7   1/8   1/9  1/10
    0   2/3   1/2   2/5   1/3   2/7   1/4   2/9   1/5
    0     0   3/4   3/5   1/2   3/7   3/8   1/3  3/10
    0     0     0   4/5   2/3   4/7   1/2   4/9   2/5
    0     0     0     0   5/6   5/7   5/8   5/9   1/2
    0     0     0     0     0   6/7   3/4   2/3   3/5
    0     0     0     0     0     0   7/8   7/9  7/10
    0     0     0     0     0     0     0   8/9   4/5
    0     0     0     0     0     0     0     0  9/10
    0     0     0     0     0     0     0     0     0

(1/2, 1/3, 1/4, 1/5, 1/6, 1/7, 1/8, 1/9, 1/10, 2/3, 2/5, 2/7, 2/9,
3/4, 3/5, 3/7, 3/8, 3/10, 4/5, 4/7, 4/9, 5/6, 5/7, 5/8, 5/9, 6/7,
7/8, 7/9, 7/10, 8/9, 9/10)

Notiamo che:
a) le colonne con denominatore numero primo hanno (denominatore - 1) termini.
b) le colonne con denominatore non primo hanno toziente(denominatore) termini.
(dove toziente(n) è il numero di interi minori di n che sono primi rispetto a n)

Funzione che verifica se un numero è primo:

(define (prime? num)
   (if (< num 2) nil
       (= 1 (length (factor num)))))

Funzione che calcola il toziente di un numero:

(define (toziente num)
  (if (= num 1) 1
    (let (res num)
      (dolist (f (unique (factor num)))
        (setq res (- res (/ res f))))
      res)))

Scriviamo la funzione finale:

(define (e072)
  (let ((num 1000000) (somma 0))
    (for (i 2 num)
      (if (prime? i)
          (setq somma (+ somma (- i 1)))
          (setq somma (+ somma (toziente i)))
      )
    )
    somma))

(e072)
;-> 303963552391

(time (e072))
;-> 2060.973


===========
Problema 76
===========

Conteggio delle somme

È possibile scrivere cinque come somma in esattamente sei modi diversi:

4 + 1
3 + 2
3 + 1 + 1
2 + 2 + 1
2 + 1 + 1 + 1
1 + 1 + 1 + 1 + 1

In quanti modi diversi si può scrivere cento come somma di almeno due numeri interi positivi?
============================================================================

La soluzione è simile a quella del problema 31. Le uniche differenze sono:
1) il totale vale 100 (invece di 200)
2) le monete (gli interi in questo caso) vanno da 1 a 99 (invece che (1 2 5 10 20 50 100 200))

(define (e076)
  (local (totale monete modi)
    ; valore obiettivo
    (setq totale 100)
    ; lista dei tagli di monete disponibili
    (setq monete (sequence 1 99))
    ; crea un vettore di totale elementi con tutti valori 0 tranne il primo (modi[0]) che vale 1
    (setq modi (array (+ totale 1) (extend '(1) (dup 0 totale))))
    (dolist (el monete)
      (for (i el totale)
        (setq (modi i) (+ (modi i) (modi (- i el))))
      )
    )
    (modi totale)))

(e076)
;-> 190569291

(time (e076))
;-> 0


===========
Problema 78
===========

Partizioni di monete

Sia p(n) il numero dei diversi modi in cui n monete possono essere separate in pile. Ad esempio, cinque monete possono essere separate in pile in esattamente sette modi diversi, quindi p(5) = 7.

OOOOO
OOOO   O
OOO   OO
OOO   O   O
OO   OO   O
OO   O   O   O
O   O   O   O   O

Trova il valore minimo di n per cui p(n) è divisibile per un milione.
============================================================================

Su wikipedia si trova che la funzione generatrice per p(n) vale:

p(n) = p(n - 1) + p(k - 2) - p(k - 5) - p(k - 7) + p(k - 12) + p(k - 15) - p(k - 22) ...

dove p(0) = 1 e p(n) = 0 per n < 0.

La sequenza dei numeri k da utilizzare è data dalla formula dei numeri pentagonali generalizzati:

f(k) = k*(3k-1)/2 che vale sia per k negativo che per k positivo. 

Questa formula può essere generata nel modo seguente:

    | (m/2 + 1)    se (k mod 2) = 0,
k = |
    | (-m/2 - 1)   altrimenti

I segni della funzione seguono lo schema +, +, -, -, +, +, -, -,...

Quindi partendo dal primo valore della sequenza possiamo calcolare quella successiva e cosi via.

(define (penta k) (/ (* k (- (* 3 k) 1)) 2))

(define (e078)
  (local (n p-vec segno penta continua i j val)
    (setq p-vec (array 100000 '(0)))
    (setq n 1)
    (setf (p-vec 0) 1)
    (setq continua true)
    (while continua
      (setq i 0)
      (setq penta 1)
      (while (<= penta n)
        (if (> (% i 4) 1)
            (setq segno -1)
            (setq segno 1))
        (setf (p-vec n) (+ (p-vec n) (* segno (p-vec (- n penta)))))
        (setf (p-vec n) (% (p-vec n) 1000000))
        (++ i)
        (if (zero? (% i 2))
            (setq j (+ (/ i 2) 1))
            (setq j (- (+ (/ i 2) 1))))
        (setq penta (/ (* j (- (* 3 j) 1)) 2))
      )
      (if (zero? (p-vec n)) 
          (setq continua nil)
          (++ n))
      ;(if (zero? (% n 10000)) (println n))
    )
    n))

(e078)
;-> 55374

(time (e078))
;-> 7918.736

Il tempo di esecuzione non è entusiasmante, ma non è che abbia capito molto bene come funziona tutta la matematica dietro il partizionamento degli interi. Mi accontento che il risultato sia corretto.


===========
Problema 87
===========

Triple potenze di primi

Il numero più piccolo esprimibile come la somma di un quadrato primo, un cubo primo e una quarta potenza primo è 28. In effetti, ci sono esattamente quattro numeri inferiori a cinquanta che possono essere espressi in questo modo:

28 = 2^2 + 2^3 + 2^4
33 = 3^2 + 2^3 + 2^4
49 = 5^2 + 2^3 + 2^4
47 = 2^2 + 3^3 + 2^4

Quanti numeri inferiori a cinquanta milioni possono essere espressi come la somma di un quadrato primo, un cubo primo e una quarta potenza primo?
============================================================================

Funzione per calcolare i numeri primi fino a n:

(define (primes-to num)
  (cond ((= num 1) '())
        ((= num 2) '(2))
        (true
         (let (lst '(2))
          (setq arr (array (+ num 1)))
          (for (x 3 num 2)
                (when (not (arr x))
                  (push x lst -1)
                  (for (y (* x x) num (* 2 x) (> y num))
                      (setf (arr y) true)))) lst))))

L'algoritmo è abbastanza semplice e può essere estrapolato dai commenti della funzione:

(define (e087)
  (local (val primi primi2 primi3 primi4 limite out)
    (setq out '())
    (setq limite 50000000)
    # calcola i primi fino a sqrt(limite)
    (setq primi (primes-to (int (sqrt limite))))
    ; calcola i quadrati di questi primi (< limite)
    (setq primi2 (filter (fn(x) (< x limite)) (map (fn(x) (* x x)) primi)))
    ; calcola i cubi di questi primi (< limite)
    (setq primi3 (filter (fn(x) (< x limite)) (map (fn(x) (* x x x)) primi)))
    ; calcola le quarte potenze di questi primi (< limite)
    (setq primi4 (filter (fn(x) (< x limite)) (map (fn(x) (* x x x x)) primi)))
    ;(println "p= " primi {-} "p2= " primi2 {-} "p3= " primi3 {-} "p4= " primi4)
    ; crea una lista con le somme di tutti i numeri delle tre liste
    (dolist (a primi2)
      (dolist (b primi3)
        (dolist (c primi4)
          (setq val (+ a b c))
          (if (< val limite) 
              (push val out -1)
          ))))
    ; elimina i numeri multipli dalla lista
    (length (unique out))))

(e087)
;-> 1097343

(time (e087))
;-> 1153.946

Per ottimizzare la funzione potremmo:
1) Generare primi2, primi3 e primi4 fino ai numeri i cui quadrati, cubi e quarte potenze sono inferiori al limite
2) fermare il ciclo b quando (a + b) > limite
3) fermare il ciclo c quando (a + b + c) > limite
4) inserire i valori in una hash-map

Comunque il tempo di esecuzione è soddisfacente.


===========
Problema 89
===========

Numeri romani

Affinché un numero scritto in numeri romani sia considerato valido, ci sono regole di base che devono essere seguite. Anche se le regole consentono di esprimere alcuni numeri in più di un modo, esiste sempre un modo "migliore" per scrivere un numero particolare.

Ad esempio, sembrerebbe che ci siano almeno sei modi per scrivere il numero sedici:

IIIIIIIIIIIIIIII
VIIIIIIIIIII
VVIIIIII
XIIIIII
VVVI
XVI

Tuttavia, secondo le regole sono validi solo XIIIIII e XVI, e l'ultimo esempio è considerato il più efficiente, poiché utilizza il minor numero di numeri.

Il file di testo 11K, roman.txt, contiene mille numeri scritti in numeri romani validi, ma non necessariamente minimi. V`edi Informazioni sui Numeri romani per le regole definitive di questo problema (.

Trova il numero di caratteri salvati scrivendo ciascuno di questi nella loro forma minima.

Nota: si può presumere che tutti i numeri romani nel file non contengano più di quattro unità identiche consecutive.
============================================================================

Funzione di conversione da numero intero a numero romano:

(define (integer2roman num)
  (local (table roman k)
    (setq table '(("M" 1000) ("CM" 900) ("D" 500) ("CD" 400)
          ("C" 100)("XC" 90)("L" 50)("XL" 40) ("X" 10) ("IX" 9) ("V" 5)
          ("IV" 4) ("I" 1)))
    (setq roman "")
    (dolist (el table)
      (setq k (/ num (last el)))
      (setq num (% num (last el)))
      (extend roman (dup (first el) k))
    )
    roman))

(integer2roman 4444)
;-> "MMMMCDXLIV"

(integer2roman 16)
;-> "XVI"

Funzione di conversione da numero romano a numero intero:

(define (roman2integer roman)
  (local (table curr prev num)
    (setq table '(("I" 1) ("V" 5) ("X" 10) ("L" 50) ("C" 100) ("D" 500) ("M" 1000)))
    (setq prev 0 num 0)
    ; iterate through all characters
    (dostring (ch roman)
      ; converts the current character into an integer
      (setq curr (lookup (char ch) table))
      ; pick the right case to add or substract
      (if (>= prev curr) 
          (setq num (+ num prev))
          (setq num (- num prev))
      )
      (setq prev curr)
    )
    ; add the last value
    (setq num (+ num curr))))

(roman2integer "MMMMCDXLIV")
;-> 4444

(roman2integer "XIIIIII")
;-> 16

Il file "roman.txt" è stato trasformato nel file "e089.lsp" che ha la seguente struttura:

(setq roma '("MMMMDCLXXII" "MMDCCCLXXXIII" "MMMDLXVIIII" ...)

Scriviamo la funzione finale:

(define (e089)
  (local (somma len1 len2)
    (setq somma 0)
    (dolist (el roma)
      (setq len1 (length el))
      (setq len2 (length (integer2roman (roman2integer el))))
      (setq somma (+ somma (- len1 len2)))
      ;(println (list el (length el)) { }
      ;         (list (integer2roman (roman2integer el)) (length (integer2roman (roman2integer el)))))
      ;(read-line)
    )
    somma))

Carichiamo il file ed eseguiamo la funzione:

(load "roma.lsp")
(length roma)
;-> 1000

(e089)
;-> 743

(time e089)
;-> 0


===========
Problema 92
===========

Catena del quadrato delle cifre

Una catena di numeri viene creata aggiungendo continuamente il quadrato delle cifre in un numero per formare un nuovo numero fino a quando non è stato visto prima.

Per esempio,

44 → 32 → 13 → 10 → 1 → 1
85 → 89 → 145 → 42 → 20 → 4 → 16 → 37 → 58 → 89

Pertanto qualsiasi catena che arriva a 1 o 89 rimarrà bloccata in un ciclo infinito. La cosa più sorprendente è che OGNI numero di partenza alla fine arriverà a 1 o 89.

Quanti numeri di partenza sotto i dieci milioni arriveranno a 89?
============================================================================

Prima di definire la funzione cha calcola la catena, dobbiamo scrivere la funzione cha calcola la somma dei quadrati delle cifre di un numero:

Prima versione "sum-sq-digit":

(define (int-lst num)
  (let (out '())
    (while (!= num 0)
      (push (% num 10) out)
      (setq num (/ num 10))) out))

(define (sum-sq-digit num)
  (apply + (map (fn(x) (* x x)) (int-lst num))))

(sum-sq-digit 32)
;-> 13
(sum-sq-digit 456)
;-> 77
(time (sum-sq-digit 12345678901234567890) 100000)
;-> 1554.87

Seconda versione "sum-sq-digit":

(define (sum-sq-digit num)
  (let ((cifra 0) (tot 0))
  (while (> num 0)
    (setq cifra (% num 10))
    (setq num (/ (- num cifra) 10))
    (setq tot (+ tot (* cifra cifra)))
  )
  tot))

(sum-sq-digit 32)
;-> 13
(sum-sq-digit 456)
;-> 77
(time (sum-sq-digit 12345678901234567890) 100000)
;-> 1263.057
;-> 140.624

Terza versione "sum-sq-digit":

(define (sum-sq-digit num)
  (let ((cifra 0) (tot 0))
  (while (> num 0)
    (setq cifra (% num 10))
    (setq tot (+ tot (* cifra cifra)))
    (setq num (/ num 10))
  )
  tot))

(sum-sq-digit 32)
;-> 13
(sum-sq-digit 456)
;-> 77
(time (sum-sq-digit 12345678901234567890) 100000)
;-> 1112.057

Quarta versione "sum-sq-digit":

(define (sum-sq-digit num)
  (let ((cifra 0) (tot 0))
  (while (> num 0)
    (setq cifra (% num 10))
    (if cifra
      (setq tot (+ tot (* cifra cifra))))
    (setq num (/ num 10))
  )
  tot))

(sum-sq-digit 32)
;-> 13
(sum-sq-digit 456)
;-> 77
(time (sum-sq-digit 12345678901234567890) 100000)
;-> 1106.45

Adesso scriviamo la funzione che calcola la catena di un numero:

(define (chain num)
  (local (chain-lst num-lst val found out)
    (setq val num found nil)
    (until found
      (setq num (sum-sq-digit num))
      (push num chain-lst -1)
      (if (or (= num 1) (= num 89))
          (setq out (list val num (length chain-lst) chain-lst) found true)
      )
    )
    out))

Vediamo alcuni esempi di catene:

(chain 100)
;-> (100 1 1 (1))
(chain 1)
;-> (1 1 1 (1))
(chain 89)
;-> (89 89 8 (145 42 20 4 16 37 58 89))
(chain 44)
;-> (44 1 4 (32 13 10 1))
(chain 85)
;-> (85 89 1 (89))

(for (i 1 20) (println (chain i)))
;-> (1 1 1 (1))
;-> (2 89 5 (4 16 37 58 89))
;-> (3 89 7 (9 81 65 61 37 58 89))
;-> (4 89 4 (16 37 58 89))
;-> (5 89 4 (25 29 85 89))
;-> (6 89 9 (36 45 41 17 50 25 29 85 89))
;-> (7 1 5 (49 97 130 10 1))
;-> (8 89 5 (64 52 29 85 89))
;-> (9 89 6 (81 65 61 37 58 89))
;-> (10 1 1 (1))
;-> (11 89 6 (2 4 16 37 58 89))
;-> (12 89 5 (5 25 29 85 89))
;-> (13 1 2 (10 1))
;-> (14 89 6 (17 50 25 29 85 89))
;-> (15 89 6 (26 40 16 37 58 89))
;-> (16 89 3 (37 58 89))
;-> (17 89 5 (50 25 29 85 89))
;-> (18 89 5 (65 61 37 58 89))
;-> (19 1 4 (82 68 100 1))
;-> (20 89 5 (4 16 37 58 89))

Scriviamo la funzione che calcola la soluzione con la forza bruta:

(define (e092)
  (local (num n89 found)
    (setq num 9999999 n89 0)
    (for (i 1 num)
      (setq found nil)
      (setq k i)
      (until found
        ;(setq k (apply + (map (fn(x) (* x x)) (int-lst k))))
        (setq k (sum-sq-digit k))
        (if (= k 89) (setq n89 (+ n89 1) found true))
        (if (= k 1)  (setq found true))
      )
    )
    n89))

(e092)
;-> 8581146

(time (e092))
;-> 51582.689

Il tempo di esecuzione non è molto soddisfacente.

Per trovare un algoritmo migliore dobbiamo fare alcune considerazioni.

Notiamo che due numeri che hanno le stesse cifre hanno la stessa catena perchè calcoliamo la somma dei quadrati delle cifre. Per esempio i numeri 4666777 e 6767674 hanno la stessa catena:

(chain 4666777)
;-> (4666777 89 9 (271 54 41 17 50 25 29 85 89))

(chain 6767674)
;-> (6767674 89 9 (271 54 41 17 50 25 29 85 89))

Quindi tutti i numeri che hanno le stesse cifre (non considerando lo 0 perchè facciamo il quadrato di ogni cifra) hanno la stessa catena.

Inoltre, la più grande somma possibile di quadrati è creata dal numero 9999999, che vale 7^9 = 567.
Possiamo usare questo numero come dimensione di una lista che contiene tutti i valori generati dal calcolo della somma dei quadrati delle cifre per i numeri inferiori 10 milioni (questo perchè tutti gli altri numeri inferiori a 10 milioni sono solo permutazioni con una somma minore).

Prima scriviamo una funzione che restituisce true se la catena di un dato numero termina con 89, altrimenti restituisce nil:

(define (end89? n)
  (local (sum x)
    (while (and (!= n 1) (!= n 89))
      (setq sum 0)
      (while (> n 0)
        (setq x (% n 10))
        (setq sum (+ sum (* x x)))
        (setq n (/ n 10))
      )
      (setq n sum)
    )
    (= n 89)))

(end89? 1)
;-> nil
(end89? 89)
;-> true
(end89? 4666777)
;-> true
(end89? 6767674)
;-> true

Poi possiamo creare la lista che contiene le somme:

(setq lst-sum '(0))
(for (i 1 567) (push (end89? i) lst-sum -1))

I valori delle somme non coprono tutti i numeri da 1 a 567:

(count '(true) lst-sum)
;-> 486

Adesso dobbiamo sapere quante volte un dato insieme di cifre può verificarsi sotto i 10 milioni. Questo è semplicemente il fattoriale del numero totale di elementi (cioè quante cifre, 7) diviso per il prodotto dei fattoriali dei conteggi degli elementi unici (quante volte compare ogni cifra):

(numero-elementi-gruppo = 7! / (c1! * c2! * ... * c9!))

Per esempio, per il numero 4666777 otteniamo che il numero di elementi vale (coefficiente multinomiale):

numero-elementi-gruppo(4666777) = 7! / (1! * 3! * 3!) = 140

Vediamo quante combinazioni di cifre univoche ci sono da 1 a 9999999 (combinazioni con ripetizione):

(define (comb-rep k lst)
  (cond ((zero? k 0) '(()))
        ((null? lst) '())
        (true
         (append (map (lambda (x) (cons (first lst) x))
                      (comb-rep (- k 1) lst))
                 (comb-rep k (rest lst))))))

(setq numeri (comb-rep 7 '(1 2 3 4 5 6 7 8 9 0)))
(length numeri)
;-> 11440

Esistono solo 11.440 combinazioni di cifre univoche comprese tra 1 e 9999999.

Quindi dobbiamo trovare un modo per calcolare la catena solo di questi numeri.
Potremmo utilizzare 9 cicli "for" per generare numeri del tipo "abcdefg" e quando le cifre soddisfano a≤b≤c≤d≤e≤f≤g, allora controllare la somma nella lista delle somme (lst-sum). Se la catena termina con 89, dobbiamo aggiungere tutte le possibili combinazioni (calcolate con il coefficiente multinomiale) al risultato.

Per velocizzare i calcoli utilizziamo una lista precalcolata per i fattoriali da 0 a 7:

fact = (1 1 2 6 24 120 720 5040)

Oppure possiamo utilizzare direttamente i numeri della lista "numeri", verificare se la sua catena di ogni termina con 89 ed eventualmente aggiungere al totale il numero degli elementi del suo gruppo (cioè tutti i numeri che conducono a 89) calcolando il relativo coefficiente multinomiale.

Proviamo a scrivere una funzione con quest'ultimo algoritmo.

Funzione che converte una lista in un intero:

(define (lst-int lst)
  (let (num 0)
    (dolist (el lst) (setq num (+ el (* num 10))))))

Funzione finale:

(define (e092)
  (local (fact numeri num out)
    (setq out 0)
    (setq fact '(1 1 2 6 24 120 720 5040))
    ; creazione dei 11440 numeri univoci
    (setq numeri (comb-rep 7 '(1 2 3 4 5 6 7 8 9 0)))
    ;(setq numeri (map lst-int (comb-rep 7 '(1 2 3 4 5 6 7 8 9 0))))
    (dolist (el numeri)
      ;(println $idx { } el)
      (setq num (lst-int el))
      ; se la catena del numero corrente finisce con 89
      (if (and (> num 0) (end89? num))
          ; allora aggiorniamo la somma totale
          ; sommando il coefficiente multinomiale
                 ; contiamo la molteplicità delle cifre del numero
          (letn ((conta (count '(1 2 3 4 5 6 7 8 9 0) el))
                 ; e poi calcoliamo il coefficiente multinomiale
                 (coeff (/ (fact 7) (apply * (map (fn(x) (fact x)) conta)))))
                 ; aggiorniamo il totale
                 (setq out (+ out coeff))
          )
      )
    )
    out))

(e092)
;-> 8581146

(time (e092))
;-> 116.715

La prima soluzione processa 9999999 di numeri, mentre la seconda soluzione processa 11440 numeri. Il rapporto vale: (/ 9999999 11440) = 874.
Per i tempi di esecuzione abbiamo il seguente rapporto: (/ 51582 116) = 444, cioè la seconda funzione è circa 450 volte più veloce.


===========
Problema 96
===========

Su Doku

Su Doku (giapponese che significa luogo del numero) è il nome di un concetto di puzzle popolare. La sua origine non è chiara, ma il merito viene attribuito a Leonhard Euler che ha inventato un puzzle simile e molto più difficile, chiamato Quadrati Latini. L'obiettivo dei puzzle di Su Doku è quello di sostituire gli spazi vuoti (o zeri) in una griglia 9 per 9 in modo tale che ogni riga, colonna e regione 3x3 contenga ciascuna delle cifre da 1 a 9. Di seguito è riportato un esempio di una tipica griglia di puzzle iniziale e della sua griglia di soluzione.

  0 0 3 | 0 2 0 | 6 0 0          4 8 3 | 9 2 1 | 6 5 7
  9 0 0 | 3 0 5 | 0 0 1          9 0 0 | 3 4 5 | 8 2 1
  0 0 1 | 8 0 6 | 4 0 0          2 5 1 | 8 7 6 | 4 9 3
  ------+-------+------          ------+-------+------
  0 0 8 | 1 0 2 | 9 0 0          5 4 8 | 1 3 2 | 9 7 6
  7 0 0 | 0 0 0 | 0 0 8          7 2 9 | 5 6 4 | 1 3 8
  0 0 6 | 7 0 8 | 2 0 0          1 3 6 | 7 9 8 | 2 4 5
  ------+-------+------          ------+-------+------
  0 0 2 | 6 0 9 | 5 0 0          3 7 2 | 6 8 9 | 5 1 4
  8 0 0 | 2 0 3 | 0 0 9          8 1 4 | 2 5 3 | 7 6 9
  0 0 5 | 0 1 0 | 3 0 0          6 9 5 | 4 1 7 | 3 8 2

Un puzzle di Su Doku ben costruito ha una soluzione unica e può essere risolto dalla logica, anche se potrebbe essere necessario impiegare metodi di "indovinare e testare" per eliminare le opzioni (questo è un'opinione molto contestata). La complessità della ricerca determina la difficoltà del puzzle. L'esempio sopra è considerato facile perché può essere risolto con una semplice deduzione diretta.

Il file di testo 6K, sudoku.txt (e096.lsp), contiene cinquanta diversi puzzle di Su Doku che variano in difficoltà, ma tutti con soluzioni uniche (il primo puzzle nel file è l'esempio sopra).

Risolvendo tutti e cinquanta i puzzle, trova la somma di tutti i numeri a 3 cifre che si trovano nell'angolo in alto a sinistra di ogni griglia della soluzione. Ad esempio, 483 è il numero di 3 cifre che si trova nell'angolo in alto a sinistra della griglia della soluzione sopra.
============================================================================

(define (isSafe board row col num)
  (local (safe regionRowStart regionColStart)
    (setq safe true)
    ; numero unico sulla riga (row-clash)
    (for (d 0 (- (length board) 1))
      ; Se il numero che stiamo provando
      ; è presente in quella riga
      ; restituire falso (nil)
      (if (= (board row d) num)
          (setq safe nil)
      )
    )
    (if safe (begin
    ; numero unico sulla colonna (column-clash)
    (for (r 0 (- (length board) 1))
      ; Se il numero che stiamo provando
      ; è presente in quella colonna
      ; restituire falso (nil)
      (if (= (board r col) num)
          (setq safe nil)
      )
    )))
    (if safe (begin
    ; numero unico in ogni regione 3x3 (region-clash)
    (setq regionRowStart (- row (% row 3)))
    (setq regionColStart (- col (% col 3)))
    (for (r regionRowStart (+ regionRowStart 2))
          (for (d regionColStart (+ regionColStart 2))
        (if (= (board r d) num)
            (setq safe nil)
        )
      )
    )))
    ; se non c'è conflitto, allora è sicuro
    safe
  )
)

(define (solveSudoku board)
(catch
  (local (i j row col isEmpty solved)
    (setq row -1 col -1)
    (setq isEmpty true)
    (setq i 0 j 0)
    (while (and isEmpty (< i (length board)))
      (while (and isEmpty (< j (length board)))
        (if (= (board i j) 0)
            ; Esistono ancora dei valori nulli nel puzzle
            (setq row i col j isEmpty nil)
        )
        (++ j)
      )
      (setq j 0)
      (++ i)
    )
    ; stampa la soluzione
    ;(if isEmpty (begin (println board) (throw true)))
    ; salva la soluzione su una variabile globale
    (if isEmpty (begin (setq *sol* board) (throw true)))
    ;else
    (for (num 1 (length board))
        (cond ((isSafe board row col num)
                 (setf (board row col) num)
                 (if (solveSudoku board) (throw true))
                 (setf (board row col) 0)
              )
        )
    )
    nil
  )
))

(define (e096)
  (local (out)
    (setq out 0)
    (load "e096.lsp")
    (setq base "(solveSudoku gridX)")
    (for (i 1 50)
      (setq expr (replace "X" (copy base) (string i)))
      (setq out (+ out (* 100 (*sol* 0 0)) (* 10 (*sol* 0 1)) (*sol* 0 2)))
      ;(println expr)
      (eval-string expr)
      ;(println i { } out)
    )
    out
  )
)

(e096)
;-> 24702

(time (e096))
;-> 27084.701


===========
Problema 97
===========

Il più grande primo non-Mersenne

Il primo numero primo noto che supera il milione di cifre è stato scoperto nel 1999 ed è un numero primo di Mersenne della forma 2 ^ 6972593-1. Contiene esattamente 2.098.960 cifre. Successivamente sono stati trovati altri numeri primi di Mersenne, della forma (2^p − 1), che contengono più cifre.

Tuttavia, nel 2004 è stato trovato un enorme numero primo non Mersenne che contiene 2.357.207 cifre: 28433 × 2^7830457 + 1.

Trova le ultime dieci cifre di questo numero primo.
============================================================================

Le ultime 10 cifre di un numero n si ottengono applicando l'operatore modulo: (n % 10000000000).
Il problema è come calcolare velocemente 2^7830457. Cercando di risolvere direttamente l'espressione,  newLISP impiega un tempo lunghissimo. Infatti:

Funzione per calcolare la potenza (intera) di un numero intero:

(define (** num power)
    (let (out 1L)
        (dotimes (i power)
            (setq out (* out num)))))

Scriviamo la funzione:

(define (e097) (% (+ (* (** 2L 7830456L) 28433) 1) 10000000000L))

Attenzione, la seguente funzione impiega moltissimo tempo:

(e097)

Abbiamo visto che per estrapolare le ultime 10 cifre occorre calcolare (n mod 10000000000). Poichè per  l'operazione modulo (mod) vale la proprietà distributiva:

a*b mod n = ((a mod n)*(b mod n)) mod n

possiamo calcolare 2^7830457 utilizzando la moltiplicazione in un ciclo e utilizzando il modulo dopo ogni moltiplicazione. In questo modo non abbiamo neanche bisogno di utilizzare i big-integer:

(define (e097)
  (let (val 2L)
    (for (i 1 7830456)
      (setq val (% (* 2L val) 10000000000L))
    )
    (setq val (* val 28433L))
    (setq val (+ val 1L))
    (setq val (% val 10000000000L))))

(e097)
;-> 8739992577L

(define (e097)
  (let (val 2)
    (for (i 1 7830456)
      (setq val (% (* 2 val) 10000000000))
    )
    (setq val (* val 28433))
    (setq val (+ val 1))
    (setq val (% val 10000000000))))

(e097)
;-> 8739992577

Inoltre il tempo di esecuzione è accettabile:

(time (e097))
;-> 497.573


===========
Problema 99
===========

Massimo esponenziale

Confrontare due numeri scritti in forma di indice come 2^11 e 3^7 non è difficile, poiché qualsiasi calcolatrice confermerebbe che 2^11 = 2048 < 3^7 = 2187.

Tuttavia, confermare che 632382^518061 > 519432^525806 sarebbe molto più difficile, poiché entrambi i numeri contengono oltre tre milioni di cifre.

Utilizzando "base_exp.txt", un file di testo da 22 KB contenente mille righe con una coppia base / esponente su ciascuna riga, determinare quale numero di riga ha il valore numerico maggiore.

NOTA: le prime due righe nel file rappresentano i numeri nell'esempio fornito sopra.
============================================================================

Il file "base_exp.txt" è stato trasformato nel file "e099.lsp".

Non è necessario calcolare le potenze. Possiamo usare i logaritmi utilizzando le seguenti proprietà:

1) log(x) < (log(y) implica che x < y e viceversa (perchè log(x) è una funzione crescente).
2) log(x^y) = y*log(x)

In questo modo dobbiamo trovare il massimo dei valori: y*(log(x).

Carichiamo il file che contiene la lista "lst" con tutte le coppie di numeri (x y):

(load "e099.lsp")

(define (e099)
  (let ((max-val 0) (riga 0))
    (dolist (el lst)
      (if (> (mul (last el) (log (first el))) max-val)
          (setq riga (+ 1 $idx) max-val (mul (last el) (log (first el))))))
    riga))

(e099)
;-> 709

(time (e099))
;-> 0


============
Problema 100
============

Probabilità stabilite

Se una scatola contiene ventuno dischi colorati, composti da quindici dischi blu e sei dischi rossi, e due dischi sono stati presi a caso, si può vedere che la probabilità di prendere due dischi blu, P (BB) = (15/21) × (14/20) = 1/2.

La successiva disposizione di questo tipo, per la quale c'è esattamente il 50% di possibilità di prendere due dischi blu a caso, è una scatola contenente ottantacinque dischi blu e trentacinque dischi rossi.

Trova la prima disposizione che contenga più di 10^12 = 1.000.000.000.000 dischi in totale, determinare il numero di dischi blu che la confezione deve contenere.
============================================================================

                                 b     (b - 1)
Bisogna risolvere l'equazione:  --- * --------- = 1/2.
                                 n     (n - 1)

Sviluppando si ottiene: 2b^2 - 2b - n^2 + n = 0 che è una equazione quadratica diofantina. Risolvendo per b otteniamo le due soluzioni: b = (2 + sqrt (4 + 8n^2 - 8n)) / 4 = (1 + sqrt (1 + 2n^2 - 2n))/2. Quindi, è sufficiente trovare valori di n tali che 2n^2 - 2n + 1 = c^2 per qualche intero c. Risolvendo per n, otteniamo n = (2 + sqrt (8c^2 - 4))/4 = (1 + sqrt(2c^2 - 1))/2. Quindi, è sufficiente trovare valori di c tali che d^2 - 2c^2 = -1 per qualche intero d. Se (d, c) è una soluzione, (3*d + 4*c, 2*d + 3*c) è la prossima soluzione. Pertanto, le soluzioni intere per c possono essere generate ricorsivamente e ciascuna può essere tradotta in una soluzione distinta per il valore di b. Questo ragionamento porta alla coppia di equazioni ricorsive:

b(k+1) = 3*b(k) + 2*n(k) - 2
n(k+1) = 4*b(k) + 3*n(k) - 3

Adesso possiamo scrivere la funzione:
756872327473

(define (e100)
  (let ((n 21) (b 15) (b1 0) (n1 0))
    (while (< n 1000000000000)
      (setq b1 (+ (* 3 b) (* 2 n) (- 2)))
      (setq n1 (+ (* 4 b) (* 3 n) (- 3)))
      (setq b b1 n n1)
    )
    b))

(e100)
;-> 756872327473

(time (e100))
;-> 0

============================================================================
=======
(e096)
;-> 24702

(time (e096))
;-> 27084.701
>>>>>>> f2acca20c0b15972390864b1078897d6e663f0b3


===========
Problema 97
===========

Il più grande primo non-Mersenne

Il primo numero primo noto che supera il milione di cifre è stato scoperto nel 1999 ed è un numero primo di Mersenne della forma 2 ^ 6972593-1. Contiene esattamente 2.098.960 cifre. Successivamente sono stati trovati altri numeri primi di Mersenne, della forma (2^p − 1), che contengono più cifre.

Tuttavia, nel 2004 è stato trovato un enorme numero primo non Mersenne che contiene 2.357.207 cifre: 28433 × 2^7830457 + 1.

Trova le ultime dieci cifre di questo numero primo.
============================================================================

Le ultime 10 cifre di un numero n si ottengono applicando l'operatore modulo: (n % 10000000000).
Il problema è come calcolare velocemente 2^7830457. Cercando di risolvere direttamente l'espressione,  newLISP impiega un tempo lunghissimo. Infatti:

Funzione per calcolare la potenza (intera) di un numero intero:

(define (** num power)
    (let (out 1L)
        (dotimes (i power)
            (setq out (* out num)))))

Scriviamo la funzione:

(define (e097) (% (+ (* (** 2L 7830456L) 28433) 1) 10000000000L))

Attenzione, la seguente funzione impiega moltissimo tempo:

(e097)

Abbiamo visto che per estrapolare le ultime 10 cifre occorre calcolare (n mod 10000000000). Poichè per  l'operazione modulo (mod) vale la proprietà distributiva:

a*b mod n = ((a mod n)*(b mod n)) mod n

possiamo calcolare 2^7830457 utilizzando la moltiplicazione in un ciclo e utilizzando il modulo dopo ogni moltiplicazione. In questo modo non abbiamo neanche bisogno di utilizzare i big-integer:

(define (e097)
  (let (val 2L)
    (for (i 1 7830456)
      (setq val (% (* 2L val) 10000000000L))
    )
    (setq val (* val 28433L))
    (setq val (+ val 1L))
    (setq val (% val 10000000000L))))

(e097)
;-> 8739992577L

(define (e097)
  (let (val 2)
    (for (i 1 7830456)
      (setq val (% (* 2 val) 10000000000))
    )
    (setq val (* val 28433))
    (setq val (+ val 1))
    (setq val (% val 10000000000))))

(e097)
;-> 8739992577

Inoltre il tempo di esecuzione è accettabile:

(time (e097))
;-> 497.573


