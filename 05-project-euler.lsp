================

 PROJECT EULERO

================

                                Intel i5     Intel i7     Intel i7
  Problema    Soluzione         Tempo (msec) Tempo (msec) Tempo (msec)
                                Algorithm 1  Algorithm 1  Algorithm 2
|    1     |  233168            |         0  |         0  |         0  |
|    2     |  4613732           |         0  |         0  |         0  |
|    3     |  6857              |         0  |         0  |         0  |
|    4     |  906609            |       297  |       203  |         0  |
|    5     |  232792560         |         0  |         0  |         0  |
|    6     |  25164150          |         0  |         0  |         0  |
|    7     |  104743            |        78  |        31  |        16  |
|    8     |  23514624000       |       110  |        62  |         0  |
|    9     |  31875000          |        62  |        31  |         0  |
|    10    |  142913828922      |      1563  |      1078  |       546  |
|    11    |  70600674          |         0  |         0  |         3  |
|    12    |  76576500          |      5445  |      4022  |         0  |
|    13    |  5537376230        |         0  |         0  |         -  |
|    14    |  837799            |     22487  |     15408  |      7563  |
|    15    |  137846528820      |         0  |         0  |         0  |
|    16    |  1366              |         0  |         0  |        32  |
|    17    |  21124             |         0  |         0  |         -  |
|    18    |  1074              |        32  |         7  |         0  |
|    19    |  171               |         3  |         1  |         1  |
|    20    |  648               |         0  |         0  |         -  |
|    21    |  31626             |       220  |       134  |        87  |
|    22    |  871198282         |        20  |        10  |         -  |
|    23    |  4179871           |     40900  |     27534  |         -  |
|    24    |  2783915460        |     25309  |     12282  |         -  |
|    25    |  4782              |      4926  |      3469  |         -  |
|    26    |  983               |       488  |       266  |         -  |
|    27    |  -59231            |      2000  |      1532  |         -  |
|    28    |  669171001         |         0  |         0  |         -  |
|    29    |  9183              |       141  |        94  |         -  |
|    30    |  443839            |       516  |       344  |         -  |
|    31    |  73682             |         1  |         0  |         -  |
|    32    |  45228             |      1625  |      1079  |         -  |
|    33    |  100               |         0  |         0  |         -  |
|    34    |  40730             |      3797  |      2625  |         -  |
|    35    |  55                |      1267  |       902  |         -  |
|    36    |  872187            |      1443  |       945  |         -  |
|    37    |  748317            |       778  |       651  |         -  |
|    38    |  932718654         |        94  |        48  |         -  |
|    39    |  840               |     13486  |      9561  |         -  |
|    40    |  210               |       141  |       433  |         -  |
|    41    |  7652413           |       125  |        64  |         -  |
|    42    |  162               |        31  |         4  |         -  |
|    43    |  16695334890       |      1749  |      1321  |         -  |
|    44    |  5482660           |      5589  |      4182  |         -  |
|    45    |  1533776805        |       115  |        63  |         -  |
|    46    |  5777              |        31  |         5  |         -  |
|    47    |  134043            |         0  |         0  |         -  |
|    48    |  9110846700        |       266  |       186  |         -  |
|    49    |  296962999629      |        19  |         5  |         -  |
|    50    |  997651            |     27113  |     18871  |         -  |
|    51    |  121313            |       269  |       180  |         -  |
|    52    |  142857            |       313  |       204  |         -  |
|    53    |  4075              |        25  |         5  |         -  |
|    54    |  376               |       154  |        91  |         -  |
|    55    |  249               |       116  |        69  |         -  |
|    56    |  972               |       186  |       119  |         -  |
|    57    |  153               |        10  |         1  |         -  |
|    58    |  26241             |       630  |       432  |         -  |
|    59    |  129448 / 107359   |        15  |         1  |         -  |
|    60    |  26033             |     55055  |     38926  |         -  |
|    61    |  28684             |         -  |        85  |         -  |
|    62    |  127035954683      |         -  |      6348  |        83  |
|    63    |  49                |         -  |         0  |         0  |
|    64    |  1322              |         -  |        81  |         -  |
|    65    |  272               |         -  |         0  |         -  |
|    66    |  661               |         -  |         0  |         -  |
|    67    |  7273              |         -  |         1  |         -  |
|    68    |  6531031914842725  |         -  |        21  |         -  |
|    69    |  510510            |         -  |       642  |         -  |
|    70    |  8319823           |         -  |      9621  |         7  |
|    71    |  428570            |         -  |       191  |         -  |
|    72    |  303963552391      |         -  |      2060  |         -  |
|    73    |  7295372           |         -  |      1809  |      2345  |
|    74    |  402               |         -  |    286059  |      1125  |
|    75    |  161667            |         -  |       822  |         -  |
|    76    |  190569291         |         -  |         0  |         -  |
|    77    |  71                |         -  |         4  |         -  |
|    78    |  55374             |         -  |      7918  |         -  |
|    79    |  73162890          |         -  |         0  |         -  |
|    80    |  40886             |         -  |        29  |         -  |
|    81    |  427337            |         -  |         3  |         -  |
|    82    |  260324            |         -  |         5  |         -  |
|    83    |  425185            |         -  |      6503  |         -  |
|    84    |  101524            |         -  |        66  |         -  |
|    85    |  2772              |         -  |         2  |         -  |
|    86    |  1818              |         -  |    233564  |       528  |
|    87    |  1097343           |         -  |      1153  |         -  |
|    88    |  7587457           |         -  |     24771  |       377  |
|    89    |  743               |         -  |         0  |         -  |
|    90    |  1217              |         -  |        31  |         -  |
|    91    |  14234             |         -  |      7259  |         1  |
|    92    |  8581146           |         -  |     51582  |        16  |
|    93    |  1258              |         -  |       389  |         -  |
|    94    |  518408346         |         -  |     28946  |         0  |
|    95    |  14316             |         -  |      1846  |         -  |
|    96    |  24702             |         -  |     27084  |         -  |
|    97    |  8739992577        |         -  |       497  |         -  |
|    98    |  18769             |         -  |       136  |         -  |
|    99    |  709               |         -  |         0  |         -  |
|   100    |  756872327473      |         -  |         0  |         -  |
|   101    |  37076114526       |         -  |        70  |         -  |
|   102    |  228               |         -  |         2  |         1  |
|   103    |  20313839404245    |         -  |         0  |         -  |
|   104    |  329468            |         -  |     37978  |         -  |
|   105    |  73702             |         -  |       864  |         -  |
|   108    |  180180            |         -  |      7521  |       331  |
|   109    |  38182             |         -  |         9  |         -  |
|   110    |  9350130049860600  |         -  |        16  |         -  |
|   112    |  1587000           |         -  |      1732  |         -  |
|   113    |  51161058134250    |         -  |         8  |         -  |
|   114    |  16475640049       |         -  |         0  |         -  |
|   115    |  168               |         -  |         2  |         -  |
|   119    |  248155780267521   |         -  |        26  |         -  |
|   120    |  333082500         |         -  |         0  |         -  |
|   121    |  2269              |         -  |         1  |         -  |
|   122    |  1582              |         -  |       138  |         -  |
|   123    |  21035             |         -  |       134  |         -  |
|   124    |  21417             |         -  |       140  |         -  |
|   125    |  2906969179        |         -  |      1570  |         -  |
|   135    |  4989              |         -  |      2874  |      1194  |
|   145    |  608720            |         -  |     99501  |         0  |
|   173    |  1572729           |         -  |       124  |         0  |
|   188    |  95962097          |         -  |        29  |         -  |
|   191    |  1918080160        |         -  |         1  |         0  |
|   206    |  1389019170        |         -  |         2  |         -  |

Sito web: https://projecteuler.net/archives

Cos'è Project Euler?
Project Euler è una serie di stimolanti problemi di programmazione matematica/informatica che richiedono molto più di semplici approfondimenti matematici per essere risolti. Sebbene la matematica aiuti ad arrivare a metodi eleganti ed efficienti, per risolvere la maggior parte dei problemi sarà necessario l'uso di un computer e competenze di programmazione.

La motivazione per l'avvio di Project Euler, e la sua continuazione, è di fornire una piattaforma per la mente indagatrice per addentrarsi in aree non familiari e apprendere nuovi concetti in un contesto divertente e ricreativo.

A chi sono rivolti i problemi?
Il pubblico previsto comprende studenti per i quali il curriculum di base non alimenta la loro fame per imparare, adulti il ​​cui background non era principalmente la matematica ma aveva un interesse per le cose matematiche, e professionisti che vogliono mantenere le loro capacità di solving e la matematica all'avanguardia.

Chiunque può risolvere i problemi?
I problemi sono di diversa difficoltà e per molti l'esperienza è l'apprendimento a catena induttivo. Cioè, risolvendo un problema ti esporrà ad un nuovo concetto che ti permette di intraprendere un problema precedentemente inaccessibile. Quindi il partecipante determinato lentamente ma sicuramente farà il suo lavoro attraverso ogni problema.

Cosa fare in seguito?
Per tenere traccia dei tuoi progressi è necessario impostare un account e abilitare i cookie. Se hai già un account puoi accedere senza problemi, altrimenti devi registrati - è completamente gratuito!

Tuttavia, poiché alcuni problemi sono difficili, potresti voler visionare i problemi prima di registrarti.

"Il progetto Eulero esiste per incoraggiare, sfidare e sviluppare le capacità e il divertimento di chiunque abbia un interesse per l'affascinante mondo della matematica."

Nota: i problemi devono essere risolti con la "regola del minuto", cioè i programmi devono trovare la soluzione entro un minuto (se possibile).

In questo paragrafo affronteremo e risolveremo alcuni di questi problemi. Comunque prima di vedere la soluzione dovresti provare a risolverli per conto proprio in modo da migliorare le tue capacità di problem-solver e di programmatore.

Nota: La maggior parte delle soluzioni contiene una spiegazione dell'algoritmo utilizzato e alcuni problemi sono risolti con due algoritmi diversi. In genere il secondo algoritmo ha un approccio più matematico ed è più veloce.

Nota: La soluzione della maggior parte dei problemi comporta (almeno per me) la ricerca di informazioni su internet di argomenti diversi (matematica, algoritmi, problem solving, ecc.).

Vengono prima presentate alcune funzioni che servono per la soluzione di diversi problemi.

;=============================================
; (isprime? n)
; Controlla se n è un numero primo
; Non funziona con i big integer
; numero massimo (int64): 9223372036854775807
;=============================================
(define (isprime? n)
   (if (< n 2) nil
       (= 1 (length (factor n)))))
;=============================================

;=============================================
; (factor-group n)
; fattorizza il numero x raggruppando i termini uguali
; Non funziona con i big integer
; numero massimo (int64): 9223372036854775807
;=============================================
(define (factor-group x)
  (if (= x 1) '(1 1)
    (letn (fattori (factor x)
          unici (unique fattori))
      (transpose (list unici (count unici fattori)))
    )
  )
)

(factor-group 1)
;-> (1 1)

(factor-group 2000)
;-> ((2 4) (5 3))

(factor-group 232792560)
;-> ((2 4) (3 2) (5 1) (7 1) (11 1) (13 1) (17 1) (19 1))

E la funzione inversa a factor-group che genera il numero partendo dalla fattorizzazione:

(define (inv-factor-group lst)
      (apply * (map (lambda (x) (pow (first x) (last x))) lst))
)

(inv-factor-group (factor-group 232792560))
;-> 232792560
----------------------------------------------------------------------------


==========
Problema 1
==========

Multipli di 3 e di 5

Se elenchiamo i numeri sotto a 10 che sono multipli di 3 o di 5, otteniamo 3, 5, 6 e 9.
La loro somma vale 23.

Trova la somma di tutti i multipli di 3 o di 5 sotto a 1000.
============================================================================

La funzione "sequence" genera una lista di numeri:

(sequence 1 10)
;-> (1 2 3 4 5 6 7 8 9 10)

(sequence 1 10 2)
;-> (1 3 5 7 9)

Possiamo anche scrivere una funzione che si comporta come "sequence":

(define (seq start end (step 1))
  (cond ((= start end) (list end))
        ((> start end) '())
        (true (cons start (seq (+ start step) end step)))
  )
)

(seq 1 10)
;-> (1 2 3 4 5 6 7 8 9 10)

(seq 1 10 2)
;-> (1 3 5 7 9)

Un numero n è divisibile esattamente per m se risulta (n mod m == 0),
cioè il resto della divisione tra n e m vale zero.
In newLISP "%" è la funzione mod per i numeri interi.

(zero? (% 10 2))
;-> true
(zero? (% 130 11))
;-> nil

La funzione "filter" seleziona tutti i valori che soddisfano un predicato:
(filter (fn(x) (> x 5)) '(6 4 5 2 6 7 3 4 8 9))
;-> (6 6 7 8 9)

La funzione "apply" applica una funzione utilizzando tutti gli argomenti:
(apply + '(1 3 5))
;-> 9

Adesso possiamo scrivere la funzione:

(define (e001)
  (apply + (filter (fn(x) (or (zero? (% x 3)) (zero? (% x 5)))) (sequence 1 999)))
)

(e001)
;-> 233168

(time (e001))
;-> 0

(time (e001) 10000)
;-> 2453.466

Soluzione alternativa:

generiamo due sequenze (una con i multipli di 3 e l'altra con i multipli di 5)
(setq a (sequence 3 20 3))
;-> (3 6 9 12 15 18)
(setq b (sequence 5 20 5))
;-> (5 10 15 20)

uniamo le sequenze (la funzione union mantiene solo valori unici)
(setq c (union a b))
;-> (3 6 9 12 15 18 5 10 20)

infine sommiamo tutti i numeri:
(apply + c)
;-> 18

Ed ecco la funzione:

(define (e001)
    (apply + (union (sequence 3 999 3) (sequence 5 999 5)))
)

(e001)
;-> 233168

(time (e001))
;-> 0

(time (e001) 10000)
;-> 796.682

Dal punto di vista matematico possiamo notare che:

Sum[1..n] (i) = (1/2)*n*(n + 1) (Formula di Gauss)

Se vogliamo sapere quanti numeri sono divisibili per 3 possiamo scrivere:

D(n 3) = 3 * Sum[1 (floor n/3)] (i) = 3*(1/2)*(floor n/3)*((floor n/3) + 1)

Perchè contiamo fino a (floor n/3)? Applichiamo la formula:

(3) * (1 + 2 + 3 + ... 999) ==> (3 6 9 12 ... 2997)

Quanti sono i divisori di 3 fino a 999:

(for (i 1 999) (if (zero? (% i 3)) (++ d))) d
;-> 333

Quindi:

(floor (div 999 3))
;-> 333

E per un generico valore k (invece di 3):

D(n k) = k*Sum[1 (floor n/k)] (i) = k*(1/2)*(floor n/k)*((floor n/k) + 1)

Adesso sommiamo i divisori di 3 e i divisori di 5 e sottraiamo i divisori 15 (perchè (lcm 5 3 = 15)):

sol = D(999 3) + D(999 5) - D(999 15)

(define (e001-2 n)
  (local (a b c)
    (setq a (floor (div n 3)))
    (setq b (floor (div n 5)))
    (setq c (floor (div n 15)))
    (div (- (+ (* 3 a (+ a 1)) (* 5 b (+ b 1))) (* 15 c (+ c 1))) 2)))

(e001-2 999)
;-> 233168

(time (e001-2 999))
;-> 0

(time (e001-2 999) 10000)
;-> 15.586

Il tempo di questa funzione non dipende da n (diversamente dalle prime due funzioni).

(time (e001-2 10000) 10000)
;-> 15.587
----------------------------------------------------------------------------


==========
Problema 2
==========

I numeri di Fibonacci pari

Ciascun nuovo termine della sequenza di Fibonacci viene generato addizionando i due termini precedenti.
Partendo da 1 e 2, i primi 10 termini valgono:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

Considerando i termini della sequenza di Fibonacci i cui valori non superano quattro milioni, trovare la somma dei termini pari.
============================================================================

Questa è la funzione per il calcolo dei numeri di fibonacci:

(define (fibonacci n)
  (let (L '(0 1))
    (dotimes (i n)
      (setq L (list (L 1) (apply + L)))
    )
    ;(L 1)
    (last L)
  )
)

Il numero 32 è quello che genera l'ultimo valore utile (minore di 4.000.000):

(fibonacci 32)
;-> 3524578

(fibonacci 33)
;-> 5702887

Modifichiamo l'espressione "dotimes" con "while" per controllare il valore ottenuto.
Inoltre aggiorniamo il valore del risultato (res) quando il numero calcolato è dispari.

(define (e002)
  (let (L '(0 1) res 0)
    ;(dotimes (i n)
    (while (< (last L) 4000000)
      (setq L (list (L 1) (apply add L)))
      (if (even? (last L)) (inc res (last L)))
    )
    ;(last L)
    res
  )
)

(e002)
;-> 4613732

(time (e002))
;-> 0

(time (e002) 100000)
;-> 671.918

Soluzione alternativa:

(define (e002)
  (let (a 2 b 1 ans 0)
    (until (> b 4000000)
      (if (even? a)
        (inc ans a))
      (inc b a)
      (swap a b))
     ans))

(e002)
;-> 4613732

(time (e002))
;-> 0

(time (e002) 100000)
;-> 343.627

Dal punto di vista matematico:

Formula di Binet (relazione tra i numeri di fibonacci e il rapporto aureo):

Fib(n) = (phi^n - psi^n)/sqrt(5)

dove: phi = (1 + sqrt(5))/2 e psi = (1 - sqrt(5))/2

Invertendo la formula troviamo l'indice n per il numero di fibonacci Fib(n) dato:

n = floor (log[phi](F*sqrt(5) + (1/2)))

Inoltre utilizziamo la seguente identità (la somma dei primi n numeri di fibonacci vale (F(n+2) - 1):

Sum[0 n] F(i) = F(n+2) - 1

Usiamo queste formule per scrivere la funzione:

(define (setval)
  (setq sr (sqrt 5))
  (setq phi (div (add 1 sr) 2))
  (setq psi (div (sub 1 sr) 2)))

(define (f n) (div (sub (pow phi n) (pow psi n)) sr))
(define (idx fib) (floor (div (log (add (mul fib sr) 0.5)) (log phi))))
(define (sumfib n) (sub (f (+ n 2)) 1))

(define (e002-2 n)
    (setval)
    (round (div (sumfib (idx n)) 2)))

(e002-2 3999999)
;-> 4613732

(time (e002-2 3999999))
;-> 0

(time (e002-2 3999999) 100000)
;-> 78.098

Il tempo di questa funzione non dipende da n (diversamente dalle prime due funzioni).

(time (e002-2 9999999) 100000)
;-> 78.096
----------------------------------------------------------------------------


==========
Problema 3
==========

Il più grande fattore primo

I fattori primi di 13195 sono 5, 7, 13 e 29.

Qual'è il fattore primo più grande del numero 600851475143 ?
============================================================================

La funzione "factor" di newLISP restituisce tutti i fattori di un numero:

(factor 600851475143)
;-> (71 839 1471 6857)

Non resta che trovare il valore massimo:

(apply max (factor 600851475143))
;-> 6857

Definiamo la funzione:

(define (e003)
  (apply max (factor 600851475143))
)

(e003)
;-> 6857

(time (e003))
;-> 0

(time (e003) 100000)
;-> 496.8

Se vogliamo implementare la fattorizzazione, possiamo scrivere:

(define (e003-2 n)
  (let (i 2)
    (while (<= (* i i) n)
      (while (= (% n i) 0)
        (setq n (/ n i))
      )
      (++ i)
    )
    n))

(e003-2 600851475143)
;-> 6857

(time (e003-2 600851475143))
;-> 0

(time (e003-2 600851475143) 100000)
;-> 18174.285
----------------------------------------------------------------------------


==========
Problema 4
==========

Il più grande prodotto palindromo

Un numero palindromo ha lo stesso valore leggendo da sinistra a destra o da destra a sinistra.
Il più grande numero palindromo ottenuto dal prodotto di due numeri da due cifre vale 9009 = 91 * 99.

Trova il più grande numero palindromo ottenuto dal prodotto di due numeri da tre cifre.
============================================================================

(define (e004)
    (let (out 0  val 0)
        (for (i 100 999)
          (for (j i 999)
            (setq val (string (* i j)))
            (when (= val (reverse (copy val)))
                (setq out (max out (int val)))
            )
          )
        )
 out)
)

(e004)
;-> 906609

(time (e004))
;-> 204.069

(time (e004) 100)
;-> 19220.569

Dal punto di vista matematico:

La prima osservazione è che il numero deve essere compreso tra 100^2 e 999^2 o nell'intervallo (10000, 998001). 1]. Poiché la maggior parte dei numeri ha 6 cifre e stiamo cercando il più grande, ignoriamo i numeri a 5 cifre. Sulla base di questo, possiamo costruire un numero palindromo come:

'abccba' = 100000a + 10000b + 1000c + 100c + 10b + a
         = 100001a + 10010b + 1100c
         11*(9091a + 910b + 100c)

Pertanto, stiamo cercando i due numeri più grandi p, q:

p*q = 11*(9091a + 910b + 100c) ≤ 999^2

Questa equazione ci mostra che p o q, ma non entrambi, devono avere un fattore 11. Per massimizzare le due incognite, iniziamo la ricerca con p = 9 e per ogni p decrescente cerchiamo un massimo q per costruire un palindromo. Possiamo fare un'ottimizzazione basata sull'osservazione precedente: se p non è divisibile per 11, q lo deve essere, e come tale possiamo iniziare la ricerca con 990 come maggior multiplo di 11 e cercare solo multipli di 11. Un'altra ottimizzazione è, che non abbiamo bisogno di lasciare che q vadaal di sotto di p poiché possiamo scambiare i numeri. Vediamo un'implementazione:

(define (palindromo? num)
  (let (str (string num))
    (= str (reverse (copy str)))))

(define (e004-2)
  (local (r s t q p found)
    (setq r 0)
    (setq p 999)
    (while (>= p 100)
      (if (zero? (% p 11))
          (setq q 999 s 1)
          (setq q 990 s 11)
      )
      (setq found nil)
      (while (and (> q 99) (not found))
        (setq t (* p q))
        (if (and (< r t) (palindromo? t))
            (setq r t found true)
            ;(begin (println p { } q { } t) (setq r t found true))
        )
        (setq q (- q s))
      )
      (-- p)
    )
    r))

(e004-2)
;-> 906609

993 * 913 = 906609

(time (e004-2))
31.237

(time (e004-2) 100)
;-> 2187.681

Questa funzione è circe 10 volte più veloce della prima funzione.

Possiamo migliorare la funzione invertendo di nuovo p e q. In questo modo possiamo usare un ciclo con p da 990 attraverso i multipli di 11 e usare q per trovare un palindromo.

(define (e004-2)
  (local (r t q p found)
    (setq r 0)
    (for (p 990 100 -11)
      (setq found nil)
      (for (q 999 100 -1 found)
        (setq t (* p q))
        (if (and (< r t) (palindromo? t))
            (setq r t found true)
            (if (< t r) (setq found true))
        )
      )
    )
    r))

(e004-2)
;-> 906609

(time (e004-2))
;-> 0

(time (e004-2) 100)
;-> 109.373

Quest'ultima funzione è 20 volte più veloce della precedente (seconda) funzione.
(div 2187.681 109.373)
;-> 20.002

Quest'ultima funzione è 175 volte più veloce della prima funzione.
(div 19220.569 109.373)
;-> 175.734
----------------------------------------------------------------------------


==========
Problema 5
==========

Il multiplo minore

2520 è il più piccolo numero che può essere diviso esattamente (senza resto) da tutti i numeri da 1 a 10.

Qual'è il più piccolo numero positivo che è divisibile esattamente per tutti i numeri da 1 a 20 ?
============================================================================

La soluzione non vale 1*2*3*4*5*6*7*8*9*10*11*12*13*14*15*16*17*18*19*20 perchè, per esempio, quando il numero cercato è divisibile per 3 e per 5 è anche divisibile per 15.

La soluzione consiste nel trovare tutti i numeri che sono fattori unici con gli esponenti massimi e moltiplicarli tra loro.

Proviamo con il numero 10:

Troviamo tutte scomposizioni in fattori:

2  -> (2)
3  -> (3)
4  -> (2 2)
5  -> (5)
6  -> (2 3)
7  -> (7)
8  -> (2 2 2)
9  -> (3 3)
10 -> (2 5)

I fattori unici sono: 2, 3, 5, e 7.

Questi hanno esponenete massimo rispettivamente: 3 2 1 1.

Quindi i numeri da moltiplicare sono: 2^3, 3^2, 5^1 e 7^1.

Otteniamo: 8 * 9 * 5 * 7 = 2520.

; lista con le fattorizzazioni dei numeri da 2 a 10
(setq a (map factor (sequence 2 10)))
;-> ((2) (3) (2 2) (5) (2 3) (7) (2 2 2) (3 3) (2 5))

; lista con tutti i numeri dei fattori
(setq b (flat (map factor (sequence 2 10))))
;-> (2 3 2 2 5 2 3 7 2 2 2 3 3 2 5)

; lista con tutti i numeri dei fattori presi una sola volta
(setq c (unique (flat (map factor (sequence 2 10)))))
;-> (2 3 5 7)

Adesso dobbiamo trovare gli esponenti massimi di 2,3,5 e 7 nella lista con le fattorizzazioni dei numeri da 2 a 10.

Vediamo prima come funziona funzione "count":

(setq a '((1 2) (5 5) (2 3)))
(setq c '(2 3 5))

Vogliamo trovare quante volte gli elementi di c compaiono in a:

(map (curry count c) a)
;-> ((1 0 0) (0 0 2) (1 1 0)

cosa significa il risultato?

(1 0 0) -> conto il 2 una  volta su (1 2)
        -> conto il 3 zero volte su (1 2)
        -> conto il 5 zero volte su (1 2)

(0 0 2) -> conto il 2 zero volte su (5 5)
        -> conto il 3 zero volte su (5 5)
        -> conto il 5 due  volte su (5 5)

(1 1 0) -> conto il 2 una  volta su (2 3)
        -> conto il 3 una  volta su (2 3)
        -> conto il 5 zero volte su (2 3)

Se trasponiamo la lista:

(transpose(map (curry count c) a))
;-> ((1 0 1) (0 0 1) (0 2 0))

Che significa:

(1 0 1) -> conto il 2 una  volta su (1 2)
        -> conto il 2 zero volte su (5 5)
        -> conto il 2 una  volta su (2 3)
(0 0 1) -> conto il 3 zero volte su (1 2)
        -> conto il 3 zero volte su (5 5)
        -> conto il 3 una  volta su (2 3)
(0 2 0) -> conto il 5 zero volte su (1 2)
        -> conto il 5 due  volte su (5 5)
        -> conto il 5 zero volte su (2 3)

Nel nostro caso:

; lista con le fattorizzazioni dei numeri da 2 a 10
(setq a (map factor (sequence 2 10)))
;-> ((2) (3) (2 2) (5) (2 3) (7) (2 2 2) (3 3) (2 5))

; lista con tutti i numeri dei fattori
(setq b (flat (map factor (sequence 2 10))))
;-> (2 3 2 2 5 2 3 7 2 2 2 3 3 2 5)

; lista con tutti i numeri dei fattori presi una sola volta
(setq c (unique (flat (map factor (sequence 2 10)))))
;-> (2 3 5 7)

Adesso troviamo quante volte gli elementi di c compaiono in a:

(setq d (transpose(map (curry count c) a)))
;-> ((1 0 2 0 1 0 3 0 1) (0 1 0 0 1 0 0 2 0) (0 0 0 1 0 0 0 0 1) (0 0 0 0 0 1 0 0 0))

Adesso dobbiamo trovare il valore massimo di ogni sottolista (che sono gli esponenti massimi rispettivamente di 2,3,5 e 7).

(setq e (map (curry apply max)
            (transpose(map (curry count c) a))))
;-> (3 2 1 1)

Per capire meglio come funziona l'ultima espressione vediamo un esempio.

Se vogliamo applicare la funzione "sin" ad una lista di valori possiamo usare la funzione "map":

(map sin '(10 20 30))
;-> (-0.5440211108893698 0.9129452507276277 -0.9880316240928618)

Ma se i valori sono in sottoliste questo non funziona:

(map sin '((10) (20) (30)))
;-> ERR: value expected in function sin : '(10)

La soluzione si ottiene utilizzando la funzione "curry" e "apply":

(map (curry apply sin) '((10) (20) (30)))
;-> (-0.5440211108893698 0.9129452507276277 -0.9880316240928618)

Oppure in modo equivalente:

(map (lambda (x) (apply sin x)) '((10) (20) (30)))

"curry" transforma una funzione f(x, y) che prende due argomenti in una funzione fx(y) che prende un singolo argomento.
In questo modo "curry" dice ad "apply" di applicare la funzione "sin" solo alla sottolista.

Tornando al problema abbiamo:

; lista con tutti i numeri dei fattori presi una sola volta
(setq c (unique (flat (map factor (sequence 2 10)))))
;-> (2 3 5 7)

; lista con gli esponenti massimi rispettivamente di 2,3,5 e 7).
(setq e (map (curry apply max)
            (transpose(map (curry count c) a))))
;-> (3 2 1 1)

Adesso calcoliamo i numeri con la funzione "pow" e li moltiplichiamo tra loro:

(apply * (map pow c e))
;-> 2520

Scriviamo la funzione finale:

(define (e005)
  (setq a (map factor (sequence 2 20)))
  (setq b (flat a))
  (setq c (unique b))
  (setq e (map (curry apply max)
               (transpose(map (curry count c) a))))
  (apply * (map pow c e))
)

(e005)
;-> 232792560

(time (e005))
;-> 0

Dal punto di vista matematico, dopo tutti questi ragionamenti per trovare la soluzione notiamo che il problema richiedeva semplicemente di trovare il minimo comune multiplo dei primi venti numeri interi...

Quindi utilizzando la seguente funzione che calcola il Minimo Comune Multiplo di una serie di numeri:

(define-macro (mcm)
  (apply (fn (x y) (/ (* x y) (gcd x y))) (args) 2))

Potevamo calcolare la soluzione con:

(mcm 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20)
;-> 232792560

(define (e005-2) (apply mcm (sequence 2 20)))

(e005-2)
;-> 232792560

(time (e005-2))
;-> 0
----------------------------------------------------------------------------


==========
Problema 6
==========

Somma quadrati differenza

La somma dei quadrati dei primi dieci numeri naturali vale,

1^2 + 2^2 + ... + 10^2 = 385

Il quadrato della somma dei primi dieci numeri naturali vale,

(1 + 2 + ... + 10)^2 = 55^2 = 3025

Quindi la differenza tra la somma dei quadrati e il quadrato della somma dei primi dieci numeri naturali vale 3025 − 385 = 2640.

Trovare la differenza tra la somma dei quadrati e il quadrato della somma dei primi cento numeri naturali.
============================================================================

I primi dieci numeri li otteniamo da:

(setq num (sequence 1 10))
;-> (1 2 3 4 5 6 7 8 9 10)

La loro somma vale:

(setq sum (apply add num))
;-> 55

Il quadrato della somma vale:

(setq qs (* sum sum))
;-> 3025

La somma dei quadrati vale:

(setq sq (apply add (map * num num)))

Nota che:

(setq lst (sequence 1 10))
(map * lst lst)
;-> (1 4 9 16 25 36 49 64 81 100)
(map * lst lst lst)
;-> (1 8 27 64 125 216 343 512 729 1000)

La loro differenza vale:

(sub qs sq)
;-> 2640

Scriviamo la funzione:

(define (e006)
  (setq num (sequence 1 100))
  (setq sum (apply add num))
  (setq qs (* sum sum))
  (setq sq (apply add (map * num num)))
  (sub qs sq)
)

(e006)
;-> 25164150

(time (e006))
;-> 0

(time (e006) 100000)
;-> 640.678

Soluzione alternativa:

(define (e006)
    (let (lst (sequence 1 100))
        (- (pow (apply + lst)) (apply + (map * lst lst))) )
)

(e006)
;-> 25164150

(time (e006))
;-> 0

(time (e006) 100000)
;-> 640.467

Dal punto di vista matematico abbiamo:

Somma dei Quadrati

f(n) = Sum[1..n] i^2 = (1/6)*n*(n - 1)*(2*n - 1)

Quadrato della Somma

g(n) = (Sum[1..n] i)^2 = (1/4)*n^2*(n + 1)^2

La loro differenza:

g(n) - f(n) = (1/12)*n*(n + 1)*(3*n^2 - n - 2)

Possiamo scrivere la funzione:

(define (e006-2 n)
  (/ (* n (+ n 1) (sub (* 3 (pow n)) n 2)) 12))

(e006-2 100)
;-> 25164150

(time (e006-2 100))
;-> 0

(time (e006-2 100) 100000)
;-> 31.237

Il tempo di questa funzione non dipende da n (diversamente dalle prime due funzioni).

(time (e006-2 10000) 100000)
;-> 31.235
----------------------------------------------------------------------------


==========
Problema 7
==========

Il 10001-esimo numero primo

Elencando i primi sei numeri primi: 2, 3, 5, 7, 11, e 13, si nota che il sesto primo è 13.

Qual'è il 10001-esimo numero primo?
============================================================================

La soluzione con la forza bruta è semplice, cerchiamo progressivamente tutti i numeri primi partendo dal primo fino ad arrivare al 10001 numero primo:

(define (e007)
  (setq cnt 1 n 3) ; partiamo da 3 (il numero 2 è primo)
  (while (!= 10001 cnt)
      (if (isprime? n) (setq cnt (+ cnt 1))) ; se è un numero primo incrementiamo il conto
      (setq n (+ n 2)) ; non consideriamo i numeri pari
  )
  (- n 2)
)

(e007)
;-> 104743

(time (e007))
;-> 31.235

(time (e007) 100)
;-> 2625.219

Dal punto di vista matematico possiamo sfruttare il fatto che tutti i numeri primi (tranne il 2 e il 3) sono nella forma (6*k ± 1):

(define (e007-2 n)
  (local (conta i)
    (setq conta 2 i 0)
    (while (< conta n)
      (++ i 6)
      (if (isprime? (+ i 1)) (++ conta))
      (if (isprime? (- i 1)) (++ conta))
    )
    ; l'aggiungo l'ultimo primo che è nella forma 6*k + 1
    (+ i 1)))

(e007-2 10001)
;-> 104743

(time (e007-2 10001))
;-> 15.587

(time (e007-2 10001) 100)
;-> 1875.206
----------------------------------------------------------------------------


==========
Problema 8
==========

Il maggior prodotto in una serie

Le quattro cifre adiacenti che hanno il più grande prodotto nel numero da 1000 cifre riportato di seguito sono 9 × 9 × 8 × 9 = 5832.

73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450

Trovare, nel numero da 1000 cifre, le tredici cifre adiacenti che hanno il prodotto più grande. Qual'è il valore di questo numero ?
============================================================================

Assegniamo il numero ad una variabile di tipo stringa:

(setq x
"7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450")

(length x)
;-> 1000

Possiamo anche assegnare la variabile in un altro modo:

; elimina gli spazi (line-feeds)
(setq x (replace "\\s+" [text]
73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450
[/text] "" 0))

(length x)
;-> 1000

Dividiamo la stringa in blocchi da 13 caratteri (con passo 1 da 0 a 987):

(slice (explode x) 0 5) ; 5 al posto di 13
;-> ("7" "3" "1" "6" "7")

(setq a (map (fn (i) (slice (explode x) i 5))
             (sequence 0 4))) ; 4 al posto di 987

;-> (("7" "3" "1" "6" "7")
;->  ("3" "1" "6" "7" "1")
;->  ("1" "6" "7" "1" "7")
;->  ("6" "7" "1" "7" "6")
;->  ("7" "1" "7" "6" "5"))

(setq b (map join a))
;-> ("73167" "31671" "16717" "67176" "71765")

Mettiamo tutto insieme:

(setq c (map join (map (fn (i) (slice (explode x) i 5))
                       (sequence 0 4))))

;-> ("73167" "31671" "16717" "67176" "71765")

Convertiamo ogni carattere del blocco in integer:

(map explode c)
;-> (("7" "3" "1" "6" "7")
;->  ("3" "1" "6" "7" "1")
;->  ("1" "6" "7" "1" "7")
;->  ("6" "7" "1" "7" "6")
;->  ("7" "1" "7" "6" "5"))

(setq d (map (fn (i) (map int i)) (map explode c)))
;-> ((7 3 1 6 7) (3 1 6 7 1) (1 6 7 1 7) (6 7 1 7 6) (7 1 7 6 5))

Adesso moltiplichiamo tra loro i numeri in ogni sottolista:

(setq e (map (fn (i) (apply * i)) d))
;-> (882 126 294 1764 1470)

Infine troviamo il valore massimo delle moltiplicazioni:

(apply max e)
;-> 1764

Possiamo scrivere la funzione:

(setq x
"7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450")

(define (e008)
  ;(setq a (map join (map (fn (i) (slice (explode x) i 4)) ; for test: 5832
  ;                       (sequence 0 996))))
  (setq a (map join (map (fn (i) (slice (explode x) i 13)); for final result
                         (sequence 0 987))))
  (setq b (map (fn (i) (map int i)) (map explode a)))
  (setq c (map (fn (i) (apply * i)) b))
  (setq _res (apply max c))
  ;(println (nth (ref _res c) b)) ;-> (5 5 7 6 6 8 9 6 6 4 8 9 5)
  ;(println (last b)) ;-> (0 4 2 0 7 5 2 9 6 3 4 5 0)
  _res
)

(e008) ; con il valore 4 di test
;-> 5832

(e008) ; con il valore 13
;-> (5 5 7 6 6 8 9 6 6 4 8 9 5)
;-> 23514624000

(* 5 5 7 6 6 8 9 6 6 4 8 9 5)
;-> 23514624000

(time (e008))
;-> 62.476

(time (e008) 500)
;-> 27315.46

Possiamo scrivere la funzione utilizzando la tecnica "window sliding". La finestra di 13 caratteri simuove lungo la stringa il nuovo valore della moltiplicazione dei 13 caratteri è data dal valore precedente moltiplicato per l'ultimo carattere della nuova finestra e diviso per il primo carattere della finestra precedente. L'unico problema è quando tgroviamo il valore 0 come prima cifra della finestra precedente (non è possibile dividere per zero): questo caso deve essere trattato a parte.

(define (e008-2 str n)
  (local (vet prod maxp pre cur)
    ; trasformo la stringa in un vettore
    (setq vet (array (length str) (map int (explode str))))
    ; il primo prodotto è il prodotto dei primi n numeri
    (setq prod (apply * (slice vet 0 n)))
    (setq maxp prod)
    (for (i n (- (length vet) 1))
      (setq pre (vet (- i n)))
      (setq cur (vet i))
      (if (= pre 0)
          ; se la prima cifra 0, allora calcolo il prodotto esteso
          (setq prod (apply * (slice vet (+ i 1 (- n)) n)))
          ; altrimenti moltiplico e divido
          (setq prod (/ (* prod cur) pre))
      )
      (setq maxp (max prod maxp))
    )
    maxp))

(setq x
"7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450")

(e008-2 x 13)
;-> 23514624000

(time (e008-2 x 13))
;-> 0

(time (e008-2 x 13) 500)
;-> 218.696

Quest'ultima funzione è 125 volte più veloce della prima:

(div 27315.46 218.696)
;-> 124.9015071148992
----------------------------------------------------------------------------


==========
Problema 9
==========

Triple Pitagoriche speciali

Una tripla pitagorica è un insieme di tre numeri naturali, a < b < c, per cui risulta,

a^2 + b^2 = c^2

Per esempio, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.

Esiste solo una tripla pitagorica per cui risulta: a + b + c = 1000.

Trovare il prodotto a*b*c.
============================================================================

(define (e009)
    (catch
      (for (a 1 1000)
        (for (b a 1000)
            (let (c (sqrt (+ (pow a) (pow b))))
                (when (and
                      (= (add a b c) 1000)
                      (< a b c)) ; a < b < c
                    ;(println a { } b { } c)
                    (throw (* a b c))
                 )
             )
         )
      )
    )
)

(e009)
;-> 200 375 425
;-> 31875000

(time (e009))
;-> 31.208

(time (e009) 1000)
;-> 30908.208

Dal punto di vista matematico, poniamo c = n - a - b.

Poichè (a < b < c) e (a + b + c = n), possiamo concludere che:

valore massimo per a: a < (n/3) - 1
valore massimo per b: b < (n/2) - 1

Adesso partendo da (a + b) = (n - c) e (a^2 + b^2 = c^2):

      a^2 + b^2 = c^2
a^2 + b^2 + 2ab = c^2 + 2ab
      (a + b)^2 = c^2 + 2ab
      (n - c)^2 = c^2 + 2ab  ==>  2ab = (n - c)^2 - c^2

Sottraiamo 2ab dalla prima equazione (a^2 + b^2 = c^2):

      a^2 + b^2 = c^2
a^2 + b^2 - 2ab = c^2 - 2ab
(a - b)^2 = c^2 - (n - c)^2 + c^2
(a - b)^2 = c^2 - n^2 - c^2 + 2nc + c^2
(a - b)^2 = c^2 - n^2 + 2nc

Poichè (c^2 - n^2 + 2nc) deve essere un quadrato perfetto, possiamo ignorare a e b e verificare solo se è un quadrato perfetto.

Una possibile implementazione è la seguente:

(define (e009-2 n)
  (local (a b ab sq-ab res found)
    (setq found nil)
    (setq res nil)
    (for (c (floor (+ (/ n 3) 1)) (- (/ n 2) 1) 1 found)
      (setq sq-ab (- (+ (* c c) (* 2 n c)) (* n n)))
      (setq ab (floor (sqrt sq-ab)))
      (if (= (* ab ab) sq-ab)
          (setq b (/ (- n (+ c ab)) 2)
                a (- n b c)
                found true
                res (list (sort (list a b c)) (+ a b c) (* a b c)))
      )
    )
    res))

(e009-2 1000)
;-> ((200 375 425) 1000 31875000)

(time (e009-2 1000))
;-> 0

(time (e009-2 1000) 1000)
;-> 31.208

Quest'ultima funzione è 990 volte più veloce della prima:

(div 30908.208 31.208)
;-> 990.3937451935401
----------------------------------------------------------------------------


===========
Problema 10
===========

Sommatoria dei numeri primi

La somma dei numeri primi minori di 10 vale 2 + 3 + 5 + 7 = 17.

Trovare la somma di tutti i primi minori di 2 milioni.
============================================================================

(sequence 2 10)
;-> (2 3 4 5 6 7 8 9 10)

(isprime? 2)
;-> true

(filter isprime? (sequence 2 10))
;-> (2 3 5 7)

(filter isprime? (sequence 2 1000))
;-> (2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107
;->  109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223
;->  227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337
;->  347 349 353 359 367 373 379 383 389 397 401 409 419 421 431 433 439 443 449 457
;->  461 463 467 479 487 491 499 503 509 521 523 541 547 557 563 569 571 577 587 593
;->  599 601 607 613 617 619 631 641 643 647 653 659 661 673 677 683 691 701 709 719
;->  727 733 739 743 751 757 761 769 773 787 797 809 811 821 823 827 829 839 853 857
;->  859 863 877 881 883 887 907 911 919 929 937 941 947 953 967 971 977 983 991 997)

(apply add (filter isprime? (sequence 2 10)))
;-> 17

(apply add (filter isprime? (sequence 2 10000)))
;-> 5736396

(apply add (filter isprime? (sequence 2 2000000)))
;-> 142913828922

(time (apply add (filter isprime? (sequence 2 2000000))))
;-> 2265.831

(+ 2 (apply + (filter isprime? (sequence 3 2000000 2 ))))
;-> 142913828922

(time (+ 2 (apply + (filter isprime? (sequence 3 2000000 2 )))))
;-> 1893.077

Proviamo con una funzione iterativa:

(define (e010)
    (let (somma 2)
        (for (i 3 1999999 2)
            (if (= 1 (length (factor i)))
                (setq somma (+ somma i)))
        )
        somma
    )
)

(e010)
;-> 142913828922

(time (e010))
;-> 1077.866

Dal punto di vista matematico possiamo implementare una versione del crivello di eratostene ottimizzata per questo problema, inoltre calcoliamo la somma dei numeri primi fino a n come la differenza tra la somma di tutti i numeri primi fino a n e la somma di tutti i numeri composti (non-primi) fino a n:

Sum[1..n]primi(i) = Sum[1..n](i) - Sum[1..n]composti(i)

dove: Sum[1..n](i) = n*(n + 1)/2

(define (e010-2 n)
  (local (sum bound data start step)
    (setq sum 0)
    (setq bound (floor (sqrt n)))
    (setq data (array (+ n 1) '(0)))
    (setf (data 1) 1)
    (setf (data 0) 1)
    (for (i 2 bound)
      (if (zero? (data i))
          (for (j (+ i i) n i)
            (if (zero? (data j))
              (begin
              (setf (data j) 1)
              (++ sum j))
            )
          )
       )
    )
    (- (/ (* n (+ n 1)) 2) sum 1)))

(e010-2 1999999)
;-> 142913828922

(time (e010-2 1999999))
;-> 546.907
----------------------------------------------------------------------------


===========
Problema 11
===========

Il più grande prodotto in una griglia

Nella griglia 20 × 20 seguente, quattro numeri lungo una linea diagonale sono stati racchiusi con i caratteri > < (es. >26<).

08  02  22  97  38  15  00  40  00  75  04  05  07  78  52  12  50  77  91  08
49  49  99  40  17  81  18  57  60  87  17  40  98  43  69  48  04  56  62  00
81  49  31  73  55  79  14  29  93  71  40  67  53  88  30  03  49  13  36  65
52  70  95  23  04  60  11  42  69  24  68  56  01  32  56  71  37  02  36  91
22  31  16  71  51  67  63  89  41  92  36  54  22  40  40  28  66  33  13  80
24  47  32  60  99  03  45  02  44  75  33  53  78  36  84  20  35  17  12  50
32  98  81  28  64  23  67  10 >26< 38  40  67  59  54  70  66  18  38  64  70
67  26  20  68  02  62  12  20  95 >63< 94  39  63  08  40  91  66  49  94  21
24  55  58  05  66  73  99  26  97  17 >78< 78  96  83  14  88  34  89  63  72
21  36  23  09  75  00  76  44  20  45  35 >14< 00  61  33  97  34  31  33  95
78  17  53  28  22  75  31  67  15  94  03  80  04  62  16  14  09  53  56  92
16  39  05  42  96  35  31  47  55  58  88  24  00  17  54  24  36  29  85  57
86  56  00  48  35  71  89  07  05  44  44  37  44  60  21  58  51  54  17  58
19  80  81  68  05  94  47  69  28  73  92  13  86  52  17  77  04  89  55  40
04  52  08  83  97  35  99  16  07  97  57  32  16  26  26  79  33  27  98  66
88  36  68  87  57  62  20  72  03  46  33  67  46  55  12  32  63  93  53  69
04  42  16  73  38  25  39  11  24  94  72  18  08  46  29  32  40  62  76  36
20  69  36  41  72  30  23  88  34  62  99  69  82  67  59  85  74  04  36  16
20  73  35  29  78  31  90  01  74  31  49  71  48  86  81  16  23  57  05  54
01  70  54  71  83  51  54  69  16  92  33  48  61  43  52  01  89  19  67  48

Il prodotto di questi numeri vale 26 × 63 × 78 × 14 = 1788696.

Qual'è il valore più grande del prodotto di quattro numeri adiacenti nella stessa direzione (su, giù, sinistra, destra o diagonalmente) nella griglia 20 × 20?
============================================================================

(setq grid
'( 8  2 22 97 38 15  0 40  0 75  4  5  7 78 52 12 50 77 91  8
  49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48  4 56 62  0
  81 49 31 73 55 79 14 29 93 71 40 67 53 88 30  3 49 13 36 65
  52 70 95 23  4 60 11 42 69 24 68 56  1 32 56 71 37  2 36 91
  22 31 16 71 51 67 63 89 41 92 36 54 22 4  40 28 66 33 13 80
  24 47 32 60 99  3 45  2 44 75 33 53 78 36 84 20 35 17 12 50
  32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70
  67 26 20 68  2 62 12 20 95 63 94 39 63  8 40 91 66 49 94 21
  24 55 58  5 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72
  21 36 23  9 75  0 76 44 20 45 35 14  0 61 33 97 34 31 33 95
  78 17 53 28 22 75 31 67 15 94  3 80  4 62 16 14  9 53 56 92
  16 39  5 42 96 35 31 47 55 58 88 24  0 17 54 24 36 29 85 57
  86 56  0 48 35 71 89  7  5 44 44 37 44 60 21 58 51 54 17 58
  19 80 81 68  5 94 47 69 28 73 92 13 86 52 17 77  4 89 55 40
   4 52  8 83 97 35 99 16  7 97 57 32 16 26 26 79 33 27 98 66
  88 36 68 87 57 62 20 72  3 46 33 67 46 55 12 32 63 93 53 69
   4 42 16 73 38 25 39 11 24 94 72 18  8 46 29 32 40 62 76 36
  20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74  4 36 16
  20 73 35 29 78 31 90  1 74 31 49 71 48 86 81 16 23 57  5 54
   1 70 54 71 83 51 54 69 16 92 33 48 61 43 52  1 89 19 67 48))

(length grid)
;-> 400

(define (right i)
  (setq r (slice grid i 4))
  (apply * r))

(define (down i)
  (setq d (select grid i (+ i 20) (+ i 40) (+ i 60)))
  (apply * d))

(define (diag-down-right i)
  (setq dr (select grid i (+ i 21) (+ i 42) (+ i 63)))
  (apply * dr))

(define (diag-down-left i)
  (setq dl (select grid i (+ i 19) (+ i 38) (+ i 57)))
  (apply * dl))

(define (e011)
  (setq down-max (apply max (map (fn (x) (down x)) (sequence 0 339))))
  (setq diag-down-left-max (apply max (map (fn (x) (diag-down-left x)) (sequence 3 339))))
  (setq diag-down-right-max (apply max (map (fn (x) (diag-down-right x)) (sequence 0 333))))
  (max down-max diag-down-left-max diag-down-left-max)
)

(e011)
;-> 70600674

(time (e011))
;-> 0

(time (e011) 1000)
;-> 501.021

Per migliorare la velocità proviamo ad utilizzare un vettore al posto di una lista, cicli "for" al posto di "map" e moltiplicazioni dirette al posto di "apply":

(setq arr (array 20 20 grid))
;-> ((8 2 22 97 38 15 0 40 0 75 4 5 7 78 52 12 50 77 91 8)
;->  (49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 4 56 62 0)
;->  (81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 3 49 13 36 65)
;->  (52 70 95 23 4 60 11 42 69 24 68 56 1 32 56 71 37 2 36 91)
;->  (22 31 16 71 51 67 63 89 41 92 36 54 22 4 40 28 66 33 13 80)
;->  (24 47 32 60 99 3 45 2 44 75 33 53 78 36 84 20 35 17 12 50)
;->  (32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70)
;->  (67 26 20 68 2 62 12 20 95 63 94 39 63 8 40 91 66 49 94 21)
;->  (24 55 58 5 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72)
;->  (21 36 23 9 75 0 76 44 20 45 35 14 0 61 33 97 34 31 33 95)
;->  (78 17 53 28 22 75 31 67 15 94 3 80 4 62 16 14 9 53 56 92)
;->  (16 39 5 42 96 35 31 47 55 58 88 24 0 17 54 24 36 29 85 57)
;->  (86 56 0 48 35 71 89 7 5 44 44 37 44 60 21 58 51 54 17 58)
;->  (19 80 81 68 5 94 47 69 28 73 92 13 86 52 17 77 4 89 55 40)
;->  (4 52 8 83 97 35 99 16 7 97 57 32 16 26 26 79 33 27 98 66)
;->  (88 36 68 87 57 62 20 72 3 46 33 67 46 55 12 32 63 93 53 69)
;->  (4 42 16 73 38 25 39 11 24 94 72 18 8 46 29 32 40 62 76 36)
;->  (20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 4 36 16)
;->  (20 73 35 29 78 31 90 1 74 31 49 71 48 86 81 16 23 57 5 54)
;->  (1 70 54 71 83 51 54 69 16 92 33 48 61 43 52 1 89 19 67 48))

(define (get-el y x)
  (if (and (>= y 0) (< y 20) (>= x 0) (< x 20))
      (arr y x)
      0))

(get-el 2 2)
;-> 31

(define (e011-2)
  (local (dx dy val max-val)
    (setq max-val 0)
    (setq dx '(1 0 1 -1))
    (setq dy '(0 1 1  1))
    (for (y 0 19)
      (for (x 0 19)
        (for (d 0 3)
          (setq val 1)
          (for (i 0 3)
            (setq val (* val (get-el (+ y (* i (dy d))) (+ x (* i (dx d))))))
          )
          (setq max-val (max val max-val))
        )
      )
    )
    max-val))

(e011-2)
;-> 70600674

(time (e011-2))
;-> 2.992

(time (e011-2) 1000)
;-> 2496.241

Questa volta la velocità è peggiorata (probabilmente la funzione "get-el" è la responsabile).
----------------------------------------------------------------------------


===========
Problema 12
===========

Numero triangolare altamente divisibile

La sequenza di numeri triangolari viene generata aggiungendo i numeri naturali. Quindi il settimo numero di triangolo sarebbe 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. I primi dieci termini sarebbero:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Cerchiamo di elencare i fattori dei primi sette numeri triangolare:

  1: 1
  3: 1,3
  6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28

Possiamo vedere che 28 è il primo numero triangolare ad avere più di cinque divisori.

Qual'è il valore del primo numero triangolare che ha oltre cinquecento divisori?
============================================================================

Funzione che calcola l'n-esimo numero triangolare:

(define (numtri n) (/ (+ (* n n) n) 2))
;-> (numtri 1)
;-> 1
;-> (numtri 2)
;-> 3
;-> (numtri 3)
;-> 6
;-> (numtri 4)
;-> 10

Funzione cha calcola il numero di divisori di un numero n:

(define (numdivisors n)
  (local (ndiv)
    (setq ndiv 0)
    (for (i 1 (+ n 1))
      (if (zero? (% n i)) (++ ndiv))
    )
    ndiv
  )
)

(numdivisors 10) ;(1 2 5 10)
;-> 4

(numdivisors 64) ;(1 2 4 8 16 32 64)
;-> 7

(numdivisors 76576500)
;-> 576

(define (e012)
  (let (look true)
    (for (i 1 99999 2 (not look))
      (if (> (* (numdivisors i) (numdivisors (div (numtri i) i))) 500)
        (begin
          (println "i = " i {; }
                   "tri = " (numtri i) {; }
                   "divisori = " (* (numdivisors i) (numdivisors (div (numtri i) i))))
          (setq look false)
        )
      )
    )
  )
)

(e012)
;-> i = 12375; tri = 76576500; divisori = 576
;-> true

(time (e012))
;-> 5444.521

Dal punto di vista matematico, il numero di divisori di un numero naturale n è dato da tau(n) o τ(n) o talvolta  delta(n) o δ(n). Ogni numero naturale può essere espresso come il prodotto dei loro fattori primi k in questo modo:

n = Prod[1..k] p(i)^e(i)
​
Quindi il numero di divisori è dato da:

tau(n) = Prod[1..k] e(i) + 1

Quindi abbiamo bisogno della scomposizione in fattori primi e del prodotto dei suoi esponenti.

Prima scriviamo la funzione che calcola tau(n):

(define (tau num)
  (local (n i p c)
    (setq n num i 2 p 1)
    (cond ((= num 1) (setq p 1))
          (true
            (while (<= (* i i) n)
              (setq c 1)
              (while (zero? (% n i))
                (setq n (/ n i))
                (++ c)
              )
              (++ i)
              (setq p (* p c))
            )
            (if (or (= n num) (> n 1)) (setq p (* p 2)))
          )
     )
     p))

(tau 20)
;-> 6

Vediamo se la funzione "tau" e "numdivisors" danno gli stessi risultati:
(for (i 1 10000)
  (if (!= (numdivisors i) (tau i)) (println i { } (numdivisors i) { } (tau i))))
  ;-> nil

Inoltre occorre la seguente funzione che calcola i numeri triangolari fino ad un certo valore num:

(define (tri num)
  (setq n 1)
  (setq d 1)
  (println d)
  (while (< d num)
    (++ n)
    (++ d n)
    (println d)
  )
  d)

(tri 21)
;-> 1
;-> 3
;-> 6
;-> 10
;-> 15
;-> 21

La funzione finale è la seguente:

(define (e012-2 x)
  (let ((n 1) (d 1))
    (while (<= (tau d) x)
      (++ n)
      (++ d n)
    )
    d))

(e012-2 500)
;-> 76576500

(time (e012-2))
;-> 0
----------------------------------------------------------------------------


===========
Problema 13
===========

Grande somma

Calcolare le prime dieci cifre della somma dei seguenti cento numeri di 50 cifre ognuno.
============================================================================

Suddividiamo la lista da 100 numeri in due liste da 50 numeri per evitare il limite dei 2048 caratteri che newLISP pone alla lunghezza di una espressione.

(setq numeriA '(
 37107287533902102798797998220837590246510135740250L
 46376937677490009712648124896970078050417018260538L
 74324986199524741059474233309513058123726617309629L
 91942213363574161572522430563301811072406154908250L
 23067588207539346171171980310421047513778063246676L
 89261670696623633820136378418383684178734361726757L
 28112879812849979408065481931592621691275889832738L
 44274228917432520321923589422876796487670272189318L
 47451445736001306439091167216856844588711603153276L
 70386486105843025439939619828917593665686757934951L
 62176457141856560629502157223196586755079324193331L
 64906352462741904929101432445813822663347944758178L
 92575867718337217661963751590579239728245598838407L
 58203565325359399008402633568948830189458628227828L
 80181199384826282014278194139940567587151170094390L
 35398664372827112653829987240784473053190104293586L
 86515506006295864861532075273371959191420517255829L
 71693888707715466499115593487603532921714970056938L
 54370070576826684624621495650076471787294438377604L
 53282654108756828443191190634694037855217779295145L
 36123272525000296071075082563815656710885258350721L
 45876576172410976447339110607218265236877223636045L
 17423706905851860660448207621209813287860733969412L
 81142660418086830619328460811191061556940512689692L
 51934325451728388641918047049293215058642563049483L
 62467221648435076201727918039944693004732956340691L
 15732444386908125794514089057706229429197107928209L
 55037687525678773091862540744969844508330393682126L
 18336384825330154686196124348767681297534375946515L
 80386287592878490201521685554828717201219257766954L
 78182833757993103614740356856449095527097864797581L
 16726320100436897842553539920931837441497806860984L
 48403098129077791799088218795327364475675590848030L
 87086987551392711854517078544161852424320693150332L
 59959406895756536782107074926966537676326235447210L
 69793950679652694742597709739166693763042633987085L
 41052684708299085211399427365734116182760315001271L
 65378607361501080857009149939512557028198746004375L
 35829035317434717326932123578154982629742552737307L
 94953759765105305946966067683156574377167401875275L
 88902802571733229619176668713819931811048770190271L
 25267680276078003013678680992525463401061632866526L
 36270218540497705585629946580636237993140746255962L
 24074486908231174977792365466257246923322810917141L
 91430288197103288597806669760892938638285025333403L
 34413065578016127815921815005561868836468420090470L
 23053081172816430487623791969842487255036638784583L
 11487696932154902810424020138335124462181441773470L
 63783299490636259666498587618221225225512486764533L
 67720186971698544312419572409913959008952310058822L ))

(setq numeriB '(
 95548255300263520781532296796249481641953868218774L
 76085327132285723110424803456124867697064507995236L
 37774242535411291684276865538926205024910326572967L
 23701913275725675285653248258265463092207058596522L
 29798860272258331913126375147341994889534765745501L
 18495701454879288984856827726077713721403798879715L
 38298203783031473527721580348144513491373226651381L
 34829543829199918180278916522431027392251122869539L
 40957953066405232632538044100059654939159879593635L
 29746152185502371307642255121183693803580388584903L
 41698116222072977186158236678424689157993532961922L
 62467957194401269043877107275048102390895523597457L
 23189706772547915061505504953922979530901129967519L
 86188088225875314529584099251203829009407770775672L
 11306739708304724483816533873502340845647058077308L
 82959174767140363198008187129011875491310547126581L
 97623331044818386269515456334926366572897563400500L
 42846280183517070527831839425882145521227251250327L
 55121603546981200581762165212827652751691296897789L
 32238195734329339946437501907836945765883352399886L
 75506164965184775180738168837861091527357929701337L
 62177842752192623401942399639168044983993173312731L
 32924185707147349566916674687634660915035914677504L
 99518671430235219628894890102423325116913619626622L
 73267460800591547471830798392868535206946944540724L
 76841822524674417161514036427982273348055556214818L
 97142617910342598647204516893989422179826088076852L
 87783646182799346313767754307809363333018982642090L
 10848802521674670883215120185883543223812876952786L
 71329612474782464538636993009049310363619763878039L
 62184073572399794223406235393808339651327408011116L
 66627891981488087797941876876144230030984490851411L
 60661826293682836764744779239180335110989069790714L
 85786944089552990653640447425576083659976645795096L
 66024396409905389607120198219976047599490197230297L
 64913982680032973156037120041377903785566085089252L
 16730939319872750275468906903707539413042652315011L
 94809377245048795150954100921645863754710598436791L
 78639167021187492431995700641917969777599028300699L
 15368713711936614952811305876380278410754449733078L
 40789923115535562561142322423255033685442488917353L
 44889911501440648020369068063960672322193204149535L
 41503128880339536053299340368006977710650566631954L
 81234880673210146739058568557934581403627822703280L
 82616570773948327592232845941706525094512325230608L
 22918802058777319719839450180888072429661980811197L
 77158542502016545090413245809786882778948721859617L
 72107838435069186155435662884062257473692284509516L
 20849603980134001723930671666823555245252804609722L
 53503534226472524250874054075591789781264330331690L ))

(length numeriA)
;-> 50
(length numeriB)
;-> 50

(apply + numeriA)
;-> 2739840008414248713350123647779193919724097856798098L

(apply + numeriB)
;-> 2797536221976627923951925099053792052049561975094574L

(+ (apply + numeriA) (apply + numeriB))

(define (e013)
  (slice (string (+ (apply + numeriA) (apply + numeriB))) 0 10))

(e013)
;-> "5537376230"

Il numero  completo vale:
5537376230390876637302048746832985971773659831892672L

(time (e013))
;-> 0
----------------------------------------------------------------------------


===========
Problema 14
===========

La sequenza di Collatz più lunga

La seguente sequenza iterativa è definita per l'insieme di numeri interi positivi:

n = 1 -> stop
n -> n / 2 (n è pari)
n -> 3 * n + 1 (n è dispari)

Usando la regola sopra e iniziando con 13, generiamo la seguente sequenza:
13 40 20 10 5 16 8 4 2 1
Si può vedere che questa sequenza (che inizia a 13 e finisce a 1) contiene 10 termini.
Anche se non è stato ancora dimostrato (Collatz Problem), si ritiene che tutti i numeri iniziali conducano al numero 1.

Quale numero iniziale, inferiore a un milione, produce la catena più lunga?

NOTA: una volta avviata la sequenza, i termini possono superare il milione.
============================================================================

Scriviamo una funzione che costruisce la sequenza di Collatz per un numero n:

(define (collatz n)
  (if (= n 1) '(1)
    (cons n (collatz (if (even? n) (/ n 2) (+ 1 (* 3 n)))))))

Poi scriviamo una funzione che calcola la lunghezza della sequenza di Collatz di un numero n:

(define (collatz-lenght n)
  (length (collatz n))
)

(collatz 24)
;-> (24 12 6 3 10 5 16 8 4 2 1)

(collatz-lenght 24)
;-> 11

Utilizzando le due funzioni direttamente (senza alcun tipo di ottimizzazione) possiamo scrivere la seguente soluzione:

(define (e014)
  (local (maxlun out num)
    (setq maxlun 0)
    (setq out '())
    (setq num 0)
    (for (i 1 1000000)
      (if (> (length (collatz i)) maxlun)
          (begin
            (setq maxlun (length (collatz i)))
            (setq num i)
          )
      )
    )
    (list num maxlun)
  )
)

Questa funzione è molto lenta...

(e014)
;-> (837799 525)

(time (e014))
;-> 107039.434 ; 107 secondi

Proviamo a scrivere una funzione unica che calcola la lunghezza di collatz senza costruire la lista:

(define (e014)
  (local (maxlun lun num c)
    (setq maxlun 0)
    (setq num 0)
    (for (i 1 1000000)
      (setq c i)
      (setq lun 1)
      ; calcolo della lunghezza della sequenza
      (while (!= c 1)
         (if (even? c) (setq c (/ c 2))
                       (setq c (+ 1 (* 3 c)))
         )
         (++ lun)
      )
      (if (> lun maxlun) ; se la sequenza è più lunga di quella massima,
          (begin         ; allora aggiorno il valore massimo e il relativo numero di collatz
            (setq maxlun lun)
            (setq num i)
          )
      )
    )
    (list num maxlun)
  )
)

(e014)
;-> (837799 525)

(time (e014))
;-> 15376.695 ; 15.4 secondi

Possiamo riscrivere la funzione in modo diverso:

(define (len-collatz n)
  (let (c 1)
    (while (> n 1)
      (if (even? n)
          (setq n (/ n 2))
          (setq n (+ (* 3 n) 1))
      )
      (++ c)
    )
    c))

(len-collatz 24)
;-> 11

(define (e014 n)
  (local (max-len max-num)
    (setq max-len 0 max-num 0)
    (for (i 1 n)
      (setq c (len-collatz i))
      (if (> c max-len)
          (setq max-len c max-num i)
      )
    )
    (list max-num max-len)))

(e014 999999)
;-> (837799 525)

(time (e014 999999))
;-> 15157.284

Non abbiamo migliorato la velocità...

Allora proviamo ad utilizzare una hash-map per contenere i valori delle lunghezze di Collatz di ogni numero:

; crea hash
(new Tree 'hash)

; assegna hash (hash chiave valore)
(hash 4 2)
;-> 2

; recupero valore con chiave
(hash 4)
;-> 2

; valore nil se non esiste la chiave
(hash 3)
;-> nil

; elimina hash
(delete 'hash)

Scriviamo la funzione:

(define (e014-2 n)
  (local (maxlun lun num c found)
    ;(delete 'hash)
    (new Tree 'hash)
    (setq maxlun 0)
    (setq num 0)
    (for (i 1 n)
      (if (= (length (hash)) n) (println i { } n))
      (setq c i)
      (setq lun 1)
      ; calcolo della lunghezza della sequenza
      (setq found nil)
      (while (and (!= c 1) (not found))
        ; se non trovo il valore della lunghezza nella hashmap
        (if (nil? (hash (string c)))
            ; calcolo la lunghezza normalmente
            (begin
            (if (even? c)
                (setq c (/ c 2))

                (setq c (+ 1 (* 3 c)))
            )
            (++ lun))
            ;else
            ; altrimenti la recupero dalla hashmap
            (begin
            (setq found true)
            (setq lun (+ lun (hash (string c)) (- 1))))
        )
      )
      ; inserisco nella hashmap il valore della lunghezza trovata
      (hash i lun)
      (if (> lun maxlun) ; se la sequenza è più lunga di quella massima,
          (begin         ; allora aggiorno il valore massimo e il relativo numero di collatz
            (setq maxlun lun)
            (setq num i)
          )
      )
    )
    (list num maxlun (length (hash)))
  )
)

(e014-2 999999)
;-> (837799 525)

Per calcolare la velocità della funzione occorre eliminare l'hashmap perchè contiene tutti i valori delle lunghezze fino al numero 999999:

(delete 'hash)

(time (e014-2 999999))
;-> 7563.103

Se non eliminiamo l'hashmap:

(time (e014-2 999999))
;-> 2015.606
----------------------------------------------------------------------------


===========
Problema 15
===========

Percorsi in una griglia

Partendo dall'angolo in alto a sinistra di una griglia 2 × 2, e potendo solo spostarsi verso destra e verso il basso, ci sono esattamente 6 percorsi diversi per raggiungere l'angolo in basso a destra.

Quanti percorsi ci sono attraverso una griglia 20 × 20?
==============

Quello che ci interessa è la distanza tra le coordinate di inizio e fine, cioè la dimensione della griglia: 20.

Possiamo scrivere una funzione ricorsiva che utilizza questo valore di distanza per calcolare il numero totale dei percorsi (minimi) tra i due punti.
Poichè ogni volta ci dobbiamo muovere a destra o verso il basso possiamo richiamare la stesse funzioni con uno dei parametri (destra o basso) diminuito di 1. Queste funzioni vengono richiamate tante volte quanto vale la distanza tra le coordinate. Facendo la somma dei risultati di queste funzioni otteniamo il numero di percorsi (minimi) tra le coordinate di inizio e fine della griglia.

La funzione ricorsiva per il calcolo dei percorsi è la seguente:

(define (numPercorsi basso destra);
    (if (or (= basso 0) (= destra 0)) 1
        (+ (numPercorsi (- basso 1) destra)
           (numPercorsi basso (- destra 1)))
    )
)

(numPercorsi 2 2)
;-> 6

(numPercorsi 10 10)
;-> 184756

(time (numPercorsi 20 20))

Purtroppo questa funzione è molto lenta (O(2^n)) quindi dobbiamo utilizzare un'altro metodo. Dal punto di vista matematico, il numero di percorsi in una griglia dal punto (0,0) al punto (n,m) è uguale al coefficiente binomiale:

(n + m)      (n + m)!
        = -------------
(  n  )      n! * m!
                          (2*n)    (2*n)!    (40)      40!
Nel nostro caso diventa:        = -------- =      = ---------
                          ( n )    (n!)^2    (20)    (20!)^2

Definiamo la funzione fattoriale:

(define (fact n) (apply * (map bigint (sequence 1 n))))

Calcoliamo il numero di percorsi:

(define (e015 n)
  (/ (fact (+ n n)) (* (fact n) (fact n)))
)

(e015 20)
;-> 137846528820L

(time (e015 20))
;-> 0

(time (e015 20) 10000)
;-> 180.548

Dal punto di vista non-matematico, notiamo che:

(for (i 1 10) (print (e015 i) { }))
;-> 2L 6L 20L 70L 252L 924L 3432L 12870L 48620L 184756L

Guardando su oesis.org si trova che questa sequenza è la A000984 (Central binomial coefficients).
Questa sequenza può essere calcolata nel modo seguente:

(define (e015-2 n)
  (let (c 1)
    (for (i 1 n)
      (setq c (/ (* c (+ n i)) i)))))

(e015-2 20)
;-> 137846528820

(time (e015-2 20))
;-> 0

(time (e015-2 20) 10000)
;-> 18.95

Questa funzione è 10 volte più veloce della precedente.
----------------------------------------------------------------------------


===========
Problema 16
===========

Somma cifre di una potenza

2^15 = 32768 e la somma delle sue cifre vale 3 + 2 + 7 + 6 + 8 = 26.

Quanto vale la somma delle cifre del numero 2^1000?
============================================================================

(Definiamo una funzione che calcola la potenza di un numero intero (big integer):

(define (potenza n m)
  (setq pot 1L)
  (dotimes (x m)
    (setq pot (* pot n))
  )
)

(potenza 3 50)
;-> 717897987691852588770249L

(define (e016)
  (setq num (potenza 2 1000))
  (setq n$ (string num))
  (setq n$ (slice n$ 0 (- (length n$) 1)))
  (apply + (map int (explode n$)))
)

(e016)
;-> 1366

(time (e016))
;-> 0

Dal punto di vista matematico possiamo utilizzare la formula per la lunghezza di un numero intero n:

L(n) = floor(1 + log10(n))

Quindi il numero 2^1000 è lungo:

d = 1 + floor(log10(2^1000)) = 1 + floor(1000*log10(2))

(add 1 (floor (mul 1000 (log 2 10))))
;-> 302

Quindi possiamo moltiplicare il numero 2 per 1000 volte utilizzando il normale algoritmo per la moltiplicazione e memorizzare il risultato in un vettore di 320 elementi. Potremmo usare una lista per memorizzare il risultato, ma un vettore è più veloce.

(define (e016-2 esp)
  (local (product carry order digits number)
    (setq order 0)
    (setq digits (add 1 (floor (mul 1000 (log 2 10)))))
    (setq number (array digits '(1)))
    (setf (number 0) 1)
    (for (i 0 (- esp 1))
      (setq carry 0)
      (for (j 0 order)
        (setq product (+ (* 2 (number j)) carry))
        (setf (number j) (% product 10))
        (setq carry (/ product 10))
        (if (and (= j order) (> carry 0))
          (++ order)
        )
      )
    )
    (apply + (array-list number))))

(e016-2 1000)
;-> 1366

(time (e016-2 1000))
;-> 31.947
----------------------------------------------------------------------------


===========
Problema 17
===========

Contare il numero di lettere

Se i numeri da 1 a 5 sono scritti con le parole inglesi:
one, two, three, four, five allora sono state usate
 3  +  3  +  5  +  4  +  4 = 19 lettere in totale.

Se tutti i numeri da 1 a 1000 (one thousand) incluso fossero scritti con le parole inglesi, quante lettere occorrerebbe usare?

NOTA: non contare spazi o trattini. Ad esempio, 342 (three hundred and forty-two) contiene 23 lettere e 115 (one hundred and fifteen) contiene 20 lettere. L'uso di "and" quando si scrivono numeri è conforme all'uso britannico.
============================================================================

La soluzione è tediosa.

(setq n1-19 '("" "one" "two" "three" "four" "five" "six" "seven" "eight" "nine" "ten" "eleven" "twelve" "thirteen" "fourteen" "fifteen" "sixteen" "seventeen" "eighteen" "nineteen"))

(setq n20-90 '("" "" "twenty" "thirty" "forty" "fifty" "sixty" "seventy" "eighty" "ninety"))

(setq n100 "hundred")

; gli spazi non contano
(setq n100and "hundredand")

(setq n1000 "onethousand")

(define (e017)
  (local (n1-9 n10-19 n20-99 n100-999)
    (setq n1-9 (apply + (map length (1 9 n1-19))))
    (setq n10-19 (apply + (map length (10 19 n1-19))))
    (setq n20-99 (+ (* 10 (apply + (map length (2 9 n20-90))))
                    (* 8 n1-9)))
    (setq n100-999 (+ (* 100 (+ n1-9))
                      (* 9 (+ n1-9 n10-19 n20-99))
                            (* 9 (length n100))
                            (* 9 99 (length n100and))))
    (+ n1-9 n10-19 n20-99 n100-999 (length n1000))
  )
)

(e017)
;-> 21124

(time (e017))
;-> 0
----------------------------------------------------------------------------


===========
Problema 18
===========

Percorso con somma massima

Iniziando dalla parte superiore del triangolo in basso e passando ai numeri adiacenti sulla riga sottostante, il totale massimo dall'alto verso il basso è 23.

   3
  7 4
 2 4 6
8 5 9 3

Cioè, 3 + 7 + 4 + 9 = 23.

Trova il totale massimo dall'alto al basso del triangolo sottostante:

                            75
                          95 64
                        17 47 82
                      18 35 87 10
                    20 04 82 47 65
                  19 01 23 75 03 34
                88 02 77 73 07 63 67
              99 65 04 28 06 16 70 92
            41 41 26 56 83 40 80 70 33
          41 48 72 33 47 32 37 16 94 29
        53 71 44 65 25 43 91 52 97 51 14
      70 11 33 28 77 73 17 78 39 68 17 57
    91 71 52 38 17 14 91 43 58 50 27 29 48
  63 66 04 68 89 53 67 30 73 16 69 87 40 31
04 62 98 27 23 09 70 98 73 93 38 53 60 04 23

NOTA: poiché ci sono solo 16384 percorsi, è possibile risolvere questo problema provando ogni percorso.
============================================================================

La seguente soluzione è veramente "brutale".

(define (e018)
  (local (a aa b bb c cc d dd e ee f ff g gg h hh i ii j jj k kk l ll m mm n nn o oo somma sommaMax)
    (setq triangle '((75) (95 64) (17 47 82) (18 35 87 10) (20 4 82 47 65) (19 1 23 75 3 34) (88 2 77 73 7 63 67) (99 65 4 28 6 16 70 92) (41 41 26 56 83 40 80 70 33) (41 48 72 33 47 32 37 16 94 29) (53 71 44 65 25 43 91 52 97 51 14) (70 11 33 28 77 73 17 78 39 68 17 57) (91 71 52 38 17 14 91 43 58 50 27 29 48) (63 66 4 68 89 53 67 30 73 16 69 87 40 31) (4 62 98 27 23 9 70 98 73 93 38 53 60 4 23)))
    (setq a (triangle 0))
    (setq b (triangle 1))
    (setq c (triangle 2))
    (setq d (triangle 3))
    (setq e (triangle 4))
    (setq f (triangle 5))
    (setq g (triangle 6))
    (setq h (triangle 7))
    (setq i (triangle 8))
    (setq j (triangle 9))
    (setq k (triangle 10))
    (setq l (triangle 11))
    (setq m (triangle 12))
    (setq n (triangle 13))
    (setq o (triangle 14))
    (setq sommaMax 0)
    (setq somma 0)
    (for (bb 0 (- (length b) 1))
     (for (cc bb (+ bb 1))
       (for (dd cc (+ cc 1))
        (for (ee dd (+ dd 1))
         (for (ff ee (+ ee 1))
          (for (gg ff (+ ff 1))
           (for (hh gg (+ gg 1))
            (for (ii hh (+ hh 1))
             (for (jj ii (+ ii 1))
              (for (kk jj (+ jj 1))
               (for (ll kk (+ kk 1))
                (for (mm ll (+ ll 1))
                 (for (nn mm (+ mm 1))
                  (for (oo nn (+ nn 1))
                   (setq somma (+ (a 0) (b bb) (c cc) (d dd) (e ee) (f ff) (g gg) (h hh)
                                  (i ii) (j jj) (k kk) (l ll) (m mm) (n nn) (o oo)))
                   (if (> somma sommaMax) (swap somma sommaMax))
    ))))))))))))))
    sommaMax
  );local
)

(e018)
;-> 1074

(time (e018))
;-> 31.248

Una soluzione generica può essere ottenuta con la programmazione dinamica. In pratica per trovare la soluzione, ogni riga deve essere aggiunta a qualsiasi riga successiva, dal basso verso l'alto. Poiché ogni cella ha due predecessori, prendiamo il valore massimo delle due. Con questo metodo, la soluzione si trova nella cella superiore del triangolo:

var triangle = [
  [75],
  [95, 64],
  [17, 47, 82],
  [18, 35, 87, 10],
  [20, 04, 82, 47, 65],
  [19, 01, 23, 75, 03, 34],
  [88, 02, 77, 73, 07, 63, 67],
  [99, 65, 04, 28, 06, 16, 70, 92],
  [41, 41, 26, 56, 83, 40, 80, 70, 33],
  [41, 48, 72, 33, 47, 32, 37, 16, 94, 29],
  [53, 71, 44, 65, 25, 43, 91, 52, 97, 51, 14],
  [70, 11, 33, 28, 77, 73, 17, 78, 39, 68, 17, 57],
  [91, 71, 52, 38, 17, 14, 91, 43, 58, 50, 27, 29, 48],
  [63, 66, 04, 68, 89, 53, 67, 30, 73, 16, 69, 87, 40, 31],
  [04, 62, 98, 27, 23, 09, 70, 98, 73, 93, 38, 53, 60, 04, 23],
];

(define (e018-2)
  (let (tri '(
             (75)
             (95 64)
             (17 47 82)
             (18 35 87 10)
             (20 4 82 47 65)
             (19 1 23 75 3 34)
             (88 2 77 73 7 63 67)
             (99 65 4 28 6 16 70 92)
             (41 41 26 56 83 40 80 70 33)
             (41 48 72 33 47 32 37 16 94 29)
             (53 71 44 65 25 43 91 52 97 51 14)
             (70 11 33 28 77 73 17 78 39 68 17 57)
             (91 71 52 38 17 14 91 43 58 50 27 29 48)
             (63 66 4 68 89 53 67 30 73 16 69 87 40 31)
             (4 62 98 27 23 9 70 98 73 93 38 53 60 4 23)))
  (for (i (- (length tri) 2) 0 -1)
    (for (j 0 i)
      (setf (tri i j) (+ (tri i j) (max (tri (+ i 1) j) (tri (+ i 1) (+ j 1)))))
    )
  )
  (tri 0 0)))

(e018-2)
;-> 1074

(time (e018) 100)
;-> 655.032

(time (e018-2) 100)
;-> 3.021

La seconda funzione è 200 volte più veloce.
----------------------------------------------------------------------------


===========
Problema 19
===========

Conteggio delle domeniche

Ti vengono fornite le seguenti informazioni, ma potresti ricercare altre informazioni per te stesso.

- Il 1 gennaio 1900 era un lunedì.
- Trenta dì conta Novembre
  con April, Giugno e Settembre.
  Di ventotto ce n'è uno,
  Tutti gli altri ne han trentuno.

Un anno bisestile si verifica quando è divisibile per 4, ma non per un secolo (00) a meno che non sia divisibile per 400.

Quante domeniche caddero il primo del mese durante il ventesimo secolo (dal 1° gennaio 1901 al 31 dicembre 2000)?
============================================================================

Usiamo l'algoritmo di Gauss per determinare il giorno della settimana:

(define (day-of-week year month day) ; 0..6 --> Sun..Sat
    (letn ( d day
            m (+ (% (- month 3) 12) 1)
            Y (if (> m 10) (- year 1) year)
            y (% Y 100)
            c (/ (- Y y) 100)
            w (add d (floor (sub (mul 2.6 m) 0.2)) y (floor (div y 4)) (floor (div c 4)) (- (mul c 2)))
            w (% w 7)
          )
       (if (< w 0) (inc w 7) w))
)

Adesso la soluzione è abbastanza semplice:

(define (e019)
  (local (somma)
    (setq somma 0)
    (for (anno 1901 1999)
      (for (mese 1 12)
        (if (zero? (day-of-week anno mese 1)) (++ somma))
      )
    )
    somma
  )
)

(e019)
;-> 171

(time (e019))
;-> 2.997

Adesso utilizziamo l'algoritmo di Zeller per calcolare il giorno della settimana di una certa data:

(define (dayZ year month day)
  (local (adjust mm yy d)
    (setq adjust (/ (- 14 month) 12))
    (setq mm (+ month (* 12 adjust) (- 2)))
    (setq yy (- year adjust))
    (setq d (% (+ day (/ (- (* 13 mm) 1) 5) yy (/ yy 4) (- (/ yy 100)) (/ yy 400)) 7))
  )
)

(define (e019-2)
  (local (somma)
    (setq somma 0)
    (for (anno 1901 2000)
      (for (mese 1 12)
        (if (zero? (dayZ anno mese 1)) (++ somma))
      )
    )
    somma
  )
)

(e019-2)
;-> 171

(time (e019-2))
;-> 1.021

(time (e019) 1000)
;-> 854.296

(time (e019-2) 1000)
;-> 816.062
----------------------------------------------------------------------------


===========
Problema 20
===========

Somma di cifre fattoriali

n! significa n × (n - 1) × ... × 3 × 2 × 1

Ad esempio, 10! = 10 × 9 × ... × 3 × 2 × 1 = 3628800,
e la somma delle cifre nel numero 10! vale 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.

Trova la somma delle cifre nel numero 100!
============================================================================

Funzione fattoriale

(define (fact n) (apply * (map bigint (sequence 1 n))))

(explode (string (fact 10)))
;-> ("3" "6" "2" "8" "8" "0" "0" "L")

(map int (explode (string (fact 10))))
;-> (3 6 2 8 8 0 0 nil)

(define (e020)
  (apply + (map (fn (x) (int x 0)) (explode (string (fact 100)))))
)

(e020)
;-> 648

(time (e020))
;-> 0

Il creatore di newLISP (Lutz Mueller) ha scritto la seguente funzione che moltiplica due numeri interi passati come stringhe (è valida anche per numeri big-integer).

(define (big* x y) ; a and b are strings of decimal digits
    (letn ( nx (length x)
            ny (length y)
            np (+ nx ny)
            X (array nx (reverse (map int (explode x))))
            Y (array ny (reverse (map int (explode y))))
            Q (array (+ nx 1) (dup 0 (+ nx 1)))
            P (array np (dup 0 np))
            carry 0
            digit 0 )
        (dotimes (i ny) ; for each digit of the multiplier
            (dotimes (j nx) ; for each digit of the multiplicant
                (setq digit (+ (* (Y i) (X j)) carry) )
                (setq carry (/ digit 10))
                (setf (Q j) (% digit 10)) )
            (setf (Q nx ) carry)
            ; add Q to P shifted by i
            (setq carry 0)
            (dotimes (j (+ nx 1))
                (setq digit (+ (P (+ j i)) (Q j) carry))
                (setq carry (/ digit 10))
                (setf (P (+ j i)) (% digit 10)) )
        )
    ; translate P to string and return
    (setq P (reverse (array-list P)))
    (if (zero? (P 0)) (pop P))
    (join (map string P))
    )
)

Con la seguente soluzione al problema:

(define (e020-Lutz)
    (let (result "1")
        (for (i 2 100)
            (setq result (big* result (string i))))
        (apply + (map int (explode result))))
)

(e020-Lutz)
;-> 648

(time (e020-Lutz))
;-> 32.948
----------------------------------------------------------------------------


===========
Problema 21
===========

Numeri Amicabili

Definiamo d(n) come la somma dei divisori propri di n (tutti i numeri minori di n che dividono esattamente n).

Se d(a) = b e d(b) = a, dove a ≠ b,, allora a e b sono una coppia amicabile e a e b sono chiamati singolarmente numeri amicabili.

Per esempio, i divisori propri di 220 sono 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 e 110: quindi d(n) = 284. I divisori propri di 284 sono 1, 2, 4, 71 e 142: così d(284) = 220.

Calcolare la somma di tutti i numeri amicabili inferiori a 10000.
============================================================================

Definiamo la funzione che calcola la somma dei divisori di un numero:

(define (sum-divisors n)
  (setq res 0)
  (setq m (sqrt n))
  (setq i 2)
  (while (<= i m)
      (if (zero? (% n i))   ; se 'i' è divisore di 'n'
          (if (= i (/ n i))              ; se entrambi i divisori sono uguali...
            (setq res (+ res i))         ; allora aggiungilo una volta,
            (setq res (+ res i (/ n i))) ; altrimenti aggiungili entrambi.
          )
      )
      (setq i (+ i 1))
  )
  res
)

(sum-divisors 10)
;-> 7

Adesso dobbiamo definire la funzione che calcola i divisori propri:

(define (sum-proper-divisors n)
  (+ 1 (sum-divisors n))
)

(sum-proper-divisors 10)
;-> 8
(sum-proper-divisors 3)
;-> 1

(sum-proper-divisors 18)
;-> 21

(sum-proper-divisors 220)
;-> 284
(sum-proper-divisors 284)
;-> 220

Adesso scriviamo la funzione che calcola i numeri amicabili:

(define (e021)
  (setq _res 0)
  (for (j 1 9999)
      (setq spd (sum-proper-divisors j))
      (setq spd2 (sum-proper-divisors spd))
      (if (and (= j spd2) (!= spd spd2))
            (begin
              (setq _res (+ _res spd spd2))
              ;(println j { } spd { } spd2)
            )
      )
  )
  (/ _res 2)
)

(e021)
;-> 220 284 220
;-> 284 220 284
;-> 1184 1210 1184
;-> 1210 1184 1210
;-> 2620 2924 2620
;-> 2924 2620 2924
;-> 5020 5564 5020
;-> 5564 5020 5564
;-> 6232 6368 6232
;-> 6368 6232 6368
;-> 31626

(time (e021))
;-> 220.022

Una soluzione più efficiente si ottiene usando la seguente formula:
Siano p1, p2, ..., pk i fattori primi del numero n.
Siano a1, a2, ..., ak le potenze massime rispettivamente di p1, p2, ..., pk che dividono n (es. n = (p1^a1)*(p2^a2)*...*(pk^ak)).

Somma dei divisori = (1 + p1 + p1^2 ... p1^a1) *
                     (1 + p2 + p2^2 ... p2^a2) *
                     ......................... *
                     (1 + pk + pk^2 ... pk^ak)

Notiamo che i termini individuali di questa formula sono progressioni geometriche.
Possiamo riscrivere la formula come:

Somma dei divisori = (p1^(a1+1) - 1)/(p1 - 1) *
                     (p2^(a2+1) - 1)/(p2 - 1) *
                     ........................ *
                     (pk^(ak+1) - 1)/(pk - 1)

Vediamo un'applicazione della formula:

Consideriamo il numero 18.

(factor 18)
;-> (2 3 3)

Somma dei divisori = 1 + 2 + 3 + 6 + 9 + 18
(+ 1 2 3 6 9 18)
;-> 39

Scrivendo i divisori come potenze dei fattori primi otteniamo:

Somma di divisori = (2^0)(3^0) + (2^1)(3^0) + (2^0)(3^1) +
                    (2^1)(3^1) + (2^0)(3^2) + (2^1)(3^2)
                  = (2^0)(3^0) + (2^0)(3^1) + (2^0)(3^2) +
                    (2^1)(3^0) + (2^1)(3^1) + (2^1)(3^2)
                  = (2^0)(3^0 + 3^1 + 3^2) +
                    (2^1)(3^0 + 3^1 + 3^2)
                  = (2^0 + 2^1)(3^0 + 3^1 + 3^2)

Guardando attentamente, possiamo notare che l'ultima espressione è del tipo:

(1 + p1) * (1 + p2 + p2^2)

dove p1 = 2, p2 = 3.

Quindi: (1 + 2) * (1 + 3 + 9) = 3*13 = 39

Per trovare la somma dei divisori di un numero è sufficiente conoscere la sua scomposizione in fattori primi e applicare la seguente formula:

Somma dei divisori = Prod [(1 + f(i)^1 + ... + f(i)^k(i)]

dove [f(i), k(i)] è il fattore i-esimo con f = valore del fattore e k = potenza del fattore
e l'indice i varia da 1 al numero dei fattori.

Per trovare la somma dei divisori propria di un numero, basta sottrarre il numero stesso alla somma dei divisori ottenuta con la formula.

Esempio:

(fattorizza 18)
;-> ((2 1) (3 2))

somma dei divisori = (1 + p1 + p1^2 ... p1^a1) * (1 + p2 + p2^2 ... p2^a2) =
= (1 + 2) * (1 + 3 + 3^2) = 3 * 13 = 39

somma dei divisori propri = somma dei divisori - n = 39 - 18 = 21

Esempio:

(fattorizza 220)
;-> ((2 2) (5 1) (11 1))

p1 = 2  a1 = 2
p2 = 5  a2 = 1
p3 = 11 a3 = 1

(p1^(a1+1) - 1)/(p1 - 1) = (2^3 - 1)/(2 - 1) = 7
(p2^(a2+1) - 1)/(p2 - 1) = (5^2 - 1)/(5 - 1) = 6
(p3^(a3+1) - 1)/(p3 - 1) = (11^2 - 1)/(11 - 1) = 12

(* 6 7 12)
;-> 504

(- 504 220)
;-> 284 ; somma dei divisori propri di 220

Adesso possiamo scrivere la funzione che calcola i numeri amicabili:

(define (factor-group x)
  (if (= x 1) '(1 1)
    (letn (fattori (factor x)
          unici (unique fattori))
      (transpose (list unici (count unici fattori)))
    )
  )
)

(factor-group 220)
;-> ((2 2) (5 1) (11 1))

(factor-group 1)
;-> (1 1)

(define (somma-divisori-propri-fast n)
  (if (= n 1) '0
    (begin (setq res 1)
     (setq lst (factor-group n))
     (dolist (el lst)
       (setq somma-el 0)
       (for (i 0 (last el))
         (setq somma-el (+ somma-el (pow (first el) i)))
       )
       (setq res (* res somma-el))
     )
     (- res n)) ;somma divisori propri (tutti tranne se stesso)
  )
)

(somma-divisori-propri-fast 220)
;-> 284

(somma-divisori-propri-fast 284)
;-> 220

(somma-divisori-propri-fast 1)
;-> 0

Scriviamo la funzione richiesta dal problema:

(define (e021-2)
  (setq _res 0)
  (for (j 2 9999)
      (setq spd (somma-divisori-propri-fast j))
      (setq spd2 (somma-divisori-propri-fast spd))
      (if (and (= j spd2) (!= spd spd2))
            (begin
              (setq _res (+ _res spd spd2))
              ;(println j { } spd { } spd2)
            )
      )
  )
  (/ _res 2)
)

(e021-2)
;-> 31626

(time (e021-2))
;-> 122.883

la funzione "e021-fast" è tre volte più veloce della funzione "e021".
----------------------------------------------------------------------------


===========
Problema 22
===========

Punteggio dei nomi

Usando "names.txt", un file di testo 46K contenente oltre cinquemila nomi, inizia crando una lista dei nomi in ordine alfabetico. Quindi, calcolando il valore alfabetico per ciascun nome, moltiplica questo valore per la sua posizione alfabetica nella lista per ottenere un punteggio del nome.

Ad esempio, quando la lista è ordinata in ordine alfabetico, COLIN, che vale 3 + 15 + 12 + 9 + 14 = 53, è il 938-esimo nome nell'elenco. Quindi, COLIN otterrebbe un punteggio di 938 × 53 = 49714.

Qual è il totale di tutti i punteggi dei nomi contenuti nel file?
============================================================================

Il file ha questa struttura:
"MARY","PATRICIA","LINDA",...

Rimuoviamo tutti i caratteri doppio-apice "":

(define (remove-char c from-file to-file)
    (set 'in-file (open from-file "read"))
    (set 'out-file (open to-file "write"))
    (while (set 'chr (read-char in-file))
        (if (!= chr c)
          (write-char out-file chr)))
    (close in-file)
    (close out-file)
    "fatto")

(char {"})
;-> 34

(char 34)
;-> "\""

(remove-char 34 "p022_nomi.txt" "nomi22.txt")

Il file adesso ha questa struttura:

MARY,PATRICIA,LINDA,...

Importiamo il file in una lista di stringhe:

(silent (setq nomi (parse (read-file "nomi22.txt") ",")))

Vediamo i primi cinque nomi:

(slice nomi 0 5)
;-> ("MARY" "PATRICIA" "LINDA" "BARBARA" "ELIZABETH")

Ordiniamo la lista:

(silent (sort nomi))

Vediamo i primi cinque nomi:

(slice nomi 0 5)
;-> ("AARON" "ABBEY" "ABBIE" "ABBY" "ABDUL")

Vediamo dove si trova "COLIN":

(ref "COLIN" nomi )
;-> 937

Quindi dobbiamo aggiungere 1 all'indice della lista (+ $idx 1).
Adesso creiamo una lista associativa (association list) tra i caratteri e il numero del relativo ordine.

(setq alfa  '(("A" 1) ("B" 2) ("C" 3) ("D" 4) ("E" 5) ("F" 6) ("G" 7) ("H" 8) ("I" 9) ("J" 10) ("K" 11) ("L" 12) ("M" 13) ("N" 14) ("O" 15) ("P" 16) ("Q" 17) ("R" 18) ("S" 19) ("T" 20) ("U" 21) ("V" 22) ("W" 23) ("X" 24) ("Y" 25) ("Z" 26)))

(lookup '"A" alfa)
;-> 1

(define (e022)
  (local (somma nomesomma nome$)
    (setq somma 0)
    (dolist (el nomi)
      (setq nome$ (explode el))
      (setq nomesomma 0)
      (dolist (c nome$)
        (setq nomesomma (add nomesomma (lookup c alfa)))
      )
      (setq nomesomma (mul nomesomma (+ $idx 1)))
      (setq somma (add somma nomesomma))
    )
  )
)

(e022)
;-> 871198282

(time (e022))
;-> 20.016
----------------------------------------------------------------------------


===========
Problema 23
===========

Somma numeri non abbondanti

Un numero perfetto è un numero per il quale la somma dei relativi divisori è esattamente uguale al numero. Ad esempio, la somma dei divisori propri di 28 sarebbe 1 + 2 + 4 + 7 + 14 = 28, il che in dica che 28 è un numero perfetto.

Un numero n è chiamato carente se la somma dei suoi divisori è inferiore a n e viene chiamato abbondante se questa somma supera n.

Dato che 12 è il numero abbondante più piccolo, 1 + 2 + 3 + 4 + 6 = 12, il numero più piccolo che può essere scritto come somma di due numeri abbondanti è 24. Con l'analisi matematica, si può dimostrare che tutti gli interi superiori a 28123 possono essere scritti come somma di due numeri abbondanti. Tuttavia, questo limite superiore non può essere ulteriormente ridotto dall'analisi anche se è noto che il più grande numero che non può essere espresso come somma di due numeri abbondanti è inferiore a questo limite.

Trovare la somma di tutti i numeri interi positivi che non possono essere scritti come la somma di due numeri abbondanti.
============================================================================

Funzione che calcola la somma di tutti i divisori propri (tutti i divisori tranne se stesso) di un numero :
(vedi problema 21)

(define (factor-group x)
  (if (= x 1) '(1 1)
    (letn (fattori (factor x)
          unici (unique fattori))
      (transpose (list unici (count unici fattori)))
    )
  )
)

(define (somma-divisori-propri-fast n)
  (if (= n 1) '0
    (begin (setq res 1)
     (setq lst (factor-group n))
     (dolist (el lst)
       (setq somma-el 0)
       (for (i 0 (last el))
         (setq somma-el (+ somma-el (pow (first el) i)))
       )
       (setq res (* res somma-el))
     )
     (- res n)) ;somma divisori propri (tutti tranne se stesso)
  )
)

(somma-divisori-propri-fast 284235235345)
;-> 59865475031

Funzione che cerca una coppia di numeri in un vettore che sommano a num.
Questa funzione ha complessità temporale O(nlog(n)).

(define (trovaCoppia vec num)
  (local (low high a b out)
    ; ordina il vettore in ordine crescente
    (sort vec)
    ; indici che puntano all'inizio e alla fine dell'array
    (setq low 0)
    (setq high (- (length vec) 1))
    (while (and (< low high) (= out nil))
      (setq a (vec low))
      (setq b (vec high))
      ; vale anche la coppia formata dallo stesso numero ripetuto
      ; altrimenti il risultato vale: 4179935
      (if (or (= num (add a b)) (= num (add a a)) (= num (add b b)))
          ; coppia trovata
          (setq out true)
      )
      (if (< (add (vec low) (vec high)) num)
          ; incrementa l'indice basso se il totale è minore della somma
          (++ low)
          ; decrementa indice alto se è totale è maggiore della somma
          (-- high)
      )
    )
    out
  );local
)

(setq lst '( 123 73 64 7 8 6 5 4 3 4 5 6 7 ))
(setq v (array (length lst) lst))
(array? v)
;-> true

(trovaCoppia v 130)
;-> true

(trovaCoppia v 230)
;-> nil

(trovaCoppia v 246)
;-> true

Funzione che crea la lista dei numeri abbondanti fino al numero 28123.

(define (creaAbbondanti)
  (local (out)
    (setq out '())
    (for (i 1 28123)
      (if (< i (somma-divisori-propri-fast i))
        (push i out)
      )
    )
    out
  )
)

(silent (setq abbo (creaAbbondanti)))
(time (setq abbo (creaAbbondanti)))

(length abbo)
;-> 6965
(sort abbo)

(slice abbo 0 30)
;-> (12 18 20 24 30 36 40 42 48 54 56 60 66 70 72 78 80 84 88 90 96 100 102 104 108 112 114 120 126 132)

Adesso possiamo scrivere la funzione che trova i numeri richiesti dal problema:

(define (e023)
  (local (abbo-lst abbo somma out)
    (setq out '())
    (setq somma 0)
    (setq abbo-lst (creaAbbondanti))
    (setq abbo (array (length abbo-lst) abbo-lst))
    (for (i 1 28123)
      (if (not (trovaCoppia abbo i))
        (begin
          (setq somma (add somma i))
          (push i out -1)
        )
      )
    )
    (println somma)
    out
  )
)

(silent (setq res (e023)))
;-> 4179871

(slice res 0 100)
;-> (1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 25 26 27 28 29 31 33
;->  34 35 37 39 41 43 45 46 47 49 51 53 55 57 59 61 63 65 67 69 71 73 75 77 79 81 83
;->  85 87 89 91 93 95 97 99 101 103 105 107 109 111 113 115 117 119 121 123 125 127
;->  129 131 133 135 137 139 141 143 145 147 149 151 153 155 157 159 161 163 165 167
;->  169)

Sopra a 50 i numeri della somma sono tutti dispari, quindi dividiamo il ciclo for in due parti:

(define (e023)
  (local (abbo-lst abbo somma)
    (setq somma 0)
    (setq abbo-lst (creaAbbondanti))
    (setq abbo (array (length abbo-lst) abbo-lst))
    (for (i 1 50)
      (if (not (trovaCoppia abbo i))
          (setq somma (add somma i))
      )
    )
    (for (i 51 28123 2)
      (if (not (trovaCoppia abbo i))
          (setq somma (add somma i))
      )
    )
    somma
  )
)

(e023)
;-> 4179871

(time (e023))
;-> 40900.186 ; circa 41 secondi
----------------------------------------------------------------------------


===========
Problema 24
===========

Permutazioni lessicografiche

Una permutazione è una disposizione ordinata di oggetti. Ad esempio, 3124 è una possibile permutazione delle cifre 1, 2, 3 e 4. Se tutte le permutazioni sono ordinate numericamente o alfabeticamente, vengono chiamate in ordine lessicografico. Le permutazioni lessicografiche di 0, 1 e 2 sono:

012 021 102 120 201 210

Qual è la milionesima permutazione lessicografica delle cifre 0, 1, 2, 3, 4, 5, 6, 7, 8 e 9?
============================================================================

Definiamo la funzione che genera le permutazioni:

(define (seq start end)
  (if (= start end)
      (list end)
      (cons start (seq (+ start 1) end))))

(define (insert l n e)
  (if (= 0 n)
      (cons e l)
      (cons (first l)
            (insert (rest l) (- n 1) e))))

(define (permute l)
  (if (null? l) '(())
      (apply append (map (lambda (p)
                           (map (lambda (n) (insert p n (first l))) (seq 0 (length p))))
                         (permute (rest l))))))

Scriviamo la funzione finale:

(define (e024)
  (setq p (sort (permute '(0 1 2 3 4 5 6 7 8 9))))
  (int (join (map string (p 999999))))
)

Abbiamo ordinato le permutazioni poichè non vengono create in ordine lessicografico.

(e024)
;-> 2783915460

(time (e024))
;-> 25309.091  ;circa 25 secondi
----------------------------------------------------------------------------


===========
Problema 25
===========

Numero di Fibonacci a 1000 cifre

La sequenza di Fibonacci è definita dalla relazione di ricorrenza:

Fn = Fn-1 + Fn-2, dove F1 = 1 e F2 = 1.
Quindi i primi 12 termini saranno:

F1 = 1
F2 = 1
F3 = 2
F4 = 3
F5 = 5
F6 = 8
F7 = 13
F8 = 21
F9 = 34
F10 = 55
F11 = 89
F12 = 144

Il dodicesimo termine, F12, è il primo termine a contenere tre cifre.

Qual è l'indice del primo termine nella sequenza di Fibonacci che contiene 1000 cifre?
============================================================================

Funzione per calcolare i numeri di Fibonacci:

(define (fibo-i n)
  (local (a b c)
    (setq a 0L b 1L c 0L)
    (for (i 0 (- n 1))
      (setq c (+ a b))
      (setq a b)
      (setq b c)
    )
    a
  )
)

(fibo-i 12)
;-> 144L
(length (fibo-i 12))
;-> 3

(define (e025)
  (local (trovato num)
    (setq num 1)
    (while (not trovato)
      (if (> (length (fibo-i num)) 999)
        (setq trovato true)
      )
      (++ num)
    )
    (-- num)
  )
)

(e025)
;-> 4782

(time (e025))
;-> 4925.875
----------------------------------------------------------------------------


===========
Problema 26
===========

Periodo dei numeri reciproci

Una frazione unitaria contiene 1 nel numeratore. La rappresentazione decimale delle frazioni unitarie con i denominatori da 2 a 10 è data:

1/2 =  0.5
1/3 =  0.(3)
1/4 =  0.25
1/5 =  0.2
1/6 =  0.1(6)
1/7 =  0.(142857)
1/8 =  0.125
1/9 =  0.(1)
1/10 = 0.1

Dove 0.1 (6) significa 0.166666 ... e ha un ciclo ricorrente di 1 cifra. Si può vedere che 1/7 ha un ciclo ricorrente di 6 cifre.

Trova il valore di d <1000 per cui 1 / d contiene il ciclo ricorrente più lungo nella sua parte della frazione decimale.
============================================================================

Calcoliamo i resti della divisione, quando troviamo lo stesso resto per la seconda volta, allora abbiamo trovato un ciclo (se il rsto è diverso da zero.
La lunghezza del ciclo è uguale alla distanza in cui si trovano i due valori uguali di resto.

Esempio: 1/14

(% 1 14)
;-> 1
(% 10 14)
;-> 10
(% 100 14)
;-> 2
(% 1000 14)
;-> 6
(% 10000 14)
;-> 4
(% 100000 14)
;-> 12
(% 1000000 14)
;-> 8
(% 10000000 14)
;-> 10 ; il numero 10 è stato già trovato ==> stop

La lista vale: (1 10 2 6 4 12 8 10)

La distanza tra i due numeri 10 è la differenza tra gli indici: 7 - 1 = 6.
Se i due numeri uguali del resto valgono 0, allora il reciproco non ha cicli.

Adesso possiamo scrivere la funzione che calcola la lunghezza del ciclo del reciproco di un numero:

(define (ciclo n)
  (local (trovato lst resto len-ciclo idx)
    (setq lst '())
    (setq pot 1)
    (while (not trovato)
      (setq resto (% pot n))
      (if (= (find resto lst) nil ) (push resto lst -1)
          (begin
            (setq trovato true)
            (push resto lst -1)
            (setq idx (ref-all resto lst))
            (setq len-ciclo (- (first (last idx)) (first (first idx))))
          )
      )
      (setq pot (* 10L pot))
      ;(println pot)
    )
    ;se i numeri uguali del resto valgono 0, allora il ciclo vale 0.
    (if (= resto 0) (setq len-ciclo 0))
    ;(list len-ciclo lst (div 1 n))
    (list len-ciclo (div 1 n))
  )
)

(ciclo 14)
;-> (6 (1 10 2 6 4 12 8 10) 0.07142857142857143)

(ciclo 7)
;-> (6 (1 3 2 6 4 5 1) 0.1428571428571429)

(ciclo 2)
;-> (0 0.5)

(ciclo 3)
;-> (1 0.3333333333333333)

(ciclo 983)
;-> (982 0.001017293997965412)

(define (e026)
  (local (num maxciclo)
    (setq maxciclo 0)
    (for (i 1 1000)
      (setq c (ciclo i))
      (if (> c maxciclo)
        (setq maxciclo c num i)
      )
    )
    (list num maxciclo)
  )
)

(e026)
;-> (983 (982 0.001017293997965412))

(time (e026))
;-> 488.049
----------------------------------------------------------------------------


===========
Problema 27
===========

Eulero scoprì la notevole formula quadratica:  n^2 + n + 41

La formula produce 40 numeri primi per i valori interi consecutivi 0≤n≤39. Tuttavia, quando n = 40, 40^2 + 40 + 41 = 40 (40 + 1) + 41 è divisibile per 41, e certamente quando n = 41, 41^2 + 41 + 41 è chiaramente divisibile per 41.

È stata scoperta l'incredibile formula n^2 - 79n + 1601, che produce 80 numeri primi per i valori consecutivi 0≤n≤79. Il prodotto dei coefficienti, -79 e 1601, è -126479.

Considerando forme quadratiche del tipo:

n^2 + a*n + b, dove |a| < 1000 e |b| ≤ 1000

dove |n| è il valore assoluto di n

Per esempio: |11| = 11 e |-4| = 4

Trova il prodotto dei coefficienti, a e b, per l'espressione quadratica che produce il numero massimo di numeri primi per valori consecutivi di n, iniziando con n = 0.
============================================================================

(define (primo? n)
        (if (< n 2) nil
            (= 1 (length (factor n)))))

(define (e027)
  (local (aa bb num min_a max_a min_b max_b max_len primo lst)
    (setq min_a -999)
    (setq max_a 999)
    (setq min_b -1000)
    (setq max_b 1000)
    (for (a min_a max_a)
      (for (b min_b max_b)
        (setq primo true)
        (setq lst '())
        (setq num 1)
        (while primo
          (if (primo? (add (mul num num) (mul a num) b))
            (begin
              (push num lst)
              (if (> (length lst) max_len)
                (begin
                  (setq max_len (length lst))
                  (setq aa a)
                  (setq bb b)
                )
              )
              (++ num)
            )
          ;else
            (setq primo nil)
          );if
        );while
      );for
    );for
    (list (* aa bb) aa bb max_len)
  );local
)

(e027)
;-> (-59231 -61 971 71)

(time (e027))
;-> 2000.151

Proviamo a ricercare in un intervallo più grande (-10000 10000):

(define (test27 min_a max_a min_b max_b)
  (local (aa bb num max_len primo lst)
    (for (a min_a max_a)
      (for (b min_b max_b)
        (setq primo true)
        (setq lst '())
        (setq num 0)
        (while primo
          (if (primo? (add (mul num num) (mul a num) b))
            (begin
              (push num lst)
              (if (> (length lst) max_len)
                (begin
                  (setq max_len (length lst))
                  (setq aa a)
                  (setq bb b)
                )
              )
              (++ num)
            )
          ;else
            (setq primo nil)
          );if
        );while
      );for
    );for
    (list aa bb max_len)
  );local
)

(test27 -10000 10000 -10000 10000)
;-> (-79 1601 80)

Abbiamo trovato l'equazione presentata come esempio nel problema.

Facciamo un controllo:

(define (f n)
  (primo? (+ (* n n) (* (- 79) n) 1601)))

(f 2)

(count '(true) (map f (sequence 0 79)))
;-> (80)

(define (f1 n)
  (list (primo? (+ (* n n) (* (- 79) n) 1601)) (+ (* n n) (* (- 79) n) 1601)))

Proviamo ad eliminare la lista dei numeri primi ed usare solo un contatore per cercare di migliorare la velocità di esecuzione, inoltre :

(define (e027-2)
  (local (aa bb num min_a max_a min_b max_b max_len primo lst_len)
    (setq min_a -999)
    (setq max_a 999)
    (setq min_b -1000)
    (setq max_b 1000)
    (for (a min_a max_a)
      (for (b min_b max_b)
        (setq primo true)
        (setq lst_len 0)
        (setq num 0)
        (while primo
          (if (primo? (add (mul num num) (mul a num) b))
            (begin
              (++ lst_len)
              (if (> lst_len max_len)
                (begin
                  (setq max_len lst_len)
                  (setq aa a)
                  (setq bb b)
                )
              )
              (++ num)
            )
          ;else
            (setq primo nil)
          );if
        );while
      );for
    );for
    (list (* aa bb) aa bb max_len)
  );local
)

(e027-2)
;-> (-59231 -61 971 71)

(time (e027-2))
;-> 2015.211

Non abbiamo migliorato, sembra che il tempo dipenda quasi esclusivamente dai due cicli for :-)
----------------------------------------------------------------------------


===========
Problema 28
===========

Diagonale di numeri a spirale

Partendo dal numero 1 e spostandosi verso destra in senso orario, si forma una spirale 5 per 5 come segue:

21 22 23 24 25
20  7  8  9 10
19  6  1  2 11
18  5  4  3 12
17 16 15 14 13

Si può verificare che la somma dei numeri sulle diagonali sia 101:
(21 + 7 + 1 + 3 + 13 + 25 + 9 + 5 + 17) = 101 (l'elemento centrale (1) viene contato solo una volta).

Qual è la somma dei numeri sulle diagonali in una spirale 1001 per 1001 formata nello stesso modo?
============================================================================

Disegniamo una matrice più grande per poter individuare una funzione che possa generarer i valori dei numeri sulla diagonale in funzione della grandezza della matrice:

 73                      81
    43                49
       21 22 23 24 25
       20  7  8  9 10
       19  6  1  2 11
       18  5  4  3 12
       17 16 15 14 13
    37                31
 65                      57

(define (e028)
  (local (m somma a_d b_d b_s a_s alto_dx basso_dx basso_sx alto_sx)
    (setq m 1001)
    (setq somma 0)
    (setq a_d '())
    (setq b_d '())
    (setq a_s '())
    (setq b_s '())
    (for (i 1 (/ (- m 1) 2))
      (setq alto_dx (* (+ (* i 2) 1) (+ (* i 2) 1)))
      (setq basso_dx (- alto_dx (* 6 i)))
      (setq basso_sx (- alto_dx (* 4 i)))
      (setq alto_sx (- alto_dx (* 2 i)))
      ;(println alto_dx { } alto_sx { } basso_sx { } basso_dx)
      (push alto_dx a_d)
      (push basso_dx b_d)
      (push basso_sx b_s)
      (push alto_sx a_s)
    )
    (setq somma (+ (apply + a_d) (apply + a_s) (apply + b_d) (apply + b_s) 1))
  )
)

Con m = 5 e con l'espressione print attiva, otteniamo:

;-> 9 7 5 3
;-> 25 21 17 13
;-> 101

(e028)
;-> 669171001

(time (e028))
;-> 0
----------------------------------------------------------------------------


===========
Problema 29
===========

Potenze distinte

Considerare tutte le combinazioni intere di ab per 2 ≤ a ≤ 5 e 2 ≤ b ≤ 5:

2^2 = 4,  2^3 = 8,   2^4 = 16,  2^5 = 32
3^2 = 9,  3^3 = 27,  3^4 = 81,  3^5 = 243
4^2 = 16, 4^3 = 64,  4^4 = 256, 4^5 = 1024
5^2 = 25, 5^3 = 125, 5^4 = 625, 5^5 = 3125

Se vengono quindi posizionati in ordine numerico, con le eventuali ripetizioni rimosse, otteniamo la seguente sequenza di 15 termini distinti:

4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

Quanti termini distinti sono nella sequenza generata da a^b per 2 ≤ a ≤ 100 e 2 ≤ b ≤ 100?
============================================================================

(define (potenza n m)
  (setq pot 1L)
  (dotimes (x m)
    (setq pot (* pot n))
  )
)

(define (e029)
  ;(local (a b lst)
  (local (a b)
    (setq lst '())
    (for (a 2 100)
      (for (b 2 100)
        (push (potenza a b) lst)
      )
    )
    (setq lst (unique lst))
    (length lst)
  )
)

(e029)
;-> 9183

(time (e029))
;-> 140.608
----------------------------------------------------------------------------


===========
Problema 30
===========

Quinta potenza delle cifre

Sorprendentemente ci sono solo tre numeri che possono essere scritti come la somma delle quarte potenze delle loro cifre:

1634 = 1^4 + 6^4 + 3^4 + 4^4
8208 = 8^4 + 2^4 + 0^4 + 8^4
9474 = 9^4 + 4^4 + 7^4 + 4^4

La somma di questi numeri è 1634 + 8208 + 9474 = 19316.

Il numero 1 = 1^4 non viene incluso perchè non è una somma.

Trova la somma di tutti i numeri che possono essere scritti come somma delle quinte potenze delle loro cifre.
============================================================================

Funzione che estrae le cifre di un numero da sinistra verso destra:

(define (estraiCifre n)
  (local (cifra)
    (while (!= n 0)
      (setq cifra (% n 10))
      (setq n (/ n 10))
      (print cifra { })
    )
  )
)

(estraiCifre 1234)
;-> 4 3 2 1 " "

Precalcoliamo la quinta potenza di ogni cifra:

(setq pot5 (map (fn (x) (pow x 5)) '(0 1 2 3 4 5 6 7 8 9)))
;-> (0 1 32 243 1024 3125 7776 16807 32768 59049)

Funzione che calcola la somma delle quinte potenze di tutte le cifre di un numero:

(define (pot5Cifre n)
  (local (cifra somma)
    (setq somma 0)
    (while (!= n 0)
      (setq cifra (% n 10))
      (setq somma (+ somma (pot5 cifra)))
      (setq n (/ n 10))
    )
    somma
  )
)

(pot5Cifre 1634)
;-> 9044

Limite superiore:
max numero con 1 cifra = 9^5 = 56049
max numero con 2 cifre = 9^5 + 9^5 = 118098
max numero con 3 cifre = 9^5 + 9^5 + 9^5 = 177147
max numero con 4 cifre = 9^5 + 9^5 + 9^5 + 9^5 = 236196
max numero con 5 cifre = 9^5 + 9^5 + 9^5 + 9^5 + 9^5 = 295245
max numero con 6 cifre = 9^5 + 9^5 + 9^5 + 9^5 + 9^5 + 9^5 = 354294
max numero con 7 cifre = 9^5 + 9^5 + 9^5 + 9^5 + 9^5 + 9^5 + 9^5 = 413343

Quindi per essere sicuri di considerare tutti i numeri di cinque cifre formati dalla somma delle quinte potenze di ogni cifra occorre prendere il numero 295245 (perchè questo numero ha 6 cifre).

(* 5 (pow 9 5))
;-> 295245

(define (e030)
  (local (maxVal tot)
    (setq maxVal 295245)
    (setq tot 0)
    (for (i 2 maxVal)
      (setq x (pot5Cifre i))
      (if (= x i) (setq tot (+ tot x)))
    )
    tot
  )
)

(e030)
;-> 443839

(time (e030))
;-> 515.564
----------------------------------------------------------------------------


===========
Problema 31
===========

Somme di monete

In Inghilterra la moneta è composta da sterline "£" e pence "p" e ci sono in circolazione otto tipi di monete:

1p, 2p, 5p, 10p, 20p, 50p, £ 1 (100p) e £ 2 (200p)

È possibile arrivare a £ 2 nel modo seguente:

1 × £ 1 + 1 × 50p + 2 × 20p + 1 × 5p + 1 × 2p + 3 × 1p

In quanti modi diversi si può arrivare a £ 2 usando un numero qualsiasi di monete?
============================================================================

Soluzione forza-bruta:

(define (e031)
  (local (A B C D E F G q tot)
    (setq A (sequence 0 200))
    (setq B (sequence 0 200 2))
    (setq C (sequence 0 200 5))
    (setq D (sequence 0 200 10))
    (setq E (sequence 0 200 20))
    (setq F (sequence 0 200 50))
    (setq G (sequence 0 200 100))
    (setq q 1)
    (setq tot 200)
    (dolist (a A)
      (dolist (b B (> (+ a b) tot))
        (dolist (c C (> (+ a b c) tot))
          (dolist (d D (> (+ a b c d) tot))
            (dolist (e E (> (+ a b c d e) tot))
              (dolist (f F (> (+ a b c d e f) tot))
                (dolist (g G)
                  (if (= (+ a b c d e f g) tot) (++ q))
    )))))))
    q
  );local
)

(e031)
;-> 73682

(time (e031))
;-> 3009.901

Soluzione programmazione dinamica:

(define (e031)
  (local (totale monete modi)
    ; valore obiettivo
    (setq totale 200)
    ; lista dei tagli di monete disponibili
    (setq monete '(1 2 5 10 20 50 100 200))
    ; crea un vettore di totale elementi con tutti valori 0 tranne il primo (modi[0]) che vale 1
    (setq modi (array (+ totale 1) (extend '(1) (dup 0 totale))))
    (dolist (el monete)
      (for (i el totale)
        (setq (modi i) (+ (modi i) (modi (- i el))))
      )
    )
    (modi totale)
  )
)

(e031)
;-> 73682

(time (e031))
;-> 0.971
----------------------------------------------------------------------------


===========
Problema 32
===========

Prodotti Pandigitali

Diciamo che un numero con n cifre è pandigitale se fa uso di tutte le cifre da 1 a n esattamente una volta. Ad esempio, il numero a 5 cifre, 15234, è pandigitale da 1 a 5.

Il prodotto 7254 è inusuale, poiché l'identità 39 × 186 = 7254, contenente moltiplicando, moltiplicatore e prodotto è pandigitale da 1 a 9.

Trovare la somma di tutti i prodotti la cui identità in moltiplicando/moltiplicatore/prodotto è pandigitale da 1 a 9.

SUGGERIMENTO: alcuni prodotti possono essere ottenuti in più di un modo, quindi assicurati di includerlo solo una volta nella somma.
============================================================================

La seguente funzione verifica se un numero è pandigitale (1-9):

(define (pan? n)
  (cond ((or (< n 123456789) (> n 987654321) (!= 0 (% n 9))) nil)
        (true
          (let (lst '(0 -1 -1 -1 -1 -1 -1 -1 -1 -1))
            (while (!= n 0)
              (setf (lst (% n 10)) 1)
              (setq n (/ n 10))
            )
            ;(println lst)
            (if (ref '-1 lst) nil true)
          )
        )
  )
)

(pan? 391867254)
;-> true

(pan? 391877254)
;-> nil

Calcoliamo i limiti dei numeri coinvolti:

(* 999 99)
;-> 98901

(* 9999 9)
;-> 89991

999 * 99 = 98901 => 10 cifre (moltiplicando/moltiplicatore/prodotto)
9999 * 9 = 89991 => 10 cifre (moltiplicando/moltiplicatore/prodotto)

Quindi, il massimo valore del primo indice vale 99 e il massimo valore del secondo indice 9999. Si tratta di una stima grossolana che potrebbe essere migliorata.

Possiamo scrivere la soluzione:

(define (e032)
  (local (somma sol p)
    (setq sol '())
    (for (i 1 99)
      (for (j (+ i 1) 9999)
        (setq p (int (string i j (* i j))))
        (if (pan? p) (push (* i j) sol))
        ;(if (pan? p) (begin (push (* i j) sol) (println i { * } j { = } (* i j))))
      )
    )
    (setq sol (unique sol))
    (apply + sol)
  )
)

(e032)
;-> 45228

(time (e032))
;-> 1625.291

Ecco tutti i prodotti pandigitali:

 4 * 1738 = 6952
 4 * 1963 = 7852
12 *  483 = 5796 (a)
18 *  297 = 5346 (b)
27 *  198 = 5346 (b)
28 *  157 = 4396
39 *  186 = 7254
42 *  138 = 5796 (a)
48 *  159 = 7632

(+ 6952 7852 5796 5346 4396 7254 7632)
;-> 45228
----------------------------------------------------------------------------


===========
Problema 33
===========

Cancellazione di cifre nelle frazioni

La frazione 49/98 è una frazione curiosa, poiché un matematico inesperto nel tentativo di semplificarlo potrebbe erroneamente credere che 49/98 = 4/8, che è corretto, si ottiene cancellando le due cifre 9.

Considereremo frazioni come, 30/50 = 3/5, come esempi banali.

Esistono esattamente quattro esempi non banali di questo tipo di frazione, che hanno valore minore di 1, e contenenti due cifre nel numeratore e nel denominatore.

Se il prodotto di queste quattro frazioni viene ridotto ai minimi termini (semplificato), trovare il valore del denominatore.
============================================================================

Funzione che converte un numero intero in una lista:

(define (int2list n)
  (let (out '())
    (while (!= n 0)
      (push (% n 10) out)
      (setq n (/ n 10))
    )
    out
  )
)

La soluzione con la forza bruta è abbastanza semplice (e anche veloce):

(define (e033)
  (local (fraction frazione N D num numL den denL d d1 d2 n n1 n2 val)
    (setq fraction '())
    (for (num 11 100)
      (for (den (+ num 1) 100)
        (setq val (div num den))
        (setq frazione 0)
        (setq denL (int2list den))
        (setq d1 (int (denL 0)))
        (setq d2 (int (denL 1)))
        (setq numL (int2list num))
        (setq n1 (int (numL 0)))
        (setq n2 (int (numL 1)))
        (cond ((and (= n1 d2) (!= d1 0))
               (setq frazione (div n2 d1))
               (setq n n2)
               (setq d d1)
              )
              ((and (= n2 d1) (!= d2 0))
               (setq frazione (div n1 d2))
              )
              ((and (= n1 d1) (!= d2 0))
               (setq frazione (div n2 d2))
              )
              ((and (= n2 d2) (!= n2 0) (!= d1 0))
               (setq frazione (div n1 d1))
              )
        )
        (if (= frazione val) (push (list num den) fraction))
      )
    )
    (println fraction)
    (setq N (apply * (map first f)))
    (setq D (apply * (map last f)))
    (div D (gcd N D))
  );local
)

(e033)
;-> ((49 98) (26 65) (19 95) (16 64))
;-> 100

(time (e033))
;-> 31.235

Le quattro frazioni sono: 16/64 (1/4), 26/65 (2/5), 19/95 (1/5) e 49/98 (4/8).

Anche in questo problema possiamo utilizzare la matematica per trovare un algoritmo migliore.
Si può dimostrare che ogni frazione della soluzione deve essere della forma:

10*n + i    n
-------- = ---
10*i + d    d

dove numeratore "n" e denominatore "d" soddisfano la relazione: 1 <= n < d <= 9
e la variabile da eliminare "i" soddisfa la relazione: 1 <= i <= 9

Per evitare di utilizzare divisoni, troveremo le soluzioni verificando se vale l'uguaglianza:

d*(10*n + i) = n*(10*i + d)

(define (e033)
  (local (den num numtot dentot)
    (setq numtot 1 dentot 1)
    (for (i 1 9)
      (setq den 1)
      (while (< den i)
        (setq num 1)
        (while (< num den)
          (if (= (* den (+ (* num 10) i)) (* num (+ (* 10 i) den)))
            (begin
              (setq dentot (* dentot den))
              (setq numtot (* numtot num))
              ;(println num i {/} i den)
            )
          )
          (++ num)
        )
        (++ den)
      )
    )
    (/ dentot (gcd numtot dentot))
  )
)

(e033)
;-> 100

(time (e033))
;-> 0
----------------------------------------------------------------------------


===========
Problema 34
===========

Cifre fattoriali

145 è un numero curioso, poichè 1! + 4! + 5! = 1 + 24 + 120 = 145.

Trovare la somma di tutti i numeri che sono uguali alla somma del fattoriale delle loro cifre.

Nota: poichè 1! = 1 e 2! = 2 non sono somme, allora non vengono inclusi.
============================================================================

Precalcoliamo il fattoriale delle cifre 0..9:

(define (fact n) (if (= n 0) 1 (apply * (sequence 1 n))))

(setq fact-lst (map (fn(n) (fact n)) (sequence 0 9)))
;-> (1 1 2 6 24 120 720 5040 40320 362880)

Limiti dei numeri
Il numero 3 potrebbe andar bene, ma poiché il fattoriale di un numero di una cifra - eccetto 3 - ha sempre più di una cifra, allora possiamo iniziare con 10.
Il calcolo del limite superiore è un pò più complicato.
Se prendiamo un numero n con "d" cifre, possiamo scrivere:

 10^(d-1) <= n < 10^d

Per formare il numero massimo di "d" cifre dobbiamo utilizzare tutti 9, e la somma delle sue cifre fattoriali sarebbe d*9!, quindi:

 10^(d-1) <= d*9! < 10^d

Provando alcuni valori di "d" notiamo che 9!*7 = 2540160. Non esiste un valore più alto, poiché sia 9!*8 che 9!*9 generano ugualmente numeri di 7 cifre (9!*8 = 2903040, 9!* = 93265920). Quindi il numero 9999999 genera 7*9! = 2540160.

(define (e034)
  (local (fact-lst somma sol n)
    (setq fact-lst '(1 1 2 6 24 120 720 5040 40320 362880))
    (setq sol '())
    (for (i 10 2540160)
      (setq somma 0)
      (setq n i)
      (while (!= n 0)
        (setq somma (+ somma (fact-lst (% n 10))))
        (setq n (/ n 10))
      )
      (if (= somma i) (push i sol))
    )
    (list (apply + sol) sol)
  )
)

(e034)
;-> (40730 (40585 145))

(time (e034))
;-> 3797.395
----------------------------------------------------------------------------


===========
Problema 35
===========

Numeri primi circolari

Il numero, 197, è chiamato primo circolare perché tutte le rotazioni delle cifre: 197, 971 e 719, sono esse stesse prime.

Ci sono tredici tali numeri primi sotto 100: 2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79 e 97.

Quanti numeri primi circolari ci sono sotto un milione?
============================================================================

Abbiamo bisogno delle seguenti funzioni ausiliarie:

Verifica se un numero è primo:

(define (primo? n)
        (if (< n 2) nil
            (= 1 (length (factor n)))))

Converte un numero intero in una lista:

(define (int2list n)
  (let (out '())
    (while (!= n 0)
      (push (% n 10) out)
      (setq n (/ n 10))
    )
    out
  )
)

Converte una lista in un numero intero:

(define (list2int lst)
  (let (n 0)
    (for (i 0 (- (length lst) 1))
      (setq n (+ n (* (lst i) (pow 10 (- (length lst) i 1)))))
    )
  )
)

Crea una lista con tutte le rotazioni della lista passata:

(define (creaRotate lst)
  (let (out '())
    ;(for (i 1 (- (length lst) 1))
    (for (i 1 (length lst))
      (push (rotate lst) out)
    )
    out
  )
)

(apply + '(1 2 3 1 2 3) 3)
;-> 15
(creaRotate '(2))
;-> ((2))

(creaRotate '(1 2 3))
;-> ((1 2 3) (2 3 1) (3 1 2))

Adesso definiamo la funzione che risolve il problema:

(define (e035)
  (local (primicirco candidate stop k)
    (setq primicirco '(2)) ;lista risultato
    (setq candidate '())   ;lista rotazioni
    (for (i 3 999999 2)    ;solo numeri pari
      (if (primo? i)
        (begin
          ; creiamo la lista di tutti numeri ruotati del numero i
          (setq candidate (creaRotate (int2list i)))
          (setq stop nil)
          (setq k 0)
          (while (and (< k (length candidate)) (= stop nil))
            (if (!= k 0) ;il primo numero è sempre primo
              ;stop quando un numero della lista candidati non è primo
              (if (not (primo? (list2int (candidate k)))) (setq stop true))
            )
            (++ k)
          )
          ; se tutti i numeri nella lista candidati sono primi
          ; aggiungiamo la lista al risultato
          (if (= stop nil) (push (list2int (candidate (- k 1))) primicirco))
        )
      );if
    );for
    (list (length primicirco) primicirco)
  );local
)

(e035)
;-> (55 (199933 999331 193939 393919 993319 391939 939391 939193 933199 331999 319993
;->      919393 19937 19391 99371 39119 37199 93911 93719 71993 11939 91193 7937 1931 7793
;->      3779 9377 9311 1193 3119 199 197 991 373 971 337 733 131 919 719 113 311 79 97
;->      37 17 73 13 71 31 11 7 5 3 2))

(time (e035))
;-> 1266.715
----------------------------------------------------------------------------


===========
Problema 36
===========

Palindromi a doppia base

Il numero decimale, 585 = 10010010012 (binario), è palindromo in entrambe le basi.

Trova la somma di tutti i numeri, sotto al milione, che sono palindromi in base 10 e in base 2.

(Si noti che il numero palindromo, in entrambe le basi, non include gli zeri iniziali.)
============================================================================

Funzioni ausiliarie

Questa funzione controlla se un numero è palindromo:

(define (paliN n)
  (= (string n) (reverse (string n))))

(paliN 113311)
;-> true

(paliN 1123311)
;-> nil

Questa funzione controlla se una stringa è palindroma:

(define (paliS s)
  (= s (reverse (copy s))))

(paliS "1234321")
;-> true

(paliS "51234321")
;-> nil

Nota: I numeri pari non sono mai palindromi in base 2, perchè il bit a destra vale sempre 0 e il bit a sinistra vale sempre 1.

Nota: per controllare se un numero in base 2 è palindromo occorre utilizzare una stringa per rappresentarlo, perchè altrimenti il numero dovrebbe essere un big integer (con L alla fine).

La funzione finale è la seguente:

(define (e036)
  (let (somma 0)
    (for (i 1 999999 2) ;nessun numero pari palindromo in base 2
      (if (and (paliN i) (paliS (bits i)))
        (begin
          (setq somma (+ somma i))
          ;(println i { - } (bits i))
        )
      )
    )
    somma
  )
)

(e036)
;-> 872187

(time (e036))
;-> 1442.523

I numeri palindromi in entrambe le basi sono:

1 - 1
3 - 11
5 - 101
7 - 111
9 - 1001
33 - 100001
99 - 1100011
313 - 100111001
585 - 1001001001
717 - 1011001101
7447 - 1110100010111
9009 - 10001100110001
15351 - 11101111110111
32223 - 111110111011111
39993 - 1001110000111001
53235 - 1100111111110011
53835 - 1101001001001011
73737 - 10010000000001001
585585 - 10001110111101110001
----------------------------------------------------------------------------


===========
Problema 37
===========

Numeri primi troncabili

Il numero 3797 ha una proprietà interessante. Essendo primo se stesso, è possibile rimuovere continuamente i numeri da sinistra a destra, e rimanere primo in ogni fase: 3797, 797, 97 e 7. Allo stesso modo possiamo lavorare da destra a sinistra: 3797, 379, 37 e 3.

Trova la somma degli unici undici numeri primi che sono entrambi troncabili da sinistra a destra e da destra a sinistra.

NOTA: 2, 3, 5 e 7 non sono considerati numeri primi troncabili.
============================================================================

(define (creaTruncate lst)
  (let (out '())
    ; da destra
    (for (i 1 (- (length lst) 1))
      (push (slice lst 0 i) out)
    )
    ; da sinistra
    (for (i 1 (- (length lst) 1))
      (push (slice lst i) out)
    )
    out
  )
)

(setq lst '(3 7 9 7))

(creaTruncate lst)
;-> ((7) (9 7) (7 9 7) (3 7 9) (3 7) (3))

(define (int2list n)
  (let (out '())
    (while (!= n 0)
      (push (% n 10) out)
      (setq n (/ n 10))
    )
    out
  )
)

(define (list2int lst)
  (let (n 0)
    (for (i 0 (- (length lst) 1))
      (setq n (+ n (* (lst i) (pow 10 (- (length lst) i 1)))))
    )
  )
)

(define (primo? n)
  (if (= n 2) true
      (if (even? n) nil
          (if (< n 2) nil
              (= 1 (length (factor n)))))))

(define (e037)
  (local (primitrunca candidate trovati stop k i)
    (setq primitrunca '()) ;lista risultato
    (setq candidate '())   ;lista troncati
    (setq trovati 0)
    (setq i 11)
    (while (< trovati 11)
      (if (primo? i)
        (begin
          (setq candidate (creaTruncate (int2list i)))
          (setq stop nil)
          (setq k 0)
          (while (and (< k (length candidate)) (= stop nil))
            (if (not (primo? (list2int (candidate k)))) (setq stop true))
            (++ k)
          )
          (if (= stop nil)
            (begin
              ;(push (list2int (candidate (- k 1))) primitrunca)
              (push i primitrunca)
              (++ trovati)
            )
          )
        )
      );if
      (setq i (+ i 2))
      (if (= 0 (% i 10000)) (println i))
    );while
    (list (apply + primitrunca) primitrunca)
  );local
)

(e037)
;-> (748317 (739397 3797 3137 797 373 317 313 73 53 37 23))

(time (e037))
;-> 939.055

Proviamo a velocizzare l'algoritmo della funzione.
Considerazioni:
- non abbiamo bisogno di una lista per il risultato: basta usare una variabile (somma).
- non abbiamo bisogno di una lista per i numeri troncati: possiamo testarli appena generati.

Definiamo una funzione che controlla se un numero è truncabile a sinistra:

(define (truncaSX n)
  (local (i stop)
    (setq i 10)
    (while (and (<= i n) (= stop nil))
      (if (not (primo? (% n i))) (setq stop true))
      (setq i (* i 10))
    )
    (not stop)
  )
)

(truncaSX 3797)
;-> true

Definiamo una funzione che controlla se un numero è truncabile a destra:

(define (truncaDX n)
  (local (i stop)
    (setq i n)
    (while (and (!= 0 i) (= stop nil))
      (if (not (primo? i)) (setq stop true))
      (setq i (/ i 10))
    )
    (not stop)
  )
)

(truncaDX 3797)
;-> true

(define (e037)
  (local (trovati somma i)
    (setq somma 0)
    (setq i 11)
    (while (< trovati 11)
      (if (and (truncaDX i) (truncaSX i))
        (begin
          (setq somma (+ somma i))
          (++ trovati)
        )
      )
      (setq i (+ i 2))
    )
    somma
  )
)

(e037)
;-> 748317

(time (e037))
;-> 778.216
----------------------------------------------------------------------------


===========
Problema 38
===========

Multiplicazioni pandigitali

Prendi il numero 192 e moltiplicalo per i numeri 1, 2 e 3:

192 × 1 = 192
192 × 2 = 384
192 × 3 = 576

Concatenando ogni prodotto otteniamo il numero pandigitale da 1 a 9, 192384576. Chiameremo 192384576 il prodotto concatenato di 192 e (1,2,3)

Lo stesso può essere ottenuto iniziando con 9 e moltiplicando per 1, 2, 3, 4 e 5, che genera il pandigitale, 918273645, che è il prodotto concatenato di 9 e (1,2,3,4,5).

Qual è il più grande numero pandigitale da 1 a 9 (9 cifre) che può essere formato come prodotto concatenato di un numero intero con (1,2, ..., n) dove n > 1?
============================================================================

(define (pan? n)
  (cond ((or (< n 123456789) (> n 987654321) (!= 0 (% n 9))) nil)
        (true
          (let (lst '(0 -1 -1 -1 -1 -1 -1 -1 -1 -1))
            (while (!= n 0)
              (setf (lst (% n 10)) 1)
              (setq n (/ n 10))
            )
            ;(println lst)
            (if (ref '-1 lst) nil true)
          )
        )
  )
)

Per calcolare il limite superiore del ciclo basta considerare che con 10000 arriviamo a considerare numeri con 10 cifre (dobbiamo concatenare le stringhe delle moltiplicazioni), quindi questo valore è sufficiente.

(define (lim n)
  (length (append (string (* n 1)) (string (* n 2))))
)

(lim 9999)
;-> 9

(lim 10000)
;-> 10

(define (e038)
  (local (maxpandi theK theI pandisomma)
    (setq maxpandi 0)
    (setq theK 0)
    (setq theI 0)
    (for (k 1 10000)
      (setq pandisomma "")
      (for (i 1 9)
        (extend pandisomma (string (* k i)))
        (if (and (= (length pandisomma) 9) (> (int pandisomma) maxpandi) (pan? (int pandisomma)))
          (begin
            (setq maxpandi (int pandisomma))
            (setq theK k)
            (setq theI i)
          )
        )
      )
    )
    (list maxpandi theK theI)
  );local
)

(e038)
;-> (932718654 9327 2)

str(9327*1) + str(9327*2) = "932718654"

(time (e038))
;-> 93.757
----------------------------------------------------------------------------


===========
Problema 39
===========

Triangoli rettangoli interi

Se p è il perimetro di un triangolo rettangolo con lati di lunghezza intera, {a, b, c}, ci sono esattamente tre soluzioni per p = 120.

{20,48,52}, {24,45,51}, {30,40,50}

Per quale valore di p ≤ 1000, il numero di soluzioni è massimizzato?
============================================================================

(define (e039)
  (local (qmax lst a b p q)
    (setq qmax 0)
    (setq lst '())
    (for (p 12 1000 2)
      (setq q 0)
      (setq a 1)
      (while (< a (/ p 3))
        (setq b (+ a 1))
        (setq stop nil)
        (while (and (= stop nil) (< b (- p a)))
          (if (= (pow (- p a b) 2) (+ (* a a) (* b b)))
            (begin
              (++ q)
              (setq stop true)
            )
          )
          (++ b)
        )
        (++ a)
      )
      (if (> q qmax)
        (begin
          (setq lst (list p q))
          (setq qmax q)
        )
      )
    )
    lst
  );local
)

(e039)
;-> (840 8)

(time (e039))
;-> 13485.51
----------------------------------------------------------------------------


===========
Problema 40
===========

La costante di Champernowne

Una frazione decimale irrazionale viene creata concatenando gli interi positivi:

0.12345678910(1)112131415161718192021 ...

Si può vedere che la dodicesima cifra della parte frazionaria è (1).

Se d(n) rappresenta l'ennesima cifra della parte frazionaria, trovare il valore della seguente espressione:

d(1) × d(10) × d(100) × d(1000) × d(10000) × d(100000) × d(1000000)
============================================================================

La lunghezza della costante di Champernowne supera (di poco) il milione quando si arriva a concatenare il numero 186000:

(length (join (map string (sequence 0 186000))))
;-> 1004896

Quindi usiamo questo valore come limite per la creazione delle cifre del risultato:

(define (e040)
  (local (num cifre val x stop sol)
    (setq lst '())
    (setq stop nil)
    (setq num 1)
    (while (and (< num 186000) (= stop nil))
      (setq cifre (length (string num)))
      (setq val num)
      (for (i cifre 1 -1)
        (setq x (/ val (pow 10 (- i 1))))
        (setq val (- val (* x (pow 10 (- i 1)))))
        (push x lst -1)
      )
      ;(if (> (length lst) 1000000) (setq stop true))
      (++ num)
      ;(if (= (% num 10000) 0) (println num { } (length lst)))
    )
    (* (lst 0) (lst 9) (lst 99) (lst 999) (lst 9999) (lst 99999) (lst 999999))
  )
)

(e040)
;-> 210

(time (e040))
;-> 640.584

Proviamo un altro metodo, creiamo una stringa che contiene almeno 1000000 di cifre e poi calcoliamo il risultato della moltiplicazione:

(define (e040)
  (let (a$ (join (map string (sequence 1 186000))))
    (* (int (a$ 0)) (int (a$ 9)) (int (a$ 99)) (int (a$ 999)) (int (a$ 9999)) (int (a$ 99999)) (int (a$ 999999)))
  )
)

(e040)
;-> 210

(time (e040))
;-> 140.625
----------------------------------------------------------------------------


===========
Problema 41
===========

Primo Pandigitale

Diremo che un numero a una cifra è pandigitale se fa uso di tutte le cifre da 1 a n esattamente una volta. Ad esempio, 2143 è un pandigitale a 4 cifre ed è anche primo.

Qual è il più grande numero primo pandigitale ad n-cifre esistente?
============================================================================

I numeri pandigitali (0..9), quelli (1..9) e quelli (1..8) non sono primi perchè sono tutti divisibili per 9 (in quanto la somma delle loro cifre vale 9).
Quindi consideriamo solo i numeri pandigitali fino a 7 cifre.

Possiamo iniziare a creare tutte le permutazioni di 7 cifre e cercare il numero primo massimo (se esiste).
Poi potremmo passare ai numeri con 6 cifre, e via di questo passo.

Funzione per le permutazioni:

(define (rimuovi x lst)
  (cond
    ((null? lst) '())
    ((= x (first lst)) (rimuovi x (rest lst)))
    (true (cons (first lst) (rimuovi x (rest lst))))))

(define (permutazioni lst)
  (cond
    ((= (length lst) 1)(list lst))
    (true (apply append(map(lambda (i) (map (lambda (j)(cons i j))
                                            (permutazioni (rimuovi i lst)))) lst)))))

Funzione test numero primo:

(define (primo? n)
   (if (< n 2) nil
       (= 1 (length (factor n)))))

Scriviamo la funzione finale:

(define (e041)
  (local (perm num primi)
    ;crea le permutazioni
    (setq perm (permutazioni '("1" "2" "3" "4" "5" "6" "7")))
    ; crea la lista dei numeri
    (setq num (map (fn (x) (int (join x))) perm))
    ;filtra i numeri primi e poi cerca il valore massimo
    (apply max (filter primo? num))
  )
)

(e041)
;-> 7652413

(time (e041))
;-> 125.004
----------------------------------------------------------------------------


===========
Problema 42
===========

Numeri triangolari codificati

L'ennesimo termine della sequenza di numeri triangolari è dato da, t(n) = ½*n*(n + 1), quindi i primi dieci numeri di triangolari sono:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Convertendo ogni lettera di una parola in un numero corrispondente alla sua posizione alfabetica e aggiungendo questi valori formiamo un valore della parola. Ad esempio, il valore della parola per SKY è 19 + 11 + 25 = 55 = t10. Se il valore della parola è un numero triangolare, chiameremo la parola triangolo.

Usando il file "words.txt", un file di testo 16K contenente quasi duemila parole inglesi comuni, quante sono le parole triangolari?
============================================================================

Il file ha questa struttura:
"A","ABILITY","ABLE","ABOUT","ABOVE","ABSENCE","ABSOLUTELY",...

Rimuoviamo tutti i caratteri doppio-apice "":

(define (remove-char c from-file to-file)
    (set 'in-file (open from-file "read"))
    (set 'out-file (open to-file "write"))
    (while (set 'chr (read-char in-file))
        (if (!= chr c)
          (write-char out-file chr)))
    (close in-file)
    (close out-file)
    "fatto")

(char {"})
;-> 34

(char 34)
;-> "\""

(remove-char 34 "p042_words.txt" "words42.txt")

Il file adesso ha questa struttura:
A,ABILITY,ABLE,ABOUT,ABOVE,ABSENCE,ABSOLUTELY,

MARY,PATRICIA,LINDA,...

Importiamo il file in una lista di stringhe:

(silent (setq parole (parse (read-file "words42.txt") ",")))

Vediamo i primi cinque nomi:

(slice parole 0 5)
;-> ("A" "ABILITY" "ABLE" "ABOUT" "ABOVE")

Calcoliamo la lunghezza della parola più lunga:

(apply max (map length parole))
;-> 14

Il valore massimo di una parola vale 14 volte "Z";
(* 14 26)
;-> 364

Adesso creiamo una lista associativa (association list) tra i caratteri e il numero del relativo ordine:

(setq alfa  '(("A" 1) ("B" 2) ("C" 3) ("D" 4) ("E" 5) ("F" 6) ("G" 7) ("H" 8) ("I" 9) ("J" 10) ("K" 11) ("L" 12) ("M" 13) ("N" 14) ("O" 15) ("P" 16) ("Q" 17) ("R" 18) ("S" 19) ("T" 20) ("U" 21) ("V" 22) ("W" 23) ("X" 24) ("Y" 25) ("Z" 26)))

(lookup '"A" alfa)
;-> 1

Creiamo una lista di numeri triangolari (almeno fino a 364):

(setq tri (map (fn (n) (/ (* n (+ n 1)) 2)) (sequence 1 27)))
;-> (1 3 6 10 15 21 28 36 45 55 66 78 91 105 120 136 153 171 190 210 231 253 276 300 325 351 378)

Calcoliamo il valore della parola "ABILITY";

(setq valore 0)
(dolist (el (explode "ABILITY"))
  (setq valore (+ valore (lookup el alfa)))
)

;-> 78
A =  1
B =  2
I =  9
L = 12
I =  9
T = 20
Y = 25
   ----
    78

Vediamo se è un numero triangolare:

(ref 78 tri)
;-> (11)

Si tratta dell'undicesimo numero triangolare (se non fosse triangolare avremmo ottenuto nil dalla funzione "ref")

Possiamo scrivere la funzione finale:

(define (e042)
  (local (alfa tri valore out)
    (setq out 0)
    (setq alfa  '(("A" 1) ("B" 2) ("C" 3) ("D" 4) ("E" 5) ("F" 6) ("G" 7) ("H" 8) ("I" 9) ("J" 10) ("K" 11) ("L" 12) ("M" 13) ("N" 14) ("O" 15) ("P" 16) ("Q" 17) ("R" 18) ("S" 19) ("T" 20) ("U" 21) ("V" 22) ("W" 23) ("X" 24) ("Y" 25) ("Z" 26)))
    (setq tri (map (fn (n) (/ (* n (+ n 1)) 2)) (sequence 1 27)))
    (setq parole (parse (read-file "words42.txt") ","))
    (dolist (parola parole)
      (setq valore 0)
      (dolist (el (explode parola))
        (setq valore (+ valore (lookup el alfa)))
      )
      (if (ref valore tri) (++ out))
    )
    out
  )
)

(e042)
;-> 162

(time (e042))
;-> 31.244
----------------------------------------------------------------------------


===========
Problema 43
===========

Divisibilità sotto-stringhe

Il numero, 1406357289, è un numero da 0 a 9 pandigitale perché è composto da ciascuna delle cifre da 0 a 9 in un certo ordine, ma ha anche una proprietà di divisibilità della sotto-stringhe piuttosto interessante.

Sia d(1) la prima cifra, d(2) la seconda cifra e così via. In questo modo, notiamo quanto segue:

d(2)d(3)d(4) = 406 è divisibile per 2
d(3)d(4)d(5) = 063 è divisibile per 3
d(4)d(5)d(6) = 635 è divisibile per 5
d(5)d(6)d(7) = 357 è divisibile per 7
d(6)d(7)d(8) = 572 è divisibile per 11
d(7)d(8)d(9) = 728 è divisibile per 13
d(8)d(9)d(10) = 289 è divisibile per 17

Trovare la somma di tutti i numeri pandigital da 0 a 9 con questa proprietà.
============================================================================

Se d(4)d(5)d(6) è divisibile per 5, allora d(6) deve valere 5 (d(5) se zero-based).

(define (list2int lst)
  (let (n 0)
    (for (i 0 (- (length lst) 1))
      (setq n (+ n (* (lst i) (pow 10 (- (length lst) i 1)))))
    )
  )
)

(define (insert l n e)
  (if (= 0 n)
      (cons e l)
      (cons (first l)
            (insert (rest l) (- n 1) e))))

(define (seq start end)
  (if (= start end)
      (list end)
      (cons start (seq (+ start 1) end))))

(define (permute l)
  (if (null? l) '(())
      (apply append (map (lambda (p)
                           (map (lambda (n) (insert p n (first l))) (seq 0 (length p))))
                         (permute (rest l))))))

(define (e043)
  (local (numeri p10 a)
    (setq numeri '())
    (setq p10 (permute '(0 1 2 3 4 6 7 8 9)))
    (dolist (p p10)
      (if (!= (p 0) 0) ;scartare le permutazioni che iniziano con 0
        (begin
          (push 5 p 5) ; p(5) deve valere 5
          (setq n1 (+ (* (p 1) 100) (* (p 2) 10) (p 3)))
          (setq n2 (+ (* (p 2) 100) (* (p 3) 10) (p 4)))
          (setq n3 (+ (* (p 3) 100) (* (p 4) 10) (p 5)))
          (setq n4 (+ (* (p 4) 100) (* (p 5) 10) (p 6)))
          (setq n5 (+ (* (p 5) 100) (* (p 6) 10) (p 7)))
          (setq n6 (+ (* (p 6) 100) (* (p 7) 10) (p 8)))
          (setq n7 (+ (* (p 7) 100) (* (p 8) 10) (p 9)))
          (if (and (= (% n1 2) 0) (= (% n2 3) 0) (= (% n3 5) 0) (= (% n4 7) 0)
                   (= (% n5 11) 0) (= (% n6 13) 0) (= (% n7 17) 0))
              (push (list2int p) numeri)
          )
        )
      )
    )
    (list (apply + numeri) numeri)
  )
)

(e043)
;-> (16695334890 (4130952867 1430952867 4160357289 4106357289 1460357289 1406357289))

(time (e043))
;-> 1748.593
----------------------------------------------------------------------------


===========
Problema 44
===========

Numeri pentagonali

I numeri pentagonali sono generati dalla formula, P(n) = n*(3n-1)/2. I primi dieci numeri pentagonali sono:

1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

Si può vedere che P4 + P7 = 22 + 70 = 92 = P8. Tuttavia, la loro differenza, 70 - 22 = 48, non è pentagonale.

Trovare la coppia di numeri pentagonali, P(j) e P(k), per cui la loro somma e differenza sono pentagonali e D = |P(k) - P(j)| è ridotto al minimo: qual è il valore di D?
============================================================================

P(n) n-esimo numero pentagonale
N = numero dato

Affinchè un numero N sia pentagonale deve risultare:

P(n) = N  ==>  (3*n*n - n - 2*N) = 0  ==>  n = (1 + sqrt(24*N + 1))/6

Prima versione:

(define (penta? n)
  (let (i (div (add (sqrt (add 1 (mul 24 n))) 1) 6))
    (if (= 0 (sub i (int i))) true nil)
  )
)

Seconda versione (più veloce):

(define (penta? n)
; molto più veloce che cercare nella lista dei numeri pentagonali
  (if (= (mod (div (add (sqrt (+ 1 (mul 24 n))) 1) 6) 1) 0) true nil)
)

(penta? 176)
;-> true

(define (e044)
  (local (n penta stop i j out)
    (setq out nil)
    (setq penta (map (fn (n) (/ (* n (- (* 3 n) 1)) 2)) (sequence 1 10000)))
    (setq stop nil)
    (dolist (i penta (= stop true))
      (dolist (j penta (= stop true))
        (if (and (penta? (+ i j)) (penta? (abs (- i j))))
          (begin
            (setq stop true)
            (setq out (list i j (- j i)))
          )
        )
      )
    )
    out
  )
)

(e044)
;-> (1560090 7042750 5482660)

(time (e044))
;-> 5588.505
----------------------------------------------------------------------------


===========
Problema 45
===========

Triangolari, pentagonali ed esagonali

I numeri triangolari, pentagonali ed esagonali sono generati dalle seguenti formule:

Triangolari T(n) = n*(n + 1)/2 ==> 1, 3, 6, 10, 15, ...
Pentagonala P(n) = n*(3*n-1)/2 ==> 1, 5, 12, 22, 35, ...
Esagonale   H(n) = n*(2*n-1)   ==> 1, 6, 15, 28, 45, ...

Si può verificare che T(285) = P(165) = H(143) = (40755)

Trovare il prossimo numero triangolare che è anche pentagonale ed esagonale.
============================================================================

(define (tri n) (/ (* n (+ n 1)) 2))
(define (pen n) (/ (* n (- (* 3 n) 1)) 2))
(define (esa n) (* n (- (* 2 n) 1)))

(tri 285)
;-> 40755
(pen 165)
;-> 40755
(esa 143)
;-> 40755

Deve risultare:

t*(t + 1)/2 == p*(3*p-1)/2 == x*(2*x-1)

dove t -> indice triangolari
dove p -> indice pentagonali
dove x -> indice esagonali

La soluzione dell'uguaglianza:

t*(t + 1)/2 == x*(2*x-1)

vale: x = (t + 1)/2, t = 2*x - 1

Per t = 285 otteniamo x = (285 + 1)/2 = 143

Definiamo una funzione che genera l'indice del numero esagonale utilizzando l'indice del numero triangolare:

(define (xidx t) (/ (+ t 1) 2))

(xidx 285)
;-> 143

Vediamo come funziona:

(for (i 285 301 2)
  (println (tri i) { } (esa (xidx i))))
;-> 40755 40755
;-> 41328 41328
;-> 41905 41905
;-> 42486 42486
;-> 43071 43071
;-> 43660 43660
;-> 44253 44253
;-> 44850 44850
;-> 45451 45451

Adesso generiamo le tre sequenze di numeri:

(silent (setq trian (map tri (sequence 0 100000))))
(silent (setq penta (map pen (sequence 0 100000))))
(silent (setq esago (map esa (sequence 0 100000))))

Possiamo scrivere la soluzione controllando per ogni valore dell'indice del numero triangolare se esiste quel valore del numero triangolare nella lista dei numeri pentagonali:

(define (e045)
  (local (stop i)
    (setq i 287)
    (setq stop nil)
    (while (= stop nil)
      (setq x (xidx i))
      ;(if (ref (esa x) penta) (begin (println i { } x { } (ref (esa x) penta) { } (esa x)) (setq stop true)))
      (if (ref (tri i) penta) (begin (println i { } x { } (ref (esa x) penta) { } (esa x)) (setq stop true)))
      (if (zero? (% i 1000))  (println i))
      (setq i (+ i 2))
    )
  )
)

(e045)
;-> 55385 27693 (31977) 1533776805

(time (e045))
;-> 19343.289

Possiamo usare la funzione "intersect" di newLISP per trovare il risultato:

(define (e045)
  (local (trian penta esago)
    (setq trian (map tri (sequence 1 100000)))
    (setq penta (map pen (sequence 1 100000)))
    (setq esago (map esa (sequence 1 100000)))
    (intersect (intersect trian penta) esago)
  )
)

(e045)
;-> (1 40755 1533776805)

(time (e045))
;-> 114.465

Questa soluzione è molto più veloce.
----------------------------------------------------------------------------


===========
Problema 46
===========

L'altra congettura di Goldbach

È stato proposto da Christian Goldbach che ogni numero composito dispari può essere scritto come la somma di un numero primo e due volte un quadrato.

9 = 7 + 2 × 1^2
15 = 7 + 2 × 2^2
21 = 3 + 2 × 3^2
25 = 7 + 2 × 3^2
27 = 19 + 2 × 2^2
33 = 31 + 2 × 1^2

Si scopre che la congettura era falsa.

Qual'è il più piccolo numero composito dispari che non può essere scritto come somma di un numero primo e due volte quadrato?
============================================================================

Per ogni numero dispari x:
- se x è un numero composito (cioè è un numero non primo) ==> non trovato
- per i che va da 1 a (* i i 2) se (x - i * i * 2) è primo ==> non trovato
  altrimenti ==> trovato

Funzione per i numeri primi:

(define (primo? n)
   (if (< n 2) nil
       (= 1 (length (factor n)))))

Funzione che controlla se un numero soddisfa la congettura (se il numero è primo non soddisfa la congettura):

(define (check x)
  (local (out i stop limite)
    (cond ((primo? x) (setq out true))
          (true
            (setq i 1)
            (setq stop nil)
            (setq limite (* i i 2))
            (while (and (<= limite x) (= stop nil))
              (if (primo? (- x (* i i 2))) (begin (setq stop true) (setq out true)))
              (++ i)
              (setq limite (* i i 2))
            )
          )
    )
    out
  )
)

Scriviamo la funzione finale:

(define (e046)
  (local (num trovato)
    (setq num 11)
    (setq trovato false)
    (while (= trovato nil)
      (if (= (check num) nil) (setq trovato true))
      (setq num (+ num 2))
    )
    (- num 2)
  )
)


(e046)
;-> 5777

(time (e046))
;-> 31.247
----------------------------------------------------------------------------


===========
Problema 47
===========

Fattori primi distinti

I primi due numeri consecutivi con due fattori primi distinti sono:

14 = 2 × 7
15 = 3 × 5

I primi tre numeri consecutivi con tre fattori primi distinti sono:

644 = 2² × 7 × 23
645 = 3 × 5 × 43
646 = 2 × 17 × 19.

Trova i primi quattro numeri interi consecutivi con quattro fattori primi distinti ciascuno. Qual è il primo di questi numeri?
============================================================================

Funzione che calcola il numero di fattori primi distitni di un numero:

(define (numFattDist n) (length (unique (factor n))))

(numFattDist 12345)
;-> 3

Possiamo scrivere la funzione finale:

(define (e047)
  (local (stop i)
    (setq i 134043)
    (while (= stop nil)
      (if (and (= (numFattDist i) 4)
               (= (numFattDist (+ i 1)) 4)
               (= (numFattDist (+ i 2)) 4)
               (= (numFattDist (+ i 3)) 4))
          (setq stop true)
      )
      (++ i)
      (if (= (% i 1000000) 0) (println i))
    )
    (-- i)
  )
)

(e047)
;-> 134043

(time (e047))
;-> 0
----------------------------------------------------------------------------


===========
Problema 48
===========

Auto potenze

La serie, 1^1 + 2^2 + 3^3 + ... + 10^10 = 10405071317.

Trova le ultime dieci cifre della serie, 1^1 + 2^2 + 3^3 + ... + 1000^1000.
============================================================================

Funzione che calcola la potenza di numeri interi (anche per numeri big integer):

(define (potenza n m)
  (setq pot 1L)
  (dotimes (x m)
    (setq pot (* pot n))
  )
  pot
)

Creiamo una lista con tutti i numeri da 1 a 1000 elevati a se stessi:
(setq a (map (fn (x) (potenza x x)) (sequence 1L 1000L)))

Sommiano tutti i valori della lista:
(setq b (apply + a))

Trasformiano il numero somma in stringa ed estraiamo le ultime 10 cifre (senza la L finale):
(setq c (pop (string b) -11 10))
;-> "9110846700"

Scriviamo la funzione:

(define (e048)
  (pop (string (apply + (map (fn (x) (potenza x x)) (sequence 1L 1000L)))) -11 10)
)

(e048)
;-> "9110846700"

(time (e048))
;-> 265.614
----------------------------------------------------------------------------


===========
Problema 49
===========

Permutazioni prime

La sequenza aritmetica, 1487, 4817, 8147, in cui ciascun termine aumenta di 3330, è inusuale in due modi: (i) ciascuno dei tre termini è primo, e (ii) ciascuno dei numeri a 4 cifre è una permutazione degli altri.

Non ci sono sequenze aritmetiche composte da tre numeri primi di 1, 2 o 3 cifre, che esibiscono questa proprietà, ma esiste un'altra sequenza crescente di 4 cifre.

Quale numero di 12 cifre si forma concatenando i tre termini in questa sequenza?
============================================================================

Funzione per i numeri primi:

(define (primo? n)
   (if (< n 2) nil
       (= 1 (length (factor n)))))

Funzione che converte un numero in una lista:

(define (int2list n)
  (let (out '())
    (while (!= n 0)
      (push (% n 10) out)
      (setq n (/ n 10))
    )
    out
  )
)

Limiti da considerare nella ricerca della soluzione: da 1001 a 9999

Filtro i numeri primi:

(setq a (filter primo? (sequence 1001 9999)))
(length a)
;-> 1061

Funzione che controlla se due numeri hanno le stesse cifre:

(define (cifreUguali x y)
  (if (= (sort (int2list x)) (sort (int2list y))))
)

(cifreUguali 1234 4231)
;-> true

Controllo tutti gli elementi della lista dei numeri primi per vedere se soddisfano le condizioni del problema:

(dolist (el a)
  (setq a1 el)
  (setq a2 (+ a1 3330))
  (setq a3 (+ a2 3330))
  (if (and (primo? a2) (primo? a3) (cifreUguali a1 a2) (cifreUguali a2 a3))
    (println a1 { } a2 { } a3)
  )
)
;-> 1487 4817 8147
;-> 2969 6299 9629

Possiamo scrivere la funzione finale:

(define (e049)
  (local (primi a1 a2 a3 out)
    (setq primi (filter primo? (sequence 1001 9999)))
    (dolist (el primi)
      (setq a1 el)
      (setq a2 (+ a1 3330))
      (setq a3 (+ a2 3330))
      (if (and (primo? a2) (primo? a3) (cifreUguali a1 a2) (cifreUguali a2 a3))
        (setq out (string a1 a2 a3))
        ;(println a1 { } a2 { } a3)
      )
    )
    out
  )
)

(e049)
;-> "296962999629"

(time (e049))
;-> 9.01
----------------------------------------------------------------------------


===========
Problema 50
===========

Somma di primi consecutivi

Il primo 41 può essere scritto come la somma di sei numeri primi consecutivi:

41 = 2 + 3 + 5 + 7 + 11 + 13

Questa è la somma più lunga di numeri primi consecutivi che si aggiunge a un numero primo inferiore a cento.

La somma più lunga di numeri primi consecutivi al di sotto di un migliaio che aggiunge un numero primo, contiene 21 termini ed è uguale a 953.

Quale primo, inferiore a un milione, può essere scritto come la somma dei numeri primi più consecutivi?
============================================================================

Funzione per i numeri primi:

(define (primo? n)
   (if (< n 2) nil
       (= 1 (length (factor n)))))

Limiti da considerare nella ricerca della soluzione: da 2 a 1000000

Filtro i numeri primi:

(silent (setq primi (filter primo? (sequence 2 1000000))))
(length primi)
;-> 78490

(slice primi 0 10)

(define (e050)
  (local (primi lenprimi somma sommaMax limite i j stop)
    (setq somma 0)
    (setq limite -1)
    (setq primi (filter primo? (sequence 2 1000000)))
    (setq lenprimi (length primi))
    (setq i 2)
    (while (< i lenprimi)
      (setq somma 0)
      (setq stop nil)
      (setq j i)
      (while (and (< j lenprimi) (= stop nil))
        (setq somma (+ somma (primi j)))
        (if (> somma 1000000) (setq stop true)
        ;else
        (if (and (> (- j i) limite) (> somma sommaMax) (primo? somma))
          (begin
            (setq sommaMax somma)
            (setq limite (- j i))
          )
        ))
        (++ j)
      )
      (++ i)
      ;(if (= (% i 10000)) (println i))
    )
    sommaMax
  )
)

(e050)
;-> 997651

(time (e050))
;-> 27113

I numeri coinvolti nella soluzione sono i seguenti:

(997651 543 (7 11 13 17 19 23 29 31 37 41 43 47 53
59 61 67 71 73 79 83 89 97 101 103 107 109 113 127
131 137 139 149 151 157 163 167 173 179 181 191 193
197 199 211 223 227 229 233 239 241 251 257 263 269
271 277 281 283 293 307 311 313 317 331 337 347 349
353 359 367 373 379 383 389 397 401 409 419 421 431
433 439 443 449 457 461 463 467 479 487 491 499 503
509 521 523 541 547 557 563 569 571 577 587 593 599
601 607 613 617 619 631 641 643 647 653 659 661 673
677 683 691 701 709 719 727 733 739 743 751 757 761
769 773 787 797 809 811 821 823 827 829 839 853 857
859 863 877 881 883 887 907 911 919 929 937 941 947
953 967 971 977 983 991 997 1009 1013 1019 1021 1031
1033 1039 1049 1051 1061 1063 1069 1087 1091 1093 1097
1103 1109 1117 1123 1129 1151 1153 1163 1171 1181 1187
1193 1201 1213 1217 1223 1229 1231 1237 1249 1259 1277
1279 1283 1289 1291 1297 1301 1303 1307 1319 1321 1327
1361 1367 1373 1381 1399 1409 1423 1427 1429 1433 1439
1447 1451 1453 1459 1471 1481 1483 1487 1489 1493 1499
1511 1523 1531 1543 1549 1553 1559 1567 1571 1579 1583
1597 1601 1607 1609 1613 1619 1621 1627 1637 1657 1663
1667 1669 1693 1697 1699 1709 1721 1723 1733 1741 1747
1753 1759 1777 1783 1787 1789 1801 1811 1823 1831 1847
1861 1867 1871 1873 1877 1879 1889 1901 1907 1913 1931
1933 1949 1951 1973 1979 1987 1993 1997 1999 2003 2011
2017 2027 2029 2039 2053 2063 2069 2081 2083 2087 2089
2099 2111 2113 2129 2131 2137 2141 2143 2153 2161 2179
2203 2207 2213 2221 2237 2239 2243 2251 2267 2269 2273
2281 2287 2293 2297 2309 2311 2333 2339 2341 2347 2351
2357 2371 2377 2381 2383 2389 2393 2399 2411 2417 2423
2437 2441 2447 2459 2467 2473 2477 2503 2521 2531 2539
2543 2549 2551 2557 2579 2591 2593 2609 2617 2621 2633
2647 2657 2659 2663 2671 2677 2683 2687 2689 2693 2699
2707 2711 2713 2719 2729 2731 2741 2749 2753 2767 2777
2789 2791 2797 2801 2803 2819 2833 2837 2843 2851 2857
2861 2879 2887 2897 2903 2909 2917 2927 2939 2953 2957
2963 2969 2971 2999 3001 3011 3019 3023 3037 3041 3049
3061 3067 3079 3083 3089 3109 3119 3121 3137 3163 3167
3169 3181 3187 3191 3203 3209 3217 3221 3229 3251 3253
3257 3259 3271 3299 3301 3307 3313 3319 3323 3329 3331
3343 3347 3359 3361 3371 3373 3389 3391 3407 3413 3433
3449 3457 3461 3463 3467 3469 3491 3499 3511 3517 3527
3529 3533 3539 3541 3547 3557 3559 3571 3581 3583 3593
3607 3613 3617 3623 3631 3637 3643 3659 3671 3673 3677
3691 3697 3701 3709 3719 3727 3733 3739 3761 3767 3769
3779 3793 3797 3803 3821 3823 3833 3847 3851 3853 3863
3877 3881 3889 3907 3911 3917 3919 3923 3929 3931))
----------------------------------------------------------------------------


===========
Problema 51
===========

Sostituzioni di cifre nei numeri primi

Sostituendo la prima cifra del numero a 2 cifre *3, si scopre che sei dei nove valori possibili: 13, 23, 43, 53, 73 e 83, sono tutti primi.

Sostituendo la terza e la quarta cifra di 56**3 con la stessa cifra, questo numero di 5 cifre è il primo esempio con sette numeri primi tra i dieci numeri generati, dando la famiglia: 56003, 56113, 56333, 56443, 56663, 56773 e 56993. Di conseguenza 56003, essendo il primo membro di questa famiglia, è il primo più piccolo con questa proprietà.

Trova il primo più piccolo che, sostituendo parte del numero (non necessariamente cifre adiacenti) con la stessa cifra, fa parte di una famiglia di otto valori primi.
============================================================================

Prima di scrivere la soluzione abbiamo bisogno di alcune funzioni ausiliarie.

Funzione che genera tutti i numeri primi da m a n:

(define (sieve-from-to m n)
  (local (arr lst out)
    (setq out '())
    (setq arr (array (+ n 1)) lst '(2))
    (for (x 3 n 2)
        (when (not (arr x))
          (push x lst -1)
          (for (y (* x x) n (* 2 x) (> y n))
              (setf (arr y) true))))
    (if (<= m 2)
        lst
        (dolist (el lst) (if (>= el m) (push el out -1)))
    )
  )
)

Funzione che conta le occorrenze di un carattere in una stringa:

(define (conta-char stringa carattere)
  (let (out 0)
    (dolist (el (explode stringa))
      (if (= carattere el) (++ out))) out))

(conta-char "451234555" "5")
;-> 4

Funzione che sostituisce caratteri (char-old -> char-new) in una stringa:

(define (cambia-char stringa char-old char-new)
  (let (out "")
    (dolist (el (explode stringa))
      (if (= char-old el)
        (write out char-new)
        (write out el)))
    out))

(cambia-char "12345543215" "5" "0")
;-> "12340043210"

Funzione che verifica la primalità di un numero:

(define (primo? n)
  (if (< n 2) nil
    (if (= 1 (length (factor n))))))

Infine la funzione soluzione (brute-force):

(define (e051 n)
  (local (cycleMaxL primi numS ciclo cycleL uguali newnum found)
    (setq found nil)
    (setq primi (sieve-from-to 100000 n))
    (dolist (num primi found)
      (setq numS (string num))
      (dolist (cifra (explode "1234567890") found)
        (setq ciclo 0)
        (setq cycleL '())
        (setq uguali (conta-char numS cifra))
        (if (= uguali 3)
          ;(dolist (nuovo (explode "1234567890"))
          (dolist (nuovo (explode "1234567890") found)
            (setq newnum (cambia-char numS cifra nuovo))
            (if (= (length newnum) (length numS))
              (if (primo? (int newnum))
                (begin (++ ciclo)
                       (push (int newnum) cycleL -1))
              )
            )
          )
        )
        (if (> (length cycleL) (length cycleMaxL))
          (begin (setq cycleMaxL cycleL)
                 (if (>= (length cycleMaxL) 8)
                   (begin (setq found true)
                    (println "Sol: " numS { } (slice cycleMaxL 0 8)))
                    ;(println "Sol: " numS { } cycleMaxL)))
                 ))
        )
      )
    )
    'end
  )
)

(e051 999999)
;-> Sol: 121313 (121313 222323 323333 424343 525353 626363 828383 929393)
;-> end

(time (e051 999999))
;-> Sol: 121313 (121313 222323 323333 424343 525353 626363 828383 929393)
;-> 269.946
----------------------------------------------------------------------------


===========
Problema 52
===========

Permutazione di multipli

Si può vedere che il numero 125874 e il suo doppio 251748 contengono esattamente le stesse cifre, ma in un ordine diverso.

Trova il numero intero positivo più piccolo x, tale che 2x, 3x, 4x, 5x e 6x contengano le stesse cifre.
============================================================================

Funzione che verifica se due numeri hanno le stesse cifre:

(define (same-digit m n)
  (if (!= (length m) (length n))
      nil
      (= (sort (explode (string m))) (sort (explode (string n))))))

(same-digit 1234 4321)
;-> true

(same-digit 12341 4321)
;-> nil

(define (e052)
  (let ((i 10)
        (continua true))
    (while continua
      (if (and (same-digit i (* 2 i))
               (same-digit i (* 3 i))
               (same-digit i (* 4 i))
               (same-digit i (* 5 i))
               (same-digit i (* 6 i)))
          (setq continua nil))
      (++ i)
    )
    (- i 1)))

(e052)
;-> 142857

(time (e052))
;-> 313.15
----------------------------------------------------------------------------


===========
Problema 53
===========

Selezione di combinazioni

Esistono esattamente dieci modi per selezionare tre cifre tra cinque cifre 1, 2, 3, 4 e 5): 123, 124, 125, 134, 135, 145, 234, 235, 245 e 345
                                      (5)
In combinatoria, si usa la notazione, ( ) = 10.
                                      (3)

In generale,

(n)         n!
( ) = --------------- , dove r <= n
(r)    r! * (n - r)!

e n! = 1 * 2 * 3 * ... * (n - 1) * n

Il numero n = 23 ha il primo valore che supera il milione:

(23)
(  ) = 1144066
(10)
                                                (n)
Quanti valori, non necessariamente distinti, di (r) per 1<=n<=100, sono maggiori di un milione?
============================================================================

Formula che calcola il binomiale (big-integer):

(define (binom n k)
  (local (M q)
    (setq M (array (+ n 1) (+ k 1) '(0L)))
    (for (i 0 n)
      (setq q (min i k))
      (for (j 0 q)
        (if (or (= j 0) (= j i))
          (setq (M i j) 1L)
          (setq (M i j) (+ (M (- i 1) (- j 1)) (M (- i 1) j)))
        )
      )
    )
    (M n k)
  );local
)

(binom 23 10)
;-> 1144066L

Funzione soluzione:

(define (e053 n)
  (let (quanti 0)
    (for (i 1 n)
      (for (j 1 i)
        (if (> (binom i j) 1e6) (++ quanti))))
    quanti))

(e053 100)
;-> 4075

(time (e053 100))
;-> 6231.481

Per velocizzare la soluzione, proviamo a non usare i big integer nella funzione che calcola il binomiale.

(define (binom n k)
  (local (M q)
    (setq M (array (+ n 1) (+ k 1) '(0)))
    (for (i 0 n)
      (setq q (min i k))
      (for (j 0 q)
        (if (or (= j 0) (= j i))
          (setq (M i j) 1)
          (setq (M i j) (+ (M (- i 1) (- j 1)) (M (- i 1) j)))
        )
      )
    )
    (M n k)
  );local
)

(binom 23 10)
;-> 1144066

I numeri binomiali che superano il valore massimo per gli int64 diventano negativi, quindi usiamo la funzione "abs" per considerarli maggiori di 10 milioni.

(define (e053 n)
  (let (quanti 0)
    (for (i 1 n)
      (for (j 1 i)
        (if (> (abs (binom i j)) 1e6) (++ quanti))))
    quanti))

(e053 100)
;-> 4075

(time (e053 100))
;-> 3522.499

Abbiamo quasi raddoppiato la velocità, ma il problema è la lentezza della funzione che calcola il binomiale. Proviamo un altro metodo: poichè il numero n arriva solo fino a 100, possiamo precalcolare il fattoriale dei primi 100 numeri e usarli per calcolare il binomiale con la formula originale.

Funzione fattoriale (big-integer):

(define (fact n) (apply * (map bigint (sequence 1 n))))

Funzione binomiale (big-integer):

(define (bino n r) (/ (f n) (* (f r) (f (- n r)))))

Adesso riscriviamo la funzione soluzione:

(define (e053)
  (local (quanti f)
    (setq quanti 0)
    ;precalcolo dei fattoriali da 0 a 100
    (setq f (map fact (sequence 0 100)))
    (for (i 1 100)
      (for (j 1 i)
        ; la differenza tra gli indici deve essere
        ; maggiore di 0 affinchè (bino i j) possa
        ; essere maggiore di un milione.
        ; Infatti (bino x x) = 1
        (if (> (- i j) 0)
          (if (> (bino i j) 1e6) (++ quanti)))))
    quanti))

(e053)
;-> 4075

(time (e053))
;-> 25.013

Questa volta la risposta di newLISP è immediata.
----------------------------------------------------------------------------


===========
Problema 54
===========

Mani di poker

Nel gioco del poker, una mano è composta da cinque carte e sono classificate, dalla più bassa alla più alta, nel modo seguente:

Carta alta: carta di valore più alto.
Una coppia: due carte dello stesso valore.
Due coppie: due coppie diverse.
Tris: tre carte dello stesso valore.
Scala: tutte le carte hanno valori consecutivi.
Colore: tutte le carte sono dello stesso seme.
Full: un tris e una coppia.
Poker: quattro carte dello stesso valore.
Scala reale: tutte le carte sono valori consecutivi dello stesso seme.
Scala reale massima: dieci, Jack, Queen, King, Asso dello stesso seme.
Le carte sono valutate nell'ordine:
2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, King, Asso

Se due giocatori hanno mani dello stesso valore, allora vince quello che ha il valore composto più alto(per esempio, una coppia di otto batte una coppia di cinque, vedi esempio 1 sotto). Ma se abbiamo un pareggio tra ranghi uguali, ad esempio entrambi i giocatori hanno una coppia di regine, vengono confrontate le carte più alte in ogni mano (vedi esempio 4 di seguito). Se le carte più alte sono uguali, allora vengono confrontate le carte più alte successive e così via.

Considera le seguenti cinque mani distribuite a due giocatori:

Hand   Player 1             Player 2               Winner
1      5H 5C 6S 7S KD       2C 3S 8S 8D TD         Player 2
       Pair of Fives        Pair of Eights

2      5D 8C 9S JS AC       2C 5C 7D 8S QH         Player 1
       Highest card Ace     Highest card Queen

3      2D 9C AS AH AC       3D 6D 7D TD QD         Player 2
       Flush with Diamonds  Three Aces

4      4D 6S 9H QH QC       3D 6D 7H QD QS         Player 1
       Pair of Queens       Pair of Queens
       Highest card Nine    Highest card Seven

5      2H 2D 4C 4D 4S       3C 3D 3S 9S 9D         Player 1
       Full House           Full House
       With Three Fours     with Three Threes

Il file "poker.txt" contiene mille mani casuali distribuite a due giocatori. Ogni riga del file contiene dieci carte (separate da un singolo spazio): le prime cinque sono le carte del giocatore 1 e le ultime cinque sono le carte del giocatore 2. Puoi presumere che tutte le mani siano valide (nessun carattere non valido o carte ripetute), la mano di ogni giocatore non è in un ordine specifico e in ogni mano c'è un chiaro vincitore.

Quante mani vince il giocatore 1?
============================================================================

Vediamo come vengono rappresentati i semi:

H = Hearts (Cuori)
D = Diamonds (Quadri)
C = Clubs (Fiori)
S = Spades (Picche)

Vediamo i passi della soluzione con il file "poker.txt" (che ha solo 10 mani):

(setq raw (read-file "poker.txt"))
"8C TS KC 9H 4S 7D 2S 5D 3S AC\r\n
 5C AD 5D AC 9C 7C 5H 8D TD KS\r\n
 3H 7H 6S KC JS QH TD JC 2D 8S\r\n
 TH 8H 5C QS TC 9H 4D JC KS JS\r\n
 7C 5H KC QH JD AS KH 4C AD 4S\r\n
 5H KS 9C 7D 9H 8D 3S 5D 5C AH\r\n
 6H 4H 5C 3H 2H 3S QH 5S 6S AS\r\n
 TD 8C 4H 7C TC KC 4C 3H 7S KS\r\n
 7C 9C 6D KD 3H 4C QS QC AC KH\r\n
 JC 6S 5H 2H 2D KD 9D 7C AS JS"

Usiamo la funzione "parse" per ottenere solo una stringa che rappresenta una mano:

(setq data (parse raw "\r\n"))
;-> ("8C TS KC 9H 4S 7D 2S 5D 3S AC"
;->  "5C AD 5D AC 9C 7C 5H 8D TD KS"
;->  "3H 7H 6S KC JS QH TD JC 2D 8S"
;->  "TH 8H 5C QS TC 9H 4D JC KS JS"
;->  "7C 5H KC QH JD AS KH 4C AD 4S"
;->  "5H KS 9C 7D 9H 8D 3S 5D 5C AH"
;->  "6H 4H 5C 3H 2H 3S QH 5S 6S AS"
;->  "TD 8C 4H 7C TC KC 4C 3H 7S KS"
;->  "7C 9C 6D KD 3H 4C QS QC AC KH"
;->  "JC 6S 5H 2H 2D KD 9D 7C AS JS")

Adesso se vogliamo ottenere una lista per ogni riga, basta mappare la funzione "list" sugli elementi della lista data:

(setq data (map list data))
;-> (("8C TS KC 9H 4S 7D 2S 5D 3S AC")
;->  ("5C AD 5D AC 9C 7C 5H 8D TD KS")
;->  ("3H 7H 6S KC JS QH TD JC 2D 8S")
;->  ("TH 8H 5C QS TC 9H 4D JC KS JS")
;->  ("7C 5H KC QH JD AS KH 4C AD 4S")
;->  ("5H KS 9C 7D 9H 8D 3S 5D 5C AH")
;->  ("6H 4H 5C 3H 2H 3S QH 5S 6S AS")
;->  ("TD 8C 4H 7C TC KC 4C 3H 7S KS")
;->  ("7C 9C 6D KD 3H 4C QS QC AC KH")
;->  ("JC 6S 5H 2H 2D KD 9D 7C AS JS"))

Dobbiamo cambiare i valori dei caratteri:
('A','14')
('K','13')
('Q','12')
('J','11')
('T','10')

e creiamo la seguente struttura per i dati per ogni mano:

((valori-p1) (semi-p1) (valori-p2) (semi-p2))

(setq mani '())
(dolist (el data)
  (setq row (first el))
  ;(println row)
  (setq val-p1 (explode (select row '(0 3 6 9 12))))
  (replace "A" val-p1 "14")
  (replace "K" val-p1 "13")
  (replace "Q" val-p1 "12")
  (replace "J" val-p1 "11")
  (replace "T" val-p1 "10")
  (setq val-p1 (sort (map int val-p1)))
  (setq val-p2 (explode (select row '(15 18 21 24 27))))
  (replace "A" val-p2 "14")
  (replace "K" val-p2 "13")
  (replace "Q" val-p2 "12")
  (replace "J" val-p2 "11")
  (replace "T" val-p2 "10")
  (setq val-p2 (sort (map int val-p2)))
  ; i semi non vengono ordinati perchè ci servono
  ; solo per calcolare "colore"
  (setq sem-p1 (select row '(1 4 7 10 13)))
  (setq sem-p2 (select row '(16 19 22 25 28)))
  (push (list val-p1 sem-p1 val-p2 sem-p2) mani -1)
  mani
)

;-> (((4 8 9 10 13) "CSCHS" (2 3 5 7 14) "DSDSC")
;->  ((5 5 9 14 14) "CDDCC" (5 7 8 10 13)  "CHDDS")
;->  ((3 6 7 11 13) "HHSCS" (2 8 10 11 12) "HDCDS")
;->  ((5 8 10 10 12) "HHCSC" (4 9 11 11 13) "HDCSS")
;->  ((5 7 11 12 13) "CHCHD" (4 4 13 14 14) "SHCDS")
;->  ((5 7 9 9 13) "HSCDH" (3 5 5 8 14) "DSDCH")
;->  ((2 3 4 5 6) "HHCHH" (3 5 6 12 14) "SHSSS")
;->  ((4 7 8 10 10) "DCHCC" (3 4 7 13 13) "CCHSS")
;->  ((3 6 7 9 13) "CCDDH" (4 12 12 13 14) "CSCCH")
;->  ((2 2 5 6 11) "CSHHD" (7 9 11 13 14) "DDCSS"))

(first mani)
;-> ((4 8 9 10 13) "CSCHS" (2 3 5 7 14) "DSDSC")
(first (first mani))
;-> (4 8 9 10 13)

Adesso scriviamo la funzione che calcola il punteggio di una singola mano con i parametri "numeri" e "semi": (4 8 9 10 13) "CSCHS". Da notare che gli indici dei semi non corrispondono agli indici dei numeri. Questo perchè i semi servono solo per stabilire se sono tutti uguali (es. "CCCCC").

Esempi di utilizzo della funzione "calcola":

Input
  numeri = (2 3 4 8 10) ; numeri è ordinato
  semi = "CHCCC"
Output
  ((1 10 8 4 3 2) "High Card")
  dove 1 è il valore della mano
  e 10,8,4,3,2 sono i valori delle ordinati carte

Input
  numeri = (2 2 2 8 8) ; numeri è ordinato
  semi = "CHCCC"
Output
  ((7 2 8) "Full House")
  dove 7 è il valore della mano
  2 è il valore del tris e
  8 è il valore della coppia

(define (calcola numeri semi)
  (local (valore nome a b c)
    (setq valore '())
    (setq nome "")
    ;
    ; Flush, Straight Flush, Royal Flush
    ; Colore, Scala Reale, Scala Reale Massima
    (if (or (= semi "CCCCC") (= semi "DDDDD") (= semi "HHHHH") (= semi "SSSSS"))
        (begin
         (setq valore '(6)
               nome "Flush") ; Colore
         (if (= 4 (- (numeri 4) (numeri 0)))
             (begin
             (setq valore (list 9 (numeri 4))
                   nome "Straight Flush") ; Scala Reale
             (if (= 14 (numeri 4))
                 (setq valore (list 10 14)
                       nome "Royal Flush") ; Scala Reale Massima
             ))
         )
        )
    )
    ;
    ; Four of a Kind
    ; Poker
    (if (= valore '()) ; non abbiamo ancora catalogato la mano
        (for (i 2 14)
          (if (= (count (list i) numeri) '(4))
              (setq valore (list 8 i)
                    nome "Four of a Kind") ; Poker
          )
        )
    )
    ;
    ; Full House
    ; Full
    (if (= valore '()) ; non abbiamo ancora catalogato la mano
        (for (i 2 14)
          (if (= (count (list i) numeri) '(3))
              (for (j 2 14)
                (if (= (count (list j) numeri) '(2))
                    (setq valore (list 7 i j)
                          nome "Full House") ; Full
                )
              )
          )
        )
    )
    ;
    ; Three of a Kind
    ; Tris
    (if (= valore '()) ; non abbiamo ancora catalogato la mano
        (for (i 2 14)
          (if (= (count (list i) numeri) '(3))
              (begin
                (setq a i)
                (setq valore (list 4 i)
                      nome "Three of a Kind") ; Tris
                (for (k 4 0 -1)
                  (if (!= a (numeri k))
                      (push (numeri k) valore -1)
                  )
                )
              )
          )
        )
    )
    ;
    ; Two Pairs
    ; Doppia Coppia
    (if (= valore '()) ; non abbiamo ancora catalogato la mano
        (for (i 2 14)
          (if (= (count (list i) numeri) '(2))
              (for (j 2 14)
                (if (and (= (count (list j) numeri) '(2)) (!= i j))
                    (begin
                    (setq a (max i j))
                    (setq b (min i j))
                    (for (k 4 0 -1)
                       (if (and (!= a (numeri k)) (!= b (numeri k)))
                           (setq c (numeri k))
                       )
                    )
                    (setq valore (list 3 a b c)
                          nome "Two Pairs") ; Doppia Coppia
                ))
              )
          )
        )
    )
    ;
    ; Straight
    ; Scala
    (if (= valore '()) ; non abbiamo ancora catalogato la mano
        (if (and (= 1 (- (numeri 4) (numeri 3)))
                 (= 1 (- (numeri 3) (numeri 2)))
                 (= 1 (- (numeri 2) (numeri 1)))
                 (= 1 (- (numeri 1) (numeri 0))))
            (setq valore (list 5 (numeri 4))
                  nome "Straight") ; Scala
        )
    )
    ;
    ; One Pair
    ; Coppia
    (if (= valore '()) ; non abbiamo ancora catalogato la mano
        (for (i 2 14)
          (if (= (count (list i) numeri) '(2))
              (begin
              (setq valore (list 2 i)
                    nome "One Pair") ; Coppia
              (for (k 4 0 -1)
                (if (!= i (numeri k))
                    (push (numeri k) valore -1)
                )
              ))
          )
        )
    )
    ;
    ; High Card
    ; Carta maggiore
    (if (= valore '()) ; non abbiamo ancora catalogato la mano
        (setq valore (list 1 (numeri 4) (numeri 3) (numeri 2)
                             (numeri 1) (numeri 0))
              nome "High Card") ; Carta maggiore
    )
    ;
    ; Error: mano unclassified
    ; Errore: mano non catalogata
    (if (= valore '()) ; non abbiamo ancora catalogato la mano
        (println "error")
    )
    (list valore nome)
  )
)

Proviamo la funzione "calcola":

(calcola '(2 3 4 6 8) "CHCCC")
;-> ((1 6 8 4 3 2) "High Card")
(calcola '(2 2 2 10 10) "CHCCC")
;-> ((7 2 10) "Full House")
(calcola '(2 3 4 8 10) "CHCCC")
;-> ((1 8 3 4 2 10) "High Card")
(calcola '(10 2 3 3 8) "CHCCC")
;-> ((2 3 8 2 10) "One Pair")
(calcola '(3 3 3 5 6) "CHCCC")
;-> ((4 3 6 5) "Three of a Kind")
(calcola '(4 8 9 10 13) "CSCHS")
;-> ((1 13 10 9 8 4) "High Card")
(calcola '(2 3 5 4 6) "DDDDD")
;-> ((9 6) "Straight Flush")
(calcola '(10 11 12 13 14) "DDDDD")
;-> ((10 14) "Royal Flush")

Vediamo se funziona correttamente:

(dolist (el mani)
  (setq p1 (calcola (el 0) (el 1)))
  (setq p2 (calcola (el 2) (el 3)))
  (println (el 0) { - } p1)
  (println (el 2) { - } p2)
)

;-> (4 8 9 10 13) - ((1 13 10 9 8 4) "High Card")
;-> (2 3 5 7 14) - ((1 14 7 5 3 2) "High Card")
;-> (5 5 9 14 14) - ((3 14 5 9) "Two Pairs")
;-> (5 7 8 10 13) - ((1 13 10 8 7 5) "High Card")
;-> (3 6 7 11 13) - ((1 13 11 7 6 3) "High Card")
;-> (2 8 10 11 12) - ((1 12 11 10 8 2) "High Card")
;-> (5 8 10 10 12) - ((2 10 12 8 5) "One Pair")
;-> (4 9 11 11 13) - ((2 11 13 9 4) "One Pair")
;-> (5 7 11 12 13) - ((1 13 12 11 7 5) "High Card")
;-> (4 4 13 14 14) - ((3 14 4 13) "Two Pairs")
;-> (5 7 9 9 13) - ((2 9 13 7 5) "One Pair")
;-> (3 5 5 8 14) - ((2 5 14 8 3) "One Pair")
;-> (2 3 4 5 6) - ((5 6) "Straight")
;-> (3 5 6 12 14) - ((1 14 12 6 5 3) "High Card")
;-> (4 7 8 10 10) - ((2 10 8 7 4) "One Pair")
;-> (3 4 7 13 13) - ((2 13 7 4 3) "One Pair")
;-> (3 6 7 9 13) - ((1 13 9 7 6 3) "High Card")
;-> (4 12 12 13 14) - ((2 12 14 13 4) "One Pair")
;-> (2 2 5 6 11) - ((2 2 11 6 5) "One Pair")
;-> (7 9 11 13 14) - ((1 14 13 11 9 7) "High Card")
;-> ((1 14 13 11 9 7) "High Card")

Adesso dobbiamo scrivere una funzione che confronta gli elementi di due liste per trovare quale delle due è maggiore:

Esempi:
(3 4 9) maggiore di (2 3 12)
(3 4 9) maggiore di (3 3 12)
(3 4 9) minore di (5 3 8)
(4 5 2 7) maggiore di (4 5 2 6)

(define (maggiore lst1 lst2)
  (cond ((or (null? lst1) (null? lst2))
         ; se lst1 ha più elementi di lst2
         (if (not (null? lst1))
             true  ;se lst1 ha più elementi di lst2
             nil)) ; altrimenti lst1 = lst2
        ((> (first lst1) (first lst2)) true)
        ((< (first lst1) (first lst2)) nil)
        ((= (first lst1) (first lst2))
         (maggiore (rest lst1) (rest lst2)))))

(maggiore '(3 4 9) '(3 4 9))
;-> nil
(= '(3 4 9) '(3 4 9))
;-> true
(maggiore '(13 10 9 8 7 6) '(13 10 9 8 7 5))
;-> true
(maggiore '(13 10 9 8 7) '(13 10 9 8 7 2))
;-> nil
(maggiore '(13 10 9 8 7 2) '(13 10 9 8 7))
;-> true
(maggiore '(13 10 9 8 7) '(12 10 9 8 7 2))
;-> true
(maggiore '(12 9 9 8 7) '(12 10 9 8 7 2))
;-> nil
(maggiore '(14 4) '(14 3 6 7 8 9))
;-> true
(maggiore '(14 4) '(14 5 6 7 8 9))
;-> nil

Adesso possiamo scrivere la funzione finale:

(define (e054)
  (setq raw (read-file "054_poker.txt"))
  (setq data (parse raw "\r\n"))
  (setq data (map list data))
  (setq mani '())
  (dolist (el data)
    (setq row (first el))
    ;(println row)
    (setq val-p1 (explode (select row '(0 3 6 9 12))))
    (replace "A" val-p1 "14")
    (replace "K" val-p1 "13")
    (replace "Q" val-p1 "12")
    (replace "J" val-p1 "11")
    (replace "T" val-p1 "10")
    (setq val-p1 (sort (map int val-p1)))
    (setq val-p2 (explode (select row '(15 18 21 24 27))))
    (replace "A" val-p2 "14")
    (replace "K" val-p2 "13")
    (replace "Q" val-p2 "12")
    (replace "J" val-p2 "11")
    (replace "T" val-p2 "10")
    (setq val-p2 (sort (map int val-p2)))
    ; i semi non vengono ordinati perchè ci servono
    ; solo per calcolare "colore"
    (setq sem-p1 (select row '(1 4 7 10 13)))
    (setq sem-p2 (select row '(16 19 22 25 28)))
    (push (list val-p1 sem-p1 val-p2 sem-p2) mani -1)
    mani
  )
  ;(println (length mani))
  (setq val-p1 0)
  (setq val-p2 0)
  (dolist (el mani)
    (setq p1 (first (calcola (el 0) (el 1))))
    (setq p2 (first (calcola (el 2) (el 3))))
    (if (maggiore p1 p2)
        (begin
          ;(println (el 0) { } (el 1))
          ;(println (el 2) { } (el 3))
          ;(println p1 { } p2)
          (++ val-p1)
          ;(read-line)
        )
    )
  )
  val-p1
)

Calcoliamo la soluzione:

(e054)
;-> 376

(time (e054))
;-> 154.756
----------------------------------------------------------------------------


===========
Problema 55
===========

Numeri di Lychrel

Se prendiamo 47, lo invertiamo e lo aggiungiamo, otteniamo 47 + 74 = 121, che è palindromo.

Non tutti i numeri producono palindromi così rapidamente. Per esempio,

349 + 943 = 1292,
1292 + 2921 = 4213
4213 + 3124 = 7337

Cioè, 349 impiega tre iterazioni per arrivare a un palindromo.

Sebbene nessuno lo abbia ancora dimostrato, si ritiene che alcuni numeri, come 196, non producano mai un palindromo. Un numero che non forma mai un palindromo attraverso il processo di inversione e aggiunta si chiama numero Lychrel. A causa della natura teorica di questi numeri e ai fini di questo problema, supponiamo che un numero sia Lychrel fino a prova contraria. Inoltre, ti viene dato che per ogni numero inferiore a diecimila, o (i) diventerà un palindromo in meno di cinquanta iterazioni, o (ii) nessuno, con tutta la potenza di calcolo esistente, è riuscito finora a mapparlo su un palindromo. Infatti, 10677 è il primo numero in cui è stato dimostrato di richiedere oltre cinquanta iterazioni prima di produrre un palindromo: 4668731596684224866951378664 (53 iterazioni, 28 cifre).

Sorprendentemente, ci sono numeri palindromi che sono essi stessi numeri Lychrel (il primo esempio è 4994).

Quanti numeri Lychrel ci sono sotto diecimila?

NOTA: il testo è stato leggermente modificato il 24 aprile 2007 per enfatizzare la natura teorica dei numeri di Lychrel.
============================================================================

Funzione che inverte le cifre un numero:

(define (inverti n)
  (int (reverse (string n)) 0 10))

Da notare che la funzione "int" considera in base ottale il suo argomento se tale numero inizia con uno "0".

(int "055")
;-> 45

Per specificare una conversione decimale occorre specificarlo:

(int "055" 0 10)
;-> 55

(inverti 12345)
;-> 54321

Funzione che controlla se un numero è palindromo:

(define (pali? n) (= n (inverti n)))

(pali? 12344321)
;-> true
(pali? 123454321)
;-> true
(pali? 123211)
;-> nil

Funzione che controlla se un numero è di Lychrel:

(define (lychrel? num)
  (local (a b found lyc zzz)
    (setq zzz num)
    (setq found nil)
    (setq lyc true)
    (for (i 1 50 1 found)
      (setq a num)
      (setq b (inverti a))
      ;(println "num: " zzz { } "i: " i { } "a: " a { } "b: " b { } "a+b: " (+ a b))
      (if (pali? (+ a b))
        (begin
          (setq lyc nil)
          (setq found true)
          ;(println "NUM: " zzz { } "i: " i { } "a: " a { } "b: " b { } "a+b: " (+ a b))
        )
      )
      (setq num (+ a b))
    )
    lyc
  )
)

(lychrel? 47)
;-> nil

Funzione finale (versione 1):

(define (e053 prove)
  (let (out 0)
    (for (i 1 prove)
      (if (lychrel? i) (++ out))
    )
    out))

(e053 10000)
;-> 249
(time (e053 10000))
;-> 116.877

Funzione finale (versione 2):

(define (e053 n)
  (count '(true) (map lychrel? (sequence 1 n))))

(e053 10000)
;-> (249)
(time (e053 10000))
;-> 125.839
----------------------------------------------------------------------------


===========
Problema 56
===========

Somma di cifre di potenza

Un googol (10^100) è un numero enorme: uno seguito da cento zeri. 100^100 è quasi inimmaginabilmente grande: uno seguito da duecento zeri. Nonostante le loro dimensioni, la somma delle cifre in ciascun numero è solo 1.

Considerando i numeri naturali della forma a^b, dove a, b < 100, qual'è la somma massima delle cifre?
============================================================================

Funzione che calcola la somma delle cifre di un numero:

(define (digit-sum n)
  (let (out 0)
    (while (!= n 0)
      (setq out (+ out (% n 10)))
      (setq n (/ n 10))
    )
    out))

(digit-sum 123456789L)
;-> 45

Funzione che calcola la potenza intera di due numeri interi:

(define (** x p)
    (let (y 1L)
        (dotimes (i p)
            (setq y (* y x)))))

(** 35 21)
;-> 266335422555582049846649169921875L

(digit-sum 266335422555582049846649169921875L)
;-> 161

(+ 2 6 6 3 3 5 4 2 2 5 5 5 5 8 2 0 4 9 8 4 6 6 4 9 1 6 9 9 2 1 8 7 5)
;-> 161

Funzione soluzione:

(define (e056)
  (local (somma somma-max)
    (setq somma-max 0)
    (for (a 75 100)
      (for (b 75 100)
        (setq somma (digit-sum (** a b)))
        (if (> somma somma-max) (setq somma-max somma))
      )
    )
    somma-max))

(e056)
;-> 972

(time (e056))
;-> 199.794

Possiamo scrivere la funzione anche in stile funzionale.

Questa funzione calcola tutte le potenza di ogni elemento della prima lista elevato ad ogni elemento della seconda lista (prodotto cartesiano):

(define (cp lst1 lst2)
  (let (out '())
    (if (or (null? lst1) (null? lst2))
        nil
        (dolist (el1 lst1)
          (dolist (el2 lst2)
            (push (** el1 el2) out -1))))))

Funzione soluzione:

(define (e056)
  (apply max (map digit-sum (cp (map bigint (sequence 75 100))
                                (map bigint (sequence 75 100))))))

(e056)
;-> 972

(time (e056))
;-> 186.794
----------------------------------------------------------------------------


===========
Problema 57
===========

È possibile dimostrare che la radice quadrata di due può essere espressa come una frazione continua infinita.

sqrt(2) = 1 + 1 / (2 + 1 / (2 + 1 / (2 +...))) = 1.414213...

Espandendo questo per le prime quattro iterazioni, otteniamo:

1 + 1/2 = 3/2 = 1.5
1 + 1 / (2 + 1/2) = 7/5 = 1.4
1 + 1 / (2 + 1 / (2 + 1/2)) = 17/12 = 1.41666...
1 + 1 / (2 + 1 / (2 + 1 / (2 + 1/2))) = 41/29 = 1.41379...

Le tre espansioni successive sono 99/70, 239/169 e 577/408, ma l'ottava espansione, 1393/985, è il primo esempio in cui il numero di cifre nel numeratore supera il numero di cifre nel denominatore.

Nelle prime mille espansioni, quante frazioni contengono un numeratore con più cifre del denominatore?
============================================================================

La sequenza a(k) inizia con a(0) = 1 + 1/2 e a(1) = (1 + (1 / (2 + 1/2))), sostituendo a(0) in a(1) otteniamo a(1) = 1 + (1 / (1 + a(0))). Quindi possiamo scrivere:

                                        1
a(k+1) = 1 + (1 / (1 + a(k))) = 1 + ----------
                                     1 + a(k)

Invece di utilizzare la libreria delle frazioni per calcolare il numeratore e il denominatore di ogni iterazione, possiamo espandere a(k+1):

a(k+1) = 1 + (1 / (1 + a(k))) = 1 + (1 / (1 + nk/dk)) =
       = 1 + (1 / (1 + nk/dk)) = 1 + (1 / (1 + (dk + nk)/dk) =
       = 1 + dk/(dk + nk) = (dk + nk + dk)/(dk + nk) =
       = (2*dk + nk)/(dk + nk)

Usiamo questa formula per calcolare il numeratore e il denominatore per ogni iterazione, poi confrontiamo le loro lunghezze e incrementiamo il contatore:

(define (e057 num)
  (local (n d tn td out)
    (setq out 0)
    (setq n 1L)
    (setq d 1L)
    (for (i 0 num)
      (setq tn n)
      (setq td d)
      (setq n (+ (* 2L td) tn))
      (setq d (+ td tn))
      ;(println n { } d)
      (if (> (length n) (length d)) (++ out))
    )
    out
  )
)

(e057 1000)
;-> 153

(time (e057 1000))
;-> 10.036
----------------------------------------------------------------------------


===========
Problema 58
===========
Numeri primi a spirale

A partire da 1 e creando una spirale in senso antiorario, si forma una spirale quadrata con lato di lunghezza 7:

37 36 35 34 33 32 31
38 17 16 15 14 13 30
39 18  5  4  3 12 29
40 19  6  1  2 11 28
41 20  7  8  9 10 27
42 21 22 23 24 25 26
43 44 45 46 47 48 49

È interessante notare che i quadrati dispari si trovano lungo la diagonale in basso a destra, ma ciò che è più interessante è che 8 dei 13 numeri che giacciono lungo entrambe le diagonali sono primi (43 7 3 13 31) e (37 17 5). Cioè, un rapporto dell'8/13 ≈ 62%.

Se un nuovo strato completo viene avvolto attorno alla spirale sopra, verrà formata una spirale quadrata con lunghezza laterale 9. Se questo processo continua, qual è la lunghezza laterale della spirale quadrata per la quale il rapporto dei numeri primi lungo entrambe le diagonali scende prima sotto il 10%?
============================================================================

La spirale di lato 9 è la seguente:

 65 64 63 62 61 60 59 58 57
 66 37 36 35 34 33 32 31 56
 67 38 17 16 15 14 13 30 55
 68 39 18  5  4  3 12 29 54
 69 40 19  6  1  2 11 28 53
 70 41 20  7  8  9 10 27 52
 71 42 21 22 23 24 25 26 51
 72 43 44 45 46 47 48 49 50
 73 74 75 76 77 78 79 80 81

Occorre notare che partendo da k=1 i valori che cerchiamo sono:

lato = 2*k + 1
basso-dx = (2*k + 1)^2
alto-dx  = (basso-dx - 6*k)
alto-sx  = (basso-dx - 4*k)
basso-sx = (basso-dx - 2*k)

Quindi ad ogni iterazione/spirale dobbiamo solo controllare se questi quattro numeri sono primi ed eventualmente aggiornare il conteggio dei numeri primi totali.

Iterazione 1:
5  4  3
6  1  2
7  8  9

Iterazione 2:
17 16 15 14 13
18  5  4  3 12
19  6  1  2 11
20  7  8  9 10
21 22 23 24 25

Iterazione 3:
37 36 35 34 33 32 31
38 17 16 15 14 13 30
39 18  5  4  3 12 29
40 19  6  1  2 11 28
41 20  7  8  9 10 27
42 21 22 23 24 25 26

...e così via.

Possiamo scrivere la funzione di soluzione:

(define (primo? n)
   (if (< n 2) nil
       (= 1 (length (factor n)))))

(define (e058 n)
  (local (numeriDiag numeriPrimi perc lato found
          alto-dx alto-sx basso-dx basso-sx)
    (setq found nil)
    (setq numeriDiag 1)
    (setq numeriPrimi 0)
    (setq perc 0)
    (for (side 1 n 1 found)
      (setq lato (+ (* 2 side) 1))
      ;(setq basso-dx (* (+ (* 2 side) 1) (+ (* 2 side) 1)))
      (setq basso-dx (* lato lato))
      (setq alto-dx (- basso-dx (* 6 side)))
      (setq alto-sx (- basso-dx (* 4 side)))
      (setq basso-sx (- basso-dx (* 2 side)))
      ;(println alto-dx { } alto-sx { } basso-sx { } basso-dx)
      (setq numeriDiag (+ (* 2 lato) 1))
      ;(if (primo? basso-dx) (++ numeriPrimi))
      (if (primo? alto-dx) (++ numeriPrimi))
      (if (primo? basso-sx) (++ numeriPrimi))
      (if (primo? alto-sx) (++ numeriPrimi))
      (setq perc (div numeriPrimi numeriDiag))
      ;(println side { } lato { } numeriPrimi { } numeriDiag { } perc)
      (if (< perc 0.1) (setq found true))
    )
    (list lato perc numeriPrimi numeriDiag)
  )
)

(e058 50000)
;-> (26241 0.09999428386334623 5248 52483)

(time (e058 50000))
;-> 630.190
----------------------------------------------------------------------------


===========
Problema 59
===========

Decodifica XOR

A ciascun carattere di un computer viene assegnato un codice univoco e lo standard preferito è ASCII (American Standard Code for Information Interchange). Ad esempio, A maiuscola = 65, asterisco (*) = 42 e k minuscola = 107.

Un moderno metodo di crittografia è quello di prendere un file di testo, convertire i byte in ASCII, quindi fare lo XOR ad ogni byte con un dato valore, preso da una chiave segreta. Il vantaggio con la funzione XOR è che l'uso della stessa chiave di crittografia sul testo cifrato ripristina il testo normale, ad esempio, 65 XOR 42 = 107, quindi 107 XOR 42 = 65.

Per avere una criptazione inviolabile, la chiave deve avere la stessa lunghezza del messaggio di testo normale e la chiave deve essere composta da byte casuali. Se l'utente tiene il messaggio crittografato e la chiave di crittografia in posti diversi allora è impossibile decrittografare il messaggio senza entrambe le 'metà' (messaggio crittografato e chiave).

Sfortunatamente, questo metodo non è pratico per la maggior parte degli utenti, quindi il metodo modificato è usare una password come chiave. Se la password è più corta del messaggio, il che è probabile, la chiave viene ripetuta ciclicamente in tutto il messaggio. Il giusto bilanciamento è quello di usare una chiave (password) sufficientemente lunga per la sicurezza, ma abbastanza corta per essere ricordata.

Il tuo compito è stata semplificato, poiché la chiave di crittografia è composta da tre caratteri minuscoli. Utilizzando il file "p059_cipher.txt" che contiene i codici ASCII crittografati e sapendo che il testo normale (decifrato) contiene parole inglesi comuni, decodificare il messaggio e trovare la somma dei valori ASCII dei caratteri contenuti nel testo originale.
============================================================================

Assegniamo i valori contenuti nel file "p059_cipher.txt" ad una lista:

(setq tc '(79 59 12 2 79 35 8 28 20 2 3 68 8 9 68 45 0 12 9 67
68 4 7 5 23 27 1 21 79 85 78 79 85 71 38 10 71 27 12 2
79 6 2 8 13 9 1 13 9 8 68 19 7 1 71 56 11 21 11 68
6 3 22 2 14 0 30 79 1 31 6 23 19 10 0 73 79 44 2 79
19 6 28 68 16 6 16 15 79 35 8 11 72 71 14 10 3 79 12 2
79 19 6 28 68 32 0 0 73 79 86 71 39 1 71 24 5 20 79 13
9 79 16 15 10 68 5 10 3 14 1 10 14 1 3 71 24 13 19 7
68 32 0 0 73 79 87 71 39 1 71 12 22 2 14 16 2 11 68 2
25 1 21 22 16 15 6 10 0 79 16 15 10 22 2 79 13 20 65 68
41 0 16 15 6 10 0 79 1 31 6 23 19 28 68 19 7 5 19 79
12 2 79 0 14 11 10 64 27 68 10 14 15 2 65 68 83 79 40 14
9 1 71 6 16 20 10 8 1 79 19 6 28 68 14 1 68 15 6 9
75 79 5 9 11 68 19 7 13 20 79 8 14 9 1 71 8 13 17 10
23 71 3 13 0 7 16 71 27 11 71 10 18 2 29 29 8 1 1 73
79 81 71 59 12 2 79 8 14 8 12 19 79 23 15 6 10 2 28 68
19 7 22 8 26 3 15 79 16 15 10 68 3 14 22 12 1 1 20 28
72 71 14 10 3 79 16 15 10 68 3 14 22 12 1 1 20 28 68 4
14 10 71 1 1 17 10 22 71 10 28 19 6 10 0 26 13 20 7 68
14 27 74 71 89 68 32 0 0 71 28 1 9 27 68 45 0 12 9 79
16 15 10 68 37 14 20 19 6 23 19 79 83 71 27 11 71 27 1 11
3 68 2 25 1 21 22 11 9 10 68 6 13 11 18 27 68 19 7 1
71 3 13 0 7 16 71 28 11 71 27 12 6 27 68 2 25 1 21 22
11 9 10 68 10 6 3 15 27 68 5 10 8 14 10 18 2 79 6 2
12 5 18 28 1 71 0 2 71 7 13 20 79 16 2 28 16 14 2 11
9 22 74 71 87 68 45 0 12 9 79 12 14 2 23 2 3 2 71 24
5 20 79 10 8 27 68 19 7 1 71 3 13 0 7 16 92 79 12 2
79 19 6 28 68 8 1 8 30 79 5 71 24 13 19 1 1 20 28 68
19 0 68 19 7 1 71 3 13 0 7 16 73 79 93 71 59 12 2 79
11 9 10 68 16 7 11 71 6 23 71 27 12 2 79 16 21 26 1 71
3 13 0 7 16 75 79 19 15 0 68 0 6 18 2 28 68 11 6 3
15 27 68 19 0 68 2 25 1 21 22 11 9 10 72 71 24 5 20 79
3 8 6 10 0 79 16 8 79 7 8 2 1 71 6 10 19 0 68 19
7 1 71 24 11 21 3 0 73 79 85 87 79 38 18 27 68 6 3 16
15 0 17 0 7 68 19 7 1 71 24 11 21 3 0 71 24 5 20 79
9 6 11 1 71 27 12 21 0 17 0 7 68 15 6 9 75 79 16 15
10 68 16 0 22 11 11 68 3 6 0 9 72 16 71 29 1 4 0 3
9 6 30 2 79 12 14 2 68 16 7 1 9 79 12 2 79 7 6 2
1 73 79 85 86 79 33 17 10 10 71 6 10 71 7 13 20 79 11 16
1 68 11 14 10 3 79 5 9 11 68 6 2 11 9 8 68 15 6 23
71 0 19 9 79 20 2 0 20 11 10 72 71 7 1 71 24 5 20 79
10 8 27 68 6 12 7 2 31 16 2 11 74 71 94 86 71 45 17 19
79 16 8 79 5 11 3 68 16 7 11 71 13 1 11 6 1 17 10 0
71 7 13 10 79 5 9 11 68 6 12 7 2 31 16 2 11 68 15 6
9 75 79 12 2 79 3 6 25 1 71 27 12 2 79 22 14 8 12 19
79 16 8 79 6 2 12 11 10 10 68 4 7 13 11 11 22 2 1 68
8 9 68 32 0 0 73 79 85 84 79 48 15 10 29 71 14 22 2 79
22 2 13 11 21 1 69 71 59 12 14 28 68 14 28 68 9 0 16 71
14 68 23 7 29 20 6 7 6 3 68 5 6 22 19 7 68 21 10 23
18 3 16 14 1 3 71 9 22 8 2 68 15 26 9 6 1 68 23 14
23 20 6 11 9 79 11 21 79 20 11 14 10 75 79 16 15 6 23 71
29 1 5 6 22 19 7 68 4 0 9 2 28 68 1 29 11 10 79 35
8 11 74 86 91 68 52 0 68 19 7 1 71 56 11 21 11 68 5 10
7 6 2 1 71 7 17 10 14 10 71 14 10 3 79 8 14 25 1 3
79 12 2 29 1 71 0 10 71 10 5 21 27 12 71 14 9 8 1 3
71 26 23 73 79 44 2 79 19 6 28 68 1 26 8 11 79 11 1 79
17 9 9 5 14 3 13 9 8 68 11 0 18 2 79 5 9 11 68 1
14 13 19 7 2 18 3 10 2 28 23 73 79 37 9 11 68 16 10 68
15 14 18 2 79 23 2 10 10 71 7 13 20 79 3 11 0 22 30 67
68 19 7 1 71 8 8 8 29 29 71 0 2 71 27 12 2 79 11 9
3 29 71 60 11 9 79 11 1 79 16 15 10 68 33 14 16 15 10 22 73))

Vediamo come criptare/decriptare un carattere con la funzione XOR:

(char "a")
;-> 97

(char "k")
;-> 107

Cripta il valore (ASCII) del carattere "a" con il valore della chiave "k":
(^ 97 107)
;-> 10

Decripta il valore criptato (10) con il valore della chiave "k":
(^ 10 107)
;-> 97

Funzione di criptazione:

(define (crypt ch key)
  (char (^ (char ch) (char key))))

(crypt "a" "k")
;-> "\n"

Funzione di decriptazione:

(define (decrypt ch key)
  (char (^ (char ch) (char key))))

(decrypt (crypt "a" "k") "k")
;-> "a"

Nota: le funzione di criptazione e decriptazione sono identiche.

Adesso scriviamo una funzione che cripta una stringa con una data password.

(define (crypt ch key)
  (char (^ (char ch) (char key))))

(crypt "a" "k")
;-> "\n"

(define (decrypt ch key)
  (char (^ (char ch) (char key))))

(decrypt (crypt "a" "k") "k")
;-> "a"

Adesso scriviamo una funzione che cripta una stringa con una data password.

(define (crypt-text text pwd)
  (local (k lst len out)
    (setq out '())
    (setq numchar (- (length pwd) 1))
    ;(setq lst (explode text)) ; non UTF-8
    (setq lst (unpack (dup "s" (length text)) text)) ; UTF-8
    (setq k 0)
    (dolist (el lst)
      (push (crypt el (pwd k)) out -1)
      (++ k)
      (if (= k numchar) (setq k 0))
    )
    (join out)))

(crypt-text "Massimo" "pwd")
;-> "=\022\003\004\025\026\031"

(crypt-text "=\022\003\004\025\026\031" "pwd")
;-> Massimo

(crypt-text (crypt-text "cryptomessage" "password") "password")
;-> cryptomessage

Per il nostro scopo è più conveniente avere in input una lista di codici ASCII (la nostra lista tc):

(define (crypt-text text pwd)
  ; text: testo in una lista di numeri ASCII
  (local (k lst len out)
    (setq out '())
    (setq numchar (length pwd))
    (setq k 0)
    (dolist (el text)
      (push (^ el (char (pwd k))) out -1)
      (++ k)
      (if (= k numchar) (setq k 0))
    )
    out
  )
)

(crypt-text (map char (explode "Massimo Eva")) "pwd")
;-> (61 22 23 3 30 9 31 87 33 6 22)

(join (map char (crypt-text '(61 22 23 3 30 9 31 87 33 6 22) "pwd")))
;-> "Massimo Eva"

Adesso dobbiamo trovare la chiave (password) del testo cifrato. Sappiamo che è formata da tre lettere minuscole. Facciamo l'analisi delle frequenze al testo cifrato.

Frequenza dei caratteri nella lingua inglese:
http://www.data-compression.com/english.html

|=========|=========|=========|=========|=========|=========|=========|
|    a    |    b    |    c    |    d    |    e    |    f    |    g    |
|=========|=========|=========|=========|=========|=========|=========|
 0.0651738 0.0124248 0.0217339 0.0349835 0.1041442 0.0197881 0.0158610

|=========|=========|=========|=========|=========|=========|=========|
|    h    |    i    |    j    |    k    |    l    |    m    |    n    |
|=========|=========|=========|=========|=========|=========|=========|
 0.0492888 0.0558094 0.0009033 0.0050529 0.0331490 0.0202124 0.0564513

|=========|=========|=========|=========|=========|=========|=========|
|    o    |    p    |    q    |    r    |    s    |    t    |    u    |
|=========|=========|=========|=========|=========|=========|=========|
 0.0596302 0.0137645 0.0008606 0.0497563 0.0515760 0.0729357 0.0225134

|=========|=========|=========|=========|=========|=========|
|    v    |    w    |    x    |    y    |    z    |  SPACE  |
|=========|=========|=========|=========|=========|=========|
 0.0082903 0.0171272 0.0013692 0.0145984 0.0007836 0.1918182

(setq af '(
 (0.0651738 "a") (0.0124248 "b") (0.0217339 "c") (0.0349835 "d")
 (0.1041442 "e") (0.0197881 "f") (0.0158610 "g") (0.0492888 "h")
 (0.0558094 "i") (0.0009033 "j") (0.0050529 "k") (0.0331490 "l")
 (0.0202124 "m") (0.0564513 "n") (0.0596302 "o") (0.0137645 "p")
 (0.0008606 "q") (0.0497563 "r") (0.0515760 "s") (0.0729357 "t")
 (0.0225134 "u") (0.0082903 "v") (0.0171272 "w") (0.0013692 "x")
 (0.0145984 "y") (0.0007836 "z") (0.1918182 " ")))

(sort af >)
;-> ((0.1918182 " ") (0.1041442 "e") (0.0729357 "t") (0.0651738 "a")
;->  (0.0596302 "o") (0.0564513 "n") (0.0558094 "i") (0.051576 "s")
;->  (0.0497563 "r") (0.0492888 "h") (0.0349835 "d") (0.033149 "l")
;->  (0.0225134 "u") (0.0217339 "c") (0.0202124 "m") (0.0197881 "f")
;->  (0.0171272 "w") (0.015861 "g")  (0.0145984 "y") (0.0137645 "p")
;->  (0.0124248 "b") (0.0082903 "v") (0.0050529 "k") (0.0013692 "x")
;->  (0.0009033 "j") (0.0008606 "q") (0.0007836 "z"))

Quindi il carattere spazio " " è quello di gran lunga più frequente (quasi il 20%). Per il nostro algoritmo sarà sufficiente utilizzare questo carattere.

Vediamo quali sono i valori più frequenti nel testo cifrato:

(apply max tc)
;-> 94
(setq freq (array 95 '(0)))

(dolist (el tc) (setf (freq el) (+ (freq el) 1)))
freq
;-> (49 63 60 37 5 21 49 41 34 41 60 54 31 24 38 26 38 9 10 35
;->  22 15 22 17 9 6 6 21 21 11 4 4 4 2 0 3 0 2 2 2 1 1 0 0 2
;->  4 0 0 1 0 0 0 1 0 0 0 2 0 0 4 1 0 0 0 1 2 0 2 77 1 0 70 5
;->  11 4 5 0 0 1 86 0 1 0 2 1 5 4 3 0 1 0 1 1 1 1)

Converto il vettore in lista:

(setq f (array-list freq))
f

Lista di frequenze ordinata:

(sort (copy f) >)
;-> (86 77 70 63 60 60 54 49 49 41 41 38 38 37 35 34 31 26 24 22 22 21 21 21 17 15 11
;->  11 10 9 9 6 6 5 5 5 5 4 4 4 4 4 4 4 3 3 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1
;->  1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)

Il valore più frequente del testo cifrato è 86.

Posizione (valore ASCII criptato):

(ref 86 f)
;-> (79)

Associo il valore 79 al carattere " " (che è il più frequente in lingua inglese). Quindi trovo il carattere della chiave che restituisce uno spazio " ":

(dolist (el (explode "abcdefghijlklmnopqrstuvwxyz "))
  (if (= " " (char (^ 79 (char el))))
    (println el)))
;-> o

Un carattere della chiave è "o".

Lo stesso ragionamento può essere fatto con il secondo valore più frequente del testo cifrato, cioè 77.
Infatti, poichè ogni carattere della chiave codifica (quasi) lo stesso numero di caratteri

Posizione (valore ASCII criptato):

(ref 77 f)
;-> (68)

(dolist (el (explode "abcdefghijlklmnopqrstuvwxyz "))
  (if (= " " (char (^ 68 (char el))))
    (println el)))
;-> d

Un altro carattere della chiave è "d".

Lo stesso ragionamento può essere fatto con il terzo valore più frequente del testo cifrato, cioè 70.

Posizione (valore ASCII criptato):

(ref 70 f)
;-> (71)

(dolist (el (explode "abcdefghijlklmnopqrstuvwxyz "))
  (if (= " " (char (^ 71 (char el))))
    (println el)))
;-> g

Il terzo carattere della chiave è "g".

La chiave è composta dai caratteri "o", "d" e "g". Proviamo con "dog":

(setq testo (join (map char (crypt-text tc "dog"))))

In questo caso otteniamo un testo illeggibile.

Proviamo con "god":

(setq testo (join (map char (crypt-text tc "god"))))
;-> "(The Gospel of John, chapter 1) 1 In the beginning the Word already existed. He was with God, and he was God. 2 He was in the beginning with God. 3 He created everything there is. Nothing exists that he didn't make. 4 Life itself was in him, and this life gives light to everyone. 5 The light shines through the darkness, and the darkness can never extinguish it. 6 God sent John the Baptist 7 to tell everyone about the light so that everyone might believe because of his testimony. 8 John himself was not the light; he was only a witness to the light. 9 The one who is the true light, who gives light to everyone, was going to come into the world. 10 But although the world was made through him, the world didn't recognize him when he came. 11 Even in his own land and among his own people, he was not accepted. 12 But to all who believed him and accepted him, he gave the right to become children of God. 13 They are reborn! This is not a physical birth resulting from human passion or plan, this rebirth comes from God.14 So the Word became human and lived here on earth among us. He was full of unfailing love and faithfulness. And we have seen his glory, the glory of the only Son of the Father."

Testo decifrato correttamente. Vediamo la somma dei valori ASCII del testo decifrato:

(setq sol (apply + (map char (explode testo))))
;-> 107359

(define (e059)
  (setq testo (join (map char (crypt-text tc "god"))))
  (setq sol (apply + (map char (explode testo)))))

(e059)
;-> 107359

(time (e059))
;-> 15.625

Il tempo registrato non è quello che include tutti i calcoli, ma credo che una funzione completa che utilizza questo metodo non dovrebbe impiegare più di 2/3 secondi per trovare la soluzione.

Sembra che il sito di Project Euler abbia cambiato il contenuto del file "p059_cipher.txt".
Proviamo il nostro metodo con questo nuovo file.

Assegniamo i valori contenuti nel file ad una lista:

(setq tc1 '(
 36 22 80 0 0 4 23 25 19 17 88 4 4 19 21 11 88 22 23 23 29 69
 12 24 0 88 25 11 12 2 10 28 5 6 12 25 10 22 80 10 30 80 10 22
 21 69 23 22 69 61 5 9 29 2 66 11 80 8 23 3 17 88 19 0 20 21
 7 10 17 17 29 20 69 8 17 21 29 2 22 84 80 71 60 21 69 11 5 8
 21 25 22 88 3 0 10 25 0 10 5 8 88 2 0 27 25 21 10 31 6 25
 2 16 21 82 69 35 63 11 88 4 13 29 80 22 13 29 22 88 31 3 88 3
 0 10 25 0 11 80 10 30 80 23 29 19 12 8 2 10 27 17 9 11 45 95
 88 57 69 16 17 19 29 80 23 29 19 0 22 4 9 1 80 3 23 5 11 28
 92 69 9 5 12 12 21 69 13 30 0 0 0 0 27 4 0 28 28 28 84 80
 4 22 80 0 20 21 2 25 30 17 88 21 29 8 2 0 11 3 12 23 30 69
 30 31 23 88 4 13 29 80 0 22 4 12 10 21 69 11 5 8 88 31 3 88
 4 13 17 3 69 11 21 23 17 21 22 88 65 69 83 80 84 87 68 69 83 80
 84 87 73 69 83 80 84 87 65 83 88 91 69 29 4 6 86 92 69 15 24 12
 27 24 69 28 21 21 29 30 1 11 80 10 22 80 17 16 21 69 9 5 4 28
 2 4 12 5 23 29 80 10 30 80 17 16 21 69 27 25 23 27 28 0 84 80
 22 23 80 17 16 17 17 88 25 3 88 4 13 29 80 17 10 5 0 88 3 16
 21 80 10 30 80 17 16 25 22 88 3 0 10 25 0 11 80 12 11 80 10 26
 4 4 17 30 0 28 92 69 30 2 10 21 80 12 12 80 4 12 80 10 22 19
 0 88 4 13 29 80 20 13 17 1 10 17 17 13 2 0 88 31 3 88 4 13
 29 80 6 17 2 6 20 21 69 30 31 9 20 31 18 11 94 69 54 17 8 29
 28 28 84 80 44 88 24 4 14 21 69 30 31 16 22 20 69 12 24 4 12 80
 17 16 21 69 11 5 8 88 31 3 88 4 13 17 3 69 11 21 23 17 21 22
 88 25 22 88 17 69 11 25 29 12 24 69 8 17 23 12 80 10 30 80 17 16
 21 69 11 1 16 25 2 0 88 31 3 88 4 13 29 80 21 29 2 12 21 21
 17 29 2 69 23 22 69 12 24 0 88 19 12 10 19 9 29 80 18 16 31 22
 29 80 1 17 17 8 29 4 0 10 80 12 11 80 84 67 80 10 10 80 7 1
 80 21 13 4 17 17 30 2 88 4 13 29 80 22 13 29 69 23 22 69 12 24
 12 11 80 22 29 2 12 29 3 69 29 1 16 25 28 69 12 31 69 11 92 69
 17 4 69 16 17 22 88 4 13 29 80 23 25 4 12 23 80 22 9 2 17 80
 70 76 88 29 16 20 4 12 8 28 12 29 20 69 26 9 69 11 80 17 23 80
 84 88 31 3 88 4 13 29 80 21 29 2 12 21 21 17 29 2 69 12 31 69
 12 24 0 88 20 12 25 29 0 12 21 23 86 80 44 88 7 12 20 28 69 11
 31 10 22 80 22 16 31 18 88 4 13 25 4 69 12 24 0 88 3 16 21 80
 10 30 80 17 16 25 22 88 3 0 10 25 0 11 80 17 23 80 7 29 80 4
 8 0 23 23 8 12 21 17 17 29 28 28 88 65 75 78 68 81 65 67 81 72
 70 83 64 68 87 74 70 81 75 70 81 67 80 4 22 20 69 30 2 10 21 80
 8 13 28 17 17 0 9 1 25 11 31 80 17 16 25 22 88 30 16 21 18 0
 10 80 7 1 80 22 17 8 73 88 17 11 28 80 17 16 21 11 88 4 4 19
 25 11 31 80 17 16 21 69 11 1 16 25 2 0 88 2 10 23 4 73 88 4
 13 29 80 11 13 29 7 29 2 69 75 94 84 76 65 80 65 66 83 77 67 80
 64 73 82 65 67 87 75 72 69 17 3 69 17 30 1 29 21 1 88 0 23 23
 20 16 27 21 1 84 80 18 16 25 6 16 80 0 0 0 23 29 3 22 29 3
 69 12 24 0 88 0 0 10 25 8 29 4 0 10 80 10 30 80 4 88 19 12
 10 19 9 29 80 18 16 31 22 29 80 1 17 17 8 29 4 0 10 80 12 11
 80 84 86 80 35 23 28 9 23 7 12 22 23 69 25 23 4 17 30 69 12 24
 0 88 3 4 21 21 69 11 4 0 8 3 69 26 9 69 15 24 12 27 24 69
 49 80 13 25 20 69 25 2 23 17 6 0 28 80 4 12 80 17 16 25 22 88
 3 16 21 92 69 49 80 13 25 6 0 88 20 12 11 19 10 14 21 23 29 20
 69 12 24 4 12 80 17 16 21 69 11 5 8 88 31 3 88 4 13 29 80 22
 29 2 12 29 3 69 73 80 78 88 65 74 73 70 69 83 80 84 87 72 84 88
 91 69 73 95 87 77 70 69 83 80 84 87 70 87 77 80 78 88 21 17 27 94
 69 25 28 22 23 80 1 29 0 0 22 20 22 88 31 11 88 4 13 29 80 20
 13 17 1 10 17 17 13 2 0 88 31 3 88 4 13 29 80 6 17 2 6 20
 21 75 88 62 4 21 21 9 1 92 69 12 24 0 88 3 16 21 80 10 30 80
 17 16 25 22 88 29 16 20 4 12 8 28 12 29 20 69 26 9 69 65 64 69
 31 25 19 29 3 69 12 24 0 88 18 12 9 5 4 28 2 4 12 21 69 80
 22 10 13 2 17 16 80 21 23 7 0 10 89 69 23 22 69 12 24 0 88 19
 12 10 19 16 21 22 0 10 21 11 27 21 69 23 22 69 12 24 0 88 0 0
 10 25 8 29 4 0 10 80 10 30 80 4 88 19 12 10 19 9 29 80 18 16
 31 22 29 80 1 17 17 8 29 4 0 10 80 12 11 80 84 86 80 36 22 20
 69 26 9 69 11 25 8 17 28 4 10 80 23 29 17 22 23 30 12 22 23 69
 49 80 13 25 6 0 88 28 12 19 21 18 17 3 0 88 18 0 29 30 69 25
 18 9 29 80 17 23 80 1 29 4 0 10 29 12 22 21 69 12 24 0 88 3
 16 21 3 69 23 22 69 12 24 0 88 3 16 26 3 0 9 5 0 22 4 69
 11 21 23 17 21 22 88 25 11 88 7 13 17 19 13 88 4 13 29 80 0 0
 0 10 22 21 11 12 3 69 25 2 0 88 21 19 29 30 69 22 5 8 26 21 23 11 94))

(apply max tc1)
;-> 95
(setq freq1 (array 96 '(0)))

(dolist (el tc1) (setf (freq1 el) (+ (freq1 el) 1)))
freq1
;-> (75 19 31 36 61 15 11 9 25 20 52 43 65 33 2 2 38 73 11 21 22 65
;->  56 46 21 42 7 10 25 70 26 24 0 0 0 2 2 0 0 0 0 0 0 0 2 1 0 0 0
;->  3 0 0 0 0 1 0 0 1 0 0 1 1 1 1 3 9 2 5 3 86 7 1 3 7 2 5 2 3 3 0
;->  107 4 2 8 16 0 4 9 77 1 0 2 6 0 4 2)

Converto il vettore in lista:

(setq f1 (array-list freq1))
f1

Lista di frequenze ordinata:

(sort (copy f1) >)
;-> (107 86 77 75 73 70 65 65 61 56 52 46 43 42 38 36 33 31 26 25 25 24
;->  22 21 21 20 19 16 15 11 11 10 9 9 9 8 7 7 7 6 5 5 4 4 4 3 3 3 3 3
;->  3 2 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0
;->  0 0 0 0 0 0 0 0 0 0 0 0 0)

Il valore più frequente del testo cifrato è 107.

Posizione (valore ASCII criptato):

(ref 107 f1)
;-> (80)

Associo il valore 80 al carattere " " (che è il più frequente in lingua inglese). Quindi trovo il carattere della chiave che restituisce uno spazio " ":

(dolist (el (explode "abcdefghijlklmnopqrstuvwxyz "))
  (if (= " " (char (^ 80 (char el))))
    (println el)))
;-> p

Un carattere della chiave è "p".

Lo stesso ragionamento può essere fatto con il secondo valore più frequente del testo cifrato, cioè 86.

Posizione (valore ASCII criptato):

(ref 86 f1)
;-> (69)

(dolist (el (explode "abcdefghijlklmnopqrstuvwxyz "))
  (if (= " " (char (^ 69 (char el))))
    (println el)))
;-> e

Un altro carattere della chiave è "e".

Lo stesso ragionamento può essere fatto con il terzo valore più frequente del testo cifrato, cioè 77.

Posizione (valore ASCII criptato):

(ref 77 f1)
;-> (88)

(dolist (el (explode "abcdefghijlklmnopqrstuvwxyz "))
  (if (= " " (char (^ 88 (char el))))
    (println el)))
;-> x

Il terzo carattere della chiave è "x".

La chiave è composta dai caratteri "p", "e" e "x".

Facciamo alcuni tentativi:

(setq testo (join (map char (crypt-text tc1 "xpe"))))
In questo caso otteniamo un testo illeggibile.

(setq testo (join (map char (crypt-text tc1 "pex"))))
In questo caso otteniamo un testo illeggibile.

(setq testo (join (map char (crypt-text tc1 "pxe"))))
In questo caso otteniamo un testo illeggibile.

(setq testo (join (map char (crypt-text tc1 "xep"))))
In questo caso otteniamo un testo illeggibile.

(setq testo (join (map char (crypt-text tc1 "exp"))))
;-> "An extract taken from the introduction of one of Euler's most celebrated papers, \"De summis serierum reciprocarum\" [On the sums of series of reciprocals]: I have recently found, quite unexpectedly, an elegant expression for the entire sum of this series 1 + 1/4 + 1/9 + 1/16 + etc., which depends on the quadrature of the circle, so that if the true sum of this series is obtained, from it at once the quadrature of the circle follows. Namely, I have found that the sum of this series is a sixth part of the square of the perimeter of the circle whose diameter is 1; or by putting the sum of this series equal to s, it has the ratio sqrt(6) multiplied by s to 1 of the perimeter to the diameter. I will soon show that the sum of this series to be approximately 1.644934066842264364; and from multiplying this number by six, and then taking the square root, the number 3.141592653589793238 is indeed produced, which expresses the perimeter of a circle whose diameter is 1. Following again the same steps by which I had arrived at this sum, I have discovered that the sum of the series 1 + 1/16 + 1/81 + 1/256 + 1/625 + etc. also depends on the quadrature of the circle. Namely, the sum of this multiplied by 90 gives the biquadrate (fourth power) of the circumference of the perimeter of a circle whose diameter is 1. And by similar reasoning I have likewise been able to determine the sums of the subsequent series in which the exponents are even numbers."

Testo decifrato correttamente.
La chiave vale "exp".

Vediamo la somma dei valori ASCII del testo decifrato:

(setq sol (apply + (map char (explode testo))))
;-> 129448
----------------------------------------------------------------------------


===========
Problema 60
===========

Insiemi di coppie di numeri primi

I numeri primi 3, 7, 109 e 673 sono piuttosto notevoli. Prendendo due numeri primi e concatenandoli in qualsiasi ordine, il risultato sarà sempre un numero primo. Ad esempio, prendendo 7 e 109, sia 7109 che 1097 sono primi. La somma di questi quattro numeri primi, 792, rappresenta la somma più bassa per un insieme di quattro numeri primi con questa proprietà.

Trova la somma più bassa per un set di cinque numeri primi per i quali qualunque coppia di numeri primi si concatenano per produrre un altro numero primo.
============================================================================

L'algoritmo di soluzione è del tipo brute-force:

Generare N numeri primi.
Il primo numero della lista dei numeri primi è "a", il secondo numero della lista è "b" (b > a).
Controllare se "ab" e "ba" sono numeri primi,
se sono numeri primi, allora prendere il terzo numero dalla lista "c" (c > b).
   controllare se "ac", "ca", "bc", "ca" sono tutti numeri primi,
   se sono numeri primi, allora prendere un quarto numero dalla lista "d" (d > c).
      controllare se "ad", "da", "bd", "db", "cd", "dc" sono tutti numeri primi,
      se sono tutti numeri primi, prendi il quinto numero dalla lista "e" (e > d)
         controllare se "ae", "ea", "be", "eb", "ce", "ec", "de", "ed" sono tutti numeri primi,
         se sono tutti numeri primi, allora stampa a + b + c + d + e.

Adesso resta il problema di definire il numero N, cioè fino a quale numero primo dobbiamo considerare?
Non possiamo fermarci quando abbiamo trovato una soluzione, perchè non sappiamo se ne esistono altre con un valore di somma minore.
Andremo per tentativi... fino a 5000, fino a 6000, fino a 7000 ecc.

Funzione per verificare se un numero n è primo:

(define (prime? n)
   (if (< n 2) nil
       (= 1 (length (factor n)))))

Funzione per generare tutti i numeri primi fino a n:

(define (sieve n)
   (setq arr (array (+ n 1)) lst '(2))
   (for (x 3 n 2)
      (when (not (arr x))
         (push x lst -1)
         (for (y (* x x) n (* 2 x) (> y n))
            (setf (arr y) true)))) lst)

(sieve 50)
;-> (2 3 5 7 11 13 17 19 23 29 31 37 41 43 47)

Funzione che controlla se la combinazione (come stringa) dei numeri ab e ba sono entrambi primi:

(define (check a b)
  (and (prime? (int (string a b))) (prime? (int (string b a)))))

Questa è più veloce.

(define (check a b)
  (local (len-a len-b)
    (setq len-a (+ (int (log a 10)) 1))
    (setq len-b (+ (int (log b 10)) 1))
    ;(setq len-a (length a))
    ;(setq len-b (length b))
    (and (prime? (int (+ (* a (pow 10 len-b)) b)))
         (prime? (int (+ (* b (pow 10 len-a)) a))))
    ;(and (prime? (int (+ (* a (pow 10 (+ (int (log b 10)) 1))) b)))
    ;     (prime? (int (+ (* b (pow 10 (+ (int (log a 10)) 1))) a))))
  )
)

(check 109 673)
;-> true
(check 3 23)
;-> nil

(define (e060 n)
  (local (primi-lst primi)
    ; (setq primi (sieve n))
    ; Il 2 e il 5 non possono essere nella soluzione perchè
    ; un numero con 2 o 5 come ultima cifra non è primo.
    (pop (setq primi (sieve n)) '(0 2))
    ;(setq primi (array (length primi-lst) primi-lst))
    ; a è il primo numero
    (dolist (a primi)
      ; b è il secondo numero
      (dolist (b primi)
        (cond ((>= a b) nil)
              (true
               (if (check a b)
                   ; c è il terzo numero
                   (dolist (c primi)
                     (cond ((>= b c) nil)
                           (true
                            ; check se (a,c) e (b,c) soddisfano la condizione
                            (if (and (check a c) (check b c))
                                ; d è il quarto numero
                                (dolist (d primi)
                                  (cond ((>= c d) nil)
                                         (true
                                          # check se (a,d), (b,d) e (c,d) soddisfano la condizione
                                          (if (and (check a d) (check b d) (check c d))
                                              ; e è il quinto numero
                                              (dolist (e primi)
                                                (cond ((>= d e) nil)
                                                       (true
                                                        ; check se (a,e), (b,e), (c,e) e (d,e) soddisfano la condizione
                                                        (if (and (check a e) (check b e) (check c e) (check d e))
                                                            (println (+ a b c d e) { } a { } b { } c { } d { } e)
                                                        )))))))))))))))))))


(e060 5000)
;-> nil
(e060 6000)
;-> nil
(e060 7000)
;-> nil
(e060 8000)
;-> nil
(e060 9000)
;-> 26033 13 5197 5701 6733 8389

(time (e060 9000))
;-> 26033 13 5197 5701 6733 8389
;-> 56943.359

La funzione impiega circa 57 secondi per trovare la soluzione (siamo sotto al minuto).

Proviamo ad usare un vettore per i numeri primi. In questo modo possiamo evitare di controllare se un numero primo selezionato è superiore al precedente, ma dobbiamo usare l'indicizzazione per trovare il valore di un numero nel vettore.

(define (e060 n)
  (local (primi primi-lst up)
    ; (setq primi (sieve n))
    ; Il 2 e il 5 non possono essere nella soluzione perchè
    ; un numero con 2 o 5 come ultima cifra non è primo.
    (pop (setq primi-lst (sieve n)) '(0 2))
    (setq primi (array (length primi-lst) primi-lst))
    (setq up (- (length primi) 1))
    ; a è il primo numero
    (for (i 0 (- up 1))
      ; b è il secondo numero
      (for (j (+ i 1) (- up 2))
        ; check se (a,b) soddisfano la condizione
        (if (check (primi i) (primi j))
            ; c è il terzo numero
            (for (k (+ j 1) (- up 3))
              ; check se (a,c) e (b,c) soddisfano la condizione
              (if (and (check (primi i) (primi k))
                       (check (primi j) (primi k)))
                  ; d è il quarto numero
                  (for (x (+ k 1) (- up 4))
                    # check se (a,d), (b,d) e (c,d) soddisfano la condizione
                    (if (and (check (primi i) (primi x))
                             (check (primi j) (primi x))
                             (check (primi k) (primi x)))
                        ; e è il quinto numero
                        (for (y (+ x 1) (- up 5))
                          ; check se (a,e), (b,e), (c,e) e (d,e) soddisfano la condizione
                          (if (and (check (primi i) (primi y))
                                   (check (primi j) (primi y))
                                   (check (primi k) (primi y))
                                   (check (primi x) (primi y)))
                              (println (+ (primi i) (primi j) (primi k) (primi x) (primi y)) { }
                                       (primi i) { } (primi j) { } (primi k) { } (primi x) { } (primi y))
                          )))))))))))

(time (e060 9000))
;-> 26033 13 5197 5701 6733 8389
;-> 55055.913

I tempi di calcolo delle due funzioni sono quasi uguali.
----------------------------------------------------------------------------


===========
Problema 61
===========

I numeri triangolari, quadrati, pentagonali, esagonali, ettagonali e ottagonali sono tutti numeri figurati (poligonali) e sono generati dalle seguenti formule:

Triangolo   P3,n = n(n + 1)/2     1, 3,  6, 10, 15, ...
Quadrato    P4,n = n^2            1, 4,  9, 16, 25, ...
Pentagonale P5,n = n(3n − 1)/2    1, 5, 12, 22, 35, ...
Esagonale   P6,n = n(2n − 1)      1, 6, 15, 28, 45, ...
Eptagonale  P7,n = n(5n − 3)/2    1, 7, 18, 34, 55, ...
Ottagonale  P8,n = n(3n − 2)      1, 8, 21, 40, 65, ...

L'insieme ordinato di tre numeri a 4 cifre: 8128, 2882, 8281, ha tre proprietà interessanti.

1) Il set è ciclico, in quanto le ultime due cifre di ogni numero sono le prime due cifre del numero successivo (compreso l'ultimo numero con il primo).
2) Ogni tipo poligonale: triangolo (P3,127 = 8128), quadrato (P4,91 = 8281) e pentagonale (P5,44 = 2882), è rappresentato da un numero diverso nell'insieme.
3) Questo è l'unico set di numeri a 4 cifre con questa proprietà.

Trova la somma dell'unico insieme ordinato di sei numeri ciclici a 4 cifre per i quali ogni tipo poligonale: triangolo, quadrato, pentagonale, esagonale, ettagonale e ottagonale, è rappresentato da un numero diverso nell'insieme.
============================================================================

L'algoritmo è abbastanza semplice, ma tedioso:

Creiamo le liste per ogni numero pentagonale (non possiamo avere un numero con lo 0 nella terza cifra ==> no ciclo).
Creiamo una lista totale con elementi univoci e ordinata.
Costruiamo una catena ciclica (valida) di numeri (percorrendo tutta la lista).
Se la catena contiene numeri da tutte le liste di numeri poligonali, allora abbiamo trovato la soluzione.

(define (do-tri)
  (let ((val 0) out '())
    (for (i 45 141)
      (setq val (/ (* i (+ i 1)) 2))
      (if (!= ((string val) 2) "0") (push val out -1)))
    out))

(define (do-square)
  (let ((val 0) out '())
    (for (i 32 99)
      (setq val (* i i))
      (if (!= ((string val) 2) "0") (push val out -1)))
    out))

(define (do-penta)
  (let ((val 0) out '())
    (for (i 26 81)
      (setq val (/ (* i (- (* 3 i) 1)) 2))
      (if (!= ((string val) 2) "0") (push val out -1)))
    out))

(define (do-hexa)
  (let ((val 0) out '())
    (for (i 23 71)
      (setq val (* i (- (* 2 i) 1)))
      (if (!= ((string val) 2) "0") (push val out -1)))
    out))

(define (do-hepta)
  (let ((val 0) out '())
    (for (i 21 63)
      (setq val (/ (* i (- (* 5 i) 3)) 2))
      (if (!= ((string val) 2) "0") (push val out -1)))
    out))

(define (do-octa)
  (let ((val 0) out '())
    (for (i 19 58)
      (setq val (* i (- (* 3 i) 2)))
      (if (!= ((string val) 2) "0") (push val out -1)))
    out))

(define (e061)
(catch
  (local (numeri chain all tri square penta hexa hepta octa
          ax1 ax2 ax3 ax4 ax5 ax6 bx1 bx2 bx3 bx4 bx5 bx6)
    (setq numeri (list 3 4 5 6 7 8))
    (setq chain '() all '())
    (setq tri (do-tri))
    (setq square (do-square))
    (setq penta (do-penta))
    (setq hexa (do-hexa))
    (setq hepta (do-hepta))
    (setq octa (do-octa))
    (setq all (apply extend (list tri square penta hexa hepta octa)))
    (setq all (sort (unique all)))
    ; costruisce la catena di numeri
    (dolist (x1 all)
      (setq ax1 (/ x1 100))
      (setq bx1 (% x1 100))
      (dolist (x2 all)
        (cond ((!= x1 x2)
               (setq ax2 (/ x2 100))
               (setq bx2 (% x2 100))
               (cond ((> ax2 bx1) nil)
                     ((= bx1 ax2)
                      (dolist (x3 all)
                        (cond ((!= x1 x2 x3)
                               (setq ax3 (/ x3 100))
                               (setq bx3 (% x3 100))
                               (cond ((> ax3 bx2) nil)
                                     ((= bx2 ax3)
                                      (dolist (x4 all)
                                        (cond ((!= x1 x2 x3 x4)
                                               (setq ax4 (/ x4 100))
                                               (setq bx4 (% x4 100))
                                               (cond ((> ax4 bx3) nil)
                                                     ((= bx3 ax4)
                                                      (dolist (x5 all)
                                                        (cond ((!= x1 x2 x3 x4 x5 x)
                                                               (setq ax5 (/ x5 100))
                                                               (setq bx5 (% x5 100))
                                                               (cond ((> ax5 bx4) nil)
                                                                     ((= bx4 ax5)
                                                                      (dolist (x6 all)
                                                                        (cond ((!= x1 x2 x3 x4 x5 x6)
                                                                               (setq ax6 (/ x6 100))
                                                                               (setq bx6 (% x6 100))
                                                                               (cond ((> ax6 bx5) nil)
                                                                                     ((and (= bx5 ax6) (= bx6 ax1))
                                                                                      ; creazione e controllo catena corrente
                                                                                      (setq chain (list x1 x2 x3 x4 x5 x6))
                                                                                      (setq lista '())
                                                                                      (dolist (x chain)
                                                                                        (cond ((find x octa) (push 8 lista))
                                                                                              ((find x hepta) (push 7 lista))
                                                                                              ((find x hexa) (push 6 lista))
                                                                                              ((find x penta) (push 5 lista))
                                                                                              ((find x square) (push 4 lista))
                                                                                              ((find x tri) (push 3 lista))
                                                                                        )
                                                                                        (setq lista (sort (unique lista)))
                                                                                        ; catena trovata
                                                                                        (if (= lista numeri) (throw (apply + chain)))
                                                                                      ))))))))))))))))))))))))))))))

(e061)
;-> 28684

(time (e061))
;-> 85.8
----------------------------------------------------------------------------


===========
Problema 62
===========

Permutazioni cubiche

Il cubo, 41063625 (3453), può essere permutato per produrre altri due cubi: 56623104 (3843) e 66430125 (4053). In effetti, 41063625 è il cubo più piccolo che ha esattamente tre permutazioni delle sue cifre che sono anche cubi.

Trova il cubo più piccolo per il quale esattamente cinque permutazioni delle sue cifre sono cubi.

Concetto di base:
Due liste con gli stessi elementi, ma in ordine diverso, producono le stesse permutazioni.

Esempio:
(setq lst1 '(1 2 3))
(setq lst2 '(2 3 1))

(sort (perm lst1))
;-> ((1 2 3) (1 3 2) (2 1 3) (2 3 1) (3 1 2) (3 2 1))

(sort (perm lst2))
;-> ((1 2 3) (1 3 2) (2 1 3) (2 3 1) (3 1 2) (3 2 1))

I numeri che possono essere permutati per produrre uno o più cubi hanno tutti le stesse cifre. Ordinando in modo decrescente le cifre di questi numeri notiamo che il risultato è lo stesso per i tutti i valori che, elevati al cubo, li generano. Vediamo un esempio:

valore   cubo                  ordinamento/codifica    risultato
3453 --> 3453^3 = 41063625 --> (digit-sort 41063625) = 66543210
3843 --> 3453^3 = 56623104 --> (digit-sort 56623104) = 66543210
4053 --> 4053^3 = 56623104 --> (digit-sort 66430125) = 66543210

In altre parole, i numeri 3453, 3843 e 4053 (che generano tutti un cubo con le stesse cifre) hanno la stessa codifica.  Per risolvere il problema occorre cercare una codifica che si ripete per 5 volte.
Quindi uno pseudo-algoritmo è il seguente:

1. valore = 0
2. codifica il valore.
3. inserisci la codifica in una lista.
4. se la codifica è presente 5 volte nella lista,
   allora il risultato vale (primo indice della codifica)^3. Stop.
   altrimenti aumenta di 1 il valore e vai al passo 3.

La prima codifica che utilizziamo è la seguente:

(setq i 27)
(setq cubo (explode (string (* i i i))))
;-> ("1" "9" "6" "8" "3")
(setq cubo (sort (explode (string (* i i i)))))
;-> ("1" "3" "6" "8" "9")

Quindi la lista contiene elementi del tipo: ("1" "3" "6" "8" "9")

Scriviamo la funzione:

(define (e062)
  (local (cubo lst num found out)
    (setq num 0 found nil)
    (until found
      ; calcoliamo la codifica
      (setq cubo (sort (explode (string (* num num num)))))
      ; inseriamo la codifica nella lista
      (push cubo lst -1)
      ; se la codifica corrente è presente 5 volte nella lista...
      (if (= (count (list cubo) lst) '(5))
          ; allora abbiamo trovato la soluzione
          (setq out (pow (first (ref cubo lst)) 3) found true)
      )
      (++ num)
    )
    out))

(e062)
;-> 127035954683

(time (e062))
;-> 23831.307

Proviamo a semplificare l'elemento della lista utilizzando un'altra codifica:

(setq i 27)
(setq cubo (explode (string (* i i i))))
;-> ("1" "9" "6" "8" "3")
(setq cubo (sort (explode (string (* i i i))) >))
;-> ("9" "8" "6" "3" "1")
(setq num 0)
(dolist (el cubo) (setq num (+ (int el) (* num 10))))
;-> 98631

Quindi la lista contiene elementi del tipo: 98631

Funzione che ordina in modo decrescente (per preservare lo zero) le cifre di un numero:

(define (digit-sort num)
  (let (out 0)
    (dolist (el (sort (explode (string num)) >))
      (setq out (+ (int el) (* out 10))))))

Scriviamo la funzione:

(define (e062)
  (local (cubo lst num found out)
    (setq num 0 found nil)
    (until found
      (setq cubo (digit-sort (* num num num)))
      (push cubo lst -1)
      (if (= (count (list cubo) lst) '(5))
          (setq out (pow (first (ref cubo lst)) 3) found true)
      )
      (++ num)
    )
    out))

(e062)
;-> 127035954683

(time (e062))
;-> 6348.037

Proviamo con un altra funzione "digit-sort" che ordina in modo decrescente (per preservare lo zero) le cifre di un numero:

(define (digit-sort num)
  (local (lst out)
    (setq lst (dup 0 10))
    (setq out 0)
    (while (> num 0)
      (++ (lst (% num 10)))
      (setq num (/ num 10))
    )
    (for (i 9 0 -1)
      (setq out (/ (- (* (pow 10 (lst i)) (+ i (* 9 out))) i) 9))
    )
    out))

(digit-sort 12340)
;-> 43210

(digit-sort 130987345354322)
;-> 987554433332210

Eseguiamo di nuovo la funzione:

(e062)
;-> 127035954683

(time (e062))
;-> 6305.131

I tempi di esecuzione delle due funzioni sono uguali.

Il secondo algoritmo utilizza una hash-map con la seguente struttura:

 chiave                       valore
((digit-sort (* num num num)) (num ripetizioni))

In questo modo la soluzione si trova quando le ripetizioni di una chiave vale 5. Maggiori spiegazioni nei commenti della funzione.

(define (e062-2)
  (local (cubo lst num found out)
    (new Tree 'myHash)
    (setq num 0 found nil)
    (until found
      ; calcola il valore della chiave
      ; es. num=5 -> num*num*num = 125 -> cubo = 521
      (setq cubo (digit-sort (* num num num)))
      ; se la chiave non esiste nella hashmap...
      (if (null? (myHash cubo))
          ; allora inserisce il cubo (chiave) con la lista (num 1) (valore)
          ; nella lista (num 1), 1 rappresenta il numero di ripetizioni del cubo
          ; mentre num rappresenta il numero da elevare a potenza
          (myHash cubo (list num 1))
          ; altrimenti aggiunge 1 al numero di ripetizioni nella lista (valore)
          (begin
            ; occorre ricostruire tutta la lista associata alla valore di cubo (chiave)
            (myHash cubo (list (first $it) (+ (last $it) 1)))
            ; se il numero di ripetizioni vale 5
            (if (= 5 (last (myHash cubo)))
                ; allora abbiamo trovato la soluzione
                (setq out (pow (first (myHash cubo)) 3) found true)
            )
          )
      )
      (++ num)
    )
    ; elimina la hash-map
    (delete 'myHash)
    out))

Vediamo come si comporta questa funzione:

(e062-2)
;-> 127035954683

(time (e062-2))
;-> 83.742

L'utilizzo di una hash-map fornisce la soluzione immediatamente.
----------------------------------------------------------------------------


===========
Problema 63
===========

Conteggio di cifre di potenze

Il numero di 5 cifre, 16807 = 7^5, è anche una quinta potenza. Allo stesso modo, il numero di 9 cifre, 134217728 = 8^9, è una nona potenza.

Quanti numeri interi positivi di n cifre esistono che sono anche un'ennesima potenza?
============================================================================

Cerchiamo un numero n tale che la lunghezza di n elevato a k sia k:  L(n^k) = k

Calcoliamo il limite superiore di n:

k = L(n^k)
k = floor(1 + log10(k^k))
k - 1 <= k*log10(n) < k
log10(n) < 1
n < 10

Quindi il valore massimo per n è 9.

Calcoliamo il limite superiore di k:

L(n^k) > k
floor(1 + k*log10(n^k)) > k
1 + k*log10(n) > k
log10(n) > (k - 1)/k = 1 - 1/k
1/k > 1 - log10(n)
k > 1/(1 - log10(n))

Con n=9 il valore massimo per k è 21:

(div (sub 1 (log 9 10)))
;-> 21.85434532678283

(define (e063)
  (let (c  0)
    (for (n 1 9)
      (for (k 1 21)
        (if (= (floor (add 1 (mul k (log n 10)))) k)
          (++ c)
        )
      )
    )
    c))

(e063)
;-> 49

(time (e063))
;-> 0

Dal punto di vista matematico possiamo notare che dalla definizione della lunghezza di  un numero L risulta:

10^(k-1) <= n^k < 10^k

Poichè n < 10, risulta che 10^(k-1) cresce più velocemente di n^k e ad un certo punto lo sorpasserà. Quindi troviamo il punto in cui queste quantità sono uguali:

10^(k-1) = n^k
(1/10)*10^k = n^k
k*log(10) - log(10) = k*log(n)
k = log(10)/(log(10 - log(n)))

Questa volta k rappresenta il numero di volte in cui le quantità considerate sono uguali (prendiamo floor(k)). La funzione è la seguente:

(define (e063-2)
  (let (res 0)
    (for (i 1 9)
      (setq res (add res (floor (div (log 10) (log (div 10 i))))))
    )
    res))

(e063-2)
;-> 49

(time (e063-2))
;-> 0

Questa seconda soluzione è molto più veloce:

(time (e063) 10000)
;-> 392.976

(time (e063-2) 10000)
;-> 20.965
----------------------------------------------------------------------------


===========
Problema 64
===========

Ogni radice quadrata può essere rappresentata con una frazione continua.

La frazione continua di sqrt(23) vale [4, (1,3,1,8)].
La notazione indica che la frazione continua inizia con 4 e il blocco (1,3,1,8) si ripete indefinitamente.

Le prime dieci rappresentazioni di frazione continua di radici quadrate (irrazionali) sono:

sqrt( 2) = [1, (2)],         periodo = 1
sqrt( 3) = [1, (1,2)],       periodo = 2
sqrt( 4) = [2, (4)],         periodo = 1
sqrt( 6) = [2, (2,4)],       periodo = 2
sqrt( 7) = [2, (1,1,1,1)],   periodo = 4
sqrt( 8) = [2, (1,4)],       periodo = 2
sqrt(10) = [3, (6)],         periodo = 1
sqrt(11) = [3, (3,6)],       periodo = 2
sqrt(12) = [3, (2,6)],       periodo = 2
sqrt(13) = [3, (1,1,1,1,6)], periodo = 5

Esattamente quattro frazioni continue hanno un periodo dispari.

Quante frazioni continue per N <= 10000 hanno un periodo dispari?
============================================================================

L'algoritmo presentato dall'articolo "Methods of computing square roots" di wikipedia è il seguente:

Start:
 m[0] = 0
 d[0] = 1
 a[0] = floor(sqrt(n))
 k = a[0]
Loop:
 m[i] = a[i-1]*d[i-1] - m[i-1]
 d[i] = (n-m[i]*m[i])/d[i-1]
 a[i] = floor((k + m[i])/d[i])
Stop: quando la i-esima tripla è stata generata precedentemente.

Note: m[i],d[i],a[i] sono sempre interi.

L'articolo di Alexandra Ioana Gliga "On continued fractions of the square root of prime numbers" dimostra che per ogni numero intero positivo che non è un quadrato perfetto risulta:

  sqrt(n) = [a1, (a2 a3 ... an 2*a1)]

Questo ci permette di fermare il ciclo quando l'i-esimo valore vale 2*a1.

Scriviamo la funzione:

(define (e064)
  (local (max-val out limite)
    (setq max-val 10000)
    (setq out 0)
    (for (n 2 max-val)
      (setq limite (int (sqrt n)))
      ; l'algortimo non funziona quando abbiamo un quadrato perfetto
      ; quindi saltiamo questi casi che non influenzano il risultato finale
      (if (!= (* limite limite ) n)
          (let ((periodo 0) (d 1) (m 0) (a limite))
            (do-while (!= a (* 2 limite))
              (setq m (- (* d a) m))
              (setq d (/ (- n (* m m)) d))
              (setq a (/ (+ limite m) d))
              (++ periodo)
            )
            (if (odd? periodo) (++ out))
          )
      )
    )
    out))

(e064)
;-> 1322

(time (e064))
;-> 81.294
----------------------------------------------------------------------------


===========
Problema 65
===========

Convergenti di e

La radice quadrata di 2 può essere scritta come una frazione continua infinita.
                       1
sqrt(2) = 1 + --------------------
                         1
              2 + ----------------
                           1
                  2 + ------------
                             1
                      2 + --------
                          2 + ...

La frazione continua infinita può essere scritta come sqrt(2) = [1, (2)] indica che 2 si ripete all'infinito. In un modo simile, sqrt(23) = [4, (1,3,1,8)].

Risulta che la sequenza dei valori parziali delle frazioni continue per le radici quadrate fornisce le migliori approssimazioni razionali. Consideriamo i convergenti per sqrt(2):

1 + 1/2 = 3/2
1 + 1/(2 + 1/2) = 7/5
1 + 1/(2 + 1/(2 + 1/2)) = 17/12
1 + 1/(2 + 1/(2 + 1/(2 + 1/2))) = 41/29

Quindi la sequenza dei primi dieci convergenti per sqrt(2) sono:

1, 3/2, 7/5, 17/12, 41/29, 99/70 239/169, 577/408, 1393/985, 3363/2378, ...

La cosa più sorprendente è che per l'importante costante matematica "e" risulta:

e = [2,1,2,1,1,4,1,1,6,1...1,2k,1...]

I primi dieci termini nella sequenza di convergenti per e sono:

2, 3, 8/3, 11/4, 19/7, 87/32, 106/39, 193/71, 1264/465, 1457/536, ...

La somma delle cifre al numeratore del decimo convergente è 1 + 4 + 5 + 7 = 17.

Trova la somma delle cifre del numeratore del centesimo convergente della frazione continua per "e".
============================================================================

Calcoliamo i primi n termini della frazione continua del numero tenendo conto che il pattern ...1,2n,1... si ripete all'infinito: cf(e) = [2, 1,2,1, 1,4,1, 1,6,1, 1,8,1, 1,10,1, ...]

(define (cf_e n)
  (let (cfe '(2))
    (for (i 1 (- n 1))
      (extend cfe (list 1 (* 2 i) 1)))
    (slice cfe 0 n)))

(cf_e 20)
;-> (2 1 2 1 1 4 1 1 6 1 1 8 1 1 10 1 1 12 1 1)

Poi scriviamo una funzione che calcola i convergenti partendo da una frazione continua e restituisce l'ultima delle frazioni convergenti Pn/Qn (dobbiamo usare i big-integer perchè il numeratore e il denominatore delle frazioni convergenti crescono velocemente):

(define (cf2conv cf)
  (local (p0 q0 p1 q1 p2 q2)
    (cond ((= (length cf) 1) (setq p2 (first cf) q2 1))
          (true
           (setq p0 1L q0 0L)
           (setq p1 (bigint (cf 0)) q1 1L)
           (for (k 1 (- (length cf) 1))
             (setq p2 (+ (* p1 (cf k)) p0))
             (setq q2 (+ (* q1 (cf k)) q0))
             ; k-esima frazione convergente
             ;(println (list p2 q2 (div p2 q2)))
             (setq p0 p1 q0 q1 p1 p2 q1 q2)
           ))
    )
    (list p2 q2)))

(cf2conv (cf_e 20))
;-> (28245729L 10391023L)

Poi ci serve una funzione che converte un numero in una lista:

(define (int2lst num)
  (let (out '())
    (while (!= num 0)
      (push (% num 10) out)
      (setq num (/ num 10))) out))

Adesso possiamo scrivere la funzione finale:

(define (e065)
  (local (numer)
    (setq numer (first (cf2conv (cf_e 100))))
    (apply + (int2lst numer))))

(e065)
;-> 272L

(time (e065))
;-> 0
----------------------------------------------------------------------------


===========
Problema 66
===========

# Equazione di Pell
# x^2 - D*y^2 = 1
#
# Espandere sqrt(D) in frazione continua
# sqrt(D) = [q0,q1,q2,...,qn,2*q0]
# Periodo della frazione continua = n
# Calcolare l'n-esimo convergente della frazione continua (Pn/Qn).
# Se n è dispari allora Pn e Qn sono la soluzione.
# Se n è pari occorre:
#    Espandere sqrt(D) in frazione continua fino al termine (2n+1)
#    Calcolare i convergenti fino al termine (2n+1).
#    P(2*n+1) e Q(2*n+1) sono le soluzioni.

(define (Pell n)
  (local (z r x y e1 e2 f1 f2 A B t1 t2)
    (setq x (bigint (int (sqrt n))))
    (setq y x)
    (setq z 1L)
    (setq r (* x 2))
    (setq e1 1L e2 0L)
    (setq f1 0L f2 1L)
    (catch
      (while true
        (setq y (bigint (- (* r z) y)))
        (setq z (bigint (/ (- n (* y y)) z)))
        (setq r (bigint (/ (+ x y) z)))
        (setq t1 e1) (setq t2 e2)
        (setq e1 t2)
        (setq e2 (bigint (+ (* t2 r) t1)))
        (setq t1 f1) (setq t2 f2)
        (setq f1 t2)
        (setq f2 (bigint (+ (* t2 r) t1)))
        (setq A f2)
        (setq B e2)
        (setq t1 A) (setq t2 B)
        (setq B t1)
        (setq A (bigint (+ (* t1 x) t2)))
        (if (= (- (* A A) (* B B n)) 1) (throw (list A B)))
        ;(println (format "z = %s\nr = %s\nx = %s\ny = %s" (string z) (string r) (string x) (string y)))
        ;(println (format "e1 = %s\ne2 = %s\nf1 = %s\nf2 = %s" (string e1) (string e2) (string f1) (string f2)))
        ;(println (format "A = %s\nB = %s" (string A) (string B)))
        ;(read-line)
      );while
    );catch
  );local
)

(Pell 61)
;-> (1766319049L 226153980L)

(Pell 109)
;-> (158070671986249L 15140424455100L)

(Pell 181)
;-> (2469645423824185801L 183567298683461940L)

(Pell 277)
;-> (159150073798980475849L 9562401173878027020L)

Se passiamo un numero quadrato, otteniamo un errore:

(Pell 4)
;-> ERR: division by zero
;-> called from user function (Pell 4)

Scriviamo la funzione finale per risolvere il problema:

(define (e066)
  (let ((maxval -1) (out 0))
    (for (i 1 1000)
      (if (!= (sqrt i) (int (sqrt i)))
          (if (> (first (Pell i)) maxval)
              (setq maxval (first (Pell i)) out i))))
    out))

(e066)
;-> 661

(time e066)
;-> 0
----------------------------------------------------------------------------


===========
Problema 67
===========

Percorso con somma massima II

Iniziando dalla parte superiore del triangolo in basso e passando ai numeri adiacenti sulla riga sottostante, il totale massimo dall'alto verso il basso è 23.

   3
  7 4
 2 4 6
8 5 9 3

Cioè, 3 + 7 + 4 + 9 = 23.

Trovare il totale massimo dall'alto verso il basso utilizzando "triangle.txt", un file di testo di 15K contenente un triangolo con cento righe.

NOTA: questa è una versione molto più difficile del problema 18. Non è possibile provare tutti i percorsi per risolvere questo problema, poiché ce ne sono 2^99 in tutto! Potendo controllare un trilione (10^12) di percorsi ogni secondo, ci vorrebbero oltre venti miliardi di anni per controllarli tutti. C'è un algoritmo efficiente per risolverlo.
============================================================================

Il file "triangle.txt" è stato trasformato in "e067.lsp" che ha il seguente formato:

(setq tri (dup 0 100))
(setf (tri 0) '(59))
(setf (tri 1) '(73 41))
(setf (tri 2) '(52 40 9))
(setf (tri 3) '(26 53 6 34))
...

Per caricare il file:

(load "e067.lsp")

Una soluzione generica può essere ottenuta con la programmazione dinamica. In pratica per trovare la soluzione, ogni riga deve essere aggiunta a qualsiasi riga successiva, dal basso verso l'alto. Poiché ogni cella ha due predecessori, prendiamo il valore massimo delle due. Con questo metodo, la soluzione si trova nella cella superiore del triangolo:

(load "e067.lsp")

(define (e067)
    (for (i (- (length tri) 2) 0 -1)
      (for (j 0 i)
        (setf (tri i j) (+ (tri i j) (max (tri (+ i 1) j) (tri (+ i 1) (+ j 1)))))
      )
    )
    (tri 0 0))

(e067)
;-> 7273

(time (e067))
;-> 1.995
----------------------------------------------------------------------------


===========
Problema 68
===========

Considera il seguente anello "magico" 3-gon, riempito con i numeri da 1 a 6 e ogni riga somma a nove.

       4
        \
         3
        / \
       1---2---6
      /
     5

Lavorando in senso orario, e partendo dal gruppo di tre con il nodo esterno numericamente più basso (4,3,2 in questo esempio), ogni soluzione può essere descritta in modo univoco. Ad esempio, la soluzione di cui sopra può essere descritta dall'insieme: 4,3,2 - 6,2,1 - 5,1,3.

È possibile completare l'anello con quattro diversi totali: 9, 10, 11 e 12. Ci sono otto soluzioni in totale.

Totale   Soluzioni
   9     4,2,3 - 5,3,1 - 6,1,2
   9     4,3,2 - 6,2,1 - 5,1,3
  10     2,3,5 - 4,5,1 - 6,1,3
  10     2,5,3 - 6,3,1 - 4,1,5
  11     1,4,6 - 3,6,2 - 5,2,4
  11     1,6,4 - 5,4,2 - 3,2,6
  12     1,5,6 - 2,6,4 - 3,4,5
  12     1,6,5 - 3,5,4 - 2,4,6

Concatenando ogni gruppo è possibile formare stringhe di 9 cifre: la stringa massima per un anello 3-gon è 432621513.

Utilizzando i numeri da 1 a 10, a seconda degli arrangiamenti, è possibile formare stringhe di 16 e 17 cifre. Qual è il numero massimo di 16 cifre per un anello "magico" 5-gon?
============================================================================

Funzione che calcola le permutazioni:

(define (perm lst)
  (local (i indici out)
    (setq indici (dup 0 (length lst)))
    (setq i 0)
    ; aggiungiamo la lista iniziale alla soluzione
    (setq out (list lst))
    (while (< i (length lst))
      (if (< (indici i) i)
          (begin
            (if (zero? (% i 2))
              (swap (lst 0) (lst i))
              (swap (lst (indici i)) (lst i))
            )
            ;(println lst);
            (push lst out -1)
            (++ (indici i))
            (setq i 0)
          )
          (begin
            (setf (indici i) 0)
            (++ i)
          )
       )
    )
    out))

(define (gon lst)
  (local (is-gon gonL pL6 pL7 pL8 pL9 pL10 p6 p7 p8 p9 p10)
    (setq is-gon nil)
    (setq gonL '() pL6 '() pL7 '() pL8 '() pL9 '() pL10 '())
    (setq p6  (+ (lst 6)  (lst 1) (lst 2)))
    (setq p7  (+ (lst 7)  (lst 2) (lst 3)))
    (setq p8  (+ (lst 8)  (lst 3) (lst 4)))
    (setq p9  (+ (lst 9)  (lst 4) (lst 5)))
    (setq p10 (+ (lst 10) (lst 5) (lst 1)))
    ; Controllo se le somme sono uguali
    (cond ((and (= p6 p7) (= p7 p8) (= p8 p10) (= p9 p10))
           (setq is-gon true)
           ; Cerco l'indice del valore minimo esterno
           ; cioè cerco il numero 6, perchè all'esterno ci devono
           ; stare i numeri 6,7,8,9,10.
           (setq indice (find 6 lst))
           ; Costruisco la lista soluzione
           (setq pL6  (list (lst 6)  (lst 1) (lst 2)))
           (setq pL7  (list (lst 7)  (lst 2) (lst 3)))
           (setq pL8  (list (lst 8)  (lst 3) (lst 4)))
           (setq pL9  (list (lst 9)  (lst 4) (lst 5)))
           (setq pL10 (list (lst 10) (lst 5) (lst 1)))
           (cond ((= indice 6)  (setq gonL (apply extend (list pL6  pL7  pL8  pL9  pL10))))
                 ((= indice 7)  (setq gonL (apply extend (list pL7  pL8  pL9  pL10 pL6))))
                 ((= indice 8)  (setq gonL (apply extend (list pL8  pL9  pL10 pL6  pL7))))
                 ((= indice 9)  (setq gonL (apply extend (list pL9  pL10 pL6  pL7  pL8))))
                 ((= indice 10) (setq gonL (apply extend (list pL10 pL6  pL7  pL8  pL9))))
           ))
    )
    (if is-gon
        (list gonL p6)
        (list '() 0))))

(define (e068)
  (local (vmax pa pb val go x y)
    (setq vmax 0)
    (setq pa (perm '(1 2 3 4 5)))
    (setq pb (perm '(6 7 8 9 10)))
    (dolist (a pa)
      (setq val '())
      (dolist (b pb)
        (setq val (apply extend (list '(0) a b)))
        (setq go (gon val))
        (setq x (first go))
        (setq y (last go))
        (if (!= y 0)
          (begin
           ;(println x { } y)
           (if (> (int (join (map string x))) vmax)
               (setq vmax (int (join (map string x))))
           ))
        )
      )
    )
    vmax))

(e068)
;-> 6531031914842725

(time (e068))
;-> 21.97
----------------------------------------------------------------------------


===========
Problema 69
===========

La funzione toziente di Eulero, φ(n) (a volte chiamata funzione phi), è usata per determinare il numero di numeri positivi minori o uguali a n che sono primi relativamente a n. Ad esempio, poiché 1, 2, 4, 5, 7 e 8 sono tutti inferiori a nove e primi relativamente a nove, φ(9) = 6.
Il numero 1 è considerato relativamente primo rispetto a ogni numero positivo, quindi φ(1)= 1.

 n | Relatively Prime | φ(n) | n/φ(n)    |
 -----------------------------------------
 2 | 1                | 1    | 2         |
 3 | 1,2              | 2    | 1.5       |
 4 | 1,3              | 2    | 2         |
 5 | 1,2,3,4          | 4    | 1.25      |
 6 | 1,5              | 2    | 3         |
 7 | 1,2,3,4,5,6      | 6    | 1.1666... |
 8 | 1,3,5,7          | 4    | 2         |
 9 | 1,2,4,5,7,8      | 6    | 1.5       |
10 | 1,3,7,9          | 4    | 2.5       |

Si può vedere che n = 6 produce un massimo n/φ(n) per n ≤ 10.

Trova il valore di n ≤ 1000000 per cui il rapporto n/φ(n) è massimo.
============================================================================

Utilizziamo un approccio con la forza bruta.

Funzione che calcola il toziente da 0 fino a n numeri:

(define (totients-to num)
  (let (phi (array (+ num 1) '(0)))
    (setf (phi 0) 0)
    (setf (phi 1) 1)
    (for (i 2 num)
      (setf (phi i) i))
    (for (i 2 num)
      (if (= (phi i) i)
          (for (j i num i)
            (setf (phi j) (- (phi j) (/ (phi j) i))))))
     phi))

(totients-to 10)
;-> (0 1 1 2 2 4 2 6 4 6 4)

Scriviamo la funzione finale:

(define (e069)
  (local (t idx cur-val max-val)
    (setq t (totients-to 1000000))
    (setq max-val -1)
    (setq idx-val nil)
    ; cerca il valore massimo
    (for (i 0 1000000)
      (setq cur-val (t i))
      (if (> (div i cur-val) max-val)
          (setq idx-val i max-val (div i cur-val))
      )
    )
    idx-val))

(e069)
;-> 510510

(time (e069))
;-> 642.279
----------------------------------------------------------------------------


===========
Problema 70
===========

Pemutazione toziente

La funzione toziente di Eulero, φ(n) (a volte chiamata funzione phi), è usata per determinare il numero di numeri positivi minori o uguali a n che sono primi relativamente a n. Ad esempio, poiché 1, 2, 4, 5, 7 e 8 sono tutti inferiori a nove e primi relativamente a nove, φ(9) = 6.
Il numero 1 è considerato relativamente primo rispetto a ogni numero positivo, quindi φ(1)= 1.

È interessante notare che φ(87109) = 79180, e si può vedere che 87109 è una permutazione di 79180.

Trova il valore di n, 1 < n < 10^7, per cui φ(n) è una permutazione di ne il rapporto n/φ(n) produce un minimo.
============================================================================

Utilizziamo un approccio con la forza bruta.

Funzione che verifica se due numeri hanno le stesse cifre:

(define (perm? n1 n2)
  (if (!= (length n1) (length n2))
      nil
      (let (ar (array 10 '(0)))
        (while (!= n1 0)
            (++ (ar (% n1 10)))
            (setq n1 (/ n1 10))
        )
        ;(println ar)
        (while (!= n2 0)
            (-- (ar (% n2 10)))
            (setq n2 (/ n2 10))
        )
        ;(println ar)
        (= (count '(0) (array-list ar)) '(10)))))

(perm? 123123 112233)
;-> true

Funzione che calcola il toziente da 0 fino a n numeri:

(define (totients-to num)
  (let (phi (array (+ num 1) '(0)))
    (setf (phi 0) 0)
    (setf (phi 1) 1)
    (for (i 2 num)
      (setf (phi i) i))
    (for (i 2 num)
      (if (= (phi i) i)
          (for (j i num i)
            (setf (phi j) (- (phi j) (/ (phi j) i))))))
     phi))

(totients-to 10)
;-> (0 1 1 2 2 4 2 6 4 6 4)

Scriviamo la funzione finale:

(define (e070)
  (local (t idx cur-val min-val)
    (setq t (totients-to 9999999))
    (setq min-val 999999)
    (setq idx-val nil)
    ; cerca il valore minimo
    (for (i 2 9999999)
      (setq cur-val (t i))
      (if (< (div i cur-val) min-val)
          (if (perm? cur-val i)
                  (setq idx-val i min-val (div i cur-val))
              )
          )
    )
    idx-val))

(e070)
;-> 8319823

(time (e070))
;-> 9621.575

Dal punto di vistta matematico possimo notare che:

1) Rendere minimo n/φ(n) equivale a massimizzare φ(n)/n, che si verifica quando n ha il minor numero di fattori primi possibile.
2) φ(n) = n - 1 dove n è primo, poiché tutti i numeri sotto sono coprimi per definizione
3) φ(n) = φ(p*q) = (p - 1) (q - 1) dove n è semiprimo e p e q sono i suoi fattori e p <> q.
4) φ(n) = φ(p2) = (p - 1) p dove n è semiprime ep è il suo unico fattore distinto.
5) n - 1 non può essere una permutazione di n, quindi il nostro n non può essere un primo, ma è probabilmente il prodotto di due numeri primi (semiprimi).

Funzone che calcola tutti i numeri primi da 1 fino a un dato numero:

(define (primes-to num)
  (cond ((= num 1) '())
        ((= num 2) '(2))
        (true
         (let (lst '(2))
          (setq arr (array (+ num 1)))
          (for (x 3 num 2)
                (when (not (arr x))
                  (push x lst -1)
                  (for (y (* x x) num (* 2 x) (> y num))
                      (setf (arr y) true)))) lst))))

Le considerazioni precedenti portano (dopo molti tentativi) alla seguente funzione:

(define (e070)
(catch
  (local (num primi min-q min-n q n totient)
  (setq num 10000000)
  (setq primi (primes-to (int (mul 1.25 (sqrt num)))))
  (setq primi (slice primi (int (mul 0.5 (length primi)))))
  (setq min-q 2 min-n 0 i 0)
  (dolist (p1 primi)
    (dolist (p2 (slice primi i))
      (cond ((!= (% (+ p1 p2) 9) 1) nil)
            (true
             (setq n (* p1 p2))
             (if (> n num) (throw min-n)) ; soluzione trovata
             (setq totient (* (- p1 1) (- p2 1)))
             (setq q (div n totient))
             (if (and (> min-q q) (perm? totient n))
                 (setq min-q q min-n n))))))
  'not-found)))

(e070)
;-> 8319823

(time (e070))
;-> 7.012
----------------------------------------------------------------------------


===========
Problema 71
===========

Frazioni ordinate

Considera la frazione, n/d, dove n e d sono numeri interi positivi. Se n < d e HCF(n,d) = 1, si parla di frazione propria ridotta.

Se elenchiamo l'insieme delle frazioni proprie ridotte per d ≤ 8 in ordine crescente di dimensione, otteniamo:

1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8

Si può vedere che 2/5 è la frazione immediatamente a sinistra di 3/7.

Elencando l'insieme delle frazioni proprie ridotte per d ≤ 1.000.000 in ordine crescente di dimensione, trova il numeratore della frazione immediatamente a sinistra di 3/7.
============================================================================

Nota: HCF = High Common Factor (fattore comune maggiore)

(define (find-upper n base)
  (let ((a 1) (cont true))
    (while (and (< a n) cont)
      (if (> (div a n) base)
          (setq cont nil)
          (++ a)))
    a))

(find-upper 8 (div 3 7))
;-> 4
(find-upper 1000000 (div 3 7))
;-> 428572

(define (e071)
  (local (n num den minimo base limite a b)
    (setq n 1000000)
    (++ n)
    (setq num 1 den 1)
    (setq minimo 0)
    (setq base (div 3 7))
    (setq limite (find-upper n base))
    (setq a (- limite 2))
    (while (< a limite)
      (setq b (+ a 1))
      (while (< b n)
        (setq v (div a b))
        (if (and (< v base) ( > v minimo))
            (setq num a den b minimo (div num den))
        )
        (++ b)
      )
      (++ a)
    )
    ;(list num den (div num den))
    num))

(e071 1000000)
;-> 428570

(time (e071))
;-> 191.169
----------------------------------------------------------------------------


===========
Problema 72
===========

Conteggio delle frazioni

Considera la frazione, n/d, dove n e d sono numeri interi positivi. Se n <de HCF (n, d) = 1, si parla di frazione propria ridotta.

Se elenchiamo l'insieme delle frazioni proprie ridotte per d ≤ 8 in ordine crescente di dimensione, otteniamo:

1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8

Si può vedere che ci sono 21 elementi in questo set.

Quanti elementi sarebbero contenuti nell'insieme delle frazioni proprie ridotte per d ≤ 1.000.000?
============================================================================

Ordinando le frazioni in una matrice si ottiene il seguente risultato (n=10):

  1/2   1/3   1/4   1/5   1/6   1/7   1/8   1/9  1/10
    0   2/3   1/2   2/5   1/3   2/7   1/4   2/9   1/5
    0     0   3/4   3/5   1/2   3/7   3/8   1/3  3/10
    0     0     0   4/5   2/3   4/7   1/2   4/9   2/5
    0     0     0     0   5/6   5/7   5/8   5/9   1/2
    0     0     0     0     0   6/7   3/4   2/3   3/5
    0     0     0     0     0     0   7/8   7/9  7/10
    0     0     0     0     0     0     0   8/9   4/5
    0     0     0     0     0     0     0     0  9/10
    0     0     0     0     0     0     0     0     0

(1/2, 1/3, 1/4, 1/5, 1/6, 1/7, 1/8, 1/9, 1/10, 2/3, 2/5, 2/7, 2/9,
3/4, 3/5, 3/7, 3/8, 3/10, 4/5, 4/7, 4/9, 5/6, 5/7, 5/8, 5/9, 6/7,
7/8, 7/9, 7/10, 8/9, 9/10)

Notiamo che:
a) le colonne con denominatore numero primo hanno (denominatore - 1) termini.
b) le colonne con denominatore non primo hanno toziente(denominatore) termini.
(dove toziente(n) è il numero di interi minori di n che sono primi rispetto a n)

Funzione che verifica se un numero è primo:

(define (prime? num)
   (if (< num 2) nil
       (= 1 (length (factor num)))))

Funzione che calcola il toziente di un numero:

(define (toziente num)
  (if (= num 1) 1
    (let (res num)
      (dolist (f (unique (factor num)))
        (setq res (- res (/ res f))))
      res)))

Scriviamo la funzione finale:

(define (e072)
  (let ((num 1000000) (somma 0))
    (for (i 2 num)
      (if (prime? i)
          (setq somma (+ somma (- i 1)))
          (setq somma (+ somma (toziente i)))
      )
    )
    somma))

(e072)
;-> 303963552391

(time (e072))
;-> 2060.973
----------------------------------------------------------------------------


===========
Problema 73
===========

Conteggio delle frazioni in un intervallo

Considera la frazione, n/d, dove n e d sono numeri interi positivi. Se n < d e HCF(n,d) = 1, si parla di frazione propria ridotta.

Se elenchiamo l'insieme delle frazioni proprie ridotte per d ≤ 8 in ordine crescente di dimensione, otteniamo:

1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8

Si può vedere che ci sono tre frazioni tra 1/3 e 1/2

Quante frazioni si trovano tra 1/3 e 1/2 nell'insieme ordinato di frazioni proprie ridotte per d ≤ 12.000?.
============================================================================

Nota: HCF = High Common Factor (fattore comune maggiore)

Soluzione brute-force:

(define (find-upper n x)
(catch
  (let (a 1)
    (while (< a n)
      (if (> (div a n) x) (throw a))
      (++ a))
    a)))

(define (e073 n)
(catch
  (local (nmin nmax limite a b v continua out)
    (++ n)
    (setq out '())
    (setq nmin (div 1 3))
    (setq nmax (div 1 2))
    (setq limite (find-upper n 0.5))
    (setq a 1)
    (while (< a limite)
      (setq b (+ a 1))
      (setq continua true)
      (while (and (< b n) continua)
        (setq v (div a b))
        ;(println a { } b { } v)
        (cond ((and (< v nmax) (> v nmin))
               (push v out -1)
               (++ somma))
              ; da qui fino al prossimo valore di 'a' tutte le frazioni sono minori...
              ((< v nmin)
               (setq continua nil))
              ; da qui in poi tutte le frazioni sono maggiori...
              ((and (> v nmax) (= b (- n 1)))
               (throw (length (unique out))))
        )
        (if continua (++ b))
      )
      (++ a)
    )
    (length (unique out)))))

(e073 12000)
;-> 7295372

(time (e073 12000))
;-> 16306.157

Invece di trovare il limite superiore, possiamo iterare su tutti i possibili denominatori e verificare che i numeratori soddisfino le condizioni.

La funzione diventa la seguente:

(define (e073)
  (local (a b num den limite somma)
    (setq a 3 b 2)
    (setq somma 0 limite 12000)
    (for (den 5 limite)
      (setq num (int (+ (div den a) 1)))
      (for (n num (int (div (- den 1) b)))
        (if (= (gcd n den) 1) (++ somma))
      )
    )
    somma))

(e073)
;-> 7295372

(time (e073))
;-> 1809.163

Dal punto di vista matematico possiamo utilizzare la sequenza di Farey.
Nel libro "Il libro dei numeri" di Conway e Guy viene spiegato come calcolare la sequenza successiva  di Farey a partire da uno degli n termini:
inserire la frazione mediante (a + b)/(c + d) tra i termini a/c e b/d quando c + d <= n. Dato 0 <= a/b < c/d <= 1 con b*c-a*d = 1, sia h/k la mediante di a/b e c/d. Allora a/b < h/k < c/d, e queste frazioni soddisfano le relazioni unimodulari

  b*h - a*k = 1

  c*k - d*h = 1

Questo metodo viene implementato nella seguente funzione:

(define (e073)
  (local (ar idx c d mediant somma continua)
    (setq ar (array 12000 '(0)))
    (setq idx 0)
    (setq c 3 d 2)
    (setq somma 0)
    (setq continua true)
    (while continua
      (setq mediant (+ c d))
      (cond ((<= mediant 12000)
             (++ somma)
             (setf (ar idx) d)
             (++ idx)
             (setq d mediant))
            (true
             (if (zero? idx) (setq continua nil))
             (setq c d)
             (-- idx)
             (setq d (ar idx)))
      )
    )
    somma))

(e073)
;-> 7295372

(time (e073))
;-> 2345.727
----------------------------------------------------------------------------


===========
Problema 74
===========

Il numero 145 è ben noto per la proprietà che la somma del fattoriale delle sue cifre è pari a 145:

1! + 4! + 5! = 1 + 24 + 120 = 145

Forse meno noto è 169, in quanto produce la catena di numeri più lunga che ricollega a 169: si scopre che esistono solo tre di tali loop:

169 → 363601 → 1454 → 169
871 → 45361 → 871
872 → 45362 → 872

Non è difficile dimostrare che OGNI numero di partenza alla fine rimarrà bloccato in un ciclo. Per esempio,

69 → 363600 → 1454 → 169 → 363601 (→ 1454)
78 → 45360 → 871 → 45361 (→ 871)
540 → 145 (→ 145)

Iniziare con 69 produce una catena di cinque termini non ripetitivi, ma la catena non ripetitiva più lunga con un numero iniziale inferiore a un milione è sessanta termini.

Quante catene, con un numero iniziale inferiore a un milione, contengono esattamente sessanta termini non ripetitivi?
============================================================================

Scriviamo la funzione che calcola la somma dei fattoriali delle cifre di un numero:

(define (sumfatt num)
       ; precodifica dei fattoriali da 0 a 9
  (let ((fact '(1 1 2 6 24 120 720 5040 40320 362880))
        (temp num) (out 0))
    (while (> temp 0)
      (setq out (+ out (fact (% temp 10))))
      (setq temp (/ temp 10))
    )
    out))

(sumfatt 145)
;-> 145
(sumfatt 169)
;-> 363601
(sumfatt 363601)
;-> 1454

Utilizziamo la forza bruta: costruiamo la catena per ogni numero (in una lista) e controlliamo se è lunga 60, in tal caso aumentiamo di 1 il conteggio.

(define (e074)
  (local (limite num chain out)
    (setq out 0 limite 1000000)
    (for (i 1 limite)
      (setq num i)
      (setq chain '())
      (until (find num chain)
        (push num chain -1)
        (setq num (sumfatt num))
      )
      (if (= (length chain) 60) (++ out))
    )
    out))

(e074)
;-> 402

(time (e074))
;-> 32332.048

Proviamo ad utilizzare una hash-map al posto della lista:

(define (e074)
  ;(local (limite num chain out)
  (local (limite num out)
    (setq out 0 limite 1000000)
    (for (i 1 limite)
      (setq num i)
      ;(setq chain '())
      (new Tree 'chain)
      ;(until (find num chain)
      (until (chain num)
        ;(push num chain -1)
        (chain num num)
        (setq num (sumfatt num))
      )
      ;(if (= (length chain) 60) (++ out))
      (if (= (length (chain)) 60) (++ out))
      ; l'eliminaziona di una hash-map è lenta
      (delete 'chain)
      ; per vedere come sono distribuite le catene da 1 a 1000000
      ;(if (zero? (% i 50000)) (println i { } out))
    )
    out))

(e074)
;-> 402

(time (e074))
;-> 76084.168

Credo che il peggioramento del tempo di esecuzione sia dovuto all'operazione di eliminazione della hash-map "delete" che è lenta. Proviamo allora ad utilizzare ogni volta una hash-map diversa utilizzando la funzione "gensym":

(define (gensym)
  (sym (string "g-" (uuid)))) ; 'g-*** è un simbolo legale

(define (e074)
  ;(local (limite num chain out)
  (local (limite num out)
    (setq out 0 limite 1000000)
    (for (i 1 limite)
      (setq num i)
      ;(setq chain '())
      ;(new Tree 'chain)
      (setq chain (new Tree (gensym) true))
      ;(until (find num chain)
      (until (chain num)
        ;(push num chain -1)
        (chain num num)
        (setq num (sumfatt num))
      )
      ;(if (= (length chain) 60) (++ out))
      (if (= (length (chain)) 60) (++ out))
      ;(delete 'chain)
      ; per vedere come sono distribuite le catene da 1 a 1000000
      ;(if (zero? (% i 50000)) (println i { } out))
    )
    out))

(e074)
;-> 402

(time (print (e074)))
;-> 51001.943

Il tempo di esecuzione è migliore della precedente funzione, ma utilizzare una lista è più veloce in questo caso.

Proviamo con un altro algoritmo.
Consideriamo i numeri di una catena: hanno tutti la stessa lunghezza della catena a cui appartengono.
Se nella costruzione della catena di un numero raggiungiamo il numero 169 o 871 o 872 sappiamo come termina la catena stessa.
Utilizzando anche gli altri numeri 363601, 1454, 45361 e 45362 possiamo modificare il criterio di arresto del calcolo diretto della catena: ci fermiamo quando incontriamo uno di questi sette numeri oppure quando un numero termina la catena su se stesso.

Scriviamo la funzione finale:

(define (e074)
  (local (limite num ultimo somma out)
    (setq stop '(169 871 872 1454 45361 45362 363601))
    (setq out 0 limite 1000000)
    (for (i 1 1000000)
      (setq num i)
      (setq somma 0 ultimo 0)
      (while (and (!= num ultimo) (not (find num stop)))
        (setq ultimo num)
        (setq num (sumfatt num))
        (++ somma)
      )
      (if (and (= somma 57) (or (= num 169) (= num 1454) (= num 363601)))
          (++ out))
    )
    out))


(e074)
;-> 402

(time (e074))
;-> 28605.673

Questa è la più veloce anche se il tempo non è entusiasmante.


Dopo un pò di analisi si può trovare che gli unici numeri che generano una catena di 60 elementi sono i seguenti:

  367945 367954 373944 379443 379465 735964

Utilizzando questa informazione possiamo scrivere una nuova soluzione:

(define (sum-fatt num)
  (let ((temp num) (out 0))
    (while (> temp 0)
      (setq out (+ out (fact (% temp 10))))
      (setq temp (/ temp 10))
    )
    out))

(define (e074-2)
  (local (iter sign fact out)
    ; signature sum-fatt che portano a una catena di 60 termini (fino a 1e8)
    (setq sign '(367945 367954 373944 379443 379465 735964))
    ; precodifica dei fattoriali da 0 a 9
    (setq fact '(1 1 2 6 24 120 720 5040 40320 362880))
    (setq out 0)
    (for (i 69 1e6)
      (if (find (sum-fatt i) sign) (++ out))
    )
    out))

(find 367954 '(367945 367954 373944 379443 379465 735964))
(e074-2)
;-> 402

(time (e074-2))
;-> 1124.954
----------------------------------------------------------------------------


===========
Problema 75
===========

Risulta che 12 cm è la più piccola lunghezza di filo che può essere piegata per formare un triangolo ad angolo retto con un lato intero esattamente in un modo, ma ci sono molti altri esempi.

12 cm: (3,4,5)
24 cm: (6,8,10)
30 cm: (5,12,13)
36 cm: (9,12,15)
40 cm: (8,15,17)
48 cm: (12,16,20)

Al contrario, alcune lunghezze di filo, come 20 cm, non possono essere piegate per formare un triangolo ad angolo retto con un lato intero, e altre lunghezze consentono di trovare più di una soluzione. Ad esempio, utilizzando 120 cm è possibile formare esattamente tre triangoli ad angolo retto con lati interi diversi.

120 cm: (30,40,50), (20,48,52), (24,45,51)

Dato che L è la lunghezza del filo, per quanti valori di L ≤ 1.500.000 si può formare esattamente un triangolo ad angolo retto con un lato intero?
============================================================================

L'idea centrale è quella di iterare sulle lunghezze dei cateti: se le lunghezze dei lati non sono numeri coprimi, allora abbiamo già contato quella tripla pitagorica. Potete trovare maggiori spiegazioni nell'articolo "Tree of primitive Pythagorean triples" su wikipedia.

(define (e075)
  (local (limite ar perimetro)
    (setq limite 1500000)
    (setq ar (array limite '(0)))
    (for (i 1 (- (sqrt limite) 1) 2)
      (for (j 2 (- (sqrt limite) i 1) 2)
        (if (= (gcd i j) 1)
            (begin
            (setq perimetro (+ (abs (- (* j j) (* i i))) (* 2 i j) (* i i) (* j j)))
            (setq x perimetro)
            (while (< x limite)
              (++ (ar x))
              (setq x (+ x perimetro))
            ))
        )
      )
    )
    (first (count '(1) (array-list ar)))))

(e075)
;-> 161667

(time (e075))
;-> 822.828
----------------------------------------------------------------------------


===========
Problema 76
===========

Conteggio delle somme

È possibile scrivere cinque come somma in esattamente sei modi diversi:

4 + 1
3 + 2
3 + 1 + 1
2 + 2 + 1
2 + 1 + 1 + 1
1 + 1 + 1 + 1 + 1

In quanti modi diversi si può scrivere cento come somma di almeno due numeri interi positivi?
============================================================================

La soluzione è simile a quella del problema 31. Le uniche differenze sono:
1) il totale vale 100 (invece di 200)
2) le monete (gli interi in questo caso) vanno da 1 a 99 (invece che (1 2 5 10 20 50 100 200))

(define (e076)
  (local (totale monete modi)
    ; valore obiettivo
    (setq totale 100)
    ; lista dei tagli di monete disponibili
    (setq monete (sequence 1 99))
    ; crea un vettore di totale elementi con tutti valori 0 tranne il primo (modi[0]) che vale 1
    (setq modi (array (+ totale 1) (extend '(1) (dup 0 totale))))
    (dolist (el monete)
      (for (i el totale)
        (setq (modi i) (+ (modi i) (modi (- i el))))
      )
    )
    (modi totale)))

(e076)
;-> 190569291

(time (e076))
;-> 0
----------------------------------------------------------------------------


===========
Problema 77
===========

Somme di primi

È possibile scrivere dieci come somma dei numeri primi esattamente in cinque modi diversi:

7 + 3
5 + 5
5 + 3 + 2
3 + 3 + 2 + 2
2 + 2 + 2 + 2 + 2

Qual è il primo valore che può essere scritto come somma di numeri primi in oltre cinquemila modi diversi?
============================================================================

L'algoritmo di soluzione è simile a quella del problema precedente. Al posto del totale=100 iniziamo da 2 fino a che non troviamo tutte le soluzioni. Inoltre, invece di utilizzare i numeri da 1 a 99, usiamo i numeri primi (preventivamente calcolati).

(define (e077)
  (local (primi limite iter modi i continua)
    (setq primi '(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79))
    (setq limite 5000)
    (setq iter 2)
    (setq continua true)
    (while continua
      ;(println iter)
      (setq modi (array (+ iter 1) (extend '(1) (dup 0 iter))))
      ;(println modi)
      ;(read-line)
      (dolist (p primi)
        (setq i p)
        (while (<= i iter)
          (setf (modi i) (+ (modi i) (modi (- i p))))
          (++ i)
        )
      )
      (if (> (modi iter) 5000)
          (setq continua nil)
          (++ iter)
      )
    )
    iter))

(e077)
;-> 71

(time (e077))
;-> 4.015
----------------------------------------------------------------------------


===========
Problema 78
===========

Partizioni di monete

Sia p(n) il numero dei diversi modi in cui n monete possono essere separate in pile. Ad esempio, cinque monete possono essere separate in pile in esattamente sette modi diversi, quindi p(5) = 7.

OOOOO
OOOO   O
OOO   OO
OOO   O   O
OO   OO   O
OO   O   O   O
O   O   O   O   O

Trova il valore minimo di n per cui p(n) è divisibile per un milione.
============================================================================

Su wikipedia si trova che la funzione generatrice per p(n) vale:

p(n) = p(n - 1) + p(k - 2) - p(k - 5) - p(k - 7) + p(k - 12) + p(k - 15) - p(k - 22) ...

dove p(0) = 1 e p(n) = 0 per n < 0.

La sequenza dei numeri k da utilizzare è data dalla formula dei numeri pentagonali generalizzati:

f(k) = k*(3k-1)/2 che vale sia per k negativo che per k positivo.

Questa formula può essere generata nel modo seguente:

    | (m/2 + 1)    se (k mod 2) = 0,
k = |
    | (-m/2 - 1)   altrimenti

I segni della funzione seguono lo schema +, +, -, -, +, +, -, -,...

Quindi partendo dal primo valore della sequenza possiamo calcolare quella successiva e cosi via.

(define (penta k) (/ (* k (- (* 3 k) 1)) 2))

(define (e078)
  (local (n p-vec segno penta continua i j val)
    (setq p-vec (array 100000 '(0)))
    (setq n 1)
    (setf (p-vec 0) 1)
    (setq continua true)
    (while continua
      (setq i 0)
      (setq penta 1)
      (while (<= penta n)
        (if (> (% i 4) 1)
            (setq segno -1)
            (setq segno 1))
        (setf (p-vec n) (+ (p-vec n) (* segno (p-vec (- n penta)))))
        (setf (p-vec n) (% (p-vec n) 1000000))
        (++ i)
        (if (zero? (% i 2))
            (setq j (+ (/ i 2) 1))
            (setq j (- (+ (/ i 2) 1))))
        (setq penta (/ (* j (- (* 3 j) 1)) 2))
      )
      (if (zero? (p-vec n))
          (setq continua nil)
          (++ n))
      ;(if (zero? (% n 10000)) (println n))
    )
    n))

(e078)
;-> 55374

(time (e078))
;-> 7918.736

Il tempo di esecuzione non è entusiasmante, ma non è che abbia capito molto bene come funziona tutta la matematica dietro il partizionamento degli interi. Mi accontento che il risultato sia corretto.
----------------------------------------------------------------------------


===========
Problema 79
===========

Derivazione del passcode

Un metodo di sicurezza comune utilizzato per l'online banking consiste nel chiedere all'utente tre caratteri casuali da un passcode. Ad esempio, se il codice di accesso era 531278, potrebbero richiedere il 2°, il 3° e il 5° carattere:  la risposta attesa sarebbe 317.

Il file di testo, keylog.txt, contiene cinquanta tentativi di accesso riusciti.

Dato che i tre caratteri vengono sempre richiesti in ordine, analizzare il file in modo da determinare il codice segreto più breve possibile di lunghezza sconosciuta.
============================================================================

Il file "keylog.txt" è stato trasformato nella lista seguente:

(setq pwd '("319" "680" "180" "690" "129" "620" "762" "689" "318" "368" "710"
            "720" "629" "168" "160" "716" "731" "736" "729" "316" "769" "290"
            "719" "389" "162" "289" "718" "790" "890" "362" "760" "380" "728"))

(length pwd)
;-> 50

Eliminiamo i valori doppi:

(setq pwd (unique pwd))
;-> ("319" "680" "180" "690" "129" "620" "762" "689" "318" "368" "710"
;->  "720" "629" "168" "160" "716" "731" "736" "729" "316" "769" "290"
;->  "719" "389" "162" "289" "718" "790" "890" "362" "760" "380" "728")

(length pwd)
;-> 33

Definiamo tre liste che conterranno le prime, le seconde e le terze cifre di ogni numero di login (ripetute solo una volta):

(setq prima '())
(setq seconda '())
(setq terza '())
(dolist (login pwd)
  (push (login 0) prima -1)
  (push (login 1) seconda -1)
  (push (login 2) terza -1)
)
(setq prima (unique prima))
;-> ("3" "6" "1" "7" "2" "8")
(setq seconda (unique seconda))
;-> ("1" "8" "9" "2" "6" "3")
(setq terza (unique terza))
;-> ("9" "0" "2" "8" "6" "1")

Uniamo tutte le cifre:

(setq uniche prima)
(setq uniche (unique (extend uniche seconda terza)))
;-> ("3" "6" "1" "7" "2" "8" "9" "0")
(length uniche)
;-> 8

Quindi possiamo trarre le seguenti conclusioni:

1) la password minima è lunga quanto la lista "uniche": 8
2) nella password non ci sono le cifre "4" e "5"
3) La prima cifra della della password è "7", perchè è l'unica cifra che compare solo nella lista "prima".
4) L'ultima cifra della password è "0", perchè è l'unica cifra che compare solo nella lista "terza".

Per adesso, la password vale "7xxxxxx0", dove xxxxxx sono occupate, in qualche ordine, da "1" "2" "3" "6" "8" "9".

Dalla lista "pwd" possiamo calcolare, per ogni cifra, tutte le cifre che appaiono prima e tutte le cifre che appaiono dopo:

(define (cifre-dove x lst)
  (setq prima-di-x '())
  (setq dopo-di-x '())
  (dolist (login pwd)
    (setq pos-x (find x login))
    (cond ((= 0 pos-x)
           (push (login 1) dopo-di-x -1)
           (push (login 2) dopo-di-x -1))
          ((= 1 pos-x)
           (push (login 0) prima-di-x -1)
           (push (login 2) dopo-di-x -1))
          ((= 2 pos-x)
           (push (login 0) prima-di-x -1)
           (push (login 1) prima-di-x -1))
    )
  )
  (setq prima-di-x (unique prima-di-x))
  (setq dopo-di-x (unique dopo-di-x))
  (println "Prima di " x " : " prima-di-x)
  (println "Dopo di " x " : " dopo-di-x))

(cifre-dove "0")
;-> Prima di 0 : ("6" "8" "1" "9" "2" "7" "3")
;-> Dopo di 0 : ()
(cifre-dove "1")
;-> Prima di 1 : ("3" "7")
;-> Dopo di 1 : ("9" "8" "0" "2" "6")
(cifre-dove "2")
;-> Prima di 2 : ("1" "6" "7" "3")
;-> Dopo di 2 : ("9" "0" "8")
(cifre-dove "3")
;-> Prima di 3 : ("7")
;-> Dopo di 3 : ("1" "9" "8" "6" "2" "0")
(cifre-dove "6")
;-> Prima di 6 : ("7" "3" "1")
;-> Dopo di 6 : ("8" "0" "9" "2")
(cifre-dove "7")
;-> Prima di 7 : ()
;-> Dopo di 7 : ("6" "2" "1" "0" "3" "9" "8")
(cifre-dove "8")
;-> Prima di 8 : ("6" "1" "3" "2" "7")
;-> Dopo di 8 : ("0" "9")
(cifre-dove "9")
;-> Prima di 9 : ("3" "1" "6" "2" "8" "7")
;-> Dopo di 9 : ("0")

Da una semplice analisi troviamo che:
prima di 3 c'è solo 7                           ==> 73xxxxx0
prima di 1 ci sono solo 3 e 7                   ==> 731xxxx0
prima di 6 ci sono solo 3 e 7 e 1               ==> 7316xxx0
prima di 2 ci sono solo 3 e 7 e 1 e 6           ==> 73162xx0
prima di 8 ci sono solo 3 e 7 e 1 e 6 e 2       ==> 731628x0
prima di 9 ci sono solo 3 e 7 e 1 e 6 e 2 e 8   ==> 73162890

Quindi la soluzione vale: 73162890

L'ultima funzione è sufficiente per definire una procedura che calcola la soluzione.

Nel 2009 avevo scritto la seguente soluzione in python:

log = [319,680,180,690,129,620,762,689,762,318,368,710,720,710,629,168,160,689,716,
731,736,729,316,729,729,710,769,290,719,680,318,389,162,289,162,718,729,319,790,680,
890,362,319,760,316,729,380,319,728,716]

def eulero079(L):
   a = []
   for i in range(0,len(L)):
       iL = int2list(L[i])
       a.append((iL[0],iL[1]))
       a.append((iL[1],iL[2]))
   a.sort()
   # calcolo, per ogni numero, la lista dei numeri che stanno prima
   pri = []
   for x in [0,1,2,3,6,7,8,9]:
       base = []
       for i in range(0,len(a)):
           if a[i][1] == x:
               base.append(a[i][0])
       newbase = list(set(base))
       newbase.sort()
       pri.append((x,newbase))
   # aggiorno le liste con i numeri che stanno davanti
   for k in range(0,10):
       primaD = {}
       for i in range(0,len(pri)):
           primaD[pri[i][0]] = pri[i][1]
       pri = []
       for i in primaD.keys():
           tp = []
           for val in primaD[i]:
               tp = tp + primaD[val]
           tpp = list(set(tp+primaD[i]))
           tpp.sort
           pri.append((i,tpp))
   ma = [(len(pri[i][1]),pri[i][0]) for i in range(0,len(pri))]
   ma.sort()
   # "ma" è una lista ordinata per posizione che contiene tuple del tipo:
   # (posizione,cifra)
   # Costruzione della soluzione
   pwd = ''
   for i in range(len(ma)):
       pwd = pwd + str(ma[i][1])
   return(pwd)

eulero079(log)
;-> 73162890
----------------------------------------------------------------------------


===========
Problema 80
===========

Espansione digitale della radice quadrata

È noto che se la radice quadrata di un numero naturale non è un intero, allora è irrazionale. L'espansione decimale di tali radici quadrate è infinita senza alcun motivo ripetitivo.

La radice quadrata di due è 1,41421356237309504880 ... e la somma digitale delle prime cento cifre decimali è 475.

Per i primi cento numeri naturali, trova il totale delle somme digitali delle prime cento cifre decimali per tutte le radici quadrate irrazionali.
============================================================================

(sqrt 2)
;-> 1.414213562373095

Funzione per calcolare una potenza intera (big-integer):

(define (** num power)
    (let (out 1L)
        (dotimes (i power)
            (setq out (* out num)))))

Funzione per calcolare la somma delle cifre di un numero:

(define (digit-sum num)
  (let (out 0)
    (while (!= num 0)
      (setq out (+ out (% num 10)))
      (setq num (/ num 10))
    )
    out))

Per calcolare la radice quadrata di un numero (specificando il numero di cifre dopo la virgola) utilizziamo l'algoritmo riportato nell'articolo "Square roots by subtraction" di Frazer Jarvis.

(setq limite (** 10 (+ 14 1)))
(define (sqrt-prec num cifre)
  (local (a b limite)
    (setq limite (** 10 (+ cifre 1)))
    (setq a (* 5L num))
    (setq b 5L)
    (while (< b limite)
      (cond ((>= a b)
             (setq a (- a b))
             (setq b (+ b 10))
            )
            (true
             (setq a (* a 100))
             (setq b (+ (* (/ b 10) 100) 5))
            )
      )
    )
    (/ b 100)))

(digit-sum (sqrt-prec 2 100))
;-> 475

(define (e080)
  (let ((q 1) (out 0))
    (for (i 1 100)
      (cond ((= (* q q) i)
             (++ q)
            )
            (true
              (setq out (+ out (digit-sum (sqrt-prec i 100))))
            )
      )
    )
    out))

(e080)
;-> 40886

(time (e080))
;-> 29.95
----------------------------------------------------------------------------


===========
Problema 81
===========

Somma del percorso: due modi

Nella matrice 5 per 5 di seguito, la somma minima del percorso da in alto a sinistra a in basso a destra, spostandosi solo a destra e in basso, è sottolineata ed è uguale a 2427.

    131 673 234 103  18
    ---
    201  96 342 965 150
    --- --- ---
    630 803 746 422 111
            ---
    537 699 497 121 956
                ---
    805 732 524  37 331
                ---

Trova la somma minima del percorso da in alto a sinistra a in basso a destra spostandoti a destra e in basso in "matrix.txt", un file di testo 31K contenente una matrice 80 per 80.
============================================================================

Il file "matrix.txt" è stato trasformato nel file "e081.lsp", una lista di nome "matrix" che rappresenta la matrice.

La somma del percorso minimo dall'angolo in alto a sinistra a una data cella è il valore della cella più il minimo della somma del percorso per la cella sopra di essa e la somma del percorso per la cella a sinistra di essa. Questo ci permette di risolvere il problema con la tecnica della programmazione dinamica.

(load "e081.lsp")

(matrix 0 0)
;-> 4445
(matrix 79 79)
;-> 7981

numero righe:
(length matrix)
;-> 80
numero colonne:
(length (matrix 0))
;-> 80

(define (e081)
  (load "e081.lsp")
  (let (len (- (length matrix) 1))
    ; calcolo dp della prima riga della matrice
    (for (i 1 len)
      (setf (matrix 0 i) (+ (matrix 0 i) (matrix 0 (- i 1))))
    )
    ; calcolo dp della prima colonna della matrice
    (for (i 1 len)
      (setf (matrix i 0) (+ (matrix i 0) (matrix (- i 1) 0)))
    )
    ; calcolo dp del resto della matrice
    (for (i 1 len)
      (for (j 1 len)
        (setf (matrix i j) (+ (matrix i j) (min (matrix (- i 1) j) (matrix i (- j 1)))))
      )
    )
    (matrix len len)))

(e081)
;-> 427337

(time (e081))
;-> 3
----------------------------------------------------------------------------


===========
Problema 82
===========

Somma del percorso: tre modi

La somma del percorso minimo nella matrice 5 per 5 di seguito, iniziando in qualsiasi cella nella colonna di sinistra e finendo in qualsiasi cella nella colonna di destra, e spostandosi solo su, giù e destra, è sottolineata: la somma è pari a 994.

    131 673 234 103  18
            --- --- ---
    201  96 342 965 150
    --- --- ---
    630 803 746 422 111

    537 699 497 121 956

    805 732 524  37 331

Trova la somma minima del percorso dalla colonna di sinistra alla colonna di destra in "matrix.txt", un file di testo 31K contenente una matrice 80 per 80.
============================================================================

Il file "matrix.txt" è stato trasformato nel file "e082.lsp", una lista di nome "matrix" che rappresenta la matrice.

(load "e082.lsp")

(matrix 0 0)
;-> 4445
(matrix 79 79)
;-> 7981

L'algoritmo è simile a quello del problema 81, ma abbiamo bisogno di un vettore ausiliario per tenere traccia delle soluzioni parziali.

(define (e082)
(load "e082.lsp")
  (letn ((len (- (length matrix) 1)) (sp (array (+ len 1) '(0))))
    ; Soluzione iniziale
    (for (i 0 len)
      (setf (sp i) (matrix i len))
    )
    ; calcolo dp della prima colonna della matrice
    (for (i (- len 1) 0)
      ; analizza in basso
      (setf (sp 0) (+ (sp 0) (matrix  0 i)))
      ; calcolo soluzione minima parziale
      (for (j 1 len)
        (setf (sp j) (min (+ (sp (- j 1)) (matrix j i)) (+ (sp j) (matrix j i))))
      )
      ; analizza in alto
      (for (j (- len 1) 0)
        (setf (sp j) (min (sp j) (+ (sp (+ j 1)) (matrix j i))))
      )
    )
    ; soluzione minima assoluta
    (apply min sp)))

(e082)
;-> 260324

(time (e082))
;-> 4
----------------------------------------------------------------------------


===========
Problema 83
===========

Somma del percorso: quattro modi

NOTA: questo problema è una versione notevolmente più impegnativa del problema 81.

Nella matrice 5 per 5 di seguito, la somma del percorso minimo dall'alto a sinistra verso il basso a destra, spostandosi a sinistra, a destra, in alto e in basso, è sottolineata ed è uguale a 2297.

    131 673 234 103  18
    ---     --- --- ---
    201  96 342 965 150
    --- --- ---     ---
    630 803 746 422 111
                --- ---
    537 699 497 121 956
                ---
    805 732 524  37 331
                --- ---

Trova la somma minima del percorso da in alto a sinistra a in basso a destra spostandoti a sinistra, destra, su e giù in "matrix.txt", un file di testo di 31K contenente 80 da 80 matrice.
============================================================================

Il file "matrix.txt" è stato trasformato nel file "e082.lsp", una lista di nome "matrix" che rappresenta la matrice.

(load "e083.lsp")
(matrix 0 0)
;-> 4445
(matrix 79 79)
;-> 7981

Algoritmo di soluzione preso da un articolo del sito https://www.programmersought.com/

Considerando la matrice come un grafo diretto in cui ogni numero rappresenta il peso di ogni arco possiamo utilizzare l'algoritmo di Dijkstra. Questo algoritmo trova la distanza più breve da un vertice ad altri vertici in un grafo diretto o non orientato (i pesi del grafo devono avere tutti un valore maggiore di 0). Sul sito https://www.programmersought.com/ ho trovato

Per risolvere il problema utilizziamo un vettore dist[][2], dist[a][0] rappresenta la lunghezza del percorso più breve da 0 ad "a" che abbiamo trovato (non necessariamente la più breve), dist[a][1] = 1 significa che questo è il più breve, dist[a][1] = 0 significa che non siamo ancora sicuri che questa sia la lunghezza più breve.

Inizializziamo i valori, dist[0][0] = 0, dist[0][1] = 1, dist[i][0](i ≠ 0) = infinito, a[i][1] = 0.

Quindi esaminando i diversi punti adiacenti ad a0, come a1 e a3, possiamo lasciare dist[1][0] = dist[0][0] + P (il peso da a0 a a1) e fare la stessa cosa per dist[3][0].

A questo punto, troviamo il valore minimo di dist[][1] = 0 in dist[][0], ad esempio, dist[3][1], quindi possiamo confermare che questo deve essere il percorso più breve da a0 a a3. Perché se c'è un percorso più breve, deve iniziare da a0 e a3 è il valore minimo in dist, il che costituisce una contraddizione. Quindi il percorso più breve da a0 ad a3 è confermato.

Adesso esaminiamo i vertici adiacenti ad a3 e ripetiamo l'operazione sopra. Dopo un numero limitato di operazioni, è possibile ottenere la lunghezza del percorso più breve da a0 a tutti i vertici e, se il percorso non viene trovato, dist[i][0] ha valore infinito.

(define (e083)
  ;(load "e083.lsp")
  (local (dist iter idxm)
    ; vettore delle distanze
    (setq dist (array 6400 2 '(10000000 0)))
    (setq iter 0)
    (setq idxm 0)
    ; inizializzazione vettore delle distanze
    (setf (dist 0 0) 0)
    (setf (dist 0 1) 1)
    (setf (dist 1 0) (matrix 0 1))
    (setf (dist 80 0) (matrix 1 0))
    ; 80x80 = 6400
    (while (< iter 6400)
      (setq idxm (foundmin dist))
      ;(println idxm)
      ;(read-line)
      ; flag: percorso minimo
      (setf (dist idxm 1) 1)
      ; aggiorna le distanze con i punti adiacenti
      (if (!= (% idxm 80) 0)
          (setf (dist (- idxm 1) 0) (min (dist (- idxm 1) 0) (+ (dist idxm 0) (matrix (/ idxm 80) (- (% idxm 80) 1))))))
      (if (!= (% idxm 80) 79)
          (setf (dist (+ idxm 1) 0) (min (dist (+ idxm 1) 0) (+ (dist idxm 0) (matrix (/ idxm 80) (+ (% idxm 80) 1))))))
      (if (!= (/ idxm 80) 0)
          (setf (dist (- idxm 80) 0) (min (dist (- idxm 80) 0) (+ (dist idxm 0) (matrix (- (/ idxm 80) 1) (% idxm 80))))))
      (if (!= (/ idxm 80) 79)
          (setf (dist (+ idxm 80) 0) (min (dist (+ idxm 80) 0) (+ (dist idxm 0) (matrix (+ (/ idxm 80) 1) (% idxm 80))))))
      ;(println (dist (- idxm 1) 0) { } (dist (+ idxm 1) 0) { } (dist (- idxm 80) 0) { } (dist (+ idxm 80) 0))
      ;(read-line)
      (++ iter)
    )
    (+ (dist 6399 0) (matrix 0 0))))

(e083)
;-> 425185

(time (e083))
;-> 6503.784
----------------------------------------------------------------------------


===========
Problema 84
===========

In the game, Monopoly, the standard board is set up in the following way:

   GO  A1  CC1 A2  T1  R1  B1  CH1 B2  B3  JAIL
   H2                                      C1
   T2                                      U1
   H1                                      C2
   CH3                                     C3
   R4                                      R2
   G3                                      D1
   CC3                                     CC2
   G2                                      D2
   G1                                      D3
   G2J F3  U2  F2  F1  R3  E3  E2  CH2 E1  FP

A player starts on the GO square and adds the scores on two 6-sided dice to determine the number of squares they advance in a clockwise direction. Without any further rules we would expect to visit each square with equal probability: 2.5%. However, landing on G2J (Go To Jail), CC (community chest), and CH (chance) changes this distribution.

In addition to G2J, and one card from each of CC and CH, that orders the player to go directly to jail, if a player rolls three consecutive doubles, they do not advance the result of their 3rd roll. Instead they proceed directly to jail.

At the beginning of the game, the CC and CH cards are shuffled. When a player lands on CC or CH they take a card from the top of the respective pile and, after following the instructions, it is returned to the bottom of the pile. There are sixteen cards in each pile, but for the purpose of this problem we are only concerned with cards that order a movement. Any instruction not concerned with movement will be ignored and the player will remain on the CC/CH square.

Community Chest (2/16 cards):
  1. Advance to GO
  2. Go to JAIL
Chance (10/16 cards):
  1. Advance to GO
  2. Go to JAIL
  3. Go to C1
  4. Go to E3
  5. Go to H2
  6. Go to R1
  7. Go to next R (railway company)
  8. Go to next R
  9. Go to next U (utility company)
 10. Go back 3 squares.

The heart of this problem concerns the likelihood of visiting a particular square. That is, the probability of finishing at that square after a roll. For this reason it should be clear that, with the exception of G2J for which the probability of finishing on it is zero, the CH squares will have the lowest probabilities, as 5/8 request a movement to another square, and it is the final square that the player finishes at on each roll that we are interested in. We shall make no distinction between "Just Visiting" and being sent to JAIL, and we shall also ignore the rule about requiring a double to "get out of jail", assuming that they pay to get out on their next turn.

By starting at GO and numbering the squares sequentially from 00 to 39 we can concatenate these two-digit numbers to produce strings that correspond with sets of squares.

Statistically it can be shown that the three most popular squares, in order, are JAIL (6.24%) = Square 10, E3 (3.18%) = Square 24, and GO (3.09%) = Square 00. So these three most popular squares can be listed with the six-digit modal string: 102400.

If, instead of using two 6-sided dice, two 4-sided dice are used, find the six-digit modal string.
============================================================================

La soluzione consiste nel simulare il gioco seguendo tutte le regole, lanciare i dadi per tante volte e contare quante volte si passa per ogni casella.

(define (e084)
(local (freq max-lanci num-lanci pos num d1 d2 d3 d4 perc)
  (setq freq (array 40 '(0)))
  (setq max-lanci 100000 num-lanci 0 pos 0 num 0)
  (while (< num-lanci max-lanci)
    (setq d1 (+ (rand 4) 1))
    (setq d2 (+ (rand 4) 1))
    (setq pos (+ pos d1 d2))
    (if (> pos 39 (setq pos (- pos 40))))
    (if (= d1 d2) (++ num) (setq num 0))
    (if (or (= pos 2) (= pos 17) (= pos 33))
        (begin (setq d3 (+ (rand 16) 1))
              (if (= d3 1) (setq pos 0))
              (if (= d3 2) (setq pos 10))))
    (if (or (= pos 7) (= pos 22) (= pos 33))
        (begin (setq d4 (+ (rand 15) 1))
              (if (= d4 1) (setq pos 0))
              (if (= d4 2) (setq pos 10))
              (if (= d4 3) (setq pos 11))
              (if (= d4 4) (setq pos 24))
              (if (= d4 5) (setq pos 39))
              (if (= d4 6) (setq pos 5))
              (if (or (= d4 7) (= d4 8))
                  (begin (if (= pos 7) (setq pos 12))
                          (if (= pos 22) (setq pos 25))
                          (if (= pos 36) (setq pos 5))))
              (if (= d4 9)
                  (begin (if (= pos 7) (setq pos 12))
                          (if (= pos 22) (setq pos 28))
                          (if (= pos 36) (setq pos 12))))
              (if (= d4 10) (setq pos (- pos 3)))))
    (if (or (= pos 30) (= num 3)) (setq pos 10))
    (++ (freq pos))
    (++ num-lanci)
    (if (= num 3) (setq num 0))
  )
  (setq perc '())
  (for (i 0 39)
    (push (list (mul (div (freq i) max-lanci) 100) i) perc)
  )
  (sort perc >)
  (int (string (perc 0 1) (perc 1 1) (perc 2 1)))))

(e084)
;-> 101524

(time (e084))
;-> 66.849
----------------------------------------------------------------------------


===========
Problema 85
===========

Contare i rettangoli

Contando attentamente si può vedere che una griglia rettangolare di 3 x 2 contiene diciotto rettangoli:

                        1 da 3x2               2 da 2x2         3 da 1x2
 ╔════╦════╦════╗       ╔══════════════╗       ╔════════╗       ╔════╗
 ║    ║    ║    ║       ║              ║       ║        ║       ║    ║
 ╠════╬════╬════╣  ==>  ║      1       ║   +   ║   2    ║   +   ║ 3  ║   +
 ║    ║    ║    ║       ║              ║       ║        ║       ║    ║
 ╚════╩════╩════╝       ╚══════════════╝       ╚════════╝       ╚════╝

                        2 da 3x1               4 da 2x2         6 da 1x1
                        ╔══════════════╗       ╔════════╗       ╔════╗
                     +  ║      2       ║   +   ║   4    ║   +   ║ 6  ║   =  18
                        ╚══════════════╝       ╚════════╝       ╚════╝

Sebbene non esista una griglia rettangolare che contenga esattamente due milioni di rettangoli, trova l'area della griglia con la soluzione più vicina.
============================================================================

Una griglia N * M può essere rappresentata come (N + 1) linee orizzontali e (M + 1) linee verticali.
In un rettangolo, abbiamo bisogno di due distinte linee orizzontali e due distinte linee verticali.
Quindi possiamo scegliere 2 linee verticali e 2 linee orizzontali per formare un rettangolo. Ci sono (N+1) scelte per la larghezza e (M+1) scelte per l'altezza, quindi il numero totale di rettangoli possibili nella griglia vale:

 binom(N+1,2) * binom(M+1,2) = (N*(N+1)*M*(M+1))/4

(define (e085)
  (local (diff area numrett adiff erow ecol)
    (setq diff 2000000 area -1 erow -1 ecol -1)
    (for (r 1 100)
      (for (c 1 100)
        (setq numrett (/ (* r (+ r 1) c (+ c 1)) 4))
        (setq adiff (abs (- numrett 2000000)))
        (if (< adiff diff)
             (setq area (* r c) diff adiff erow r ecol c))))
    area))

(e085)
;-> 2772

(time (e085))
;-> 2
----------------------------------------------------------------------------


===========
Problema 86
===========

Un ragno, S, si trova in un angolo di una stanza cuboide (parallelepipedo) che misura 6 per 5 per 3, e una mosca, F, si trova nell'angolo opposto. Percorrendo le superfici della stanza la distanza "retta" più breve da S a F è 10 e il percorso è mostrato nel diagramma "e086p.png".

Tuttavia, ci sono fino a tre candidati di percorso "più breve" per ogni dato cuboide e il percorso più breve non ha sempre una lunghezza intera.

Si può dimostrare che ci sono esattamente 2060 cuboidi distinti, ignorando le rotazioni, con dimensioni intere, fino a una dimensione massima di M per M per M, per cui la rotta più breve ha lunghezza intera quando M = 100. Questo è il valore minimo di M per cui il numero di soluzioni supera il valore duemila. Il numero di soluzioni quando M = 99 è 1975.

Trova il valore minimo di M tale che il numero di soluzioni superi prima un milione.
============================================================================

Vedi la figura "e086s.png" per capire quale sia il percorso minimo in un cubo aperto.

Presumendo che a <= b <= c esistono tre percorsi più brevi:

percorso1 = (a + b)^2 + c^2
percorso2 = (a + c)^2 + b^2
percorso3 = (c + b)^2 + a^2

Espandendo le espressioni si trova che il percorso1 ha il valore minimo. Calcoliamo tutti questi percorsi e contiamo quelli che hanno valore intero.

(define (e086)
(catch
  (local (limite conta m a b c percorso sqr)
    (setq limite 1000000 conta 0 m 1)
    (for (m 1 10000)
      (for (a 1 m)
        (for (b a m)
          (setq c m)
          (setq percorso (+ (* (+ a b) (+ a b)) (* c c)))
          (setq sqr (sqrt percorso))
          (if (= (* sqr sqr) percorso) (++ conta))
        )
      )
      (if (> conta limite) (throw m))
    )
    m)))

(e086)
;-> 1818

(time (println (e086)))
;-> 233564.084

Calcolando tutti i percorsi occorre molto tempo per calcolare la soluzione.

Un altro metodo è quello di pensare (a + b) come un unico valore "ab", che varia da 2 a 2*M. In questo modo si fissa il valore "c" al suo valore massimo. Adesso dobbiamo trovare il numero di cubi, corrispondenti al valore "c", che soddisfano la condizione.

(define (e086)
  (local (limit conta ab c sqr)
    (setq limit 1000000 conta 0 c 1)
    (while (< conta limit)
      (++ c)
      (for (ab 2 (* 2 c))
        (setq path (+ (* ab ab) (* c c)))
        (setq sqr (sqrt path))
        (if (= (* sqr sqr) path)
            (if (>= ab c)
                (setq conta (+ conta 1 (- c (/ (+ ab 1) 2))))
                (setq conta (+ conta (/ ab 2)))))))
    c))

(e086)
;-> 1818

(time (e086))
;-> 528.583
----------------------------------------------------------------------------


===========
Problema 87
===========

Triple potenze di primi

Il numero più piccolo esprimibile come la somma di un quadrato primo, un cubo primo e una quarta potenza primo è 28. In effetti, ci sono esattamente quattro numeri inferiori a cinquanta che possono essere espressi in questo modo:

28 = 2^2 + 2^3 + 2^4
33 = 3^2 + 2^3 + 2^4
49 = 5^2 + 2^3 + 2^4
47 = 2^2 + 3^3 + 2^4

Quanti numeri inferiori a cinquanta milioni possono essere espressi come la somma di un quadrato primo, un cubo primo e una quarta potenza primo?
============================================================================

Funzione per calcolare i numeri primi fino a n:

(define (primes-to num)
  (cond ((= num 1) '())
        ((= num 2) '(2))
        (true
         (let (lst '(2))
          (setq arr (array (+ num 1)))
          (for (x 3 num 2)
                (when (not (arr x))
                  (push x lst -1)
                  (for (y (* x x) num (* 2 x) (> y num))
                      (setf (arr y) true)))) lst))))

L'algoritmo è abbastanza semplice e può essere estrapolato dai commenti della funzione:

(define (e087)
  (local (val primi primi2 primi3 primi4 limite out)
    (setq out '())
    (setq limite 50000000)
    # calcola i primi fino a sqrt(limite)
    (setq primi (primes-to (int (sqrt limite))))
    ; calcola i quadrati di questi primi (< limite)
    (setq primi2 (filter (fn(x) (< x limite)) (map (fn(x) (* x x)) primi)))
    ; calcola i cubi di questi primi (< limite)
    (setq primi3 (filter (fn(x) (< x limite)) (map (fn(x) (* x x x)) primi)))
    ; calcola le quarte potenze di questi primi (< limite)
    (setq primi4 (filter (fn(x) (< x limite)) (map (fn(x) (* x x x x)) primi)))
    ;(println "p= " primi {-} "p2= " primi2 {-} "p3= " primi3 {-} "p4= " primi4)
    ; crea una lista con le somme di tutti i numeri delle tre liste
    (dolist (a primi2)
      (dolist (b primi3)
        (dolist (c primi4)
          (setq val (+ a b c))
          (if (< val limite)
              (push val out -1)
          ))))
    ; elimina i numeri multipli dalla lista
    (length (unique out))))

(e087)
;-> 1097343

(time (e087))
;-> 1153.946

Per ottimizzare la funzione potremmo:
1) Generare primi2, primi3 e primi4 fino ai numeri i cui quadrati, cubi e quarte potenze sono inferiori al limite
2) fermare il ciclo b quando (a + b) > limite
3) fermare il ciclo c quando (a + b + c) > limite
4) inserire i valori in una hash-map

Comunque il tempo di esecuzione è soddisfacente.
----------------------------------------------------------------------------


===========
Problema 88
===========

Somma e prodotti di numeri

Un numero naturale, N, che può essere scritto come la somma e il prodotto di un dato insieme di almeno due numeri naturali, {a1, a2, ..., ak} è chiamato numero di somma-prodotto: N = a1 + a2 + ... + ak = a1 × a2 × ... × ak.

Ad esempio, 6 = 1 + 2 + 3 = 1 × 2 × 3.

Per un dato insieme di dimensioni, k, chiameremo il più piccolo N con questa proprietà un numero minimo di somma-prodotto. I numeri minimi della somma-prodotto per gli insiemi di dimensione, k = 2, 3, 4, 5 e 6 sono i seguenti.

k = 2:  4 = 2 × 2 = 2 + 2
k = 3:  6 = 1 × 2 × 3 = 1 + 2 + 3
k = 4:  8 = 1 × 1 × 2 × 4 = 1 + 1 + 2 + 4
k = 5:  8 = 1 × 1 × 2 × 2 × 2 = 1 + 1 + 2 + 2 + 2
k = 6: 12 = 1 × 1 × 1 × 1 × 2 × 6 = 1 + 1 + 1 + 1 + 2 + 6

Quindi per 2≤k≤6, la somma di tutti i numeri minimi di somma-prodotto è 4 + 6 + 8 + 12 = 30. Si noti che 8 viene conteggiato una sola volta nella somma.

Infatti, poiché l'insieme completo dei numeri minimi di somma del prodotto per 2≤k≤12 è {4, 6, 8, 12, 15, 16}, la somma è 61.

Qual'è la somma di tutti i numeri minimi di somma-prodotto per 2≤k≤12000?
============================================================================

Per ottenere la somma-prodotto uguale di un numero n occorre utilizzare la fattorizzazione del numero per ottenere il prodotto e aggiungere tanti 1 alla somma per eguagliare il valore del prodotto, poi aggiungiamo lo stesso numero di 1 come moltiplicandi (che non cambiano il valore del prodotto). Per esempio:

(setq n 12)
(factor n)
;-> (2 2 3)

prodotto = 2 * 2 * 3 = 12
   somma = 2 + 2 + 3 + 1 + 1 + 1 + 1 + 1 = 12
prodotto = 2 * 2 * 3 * 1 * 1 * 1 * 1 = 12

Possiamo anche ricavare una formula per il valore della somma-prodotto di una qualunque lista di fattori:

k = numero-di-fattori + prodotto-dei-fattori - somma-dei-fattori

Per esempio per la lista di fattori (2 2 3) abbiamo:

k = 3 + 12 - 7 = 8

Inoltre la somma-prodotto minima per k è maggiore o uguale a k poiché la somma-prodotto minima consiste di k unità che sommano a k. Il limite superiore per la somma-prodotto minima per k è 2k. Il motivo è che possiamo sempre usare i fattori (2, k) questo ci dà il prodotto 2*k e la somma 2+k. Aggiungendo k-2 unità otteniamo una somma di prodotto valida per k che è uguale a 2k.
In altre parole, il prodotto-somma minimo (spm) per k è compreso tra k e 2*k (k ≤ spm(k) ≤ 2*k).

(define (get-k f-lst) (+ (length f-lst) (apply * f-lst) (- (apply + f-lst))))

(get-k (factor 6))
;-> 3

(get-k (factor 8))
;-> 5

Quindi basta fattorizzare tutti i numeri compresi tra 2 e 24000 per verificare se queste fattorizzazioni sono una somma-prodotto minima di qualche k.
Purtroppo bisogna considerare tutte le combinazioni di fattorizzazione per ogni numero perchè la somma-prodotto minima di qualche k non viene prodotta dalla scomposizione primitiva. Per esempio prendiamo il numero 8:

Scomposizione primitiva:
(factor 8)
;-> (2 2 2)
(get-k (factor 8))
;-> 5

L'altra scomposizione di 8 vale: (2 4)
(get-k '(2 4))
;-> 4

Il valore somma-prodotto minimo vale 4 per il numero 8.

Possiamo scrivere una funzione che genera tutte le fattorizzazioni di ogni numero fino a 2*k, ma è molto lenta:

(define (get-factorizations n)
  (let (afc '())
    (all-fact n '() n)))

(define (all-fact num parfac parval)
  (let ((newval parval) (i (- num 1)))
    (while (>= i 2)
      (cond ((zero? (% num i))
              (if (> newval 1) (setq newval i))
              (if (and (<= (/ num i) parval) (<= i parval) (>= (/ num i) i))
                  (begin
                    (push (append parfac (list i (/ num i))) afc -1)
                    (setq newval (/ num i))
                  )
              )
              (if (<= i parval)
                  (all-fact (/ num i) (append parfac (list i)) newval)
              )
            )
      )
      (-- i)
    )
    (sort (unique (map sort afc)))))

(get-factorizations 8)
;-> ((2 2 2) (2 4))
(get-factorizations 12)
;-> ((2 2 3) (2 6) (3 4))
(get-factorizations 24)
;-> ((2 2 2 3) (2 2 6) (2 3 4) (2 12) (3 8) (4 6))
(get-factorizations 280)
;-> ((2 2 2 5 7) (2 2 2 35) (2 2 5 14) (2 2 7 10) (2 2 70)
;->  (2 4 5 7) (2 4 35) (2 5 28) (2 7 20) (2 10 14) (2 140)
;->  (4 5 14) (4 7 10) (4 70) (5 7 8) (5 56) (7 40) (8 35)
;->  (10 28) (14 20))
(get-factorizations 11)
;-> ()
(get-factorizations 577)
;-> ()

Ma questa funzione è inutilizzabile per valori superiori a 10000:

(time (println (get-factorizations 12000)))
;->  ....
;->  (75 160)
;->  (80 150)
;->  (96 125)
;->  (100 120))
;-> 275880.184

Allora calcoliamo dinamicamente ogni fattorizzazione per ogni numero fino a 24.000 aggiungendo ogni fattore a ciascuna fattorizzazione di numeri più piccoli.

(define (fattorizza n resto fattore-max termine somma)
  (cond ((= resto 1)
         (setq termine (+ termine (- n somma)))
         (if (and (<= termine limite) (< n (spm termine)))
             (setf (spm termine) n))
        )
        (true
        (for (i 2 fattore-max)
          (cond ((zero? (% resto i))
                 (setq fattore i)
                 (fattorizza n (/ resto fattore) (min fattore fattore-max) (+ termine 1) (+ somma fattore))))))))

(define (e088)
  (local (limite spm n resto fattore-max fattore somma termine)
    (setq limite 12000)
    (setq spm (array (+ limite 1) '(999999999)))
    (for (i 2 (* limite 2))
      ;(if (zero? (% i 4000)) (print i { }))
      (fattorizza i i i 0 0)
    )
    (setq out (sort (unique (array-list spm))))
    (apply + (slice out 1 (- (length out) 2)))))

(e088)
;-> 7587457

(time (println (e088)))
;-> 24771.751

Il seguente algoritmo calcola il valore minimo di somma-prodotto ricorsivamente:

(define (cerca prodotto somma i)
  (catch
  (local (valprod valsomma)
    (setf (out (- prodotto somma)) (min (out (- prodotto somma)) prodotto))
    (while (<= i (+ n 2))
      (setq valprod (* prodotto i))
      (setq valsomma (+ somma i (- 1)))
      (if (> (- valprod valsomma) n) (throw 'end))
      (cerca valprod valsomma i)
      (++ i)))))

(define (e088)
  (local (limite extra)
    (setq limite 12000)
    (setq extra (+ limite 10))
    (setq out (array extra '(999999999)))
    (cerca 1 0 2)
    (apply + (unique (array-list (slice out 2 11999))))))

(e088)
;-> 7587457

(time (e088))
;-> 377.014
----------------------------------------------------------------------------


===========
Problema 89
===========

Numeri romani

Affinché un numero scritto in numeri romani sia considerato valido, ci sono regole di base che devono essere seguite. Anche se le regole consentono di esprimere alcuni numeri in più di un modo, esiste sempre un modo "migliore" per scrivere un numero particolare.

Ad esempio, sembrerebbe che ci siano almeno sei modi per scrivere il numero sedici:

IIIIIIIIIIIIIIII
VIIIIIIIIIII
VVIIIIII
XIIIIII
VVVI
XVI

Tuttavia, secondo le regole sono validi solo XIIIIII e XVI, e l'ultimo esempio è considerato il più efficiente, poiché utilizza il minor numero di numeri.

Il file di testo 11K, roman.txt, contiene mille numeri scritti in numeri romani validi, ma non necessariamente minimi. V`edi Informazioni sui Numeri romani per le regole definitive di questo problema (.

Trova il numero di caratteri salvati scrivendo ciascuno di questi nella loro forma minima.

Nota: si può presumere che tutti i numeri romani nel file non contengano più di quattro unità identiche consecutive.
============================================================================

Funzione di conversione da numero intero a numero romano:

(define (integer2roman num)
  (local (table roman k)
    (setq table '(("M" 1000) ("CM" 900) ("D" 500) ("CD" 400)
          ("C" 100)("XC" 90)("L" 50)("XL" 40) ("X" 10) ("IX" 9) ("V" 5)
          ("IV" 4) ("I" 1)))
    (setq roman "")
    (dolist (el table)
      (setq k (/ num (last el)))
      (setq num (% num (last el)))
      (extend roman (dup (first el) k))
    )
    roman))

(integer2roman 4444)
;-> "MMMMCDXLIV"

(integer2roman 16)
;-> "XVI"

Funzione di conversione da numero romano a numero intero:

(define (roman2integer roman)
  (local (table curr prev num)
    (setq table '(("I" 1) ("V" 5) ("X" 10) ("L" 50) ("C" 100) ("D" 500) ("M" 1000)))
    (setq prev 0 num 0)
    ; iterate through all characters
    (dostring (ch roman)
      ; converts the current character into an integer
      (setq curr (lookup (char ch) table))
      ; pick the right case to add or subtract
      (if (>= prev curr)
          (setq num (+ num prev))
          (setq num (- num prev))
      )
      (setq prev curr)
    )
    ; add the last value
    (setq num (+ num curr))))

(roman2integer "MMMMCDXLIV")
;-> 4444

(roman2integer "XIIIIII")
;-> 16

Il file "roman.txt" è stato trasformato nel file "e089.lsp" che ha la seguente struttura:

(setq roma '("MMMMDCLXXII" "MMDCCCLXXXIII" "MMMDLXVIIII" ...)

Scriviamo la funzione finale:

(define (e089)
  (local (somma len1 len2)
    (setq somma 0)
    (dolist (el roma)
      (setq len1 (length el))
      (setq len2 (length (integer2roman (roman2integer el))))
      (setq somma (+ somma (- len1 len2)))
      ;(println (list el (length el)) { }
      ;         (list (integer2roman (roman2integer el)) (length (integer2roman (roman2integer el)))))
      ;(read-line)
    )
    somma))

Carichiamo il file ed eseguiamo la funzione:

(load "roma.lsp")
(length roma)
;-> 1000

(e089)
;-> 743

(time e089)
;-> 0
----------------------------------------------------------------------------


===========
Problema 90
===========

Coppie di cubi con cifre

Ciascuna delle sei facce di un cubo ha una cifra diversa (da 0 a 9) scritta su di essa. Lo stesso viene fatto per un secondo cubo. Mettendo i due cubi fianco a fianco in posizioni diverse possiamo formare una varietà di numeri a 2 cifre.

Ad esempio, il numero quadrato 64 potrebbe essere formato con 6 e 4.

Infatti, scegliendo attentamente le cifre su entrambi i cubi è possibile visualizzare tutti i numeri quadrati inferiori al cento: 01, 04, 09, 16, 25, 36, 49, 64 e 81.

Ad esempio, un modo per ottenere questo risultato è posizionare {0, 5, 6, 7, 8, 9} su un cubo e {1, 2, 3, 4, 8, 9} sull'altro cubo.

Tuttavia, per questo problema, permetteremo che il 6 o il 9 siano capovolti in modo che una disposizione come {0, 5, 6, 7, 8, 9} e {1, 2, 3, 4, 6, 7} permette la visualizzazione di tutti i nove numeri quadrati, altrimenti sarebbe impossibile ottenere 09.

Nel determinare una disposizione distinta siamo interessati alle cifre su ogni cubo, non all'ordine.

{1, 2, 3, 4, 5, 6} è equivalente a {3, 6, 4, 1, 2, 5}
{1, 2, 3, 4, 5, 6} è distinto da {1, 2, 3, 4, 5, 9}

Ma poiché stiamo consentendo l'inversione di 6 e 9, i due insiemi distinti nell'ultimo esempio rappresentano entrambi l'insieme esteso {1, 2, 3, 4, 5, 6, 9} allo scopo di formare numeri a 2 cifre.

Quante disposizioni distinte dei due cubi consentono di visualizzare tutti i numeri quadrati?
============================================================================

Risolviamo il problema con il metodo brute-force. Le spiegazioni dell'algoritmo si trovano nei commenti alla funzione.

Funzione che calcola il numero di combinazioni:

(define (comb k lst)
  (cond ((zero? k)   '(()))
        ((null? lst) '())
        (true
          (append (map (lambda (k-1) (cons (first lst) k-1))
                       (comb (- k 1) (rest lst)))
                  (comb k (rest lst))))))

(define (e090)
  (local (quadrati cifre dado out idx1)
    ; lista delle cifre dove al posto del 9 mettiamo 6
    ; per evitare di dover capovolgere le due cifre nel controllo
    (setq cifre '(0 1 2 3 4 5 6 7 8 6))
    ; lista di tutti i quadrati da creare
    ; nota: (0 6) invece di (0 9) e (4 6) invece di (4 9)
    (setq quadrati '((0 1) (0 4) (0 6) (1 6) (2 5) (3 6) (4 6) (8 1)))
    ; lista di tutte le combinazioni di 6 cifre
    (setq dado (comb 6 cifre))
    ; risultato
    (setq out 0)
    ; per ogni elemento/combinazione (es. (2 3 4 6 7 6)) in dado
    (dolist (d1 dado)
      (setq idx1 $idx)
      ; per ogni elemento/combinazione (es. (2 3 4 6 7 6)) in dado
      ; (diverso da se stesso, infatti prendiamo una parte
      ; della lista "dado" con (slice dado idx1))
      (dolist (d2 (slice dado idx1))
        ; controlla se i due elementi/combinazioni verificano i requisiti
        ; cioè creano tutti i quadrati
        (if (controlla d1 d2) (++ out))
      )
    )
    out))

(define (controlla c1 c2)
  (let ((stop nil) (out true))
    ; Per ogni elemento della lista quadrati
    (dolist (quad quadrati stop)
      ; prima cifra del quadrato
      (setq x (first quad))
      ; seconda cifra del quadrato
      (setq y (last quad))
      ; verifichiamo che può essere creato dalla coppia c1 e c2
      ; se un solo quadrato non può essere creato restituisce nil
      ; altrimenti restituisce true, cioè tutti i quadrati
      ; possono essere creati dalla coppia c1 e c2.
      ; la verifica consiste nel controllare se x e y
      ; compaiono in c1 e c2 o viceversa.
      (if (not (or (and (find x c1) (find y c2)) (and (find x c2) (find y c1))))
          (setq out nil stop true)
      )
    )
    out))

(e090)
;-> 1217

(time (e090))
;-> 31.942
----------------------------------------------------------------------------


===========
Problema 91
===========

Triangoli rettangoli con coordinate intere

I punti P (x1,y1) e Q (x2,y2) sono tracciati in coordinate intere e sono uniti all'origine, O (0,0), per formare ΔOPQ.

Ci sono esattamente quattordici triangoli contenenti un angolo retto che può essere formato quando ciascuna coordinata è compresa tra 0 e 2 inclusi, cioè
0 ≤ x1, y1, x2, y2 ≤ 2.

Dato che 0 ≤ x1, y1, x2, y2 ≤ 50, quanti triangoli rettangoli possono essere formati?
============================================================================

Possiamo risolvere il problema con la forza bruta analizzando tutti i possibili triangoli con coordinate x1,y1 e x2,y2 e la terza coordinata da calcolare/verificare.

(define (qdist x1 y1 x2 y2)
  (let ((d1 (mul (- x1 x2) (- x1 x2)))
        (d2 (mul (- y1 y2) (- y1 y2))))
  (add d1 d2)))

(define (e091)
  (local (limite x1 y1 x2 y2 d1 d2 d3 out)
    (setq limite 50)
    (setq out 0)
    (for (x1 0 limite)
      (for (y1 0 limite)
        (cond ((and (= x1 0) (= y1 0)) nil)
              (true
                (for (x2 0 limite)
                  (for (y2 0 limite)
                    (cond ((or (and (= x2 0) (= y2 0)) (and (= x1 x2) (= y1 y2))) nil)
                          (true
                            (setq d1 (qdist 0 0 x1 y1))
                            (setq d2 (qdist 0 0 x2 y2))
                            (setq d3 (qdist x1 y1 x2 y2))
                            (if (or (= (add d1 d2) d3) (= (add d2 d3) d1) (= (add d1 d3) d2))
                                (++ out))))))))))
    (/ out 2)))

(e091)
;-> 14234

(time (e091))
;-> 7259.789

Altro algoritmo:
se entrambe le coordinate si trovano ai lati della griglia, possiamo creare un triangolo rettangolo. Questo triangolo rettangolo può anche essere trasformato in altri due triangoli rettangoli. Poiché ci sono 50 * 50 = 2500 modi per scegliere queste due coordinate, sappiamo già che ci sono almeno 2500 * 3 = 7500 triangoli rettangoli.
Per trovare il resto dei triangoli facciamo questo ragionamento: se vogliamo trovare un triangolo rettangolo con la coordinata P = (1,2) possiamo tracciare una linea che parte dall'origine O fino a P, la linea avrà una pendenza di 2. Quindi se tracciamo una linea con una pendenza -1/2, il reciproco negativo di 2, sarà perpendicolare a OP. Poiché l'altra coordinata Q deve contenere numeri interi, troveremo Q spostando P 2 blocchi a destra e 1 blocco in basso (usando pendenza = -1/2). Questo triangolo rettangolo sopra può anche essere riflesso lungo la linea y = x per formare un altro triangolo rettangolo.
triangolo rettangolo con coordinate (2, 1) e (1, 3), a y = x riflesso dell'immagine sopra.
Inoltre, possiamo estendere PQ di altri 2 blocchi a destra e 1 blocco in basso e creare un triangolo rettangolo diverso con coordinate (1, 2) e (5, 0).
Avvertenza: le pendenze (frazioni) vanno semplificate altrimenti possiamo perdere alcuni triangoli rettangoli.

(define (e091)
  (local (limite p val out)
    (setq limite 50)
    ; Numero di rettangoli per i punti su entrambi i lati.
    ; (che hanno 3 possibili trasformazioni)
    (setq out (* (pow limite 2) 3))
    ; Calcolo rettangoli rimanenti
    (for (x 1 50)
      (for (y 1 50)
        (setq p (gcd x y))
        (setq dx (/ x p))
        (setq dy (/ y p))
        (setq val (mul 2 (min (/ (- limite x) dy) (/ y dx))))
        (setq out (+ out val))
      )
    )
    out))

(e091)
;-> 14234

(time (e091))
;-> 1
----------------------------------------------------------------------------


===========
Problema 92
===========

Catena del quadrato delle cifre

Una catena di numeri viene creata aggiungendo continuamente il quadrato delle cifre in un numero per formare un nuovo numero fino a quando non è stato visto prima.

Per esempio,

44 → 32 → 13 → 10 → 1 → 1
85 → 89 → 145 → 42 → 20 → 4 → 16 → 37 → 58 → 89

Pertanto qualsiasi catena che arriva a 1 o 89 rimarrà bloccata in un ciclo infinito. La cosa più sorprendente è che OGNI numero di partenza alla fine arriverà a 1 o 89.

Quanti numeri di partenza sotto i dieci milioni arriveranno a 89?
============================================================================

Prima di definire la funzione cha calcola la catena, dobbiamo scrivere la funzione cha calcola la somma dei quadrati delle cifre di un numero:

Prima versione "sum-sq-digit":

(define (int-lst num)
  (let (out '())
    (while (!= num 0)
      (push (% num 10) out)
      (setq num (/ num 10))) out))

(define (sum-sq-digit num)
  (apply + (map (fn(x) (* x x)) (int-lst num))))

(sum-sq-digit 32)
;-> 13
(sum-sq-digit 456)
;-> 77
(time (sum-sq-digit 12345678901234567890) 100000)
;-> 1554.87

Seconda versione "sum-sq-digit":

(define (sum-sq-digit num)
  (let ((cifra 0) (tot 0))
  (while (> num 0)
    (setq cifra (% num 10))
    (setq num (/ (- num cifra) 10))
    (setq tot (+ tot (* cifra cifra)))
  )
  tot))

(sum-sq-digit 32)
;-> 13
(sum-sq-digit 456)
;-> 77
(time (sum-sq-digit 12345678901234567890) 100000)
;-> 1263.057
;-> 140.624

Terza versione "sum-sq-digit":

(define (sum-sq-digit num)
  (let ((cifra 0) (tot 0))
  (while (> num 0)
    (setq cifra (% num 10))
    (setq tot (+ tot (* cifra cifra)))
    (setq num (/ num 10))
  )
  tot))

(sum-sq-digit 32)
;-> 13
(sum-sq-digit 456)
;-> 77
(time (sum-sq-digit 12345678901234567890) 100000)
;-> 1112.057

Quarta versione "sum-sq-digit":

(define (sum-sq-digit num)
  (let ((cifra 0) (tot 0))
  (while (> num 0)
    (setq cifra (% num 10))
    (if cifra
      (setq tot (+ tot (* cifra cifra))))
    (setq num (/ num 10))
  )
  tot))

(sum-sq-digit 32)
;-> 13
(sum-sq-digit 456)
;-> 77
(time (sum-sq-digit 12345678901234567890) 100000)
;-> 1106.45

Adesso scriviamo la funzione che calcola la catena di un numero:

(define (chain num)
  (local (chain-lst num-lst val found out)
    (setq val num found nil)
    (until found
      (setq num (sum-sq-digit num))
      (push num chain-lst -1)
      (if (or (= num 1) (= num 89))
          (setq out (list val num (length chain-lst) chain-lst) found true)
      )
    )
    out))

Vediamo alcuni esempi di catene:

(chain 100)
;-> (100 1 1 (1))
(chain 1)
;-> (1 1 1 (1))
(chain 89)
;-> (89 89 8 (145 42 20 4 16 37 58 89))
(chain 44)
;-> (44 1 4 (32 13 10 1))
(chain 85)
;-> (85 89 1 (89))

(for (i 1 20) (println (chain i)))
;-> (1 1 1 (1))
;-> (2 89 5 (4 16 37 58 89))
;-> (3 89 7 (9 81 65 61 37 58 89))
;-> (4 89 4 (16 37 58 89))
;-> (5 89 4 (25 29 85 89))
;-> (6 89 9 (36 45 41 17 50 25 29 85 89))
;-> (7 1 5 (49 97 130 10 1))
;-> (8 89 5 (64 52 29 85 89))
;-> (9 89 6 (81 65 61 37 58 89))
;-> (10 1 1 (1))
;-> (11 89 6 (2 4 16 37 58 89))
;-> (12 89 5 (5 25 29 85 89))
;-> (13 1 2 (10 1))
;-> (14 89 6 (17 50 25 29 85 89))
;-> (15 89 6 (26 40 16 37 58 89))
;-> (16 89 3 (37 58 89))
;-> (17 89 5 (50 25 29 85 89))
;-> (18 89 5 (65 61 37 58 89))
;-> (19 1 4 (82 68 100 1))
;-> (20 89 5 (4 16 37 58 89))

Scriviamo la funzione che calcola la soluzione con la forza bruta:

(define (e092)
  (local (num n89 found)
    (setq num 9999999 n89 0)
    (for (i 1 num)
      (setq found nil)
      (setq k i)
      (until found
        ;(setq k (apply + (map (fn(x) (* x x)) (int-lst k))))
        (setq k (sum-sq-digit k))
        (if (= k 89) (setq n89 (+ n89 1) found true))
        (if (= k 1)  (setq found true))
      )
    )
    n89))

(e092)
;-> 8581146

(time (e092))
;-> 51582.689

Il tempo di esecuzione non è molto soddisfacente.

Per trovare un algoritmo migliore dobbiamo fare alcune considerazioni.

Notiamo che due numeri che hanno le stesse cifre hanno la stessa catena perchè calcoliamo la somma dei quadrati delle cifre. Per esempio i numeri 4666777 e 6767674 hanno la stessa catena:

(chain 4666777)
;-> (4666777 89 9 (271 54 41 17 50 25 29 85 89))

(chain 6767674)
;-> (6767674 89 9 (271 54 41 17 50 25 29 85 89))

Quindi tutti i numeri che hanno le stesse cifre (non considerando lo 0 perchè facciamo il quadrato di ogni cifra) hanno la stessa catena.

Inoltre, la più grande somma possibile di quadrati è creata dal numero 9999999, che vale 7^9 = 567.
Possiamo usare questo numero come dimensione di una lista che contiene tutti i valori generati dal calcolo della somma dei quadrati delle cifre per i numeri inferiori 10 milioni (questo perchè tutti gli altri numeri inferiori a 10 milioni sono solo permutazioni con una somma minore).

Prima scriviamo una funzione che restituisce true se la catena di un dato numero termina con 89, altrimenti restituisce nil:

(define (end89? n)
  (local (sum x)
    (while (and (!= n 1) (!= n 89))
      (setq sum 0)
      (while (> n 0)
        (setq x (% n 10))
        (setq sum (+ sum (* x x)))
        (setq n (/ n 10))
      )
      (setq n sum)
    )
    (= n 89)))

(end89? 1)
;-> nil
(end89? 89)
;-> true
(end89? 4666777)
;-> true
(end89? 6767674)
;-> true

Poi possiamo creare la lista che contiene le somme:

(setq lst-sum '(0))
(for (i 1 567) (push (end89? i) lst-sum -1))

I valori delle somme non coprono tutti i numeri da 1 a 567:

(count '(true) lst-sum)
;-> 486

Adesso dobbiamo sapere quante volte un dato insieme di cifre può verificarsi sotto i 10 milioni. Questo è semplicemente il fattoriale del numero totale di elementi (cioè quante cifre, 7) diviso per il prodotto dei fattoriali dei conteggi degli elementi unici (quante volte compare ogni cifra):

(numero-elementi-gruppo = 7! / (c1! * c2! * ... * c9!))

Per esempio, per il numero 4666777 otteniamo che il numero di elementi vale (coefficiente multinomiale):

numero-elementi-gruppo(4666777) = 7! / (1! * 3! * 3!) = 140

Vediamo quante combinazioni di cifre univoche ci sono da 1 a 9999999 (combinazioni con ripetizione):

(define (comb-rep k lst)
  (cond ((zero? k 0) '(()))
        ((null? lst) '())
        (true
         (append (map (lambda (x) (cons (first lst) x))
                      (comb-rep (- k 1) lst))
                 (comb-rep k (rest lst))))))

(setq numeri (comb-rep 7 '(1 2 3 4 5 6 7 8 9 0)))
(length numeri)
;-> 11440

Esistono solo 11.440 combinazioni di cifre univoche comprese tra 1 e 9999999.

Quindi dobbiamo trovare un modo per calcolare la catena solo di questi numeri.
Potremmo utilizzare 9 cicli "for" per generare numeri del tipo "abcdefg" e quando le cifre soddisfano a≤b≤c≤d≤e≤f≤g, allora controllare la somma nella lista delle somme (lst-sum). Se la catena termina con 89, dobbiamo aggiungere tutte le possibili combinazioni (calcolate con il coefficiente multinomiale) al risultato.

Per velocizzare i calcoli utilizziamo una lista precalcolata per i fattoriali da 0 a 7:

fact = (1 1 2 6 24 120 720 5040)

Oppure possiamo utilizzare direttamente i numeri della lista "numeri", verificare se la sua catena di ogni termina con 89 ed eventualmente aggiungere al totale il numero degli elementi del suo gruppo (cioè tutti i numeri che conducono a 89) calcolando il relativo coefficiente multinomiale.

Proviamo a scrivere una funzione con quest'ultimo algoritmo.

Funzione che converte una lista in un intero:

(define (lst-int lst)
  (let (num 0)
    (dolist (el lst) (setq num (+ el (* num 10))))))

Funzione finale:

(define (e092)
  (local (fact numeri num out)
    (setq out 0)
    (setq fact '(1 1 2 6 24 120 720 5040))
    ; creazione dei 11440 numeri univoci
    (setq numeri (comb-rep 7 '(1 2 3 4 5 6 7 8 9 0)))
    ;(setq numeri (map lst-int (comb-rep 7 '(1 2 3 4 5 6 7 8 9 0))))
    (dolist (el numeri)
      ;(println $idx { } el)
      (setq num (lst-int el))
      ; se la catena del numero corrente finisce con 89
      (if (and (> num 0) (end89? num))
          ; allora aggiorniamo la somma totale
          ; sommando il coefficiente multinomiale
                 ; contiamo la molteplicità delle cifre del numero
          (letn ((conta (count '(1 2 3 4 5 6 7 8 9 0) el))
                 ; e poi calcoliamo il coefficiente multinomiale
                 (coeff (/ (fact 7) (apply * (map (fn(x) (fact x)) conta)))))
                 ; aggiorniamo il totale
                 (setq out (+ out coeff))
          )
      )
    )
    out))

(e092)
;-> 8581146

(time (e092))
;-> 116.715

La prima soluzione processa 9999999 di numeri, mentre la seconda soluzione processa 11440 numeri. Il rapporto vale: (/ 9999999 11440) = 874.
Per i tempi di esecuzione abbiamo il seguente rapporto: (/ 51582 116) = 444, cioè la seconda funzione è circa 450 volte più veloce.
----------------------------------------------------------------------------


===========
Problema 93
===========

Espressioni aritmetiche

Utilizzando ciascuna delle cifre dell'insieme, {1, 2, 3, 4}, esattamente una volta, e facendo uso delle quattro operazioni aritmetiche (+, -, *, /) e parentesi, è possibile formare diversi target interi positivi.

Per esempio,

8 = (4 * (1 + 3)) / 2
14 = 4 * (3 + 1/2)
19 = 4 * (2 + 3) - 1
36 = 3 * 4 * (2 + 1)

Si noti che le concatenazioni delle cifre, come 12 + 34, non sono consentite.

Utilizzando l'insieme, {1, 2, 3, 4}, è possibile ottenere trentuno numeri target diversi di cui 36 è il massimo, e ciascuno dei numeri da 1 a 28 può essere ottenuto prima di incontrare il primo numero non esprimibile.

Trova l'insieme di quattro cifre distinte, a < b < c < d, per il quale è possibile ottenere l'insieme più lungo di interi positivi consecutivi, da 1 a n, dando la tua risposta come una stringa: abcd.
============================================================================

Funzione che valuta le espressioni (rpn):

(define (eval-rpn lst)
  (local (stack a b op operator)
    (setq stack '())
    (setq operator '(+ - * / add sub mul div))
    (dolist (el lst)
      (cond ((number? el)
             (push el stack))
            (true
             (cond ((find el operator)
                    (setq a (pop stack))
                    (setq b (pop stack))
                    (setq op (eval el))
                    ; ritorna 0 se si divide per zero
                    (if (and (zero? a) (or (= op div) (= op /)))
                        (push 0 stack )
                        (push (op b a) stack)))
                   (true (println "operator error:" el))))))
    (pop stack)))

Funzione che calcola le combinazioni:

(define (comb k lst)
  (cond ((zero? k)   '(()))
        ((null? lst) '())
        (true
          (append (map (lambda (k-1) (cons (first lst) k-1))
                       (comb (- k 1) (rest lst)))
                  (comb k (rest lst))))))

(setq cifre '(1 2 3 4 5 6 7 8 9))

(setq digit4 (comb 4 cifre))

(length digit4)
;-> 126

(sort digit4)
;-> ((1 2 3 4) (1 2 3 5) (1 2 3 6) (1 2 3 7) (1 2 3 8) (1 2 3 9)
;->  (1 2 4 5) (1 2 4 6) (1 2 4 7) (1 2 4 8) (1 2 4 9) (1 2 5 6)
;->  ...
;->  (4 7 8 9) (5 6 7 8) (5 6 7 9) (5 6 8 9) (5 7 8 9) (6 7 8 9))

Adesso occorre calcolare le permutazioni di ogni elemento di digit4:

(define (perm lst)
  (local (i indici out)
    (setq indici (dup 0 (length lst)))
    (setq i 0)
    ; aggiungiamo la lista iniziale alla soluzione
    (setq out (list lst))
    (while (< i (length lst))
      (if (< (indici i) i)
          (begin
            (if (zero? (% i 2))
              (swap (lst 0) (lst i))
              (swap (lst (indici i)) (lst i))
            )
            ;(println lst);
            (push lst out -1)
            (++ (indici i))
            (setq i 0)
          )
          (begin
            (setf (indici i) 0)
            (++ i)
          )
       )
    )
    out))

(setq p1234 (perm '(1 2 3 4)))
;-> ((1 2 3 4) (2 1 3 4) (3 1 2 4) (1 3 2 4) (2 3 1 4) (3 2 1 4)
;->  (4 2 1 3) (2 4 1 3) (1 4 2 3) (4 1 2 3) (2 1 4 3) (1 2 4 3)
;->  (1 3 4 2) (3 1 4 2) (4 1 3 2) (1 4 3 2) (3 4 1 2) (4 3 1 2)
;->  (4 3 2 1) (3 4 2 1) (2 4 3 1) (4 2 3 1) (3 2 4 1) (2 3 4 1))

(length (perm '(1 2 3 4)))
;-> 24

(* 24 126)
;-> 3024 liste di numeri da calcolare

Vediamo la lista delle operazioni:

Permutazioni con ripetizione (n^k):

(define (perm-rep k lst)
  (if (zero? k) '(())
      (flat (map (lambda (p) (map (lambda (e) (cons e p)) lst))
                         (perm-rep (- k 1) lst)) 1)))

(setq op '(add sub mul div))

Lista delle operazioni possibili (n^k) = 4^3 = 64:

(setq operats (perm-rep 3 op))
;-> ((add add add) (sub add add) (mul add add) (div add add)
;->  (add sub add) (sub sub add) (mul sub add) (div sub add)
;->  ...
;->  (add div div) (sub div div) (mul div div) (div div div))

(length operats)
;-> 64
(pow 4 3)
;-> 64

(* 3024 64)
;-> 193536 espressioni da valutare

Calcoliamo le sequenze:

Funzione che calcola la sequenza massima (1,n) di una lista:

(define (maxseq lst)
  (let (out 0)
    (setq (lst 0 0) 0)
    (dolist (el lst)
      (if (= el $idx) (setq out $idx)))
    out))

(setq valmaxseq 0)
(setq valmaxseq-numbers '())
(setq res4 '())
(setq res '())
(setq alld4 '())
(dolist (d4 digit4)
  (setq alld4 (perm d4))
  (setq res4 '())
  ;(println d4)
  ;(read-line)
  (dolist (numeri alld4)
    (dolist (el operats)
      ; crea e valuta espressione (es. (1 3 2 4 add mul mul))
      (setq val (abs (eval-rpn (append numeri el))))
      ;(println val { } numeri)
      ;(read-line)
      (if (= val (int val))
        (push val res4)
      )
    )
  )
  (setq res4 (unique (sort res4)))
  ;(println res4)
  ;(read-line)
  (setq seqval (maxseq res4))
  ;(println seqval { } d4)
  ;(read-line)
  (if (> seqval valmaxseq)
      (setq valmaxseq seqval valmaxseq-numbers d4)
  )
)
(println (list valmaxseq valmaxseq-numbers))
;-> (51 (1 2 5 8))

Adesso possiamo scrivere la funzione finale:

(define (e093)
  (local (cifre digit4 op)
    (setq cifre '(1 2 3 4 5 6 7 8 9))
    (setq digit4 (comb 4 cifre))
    (sort digit4)
    (setq op '(add sub mul div))
    (setq operats (perm-rep 3 op))
    (setq valmaxseq 0)
    (setq valmaxseq-numbers '())
    (setq res4 '())
    (setq res '())
    (setq alld4 '())
    (dolist (d4 digit4)
      (setq alld4 (perm d4))
      (setq res4 '())
      ;(println d4)
      ;(read-line)
      (dolist (numeri alld4)
        (dolist (el operats)
          ; crea e valuta espressione (es. (1 3 2 4 add mul mul))
          (setq val (abs (eval-rpn (append numeri el))))
          ;(println val { } numeri)
          ;(read-line)
          (if (= val (int val))
            (push val res4)
          )
        )
      )
      (setq res4 (unique (sort res4)))
      ;(println res4)
      ;(read-line)
      (setq seqval (maxseq res4))
      ;(println seqval { } d4)
      ;(read-line)
      (if (> seqval valmaxseq)
          (setq valmaxseq seqval valmaxseq-numbers d4)
      )
    )
  (list valmaxseq valmaxseq-numbers)
  (join (map string valmaxseq-numbers))))

(e093)
;-> "1258"

(time (e093))
;-> 389.985
----------------------------------------------------------------------------


===========
Problema 94
===========

Triangoli quasi equilateri

È facilmente dimostrato che non esiste alcun triangolo equilatero con lati di lunghezza intera e area intera. Tuttavia, il triangolo quasi equilatero 5-5-6 ha un'area di 12 unità quadrate.

Definiremo un triangolo quasi equilatero come un triangolo per cui due lati sono uguali e il terzo differisce di non più di un'unità.

Trova la somma dei perimetri di tutti i triangoli quasi equilateri con lunghezze laterali e area integrali e i cui perimetri non superano un miliardo (1.000.000.000).
============================================================================

Possiamo risolvere il problema utilizzando le triple pitagoriche primitive o l'equazione di Pell.

(define (e094)
  (local (a b c m n limite out)
  ; a = m^2 - n^2
  ; b = 2*m*n
  ; c = m^2 + n^2
  ; a + b + c = 2*m^2 + 2*m*n = 2*m*(m + n)
  ; quindi m < sqrt((a+b+c)/2)
  (setq limite (int (sqrt (div 1e9 2))))
  ;(setq limite 12000)
  (setq out 0)
  (for (n 1 limite)
    (for (m (+ n 1) limite)
      ; test tripla primitiva
      (if (and (= (gcd m n) 1) (!= (% (- m n) 2) 0))
          (begin
            ; genera una tripla pitagorica (metodo di euclide)
            (setq a (- (* m m) (* n n)))
            (setq b (* 2 m n))
            (setq c (+ (* m m) (* n n)))
            ;(println "--> " a { } b { } c)
            ;(read-line)
            ; controllo triangolo quasi equilatero
            (cond ((<= (+ a b c) 1e9)
                   (if (= (abs (- (* 2 a) c)) 1)
                       (setq out (+ out (+ (* 2 c) (* 2 a)))))
                   (if (= (abs (- (* 2 b) c)) 1)
                       (setq out (+ out (+ (* 2 c) (* 2 b))))))
            )
          )
      )
    )
  )
  out))

(e094)
;-> 518408346

(time (e094))
;-> 93751.845

Ponendo il limite uguale a 12000 otteniamo il seguente risultato:

(e094)
;-> 518408346

(time (e094))
;-> 28946.177

Con un altro algoritmo (intelligent brute-force):

(define-macro (psetq)
  (let ((_var '()) (_ex '()))
    (for (i 0 (- (length (args 1)) 1))
      (setq _ex (expand (args 1 i) (args 0 0)))
      (for (j 1 (- (length (args 0)) 1))
        (setq _ex (expand _ex (args 0 j))))
      (push _ex _var -1))
    (dolist (el _var)
      (set (args 0 $idx) (eval el)))))

(define (e094)
  (local (lato1 lato2 perim k out)
    (setq lato1 1 lato2 1 perim 0 k 1 out 0)
    (while (< perim 1e9)
      (psetq (lato1 lato2 k) (lato2 (+ (* 4 lato2) (* 2 k) (- lato1)) (- k)))
      (setq out (+ out perim))
      (setq perim (- (* 3 lato2) k))
    )
    out))

(e094)
;-> 518408346

(time (e094))
;-> 0
----------------------------------------------------------------------------


===========
Problema 95
===========

Catene amichevoli

I divisori propri di un numero sono tutti i divisori escluso il numero stesso. Ad esempio, i divisori propri di 28 sono 1, 2, 4, 7 e 14. Poiché la somma di questi divisori è uguale a 28, lo chiamiamo numero perfetto.

È interessante notare che la somma dei divisori propri di 220 è 284 e la somma dei divisori propri di 284 è 220, formando una catena di due numeri. Per questo motivo, 220 e 284 sono chiamati una coppia amichevole.

Forse meno conosciute sono le catene più lunghe. Ad esempio, iniziando con 12496, formiamo una catena di cinque numeri:

        12496 → 14288 → 15472 → 14536 → 14264 (→ 12496 → ...)

Poiché questa catena ritorna al punto di partenza, viene chiamata catena amichevole.

Trova il membro più piccolo della catena amichevole più lunga con nessun elemento superiore a un milione.
============================================================================

(define (e095)
  (local (limite dp lcmax catena num tmp idx out)
    (setq limite 1000000)
    (setq dp (array limite '(1)))
    (for (i 2 (- (/ limite 2) 1))
      (for (j (* 2 i) (- limite 1) i)
        (setf (dp j) (+ (dp j) i))))
    (setq lcmax 0)
    (for (i 2 (- limite 1))
      (setq num i)
      (setq catena '())
      (while (< (dp num) limite)
        (setq tmp (dp num))
        (setf (dp num) (+ limite 1))
        (setq num tmp)
        (cond ((if (find num catena))
               (setq idx (find num catena))
               (if (> (length (slice catena idx)) lcmax)
                   (setq lcmax (length (slice catena idx))
                        out (apply min (slice catena idx)))))
              (true
               (push num catena -1))
        )
      )
    )
    out))

(e095)
;-> 14316

(time (e095))
;-> 1824.12
----------------------------------------------------------------------------


===========
Problema 96
===========

Su Doku

Su Doku (giapponese che significa luogo del numero) è il nome di un concetto di puzzle popolare. La sua origine non è chiara, ma il merito viene attribuito a Leonhard Euler che ha inventato un puzzle simile e molto più difficile, chiamato Quadrati Latini. L'obiettivo dei puzzle di Su Doku è quello di sostituire gli spazi vuoti (o zeri) in una griglia 9 per 9 in modo tale che ogni riga, colonna e regione 3x3 contenga ciascuna delle cifre da 1 a 9. Di seguito è riportato un esempio di una tipica griglia di puzzle iniziale e della sua griglia di soluzione.

  0 0 3 | 0 2 0 | 6 0 0          4 8 3 | 9 2 1 | 6 5 7
  9 0 0 | 3 0 5 | 0 0 1          9 0 0 | 3 4 5 | 8 2 1
  0 0 1 | 8 0 6 | 4 0 0          2 5 1 | 8 7 6 | 4 9 3
  ------+-------+------          ------+-------+------
  0 0 8 | 1 0 2 | 9 0 0          5 4 8 | 1 3 2 | 9 7 6
  7 0 0 | 0 0 0 | 0 0 8          7 2 9 | 5 6 4 | 1 3 8
  0 0 6 | 7 0 8 | 2 0 0          1 3 6 | 7 9 8 | 2 4 5
  ------+-------+------          ------+-------+------
  0 0 2 | 6 0 9 | 5 0 0          3 7 2 | 6 8 9 | 5 1 4
  8 0 0 | 2 0 3 | 0 0 9          8 1 4 | 2 5 3 | 7 6 9
  0 0 5 | 0 1 0 | 3 0 0          6 9 5 | 4 1 7 | 3 8 2

Un puzzle di Su Doku ben costruito ha una soluzione unica e può essere risolto dalla logica, anche se potrebbe essere necessario impiegare metodi di "indovinare e testare" per eliminare le opzioni (questo è un'opinione molto contestata). La complessità della ricerca determina la difficoltà del puzzle. L'esempio sopra è considerato facile perché può essere risolto con una semplice deduzione diretta.

Il file di testo 6K, sudoku.txt (e096.lsp), contiene cinquanta diversi puzzle di Su Doku che variano in difficoltà, ma tutti con soluzioni uniche (il primo puzzle nel file è l'esempio sopra).

Risolvendo tutti e cinquanta i puzzle, trova la somma di tutti i numeri a 3 cifre che si trovano nell'angolo in alto a sinistra di ogni griglia della soluzione. Ad esempio, 483 è il numero di 3 cifre che si trova nell'angolo in alto a sinistra della griglia della soluzione sopra.
============================================================================

(define (isSafe board row col num)
  (local (safe regionRowStart regionColStart)
    (setq safe true)
    ; numero unico sulla riga (row-clash)
    (for (d 0 (- (length board) 1))
      ; Se il numero che stiamo provando
      ; è presente in quella riga
      ; restituire falso (nil)
      (if (= (board row d) num)
          (setq safe nil)
      )
    )
    (if safe (begin
    ; numero unico sulla colonna (column-clash)
    (for (r 0 (- (length board) 1))
      ; Se il numero che stiamo provando
      ; è presente in quella colonna
      ; restituire falso (nil)
      (if (= (board r col) num)
          (setq safe nil)
      )
    )))
    (if safe (begin
    ; numero unico in ogni regione 3x3 (region-clash)
    (setq regionRowStart (- row (% row 3)))
    (setq regionColStart (- col (% col 3)))
    (for (r regionRowStart (+ regionRowStart 2))
          (for (d regionColStart (+ regionColStart 2))
        (if (= (board r d) num)
            (setq safe nil)
        )
      )
    )))
    ; se non c'è conflitto, allora è sicuro
    safe
  )
)

(define (solveSudoku board)
(catch
  (local (i j row col isEmpty solved)
    (setq row -1 col -1)
    (setq isEmpty true)
    (setq i 0 j 0)
    (while (and isEmpty (< i (length board)))
      (while (and isEmpty (< j (length board)))
        (if (= (board i j) 0)
            ; Esistono ancora dei valori nulli nel puzzle
            (setq row i col j isEmpty nil)
        )
        (++ j)
      )
      (setq j 0)
      (++ i)
    )
    ; stampa la soluzione
    ;(if isEmpty (begin (println board) (throw true)))
    ; salva la soluzione su una variabile globale
    (if isEmpty (begin (setq *sol* board) (throw true)))
    ;else
    (for (num 1 (length board))
        (cond ((isSafe board row col num)
                 (setf (board row col) num)
                 (if (solveSudoku board) (throw true))
                 (setf (board row col) 0)
              )
        )
    )
    nil
  )
))

(define (e096)
  (local (out)
    (setq out 0)
    (load "e096.lsp")
    (setq base "(solveSudoku gridX)")
    (for (i 1 50)
      (setq expr (replace "X" (copy base) (string i)))
      (setq out (+ out (* 100 (*sol* 0 0)) (* 10 (*sol* 0 1)) (*sol* 0 2)))
      ;(println expr)
      (eval-string expr)
      ;(println i { } out)
    )
    out
  )
)

(e096)
;-> 24702

(time (e096))
;-> 27084.701
----------------------------------------------------------------------------


===========
Problema 97
===========

Il più grande primo non-Mersenne

Il primo numero primo noto che supera il milione di cifre è stato scoperto nel 1999 ed è un numero primo di Mersenne della forma 2 ^ 6972593-1. Contiene esattamente 2.098.960 cifre. Successivamente sono stati trovati altri numeri primi di Mersenne, della forma (2^p − 1), che contengono più cifre.

Tuttavia, nel 2004 è stato trovato un enorme numero primo non Mersenne che contiene 2.357.207 cifre: 28433 × 2^7830457 + 1.

Trova le ultime dieci cifre di questo numero primo.
============================================================================

Le ultime 10 cifre di un numero n si ottengono applicando l'operatore modulo: (n % 10000000000).
Il problema è come calcolare velocemente 2^7830457. Cercando di risolvere direttamente l'espressione,  newLISP impiega un tempo lunghissimo. Infatti:

Funzione per calcolare la potenza (intera) di un numero intero:

(define (** num power)
    (let (out 1L)
        (dotimes (i power)
            (setq out (* out num)))))

Scriviamo la funzione:

(define (e097) (% (+ (* (** 2L 7830456L) 28433) 1) 10000000000L))

Attenzione, la seguente funzione impiega moltissimo tempo:

(e097)

Abbiamo visto che per estrapolare le ultime 10 cifre occorre calcolare (n mod 10000000000). Poichè per  l'operazione modulo (mod) vale la proprietà distributiva:

a*b mod n = ((a mod n)*(b mod n)) mod n

possiamo calcolare 2^7830457 utilizzando la moltiplicazione in un ciclo e utilizzando il modulo dopo ogni moltiplicazione. In questo modo non abbiamo neanche bisogno di utilizzare i big-integer:

(define (e097)
  (let (val 2L)
    (for (i 1 7830456)
      (setq val (% (* 2L val) 10000000000L))
    )
    (setq val (* val 28433L))
    (setq val (+ val 1L))
    (setq val (% val 10000000000L))))

(e097)
;-> 8739992577L

(define (e097)
  (let (val 2)
    (for (i 1 7830456)
      (setq val (% (* 2 val) 10000000000))
    )
    (setq val (* val 28433))
    (setq val (+ val 1))
    (setq val (% val 10000000000))))

(e097)
;-> 8739992577

Inoltre il tempo di esecuzione è accettabile:

(time (e097))
;-> 497.573
----------------------------------------------------------------------------


===========
Problema 98
===========

Anagrammi quadrati

Sostituendo ciascuna delle lettere della parola CARE con 1, 2, 9 e 6 rispettivamente, formiamo un numero quadrato: 1296 = 36^2. Ciò che è notevole è che, utilizzando le stesse sostituzioni digitali, anche l'anagramma RACE forma un numero quadrato: 9216 = 96^2. Chiameremo CARE (e RACE) una coppia di parole anagrammate quadrate e specificheremo inoltre che gli zeri iniziali non sono consentiti, né una lettera diversa può avere lo stesso valore digitale di un'altra lettera.

Utilizzando "words.txt", un file di testo da 16 KB contenente quasi duemila parole inglesi comuni, trova tutte le coppie di parole anagrammi quadrate (una parola palindromica NON è considerata anagramma di se stesso).

Qual'è il numero quadrato più grande formato da un membro di una tale coppia?

NOTA: Tutti gli anagrammi formati devono essere contenuti nel file di testo specificato.
============================================================================

(load "e098.lsp")
(length words)
;-> 1786

(words 7)
;-> academic

Definiamo una funzione che ordina le word:

(define (sortword str)
  (list (length str) (join (sort (explode str))) str))

(sortword (words 7))
;-> (8 "AACCDEIM" "ACADEMIC")

(setq ord-words (sort (map sortword words)))
;-> ((1 "A" "A") (1 "I" "I")
;->  (2 "AN" "AN") (2 "AS" "AS")
;->  ...
;->  (13 "AEGIIINNOSTTV" "INVESTIGATION")
;->  (14 "AACCCEHIIRRSTT" "CHARACTERISTIC")
;->  (14 "AADIIIMNNORSTT" "ADMINISTRATION")
;->  (14 "AEEEEINPRRSTTV" "REPRESENTATIVE")
;->  (14 "AEEEINNOPRRSTT" "REPRESENTATION")
;->  (14 "AEEIINNOPRRTTT" "INTERPRETATION")
;->  (14 "BEIIILNOPRSSTY" "RESPONSIBILITY"))

(length ord-words)
;-> 1786

Struttura elemento della lista ord-words:

(lunghezza-word sorted-word word)

Due parole sono anagramma una dell'altra se hanno la stessa sorted-word (quindi anche la lunghezza è la stessa.

Poichè le word palindrome non devono essere considerate possiamo eliminare tutte le parole con lunghezza minore di 3.

(setq ord-words (filter (fn(x) (> (first x) 2)) ord-words))
;-> ((3 "ABD" "BAD") (3 "ABG" "BAG") (3 "ABR" "BAR") (3 "ACN" "CAN")
;->  (3 "ACR" "CAR") (3 "ACT" "ACT") (3 "ACT" "CAT") (3 "ADD" "ADD")
;->  ...
;->  (14 "AEEIINNOPRRTTT" "INTERPRETATION")
;->  (14 "BEIIILNOPRSSTY" "RESPONSIBILITY"))

(length ord-words)
;-> 1761

Cerca le word che sono anagramma:

(setq ana-words '())
(setq len-w 0)
(setq ord-w "")
(setq w-w   "")
(dolist (el ord-words)
  (if (and (= (el 0) len-w) (= (el 1) ord-w))
      (push (list w-w (el 2)) ana-words -1)
  )
  (setq len-w (el 0))
  (setq ord-w (el 1))
  (setq w-w   (el 2))
)

ana-words
;-> (("ACT" "CAT") ("EAT" "TEA") ("DOG" "GOD") ("HOW" "WHO") ("ITS" "SIT")
;->  ("NOW" "OWN") ("CARE" "RACE") ("DEAL" "LEAD") ("HATE" "HEAT")
;->  ("MALE" "MEAL") ("MEAN" "NAME") ("EARN" "NEAR") ("RATE" "TEAR")
;->  ("EAST" "SEAT") ("FILE" "LIFE") ("ITEM" "TIME") ("NOTE" "TONE")
;->  ("SURE" "USER") ("FORM" "FROM") ("SIGN" "SING") ("SHUT" "THUS")
;->  ("POST" "SPOT") ("SPOT" "STOP") ("BOARD" "BROAD") ("PHASE" "SHAPE")
;->  ("EARTH" "HEART") ("ARISE" "RAISE") ("LEAST" "STEAL") ("SHEET" "THESE")
;->  ("QUIET" "QUITE") ("NIGHT" "THING") ("THROW" "WORTH") ("SHOUT" "SOUTH")
;->  ("DANGER" "GARDEN") ("CREDIT" "DIRECT") ("CENTRE" "RECENT")
;->  ("EXCEPT" "EXPECT") ("COURSE" "SOURCE") ("FORMER" "REFORM")
;->  ("IGNORE" "REGION") ("CREATION" "REACTION") ("INTRODUCE" "REDUCTION"))

(length ana-words)
;-> 42

Vediamo se ci sono anagrammi palindromi:

(dolist (el ana-words) (if (= (el 0) (reverse (el 1))) (println el)))
;-> ("DOG" "GOD")

Lasciamolo stare...se non è la soluzione finale.

Adesso dovremmo provare tutte le combinazioni delle cifre (1..9) per ogni coppia di word. Questo è un calcolo molto oneroso e dobbiamo evitarlo.

Se proviamo tutte le sostituzioni lettera per cifra, allora stiamo cercando coppie di quadrati con queste proprietà:

1) hanno la stessa lunghezza

2) hanno le stesse cifre con il numero di occorrenze della stringa di input.

Quindi è più veloce trovare tutte queste coppie di quadrati.

(setq squares (map (fn(x) (* x x)) (sequence 1 50)))
;-> (1 4 9 16 25 36 49 64 81 100 121 144 169 196 225 256 289 324 361 400 441 484 529
;->  576 625 676 729 784 841 900 961 1024 1089 1156 1225 1296 1369 1444 1521 1600 1681
;->  1764 1849 1936 2025 2116 2209 2304 2401 2500)

(define (number-stamp num)
  (let ((ar (array 10 '(0))) (out 0))
    ; fill array with the count of digits
    (while (> num 0)
      (++ (ar (% num 10)))
      (setq num (/ num 10))
    )
    ; create output number from array
    (for (i 9 0)
      (setq out (+ (ar i) (* out 10)))
    )
    out))

(setq squares-stamp (sort (map (fn(x) (list (number-stamp x) x)) squares)))
;-> ((10 1) (12 100) (120 121) (10000 4) (10002 400) (10111 1024)
;->  (10111 2401) (11100 324) (11101 2304) (20010 144) (20010 441)
;->  (30010 1444) (100100 25) (100102 2500) (100120 1521) (100200 225)
;->  (100201 2025) (100210 1225) (1000010 16) (1000012 1600) (1000120 2116)
;->  (1001000 36) (1001010 361) (1010000 64) (1100020 1156) (1100100 256)
;->  (1100100 625) (11010010 1764) (11100000 576) (12000000 676)
;->  (100000010 81) (100010010 841) (100020000 484) (101000020 1681)
;->  (110010000 784) (1000000000 9) (1000000002 900) (1000000201 2209)
;->  (1000010000 49) (1000100100 529) (1001000010 169) (1001000010 196)
;->  (1001000010 961) (1001000110 1296) (1001001010 1369) (1001001010 1936)
;->  (1010000100 729) (1100000011 1089) (1100000100 289) (1100010010 1849))

Cerchiamo le coppie che hanno lo stesso "stampo":

(setq squares-pair '())
(setq stamp-sq 0)
(setq num-sq 0)
(dolist (el squares-stamp)
  (if (= (el 0) stamp-sq)
      (push (list (el 0) num-sq (el 1)) squares-pair -1)
  )
  (setq stamp-sq (el 0))
  (setq num-sq (el 1))
)

squares-pair
;-> ((10111 1024 2401) (20010 144 441) (1100100 256 625)
;->  (1001000010 169 196) (1001000010 196 961) (1001001010 1369 1936))

Adesso dobbiamo eliminare quelle che hanno cifre doppie (es. la cifra 4 nella coppia 144 e 441), cioè quelle che hanno una (o più) cifra con valore maggiore di 1 nello "stamp" (es. la cifra 2 nell'elemento (20010 144 441).

(define (doppie stamp)
  (if (find "2|3|4|5|6|7|8|9" (string stamp) 0) true nil))

(setq sq-pair '())
(dolist (el squares-pair)
  (if (not (doppie (el 0)))
      (push el sq-pair -1)))

sq-pair
;-> ((10111 1024 2401) (1100100 256 625) (1001000010 169 196)
;->  (1001000010 196 961) (1001001010 1369 1936))

Ma fino a quanto dobbiamo calcolare i quadrati?

La word più lunga ha 9 caratteri ("INTRODUCE" "REDUCTION"), quindi il quadrato più grande non può essere maggiore di 987654321.

(sqrt 987654321)
;-> 31426.96805293187

Quindi dobbiamo calcolare il quadrato dei primi 31476 numeri.

Ripetiamo il calcolo:

(setq max-sq 31426)
(setq squares (map (fn(x) (* x x)) (sequence 1 31426)))
(setq squares-stamp (sort (map (fn(x) (list (number-stamp x) x)) squares)))
(setq squares-pair '())
(setq stamp-sq 0)
(setq num-sq 0)
(dolist (el squares-stamp)
  (if (= (el 0) stamp-sq)
      (push (list (el 0) num-sq (el 1)) squares-pair -1)
  )
  (setq stamp-sq (el 0))
  (setq num-sq (el 1))
)
(setq sq-pair '())
(dolist (el squares-pair)
  (if (not (doppie (el 0)))
      (push (list (el 1) (el 2)) sq-pair -1)))

(length sq-pair)
;-> 300

(sort sq-pair)
;-> ((169 196) (196 961) (256 625)
;->  (1024 2401) (1089 9801) (1296 2916)
;->  (1369 1936) (1764 4761) (2916 9216)
;->  (4096 9604) (12769 96721)
;->  (16384 31684) (17689 18769) (18769 78961)
;->  (20736 30276) (21904 41209) (23104 32041)
;->  (23409 39204) (23716 32761) (29584 54289)
;->  (31684 36481) (32761 72361) (34596 45369)
;->  ...
;->  (798401536 803495716)
;->  (825470361 853107264)
;->  (842973156 847159236)
;->  (847159236 923187456))

(sqrt 847159236)
;-> 29106
(sqrt 923187456)
;-> 30384

Quindi dobbiamo confrontare queste 300 coppie di quadrati della lista "sq-pair" con le 42 coppie di word della lista ana-words.
Il confronto completo va effettuato solo con le coppie di word che hanno la stessa lunghezza delle coppie dei quadrati.

Definiamo una funzione che effettua il check:

(define (square? n)
  (let (v (+ (sqrt n 0.5)))
    (= n (* v v))))

(define (int-lst num)
  (let (out '())
    (while (!= num 0)
      (push (% num 10) out)
      (setq num (/ num 10))) out))

(define (lst-int lst)
  (let (num 0)
    (dolist (el lst) (setq num (+ el (* num 10))))))

(setq ww '("CARE" "RACE"))
(setq qq '(1296 9216))

(setq mappa (map list (explode (ww 0)) (int-lst (qq 0))))
;-> (("C" 1) ("A" 2) ("R" 9) ("E" 6))

(setq new-num (lst-int (map (fn(x) (lookup x mappa)) (explode (ww 1)))))
;-> 9216

(define (check w-pair q-pair)
  (setq out nil)
  (cond ((!= (length (w-pair 0)) (length (q-pair 0)))
         (setq out nil))
        (true
          (setq mappa (map list (explode (w-pair 0)) (int-lst (qq 0))))
          (setq new-num (lst-int (map (fn(x) (lookup x mappa)) (explode (w-pair 1)))))
          (if (= new-num (q-pair 1))
              (setq out true)
          )
        )
  )
  out)

(check ww qq)
;-> true

Adesso possiamo confrontare la liste degli anagrammi con la lista dei quadrati:

(setq valmax 0)
(dolist (ww ana-words)
  (dolist (qq sq-pair)
    (cond ((check ww qq)
           (if (> (qq 0) valmax)
             (begin
               (setq valmax (qq 0))
               (println ww { } qq { } valmax)
             ))
           (if (> (qq 1) valmax)
               (begin
                 (setq valmax (qq 1))
                 (println ww { } qq { } valmax)
               )))
    )
  )
)
;-> ("EAT" "TEA") (256 625) 256
;-> ("EAT" "TEA") (256 625) 625
;-> ("NOW" "OWN") (196 961) 961
;-> ("CARE" "RACE") (1296 2916) 1296
;-> ("CARE" "RACE") (1296 2916) 2916
;-> ("DEAL" "LEAD") (1764 4761) 4761
;-> ("RATE" "TEAR") (4096 9604) 9604
;-> ("BOARD" "BROAD") (17689 18769) 17689
;-> ("BOARD" "BROAD") (17689 18769) 18769

valmax
;-> 18769

Nota: questo metodo trova la soluzione esatta, ma non trova l'esempio citato dal problema (CARE RACE 1296 9216) perchè quando abbiamo cercato le coppie che hanno lo stesso "stampo" non abbiamo considerato l'ipotesi che possano esistere delle triple con lo stesso stampo, in questo caso la tripla: (1296 = 36^2, 2916 = 54, 9216 = 96^2).

Scriviamo la funzione completa:

(load "e098.lsp")

(define (sortword str)
  (list (length str) (join (sort (explode str))) str))

(define (number-stamp num)
  (let ((ar (array 10 '(0))) (out 0))
    ; fill array with the count of digits
    (while (> num 0)
      (++ (ar (% num 10)))
      (setq num (/ num 10))
    )
    ; create output number from array
    (for (i 9 0)
      (setq out (+ (ar i) (* out 10)))
    )
    out))

(define (doppie stamp)
  (if (find "2|3|4|5|6|7|8|9" (string stamp) 0) true nil))

(define (square? n)
  (let (v (+ (sqrt n 0.5)))
    (= n (* v v))))

(define (int-lst num)
  (let (out '())
    (while (!= num 0)
      (push (% num 10) out)
      (setq num (/ num 10))) out))

(define (lst-int lst)
  (let (num 0)
    (dolist (el lst) (setq num (+ el (* num 10))))))

(define (check w-pair q-pair)
  (setq out nil)
  (cond ((!= (length (w-pair 0)) (length (q-pair 0)))
         (setq out nil))
        (true
          (setq mappa (map list (explode (w-pair 0)) (int-lst (qq 0))))
          (setq new-num (lst-int (map (fn(x) (lookup x mappa)) (explode (w-pair 1)))))
          (if (= new-num (q-pair 1))
              (setq out true)
          )
        )
  )
  out)

(define (e098)
  (local (ord-words ana-words len-w ord-w w-w
          max-sq squares squares-stamp squares-pair
          stamp-sq num-sq sq-pair valmax)
    (setq ord-words (sort (map sortword words)))
    (setq ord-words (filter (fn(x) (> (first x) 2)) ord-words))
    (setq ana-words '())
    (setq len-w 0)
    (setq ord-w "")
    (setq w-w   "")
    (dolist (el ord-words)
      (if (and (= (el 0) len-w) (= (el 1) ord-w))
          (push (list w-w (el 2)) ana-words -1)
      )
      (setq len-w (el 0))
      (setq ord-w (el 1))
      (setq w-w   (el 2))
    )
    (setq max-sq 31426)
    (setq squares (map (fn(x) (* x x)) (sequence 1 max-sq)))
    (setq squares-stamp (sort (map (fn(x) (list (number-stamp x) x)) squares)))
    (setq squares-pair '())
    (setq stamp-sq 0)
    (setq num-sq 0)
    (dolist (el squares-stamp)
      (if (= (el 0) stamp-sq)
          (push (list (el 0) num-sq (el 1)) squares-pair -1)
      )
      (setq stamp-sq (el 0))
      (setq num-sq (el 1))
    )
    (setq sq-pair '())
    (dolist (el squares-pair)
      (if (not (doppie (el 0)))
          (push (list (el 1) (el 2)) sq-pair -1)))
    (sort sq-pair)
    (setq valmax 0)
    (dolist (ww ana-words)
      (dolist (qq sq-pair)
        (cond ((check ww qq)
              (if (> (qq 0) valmax)
                (begin
                  (setq valmax (qq 0))
                  ;(println ww { } qq { } valmax)
                ))
              (if (> (qq 1) valmax)
                  (begin
                    (setq valmax (qq 1))
                    ;(println ww { } qq { } valmax)
                  )))
        )
      )
    )
    valmax))

(e098)
;-> 18769

(time (e098))
;-> 130.677
----------------------------------------------------------------------------


===========
Problema 99
===========

Massimo esponenziale

Confrontare due numeri scritti in forma di indice come 2^11 e 3^7 non è difficile, poiché qualsiasi calcolatrice confermerebbe che 2^11 = 2048 < 3^7 = 2187.

Tuttavia, confermare che 632382^518061 > 519432^525806 sarebbe molto più difficile, poiché entrambi i numeri contengono oltre tre milioni di cifre.

Utilizzando "base_exp.txt", un file di testo da 22 KB contenente mille righe con una coppia base / esponente su ciascuna riga, determinare quale numero di riga ha il valore numerico maggiore.

NOTA: le prime due righe nel file rappresentano i numeri nell'esempio fornito sopra.
============================================================================

Il file "base_exp.txt" è stato trasformato nel file "e099.lsp".

Non è necessario calcolare le potenze direttamente. Possiamo usare i logaritmi utilizzando le seguenti proprietà:

1) log(x) < (log(y) implica che x < y e viceversa (perchè log(x) è una funzione crescente).
2) log(x^y) = y*log(x)

In questo modo dobbiamo trovare il massimo dei valori: y*(log(x).

Carichiamo il file che contiene la lista "lst" con tutte le coppie di numeri (x y):

(load "e099.lsp")

(define (e099)
  (let ((max-val 0) (riga 0))
    (dolist (el lst)
      (if (> (mul (last el) (log (first el))) max-val)
          (setq riga (+ 1 $idx) max-val (mul (last el) (log (first el))))))
    riga))

(e099)
;-> 709

(time (e099))
;-> 0
----------------------------------------------------------------------------


============
Problema 100
============

Probabilità stabilite

Se una scatola contiene ventuno dischi colorati, composti da quindici dischi blu e sei dischi rossi, e due dischi sono stati presi a caso, si può vedere che la probabilità di prendere due dischi blu, P (BB) = (15/21) × (14/20) = 1/2.

La successiva disposizione di questo tipo, per la quale c'è esattamente il 50% di possibilità di prendere due dischi blu a caso, è una scatola contenente ottantacinque dischi blu e trentacinque dischi rossi.

Trova la prima disposizione che contenga più di 10^12 = 1.000.000.000.000 dischi in totale, determinare il numero di dischi blu che la confezione deve contenere.
============================================================================

                                 b     (b - 1)
Bisogna risolvere l'equazione:  --- * --------- = 1/2.
                                 n     (n - 1)

Sviluppando si ottiene: 2b^2 - 2b - n^2 + n = 0 che è una equazione quadratica diofantina. Risolvendo per b otteniamo le due soluzioni: b = (2 + sqrt (4 + 8n^2 - 8n)) / 4 = (1 + sqrt (1 + 2n^2 - 2n))/2. Quindi, è sufficiente trovare valori di n tali che 2n^2 - 2n + 1 = c^2 per qualche intero c. Risolvendo per n, otteniamo n = (2 + sqrt (8c^2 - 4))/4 = (1 + sqrt(2c^2 - 1))/2. Quindi, è sufficiente trovare valori di c tali che d^2 - 2c^2 = -1 per qualche intero d. Se (d, c) è una soluzione, (3*d + 4*c, 2*d + 3*c) è la prossima soluzione. Pertanto, le soluzioni intere per c possono essere generate ricorsivamente e ciascuna può essere tradotta in una soluzione distinta per il valore di b. Questo ragionamento porta alla coppia di equazioni ricorsive:

b(k+1) = 3*b(k) + 2*n(k) - 2
n(k+1) = 4*b(k) + 3*n(k) - 3

Adesso possiamo scrivere la funzione:

(define (e100)
  (let ((n 21) (b 15) (b1 0) (n1 0))
    (while (< n 1000000000000)
      (setq b1 (+ (* 3 b) (* 2 n) (- 2)))
      (setq n1 (+ (* 4 b) (* 3 n) (- 3)))
      (setq b b1 n n1)
    )
    b))

(e100)
;-> 756872327473

(time (e100))
;-> 0
----------------------------------------------------------------------------


============
Problema 101
============

Polinomio ottimale

Se ci vengono presentati i primi k termini di una sequenza, è impossibile dire con certezza il valore del termine successivo, poiché ci sono infinite funzioni polinomiali che possono modellare la sequenza.

Ad esempio, consideriamo la sequenza dei numeri dei cubi. Questo è definito dalla funzione generatrice,
u^n = n^3: 1, 8, 27, 64, 125, 216, ...

Supponiamo che ci siano stati dati solo i primi due termini di questa sequenza. Lavorando sul principio che "semplice è il migliore" dovremmo assumere una relazione lineare e prevedere che il termine successivo sia 15 (differenza comune 7). Anche se ci venissero presentati i primi tre termini, secondo lo stesso principio di semplicità, si dovrebbe assumere una relazione quadratica.

Definiremo OP(k, n) come l'ennesimo termine della funzione generatrice polinomiale ottima per i primi k termini di una sequenza. Dovrebbe essere chiaro che OP(k, n) genererà accuratamente i termini della sequenza per n ≤ k, e potenzialmente il primo termine errato (FIT - First Incorrect Term) sarà OP(k, k + 1): in tal caso lo chiameremo un cattivo OP (BOP - Bad OP).

Come base, se ci fosse dato solo il primo termine di sequenza, sarebbe più sensato assumerlo costante, cioè, per n ≥ 2, OP(1, n) = u1.

Quindi otteniamo i seguenti OP per la sequenza cubica:

OP (1, n) = 1                   1, 1, 1, 1, ...
                                   -
OP (2, n) = 7n − 6              1, 8, 15, ...
                                      --
OP (3, n) = 6n^2 − 11n + 6      1, 8, 27, 58, ...
                                          --
OP (4, n) = n3                  1, 8, 27, 64, 125, ...

Chiaramente non esistono BOP per k ≥ 4.

Considerando la somma dei FIT generati dai BOP (sottolineati sopra), otteniamo 1 + 15 + 58 = 74.

Considera la seguente funzione di generazione del polinomio di decimo grado:

un = 1 - n + n ^ 2 - n ^ 3 + n ^ 4 - n ^ 5 + n ^ 6 - n ^ 7 + n ^ 8 - n ^ 9 + n ^ 10

Trova la somma dei FIT per i BOP.
============================================================================

Si tratta di un problema prettamente matematico e questa volta ho utilizzato SAGE/python per trovare la soluzione.

def ug(n):
   y = 1 - n + n^2 - n^3 + n^4 - n^5 + n^6 -n^7 + n^8 - n^9 +  n^10
   return(y)

def ugLista(n):
   ugL = []
   for i in range(1,n+1):
       ugL.append(ug(i))
   return(ugL)

ugLista(12)

[1, 683, 44287, 838861, 8138021, 51828151, 247165843, 954437177,
3138105961, 9090909091, 23775972551, 57154490053]

def eulero101(plotta = False):
   import numpy as np
   bop = [1]

   grado = 1
   x = np.array(range(0,grado+1), dtype=float)
   y = np.array([1,683], dtype=float)
   coeff = np.polyfit(x,y,grado)
   poli = np.poly1d(np.polyfit(x,y,grado))
   coeffL = []
   for i in range(len(coeff)):
       coeffL.append(int(round(coeff[i])))
   print coeffL,
   html('<pre>' + str(poli)  + '</pre>')
   for i in range(0,grado+2):
       print poli(i),
   bop.append(poli(i))
   if plotta:
       P0 = list_plot(zip(x,y), rgbcolor='red')
       P1 = list_plot([(i,poli(i)) for i in np.linspace(int(0),int(10),100)],plotjoined=True)
       show(P0 + P1)

   grado = 2
   x = np.array(range(0,grado+1), dtype=float)
   y = np.array([1,683,44287], dtype=float)
   coeff = np.polyfit(x,y,grado)
   poli = np.poly1d(np.polyfit(x,y,grado))
   coeffL = []
   for i in range(len(coeff)):
       coeffL.append(int(round(coeff[i])))
   print coeffL,
   html('<pre>' + str(poli)  + '</pre>')
   for i in range(0,grado+2):
       print poli(i),
   bop.append(poli(i))
   if plotta:
       P0 = list_plot(zip(x,y), rgbcolor='red')
       P1 = list_plot([(i,poli(i)) for i in np.linspace(int(0),int(10),100)],plotjoined=True)
       show(P0 + P1)

   grado = 3
   x = np.array(range(0,grado+1), dtype=float)
   y = np.array([1,683,44287,838861], dtype=float)
   coeff = np.polyfit(x,y,grado)
   poli = np.poly1d(np.polyfit(x,y,grado))
   coeffL = []
   for i in range(len(coeff)):
       coeffL.append(int(round(coeff[i])))
   print coeffL,
   html('<pre>' + str(poli)  + '</pre>')
   for i in range(0,grado+2):
       print poli(i),
   bop.append(poli(i))
   if plotta:
       P0 = list_plot(zip(x,y), rgbcolor='red')
       P1 = list_plot([(i,poli(i)) for i in np.linspace(int(0),int(10),100)],plotjoined=True)
       show(P0 + P1)

   grado = 4
   x = np.array(range(0,grado+1), dtype=float)
   y = np.array([1,683,44287,838861,8138021], dtype=float)
   coeff = np.polyfit(x,y,grado)
   poli = np.poly1d(np.polyfit(x,y,grado))
   coeffL = []
   for i in range(len(coeff)):
       coeffL.append(int(round(coeff[i])))
   print coeffL,
   html('<pre>' + str(poli)  + '</pre>')
   for i in range(0,grado+2):
       print poli(i),
   bop.append(poli(i))
   if plotta:
       P0 = list_plot(zip(x,y), rgbcolor='red')
       P1 = list_plot([(i,poli(i)) for i in np.linspace(int(0),int(10),100)],plotjoined=True)
       show(P0 + P1)

   grado = 5
   x = np.array(range(0,grado+1), dtype=float)
   y = np.array([1, 683, 44287, 838861, 8138021, 51828151], dtype=float)
   coeff = np.polyfit(x,y,grado)
   poli = np.poly1d(np.polyfit(x,y,grado))
   coeffL = []
   for i in range(len(coeff)):
       coeffL.append(int(round(coeff[i])))
   print coeffL,
   html('<pre>' + str(poli)  + '</pre>')
   for i in range(0,grado+2):
       print poli(i),
   bop.append(poli(i))
   if plotta:
       P0 = list_plot(zip(x,y), rgbcolor='red')
       P1 = list_plot([(i,poli(i)) for i in np.linspace(int(0),int(10),100)],plotjoined=True)
       show(P0 + P1)

   grado = 6
   x = np.array(range(0,grado+1), dtype=float)
   y = np.array([1, 683, 44287, 838861, 8138021, 51828151, 247165843], dtype=float)
   coeff = np.polyfit(x,y,grado)
   poli = np.poly1d(np.polyfit(x,y,grado))
   coeffL = []
   for i in range(len(coeff)):
       coeffL.append(int(round(coeff[i])))
   print coeffL,
   html('<pre>' + str(poli)  + '</pre>')
   for i in range(0,grado+2):
       print poli(i),
   bop.append(poli(i))
   if plotta:
       P0 = list_plot(zip(x,y), rgbcolor='red')
       P1 = list_plot([(i,poli(i)) for i in np.linspace(int(0),int(10),100)],plotjoined=True)
       show(P0 + P1)

   grado = 7
   x = np.array(range(0,grado+1), dtype=float)
   y = np.array([1, 683, 44287, 838861, 8138021, 51828151, 247165843, 954437177], dtype=float)
   coeff = np.polyfit(x,y,grado)
   poli = np.poly1d(np.polyfit(x,y,grado))
   coeffL = []
   for i in range(len(coeff)):
       coeffL.append(int(round(coeff[i])))
   print coeffL,
   html('<pre>' + str(poli)  + '</pre>')
   for i in range(0,grado+2):
       print poli(i),
   bop.append(poli(i))
   if plotta:
       P0 = list_plot(zip(x,y), rgbcolor='red')
       P1 = list_plot([(i,poli(i)) for i in np.linspace(int(0),int(10),100)],plotjoined=True)
       show(P0 + P1)

   grado = 8
   x = np.array(range(0,grado+1), dtype=float)
   y = np.array([1, 683, 44287, 838861, 8138021, 51828151, 247165843, 954437177, 3138105961], dtype=float)
   coeff = np.polyfit(x,y,grado)
   poli = np.poly1d(np.polyfit(x,y,grado))
   coeffL = []
   for i in range(len(coeff)):
       coeffL.append(int(round(coeff[i])))
   print coeffL,
   html('<pre>' + str(poli)  + '</pre>')
   for i in range(0,grado+2):
       print poli(i),
   bop.append(poli(i))
   if plotta:
       P0 = list_plot(zip(x,y), rgbcolor='red')
       P1 = list_plot([(i,poli(i)) for i in np.linspace(int(0),int(10),100)],plotjoined=True)
       show(P0 + P1)

   grado = 9
   x = np.array(range(0,grado+1), dtype=float)
   y = np.array([1, 683, 44287, 838861, 8138021, 51828151, 247165843, 954437177, 3138105961, 9090909091], dtype=float)
   coeff = np.polyfit(x,y,grado)
   poli = np.poly1d(np.polyfit(x,y,grado))
   coeffL = []
   for i in range(len(coeff)):
       coeffL.append(int(round(coeff[i])))
   print coeffL,
   html('<pre>' + str(poli)  + '</pre>')
   for i in range(0,grado+2):
       print poli(i),
   bop.append(poli(i))
   if plotta:
       P0 = list_plot(zip(x,y), rgbcolor='red')
       P1 = list_plot([(i,poli(i)) for i in np.linspace(int(0),int(10),100)],plotjoined=True)
       show(P0 + P1)

   grado = 10
   x = np.array(range(0,grado+1), dtype=float)
   y = np.array([1, 683, 44287, 838861, 8138021, 51828151, 247165843, 954437177, 3138105961, 9090909091, 23775972551], dtype=float)
   coeff = np.polyfit(x,y,grado)
   poli = np.poly1d(np.polyfit(x,y,grado))
   coeffL = []
   for i in range(len(coeff)):
       coeffL.append(int(round(coeff[i])))
   print coeffL,
   html('<pre>' + str(poli)  + '</pre>')
   for i in range(0,grado+2):
       print poli(i),
   if plotta:
       P0 = list_plot(zip(x,y), rgbcolor='red')
       P1 = list_plot([(i,poli(i)) for i in np.linspace(int(0),int(10),100)],plotjoined=True)
       show(P0 + P1)

   print bop
   #print int(round(sum(bop)))
   return(int(round(sum(bop))))

time eulero101(plotta=False)

[682, 1]

682 x + 1

1.0 683.0 1365.0
[21461, -20779, 1]
           2
2.146e+04 x - 2.078e+04 x + 1

0.999999999993 683.0 44287.0 130813.0
[118008, -332563, 215237, 1]
          3             2
1.18e+05 x - 3.326e+05 x + 2.152e+05 x + 1

1.0 683.0 44287.0 838861.0 3092453.0
[210232, -1143384, 1979989, -1046155, 1]
           4             3            2
2.102e+05 x - 1.143e+06 x + 1.98e+06 x - 1.046e+06 x + 1

1.0000000149 683.00000001 44287.0 838861.0 8138021.0 32740951.0
[159060, -1380368, 4423716, -5973011, 2771285, 1]
           5            4             3             2
1.591e+05 x - 1.38e+06 x + 4.424e+06 x - 5.973e+06 x + 2.771e+06 x + 1

0.999999880791 683.000000086 44286.9999999 838861.0 8138021.0 51828151.0 205015603.0
[58542, -719070, 3595702, -8748234, 10067497, -4253755, 1]
           6             5             4             3             2
5.854e+04 x - 7.191e+05 x + 3.596e+06 x - 8.748e+06 x + 1.007e+07 x - 4.254e+06 x + 1

1.0 682.999999477 44287.0000006 838861.0 8138021.0 51828151.0 247165843.0 898165577.0
[11165, -175923, 1234805, -4610573, 9383726, -9627563, 3785045, 1]
           7             6             5             4             3              2
1.117e+04 x - 1.759e+05 x + 1.235e+06 x - 4.611e+06 x + 9.384e+06 x - 9.628e+06 x + 3.785e+06 x + 1

1.0 683.000003743 44287.0000004 838861.000003 8138021.0 51828151.0 247165843.0 954437177.0 3093310441.0
[1111, -19943, 181819, -942755, 2909786, -5205926, 4890985, -1814395, 1]
      8             7             6             5            4             3             2
1111 x - 1.994e+04 x + 1.818e+05 x - 9.428e+05 x + 2.91e+06 x - 5.206e+06 x + 4.891e+06 x - 1.814e+06 x + 1

1.00000762939 683.000007528 44286.9999997 838861.000002 8138021.00001 51828151.0 247165843.0 954437177.0 3138105961.0 9071313571.0
[54, -833, 9541, -63125, 269491, -723550, 1172770, -1026551, 362885, 1]
    9       8        7             6             5             4             3             2
54 x - 833 x + 9541 x - 6.312e+04 x + 2.695e+05 x - 7.235e+05 x + 1.173e+06 x - 1.027e+06 x + 3.629e+05 x + 1

0.999998092651 682.99998807 44286.9999814 838860.999984 8138020.99998 51828151.0 247165843.0 954437177.0 3138105961.0 9090909091.0 23772343751.0
[1, 9, 37, 91, 148, 166, 130, 70, 25, 5, 1]
   10     9      8      7       6       5       4      3      2
1 x  + 9 x + 37 x + 91 x + 148 x + 166 x + 130 x + 70 x + 25 x + 5 x + 1

0.999999046326 682.999999004 44286.9999978 838860.999998 8138021.0 51828151.0 247165843.0 954437177.0 3138105961.0 9090909091.0 23775972551.0 57154490053.0
[1, 1365.0, 130812.99999999997, 3092452.9999999986, 32740951.000000015, 205015603.00000089, 898165576.99999714, 3093310441.0001335, 9071313571.000391, 23772343750.999367]
37076114526L
Time: CPU 0.07 s, Wall: 0.22 s

Soluzione: 37076114526
Tempo: 0.07 sec = 70 msec
----------------------------------------------------------------------------


============
Problema 102
============

Contenimento del triangolo

Tre punti distinti vengono tracciati a caso su un piano cartesiano, per il quale -1000 ≤ x, y ≤ 1000, in modo tale che si formi un triangolo.

Considera i seguenti due triangoli:

A (-340,495), B (-153, -910), C (835, -947)

X (-175,41), Y (-421, -714), Z (574, -645)

Si può verificare che il triangolo ABC contiene l'origine, mentre il triangolo XYZ no.

Utilizzando "triangles.txt", un file di testo di 27K contenente le coordinate di mille triangoli "casuali", trova il numero di triangoli di cui l'interno contiene l'origine.

NOTA: i primi due esempi nel file rappresentano i triangoli nell'esempio fornito sopra.
============================================================================

Il file "triangle.txt" è stato trasformato nel file "e102.lsp" che contiene la lista "triangle".

(load "e102.lsp")

(triangle 0)
;-> (-340 495 -153 -910 835 -947)
(triangle 1)
;-> (-175 41 -421 -714 574 -645)

Possiamo usare il teorema di Jordan (che vale anche per qualunque poligono):

1) Calcolare delle intersezioni tra la semiretta x = 0 per y < 0 che passa per 0,0 e i segmenti del triangolo.

2) Se le intersezioni sono pari, allora il punto è esterno.

3) Se le intersezioni sono dispari, allora il punto è interno.

(define (retta x1 y1 x2 y2)
  ; y = a*x + b
  (local (a b)
    ; rette parallele ?
    (if (zero? (sub x2 x1)) (setq x (add x 0.01)))
    (setq a (div (sub y2 y1) (sub x2 x1)))
    (setq b (sub y1 (mul a x1)))
    (list a b)))

(define (e102)
  (local (x0 y0 xmax xmin ymax ymin r1 a1 b1 r2 a2 b2 r3 a3 b3 conta dentro fuori)
    (setq x0 0 y0 0 dentro 0 fuori 0)
    (dolist (el triangle)
      (setq xmax (max (el 0) (el 2) (el 4)))
      (setq xmin (min (el 0) (el 2) (el 4)))
      (setq ymax (max (el 1) (el 3) (el 5)))
      (setq ymin (min (el 1) (el 3) (el 5)))
      ; Controllo se 0,0 è esterno al rettangolo di contenimento del triangolo
      (cond ((or (> x0 xmax) (< x0 xmin) (> y0 ymax) (< y0 ymin))
             (++ fuori))
            ; Calcolo dei parametri delle rette dei lati del triangolo
            (true
             (setq r1 (retta (el 0) (el 1) (el 2) (el 3)))
             (setq a1 (first r1)) (setq b1 (last r1))
             (setq r2 (retta (el 2) (el 3) (el 4) (el 5)))
             (setq a2 (first r2)) (setq b2 (last r2))
             (setq r3 (retta (el 4) (el 5) (el 0) (el 1)))
             (setq a3 (first r3)) (setq b3 (last r3))
             (setq conta 0)
             ; b1, b2, b3 sono le soluzioni delle intersezioni
             ; la soluzione deve essere compresa tra y1 e y2 del lato e deve essere minore di 0
             (if (and (>= b1 (min (el 1) (el 3))) (<= b1 (max (el 1) (el 3))) (< b1 0))
                 (++ conta))
             (if (and (>= b2 (min (el 3) (el 5))) (<= b2 (max (el 3) (el 5))) (< b2 0))
                 (++ conta))
             (if (and (>= b3 (min (el 5) (el 1))) (<= b3 (max (el 5) (el 1))) (< b3 0))
                 (++ conta))
             (if (odd? conta)
                 (++ dentro)
                 (++ fuori))
            )
      )
    )
    dentro))

(e102)
;-> 228

(time (e102))
;-> 2.022

Un altro algoritmo semplice e veloce, chiamato metodo baricentrico, consiste nel controllare su quale lato del semipiano creato dai lati si trova il punto.

(define (e102-2)
  (local (x1 y1 x2 y2 x3 y3 a b c out)
    (setq out 0)
    (dolist (el triangle)
      (setq x1 (el 0)) (setq y1 (el 1))
      (setq x2 (el 2)) (setq y2 (el 3))
      (setq x3 (el 4)) (setq y3 (el 5))
      (setq a (> (- (* x1 y2) (* y1 x2)) 0))
      (setq b (> (- (* x2 y3) (* y2 x3)) 0))
      (setq c (> (- (* x3 y1) (* y3 x1)) 0))
      (if (= a b c) (++ out))
    )
    out))

(e102-2)
;-> 228

(time (e102-2))
;-> 0.969
----------------------------------------------------------------------------


============
Problema 103
============

Somme speciali di sottoinsiemi: test

Sia S(A) la somma degli elementi dell'insieme A di dimensione n. Lo chiameremo insieme speciale di somma se per due sottoinsiemi disgiunti non vuoti, B e C, sono vere le seguenti proprietà:

  1. S(B) ≠ S(C), cioè, le somme dei sottoinsiemi non possono essere uguali.
  2. Se B contiene più elementi di C allora S(B) > S(C).

Se S(A) è minimizzato per un dato n, lo chiameremo un insieme di somma speciale ottimale. Di seguito sono riportati i primi cinque insiemi di somme speciali ottimali:

n = 1: {1}
n = 2: {1, 2}
n = 3: {2, 3, 4}
n = 4: {3, 5, 6, 7}
n = 5: {6, 9, 11, 12, 13}

Sembra che per un dato insieme ottimo, A = {a1, a2, ... , an}, il successivo insieme ottimo sia della forma B = {b, a1+b, a2+b, ... ,an+ b}, dove b è l'elemento "medio" nella riga precedente.

Applicando questa "regola" ci aspetteremmo che l'insieme ottimo per n = 6 sia A = {11, 17, 20, 22, 23, 24}, con S(A) = 117. Tuttavia, questo non è l'insieme ottimale, poiché abbiamo semplicemente applicato un algoritmo per fornire un insieme quasi ottimale. L'insieme ottimale per n = 6 è A = {11, 18, 19, 20, 22, 25}, con S(A) = 115 e la stringa dell'insieme corrispondente: 111819202225.

Dato che A è un insieme di somma speciale ottimale per n = 7, trova la sua stringa.

NOTA: questo problema è correlato al problema 103 e al problema 106.
============================================================================

Appplichiamo la regola di costruzione all'insieme ottimale per n = 6:

n = 6 ==> (11 18 19 20 22 25)

n = 7 ==> (20 11+20 18+20 19+20 22+20 25+20) = (20 31 38 39 40 42 45)

Che risulta essere l'insieme ottimale per n = 7:

(define (e105)
  (local (s6 idx b)
    (setq s6 '(11 18 19 20 22 25))
    (setq idx (/ (length s6) 2))
    (setq b (s6 idx))
    (join (map string (push b (map (curry + b) s6))))))

(e105)
;-> "20313839404245"

(time (e105))
;-> 0
----------------------------------------------------------------------------


============
Problema 104
============

Bordi Pandigitali dei Fibonacci

La sequenza di Fibonacci è definita dalla relazione di ricorrenza:

F(n) = F(n−1) + F(n−2), dove F(1) = 1 e F(2) = 1.
Si scopre che F(541), che contiene 113 cifre, è il primo numero di Fibonacci per il quale le ultime nove cifre sono 1-9 pandigitali (contengono tutte le cifre da 1 a 9, ma non necessariamente in ordine). E F(2749), che contiene 575 cifre, è il primo numero di Fibonacci per il quale le prime nove cifre sono 1-9 pandigitali.

Dato che F(k) è il primo numero di Fibonacci per il quale le prime nove cifre e le ultime nove cifre sono 1-9 pandigitali, trovare k.

Soluzione brute-force
Generiamo la sequenza dei numeri di Fibonacci finché non ne raggiungiamo uno in cui le ultime 9 cifre (che possono essere estratte con modulo) sono pandigitali. Se troviamo un numero candidato, prendiamo le prime 9 cifre e controlliamo quelle. Questo metodo richiede l'utilizzo dei big-integer.
============================================================================

Funzione per verificare se un numero di 9 cifre è pandigitale:

(define (pan9? n)
  (cond ((or (< n 123456789) (> n 987654321) (!= 0 (% n 9))) nil)
        (true
          (let (lst '(0 -1 -1 -1 -1 -1 -1 -1 -1 -1))
            (while (!= n 0)
              (setf (lst (% n 10)) 1)
              (setq n (/ n 10))
            )
            ;(println lst)
            (if (ref '-1 lst) nil true)))))

Funzione per il calcolo della potenza di due numeri big-integer:

(define (pow-i num power)
  (local (pot out)
    (if (zero? power)
        (setq out 1L)
        (begin
          (setq pot (pow-i num (/ power 2)))
          (if (odd? power)
              (setq out (* num pot pot))
              (setq out (* pot pot)))
        )
    )
    out))

(define (e104)
  (setq fb0 0L)
  (setq fb1 1L)
  (setq fb2 1L)
  (setq taglio 1000000000L)
  (setq n 2)
  (setq trovato nil)
  (until trovato
    (++ n)
    (setq fb0 (+ fb1 fb2))
    (setq coda (% fb0 taglio))
    (cond ((pan9? coda)
           (setq digits (length fb0))
           (cond ((> digits 9)
                  ;(setq testa (/ fb0 (** 10 (- digits 9))))
                  (setq testa (/ fb0 (pow-i 10L (- digits 9))))
                  (if (pan9? testa) (setq trovato true)))
           ))
    )
    (setq fb2 fb1)
    (setq fb1 fb0)
    ;(print n { })
  )
  ;(println fb0)
  (println n { } testa { } coda)
  (list n testa coda))

(time (e104))
;-> 329468 245681739L 352786941L
;-> 37977.562 (quasi 38 secondi)
----------------------------------------------------------------------------


============
Problema 105
============

Somme speciali di sottoinsiemi: test

Sia S(A) la somma degli elementi dell'insieme A di dimensione n. Lo chiameremo insieme speciale di somma se per due sottoinsiemi disgiunti non vuoti, B e C, sono vere le seguenti proprietà:

  1. S(B) ≠ S(C), cioè, le somme dei sottoinsiemi non possono essere uguali.
  2. Se B contiene più elementi di C allora S(B) > S(C).

Ad esempio, {81, 88, 75, 42, 87, 84, 86, 65} non è un insieme speciale di somma perché 65 + 87 + 88 = 75 + 81 + 84, mentre {157, 150, 164, 119, 79 , 159, 161, 139, 158} soddisfa entrambe le regole per tutte le possibili combinazioni di coppie di sottoinsiemi e S(A) = 1286.

Utilizzando il file "set.txt" (inserito direttamente di seguito), un file di testo 4K con cento set contenenti da sette a dodici elementi (i due esempi sopra riportati sono i primi due set nel file), identificare tutti gli insiemi di somme speciali, A1, A2, ..., Ak, e trovare il valore di S(A1) + S(A2) + ... + S(Ak).

NOTA: questo problema è correlato al problema 103 e al problema 106.
============================================================================

(define (setup)
  (setq sets '(
(81 88 75 42 87 84 86 65)
(157 150 164 119 79 159 161 139 158)
(673 465 569 603 629 592 584 300 601 599 600)
(90 85 83 84 65 87 76 46)
(165 168 169 190 162 85 176 167 127)
(224 275 278 249 277 279 289 295 139)
(354 370 362 384 359 324 360 180 350 270)
(599 595 557 298 448 596 577 667 597 588 602)
(175 199 137 88 187 173 168 171 174)
(93 187 196 144 185 178 186 202 182)
(157 155 81 158 119 176 152 167 159)
(184 165 159 166 163 167 174 124 83)
(1211 1212 1287 605 1208 1189 1060 1216 1243 1200 908 1210)
(339 299 153 305 282 304 313 306 302 228)
(94 104 63 112 80 84 93 96)
(41 88 82 85 61 74 83 81)
(90 67 84 83 82 97 86 41)
(299 303 151 301 291 302 307 377 333 280)
(55 40 48 44 25 42 41)
(1038 1188 1255 1184 594 890 1173 1151 1186 1203 1187 1195)
(76 132 133 144 135 99 128 154)
(77 46 108 81 85 84 93 83)
(624 596 391 605 529 610 607 568 604 603 453)
(83 167 166 189 163 174 160 165 133)
(308 281 389 292 346 303 302 304 300 173)
(593 1151 1187 1184 890 1040 1173 1186 1195 1255 1188 1203)
(68 46 64 33 60 58 65)
(65 43 88 87 86 99 93 90)
(83 78 107 48 84 87 96 85)
(1188 1173 1256 1038 1187 1151 890 1186 1184 1203 594 1195)
(302 324 280 296 294 160 367 298 264 299)
(521 760 682 687 646 664 342 698 692 686 672)
(56 95 86 97 96 89 108 120)
(344 356 262 343 340 382 337 175 361 330)
(47 44 42 27 41 40 37)
(139 155 161 158 118 166 154 156 78)
(118 157 164 158 161 79 139 150 159)
(299 292 371 150 300 301 281 303 306 262)
(85 77 86 84 44 88 91 67)
(88 85 84 44 65 91 76 86)
(138 141 127 96 136 154 135 76)
(292 308 302 346 300 324 304 305 238 166)
(354 342 341 257 348 343 345 321 170 301)
(84 178 168 167 131 170 193 166 162)
(686 701 706 673 694 687 652 343 683 606 518)
(295 293 301 367 296 279 297 263 323 159)
(1038 1184 593 890 1188 1173 1187 1186 1195 1150 1203 1255)
(343 364 388 402 191 383 382 385 288 374)
(1187 1036 1183 591 1184 1175 888 1197 1182 1219 1115 1167)
(151 291 307 303 345 238 299 323 301 302)
(140 151 143 138 99 69 131 137)
(29 44 42 59 41 36 40)
(348 329 343 344 338 315 169 359 375 271)
(48 39 34 37 50 40 41)
(593 445 595 558 662 602 591 297 610 580 594)
(686 651 681 342 541 687 691 707 604 675 699)
(180 99 189 166 194 188 144 187 199)
(321 349 335 343 377 176 265 356 344 332)
(1151 1255 1195 1173 1184 1186 1188 1187 1203 593 1038 891)
(90 88 100 83 62 113 80 89)
(308 303 238 300 151 304 324 293 346 302)
(59 38 50 41 42 35 40)
(352 366 174 355 344 265 343 310 338 331)
(91 89 93 90 117 85 60 106)
(146 186 166 175 202 92 184 183 189)
(82 67 96 44 80 79 88 76)
(54 50 58 66 31 61 64)
(343 266 344 172 308 336 364 350 359 333)
(88 49 87 82 90 98 86 115)
(20 47 49 51 54 48 40)
(159 79 177 158 157 152 155 167 118)
(1219 1183 1182 1115 1035 1186 591 1197 1167 887 1184 1175)
(611 518 693 343 704 667 686 682 677 687 725)
(607 599 634 305 677 604 603 580 452 605 591)
(682 686 635 675 692 730 687 342 517 658 695)
(662 296 573 598 592 584 553 593 595 443 591)
(180 185 186 199 187 210 93 177 149)
(197 136 179 185 156 182 180 178 99)
(271 298 218 279 285 282 280 238 140)
(1187 1151 890 593 1194 1188 1184 1173 1038 1186 1255 1203)
(169 161 177 192 130 165 84 167 168)
(50 42 43 41 66 39 36)
(590 669 604 579 448 599 560 299 601 597 598)
(174 191 206 179 184 142 177 180 90)
(298 299 297 306 164 285 374 269 329 295)
(181 172 162 138 170 195 86 169 168)
(1184 1197 591 1182 1186 889 1167 1219 1183 1033 1115 1175)
(644 695 691 679 667 687 340 681 770 686 517)
(606 524 592 576 628 593 591 584 296 444 595)
(94 127 154 138 135 74 136 141)
(179 168 172 178 177 89 198 186 137)
(302 299 291 300 298 149 260 305 280 370)
(678 517 670 686 682 768 687 648 342 692 702)
(302 290 304 376 333 303 306 298 279 153)
(95 102 109 54 96 75 85 97)
(150 154 146 78 152 151 162 173 119)
(150 143 157 152 184 112 154 151 132)
(36 41 54 40 25 44 42)
(37 48 34 59 39 41 40)
(681 603 638 611 584 303 454 607 606 605 596))))

(define (e105)
  (local (out stop somme somme-minime somme-massime contatore)
    (setup)
    (setq out 0)
    (dolist (s sets)
      (if (speciale? s) (setq out (+ out (apply + s))))
    )
    out))

(define (speciale? s)
  (setq stop nil)
  (setq somme '())
  (setq somme-massime (array (+ (length s) 1) '(nil)))
  (setq somme-minime (array (+ (length s) 1) '(nil)))
  (cerca-subset 0 0 0)
  (if (= (length somme) (pow 2 (length s)))
      (for (i 0 (- (length s) 1) 1 stop)
        (if (>= (somme-massime i) (somme-minime (+ i 1)))
            (setq stop true)
        )
      )
      ;else
      (setq stop true)
  )
  (not stop))

(define (cerca-subset k somma contatore)
  (cond ((= k (length s))
          (if (not (find somma somme))
              (push somma somme -1)
          )
          (if (or (= (somme-minime contatore) nil)
                  (< somma (somme-minime contatore)))
              (setq (somme-minime contatore) somma)
          )
          (if (or (= (somme-massime contatore) nil)
                  (> somma (somme-massime contatore)))
              (setq (somme-massime contatore) somma)
          ))
        (true
          (cerca-subset (+ k 1) somma contatore)
          (cerca-subset (+ k 1) (+ somma (s k)) (+ contatore 1)))))

(e105)
;-> 73702

(time (e105))
;-> 864.226
----------------------------------------------------------------------------


============
Problema 108
============

Reciproci diofantei I

Nella seguente equazione x, y e n sono numeri interi positivi.

   1     1     1
  --- + --- = ---
   x     y     n

Per n = 4 esistono esattamente tre soluzioni distinte:

   1     1      1
  --- + ---- = ---
   5     20     4

   1     1      1
  --- + ---- = ---
   6     12     4

   1     1     1
  --- + --- = ---
   8     8     4

Qual è il valore minimo di n per il quale il numero di soluzioni distinte supera mille?

NOTA: questo problema è una versione più semplice del problema 110. Si consiglia vivamente di risolverlo prima.
============================================================================

1/x + 1/y = 1/n è equivalente a n*(x + y) = x*y.

Osservando che x e y devono essere maggiori di n, sostituiamo:

  x = n + a, y = n + b

ottenendo:

  n^2 = a * b

Questo significa che qualsiasi coppia di divisori di n^2 darà una soluzione.

La metà di queste coppie sono uniche. Poiché n^2 è un quadrato, ha un numero dispari di divisori, il che significa che non dividiamo la soluzione 1/2n + 1/2n = 1/n per 2. Essendo d(n) il numero di divisori di n, vogliamo trovare n in modo che

   (divisori(n^2) + 1)/2 > 1000

(define (divisors-count num)
"Count the divisors of an integer number"
  (if (= num 1)
      1
      (let (lst (factor-group num))
        (apply * (map (fn(x) (+ 1 (last x))) lst)))))

(define (e108)
  (local (found d)
    (setq found nil)
    (setq n 10)
    (until found
      (++ n)
      (setq d (/ (+ (divisors-count (* n n)) 1) 2))
      (if (> d 1000)
          (setq found true))
      ;(println n { } f { } num-sol) (read-line)
    )
    (list n d)))

(e108)
;-> (180180 1013)

(time (e108))
;-> 7520.704

Utilizziamo un'altro metodo.
Se la fattorizzazione di n vale n = p1^e1*p2^e2*...*pk^ek allora il numero di soluzioni sono:

   (2*e1+1)*(2*e2+1)...(2*ek+1) + 1
  ----------------------------------
                2

(define (factor-group num)
"Factorize an integer number"
  (if (< num 2) nil
      (letn ((out '()) (lst (factor num)) (cur-val (first lst)) (cur-count 0))
        (dolist (el lst)
          (if (= el cur-val) (++ cur-count)
              (begin
                (push (list cur-val cur-count) out -1)
                (setq cur-count 1 cur-val el))))
        (push (list cur-val cur-count) out -1))))

(factor-group 104)
;-> (2 3 (13 1))

(define (e108-2)
  (local (found f)
    (setq found nil)
    (setq n 10)
    (until found
      (++ n)
      (setq f (factor-group n))
      (setq num-sol (+ (/ (apply * (map (fn(x) (+ (* 2 (last x)) 1)) f)) 2) 1))
      (if (> num-sol 1000) (setq found true))
    )
    (list n f num-sol)))

(e108-2)
;-> (180180 ((2 2) (3 2) (5 1) (7 1) (11 1) (13 1)) 1013)

(time (e108))
;-> 331.92
----------------------------------------------------------------------------


============
Problema 109
============

Freccette

Nel gioco delle freccette un giocatore lancia tre freccette (dardi) su un bersaglio che è diviso in venti sezioni di uguali dimensioni numerate da uno a venti.

Vedi immagine "e109.png" nella cartella "data".

Il punteggio di un dardo è determinato dal numero della regione in cui il dardo atterra. Un dardo che atterra al di fuori dell'anello esterno rosso/verde ha un punteggio zero. Le regioni nere e crema all'interno di questo anello rappresentano punteggi singoli. Tuttavia, l'anello esterno rosso/verde e l'anello medio ottengono rispettivamente punteggi doppi e tripli.

Al centro del tabellone ci sono due cerchi concentrici chiamati "regione del toro", o "occhio del toro". Il toro esterno vale 25 punti e il toro interno vale doppio, cioè 50 punti.

Ci sono molte varianti nelle regole, ma nel gioco più popolare i giocatori inizieranno con un punteggio di 301 o 501 e il primo giocatore che riduce il proprio totale parziale a zero è il vincitore. Tuttavia, è normale giocare un sistema di "raddoppio", il che significa che il giocatore deve ottenere un doppio (incluso il doppio occhio di bue al centro del tabellone) sulla sua freccetta finale per vincere. Qualsiasi altra freccetta che ridurrebbe il totale parziale a 1 o minore significa che il punteggio per quella serie di tre freccette è "sballato".

Quando un giocatore è in grado di terminare il punteggio corrente, viene chiamato "checkout" e il checkout più alto è 170: T20 T20 D25 (due tripli 20 e un doppio toro).

Esistono esattamente undici modi distinti per effettuare il checkout con un punteggio di 6:
     
  D3
  D1 D2
  S2 D2
  D2 D1
  S4 D1
  S1 S1 D2
  S1 T1 D1
  S1 S3 D1
  D1 D1 D1
  D1 S2 D1
  S2 S2 D1

Notare che D1 D2 è considerato diverso da D2 D1 poiché finiscono su doppi diversi. Tuttavia, la combinazione S1 T1 D1 è considerata uguale a T1 S1 D1.

Inoltre non includeremo gli errori nel considerare le combinazioni: ad esempio, D3 è uguale a 0 D3 e 0 0 D3.

Incredibilmente ci sono 42336 modi distinti per effettuare il check-out in totale.

In quanti modi distinti può effettuare il checkout un giocatore con un punteggio inferiore a 100?
============================================================================

(define (e109)
  (local (score lst limite out)
    (setq limite 100)
    (setq lst '())
    ; punteggi doppi
    (for (i 1 20) (push (* 2 i) lst -1))
    (push 50 lst -1)
    ; punteggi singoli
    (for (i 1 20) (push i lst -1))
    (push 25 lst -1)
    ; punteggi tripli
    (for (i 1 20) (push (* 3 i) lst -1))
    ;(println lst)
    ; brute force 
    (setq out 0)
    (for (i 0 20)
      (setq score (lst i))
      (if (< score limite) (++ out))
      (for (j 0 61)
        (setq score (+ score (lst j)))
        (if (< score limite) (++ out))
        (for (k j 61)
          (setq score (+ score (lst k)))
          (if (< score limite) (++ out))
          (setq score (- score (lst k)))
        )
        (setq score (- score (lst j)))
      )
    )
    out))

(e109)
;-> 38182

(time (e109))
;-> 8.977
----------------------------------------------------------------------------


============
Problema 110
============

Reciproci diofantei II

Nella seguente equazione x, y e n sono numeri interi positivi.

   1     1     1
  --- + --- = ---
   x     y     n

Si può verificare che quando n = 1260 ci sono 113 soluzioni distinte e questo è il valore minimo di n per il quale il numero totale di soluzioni distinte supera cento.

Qual è il valore minimo di n per il quale il numero di soluzioni distinte supera i quattro milioni?

NOTA: questo problema è una versione molto più difficile del problema 108 e poiché è ben oltre i limiti di un approccio di forza bruta, richiede un'implementazione intelligente.
============================================================================

Usiamo la stessa logica del problema 108, ma invece di incrementare n, generiamo n dalla sua fattorizzazione in numeri primi.
Abbiamo bisogno al massimo di 14 primi distinti, perché un numero con 15 primi distinti avrebbe

         ((2*1 + 1)^15 + 1) / 2 = 7174454 > 4000000

soluzioni. Il quattordicesimo numero primo è 43.

(setq p '(2 3 5 7 11 13 17 19 23 29 31 37 41 43))

Se la fattorizzazione di n vale n = p1^e1*p2^e2*...*pk^ek allora il numero di soluzioni vale:

   (2*e1+1)*(2*e2+1)...(2*ek+1) + 1
  ----------------------------------
                2

(define (factor-group num)
"Factorize an integer number"
  (if (< num 2) nil
      (letn ((out '()) (lst (factor num)) (cur-val (first lst)) (cur-count 0))
        (dolist (el lst)
          (if (= el cur-val) (++ cur-count)
              (begin
                (push (list cur-val cur-count) out -1)
                (setq cur-count 1 cur-val el))))
        (push (list cur-val cur-count) out -1))))

Scriviamo una funzione cha calcola il numero di soluzioni del numero n:

(define (num-sols n)
  (let (f (factor-group n))
    (/ (+ (apply * (map (fn(x) (+ (* 2 (last x)) 1)) f)) 1) 2)))

(num-sols 1260)
;-> 113

In realtà a noi interessa generare gli esponenti del numero n. Per fare questo utilizziamo le combinazioni con ripetizione.

(define (comb-rep k lst)
"Generates all combinations of k elements with repetition from a list of items"
  (cond ((zero? k 0) '(()))
        ((null? lst) '())
        (true
         (append (map (lambda (x) (cons (first lst) x))
                      (comb-rep (- k 1) lst))
                 (comb-rep k (rest lst))))))

(comb-rep 4 '(0 1 2))
;-> ((0 0 0 0) (0 0 0 1) (0 0 0 2) (0 0 1 1) (0 0 1 2)
;->  (0 0 2 2) (0 1 1 1) (0 1 1 2) (0 1 2 2) (0 2 2 2)
;->  (1 1 1 1) (1 1 1 2) (1 1 2 2) (1 2 2 2) (2 2 2 2))

Supponiamo che gli esponenti vanno da 0 a 3 e li generiamo con la seguente chiamata:

(reverse (comb-rep 14 '(3 2 1 0)))
;-> ((0 0 0 0 0 0 0 0 0 0 0 0 0 0)
;->  (1 0 0 0 0 0 0 0 0 0 0 0 0 0)
;->  (1 1 0 0 0 0 0 0 0 0 0 0 0 0)
;->  (1 1 1 0 0 0 0 0 0 0 0 0 0 0)
;->  (1 1 1 1 0 0 0 0 0 0 0 0 0 0)
;->  (1 1 1 1 1 0 0 0 0 0 0 0 0 0)
;->  (1 1 1 1 1 1 0 0 0 0 0 0 0 0)
;->  (1 1 1 1 1 1 1 0 0 0 0 0 0 0)
;->  (1 1 1 1 1 1 1 1 0 0 0 0 0 0)
;->  (1 1 1 1 1 1 1 1 1 0 0 0 0 0)
;->  (1 1 1 1 1 1 1 1 1 1 0 0 0 0)
;->  (1 1 1 1 1 1 1 1 1 1 1 0 0 0)
;->  (1 1 1 1 1 1 1 1 1 1 1 1 0 0)
;->  (1 1 1 1 1 1 1 1 1 1 1 1 1 0)
;->  (1 1 1 1 1 1 1 1 1 1 1 1 1 1)
;->  (2 0 0 0 0 0 0 0 0 0 0 0 0 0)
;->  (2 1 0 0 0 0 0 0 0 0 0 0 0 0)
;->  (2 1 1 0 0 0 0 0 0 0 0 0 0 0)
;-> ...
;->  (3 3 3 3 3 3 3 3 3 3 3 3 1 1)
;->  (3 3 3 3 3 3 3 3 3 3 3 3 2 0)
;->  (3 3 3 3 3 3 3 3 3 3 3 3 2 1)
;->  (3 3 3 3 3 3 3 3 3 3 3 3 2 2)
;->  (3 3 3 3 3 3 3 3 3 3 3 3 3 0)
;->  (3 3 3 3 3 3 3 3 3 3 3 3 3 1)
;->  (3 3 3 3 3 3 3 3 3 3 3 3 3 2)
;->  (3 3 3 3 3 3 3 3 3 3 3 3 3 3))

Ci sono 680 numeri da verificare:

(length (reverse (comb-rep 14 '(3 2 1 0))))
;-> 680

Scriviamo la funzione che dalla lista degli esponenti calcola il numero:

(define (** num power)
"Calculates the integer power of an integer"
  (if (zero? power) 1
      (let (out 1L)
        (dotimes (i power)
          (setq out (* out num))))))

(define (number-e lst)
  (setq p '(2L 3L 5L 7L 11L 13L 17L 19L 23L 29L 31L 37L 41L 43L))
  (apply * (map ** p lst)))

(number-e '(1 1 0 0 0 0 0 0 0 0 0 0 0 0 0))
;-> 6L
(number-e '(2 1 0 0 0 0 0 0 0 0 0 0 0 0 0))
;-> 12L

Abbiamo bisogno dei big-integer perchè risulta:

(number-e '(3 3 3 3 3 3 3 3 3 3 3 3 3 3))
;-> 2239227690108088991425163984029948967596509027000L

che è più grande dell'intero massimo degli int64 che vale 9223372036854775807.

Prima calcoliamo quale di queste 680 liste di esponenti genera un numero di soluzioni maggiore di 4 milioni. Poi vediamo quale di queste liste genera il numero minore.

(define (e110)
  (local (ex sol4 sol num minimo)
    (setq ex (reverse (comb-rep 14 '(3 2 1 0))))
    (setq sol4 '())
    ; cerca le liste di esponenti che generano più
    ; di 4 milioni di soluzioni
    (dolist (e ex)
      (setq sol (/ (+ (apply * (map (fn(x) (+ (* 2 x) 1)) e)) 1) 2))
      (if (> sol 4e6) (push e sol4 -1))
    )
    ; cerca il numero minimo della lista delle soluzioni
    (setq minimo 2239227690108088991425163984029948967596509027000L)
    (dolist (s sol4)
      (setq num (number-e s))
      (if (< num minimo) (setq minimo num))
    )
    minimo))

(e110)
;-> 9350130049860600L

Verifichiamo che il numero di soluzioni è superiore a 4 milioni.

(num-sols 9350130049860600L)
;-> 4018613

(time (e110))
;-> 15.587
----------------------------------------------------------------------------


============
Problema 112
============

Numeri bouncy

Partendo da sinistra a destra, se nessuna cifra viene superata dalla cifra alla sua sinistra, viene chiamato un numero crescente, ad esempio 134468.

Allo stesso modo, se nessuna cifra viene superata dalla cifra alla sua destra, viene chiamato un numero decrescente, ad esempio 66420.

Chiameremo un numero intero positivo che non aumenta né diminuisce un numero "bouncy" (rimbalzante), ad esempio 155349.

Chiaramente non possono esserci numeri rimbalzanti al di sotto di cento, ma poco più della metà dei numeri al di sotto di mille (525) sono rimbalzanti. In effetti, il numero minimo per il quale la percentuale di numeri rimbalzanti raggiunge prima il 50% è 538.

Sorprendentemente, i numeri rimbalzanti diventano sempre più comuni e quando raggiungiamo 21780 la proporzione di numeri rimbalzanti è pari al 90%.

Trova il numero minimo per il quale la proporzione di numeri rimbalzanti è esattamente del 99%.
============================================================================

Soluzione brute-force

Primo metodo per vedere se un numero è bouncy:

(define (bouncy? num)
  (local (incr decr ultimo prossimo continua)
    (setq continua true)
    (setq incr nil decr nil)
    (setq ultimo (% num 10))
    (setq num (/ num 10))
    (while (and (> num 0) continua)
      (setq prossimo (% num 10))
      (setq num (/ num 10))
      (if (< prossimo ultimo)
          (setq incr true)
          (if (> prossimo ultimo)
              (setq decr true)))
      (setq ultimo prossimo)
      (if (and decr incr) (setq continua nil))
    )
    (and decr incr)))

(define (e112)
  (let ((bouncy 0) (i 99))
    (while (< (mul bouncy 100) (mul i 99))
      (++ i)
      (if (bouncy? i) (++ bouncy))
    )
    i))

(time (println (e112)))
;-> 1587000
;-> 1731.366

Secondo metodo per vedere se un numero è bouncy:

(define (int-lst num)
  (let (out '())
    (while (!= num 0)
      (push (% num 10) out)
      (setq num (/ num 10))) out))

(define (bouncy? num)
  (let (digits (int-lst num))
    (not (or (apply >= digits) (apply <= digits)))))

(time (println (e112)))
> (time (println (e112)))
;-> 1587000
;-> 2014.022
----------------------------------------------------------------------------


============
Problema 113
============

Numeri Non-bouncy

Lavorando da sinistra a destra se nessuna cifra viene superata dalla cifra alla sua sinistra si chiama numero crescente, per esempio, 134468.

Allo stesso modo se nessuna cifra viene superata dalla cifra alla sua destra viene chiamata numero decrescente, ad esempio, 66420.

Chiameremo un numero intero positivo che non è né crescente né decrescente un numero "rimbalzante" (bouncy), per esempio, 155349.

All'aumentare di n, la proporzione di numeri rimbalzanti al di sotto di n aumenta in modo tale che ci siano solo 12951 numeri al di sotto di un milione che non sono rimbalzanti e solo 277032 numeri non rimbalzanti al di sotto di 10^10.

Quanti numeri sotto un googol (10^100) non sono rimbalzanti?
============================================================================

(define (binom num k)
"Calculates the binomial coefficient (n k) = n!/(k!*(n - k)!) (combinations of k elements without repetition from n elements)"
  (cond ((> k num) 0)
        ((zero? k) 1)
        (true
          (let (r 1L)
            (for (d 1 k)
              (setq r (/ (* r num) d))
              (-- num)
            )
          r))))

(binom 21 6)
;-> 54264L

Calcola quanti sono i numeri non-bouncy con n cifre:

(define (non-bouncy-n-digits num-digit)
  (add (binom (+ num-digit 8) num-digit)
       (binom (+ num-digit 9) num-digit)
       (- 10)))

(non-bouncy-n-digits 1)
;-> 9
(non-bouncy-n-digits 2)
;-> 90
(non-bouncy-n-digits 10)
;-> 136126

Calcola quanti sono i numeri non-bouncy fino a un numero di n cifre:

(define (non-bouncy-n-digits-all num-digit)
  (let (out 0)
    (for (i 1 num-digit)
      (setq out (+ out (non-bouncy-n-digits i)))
    )
    out))

(non-bouncy-n-digits-all 1)
;-> 9
(non-bouncy-n-digits-all 2)
;-> 99
(non-bouncy-n-digits-all 10)
;-> 277032

(define (e113 n)
  (non-bouncy-n-digits-all n))

(e113 100)
;-> 51161058134250

(time (e113 100))
;-> 7.978
----------------------------------------------------------------------------


============
Problema 114
============

Conteggio delle combinazioni di blocchi I

Una riga di sette unità di lunghezza ha blocchi rossi con una lunghezza minima di tre unità posizionate su di essa, in modo tale che due blocchi rossi qualsiasi (che possono avere lunghezze diverse) siano separati da almeno un quadrato grigio. Ci sono esattamente diciassette modi per farlo.

  GGGGGGG  RRRGGGG
  GRRRGGG  GGRRRGG
  GGGRRRG  GGGGRRR
  RRRGRRR  RRRRGGG
  GRRRRGG  GGRRRRG
  GGGRRRR  RRRRRGG
  GRRRRRG  GGRRRRR
  RRRRRRG  GRRRRRR
  RRRRRRR

In quanti modi si può riempire una riga lunga cinquanta unità?

NOTA: Sebbene l'esempio sopra non si presti alla possibilità, in generale è consentito mescolare le dimensioni dei blocchi. Ad esempio, su una riga di otto unità di lunghezza è possibile utilizzare il rosso (3), il grigio (1) e il rosso (4).
============================================================================

Indichiamo con dp(i) il numero di combinazioni di i unità che iniziano con un blocco rosso, dove i>=3. Quindi considerando la posizione di partenza del secondo blocco rosso (se esiste) abbiamo:

                   i-2
  dp(i) = (i - 2) + ∑ [(j - 4) * dp(i-j+1)]
                   j=5

Il numero totale di combinazioni di i unità vale:

      i
  1 + ∑ [dp(j)]
     j=3

(define (e114 num)
  (let (dp (array (+ num 1) '(0)))
    (for (i 3 num)
      (setf (dp i) (- i 2))
      (if (> i 6)
          (for (j 5 (- i 2))
            (setf (dp i) (+ (dp i) (* (- j 4) (dp (+ i (- j) 1)))))
          )
      )
    )
    (+ 1 (apply + (slice dp 2)))))

(e114 7)
;-> 17

(e114 50)
;-> 16475640049

(time (e114 50))
;-> 0
----------------------------------------------------------------------------


============
Problema 115
============

Conteggio delle combinazioni di blocchi II

NOTA: questa è una versione più difficile del problema 114.

Una riga che misura n unità di lunghezza ha blocchi rossi con una lunghezza minima di m unità posizionati su di essa, in modo tale che due blocchi rossi qualsiasi (che possono avere lunghezze diverse) siano separati da almeno un quadrato nero.

La funzione fill-count, F(m, n), rappresenta il numero di modi in cui una riga può essere riempita.

Ad esempio, F(3, 29) = 673135 e F(3, 30) = 1089155.

Cioè, per m = 3, si può vedere che n = 30 è il valore più piccolo per il quale la funzione fill-count supera prima il milione.

Allo stesso modo, per m = 10, si può verificare che F(10, 56) = 880711 e F(10, 57) = 1148904, quindi n = 57 è il valore minimo per il quale la funzione fill-count supera per primo un milione.

Per m = 50, trova il valore minimo di n per il quale la funzione fill-count supera prima un milione.
============================================================================

dp(m,i) indica il numero di combinazioni di i unità che iniziano con un blocco rosso, dove i>=m. Quindi considerando la posizione di partenza del secondo blocco rosso (se esiste) abbiamo:

                        i-m+1
  dp(m,i) = (i - m + 1) + ∑ [(j-m-1) * dp(m,i-j+1),
                         m+2

e il numero totale di combinazioni di n unità, indicato con F(m,i) nel problema, vale:

      i
  1 + ∑ [f(m,j)]
     j=m

(define (e115 num)
  (local (dp i)
    (setq dp (array 1001 '(0)))
    (setq i (- num 1))
    (setq conta 1)
    (while (< conta 1e6)
      (++ i)
      (setf (dp i) (+ i 1 (- num)))
      (if (>= (+ i 1 (- num))(+ num 2))
        (for (j (+ num 2) (+ i 1 (- num)))
          (setf (dp i) (+ (dp i) (* (- j num 1) (dp (+ i 1 (- j))))))
        )
      )
      (setq conta (+ conta (dp i)))
    )
    i))

(e115 50)
;-> 168

(time (e115 50))
;-> 2
----------------------------------------------------------------------------


============
Problema 119
============

Somma delle potenze delle cifre

Il numero 512 è interessante perché è uguale alla somma delle sue cifre elevate a una certa potenza: 5 + 1 + 2 = 8 e 8^3 = 512. Un altro esempio di numero con questa proprietà è 614656 = 28^4.

Definiremo a(n) come l'n-esimo termine di questa sequenza e imponiamo il vincolo che un numero deve contenere almeno due cifre per avere una somma.

Ti viene dato che a(2) = 512 e a(10) = 614656.

Trova a30.
============================================================================

(define (digit-sum num)
"Calculates the sum of the digits of an integer"
  (let (out 0)
    (while (!= num 0)
      (setq out (+ out (% num 10)))
      (setq num (/ num 10))
    )
    out))

(digit-sum 1352)
;-> 11

(define (e119 n)
  (local (out val)
    (setq out '())
    (for (digit 2 99)
      (for (power 2 99)
        (setq val (int (pow digit power)))
        (if (= digit (digit-sum val))
            (push val out -1)
        )
      )
    )
    ((sort out) (- n 1))))

(e119 2)
;-> 512
(e119 10)
;-> 614656
(e119 30)
;-> 248155780267521

(time (e119 30))
;-> 25.96
----------------------------------------------------------------------------


============
Problema 120
============

Resti dei quadrati

Sia r il resto quando (a−1)^n + (a+1)^n è diviso per a^2.

Ad esempio, se a = 7 e n = 3, allora r = 42: 6^3 + 8^3 = 728 ≡ 42 mod 49. E poiché n varia, anche r varia, ma per a = 7 risulta che rmax = 42.

Per 3 ≤ a ≤ 1000, trova ∑ rmax.
============================================================================

Soluzione 1:
Matematicamente dal teorema del binomiale risulta:

                      n
  (a−1)^n + (a+1)^n = ∑ (binom n i)*a^i*((-1)^n + 1)
                     i=0

Espandendo i termini, otteniamo 2 se n è pari e 2*a*n se n è dispari.

Per n pari:

  (a-1)^n + (a+1)^n (mod a^2) ≡ 2

Per n dispari:

  (a-1)^n + (a+1)^n (mod a^2) ≡ 2*n*a

La soluzione consiste nel trovare n in modo che 2*n*a sia il più vicino possibile ad a^2, ma non lo superi. Quindi consideriamo la disuguaglianza 2*n*a < a^2, o 2n < a.
Se a è pari, il valore di n che soddisfa la disuguaglianza è n = a/2 – 1, e il resto corrispondente è a^2 – 2a.
Se a è dispari, il valore di n che soddisfa la disuguaglianza è n = (a-1)/2, e il resto corrispondente è a^2 – a.
Per massimizzare il valore deve risultare, 2*a*n < a*a => n <= (a - 1)/2 (divisione intera)

(define (e120 n)
  (let (somma 0)
    (for (a 3 n)
      (setq somma (+ somma (* 2 a (/ (- a 1) 2))))
    )
    somma))

(euler120 1000)
;-> 333082500

Soluzione 2:
L'espansione diretta della formula porta al seguente risultato:

  1000            999
    ∑(a^2 - 2*a) + ∑(a^2 - 2*a) =
  a=4(pari)      a=3(dispari)

  1000     1000   1000
=   ∑(a^2) - ∑(a) - ∑(a) =
   a=3      a=3    a=4(pari)

  1000     1000   1000
=   ∑(a^2) - ∑(a) - ∑(a) =
   a=3      a=3    a=4(pari)

   1000          1000      500
=   (∑(a^2)-1+4) - ∑(a) - 2*∑(a) =
    i=1           i=1      i=2

= ((1000*1001*2001)/6 + 5) - 998*1003/2 - 2*(499*502/2)

(define (e120-2 n)
  (-
    (- (/ (* n (+ n 1) (+ (* 2 n) 1)) 6) 5)
    (/ (* (- n 2) (+ n 3)) 2)
    (* (- (/ n 2) 1) (+ (/ n 2) 2))))

(e120-2 1000)
;-> 333082500

(time (e120 1000))
;-> 0
(time (e120-2 1000))
;-> 0
----------------------------------------------------------------------------


============
Problema 121
============

Montepremi del gioco dei dischi

Una borsa contiene un disco rosso e un disco blu. In un gioco d'azzardo un giocatore prende un disco a caso e ne viene annotato il colore. Dopo ogni turno il disco viene rimesso nella borsa, viene aggiunto un disco rosso extra e un altro disco viene preso a caso.

Il giocatore paga £1 per giocare e vince se ha preso più dischi blu che rossi alla fine del gioco.

Se il gioco viene giocato per quattro turni, la probabilità che un giocatore vinca è esattamente 11/120, quindi il montepremi massimo che il banchiere dovrebbe destinare per vincere in questo gioco sarebbe £10 prima che si aspetti una perdita. Nota che qualsiasi vincita sarà un numero intero di sterline e include anche l'originale £1 pagato per giocare, quindi nell'esempio fornito il giocatore vince effettivamente £9.

Trova il montepremi massimo che dovrebbe essere assegnato a un singolo gioco in cui vengono giocati quindici turni.
============================================================================

(define (e121)
  (local (limite evento positivi totale)
    (setq limite 15)
    (setq evento (array (+ limite 1) '(0)))
    (setf (evento limite) 1)
    (setf (evento (- limite 1)) 1)
    (for (i 2 limite)
      (for (j 0 (- (length evento) 2))
        (setf (evento j) (evento (+ j 1)))
      )
      (setf (evento limite) 0)
      (for (j (- (length evento) 1) 1)
        (setf (evento j) (+ (evento j) (* (evento (- j 1)) i)))
      )
    )
    (setq positivi 0)
    (for (i 0 (/ limite 2))
      (setq positivi (+ positivi (evento i)))
    )
    (setq totale 1)
    (for (i 2 (+ limite 1))
      (setq totale (* totale i))
    )
    (println positivi { } totale)
    (list positivi totale (/ totale positivi))))

(e121)
;-> (9219406943 20922789888000 2269)

(time (e121))
;-> 0.998
----------------------------------------------------------------------------


============
Problema 122
============

Esponenziazione efficiente

Il modo più ingenuo di calcolare n^15 richiede quattordici moltiplicazioni:

n × n × ... × n = n^15

Ma usando un metodo "binario" puoi calcolarlo in sei moltiplicazioni:

  n × n = n^2
  n^2 × n^2 = n^4
  n^4 × n^4 = n^8
  n^8 × n^4 = n^12
  n^12 × n^2 = n^14
  n^14 × n = n^15

Tuttavia è ancora possibile calcolarlo in sole cinque moltiplicazioni:

  n × n = n^2
  n^2 × n = n^3
  n^3 × n^3 = n^6
  n^6 × n^6 = n^12
  n^12 × n^3 = n^15

Definiremo m(k) come il numero minimo di moltiplicazioni per calcolare nk. Ad esempio m(15) = 5.

Per 1 ≤ k ≤ 200, trova ∑m(k).
============================================================================

https://en.wikipedia.org/wiki/Addition_chain
https://en.wikipedia.org/wiki/Addition-chain_exponentiation

(define (e122)
  (local (limite costo percorso res k)
    (setq limite 200)
    (setq costo (array (+ limite 1) '(999999999)))
    (setq percorso (array (+ limite 1) '(0)))
    (setq res 0)
    (backtrack 1 0)
    (for (i 1 limite)
      (setq res (+ res (costo i)))
    )
    res))

(define (backtrack potenza profondita)
  (cond ((or (> potenza limite) (> profondita (costo potenza)))
         nil)
        (true
         ;(println profondita) (read-line)
         (setf (costo potenza) profondita)
         (setf (percorso profondita) potenza)
         (for (k profondita 0 -1)
           (if (>= k 0)
             (backtrack (+ potenza (percorso k)) (+ profondita 1))
           )
         ))))

(e122)
;-> 1582

(time (e122))
;-> 138.074
----------------------------------------------------------------------------


============
Problema 123
============

Resti di quadrati di primi

Sia p(n) l'n-esimo primo: 2, 3, 5, 7, 11, ..., e sia r il resto quando (p(n)−1)*n + (p(n)+1)*n è diviso per p(n)^2.

Ad esempio, quando n = 3, p(3) = 5 e 4^3 + 6^3 = 280 ≡ 5 mod 25.

Il valore minimo di n per il quale il resto prima supera 10^9 è 7037.

Trova il valore minimo di n per il quale il resto prima supera 10^10.
============================================================================

Nel problema 120, abbiamo visto che il resto r per questa equazione è dato da:

  r = 2*p(n)*n per n dispari
  r = 2        per n pari

Quindi dobbiamo cercare in sequenza, solo per n dispari, un primo che rende r superiore al limite (10^10).
Invece di creare una lista di primi (di cui non conosciamo quanto debba essere lunga) utilizziamo un generatore di primi.

Funzione che verifica se un numero è primo:

(define (primo:isprime? n)
  (if (< n 2) nil
    (= 1 (length (factor n)))))

Funzione che inizializza il generatore di numeri primi:

(define (primo:start x)
  (setq primo:val x))

Funzione che stampa il numero primo corrente:

(define (primo:print-val) primo:val)

Infine scriviamo la funzione/funtore del contesto "primo" (il parametro "dir" può assumere true o nil e specifica se generare il  primo successivo oppure il primo precedente):

Funzione che genera il primo successivo (primo) oppure il primo precedente (primo true):

(define (primo:primo dir)
  (local (found num)
    (setq found nil)
    (if (null? dir)
      (setq num (+ primo:val 1))
      (setq num (- primo:val 1))
    )
    (until found
      (if (primo:isprime? num)
          (setq primo:val num found true)
      )
      (if (null? dir)
        (++ num)
        (-- num)
      )
    )
    primo:val))

Proviamo il generatore:

(primo:start 2)
(primo)
;-> 3
(primo:start 13)
;-> 13
(primo:print-val)
;-> 13
(primo:isprime? 13)
;-> true
(primo)
;-> 17
(primo)
;-> 19
(primo)
;-> 23
(primo true)
;-> 19
(primo true)
;-> 17
(primo)
;-> 19

Adesso possiamo scrive la funzione soluzione:

(define (e123)
(catch
  (local (n p)
    (primo:start 1)
    (setq n 1)
    (while true
      (setq p (primo))
      (if (> (* 2 p n) 1e10)
          (throw n)
      )
      (primo)
      (++ n 2)
    )
  )))

(e123)
;-> 21035

(time (e123))
;-> 134.032
----------------------------------------------------------------------------


============
Problema 124
============

Radicali ordinati

Il radicale di n, rad(n), è il prodotto dei distinti fattori primi di n. Ad esempio, 504 = 2^3 × 3^2 × 7, quindi rad(504) = 2 × 3 × 7 = 42.

Se calcoliamo rad(n) per 1 ≤ n ≤ 10, quindi li ordiniamo su rad(n) e ordinando su n se i valori radicali sono uguali, otteniamo:

  Non ordinati    Ordinati
  n  rad(n)       n  rad(n)  k
  1    1          1    1     1
  2    2          2    2     2
  3    3          4    2     3
  4    2          8    2     4
  5    5          3    3     5
  6    6          9    3     6
  7    7          5    5     7
  8    2          6    6     8
  9    3          7    7     9
  10  10         10   10    10

Sia E(k) il k-esimo elemento nella colonna n ordinata. Ad esempio, E(4) = 8 e E(6) = 9.

Se rad(n) è ordinato per 1 ≤ n ≤ 100000, trovare E(10000).
============================================================================

Funzione che calcola il radicale di un numero intero positivo:

(define (rad n)
  (if (= n 1) 1
      (apply * (unique (factor n)))))

(sort (map (fn(x) (list (rad x) (+ $idx 1))) (sequence 1 10)))
;-> ((1 1) (2 2) (2 4) (2 8) (3 3) (3 9) (5 5) (6 6) (7 7) (10 10))

(define (e124)
  ((sort (map (fn(x) (list (rad x) (+ $idx 1))) (sequence 1 100000))) 9999 1))

(e124)
;-> 21417

(time (e124))
;-> 140.315
----------------------------------------------------------------------------


============
Problema 125
============

Somme palindrome

Il numero palindromo 595 è interessante perché può essere scritto come somma di quadrati consecutivi: 6^2 + 7^2 + 8^2 + 9^2 + 10^2 + 11^2 + 12^2.

Ci sono esattamente undici palindromi al di sotto di mille che possono essere scritti come somme consecutive di quadrati e la somma di questi palindromi è 4164. Si noti che 1 = 0^2 + 1^2 non è stato incluso poiché questo problema riguarda i quadrati di numeri interi positivi.

Trova la somma di tutti i numeri minori di 10^8 che sono entrambi palindromi e possono essere scritti come somma di quadrati consecutivi.
============================================================================

(define (palindrome? obj)
"Check if a list or a string or a number is palindrome"
  (let (str (string obj))
    (= str (reverse (copy str)))))

(palindrome? 1250521)
;-> true

(define (e125 n)
  (local (out primo-quad ultimo-quad somma-quad)
    (setq out '())
    (setq primo-quad 1)
    (setq somma-quad 5)
    (while (< somma-quad n)
      (setq ultimo-quad (+ primo-quad 1))
      (while (< somma-quad n)
        (if (palindrome? somma-quad)
            (push somma-quad out -1)
        )
        (++ ultimo-quad)
        (setq somma-quad (+ somma-quad (mul ultimo-quad ultimo-quad)))
      )
      (++ primo-quad)
      (setq somma-quad (+ (* primo-quad primo-quad) (* (+ primo-quad 1) (+ primo-quad 1))))
    )
    (apply + (unique out))))

(e125 1e8)
;-> 2906969179

(time (e125 1e8))
;-> 1569.753
----------------------------------------------------------------------------


============
Problema 135
============

Stesse differenze

Dati gli interi positivi, x, y e z, che sono termini consecutivi di una progressione aritmetica, il valore minimo dell'intero positivo, n, per il quale l'equazione, x^2 − y^2 − z^2 = n, ha esattamente due soluzioni è n = 27:

34^2 − 27^2 − 20^2 = 12^2 − 9^2 − 6^2 = 27

Si scopre che n = 1155 è il valore minimo che ha esattamente dieci soluzioni.

Quanti valori di n inferiori a un milione hanno esattamente dieci soluzioni distinte?
============================================================================

Ponendo x,y,z rispettivamente nella forma a+b, a, a-b, l'equazione data si riduce a a*(4*b-a) = n.

  x^2 − y^2 − z^2 = n (*)

Poniamo:

  y = a
  x = a + b
  z = a - b

e sostituendo nella equazione (*) otteniamo:

    (a+b)^2 - a^2 - (a-b)^2 =
  = a^2 + 2ab + b^2 - a^2 - a^2 + 2ab - b^2 =
  = 4ab - a^2 =
  = a(4b - a)

Tutte le variabili sono interi positivi, quindi deve risultare 1 <= a < n.
Calcoliamo il numero di soluzioni per ogni n fino a 1 milione fissando "a" e quindi considerando che "n" deve essere multiplo di "a".

(define (e135 n)
  (local (freq diff)
    (setq freq (array (+ n 1) '(0)))
    (for (primo 1 (- n 1))
      (for (k primo (- n 1) primo)
        (setq diff (+ primo (/ k primo)))
              ; diff deve essere divisibile per 4
        (cond ((!= (% diff 4) 0) nil)
              (true
                (setq diff (/ diff 4))
                ; se x,y,z sono interi positivi
                ; risulta z>0, a>d e 4d<a
                (if (and (> primo diff) (< primo (* diff 4)))
                    (++ (freq k))
                ))
        )
      )
    )
    (first (count '(10) (array-list freq)))))

(e135 1e6)
;-> 4989

(time (e135 1e6))
;-> 2873.557

Possiamo migliorare il tempo di esecuzione considerando che anche il valore tra parentesi (4b - a) deve essere positivo, quindi deve risultare ceil(a/4) <= b < a.

(define (e135-2 n)
  (local (freq stop val)
    (setq freq (array (+ n 1) '(0)))
    (for (a 1 (- n 1))
      (setq stop nil)
      (for (b (/ (+ a 3) 4) (- a 1) 1 stop)
        (setq val (* a (- (* 4 b) a)))
        (if (>= val n)
            (setq stop true)
            (++ (freq val))
        )
      )
    )
    (first (count '(10) (array-list freq)))))

(e135-2 1e6)
;-> 4989

(time (e135-2 1e6))
;-> 1194.103
----------------------------------------------------------------------------


============
Problema 145
============

Quanti numeri reversibili ci sono sotto il miliardo?

Alcuni interi positivi n hanno la proprietà che la somma [ n + reverse(n) ]
è composto interamente da cifre dispari (decimali).
Ad esempio, 36 + 63 = 99 e 409 + 904 = 1313.
Chiameremo tali numeri reversibili, quindi 36, 63, 409 e 904 sono reversibili.
Gli zeri iniziali non sono consentiti né in n né in reverse(n).

Ci sono 120 numeri reversibili sotto mille.

Quanti numeri reversibili ci sono sotto il miliardo (10^9)?
============================================================================

Soluzione forza bruta
---------------------
Scriviamo la funzione che verifica se le cifre di un numero intero sono tutte dispari:

(define (odd-digits? num)
(catch
  (local (digit)
    (while (> num 0)
      (setq digit (% num 10))
      (if (even? digit) (throw nil))
      (setq num (/ num 10))
    )
    true)))

(odd-digits? 13579)
;-> true
(odd-digits? 13572)
;-> nil

Scriviamo la funzione soluzione (forza bruta):

(define (e145 iter)
  (local (result num-sum)
    (setq result 0)
    ; I numeri a una cifra si invertono su se stessi,
    ; quindi le loro somme sono pari
    (for (num 11 iter)
      ; L'ultima cifra non può essere 0
      (cond ((zero? (% num 10)) nil)
            (true
              (setq num-sum (+ num (int (reverse (string num)))))
              (if (odd-digits? num-sum) (++ result)))
      )
    )
    result))

(e145 999)
;-> 120

Vediamo la sua velocità:

(time (println (e145 (- 1e6 1))))
;-> 18720
;-> 2017.743

Prima di calcolare la soluzione fino a 1e9 vediamo di ottimizzare il codice:
1) quando un numero num è reversibile, allora anche (reverse num) è reversibile (es. se 1638 è reversibile, allora anche 8361 è reversibile). Ciò significa che dobbiamo solo verificare i numeri dispari e quando troviamo un numero reversibile aggiungere 2 al risultato (uno per num e uno per (reverse num).
2) calcoliamo l'inverso di un numero in modo matematico.
3) inglobiamo la funzione "odd-digits?" nella funzione "reversible?".
4) non ci sono numeri reversibili tra 1e8 e 1e9 (dalla soluzione analitica).

(define (reversible? num)
(catch
  (local (numero inverso)
    (setq numero num)
    ; check 0 alla fine
    (if (zero? (% num 10)) (throw nil))
    ; inversione del numero
    (setq inverso 0)
    (while (> numero 0)
      (setq inverso (+ (* 10 inverso) (% numero 10)))
      (setq numero (/ numero 10))
    )
    ; numero somma
    (setq inverso (+ inverso num))
    ; check tutte cifre dispari
    (while (> inverso 0)
      (if (zero? (% (% inverso 10) 2)) (throw nil))
      (setq inverso (/ inverso 10))
    )
    true)))

(reversible? 63)
;-> true
(reversible? 409)
;-> true
(reversible? 999)
;-> nil

(define (e145 iter)
  (let (conta 0)
    (for (i 1 iter 2)
      (if (reversible? i) (++ conta 2))
    )
    conta))

(e145 999)
;-> 120

(time (println (e145 (- 1e6 1))))
;-> 18720
;-> 1316.35

Possiamo migliorare ancora un pò la velocità se scrivendo la funzione "reversible?" senza usare "catch":

(define (reversible? num)
  (local (numero inverso cont out)
    (setq numero num)
    (setq out true)
    ; check 0 alla fine
    (cond ((zero? (% num 10)) (setq out nil))
          (true
            ; inversione del numero
            (setq inverso 0)
            (while (> numero 0)
              (setq inverso (+ (* 10 inverso) (% numero 10)))
              (setq numero (/ numero 10))
            )
            ; numero somma
            (setq inverso (+ inverso num))
            ; check tutte cifre dispari
            (setq cont true)
            (while (and cont (> inverso 0))
              (if (zero? (% (% inverso 10) 2)) 
                  (set 'cont nil 'out nil))
              (setq inverso (/ inverso 10))
            ))
    )
    out))

(e145 999)
;-> 120

(time (println (e145 (- 1e6 1))))
;-> 18720
;-> 850.272

Proviamo a risolvere il problema fino a 1e8:

(time (println (e145 (- 1e8 1))))
;-> 608720
;-> 99501.769 ; quasi 100 secondi

Soluzione analitica
-------------------
Analizziamo i numeri in base al numero di cifre che lo compongono:

1 cifra
Qualsiasi numero di una cifra si aggiungerà a se stesso e finisce sempre per essere un numero pari. E quindi non ci sono soluzioni.

2 cifre
Se abbiamo due cifre a e b allora avremo una soluzione composta da due cifre con a+b. Entrambi devono essere dispari. Se a+b > 10 allora abbiamo un riporto e quindi la prima cifra del risultato avrà una parità diversa dalla seconda cifra. Pertanto possiamo solo formare soluzioni dove a+b < 10 e a+b è dispari. In tutto abbiamo 20 soluzioni (calcolate a mano)

3 cifre
Nel caso a tre cifre abbiamo ancora una volta che la cifra centrale deve essere aggiunta a se stessa. Ciò significa che la terza cifra deve avere un riporto ed essere dispari.
Poiché la terza cifra è dispari, anche la prima cifra è dispari se la seconda cifra non ha un riporto, cosa che accade quando la seconda cifra è inferiore a 5, il che ci dà 20 scelte per la prima/terza cifra impostata e 5 opzioni per il mezzo. Che totalizza 100 soluzioni.

4 cifre
Qui abbiamo due coppie, interna ed esterna. Se la coppia interna ha il riporto, anche la coppia esterna deve avere il riporto. Poiché altrimenti le due coppie interne avranno parità diversa. Tuttavia, se la coppia interna ha un riporto, la coppia esterna avrà una parità diversa poiché la prima cifra finirà con un riporto che l'ultima cifra non otterrà. Pertanto abbiamo soluzioni solo quando nessuna delle coppie ha il riporto.
Per la coppia esterna questo ci dà le 20 scelte che abbiamo visto nel caso a due cifre. E ci dà 30 casi per la coppia interna, poiché possono anche contenere uno zero.
In totale otteniamo 20*30 = 600 soluzioni
 
5 cifre
Qui abbiamo la cifra centrale, la coppia interna e la coppia esterna.
La cifra centrale si aggiunge a se stessa, il che significa che la coppia interna deve avere un riporto. Quando la coppia interna ha un riporto, significa che la coppia esterna avrà una parità diversa. E quindi non ci sono soluzioni.

6 cifre
Possiamo fare lo stesso discorso del caso a 4 cifre, ma con una coppia in più. Quindi se abbiamo la coppia interna, centrale ed esterna. Possiamo vedere che se la coppia interna ha un riporto, anche la coppia centrale deve avere un riporto e questo porta la coppia esterna ad avere una parità diversa. Ciò significa che nessuna delle coppie può avere un riporto.
Quindi abbiamo che la coppia interna e quella centrale hanno 30 opzioni ciascuna e la coppia esterna ha 20 opzioni. Quindi in totale 20*30^2 = 18.000 soluzioni.

7 cifre
In questo caso abbiamo la cifra centrale, la coppia interna, la coppia centrale e la coppia esterna.
La cifra centrale ha bisogno di un riporto, poiché si aggiunge a se stessa. Ciò significa che la coppia interna deve avere un riporto.
Questo a sua volta significa che ci sarà un riporto alla coppia centrale dalla coppia interna che dovrà essere pari da sola. Il che a sua volta ci porta a concludere che la coppia esterna deve avere un riporto. Inoltre, la coppia centrale non può avere un riporto poiché ciò porterebbe la coppia esterna ad avere una parità diversa.
Quindi la coppia esterna deve avere un riporto ed essere dispari e non includere 0. Questo dà 20 opzioni.
La coppia centrale deve essere pari e non avere un riporto. Questo ci dà 25 opzioni.
La coppia interna deve essere dispari e avere un riporto. Questo ci dà 20 opzioni.
La cifra centrale non deve avere un riporto in modo che ci dia 5 opzioni.
Quindi questo è un totale di 20*25*20*5 = 50.000 soluzioni

8 cifre
Possiamo portare lo stesso argomento del caso a 6 cifre e il risultato vale
20*30^3 = 540.000 soluzioni

9 cifre
Abbiamo quattro coppie e una cifra centrale. Le coppie sono 1,2,3,4.
La cifra centrale deve come sempre avere un riporto, quindi la coppia 4 deve avere un riporto.
Se la coppia 4 ha un riporto, consegnerà un riporto alla coppia 3 e quindi, anche la coppia 2 deve fornire un riporto alla coppia 3.
Se la coppia 2 ha un riporto, la coppia uno riceverà un riporto, il che significa che finirà con parità diverse. Quindi possiamo concludere che non ci sono soluzioni in questo caso.

A questo punto possiamo ottenere la risposta semplicemente aggiungendo possibili soluzioni per le cifre (1-9).

Ma possiamo anche vedere che esistono degli schemi (pattern). Per esempio:

1) se n è pari, allora possibili numeri reversibili di n cifre = 20 * 30 ^ (n/2 - 1)
2) ora se n % 4 = 1, allora possibili numeri reversibili di n cifre = 20 x 20 * (20 * 25) ^ (n/4 - 1)
3) e per n % 4 = 3, allora possibili numeri reversibili di n cifre = 0

Scriviamo la funzione finale:

(define (e145-2)
  (let (conta 0)
    (for (i 2 9)
      (cond ((zero? (% i 2))
              (setq conta (+ conta (* 20 (pow 30 (- (/ i 2) 1))))))
            ((= 1 (% i 4))
              (setq conta (+ conta (* 100 (pow 500 (- (/ i 4) 1))))))
      )
    )
    conta))

(e145-2)
;-> 608720

(time (e145-2))
;-> 0
----------------------------------------------------------------------------


============
Problema 173
============

Utilizzando fino a un milione di tessere quante diverse lamine quadrate "bucate" si possono formare?

Definiremo una lamina quadrata come un contorno quadrato con un "buco" quadrato in modo che la forma possieda una simmetria verticale e orizzontale. Ad esempio, utilizzando esattamente trentadue tessere quadrate possiamo formare due diverse lamine quadrate:

******           *********
******           *       *
**  **           *       *
**  **           *       *
******           *       *
******           *       *
                 *       *
                 *       *
                 *       *
                 *********

Con cento tessere, e non necessariamente utilizzando tutte le tessere contemporaneamente, è possibile formare quarantuno lamine quadrate diverse.

Utilizzando fino a un milione di tessere quante diverse lamine quadrate si possono formare?
============================================================================

(define (e173 limite)
  (local (out bordo buco)
    (setq out 0)
    (setq bordo 3)
    (while (< bordo (+ (/ limite 4) 2))
      (if (> (* bordo bordo) limite)
          (setq buco (max (ceil (sqrt (- (* bordo bordo) limite))) 1))
          (setq buco 1)
      )
      (if (odd? (- bordo buco)) (++ buco))
      (setq out (+ out (/ (- bordo buco 2) 2) 1))
      (++ bordo)
    )
    out))

(e173 100)
;-> 41
(e173 1e6)
;-> 1572729

(time (e173 1e6))
;-> 123.697

(define (e173-2 limite)
(local (out tessere lato)
  (setq out 0)
  (setq tessere (/ limite 4))
  (setq lato (int (sqrt tessere)))
  (for (i 1 lato)
    (setq out (+ out (- (/ tessere i) i)))
  )
  out))

(e173-2 100)
;-> 41

(e173-2 1e6)
;-> 1572729

(time (e173-2 1e6))
;-> 0
----------------------------------------------------------------------------


============
Problema 188
============

L'iperesponenziazione di un numero

L'iperesponenziazione o tetrazione di un numero a per un intero positivo b, denotato da a↑↑b o (b)^a, è definita ricorsivamente da:

  a↑↑1 = a,
  a↑↑(k+1) = a(a↑↑k).

Quindi abbiamo ad es. 3↑↑2 = 3^3 = 27, quindi 3↑↑3 = 3^27 = 7625597484987 e 3↑↑4 è circa 10^3,6383346400240996*10^12.

Trova le ultime 8 cifre di 1777↑↑1855.
============================================================================

(define (powmod base expt modulo)
"Calculates (base^exponent % modulo)"
  (let (out 1L)
    (while (> expt 0)
      (if (odd? expt)
          (setq out (% (* out base) modulo)))
      (setq base (% (* base base) modulo))
      (setq expt (/ expt 2)))
    out))

(powmod 15 65535 6)
;-> 3L

(define (e188)
  (let ((base 1777) (hyper 1855) (digit 8) (out 0))
    (setq out base)
    ; calcola base↑↑hyper mediante esponenziazione modulare ripetuta
    ; (associativa a destra)
    (for (i 1 (- hyper 1))
      (setq out (powmod base out (pow 10 digit)))
    )
    out))

(e188)
;-> 95962097L

(time (e188))
;-> 29.751
----------------------------------------------------------------------------


============
Problema 191
============

Stringhe premiate

Una scuola particolare offre premi in denaro ai bambini con buona frequenza e puntualità. Se sono assenti per tre giorni consecutivi o in ritardo per più di un'occasione, perdono il premio.

Durante un periodo di n giorni si forma una stringa ternaria per ogni bambino composta da L (in ritardo), O (in orario) e A (assente).

Sebbene ci siano ottantuno stringhe trinarie per un periodo di 4 giorni che possono essere formate, esattamente quarantatre stringhe porterebbero a un premio:

   OOOO OOOA OOOL OOAO OOAA OOAL OOLO OOLA OAOO OAOA
   OAOL OAAO OAAL OALO OALA OLOO OLOA OLAO OLAA AOOO
   AOOA AOOL AOAO AOAA AOAL AOLO AOLA AAOO AAOA AAOL
   AALO AALA ALOO ALOA ALAO ALAA LOOO LOOA LOAO LOAA
   LAOO LAOA LAAO

Quante stringhe di "premio" esistono in un periodo di 30 giorni?
============================================================================

Usiamo una funzione ricorsiva che deve essere chiamata con il numero di giorni (corrispondente alla durata del "premio" desiderata), i valori iniziali per il numero di giorni di assenza consecutivi e il numero di giorni di ritardo totali.
Questa funzione genera una situazione del giorno che permette di calcolare in numero di stringhe premiate fino a quel punto (che viene memorizzata in una hash-map).

(define (calc days absent late)
(catch
  (local (key event-late event-absent event-ontime prizes)
    ; se assenti due volte, o in ritardo per 3 giorni consecutivi,
    ; allora non sono possibili ulteriori stringhe da premiare
    (if (or (= late 3) (= absent 2)) (throw 0))
    ; se non abbiamo più giorni e non abbiamo fallito le altre regole
    ; allora abbiamo una stringa da premiare
    (if (= days 0) (throw 1))
    ; calcolo ricorsivo,
    ; se la combinazione è già nella hash-map,
    ; allora restituisce il valore memorizzato poiché conosciamo
    ; il numero di possibili stringhe da premiare da adesso in poi
    (setq key (string days "-" absent "-" late))
    (if (!= (h key) nil) (throw (h key)))
    ; Adesso calcoliamo i tre possibili modi che possono crearsi
    ; questo punto in poi, a seconda della nostra presenza odierna
    ; 1) se siamo in ritardo (ma non assenti),
    ;    allora il contatore "assenti" resta invariato e
    ;    il contatore di "ritardo" aumenta di uno
    (setq event-late   (calc (- days 1) absent (+ late 1)))
    ; 2) se siamo assenti,
    ;    allora il contatore "assenti" aumenta di 1 e
    ;    il contatore "ritardo" si azzera
    (setq event-absent (calc (- days 1) (+ absent 1) 0))
    ; 3) se siamo puntuali,
    ;    allora azzera il contatore di "ritardo" e
    ;    mantiene il contatore di "assenti"
    (setq event-ontime (calc (- days 1) absent 0))
    ; calcola il numero delle stringhe premiate
    (setq prizes (+ event-late event-absent event-ontime))
    ; inserisce il valore nella hash-map
    (h key prizes)
    prizes)))

(define (e191)
  (new Tree 'h)
  (println (calc 30 0 0))
  (delete 'h))

(e191)
;-> 1918080160

(time (e191))
;-> 0.969

Una interessante e dettagliata soluzione per induzione (scritta in python) si trova al seguente indirizzo:

https://jsomers.net/blog/project-euler-problem-191-or-how-i-learned-to-stop-counting-and-love-induction

Riportiamo l'implementazione in newLISP:

(define (e191)
  (setq lst '(1 3 0 2 1 0 0 1))
  (setq val '(n t a b c d e f))
  (while (< (lst 0) 30)
    (map set val lst)
    (setq lst (list (+ n 1)
                    (+ (* 2 t) b (- a))
                    c
                    (+ (* 2 b) d (- a))
                    (- t (+ a c))
                    e
                    f
                    t))
  )
  (lst 1))

(e191)
;-> 1918080160

(time (e191))
;-> 0
----------------------------------------------------------------------------


============
Problema 206
============

Quadrato nascosto

Trova l'intero positivo univoco il cui quadrato ha la forma 1_2_3_4_5_6_7_8_9_0, dove ogni "_" è una singola cifra.
============================================================================

Proviamo ad applicare la forza-bruta (ciclo) e calcoliamo i limiti minimo e massimo del numero cercato:

Valore minimo quando "_" vale "0":  1020304050607080900
(sqrt 1020304050607080900)
;-> 1010101010.10101

Valore massimo quando "_" vale "9": 1929394959697989990
(sqrt 1929394959697989990)
;-> 1389026623.106264

I limiti del numero cercato valgono: (x > 1010101010) e (x < 1389026623).

Poichè l'ultima cifra del quadrato vale 0, allora anche la sua radice quadrata deve avere l'ultima cifra uguale a "0". Quindi il ciclo può avanzare di 10 per ogni step.

I limiti del numero cercato valgono: (x > 1010101010) e (x < 1389026630).

Controlliamo che non abbiamo bisogno dei big integer:

(setq INT-MAX 9223372036854775807)
(length INT-MAX)
;-> 19
(- INT-MAX 1020304050607080900)
;-> 8203067986247694907
(- INT-MAX 1929394959697989990)
;-> 7293977077156785817

Scriviamo la funzione finale:

(define (e206 tipo)
(catch
  (local (start end step num)
    (if (= tipo -1)
      ; ciclo all'indietro
      (set 'start 1389026630
           'end 1010101010
           'step -10)
      ;else
      ; ciclo in avanti
      (set 'start 1010101010
           'end 1389026630
           'step 10)
    )
    ; ciclo brute-force
    (for (i start end step)
      ; quadrato
      (setq num (string (* i i)))
      ; check quadrato
      (if (and (= (num 0) "1")
              (= (num 2) "2")
              (= (num 4) "3")
              (= (num 6) "4")
              (= (num 8) "5")
              (= (num 10) "6")
              (= (num 12) "7")
              (= (num 14) "8")
              (= (num 16) "9")
              (= (num 18) "0"))
           (begin
            (println i { - } num)
            (throw (list i num))))))))

(time (e206 -1))
;-> 1389019170 - 1929374254627488900
;-> 1.966

(time (e206 +1))
;-> 1389019170 - 1929374254627488900
;-> 35973.2

(define (e206-2 tipo)
(catch
  (local (start end step num)
    (if (= tipo -1)
      ; ciclo all'indietro
      (set 'start 138902663
           'end 101010101
           'step -1)
      ;else
      ; ciclo in avanti
      (set 'start 101010101
           'end 138902663
           'step 1)
    )
    ; ciclo brute-force
    (for (i start end step)
      ; quadrato
      (setq num (string (* i i)))
      ; check quadrato
      (if (and (= (num 0) "1")
              (= (num 2) "2")
              (= (num 4) "3")
              (= (num 6) "4")
              (= (num 8) "5")
              (= (num 10) "6")
              (= (num 12) "7")
              (= (num 14) "8")
              (= (num 16) "9"))
              ;(= (num 18) "0"))
           (begin
            (println i { - } num)
            (throw (list i num))))))))

(time (e206-2 -1))
;-> 1389019170 - 1929374254627488900
;-> 1.658

(time (e206-2 +1))
;-> 1389019170 - 1929374254627488900
;-> 34304.343
----------------------------------------------------------------------------

=============================================================================

